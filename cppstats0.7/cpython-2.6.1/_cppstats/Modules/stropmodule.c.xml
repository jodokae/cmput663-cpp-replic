<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="Modules/stropmodule.c"><cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PY_SSIZE_T_CLEAN</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>strop_module__doc__</name></expr></argument>,
<argument><expr>"Common string manipulations, optimized for speed.\n"
"\n"
"Always use \"import string\" rather than referencing\n"
"this module directly."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WARN</name></cpp:macro> <cpp:value>if (PyErr_Warn(PyExc_DeprecationWarning, "strop functions are obsolete; use string methods")) return NULL</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LEFTSTRIP</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RIGHTSTRIP</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BOTHSTRIP</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>split_whitespace</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>s</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>maxsplit</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name> <init>= <expr>0</expr></init>, <name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>countsplit</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name>*</type> <name>item</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>list</name> <init>= <expr><call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>list</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<while>while <condition>(<expr><name>i</name> &lt; <name>len</name></expr>)</condition> <block>{
<while>while <condition>(<expr><name>i</name> &lt; <name>len</name> &amp;&amp; <call><name>isspace</name><argument_list>(<argument><expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<expr_stmt><expr><name>i</name> = <name>i</name>+1</expr>;</expr_stmt>
}</block></while>
<expr_stmt><expr><name>j</name> = <name>i</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>i</name> &lt; <name>len</name> &amp;&amp; !<call><name>isspace</name><argument_list>(<argument><expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<expr_stmt><expr><name>i</name> = <name>i</name>+1</expr>;</expr_stmt>
}</block></while>
<if>if <condition>(<expr><name>j</name> &lt; <name>i</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>item</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>s</name>+<name>j</name></expr></argument>, <argument><expr><name>i</name>-<name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>item</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>finally</name>;</goto></then></if>
<expr_stmt><expr><name>err</name> = <call><name>PyList_Append</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>err</name> &lt; 0</expr>)</condition><then>
<goto>goto <name>finally</name>;</goto></then></if>
<expr_stmt><expr><name>countsplit</name>++</expr>;</expr_stmt>
<while>while <condition>(<expr><name>i</name> &lt; <name>len</name> &amp;&amp; <call><name>isspace</name><argument_list>(<argument><expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<expr_stmt><expr><name>i</name> = <name>i</name>+1</expr>;</expr_stmt>
}</block></while>
<if>if <condition>(<expr><name>maxsplit</name> &amp;&amp; (<name>countsplit</name> &gt;= <name>maxsplit</name>) &amp;&amp; <name>i</name> &lt; <name>len</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>item</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(
<argument><expr><name>s</name>+<name>i</name></expr></argument>, <argument><expr><name>len</name> - <name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>item</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>finally</name>;</goto></then></if>
<expr_stmt><expr><name>err</name> = <call><name>PyList_Append</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>err</name> &lt; 0</expr>)</condition><then>
<goto>goto <name>finally</name>;</goto></then></if>
<expr_stmt><expr><name>i</name> = <name>len</name></expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
}</block></while>
<return>return <expr><name>list</name></expr>;</return>
<label><name>finally</name>:</label>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>splitfields__doc__</name></expr></argument>,
<argument><expr>"split(s [,sep [,maxsplit]]) -&gt; list of strings\n"
"splitfields(s [,sep [,maxsplit]]) -&gt; list of strings\n"
"\n"
"Return a list of the words in the string s, using sep as the\n"
"delimiter string. If maxsplit is nonzero, splits into at most\n"
"maxsplit words. If sep is not specified, any whitespace string\n"
"is a separator. Maxsplit defaults to 0.\n"
"\n"
"(split and splitfields are synonymous)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>strop_splitfields</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>n</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>err</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>splitcount</name></decl>, <decl><type ref="prev"/><name>maxsplit</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>s</name></decl>, *<decl><type ref="prev"/><name>sub</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>list</name></decl>, *<decl><type ref="prev"/><name>item</name></decl>;</decl_stmt>
<expr_stmt><expr><name>WARN</name></expr>;</expr_stmt>
<expr_stmt><expr><name>sub</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>splitcount</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>maxsplit</name> = 0</expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"t#|z#n:split"</expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr>&amp;<name>sub</name></expr></argument>, <argument><expr>&amp;<name>n</name></expr></argument>, <argument><expr>&amp;<name>maxsplit</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>sub</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><call><name>split_whitespace</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>maxsplit</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><name>n</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"empty separator"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>list</name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>list</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>i</name> = <name>j</name> = 0</expr>;</expr_stmt>
<while>while <condition>(<expr><name>i</name>+<name>n</name> &lt;= <name>len</name></expr>)</condition> <block>{
<if>if <condition>(<expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> == <name><name>sub</name><index>[<expr>0</expr>]</index></name> &amp;&amp; (<name>n</name> == 1 || <call><name>memcmp</name><argument_list>(<argument><expr><name>s</name>+<name>i</name></expr></argument>, <argument><expr><name>sub</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call> == 0)</expr>)</condition><then> <block>{
<expr_stmt><expr><name>item</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>s</name>+<name>j</name></expr></argument>, <argument><expr><name>i</name>-<name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>item</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>fail</name>;</goto></then></if>
<expr_stmt><expr><name>err</name> = <call><name>PyList_Append</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>err</name> &lt; 0</expr>)</condition><then>
<goto>goto <name>fail</name>;</goto></then></if>
<expr_stmt><expr><name>i</name> = <name>j</name> = <name>i</name> + <name>n</name></expr>;</expr_stmt>
<expr_stmt><expr><name>splitcount</name>++</expr>;</expr_stmt>
<if>if <condition>(<expr><name>maxsplit</name> &amp;&amp; (<name>splitcount</name> &gt;= <name>maxsplit</name>)</expr>)</condition><then>
<break>break;</break></then></if>
}</block></then> <else>else
<expr_stmt><expr><name>i</name>++</expr>;</expr_stmt></else></if>
}</block></while>
<expr_stmt><expr><name>item</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>s</name>+<name>j</name></expr></argument>, <argument><expr><name>len</name>-<name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>item</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>fail</name>;</goto></then></if>
<expr_stmt><expr><name>err</name> = <call><name>PyList_Append</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>err</name> &lt; 0</expr>)</condition><then>
<goto>goto <name>fail</name>;</goto></then></if>
<return>return <expr><name>list</name></expr>;</return>
<label><name>fail</name>:</label>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>joinfields__doc__</name></expr></argument>,
<argument><expr>"join(list [,sep]) -&gt; string\n"
"joinfields(list [,sep]) -&gt; string\n"
"\n"
"Return a string composed of the words in list, with\n"
"intervening occurrences of sep. Sep defaults to a single\n"
"space.\n"
"\n"
"(join and joinfields are synonymous)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>strop_joinfields</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>seq</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>sep</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>seqlen</name></decl>, <decl><type ref="prev"/><name>seplen</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>reslen</name> <init>= <expr>0</expr></init>, <name>slen</name> <init>= <expr>0</expr></init>, <name>sz</name> <init>= <expr>100</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>*</type> <name>p</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ssizeargfunc</name></type> <name>getitemfunc</name></decl>;</decl_stmt>
<expr_stmt><expr><name>WARN</name></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O|t#:join"</expr></argument>, <argument><expr>&amp;<name>seq</name></expr></argument>, <argument><expr>&amp;<name>sep</name></expr></argument>, <argument><expr>&amp;<name>seplen</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>sep</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>sep</name> = " "</expr>;</expr_stmt>
<expr_stmt><expr><name>seplen</name> = 1</expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>seqlen</name> = <call><name>PySequence_Size</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>seqlen</name> &lt; 0 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>seqlen</name> == 1</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>item</name> <init>= <expr><call><name>PySequence_GetItem</name><argument_list>(<argument><expr><name>seq</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>item</name> &amp;&amp; !<call><name>PyString_Check</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"first argument must be sequence of strings"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><name>item</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>!(<name>res</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr>(<name>char</name>*)<name>NULL</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>p</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyList_Check</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>seqlen</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>item</name> <init>= <expr><call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>seq</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyString_Check</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"first argument must be sequence of strings"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>slen</name> = <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>slen</name> &gt; <name>PY_SSIZE_T_MAX</name> - <name>reslen</name> ||
<name>seplen</name> &gt; <name>PY_SSIZE_T_MAX</name> - <name>reslen</name> - <name>seplen</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
<argument><expr>"input too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<while>while <condition>(<expr><name>reslen</name> + <name>slen</name> + <name>seplen</name> &gt;= <name>sz</name></expr>)</condition> <block>{
<if>if <condition>(<expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>res</name></expr></argument>, <argument><expr><name>sz</name> * 2</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>sz</name> *= 2</expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> + <name>reslen</name></expr>;</expr_stmt>
}</block></while>
<if>if <condition>(<expr><name>i</name> &gt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>, <argument><expr><name>seplen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> += <name>seplen</name></expr>;</expr_stmt>
<expr_stmt><expr><name>reslen</name> += <name>seplen</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>slen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> += <name>slen</name></expr>;</expr_stmt>
<expr_stmt><expr><name>reslen</name> += <name>slen</name></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>res</name></expr></argument>, <argument><expr><name>reslen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name><name>seq</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_sequence</name></name> == <name>NULL</name> ||
(<name>getitemfunc</name> = <name><name>seq</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_sequence</name>-&gt;<name>sq_item</name></name>) == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"first argument must be a sequence"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>seqlen</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>item</name> <init>= <expr><call><name>getitemfunc</name><argument_list>(<argument><expr><name>seq</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>item</name> || !<call><name>PyString_Check</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"first argument must be sequence of strings"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>slen</name> = <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>slen</name> &gt; <name>PY_SSIZE_T_MAX</name> - <name>reslen</name> ||
<name>seplen</name> &gt; <name>PY_SSIZE_T_MAX</name> - <name>reslen</name> - <name>seplen</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
<argument><expr>"input too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<while>while <condition>(<expr><name>reslen</name> + <name>slen</name> + <name>seplen</name> &gt;= <name>sz</name></expr>)</condition> <block>{
<if>if <condition>(<expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>res</name></expr></argument>, <argument><expr><name>sz</name> * 2</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>sz</name> *= 2</expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> + <name>reslen</name></expr>;</expr_stmt>
}</block></while>
<if>if <condition>(<expr><name>i</name> &gt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>, <argument><expr><name>seplen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> += <name>seplen</name></expr>;</expr_stmt>
<expr_stmt><expr><name>reslen</name> += <name>seplen</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>slen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> += <name>slen</name></expr>;</expr_stmt>
<expr_stmt><expr><name>reslen</name> += <name>slen</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>res</name></expr></argument>, <argument><expr><name>reslen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>find__doc__</name></expr></argument>,
<argument><expr>"find(s, sub [,start [,end]]) -&gt; in\n"
"\n"
"Return the lowest index in s where substring sub is found,\n"
"such that sub is contained within s[start,end]. Optional\n"
"arguments start and end are interpreted as in slice notation.\n"
"\n"
"Return -1 on failure."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>strop_find</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>s</name></decl>, *<decl><type ref="prev"/><name>sub</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>n</name></decl>, <decl><type ref="prev"/><name>i</name> <init>= <expr>0</expr></init>, <name>last</name> <init>= <expr><name>PY_SSIZE_T_MAX</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>WARN</name></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"t#t#|nn:find"</expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr>&amp;<name>sub</name></expr></argument>, <argument><expr>&amp;<name>n</name></expr></argument>, <argument><expr>&amp;<name>i</name></expr></argument>, <argument><expr>&amp;<name>last</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>last</name> &gt; <name>len</name></expr>)</condition><then>
<expr_stmt><expr><name>last</name> = <name>len</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>last</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>last</name> += <name>len</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>last</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>last</name> = 0</expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>i</name> += <name>len</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>i</name> = 0</expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>n</name> == 0 &amp;&amp; <name>i</name> &lt;= <name>last</name></expr>)</condition><then>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name>i</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>last</name> -= <name>n</name></expr>;</expr_stmt>
<for>for (<init>;</init> <condition><expr><name>i</name> &lt;= <name>last</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>)
<if>if <condition>(<expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> == <name><name>sub</name><index>[<expr>0</expr>]</index></name> &amp;&amp;
(<name>n</name> == 1 || <call><name>memcmp</name><argument_list>(<argument><expr>&amp;<name><name>s</name><index>[<expr><name>i</name>+1</expr>]</index></name></expr></argument>, <argument><expr>&amp;<name><name>sub</name><index>[<expr>1</expr>]</index></name></expr></argument>, <argument><expr><name>n</name>-1</expr></argument>)</argument_list></call> == 0)</expr>)</condition><then>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name>i</name></expr></argument>)</argument_list></call></expr>;</return></then></if></for>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>-1L</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>rfind__doc__</name></expr></argument>,
<argument><expr>"rfind(s, sub [,start [,end]]) -&gt; int\n"
"\n"
"Return the highest index in s where substring sub is found,\n"
"such that sub is contained within s[start,end]. Optional\n"
"arguments start and end are interpreted as in slice notation.\n"
"\n"
"Return -1 on failure."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>strop_rfind</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>s</name></decl>, *<decl><type ref="prev"/><name>sub</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>n</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name> <init>= <expr>0</expr></init>, <name>last</name> <init>= <expr><name>PY_SSIZE_T_MAX</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>WARN</name></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"t#t#|nn:rfind"</expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr>&amp;<name>sub</name></expr></argument>, <argument><expr>&amp;<name>n</name></expr></argument>, <argument><expr>&amp;<name>i</name></expr></argument>, <argument><expr>&amp;<name>last</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>last</name> &gt; <name>len</name></expr>)</condition><then>
<expr_stmt><expr><name>last</name> = <name>len</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>last</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>last</name> += <name>len</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>last</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>last</name> = 0</expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>i</name> += <name>len</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>i</name> = 0</expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>n</name> == 0 &amp;&amp; <name>i</name> &lt;= <name>last</name></expr>)</condition><then>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name>last</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<for>for (<init><expr><name>j</name> = <name>last</name>-<name>n</name></expr>;</init> <condition><expr><name>j</name> &gt;= <name>i</name></expr>;</condition> <incr><expr>--<name>j</name></expr></incr>)
<if>if <condition>(<expr><name><name>s</name><index>[<expr><name>j</name></expr>]</index></name> == <name><name>sub</name><index>[<expr>0</expr>]</index></name> &amp;&amp;
(<name>n</name> == 1 || <call><name>memcmp</name><argument_list>(<argument><expr>&amp;<name><name>s</name><index>[<expr><name>j</name>+1</expr>]</index></name></expr></argument>, <argument><expr>&amp;<name><name>sub</name><index>[<expr>1</expr>]</index></name></expr></argument>, <argument><expr><name>n</name>-1</expr></argument>)</argument_list></call> == 0)</expr>)</condition><then>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name>j</name></expr></argument>)</argument_list></call></expr>;</return></then></if></for>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>-1L</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>do_strip</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>int</name></type> <name>striptype</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyString_AsStringAndSize</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>i</name> = 0</expr>;</expr_stmt>
<if>if <condition>(<expr><name>striptype</name> != <name>RIGHTSTRIP</name></expr>)</condition><then> <block>{
<while>while <condition>(<expr><name>i</name> &lt; <name>len</name> &amp;&amp; <call><name>isspace</name><argument_list>(<argument><expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
}</block></while>
}</block></then></if>
<expr_stmt><expr><name>j</name> = <name>len</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>striptype</name> != <name>LEFTSTRIP</name></expr>)</condition><then> <block>{
<do>do <block>{
<expr_stmt><expr><name>j</name>--</expr>;</expr_stmt>
}</block> while <condition>(<expr><name>j</name> &gt;= <name>i</name> &amp;&amp; <call><name>isspace</name><argument_list>(<argument><expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr><name><name>s</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>;</do>
<expr_stmt><expr><name>j</name>++</expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>i</name> == 0 &amp;&amp; <name>j</name> == <name>len</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>args</name></expr>;</return>
}</block></then> <else>else
<return>return <expr><call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>s</name>+<name>i</name></expr></argument>, <argument><expr><name>j</name>-<name>i</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>strip__doc__</name></expr></argument>,
<argument><expr>"strip(s) -&gt; string\n"
"\n"
"Return a copy of the string s with leading and trailing\n"
"whitespace removed."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>strop_strip</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>WARN</name></expr>;</expr_stmt>
<return>return <expr><call><name>do_strip</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>BOTHSTRIP</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>lstrip__doc__</name></expr></argument>,
<argument><expr>"lstrip(s) -&gt; string\n"
"\n"
"Return a copy of the string s with leading whitespace removed."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>strop_lstrip</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>WARN</name></expr>;</expr_stmt>
<return>return <expr><call><name>do_strip</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>LEFTSTRIP</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>rstrip__doc__</name></expr></argument>,
<argument><expr>"rstrip(s) -&gt; string\n"
"\n"
"Return a copy of the string s with trailing whitespace removed."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>strop_rstrip</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>WARN</name></expr>;</expr_stmt>
<return>return <expr><call><name>do_strip</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>RIGHTSTRIP</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>lower__doc__</name></expr></argument>,
<argument><expr>"lower(s) -&gt; string\n"
"\n"
"Return a copy of the string s converted to lowercase."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>strop_lower</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>s</name></decl>, *<decl><type ref="prev"/><name>s_new</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>newstr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>changed</name></decl>;</decl_stmt>
<expr_stmt><expr><name>WARN</name></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyString_AsStringAndSize</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>, <argument><expr>&amp;<name>n</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>newstr</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>newstr</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>s_new</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><name>newstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>changed</name> = 0</expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>s</name>++</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>isupper</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>changed</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr>*<name>s_new</name> = <call><name>tolower</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else
<expr_stmt><expr>*<name>s_new</name> = <name>c</name></expr>;</expr_stmt></else></if>
<expr_stmt><expr><name>s_new</name>++</expr>;</expr_stmt>
}</block></for>
<if>if <condition>(<expr>!<name>changed</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>newstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>args</name></expr>;</return>
}</block></then></if>
<return>return <expr><name>newstr</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>upper__doc__</name></expr></argument>,
<argument><expr>"upper(s) -&gt; string\n"
"\n"
"Return a copy of the string s converted to uppercase."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>strop_upper</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>s</name></decl>, *<decl><type ref="prev"/><name>s_new</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>newstr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>changed</name></decl>;</decl_stmt>
<expr_stmt><expr><name>WARN</name></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyString_AsStringAndSize</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>, <argument><expr>&amp;<name>n</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>newstr</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>newstr</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>s_new</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><name>newstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>changed</name> = 0</expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>s</name>++</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>islower</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>changed</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr>*<name>s_new</name> = <call><name>toupper</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else
<expr_stmt><expr>*<name>s_new</name> = <name>c</name></expr>;</expr_stmt></else></if>
<expr_stmt><expr><name>s_new</name>++</expr>;</expr_stmt>
}</block></for>
<if>if <condition>(<expr>!<name>changed</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>newstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>args</name></expr>;</return>
}</block></then></if>
<return>return <expr><name>newstr</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>capitalize__doc__</name></expr></argument>,
<argument><expr>"capitalize(s) -&gt; string\n"
"\n"
"Return a copy of the string s with only its first character\n"
"capitalized."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>strop_capitalize</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>s</name></decl>, *<decl><type ref="prev"/><name>s_new</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>newstr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>changed</name></decl>;</decl_stmt>
<expr_stmt><expr><name>WARN</name></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyString_AsStringAndSize</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>, <argument><expr>&amp;<name>n</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>newstr</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>newstr</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>s_new</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><name>newstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>changed</name> = 0</expr>;</expr_stmt>
<if>if <condition>(<expr>0 &lt; <name>n</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>s</name>++</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>islower</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>changed</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr>*<name>s_new</name> = <call><name>toupper</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else
<expr_stmt><expr>*<name>s_new</name> = <name>c</name></expr>;</expr_stmt></else></if>
<expr_stmt><expr><name>s_new</name>++</expr>;</expr_stmt>
}</block></then></if>
<for>for (<init><expr><name>i</name> = 1</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>s</name>++</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>isupper</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>changed</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr>*<name>s_new</name> = <call><name>tolower</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else
<expr_stmt><expr>*<name>s_new</name> = <name>c</name></expr>;</expr_stmt></else></if>
<expr_stmt><expr><name>s_new</name>++</expr>;</expr_stmt>
}</block></for>
<if>if <condition>(<expr>!<name>changed</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>newstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>args</name></expr>;</return>
}</block></then></if>
<return>return <expr><name>newstr</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>expandtabs__doc__</name></expr></argument>,
<argument><expr>"expandtabs(string, [tabsize]) -&gt; string\n"
"\n"
"Expand tabs in a string, i.e. replace them by one or more spaces,\n"
"depending on the current column and the given tab size (default 8).\n"
"The column number is reset to zero after each newline occurring in the\n"
"string. This doesn't understand other non-printing characters."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>strop_expandtabs</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name>*</type> <name>e</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>*</type> <name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>*</type> <name>q</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>old_j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name>*</type> <name>out</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>*</type> <name>string</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>stringlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tabsize</name> <init>= <expr>8</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>WARN</name></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s#|i:expandtabs"</expr></argument>, <argument><expr>&amp;<name>string</name></expr></argument>, <argument><expr>&amp;<name>stringlen</name></expr></argument>, <argument><expr>&amp;<name>tabsize</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>tabsize</name> &lt; 1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"tabsize must be at least 1"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>i</name> = <name>j</name> = <name>old_j</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>e</name> = <name>string</name> + <name>stringlen</name></expr>;</expr_stmt>
<for>for (<init><expr><name>p</name> = <name>string</name></expr>;</init> <condition><expr><name>p</name> &lt; <name>e</name></expr>;</condition> <incr><expr><name>p</name>++</expr></incr>) <block>{
<if>if <condition>(<expr>*<name>p</name> == '\t'</expr>)</condition><then> <block>{
<expr_stmt><expr><name>j</name> += <name>tabsize</name> - (<name>j</name>%<name>tabsize</name>)</expr>;</expr_stmt>
<if>if <condition>(<expr><name>old_j</name> &gt; <name>j</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
<argument><expr>"new string is too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>old_j</name> = <name>j</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>j</name>++</expr>;</expr_stmt>
<if>if <condition>(<expr>*<name>p</name> == '\n'</expr>)</condition><then> <block>{
<expr_stmt><expr><name>i</name> += <name>j</name></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name> = 0</expr>;</expr_stmt>
}</block></then></if>
}</block></else></if>
}</block></for>
<if>if <condition>(<expr>(<name>i</name> + <name>j</name>) &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>, <argument><expr>"new string is too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>out</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>i</name>+<name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>out</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>i</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>q</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>p</name> = <name>string</name></expr>;</init> <condition><expr><name>p</name> &lt; <name>e</name></expr>;</condition> <incr><expr><name>p</name>++</expr></incr>) <block>{
<if>if <condition>(<expr>*<name>p</name> == '\t'</expr>)</condition><then> <block>{
<expr_stmt><expr><name>j</name> = <name>tabsize</name> - (<name>i</name>%<name>tabsize</name>)</expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> += <name>j</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>j</name>-- &gt; 0</expr>)</condition>
<expr_stmt><expr>*<name>q</name>++ = ' '</expr>;</expr_stmt></while>
}</block></then> <else>else <block>{
<expr_stmt><expr>*<name>q</name>++ = *<name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
<if>if <condition>(<expr>*<name>p</name> == '\n'</expr>)</condition><then>
<expr_stmt><expr><name>i</name> = 0</expr>;</expr_stmt></then></if>
}</block></else></if>
}</block></for>
<return>return <expr><name>out</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>count__doc__</name></expr></argument>,
<argument><expr>"count(s, sub[, start[, end]]) -&gt; int\n"
"\n"
"Return the number of occurrences of substring sub in string\n"
"s[start:end]. Optional arguments start and end are\n"
"interpreted as in slice notation."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>strop_count</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>s</name></decl>, *<decl><type ref="prev"/><name>sub</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name> <init>= <expr>0</expr></init>, <name>last</name> <init>= <expr><name>PY_SSIZE_T_MAX</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>m</name></decl>, <decl><type ref="prev"/><name>r</name></decl>;</decl_stmt>
<expr_stmt><expr><name>WARN</name></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"t#t#|nn:count"</expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr>&amp;<name>sub</name></expr></argument>, <argument><expr>&amp;<name>n</name></expr></argument>, <argument><expr>&amp;<name>i</name></expr></argument>, <argument><expr>&amp;<name>last</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>last</name> &gt; <name>len</name></expr>)</condition><then>
<expr_stmt><expr><name>last</name> = <name>len</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>last</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>last</name> += <name>len</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>last</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>last</name> = 0</expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>i</name> += <name>len</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>i</name> = 0</expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>m</name> = <name>last</name> + 1 - <name>n</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>n</name> == 0</expr>)</condition><then>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><call>(<name>long</name>) <argument_list>(<argument><expr><name>m</name>-<name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>r</name> = 0</expr>;</expr_stmt>
<while>while <condition>(<expr><name>i</name> &lt; <name>m</name></expr>)</condition> <block>{
<if>if <condition>(<expr>!<call><name>memcmp</name><argument_list>(<argument><expr><name>s</name>+<name>i</name></expr></argument>, <argument><expr><name>sub</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>r</name>++</expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> += <name>n</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
}</block></else></if>
}</block></while>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>) <name>r</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>swapcase__doc__</name></expr></argument>,
<argument><expr>"swapcase(s) -&gt; string\n"
"\n"
"Return a copy of the string s with upper case characters\n"
"converted to lowercase and vice versa."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>strop_swapcase</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>s</name></decl>, *<decl><type ref="prev"/><name>s_new</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>newstr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>changed</name></decl>;</decl_stmt>
<expr_stmt><expr><name>WARN</name></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyString_AsStringAndSize</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>, <argument><expr>&amp;<name>n</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>newstr</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>newstr</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>s_new</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><name>newstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>changed</name> = 0</expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>s</name>++</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>islower</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>changed</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr>*<name>s_new</name> = <call><name>toupper</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><call><name>isupper</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>changed</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr>*<name>s_new</name> = <call><name>tolower</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else
<expr_stmt><expr>*<name>s_new</name> = <name>c</name></expr>;</expr_stmt></else></if></else></if>
<expr_stmt><expr><name>s_new</name>++</expr>;</expr_stmt>
}</block></for>
<if>if <condition>(<expr>!<name>changed</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>newstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>args</name></expr>;</return>
}</block></then></if>
<return>return <expr><name>newstr</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>atoi__doc__</name></expr></argument>,
<argument><expr>"atoi(s [,base]) -&gt; int\n"
"\n"
"Return the integer represented by the string s in the given\n"
"base, which defaults to 10. The string s must consist of one\n"
"or more digits, possibly preceded by a sign. If base is 0, it\n"
"is chosen from the leading characters of s, 0 for octal, 0x or\n"
"0X for hexadecimal. If base is 16, a preceding 0x or 0X is\n"
"accepted."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>strop_atoi</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>s</name></decl>, *<decl><type ref="prev"/><name>end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>base</name> <init>= <expr>10</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>x</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr>256</expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><name>WARN</name></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s|i:atoi"</expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>, <argument><expr>&amp;<name>base</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr>(<name>base</name> != 0 &amp;&amp; <name>base</name> &lt; 2) || <name>base</name> &gt; 36</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"invalid base for atoi()"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<while>while <condition>(<expr>*<name>s</name> &amp;&amp; <call><name>isspace</name><argument_list>(<argument><expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt></while>
<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
<if>if <condition>(<expr><name>base</name> == 0 &amp;&amp; <name><name>s</name><index>[<expr>0</expr>]</index></name> == '0'</expr>)</condition><then>
<expr_stmt><expr><name>x</name> = (<name>long</name>) <call><name>PyOS_strtoul</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>&amp;<name>end</name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>x</name> = <call><name>PyOS_strtol</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>&amp;<name>end</name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<if>if <condition>(<expr><name>end</name> == <name>s</name> || !<call><name>isalnum</name><argument_list>(<argument><expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr><name><name>end</name><index>[<expr>-1</expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
<goto>goto <name>bad</name>;</goto></then></if>
<while>while <condition>(<expr>*<name>end</name> &amp;&amp; <call><name>isspace</name><argument_list>(<argument><expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>end</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
<expr_stmt><expr><name>end</name>++</expr>;</expr_stmt></while>
<if>if <condition>(<expr>*<name>end</name> != '\0'</expr>)</condition><then> <block>{
<label><name>bad</name>:</label>
<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr>"invalid literal for atoi(): %.200s"</expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><name>errno</name> != 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr>"atoi() literal too large: %.200s"</expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if></else></if>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>atol__doc__</name></expr></argument>,
<argument><expr>"atol(s [,base]) -&gt; long\n"
"\n"
"Return the long integer represented by the string s in the\n"
"given base, which defaults to 10. The string s must consist\n"
"of one or more digits, possibly preceded by a sign. If base\n"
"is 0, it is chosen from the leading characters of s, 0 for\n"
"octal, 0x or 0X for hexadecimal. If base is 16, a preceding\n"
"0x or 0X is accepted. A trailing L or l is not accepted,\n"
"unless base is 0."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>strop_atol</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>s</name></decl>, *<decl><type ref="prev"/><name>end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>base</name> <init>= <expr>10</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>x</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr>256</expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><name>WARN</name></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s|i:atol"</expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>, <argument><expr>&amp;<name>base</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr>(<name>base</name> != 0 &amp;&amp; <name>base</name> &lt; 2) || <name>base</name> &gt; 36</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"invalid base for atol()"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<while>while <condition>(<expr>*<name>s</name> &amp;&amp; <call><name>isspace</name><argument_list>(<argument><expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt></while>
<if>if <condition>(<expr><name><name>s</name><index>[<expr>0</expr>]</index></name> == '\0'</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"empty string for atol()"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>x</name> = <call><name>PyLong_FromString</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>&amp;<name>end</name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>x</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>base</name> == 0 &amp;&amp; (*<name>end</name> == 'l' || *<name>end</name> == 'L')</expr>)</condition><then>
<expr_stmt><expr><name>end</name>++</expr>;</expr_stmt></then></if>
<while>while <condition>(<expr>*<name>end</name> &amp;&amp; <call><name>isspace</name><argument_list>(<argument><expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>end</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
<expr_stmt><expr><name>end</name>++</expr>;</expr_stmt></while>
<if>if <condition>(<expr>*<name>end</name> != '\0'</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr>"invalid literal for atol(): %.200s"</expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><name>x</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>atof__doc__</name></expr></argument>,
<argument><expr>"atof(s) -&gt; float\n"
"\n"
"Return the floating point number represented by the string s."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>strop_atof</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>s</name></decl>, *<decl><type ref="prev"/><name>end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>x</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr>256</expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><name>WARN</name></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s:atof"</expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<while>while <condition>(<expr>*<name>s</name> &amp;&amp; <call><name>isspace</name><argument_list>(<argument><expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt></while>
<if>if <condition>(<expr><name><name>s</name><index>[<expr>0</expr>]</index></name> == '\0'</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"empty string for atof()"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
<macro><name>PyFPE_START_PROTECT</name><argument_list>(<argument>"strop_atof"</argument>, <argument>return 0</argument>)</argument_list></macro>
<expr_stmt><expr><name>x</name> = <call><name>PyOS_ascii_strtod</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>&amp;<name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>PyFPE_END_PROTECT</name><argument_list>(<argument>x</argument>)</argument_list></macro>
<while>while <condition>(<expr>*<name>end</name> &amp;&amp; <call><name>isspace</name><argument_list>(<argument><expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>end</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
<expr_stmt><expr><name>end</name>++</expr>;</expr_stmt></while>
<if>if <condition>(<expr>*<name>end</name> != '\0'</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr>"invalid literal for atof(): %.200s"</expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><name>errno</name> != 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr>"atof() literal too large: %.200s"</expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if></else></if>
<return>return <expr><call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>maketrans__doc__</name></expr></argument>,
<argument><expr>"maketrans(frm, to) -&gt; string\n"
"\n"
"Return a translation table (a string of 256 bytes long)\n"
"suitable for use in string.translate. The strings frm and to\n"
"must be of the same length."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>strop_maketrans</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>c</name></decl>, *<decl><type ref="prev"/><name>from</name><init>=<expr><name>NULL</name></expr></init>, *<name>to</name><init>=<expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>fromlen</name><init>=<expr>0</expr></init>, <name>tolen</name><init>=<expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"t#t#:maketrans"</expr></argument>, <argument><expr>&amp;<name>from</name></expr></argument>, <argument><expr>&amp;<name>fromlen</name></expr></argument>, <argument><expr>&amp;<name>to</name></expr></argument>, <argument><expr>&amp;<name>tolen</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>fromlen</name> != <name>tolen</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"maketrans arguments must have same length"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>result</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr>(<name>char</name> *)<name>NULL</name></expr></argument>, <argument><expr>256</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>c</name> = (<name>unsigned</name> <name>char</name> *) <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr>(<name>PyStringObject</name> *)<name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; 256</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
<expr_stmt><expr><name><name>c</name><index>[<expr><name>i</name></expr>]</index></name>=(<name>unsigned</name> <name>char</name>)<name>i</name></expr>;</expr_stmt></for>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>fromlen</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
<expr_stmt><expr><name><name>c</name><index>[<expr><name><name>from</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name>=<name><name>to</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></for>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>translate__doc__</name></expr></argument>,
<argument><expr>"translate(s,table [,deletechars]) -&gt; string\n"
"\n"
"Return a copy of the string s, where all characters occurring\n"
"in the optional argument deletechars are removed, and the\n"
"remaining characters have been mapped through the given\n"
"translation table, which must be a string of length 256."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>strop_translate</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>register</name> <name>char</name> *</type><name>input</name></decl>, *<decl><type ref="prev"/><name>table</name></decl>, *<decl><type ref="prev"/><name>output</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>, <decl><type ref="prev"/><name>changed</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>input_obj</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>table1</name></decl>, *<decl><type ref="prev"/><name>output_start</name></decl>, *<decl><type ref="prev"/><name>del_table</name><init>=<expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>inlen</name></decl>, <decl><type ref="prev"/><name>tablen</name></decl>, <decl><type ref="prev"/><name>dellen</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>trans_table</name><index>[<expr>256</expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><name>WARN</name></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"St#|t#:translate"</expr></argument>, <argument><expr>&amp;<name>input_obj</name></expr></argument>,
<argument><expr>&amp;<name>table1</name></expr></argument>, <argument><expr>&amp;<name>tablen</name></expr></argument>, <argument><expr>&amp;<name>del_table</name></expr></argument>, <argument><expr>&amp;<name>dellen</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>tablen</name> != 256</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"translation table must be 256 characters long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>table</name> = <name>table1</name></expr>;</expr_stmt>
<expr_stmt><expr><name>inlen</name> = <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>input_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr>(<name>char</name> *)<name>NULL</name></expr></argument>, <argument><expr><name>inlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>output_start</name> = <name>output</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>input</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><name>input_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>dellen</name> == 0</expr>)</condition><then> <block>{
<for>for (<init><expr><name>i</name> = <name>inlen</name></expr>;</init> <condition><expr>--<name>i</name> &gt;= 0</expr>;</condition> <incr/>) <block>{
<expr_stmt><expr><name>c</name> = <call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>input</name>++</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>(*<name>output</name>++ = <name><name>table</name><index>[<expr><name>c</name></expr>]</index></name>)</expr></argument>)</argument_list></call> != <name>c</name></expr>)</condition><then>
<expr_stmt><expr><name>changed</name> = 1</expr>;</expr_stmt></then></if>
}</block></for>
<if>if <condition>(<expr><name>changed</name></expr>)</condition><then>
<return>return <expr><name>result</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>input_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>input_obj</name></expr>;</return>
}</block></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; 256</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
<expr_stmt><expr><name><name>trans_table</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name>Py_CHARMASK</name><argument_list>(<argument><expr><name><name>table</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>dellen</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
<expr_stmt><expr><name><name>trans_table</name><index>[<expr>(<name>int</name>) <call><name>Py_CHARMASK</name><argument_list>(<argument><expr><name><name>del_table</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>]</index></name> = -1</expr>;</expr_stmt></for>
<for>for (<init><expr><name>i</name> = <name>inlen</name></expr>;</init> <condition><expr>--<name>i</name> &gt;= 0</expr>;</condition> <incr/>) <block>{
<expr_stmt><expr><name>c</name> = <call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>input</name>++</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>trans_table</name><index>[<expr><name>c</name></expr>]</index></name> != -1</expr>)</condition><then>
<if>if <condition>(<expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>output</name>++ = (<name>char</name>)<name><name>trans_table</name><index>[<expr><name>c</name></expr>]</index></name></expr></argument>)</argument_list></call> == <name>c</name></expr>)</condition><then>
<continue>continue;</continue></then></if></then></if>
<expr_stmt><expr><name>changed</name> = 1</expr>;</expr_stmt>
}</block></for>
<if>if <condition>(<expr>!<name>changed</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>input_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>input_obj</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>inlen</name> &gt; 0</expr>)</condition><then>
<expr_stmt><expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>result</name></expr></argument>, <argument><expr><name>output</name> - <name>output_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>Py_ssize_t</name></type>
<name>mymemfind</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>mem</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>pat</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>pat_len</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>ii</name></decl>;</decl_stmt>
<expr_stmt><expr><name>len</name> -= <name>pat_len</name></expr>;</expr_stmt>
<for>for (<init><expr><name>ii</name> = 0</expr>;</init> <condition><expr><name>ii</name> &lt;= <name>len</name></expr>;</condition> <incr><expr><name>ii</name>++</expr></incr>) <block>{
<if>if <condition>(<expr><name><name>mem</name><index>[<expr><name>ii</name></expr>]</index></name> == <name><name>pat</name><index>[<expr>0</expr>]</index></name> &amp;&amp;
(<name>pat_len</name> == 1 ||
<call><name>memcmp</name><argument_list>(<argument><expr>&amp;<name><name>mem</name><index>[<expr><name>ii</name>+1</expr>]</index></name></expr></argument>, <argument><expr>&amp;<name><name>pat</name><index>[<expr>1</expr>]</index></name></expr></argument>, <argument><expr><name>pat_len</name>-1</expr></argument>)</argument_list></call> == 0)</expr>)</condition><then> <block>{
<return>return <expr><name>ii</name></expr>;</return>
}</block></then></if>
}</block></for>
<return>return <expr>-1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>Py_ssize_t</name></type>
<name>mymemcnt</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>mem</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>pat</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>pat_len</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>offset</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>nfound</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>len</name> &gt;= 0</expr>)</condition> <block>{
<expr_stmt><expr><name>offset</name> = <call><name>mymemfind</name><argument_list>(<argument><expr><name>mem</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>pat</name></expr></argument>, <argument><expr><name>pat_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>offset</name> == -1</expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr><name>mem</name> += <name>offset</name> + <name>pat_len</name></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> -= <name>offset</name> + <name>pat_len</name></expr>;</expr_stmt>
<expr_stmt><expr><name>nfound</name>++</expr>;</expr_stmt>
}</block></while>
<return>return <expr><name>nfound</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>char</name> *</type>
<name>mymemreplace</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>str</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>pat</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>pat_len</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>sub</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>sub_len</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>count</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name> *</type><name>out_len</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>out_s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>new_s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>nfound</name></decl>, <decl><type ref="prev"/><name>offset</name></decl>, <decl><type ref="prev"/><name>new_len</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>len</name> == 0 || <name>pat_len</name> &gt; <name>len</name></expr>)</condition><then>
<goto>goto <name>return_same</name>;</goto></then></if>
<expr_stmt><expr><name>nfound</name> = <call><name>mymemcnt</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>pat</name></expr></argument>, <argument><expr><name>pat_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>count</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>count</name> = <name>PY_SSIZE_T_MAX</name></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name>nfound</name> &gt; <name>count</name></expr>)</condition><then>
<expr_stmt><expr><name>nfound</name> = <name>count</name></expr>;</expr_stmt></then></if></else></if>
<if>if <condition>(<expr><name>nfound</name> == 0</expr>)</condition><then>
<goto>goto <name>return_same</name>;</goto></then></if>
<expr_stmt><expr><name>new_len</name> = <name>len</name> + <call><name>nfound</name>*<argument_list>(<argument><expr><name>sub_len</name> - <name>pat_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>new_len</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>out_s</name> = (<name>char</name> *)<call><name>PyMem_MALLOC</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>out_s</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>out_s</name><index>[<expr>0</expr>]</index></name> = '\0'</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>new_len</name> &gt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>new_s</name> = (<name>char</name> *)<call><name>PyMem_MALLOC</name><argument_list>(<argument><expr><name>new_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>new_s</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>out_s</name> = <name>new_s</name></expr>;</expr_stmt>
<for>for (<init>;</init> <condition><expr><name>count</name> &gt; 0 &amp;&amp; <name>len</name> &gt; 0</expr>;</condition> <incr><expr>--<name>count</name></expr></incr>) <block>{
<expr_stmt><expr><name>offset</name> = <call><name>mymemfind</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>pat</name></expr></argument>, <argument><expr><name>pat_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>offset</name> == -1</expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>new_s</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>str</name> += <name>offset</name> + <name>pat_len</name></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> -= <name>offset</name> + <name>pat_len</name></expr>;</expr_stmt>
<expr_stmt><expr><name>new_s</name> += <name>offset</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>new_s</name></expr></argument>, <argument><expr><name>sub</name></expr></argument>, <argument><expr><name>sub_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>new_s</name> += <name>sub_len</name></expr>;</expr_stmt>
}</block></for>
<if>if <condition>(<expr><name>len</name> &gt; 0</expr>)</condition><then>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>new_s</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></else></if>
<expr_stmt><expr>*<name>out_len</name> = <name>new_len</name></expr>;</expr_stmt>
<return>return <expr><name>out_s</name></expr>;</return>
<label><name>return_same</name>:</label>
<expr_stmt><expr>*<name>out_len</name> = -1</expr>;</expr_stmt>
<return>return <expr>(<name>char</name> *)<name>str</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>replace__doc__</name></expr></argument>,
<argument><expr>"replace (str, old, new[, maxsplit]) -&gt; string\n"
"\n"
"Return a copy of string str with all occurrences of substring\n"
"old replaced by new. If the optional argument maxsplit is\n"
"given, only the first maxsplit occurrences are replaced."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>strop_replace</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>str</name></decl>, *<decl><type ref="prev"/><name>pat</name></decl>,*<decl><type ref="prev"/><name>sub</name></decl>,*<decl><type ref="prev"/><name>new_s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl>,<decl><type ref="prev"/><name>pat_len</name></decl>,<decl><type ref="prev"/><name>sub_len</name></decl>,<decl><type ref="prev"/><name>out_len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>count</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>newstr</name></decl>;</decl_stmt>
<expr_stmt><expr><name>WARN</name></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"t#t#t#|n:replace"</expr></argument>,
<argument><expr>&amp;<name>str</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr>&amp;<name>pat</name></expr></argument>, <argument><expr>&amp;<name>pat_len</name></expr></argument>, <argument><expr>&amp;<name>sub</name></expr></argument>, <argument><expr>&amp;<name>sub_len</name></expr></argument>,
<argument><expr>&amp;<name>count</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>pat_len</name> &lt;= 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"empty pattern string"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>count</name> == 0</expr>)</condition><then>
<expr_stmt><expr><name>count</name> = -1</expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>new_s</name> = <call><name>mymemreplace</name><argument_list>(<argument><expr><name>str</name></expr></argument>,<argument><expr><name>len</name></expr></argument>,<argument><expr><name>pat</name></expr></argument>,<argument><expr><name>pat_len</name></expr></argument>,<argument><expr><name>sub</name></expr></argument>,<argument><expr><name>sub_len</name></expr></argument>,<argument><expr><name>count</name></expr></argument>,<argument><expr>&amp;<name>out_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>new_s</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>out_len</name> == -1</expr>)</condition><then> <block>{
<expr_stmt><expr><name>newstr</name> = <call><name>PyTuple_GetItem</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name>newstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>newstr</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>new_s</name></expr></argument>, <argument><expr><name>out_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyMem_FREE</name><argument_list>(<argument><expr><name>new_s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<return>return <expr><name>newstr</name></expr>;</return>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type>
<name><name>strop_methods</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr>"atof"</expr>, <expr><name>strop_atof</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>atof__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"atoi"</expr>, <expr><name>strop_atoi</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>atoi__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"atol"</expr>, <expr><name>strop_atol</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>atol__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"capitalize"</expr>, <expr><name>strop_capitalize</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>capitalize__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"count"</expr>, <expr><name>strop_count</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>count__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"expandtabs"</expr>, <expr><name>strop_expandtabs</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>expandtabs__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"find"</expr>, <expr><name>strop_find</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>find__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"join"</expr>, <expr><name>strop_joinfields</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>joinfields__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"joinfields"</expr>, <expr><name>strop_joinfields</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>joinfields__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"lstrip"</expr>, <expr><name>strop_lstrip</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>lstrip__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"lower"</expr>, <expr><name>strop_lower</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>lower__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"maketrans"</expr>, <expr><name>strop_maketrans</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>maketrans__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"replace"</expr>, <expr><name>strop_replace</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>replace__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"rfind"</expr>, <expr><name>strop_rfind</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>rfind__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"rstrip"</expr>, <expr><name>strop_rstrip</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>rstrip__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"split"</expr>, <expr><name>strop_splitfields</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>splitfields__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"splitfields"</expr>, <expr><name>strop_splitfields</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>splitfields__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"strip"</expr>, <expr><name>strop_strip</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>strip__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"swapcase"</expr>, <expr><name>strop_swapcase</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>swapcase__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"translate"</expr>, <expr><name>strop_translate</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>translate__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"upper"</expr>, <expr><name>strop_upper</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>upper__doc__</name></expr>}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<function><type><name>PyMODINIT_FUNC</name></type>
<name>initstrop</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name></decl>, *<decl><type ref="prev"/><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>256</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
<expr_stmt><expr><name>m</name> = <call><name>Py_InitModule4</name><argument_list>(<argument><expr>"strop"</expr></argument>, <argument><expr><name>strop_methods</name></expr></argument>, <argument><expr><name>strop_module__doc__</name></expr></argument>,
<argument><expr>(<name>PyObject</name>*)<name>NULL</name></expr></argument>, <argument><expr><name>PYTHON_API_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>m</name> == <name>NULL</name></expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><name>n</name> = 0</expr>;</expr_stmt>
<for>for (<init><expr><name>c</name> = 0</expr>;</init> <condition><expr><name>c</name> &lt; 256</expr>;</condition> <incr><expr><name>c</name>++</expr></incr>) <block>{
<if>if <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name><name>buf</name><index>[<expr><name>n</name>++</expr>]</index></name> = <name>c</name></expr>;</expr_stmt></then></if>
}</block></for>
<expr_stmt><expr><name>s</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>s</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"whitespace"</expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>n</name> = 0</expr>;</expr_stmt>
<for>for (<init><expr><name>c</name> = 0</expr>;</init> <condition><expr><name>c</name> &lt; 256</expr>;</condition> <incr><expr><name>c</name>++</expr></incr>) <block>{
<if>if <condition>(<expr><call><name>islower</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name><name>buf</name><index>[<expr><name>n</name>++</expr>]</index></name> = <name>c</name></expr>;</expr_stmt></then></if>
}</block></for>
<expr_stmt><expr><name>s</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>s</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"lowercase"</expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>n</name> = 0</expr>;</expr_stmt>
<for>for (<init><expr><name>c</name> = 0</expr>;</init> <condition><expr><name>c</name> &lt; 256</expr>;</condition> <incr><expr><name>c</name>++</expr></incr>) <block>{
<if>if <condition>(<expr><call><name>isupper</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name><name>buf</name><index>[<expr><name>n</name>++</expr>]</index></name> = <name>c</name></expr>;</expr_stmt></then></if>
}</block></for>
<expr_stmt><expr><name>s</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>s</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"uppercase"</expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>
</unit>
