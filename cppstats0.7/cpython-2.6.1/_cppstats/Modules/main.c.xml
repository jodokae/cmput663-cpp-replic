<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="Modules/main.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"osdefs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"code.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"import.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__VMS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unixlib.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FCNTL_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>PYCC_GCC</name></expr></argument>)</argument_list></call>) || <call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PYTHONHOMEHELP</name></cpp:macro> <cpp:value>"&lt;prefix&gt;\\lib"</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>PYCC_GCC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PYTHONHOMEHELP</name></cpp:macro> <cpp:value>"&lt;prefix&gt;/Lib"</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PYTHONHOMEHELP</name></cpp:macro> <cpp:value>"&lt;prefix&gt;/pythonX.X"</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pygetopt.h"</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COPYRIGHT</name></cpp:macro> <cpp:value>"Type \"help\", \"copyright\", \"credits\" or \"license\" " "for more information."</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call></expr></cpp:if>
<extern>extern "C" <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> **</type><name>orig_argv</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>orig_argc</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BASE_OPTS</name></cpp:macro> <cpp:value>"3bBc:dEhiJm:OQ:sStuUvVW:xX?"</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>RISCOS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROGRAM_OPTS</name></cpp:macro> <cpp:value>BASE_OPTS</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROGRAM_OPTS</name></cpp:macro> <cpp:value>BASE_OPTS "w"</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type> <name>Py_RISCOSWimpFlag</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name>usage_line</name> <init>=
<expr>"usage: %s [option] ... [-c cmd | -m mod | file | -] [arg] ...\n"</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name>usage_1</name> <init>= <expr>"\
Options and arguments (and corresponding environment variables):\n\
-B : don't write .py[co] files on import; also PYTHONDONTWRITEBYTECODE=x\n\
-c cmd : program passed in as string (terminates option list)\n\
-d : debug output from parser; also PYTHONDEBUG=x\n\
-E : ignore PYTHON* environment variables (such as PYTHONPATH)\n\
-h : print this help message and exit (also --help)\n\
-i : inspect interactively after running script; forces a prompt even\n\
"</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name>usage_2</name> <init>= <expr>"\
if stdin does not appear to be a terminal; also PYTHONINSPECT=x\n\
-m mod : run library module as a script (terminates option list)\n\
-O : optimize generated bytecode slightly; also PYTHONOPTIMIZE=x\n\
-OO : remove doc-strings in addition to the -O optimizations\n\
-Q arg : division options: -Qold (default), -Qwarn, -Qwarnall, -Qnew\n\
-s : don't add user site directory to sys.path; also PYTHONNOUSERSITE\n\
-S : don't imply 'import site' on initialization\n\
-t : issue warnings about inconsistent tab usage (-tt: issue errors)\n\
"</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name>usage_3</name> <init>= <expr>"\
-u : unbuffered binary stdout and stderr; also PYTHONUNBUFFERED=x\n\
see man page for details on internal buffering relating to '-u'\n\
-v : verbose (trace import statements); also PYTHONVERBOSE=x\n\
can be supplied multiple times to increase verbosity\n\
-V : print the Python version number and exit (also --version)\n\
-W arg : warning control; arg is action:message:category:module:lineno\n\
-x : skip first line of source, allowing use of non-Unix forms of #!cmd\n\
"</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name>usage_4</name> <init>= <expr>"\
-3 : warn about Python 3.x incompatibilities\n\
file : program read from script file\n\
- : program read from stdin (default; interactive mode if a tty)\n\
arg ...: arguments passed to program in sys.argv[1:]\n\n\
Other environment variables:\n\
PYTHONSTARTUP: file executed on interactive startup (no default)\n\
PYTHONPATH : '%c'-separated list of directories prefixed to the\n\
default module search path. The result is sys.path.\n\
"</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name>usage_5</name> <init>= <expr>"\
PYTHONHOME : alternate &lt;prefix&gt; directory (or &lt;prefix&gt;%c&lt;exec_prefix&gt;).\n\
The default module search path uses %s.\n\
PYTHONCASEOK : ignore case in 'import' statements (Windows).\n\
PYTHONIOENCODING: Encoding[:errors] used for stdin/stdout/stderr.\n\
"</expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>usage</name><parameter_list>(<param><decl><type><name>int</name></type> <name>exitcode</name></decl></param>, <param><decl><type><name>char</name>*</type> <name>program</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>FILE</name> *</type><name>f</name> <init>= <expr><name>exitcode</name> ? <name>stderr</name> : <name>stdout</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>usage_line</name></expr></argument>, <argument><expr><name>program</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>exitcode</name></expr>)</condition><then>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr>"Try `python -h' for more information.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else <block>{
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>usage_1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>usage_2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>usage_3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>usage_4</name></expr></argument>, <argument><expr><name>DELIM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>usage_5</name></expr></argument>, <argument><expr><name>DELIM</name></expr></argument>, <argument><expr><name>PYTHONHOMEHELP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__VMS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>exitcode</name> == 0</expr>)</condition><then> <block>{
<return>return <expr>1</expr>;</return>
}</block></then> <else>else <block>{
<return>return <expr>0x1000002c</expr>;</return>
}</block></else></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<return>return <expr><name>exitcode</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>RunStartupFile</name><parameter_list>(<param><decl><type><name>PyCompilerFlags</name> *</type><name>cf</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>startup</name> <init>= <expr><call><name>Py_GETENV</name><argument_list>(<argument><expr>"PYTHONSTARTUP"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>startup</name> != <name>NULL</name> &amp;&amp; <name><name>startup</name><index>[<expr>0</expr>]</index></name> != '\0'</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>FILE</name> *</type><name>fp</name> <init>= <expr><call><name>fopen</name><argument_list>(<argument><expr><name>startup</name></expr></argument>, <argument><expr>"r"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>fp</name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr>(<name>void</name>) <call><name>PyRun_SimpleFileExFlags</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>startup</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>cf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>int</name></type> <name>save_errno</name></decl>;</decl_stmt>
<expr_stmt><expr><name>save_errno</name> = <name>errno</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"Could not open PYTHONSTARTUP\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>errno</name> = <name>save_errno</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_SetFromErrnoWithFilename</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>,
<argument><expr><name>startup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_Print</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
}</block></then></if>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>RunModule</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>module</name></decl></param>, <param><decl><type><name>int</name></type> <name>set_argv0</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>runpy</name></decl>, *<decl><type ref="prev"/><name>runmodule</name></decl>, *<decl><type ref="prev"/><name>runargs</name></decl>, *<decl><type ref="prev"/><name>result</name></decl>;</decl_stmt>
<expr_stmt><expr><name>runpy</name> = <call><name>PyImport_ImportModule</name><argument_list>(<argument><expr>"runpy"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>runpy</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Could not import runpy module\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>runmodule</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>runpy</name></expr></argument>, <argument><expr>"_run_module_as_main"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>runmodule</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Could not access runpy._run_module_as_main\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>runpy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>runargs</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(si)"</expr></argument>, <argument><expr><name>module</name></expr></argument>, <argument><expr><name>set_argv0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>runargs</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
<argument><expr>"Could not create arguments for runpy._run_module_as_main\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>runpy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>runmodule</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>result</name> = <call><name>PyObject_Call</name><argument_list>(<argument><expr><name>runmodule</name></expr></argument>, <argument><expr><name>runargs</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Print</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>runpy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>runmodule</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>runargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then> <block>{
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>RunMainFromImporter</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>filename</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>argv0</name> <init>= <expr><name>NULL</name></expr></init>, *<name>importer</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>(<name>argv0</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call>) &amp;&amp;
(<name>importer</name> = <call><name>PyImport_GetImporter</name><argument_list>(<argument><expr><name>argv0</name></expr></argument>)</argument_list></call>) &amp;&amp;
(<name><name>importer</name>-&gt;<name>ob_type</name></name> != &amp;<name>PyNullImporter_Type</name>)</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>sys_path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>(<name>sys_path</name> = <call><name>PySys_GetObject</name><argument_list>(<argument><expr>"path"</expr></argument>)</argument_list></call>) &amp;&amp;
!<call><name>PyList_SetItem</name><argument_list>(<argument><expr><name>sys_path</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>argv0</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>argv0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>importer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>sys_path</name> = <name>NULL</name></expr>;</expr_stmt>
<return>return <expr><call><name>RunModule</name><argument_list>(<argument><expr>"__main__"</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call> != 0</expr>;</return>
}</block></then></if>
}</block></then></if>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>argv0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>importer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Print</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></then></if>
<return>return <expr>-1</expr>;</return>
}</block></function>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"abstract.h"</cpp:file></cpp:include>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>WaitForThreadShutdown</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WITH_THREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyThreadState</name> *</type><name>tstate</name> <init>= <expr><call><name>PyThreadState_GET</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>threading</name> <init>= <expr><call><name>PyMapping_GetItemString</name><argument_list>(<argument><expr><name><name>tstate</name>-&gt;<name>interp</name>-&gt;<name>modules</name></name></expr></argument>,
<argument><expr>"threading"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>threading</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
}</block></then></if>
<expr_stmt><expr><name>result</name> = <call><name>PyObject_CallMethod</name><argument_list>(<argument><expr><name>threading</name></expr></argument>, <argument><expr>"_shutdown"</expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyErr_WriteUnraisable</name><argument_list>(<argument><expr><name>threading</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>threading</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>
<function><type><name>int</name></type>
<name>Py_Main</name><parameter_list>(<param><decl><type><name>int</name></type> <name>argc</name></decl></param>, <param><decl><type><name>char</name> **</type><name>argv</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sts</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>command</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>filename</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>module</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> *</type><name>fp</name> <init>= <expr><name>stdin</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>unbuffered</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>skipfirstline</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>stdin_is_interactive</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>help</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>version</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>saw_unbuffered_flag</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyCompilerFlags</name></type> <name>cf</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>cf</name>.<name>cf_flags</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>orig_argc</name> = <name>argc</name></expr>;</expr_stmt>
<expr_stmt><expr><name>orig_argv</name> = <name>argv</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>RISCOS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>Py_RISCOSWimpFlag</name> = 0</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>PySys_ResetWarnOptions</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr>(<name>c</name> = <call><name>_PyOS_GetOpt</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>PROGRAM_OPTS</name></expr></argument>)</argument_list></call>) != <name>EOF</name></expr>)</condition> <block>{
<if>if <condition>(<expr><name>c</name> == 'c'</expr>)</condition><then> <block>{
<expr_stmt><expr><name>command</name> = (<name>char</name> *)<call><name>malloc</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>_PyOS_optarg</name></expr></argument>)</argument_list></call> + 2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>command</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(
<argument><expr>"not enough memory to copy -c argument"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr><name>_PyOS_optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
<if>if <condition>(<expr><name>c</name> == 'm'</expr>)</condition><then> <block>{
<expr_stmt><expr><name>module</name> = (<name>char</name> *)<call><name>malloc</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>_PyOS_optarg</name></expr></argument>)</argument_list></call> + 2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>module</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(
<argument><expr>"not enough memory to copy -m argument"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr><name>_PyOS_optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
<switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{
<case>case <expr>'b'</expr>:
<expr_stmt><expr><name>Py_BytesWarningFlag</name>++</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'d'</expr>:
<expr_stmt><expr><name>Py_DebugFlag</name>++</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'3'</expr>:
<expr_stmt><expr><name>Py_Py3kWarningFlag</name>++</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'Q'</expr>:
<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>_PyOS_optarg</name></expr></argument>, <argument><expr>"old"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>Py_DivisionWarningFlag</name> = 0</expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>_PyOS_optarg</name></expr></argument>, <argument><expr>"warn"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>Py_DivisionWarningFlag</name> = 1</expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>_PyOS_optarg</name></expr></argument>, <argument><expr>"warnall"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>Py_DivisionWarningFlag</name> = 2</expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>_PyOS_optarg</name></expr></argument>, <argument><expr>"new"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>cf</name>.<name>cf_flags</name></name> |= <name>CO_FUTURE_DIVISION</name></expr>;</expr_stmt>
<expr_stmt><expr><name>_Py_QnewFlag</name> = 1</expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
<argument><expr>"-Q option should be `-Qold', "
"`-Qwarn', `-Qwarnall', or `-Qnew' only\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>usage</name><argument_list>(<argument><expr>2</expr></argument>, <argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr>'i'</expr>:
<expr_stmt><expr><name>Py_InspectFlag</name>++</expr>;</expr_stmt>
<expr_stmt><expr><name>Py_InteractiveFlag</name>++</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'O'</expr>:
<expr_stmt><expr><name>Py_OptimizeFlag</name>++</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'B'</expr>:
<expr_stmt><expr><name>Py_DontWriteBytecodeFlag</name>++</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'s'</expr>:
<expr_stmt><expr><name>Py_NoUserSiteDirectory</name>++</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'S'</expr>:
<expr_stmt><expr><name>Py_NoSiteFlag</name>++</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'E'</expr>:
<expr_stmt><expr><name>Py_IgnoreEnvironmentFlag</name>++</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'t'</expr>:
<expr_stmt><expr><name>Py_TabcheckFlag</name>++</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'u'</expr>:
<expr_stmt><expr><name>unbuffered</name>++</expr>;</expr_stmt>
<expr_stmt><expr><name>saw_unbuffered_flag</name> = 1</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'v'</expr>:
<expr_stmt><expr><name>Py_VerboseFlag</name>++</expr>;</expr_stmt>
<break>break;</break>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>RISCOS</name></expr></argument>)</argument_list></call></expr></cpp:if>
</case><case>case <expr>'w'</expr>:
<expr_stmt><expr><name>Py_RISCOSWimpFlag</name> = 1</expr>;</expr_stmt>
<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</case><case>case <expr>'x'</expr>:
<expr_stmt><expr><name>skipfirstline</name> = 1</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'U'</expr>:
<expr_stmt><expr><name>Py_UnicodeFlag</name>++</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'h'</expr>:
</case><case>case <expr>'?'</expr>:
<expr_stmt><expr><name>help</name>++</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'V'</expr>:
<expr_stmt><expr><name>version</name>++</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'W'</expr>:
<expr_stmt><expr><call><name>PySys_AddWarnOption</name><argument_list>(<argument><expr><name>_PyOS_optarg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><default>default:
<return>return <expr><call><name>usage</name><argument_list>(<argument><expr>2</expr></argument>, <argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
</default>}</block></switch>
}</block></while>
<if>if <condition>(<expr><name>help</name></expr>)</condition><then>
<return>return <expr><call><name>usage</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><name>version</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Python %s\n"</expr></argument>, <argument><expr><name>PY_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>!<name>Py_InspectFlag</name> &amp;&amp;
(<name>p</name> = <call><name>Py_GETENV</name><argument_list>(<argument><expr>"PYTHONINSPECT"</expr></argument>)</argument_list></call>) &amp;&amp; *<name>p</name> != '\0'</expr>)</condition><then>
<expr_stmt><expr><name>Py_InspectFlag</name> = 1</expr>;</expr_stmt></then></if>
<if>if <condition>(<expr>!<name>saw_unbuffered_flag</name> &amp;&amp;
(<name>p</name> = <call><name>Py_GETENV</name><argument_list>(<argument><expr>"PYTHONUNBUFFERED"</expr></argument>)</argument_list></call>) &amp;&amp; *<name>p</name> != '\0'</expr>)</condition><then>
<expr_stmt><expr><name>unbuffered</name> = 1</expr>;</expr_stmt></then></if>
<if>if <condition>(<expr>!<name>Py_NoUserSiteDirectory</name> &amp;&amp;
(<name>p</name> = <call><name>Py_GETENV</name><argument_list>(<argument><expr>"PYTHONNOUSERSITE"</expr></argument>)</argument_list></call>) &amp;&amp; *<name>p</name> != '\0'</expr>)</condition><then>
<expr_stmt><expr><name>Py_NoUserSiteDirectory</name> = 1</expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>command</name> == <name>NULL</name> &amp;&amp; <name>module</name> == <name>NULL</name> &amp;&amp; <name>_PyOS_optind</name> &lt; <name>argc</name> &amp;&amp;
<call><name>strcmp</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>_PyOS_optind</name></expr>]</index></name></expr></argument>, <argument><expr>"-"</expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__VMS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>filename</name> = <name>decc</name><name/>$<call><name>translate_vms</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr><name>_PyOS_optind</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>filename</name> == (<name>char</name> *)0 || <name>filename</name> == (<name>char</name> *)-1</expr>)</condition><then>
<expr_stmt><expr><name>filename</name> = <name><name>argv</name><index>[<expr><name>_PyOS_optind</name></expr>]</index></name></expr>;</expr_stmt></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>filename</name> = <name><name>argv</name><index>[<expr><name>_PyOS_optind</name></expr>]</index></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></then></if>
<expr_stmt><expr><name>stdin_is_interactive</name> = <call><name>Py_FdIsInteractive</name><argument_list>(<argument><expr><name>stdin</name></expr></argument>, <argument><expr>(<name>char</name> *)0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>unbuffered</name></expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>_setmode</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stdin</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>O_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>_setmode</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>O_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SETVBUF</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>setvbuf</name><argument_list>(<argument><expr><name>stdin</name></expr></argument>, <argument><expr>(<name>char</name> *)<name>NULL</name></expr></argument>, <argument><expr><name>_IONBF</name></expr></argument>, <argument><expr><name>BUFSIZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setvbuf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr>(<name>char</name> *)<name>NULL</name></expr></argument>, <argument><expr><name>_IONBF</name></expr></argument>, <argument><expr><name>BUFSIZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setvbuf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>(<name>char</name> *)<name>NULL</name></expr></argument>, <argument><expr><name>_IONBF</name></expr></argument>, <argument><expr><name>BUFSIZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>setbuf</name><argument_list>(<argument><expr><name>stdin</name></expr></argument>, <argument><expr>(<name>char</name> *)<name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setbuf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr>(<name>char</name> *)<name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setbuf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>(<name>char</name> *)<name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></then> <else>else <if>if <condition>(<expr><name>Py_InteractiveFlag</name></expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>setvbuf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr>(<name>char</name> *)<name>NULL</name></expr></argument>, <argument><expr><name>_IONBF</name></expr></argument>, <argument><expr><name>BUFSIZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SETVBUF</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>setvbuf</name><argument_list>(<argument><expr><name>stdin</name></expr></argument>, <argument><expr>(<name>char</name> *)<name>NULL</name></expr></argument>, <argument><expr><name>_IOLBF</name></expr></argument>, <argument><expr><name>BUFSIZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>setvbuf</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr>(<name>char</name> *)<name>NULL</name></expr></argument>, <argument><expr><name>_IOLBF</name></expr></argument>, <argument><expr><name>BUFSIZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></then>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__VMS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<else>else <block>{
<expr_stmt><expr><call><name>setvbuf</name> <argument_list>(<argument><expr><name>stdout</name></expr></argument>, <argument><expr>(<name>char</name> *)<name>NULL</name></expr></argument>, <argument><expr><name>_IOLBF</name></expr></argument>, <argument><expr><name>BUFSIZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr>(<name>p</name> = <call><name>Py_GETENV</name><argument_list>(<argument><expr>"PYTHONEXECUTABLE"</expr></argument>)</argument_list></call>) &amp;&amp; *<name>p</name> != '\0'</expr>)</condition><then>
<expr_stmt><expr><call><name>Py_SetProgramName</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><call><name>Py_SetProgramName</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>Py_SetProgramName</name><argument_list>(<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>Py_Initialize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>Py_VerboseFlag</name> ||
(<name>command</name> == <name>NULL</name> &amp;&amp; <name>filename</name> == <name>NULL</name> &amp;&amp; <name>module</name> == <name>NULL</name> &amp;&amp; <name>stdin_is_interactive</name>)</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Python %s on %s\n"</expr></argument>,
<argument><expr><call><name>Py_GetVersion</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>Py_GetPlatform</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>Py_NoSiteFlag</name></expr>)</condition><then>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"%s\n"</expr></argument>, <argument><expr><name>COPYRIGHT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></then></if>
<if>if <condition>(<expr><name>command</name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>_PyOS_optind</name>--</expr>;</expr_stmt>
<expr_stmt><expr><name><name>argv</name><index>[<expr><name>_PyOS_optind</name></expr>]</index></name> = "-c"</expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>module</name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>_PyOS_optind</name>--</expr>;</expr_stmt>
<expr_stmt><expr><name><name>argv</name><index>[<expr><name>_PyOS_optind</name></expr>]</index></name> = "-c"</expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>PySys_SetArgv</name><argument_list>(<argument><expr><name>argc</name>-<name>_PyOS_optind</name></expr></argument>, <argument><expr><name>argv</name>+<name>_PyOS_optind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>(<name>Py_InspectFlag</name> || (<name>command</name> == <name>NULL</name> &amp;&amp; <name>filename</name> == <name>NULL</name> &amp;&amp; <name>module</name> == <name>NULL</name>)) &amp;&amp;
<call><name>isatty</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stdin</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
<expr_stmt><expr><name>v</name> = <call><name>PyImport_ImportModule</name><argument_list>(<argument><expr>"readline"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
}</block></then></if>
<if>if <condition>(<expr><name>command</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>sts</name> = <call><name>PyRun_SimpleStringFlags</name><argument_list>(<argument><expr><name>command</name></expr></argument>, <argument><expr>&amp;<name>cf</name></expr></argument>)</argument_list></call> != 0</expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>command</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>module</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>sts</name> = <call><name>RunModule</name><argument_list>(<argument><expr><name>module</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>module</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<if>if <condition>(<expr><name>filename</name> == <name>NULL</name> &amp;&amp; <name>stdin_is_interactive</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>Py_InspectFlag</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><call><name>RunStartupFile</name><argument_list>(<argument><expr>&amp;<name>cf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>sts</name> = -1</expr>;</expr_stmt>
<if>if <condition>(<expr><name>filename</name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>sts</name> = <call><name>RunMainFromImporter</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>sts</name>==-1 &amp;&amp; <name>filename</name>!=<name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>(<name>fp</name> = <call><name>fopen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr>"r"</expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"%s: can't open file '%s': [Errno %d] %s\n"</expr></argument>,
<argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>errno</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>2</expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><name>skipfirstline</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>ch</name></decl>;</decl_stmt>
<while>while <condition>(<expr>(<name>ch</name> = <call><name>getc</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call>) != <name>EOF</name></expr>)</condition> <block>{
<if>if <condition>(<expr><name>ch</name> == '\n'</expr>)</condition><then> <block>{
<expr_stmt><expr>(<name>void</name>)<call><name>ungetc</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
}</block></while>
}</block></then></if></else></if>
<block>{
<decl_stmt><decl><type>struct <name>stat</name></type> <name>sb</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>fstat</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>sb</name></expr></argument>)</argument_list></call> == 0 &amp;&amp;
<call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>sb</name>.<name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"%s: '%s' is a directory, cannot continue\n"</expr></argument>, <argument><expr><name><name>argv</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></then></if>
}</block>
}</block></then></if>
<if>if <condition>(<expr><name>sts</name>==-1</expr>)</condition><then> <block>{
<expr_stmt><expr><name>sts</name> = <call><name>PyRun_AnyFileExFlags</name><argument_list>(
<argument><expr><name>fp</name></expr></argument>,
<argument><expr><name>filename</name> == <name>NULL</name> ? "&lt;stdin&gt;" : <name>filename</name></expr></argument>,
<argument><expr><name>filename</name> != <name>NULL</name></expr></argument>, <argument><expr>&amp;<name>cf</name></expr></argument>)</argument_list></call> != 0</expr>;</expr_stmt>
}</block></then></if>
}</block></else></if></else></if>
<if>if <condition>(<expr>!<name>Py_InspectFlag</name> &amp;&amp;
(<name>p</name> = <call><name>Py_GETENV</name><argument_list>(<argument><expr>"PYTHONINSPECT"</expr></argument>)</argument_list></call>) &amp;&amp; *<name>p</name> != '\0'</expr>)</condition><then> <block>{
<expr_stmt><expr><name>Py_InspectFlag</name> = 1</expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>Py_InspectFlag</name> &amp;&amp; <name>stdin_is_interactive</name> &amp;&amp;
(<name>filename</name> != <name>NULL</name> || <name>command</name> != <name>NULL</name> || <name>module</name> != <name>NULL</name>)</expr>)</condition><then> <block>{
<expr_stmt><expr><name>Py_InspectFlag</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>sts</name> = <call><name>PyRun_AnyFileFlags</name><argument_list>(<argument><expr><name>stdin</name></expr></argument>, <argument><expr>"&lt;stdin&gt;"</expr></argument>, <argument><expr>&amp;<name>cf</name></expr></argument>)</argument_list></call> != 0</expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>WaitForThreadShutdown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_Finalize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>RISCOS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>Py_RISCOSWimpFlag</name></expr>)</condition><then>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"\x0cq\x0c"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__INSURE__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>_Py_ReleaseInternedStrings</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><name>sts</name></expr>;</return>
}</block></function>
<function><type><name>void</name></type>
<name>Py_GetArgcArgv</name><parameter_list>(<param><decl><type><name>int</name> *</type><name>argc</name></decl></param>, <param><decl><type><name>char</name> ***</type><name>argv</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr>*<name>argc</name> = <name>orig_argc</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>argv</name> = <name>orig_argv</name></expr>;</expr_stmt>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call></expr></cpp:if>
}</block></extern>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
