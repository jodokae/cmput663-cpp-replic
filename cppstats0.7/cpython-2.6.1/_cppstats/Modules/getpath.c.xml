<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="Modules/getpath.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"osdefs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;mach-o/dyld.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call></expr></cpp:if>
<extern>extern "C" <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>VERSION</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VERSION</name></cpp:macro> <cpp:value>"2.1"</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>VPATH</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VPATH</name></cpp:macro> <cpp:value>"."</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>PREFIX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__VMS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PREFIX</name></cpp:macro> <cpp:value>""</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PREFIX</name></cpp:macro> <cpp:value>"/usr/local"</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>EXEC_PREFIX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXEC_PREFIX</name></cpp:macro> <cpp:value>PREFIX</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>PYTHONPATH</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PYTHONPATH</name></cpp:macro> <cpp:value>PREFIX "/lib/python" VERSION ":" EXEC_PREFIX "/lib/python" VERSION "/lib-dynload"</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>LANDMARK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LANDMARK</name></cpp:macro> <cpp:value>"os.py"</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>prefix</name><index>[<expr><name>MAXPATHLEN</name>+1</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>exec_prefix</name><index>[<expr><name>MAXPATHLEN</name>+1</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>progpath</name><index>[<expr><name>MAXPATHLEN</name>+1</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name>module_search_path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>lib_python</name><index>[]</index></name> <init>= <expr>"lib/python" <name>VERSION</name></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>reduce</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>dir</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>i</name> &gt; 0 &amp;&amp; <name><name>dir</name><index>[<expr><name>i</name></expr>]</index></name> != <name>SEP</name></expr>)</condition>
<expr_stmt><expr>--<name>i</name></expr>;</expr_stmt></while>
<expr_stmt><expr><name><name>dir</name><index>[<expr><name>i</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>isfile</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>filename</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>stat</name></type> <name>buf</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr>&amp;<name>buf</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>S_ISREG</name><argument_list>(<argument><expr><name><name>buf</name>.<name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>ismodule</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>filename</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><call><name>isfile</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>1</expr>;</return></then></if>
<if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call> &lt; <name>MAXPATHLEN</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>Py_OptimizeFlag</name> ? "o" : "c"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>isfile</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>1</expr>;</return></then></if>
}</block></then></if>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>isxfile</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>filename</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>stat</name></type> <name>buf</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr>&amp;<name>buf</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>S_ISREG</name><argument_list>(<argument><expr><name><name>buf</name>.<name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<if>if <condition>(<expr>(<name><name>buf</name>.<name>st_mode</name></name> &amp; 0111) == 0</expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>isdir</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>filename</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>stat</name></type> <name>buf</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr>&amp;<name>buf</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>buf</name>.<name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>joinpath</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>buffer</name></decl></param>, <param><decl><type><name>char</name> *</type><name>stuff</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>size_t</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>stuff</name><index>[<expr>0</expr>]</index></name> == <name>SEP</name></expr>)</condition><then>
<expr_stmt><expr><name>n</name> = 0</expr>;</expr_stmt></then>
<else>else <block>{
<expr_stmt><expr><name>n</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>n</name> &gt; 0 &amp;&amp; <name><name>buffer</name><index>[<expr><name>n</name>-1</expr>]</index></name> != <name>SEP</name> &amp;&amp; <name>n</name> &lt; <name>MAXPATHLEN</name></expr>)</condition><then>
<expr_stmt><expr><name><name>buffer</name><index>[<expr><name>n</name>++</expr>]</index></name> = <name>SEP</name></expr>;</expr_stmt></then></if>
}</block></else></if>
<if>if <condition>(<expr><name>n</name> &gt; <name>MAXPATHLEN</name></expr>)</condition><then>
<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"buffer overflow in getpath.c's joinpath()"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>k</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>stuff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>n</name> + <name>k</name> &gt; <name>MAXPATHLEN</name></expr>)</condition><then>
<expr_stmt><expr><name>k</name> = <name>MAXPATHLEN</name> - <name>n</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>buffer</name>+<name>n</name></expr></argument>, <argument><expr><name>stuff</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buffer</name><index>[<expr><name>n</name>+<name>k</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>copy_absolute</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><name>char</name> *</type><name>p</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name><name>p</name><index>[<expr>0</expr>]</index></name> == <name>SEP</name></expr>)</condition><then>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else <block>{
<expr_stmt><expr><call><name>getcwd</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>p</name><index>[<expr>0</expr>]</index></name> == '.' &amp;&amp; <name><name>p</name><index>[<expr>1</expr>]</index></name> == <name>SEP</name></expr>)</condition><then>
<expr_stmt><expr><name>p</name> += 2</expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>joinpath</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>absolutize</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>path</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr><name>MAXPATHLEN</name> + 1</expr>]</index></name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>path</name><index>[<expr>0</expr>]</index></name> == <name>SEP</name></expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><call><name>copy_absolute</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>search_for_prefix</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>argv0_path</name></decl></param>, <param><decl><type><name>char</name> *</type><name>home</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>size_t</name></type> <name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>vpath</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>home</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>delim</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>home</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>delim</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>DELIM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>delim</name></expr>)</condition><then>
<expr_stmt><expr>*<name>delim</name> = '\0'</expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>joinpath</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>lib_python</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>joinpath</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>LANDMARK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>argv0_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>joinpath</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr>"Modules/Setup"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>isfile</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>vpath</name> = <name>VPATH</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>argv0_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>joinpath</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>vpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>joinpath</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr>"Lib"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>joinpath</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>LANDMARK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>ismodule</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
}</block></then></if>
<expr_stmt><expr><call><name>copy_absolute</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>argv0_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<do>do <block>{
<expr_stmt><expr><name>n</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>joinpath</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>lib_python</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>joinpath</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>LANDMARK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>ismodule</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>1</expr>;</return></then></if>
<expr_stmt><expr><name><name>prefix</name><index>[<expr><name>n</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
<expr_stmt><expr><call><name>reduce</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block> while <condition>(<expr><name><name>prefix</name><index>[<expr>0</expr>]</index></name></expr>)</condition>;</do>
<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>PREFIX</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>joinpath</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>lib_python</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>joinpath</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>LANDMARK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>ismodule</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>1</expr>;</return></then></if>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>search_for_exec_prefix</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>argv0_path</name></decl></param>, <param><decl><type><name>char</name> *</type><name>home</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>size_t</name></type> <name>n</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>home</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>delim</name></decl>;</decl_stmt>
<expr_stmt><expr><name>delim</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>home</name></expr></argument>, <argument><expr><name>DELIM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>delim</name></expr>)</condition><then>
<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>exec_prefix</name></expr></argument>, <argument><expr><name>delim</name>+1</expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>exec_prefix</name></expr></argument>, <argument><expr><name>home</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<expr_stmt><expr><call><name>joinpath</name><argument_list>(<argument><expr><name>exec_prefix</name></expr></argument>, <argument><expr><name>lib_python</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>joinpath</name><argument_list>(<argument><expr><name>exec_prefix</name></expr></argument>, <argument><expr>"lib-dynload"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>exec_prefix</name></expr></argument>, <argument><expr><name>argv0_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>joinpath</name><argument_list>(<argument><expr><name>exec_prefix</name></expr></argument>, <argument><expr>"Modules/Setup"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>isfile</name><argument_list>(<argument><expr><name>exec_prefix</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>reduce</name><argument_list>(<argument><expr><name>exec_prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>copy_absolute</name><argument_list>(<argument><expr><name>exec_prefix</name></expr></argument>, <argument><expr><name>argv0_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<do>do <block>{
<expr_stmt><expr><name>n</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>exec_prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>joinpath</name><argument_list>(<argument><expr><name>exec_prefix</name></expr></argument>, <argument><expr><name>lib_python</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>joinpath</name><argument_list>(<argument><expr><name>exec_prefix</name></expr></argument>, <argument><expr>"lib-dynload"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>isdir</name><argument_list>(<argument><expr><name>exec_prefix</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>1</expr>;</return></then></if>
<expr_stmt><expr><name><name>exec_prefix</name><index>[<expr><name>n</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
<expr_stmt><expr><call><name>reduce</name><argument_list>(<argument><expr><name>exec_prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block> while <condition>(<expr><name><name>exec_prefix</name><index>[<expr>0</expr>]</index></name></expr>)</condition>;</do>
<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>exec_prefix</name></expr></argument>, <argument><expr><name>EXEC_PREFIX</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>joinpath</name><argument_list>(<argument><expr><name>exec_prefix</name></expr></argument>, <argument><expr><name>lib_python</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>joinpath</name><argument_list>(<argument><expr><name>exec_prefix</name></expr></argument>, <argument><expr>"lib-dynload"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>isdir</name><argument_list>(<argument><expr><name>exec_prefix</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>1</expr>;</return></then></if>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>calculate_path</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<function_decl><type><specifier>extern</specifier> <name>char</name> *</type><name>Py_GetProgramName</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>delimiter</name><index>[<expr>2</expr>]</index></name> <init>= <expr><block>{<expr><name>DELIM</name></expr>, <expr>'\0'</expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>separator</name><index>[<expr>2</expr>]</index></name> <init>= <expr><block>{<expr><name>SEP</name></expr>, <expr>'\0'</expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>pythonpath</name> <init>= <expr><name>PYTHONPATH</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>rtpypath</name> <init>= <expr><call><name>Py_GETENV</name><argument_list>(<argument><expr>"PYTHONPATH"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>home</name> <init>= <expr><call><name>Py_GetPythonHome</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>path</name> <init>= <expr><call><name>getenv</name><argument_list>(<argument><expr>"PATH"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>prog</name> <init>= <expr><call><name>Py_GetProgramName</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>argv0_path</name><index>[<expr><name>MAXPATHLEN</name>+1</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>zip_path</name><index>[<expr><name>MAXPATHLEN</name>+1</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>pfound</name></decl>, <decl><type ref="prev"/><name>efound</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>bufsz</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>prefixsz</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>defpath</name> <init>= <expr><name>pythonpath</name></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WITH_NEXT_FRAMEWORK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>NSModule</name></type> <name>pythonModule</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>MAC_OS_X_VERSION_MAX_ALLOWED</name> &gt;= <name>MAC_OS_X_VERSION_10_4</name></expr></cpp:if>
<decl_stmt><decl><type><name>uint32_t</name></type> <name>nsexeclength</name> <init>= <expr><name>MAXPATHLEN</name></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>nsexeclength</name> <init>= <expr><name>MAXPATHLEN</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name>prog</name></expr></argument>, <argument><expr><name>SEP</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>progpath</name></expr></argument>, <argument><expr><name>prog</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<else>else <if>if<condition>(<expr>0 == <call><name>_NSGetExecutablePath</name><argument_list>(<argument><expr><name>progpath</name></expr></argument>, <argument><expr>&amp;<name>nsexeclength</name></expr></argument>)</argument_list></call> &amp;&amp; <name><name>progpath</name><index>[<expr>0</expr>]</index></name> == <name>SEP</name></expr>)</condition><then>
<empty_stmt>;</empty_stmt></then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<else>else <if>if <condition>(<expr><name>path</name></expr>)</condition><then> <block>{
<while>while <condition>(<expr>1</expr>)</condition> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>delim</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>DELIM</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>delim</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><name>delim</name> - <name>path</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>len</name> &gt; <name>MAXPATHLEN</name></expr>)</condition><then>
<expr_stmt><expr><name>len</name> = <name>MAXPATHLEN</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>progpath</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*(<name>progpath</name> + <name>len</name>) = '\0'</expr>;</expr_stmt>
}</block></then> <else>else
<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>progpath</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<expr_stmt><expr><call><name>joinpath</name><argument_list>(<argument><expr><name>progpath</name></expr></argument>, <argument><expr><name>prog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>isxfile</name><argument_list>(<argument><expr><name>progpath</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<break>break;</break></then></if>
<if>if <condition>(<expr>!<name>delim</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>progpath</name><index>[<expr>0</expr>]</index></name> = '\0'</expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
<expr_stmt><expr><name>path</name> = <name>delim</name> + 1</expr>;</expr_stmt>
}</block></while>
}</block></then> <else>else
<expr_stmt><expr><name><name>progpath</name><index>[<expr>0</expr>]</index></name> = '\0'</expr>;</expr_stmt></else></if></else></if></else></if>
<if>if <condition>(<expr><name><name>progpath</name><index>[<expr>0</expr>]</index></name> != <name>SEP</name></expr>)</condition><then>
<expr_stmt><expr><call><name>absolutize</name><argument_list>(<argument><expr><name>progpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>argv0_path</name></expr></argument>, <argument><expr><name>progpath</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>argv0_path</name><index>[<expr><name>MAXPATHLEN</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WITH_NEXT_FRAMEWORK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>pythonModule</name> = <call><name>NSModuleForSymbol</name><argument_list>(<argument><expr><call><name>NSLookupAndBindSymbol</name><argument_list>(<argument><expr>"_Py_Initialize"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>buf</name> = (<name>char</name> *)<call><name>NSLibraryNameForModule</name><argument_list>(<argument><expr><name>pythonModule</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>buf</name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>argv0_path</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>reduce</name><argument_list>(<argument><expr><name>argv0_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>joinpath</name><argument_list>(<argument><expr><name>argv0_path</name></expr></argument>, <argument><expr><name>lib_python</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>joinpath</name><argument_list>(<argument><expr><name>argv0_path</name></expr></argument>, <argument><expr><name>LANDMARK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>ismodule</name><argument_list>(<argument><expr><name>argv0_path</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>argv0_path</name></expr></argument>, <argument><expr><name>prog</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>argv0_path</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>HAVE_READLINK</name></expr></cpp:if>
<block>{
<decl_stmt><decl><type><name>char</name></type> <name><name>tmpbuffer</name><index>[<expr><name>MAXPATHLEN</name>+1</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>linklen</name> <init>= <expr><call><name>readlink</name><argument_list>(<argument><expr><name>progpath</name></expr></argument>, <argument><expr><name>tmpbuffer</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>linklen</name> != -1</expr>)</condition> <block>{
<expr_stmt><expr><name><name>tmpbuffer</name><index>[<expr><name>linklen</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>tmpbuffer</name><index>[<expr>0</expr>]</index></name> == <name>SEP</name></expr>)</condition><then>
<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>argv0_path</name></expr></argument>, <argument><expr><name>tmpbuffer</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else <block>{
<expr_stmt><expr><call><name>reduce</name><argument_list>(<argument><expr><name>argv0_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>joinpath</name><argument_list>(<argument><expr><name>argv0_path</name></expr></argument>, <argument><expr><name>tmpbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><name>linklen</name> = <call><name>readlink</name><argument_list>(<argument><expr><name>argv0_path</name></expr></argument>, <argument><expr><name>tmpbuffer</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></while>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>reduce</name><argument_list>(<argument><expr><name>argv0_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!(<name>pfound</name> = <call><name>search_for_prefix</name><argument_list>(<argument><expr><name>argv0_path</name></expr></argument>, <argument><expr><name>home</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<name>Py_FrozenFlag</name></expr>)</condition><then>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
<argument><expr>"Could not find platform independent libraries &lt;prefix&gt;\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>PREFIX</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>joinpath</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>lib_python</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else
<expr_stmt><expr><call><name>reduce</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>zip_path</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip_path</name><index>[<expr><name>MAXPATHLEN</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
<if>if <condition>(<expr><name>pfound</name> &gt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>reduce</name><argument_list>(<argument><expr><name>zip_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>reduce</name><argument_list>(<argument><expr><name>zip_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else
<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>zip_path</name></expr></argument>, <argument><expr><name>PREFIX</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<expr_stmt><expr><call><name>joinpath</name><argument_list>(<argument><expr><name>zip_path</name></expr></argument>, <argument><expr>"lib/python00.zip"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>bufsz</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>zip_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip_path</name><index>[<expr><name>bufsz</name> - 6</expr>]</index></name> = <name><name>VERSION</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>zip_path</name><index>[<expr><name>bufsz</name> - 5</expr>]</index></name> = <name><name>VERSION</name><index>[<expr>2</expr>]</index></name></expr>;</expr_stmt>
<if>if <condition>(<expr>!(<name>efound</name> = <call><name>search_for_exec_prefix</name><argument_list>(<argument><expr><name>argv0_path</name></expr></argument>, <argument><expr><name>home</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<name>Py_FrozenFlag</name></expr>)</condition><then>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
<argument><expr>"Could not find platform dependent libraries &lt;exec_prefix&gt;\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>exec_prefix</name></expr></argument>, <argument><expr><name>EXEC_PREFIX</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>joinpath</name><argument_list>(<argument><expr><name>exec_prefix</name></expr></argument>, <argument><expr>"lib/lib-dynload"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr>(!<name>pfound</name> || !<name>efound</name>) &amp;&amp; !<name>Py_FrozenFlag</name></expr>)</condition><then>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>,
<argument><expr>"Consider setting $PYTHONHOME to &lt;prefix&gt;[:&lt;exec_prefix&gt;]\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>bufsz</name> = 0</expr>;</expr_stmt>
<if>if <condition>(<expr><name>rtpypath</name></expr>)</condition><then>
<expr_stmt><expr><name>bufsz</name> += <call><name>strlen</name><argument_list>(<argument><expr><name>rtpypath</name></expr></argument>)</argument_list></call> + 1</expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>prefixsz</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call> + 1</expr>;</expr_stmt>
<while>while <condition>(<expr>1</expr>)</condition> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>delim</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>defpath</name></expr></argument>, <argument><expr><name>DELIM</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>defpath</name><index>[<expr>0</expr>]</index></name> != <name>SEP</name></expr>)</condition><then>
<expr_stmt><expr><name>bufsz</name> += <name>prefixsz</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>delim</name></expr>)</condition><then>
<expr_stmt><expr><name>bufsz</name> += <name>delim</name> - <name>defpath</name> + 1</expr>;</expr_stmt></then>
<else>else <block>{
<expr_stmt><expr><name>bufsz</name> += <call><name>strlen</name><argument_list>(<argument><expr><name>defpath</name></expr></argument>)</argument_list></call> + 1</expr>;</expr_stmt>
<break>break;</break>
}</block></else></if>
<expr_stmt><expr><name>defpath</name> = <name>delim</name> + 1</expr>;</expr_stmt>
}</block></while>
<expr_stmt><expr><name>bufsz</name> += <call><name>strlen</name><argument_list>(<argument><expr><name>zip_path</name></expr></argument>)</argument_list></call> + 1</expr>;</expr_stmt>
<expr_stmt><expr><name>bufsz</name> += <call><name>strlen</name><argument_list>(<argument><expr><name>exec_prefix</name></expr></argument>)</argument_list></call> + 1</expr>;</expr_stmt>
<expr_stmt><expr><name>buf</name> = (<name>char</name> *)<call><name>PyMem_Malloc</name><argument_list>(<argument><expr><name>bufsz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>buf</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Not enough memory for dynamic PYTHONPATH.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr>"Using default static PYTHONPATH.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>module_search_path</name> = <name>PYTHONPATH</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<if>if <condition>(<expr><name>rtpypath</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>rtpypath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>delimiter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else
<expr_stmt><expr><name><name>buf</name><index>[<expr>0</expr>]</index></name> = '\0'</expr>;</expr_stmt></else></if>
<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>zip_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>delimiter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>defpath</name> = <name>pythonpath</name></expr>;</expr_stmt>
<while>while <condition>(<expr>1</expr>)</condition> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>delim</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>defpath</name></expr></argument>, <argument><expr><name>DELIM</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>defpath</name><index>[<expr>0</expr>]</index></name> != <name>SEP</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>separator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>delim</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><name>delim</name> - <name>defpath</name> + 1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>end</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call> + <name>len</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>strncat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>defpath</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*(<name>buf</name> + <name>end</name>) = '\0'</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>defpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
}</block></else></if>
<expr_stmt><expr><name>defpath</name> = <name>delim</name> + 1</expr>;</expr_stmt>
}</block></while>
<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>delimiter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>exec_prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>module_search_path</name> = <name>buf</name></expr>;</expr_stmt>
}</block></else></if>
<if>if <condition>(<expr><name>pfound</name> &gt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>reduce</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>reduce</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name><name>prefix</name><index>[<expr>0</expr>]</index></name></expr>)</condition><then>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>separator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></then> <else>else
<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>PREFIX</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<if>if <condition>(<expr><name>efound</name> &gt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>reduce</name><argument_list>(<argument><expr><name>exec_prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>reduce</name><argument_list>(<argument><expr><name>exec_prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>reduce</name><argument_list>(<argument><expr><name>exec_prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name><name>exec_prefix</name><index>[<expr>0</expr>]</index></name></expr>)</condition><then>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>exec_prefix</name></expr></argument>, <argument><expr><name>separator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></then> <else>else
<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>exec_prefix</name></expr></argument>, <argument><expr><name>EXEC_PREFIX</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
}</block></function>
<function><type><name>char</name> *</type>
<name>Py_GetPath</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr>!<name>module_search_path</name></expr>)</condition><then>
<expr_stmt><expr><call><name>calculate_path</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>module_search_path</name></expr>;</return>
}</block></function>
<function><type><name>char</name> *</type>
<name>Py_GetPrefix</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr>!<name>module_search_path</name></expr>)</condition><then>
<expr_stmt><expr><call><name>calculate_path</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>prefix</name></expr>;</return>
}</block></function>
<function><type><name>char</name> *</type>
<name>Py_GetExecPrefix</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr>!<name>module_search_path</name></expr>)</condition><then>
<expr_stmt><expr><call><name>calculate_path</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>exec_prefix</name></expr>;</return>
}</block></function>
<function><type><name>char</name> *</type>
<name>Py_GetProgramFullPath</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr>!<name>module_search_path</name></expr>)</condition><then>
<expr_stmt><expr><call><name>calculate_path</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>progpath</name></expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call></expr></cpp:if>
}</block></extern>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
