<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="Modules/itertoolsmodule.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"structmember.h"</cpp:file></cpp:include>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>PyObject_HEAD</name>
<name>PyObject</name> *</type><name>it</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>keyfunc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>tgtkey</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>currkey</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>currvalue</name></decl>;</decl_stmt>
}</block></struct></type> <name>groupbyobject</name>;</typedef>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>groupby_type</name></decl>;</decl_stmt>
<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>_grouper_create</name><parameter_list>(<param><decl><type><name>groupbyobject</name> *</type></decl></param>, <param><decl><type><name>PyObject</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>groupby_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>kwargs</name><index>[]</index></name> <init>= <expr><block>{<expr>"iterable"</expr>, <expr>"key"</expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>groupbyobject</name> *</type><name>gbo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>it</name></decl>, *<decl><type ref="prev"/><name>keyfunc</name> <init>= <expr><name>Py_None</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>, <argument><expr>"O|O:groupby"</expr></argument>, <argument><expr><name>kwargs</name></expr></argument>,
<argument><expr>&amp;<name>it</name></expr></argument>, <argument><expr>&amp;<name>keyfunc</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>gbo</name> = (<name>groupbyobject</name> *)<call><name><name>type</name>-&gt;<name>tp_alloc</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>gbo</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>gbo</name>-&gt;<name>tgtkey</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>gbo</name>-&gt;<name>currkey</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>gbo</name>-&gt;<name>currvalue</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>gbo</name>-&gt;<name>keyfunc</name></name> = <name>keyfunc</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>keyfunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>gbo</name>-&gt;<name>it</name></name> = <call><name>PyObject_GetIter</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>gbo</name>-&gt;<name>it</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>gbo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr>(<name>PyObject</name> *)<name>gbo</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>groupby_dealloc</name><parameter_list>(<param><decl><type><name>groupbyobject</name> *</type><name>gbo</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>PyObject_GC_UnTrack</name><argument_list>(<argument><expr><name>gbo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>gbo</name>-&gt;<name>it</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>gbo</name>-&gt;<name>keyfunc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>gbo</name>-&gt;<name>tgtkey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>gbo</name>-&gt;<name>currkey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>gbo</name>-&gt;<name>currvalue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>gbo</name></expr></argument>)</argument_list></call>-&gt;<call><name>tp_free</name><argument_list>(<argument><expr><name>gbo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>groupby_traverse</name><parameter_list>(<param><decl><type><name>groupbyobject</name> *</type><name>gbo</name></decl></param>, <param><decl><type><name>visitproc</name></type> <name>visit</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>gbo</name>-&gt;<name>it</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>gbo</name>-&gt;<name>keyfunc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>gbo</name>-&gt;<name>tgtkey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>gbo</name>-&gt;<name>currkey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>gbo</name>-&gt;<name>currvalue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>groupby_next</name><parameter_list>(<param><decl><type><name>groupbyobject</name> *</type><name>gbo</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>newvalue</name></decl>, *<decl><type ref="prev"/><name>newkey</name></decl>, *<decl><type ref="prev"/><name>r</name></decl>, *<decl><type ref="prev"/><name>grouper</name></decl>, *<decl><type ref="prev"/><name>tmp</name></decl>;</decl_stmt>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<if>if <condition>(<expr><name><name>gbo</name>-&gt;<name>currkey</name></name> == <name>NULL</name></expr>)</condition><then>
<empty_stmt>;</empty_stmt></then>
<else>else <if>if <condition>(<expr><name><name>gbo</name>-&gt;<name>tgtkey</name></name> == <name>NULL</name></expr>)</condition><then>
<break>break;</break></then>
<else>else <block>{
<decl_stmt><decl><type><name>int</name></type> <name>rcmp</name></decl>;</decl_stmt>
<expr_stmt><expr><name>rcmp</name> = <call><name>PyObject_RichCompareBool</name><argument_list>(<argument><expr><name><name>gbo</name>-&gt;<name>tgtkey</name></name></expr></argument>,
<argument><expr><name><name>gbo</name>-&gt;<name>currkey</name></name></expr></argument>, <argument><expr><name>Py_EQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rcmp</name> == -1</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then>
<else>else <if>if <condition>(<expr><name>rcmp</name> == 0</expr>)</condition><then>
<break>break;</break></then></if></else></if>
}</block></else></if></else></if>
<expr_stmt><expr><name>newvalue</name> = <call><name>PyIter_Next</name><argument_list>(<argument><expr><name><name>gbo</name>-&gt;<name>it</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>newvalue</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name><name>gbo</name>-&gt;<name>keyfunc</name></name> == <name>Py_None</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>newkey</name> = <name>newvalue</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>newvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>newkey</name> = <call><name>PyObject_CallFunctionObjArgs</name><argument_list>(<argument><expr><name><name>gbo</name>-&gt;<name>keyfunc</name></name></expr></argument>,
<argument><expr><name>newvalue</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>newkey</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>newvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
}</block></else></if>
<expr_stmt><expr><name>tmp</name> = <name><name>gbo</name>-&gt;<name>currkey</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>gbo</name>-&gt;<name>currkey</name></name> = <name>newkey</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tmp</name> = <name><name>gbo</name>-&gt;<name>currvalue</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>gbo</name>-&gt;<name>currvalue</name></name> = <name>newvalue</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name><name>gbo</name>-&gt;<name>currkey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tmp</name> = <name><name>gbo</name>-&gt;<name>tgtkey</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>gbo</name>-&gt;<name>tgtkey</name></name> = <name><name>gbo</name>-&gt;<name>currkey</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>grouper</name> = <call><name>_grouper_create</name><argument_list>(<argument><expr><name>gbo</name></expr></argument>, <argument><expr><name><name>gbo</name>-&gt;<name>tgtkey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>grouper</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>r</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>2</expr></argument>, <argument><expr><name><name>gbo</name>-&gt;<name>currkey</name></name></expr></argument>, <argument><expr><name>grouper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>grouper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>r</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>groupby_doc</name></expr></argument>,
<argument><expr>"groupby(iterable[, keyfunc]) -&gt; create an iterator which returns\n\
(key, sub-iterator) grouped by each value of key(value).\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>groupby_type</name> <init>= <expr><block>{
<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
"itertools.groupby"</expr>,
<expr><sizeof>sizeof<argument_list>(<argument><expr><name>groupbyobject</name></expr></argument>)</argument_list></sizeof></expr>,
<expr>0</expr>,
<expr>(<name>destructor</name>)<name>groupby_dealloc</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>PyObject_GenericGetAttr</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_HAVE_GC</name> |
<name>Py_TPFLAGS_BASETYPE</name></expr>,
<expr><name>groupby_doc</name></expr>,
<expr>(<name>traverseproc</name>)<name>groupby_traverse</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>PyObject_SelfIter</name></expr>,
<expr>(<name>iternextfunc</name>)<name>groupby_next</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>groupby_new</name></expr>,
<expr><name>PyObject_GC_Del</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>PyObject_HEAD</name>
<name>PyObject</name> *</type><name>parent</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>tgtkey</name></decl>;</decl_stmt>
}</block></struct></type> <name>_grouperobject</name>;</typedef>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>_grouper_type</name></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>_grouper_create</name><parameter_list>(<param><decl><type><name>groupbyobject</name> *</type><name>parent</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>tgtkey</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>_grouperobject</name> *</type><name>igo</name></decl>;</decl_stmt>
<expr_stmt><expr><name>igo</name> = <call><name>PyObject_GC_New</name><argument_list>(<argument><expr><name>_grouperobject</name></expr></argument>, <argument><expr>&amp;<name>_grouper_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>igo</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>igo</name>-&gt;<name>parent</name></name> = (<name>PyObject</name> *)<name>parent</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>igo</name>-&gt;<name>tgtkey</name></name> = <name>tgtkey</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>tgtkey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyObject_GC_Track</name><argument_list>(<argument><expr><name>igo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *)<name>igo</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_grouper_dealloc</name><parameter_list>(<param><decl><type><name>_grouperobject</name> *</type><name>igo</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>PyObject_GC_UnTrack</name><argument_list>(<argument><expr><name>igo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name><name>igo</name>-&gt;<name>parent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name><name>igo</name>-&gt;<name>tgtkey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyObject_GC_Del</name><argument_list>(<argument><expr><name>igo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>_grouper_traverse</name><parameter_list>(<param><decl><type><name>_grouperobject</name> *</type><name>igo</name></decl></param>, <param><decl><type><name>visitproc</name></type> <name>visit</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>igo</name>-&gt;<name>parent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>igo</name>-&gt;<name>tgtkey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>_grouper_next</name><parameter_list>(<param><decl><type><name>_grouperobject</name> *</type><name>igo</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>groupbyobject</name> *</type><name>gbo</name> <init>= <expr>(<name>groupbyobject</name> *)<name><name>igo</name>-&gt;<name>parent</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>newvalue</name></decl>, *<decl><type ref="prev"/><name>newkey</name></decl>, *<decl><type ref="prev"/><name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>rcmp</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>gbo</name>-&gt;<name>currvalue</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>newvalue</name> = <call><name>PyIter_Next</name><argument_list>(<argument><expr><name><name>gbo</name>-&gt;<name>it</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>newvalue</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name><name>gbo</name>-&gt;<name>keyfunc</name></name> == <name>Py_None</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>newkey</name> = <name>newvalue</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>newvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>newkey</name> = <call><name>PyObject_CallFunctionObjArgs</name><argument_list>(<argument><expr><name><name>gbo</name>-&gt;<name>keyfunc</name></name></expr></argument>,
<argument><expr><name>newvalue</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>newkey</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>newvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
}</block></else></if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>gbo</name>-&gt;<name>currkey</name></name> == <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>gbo</name>-&gt;<name>currkey</name></name> = <name>newkey</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>gbo</name>-&gt;<name>currvalue</name></name> = <name>newvalue</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>gbo</name>-&gt;<name>currkey</name></name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rcmp</name> = <call><name>PyObject_RichCompareBool</name><argument_list>(<argument><expr><name><name>igo</name>-&gt;<name>tgtkey</name></name></expr></argument>, <argument><expr><name><name>gbo</name>-&gt;<name>currkey</name></name></expr></argument>, <argument><expr><name>Py_EQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rcmp</name> &lt;= 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>r</name> = <name><name>gbo</name>-&gt;<name>currvalue</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>gbo</name>-&gt;<name>currvalue</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>gbo</name>-&gt;<name>currkey</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>r</name></expr>;</return>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>_grouper_type</name> <init>= <expr><block>{
<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
"itertools._grouper"</expr>,
<expr><sizeof>sizeof<argument_list>(<argument><expr><name>_grouperobject</name></expr></argument>)</argument_list></sizeof></expr>,
<expr>0</expr>,
<expr>(<name>destructor</name>)<name>_grouper_dealloc</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>PyObject_GenericGetAttr</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_HAVE_GC</name></expr>,
<expr>0</expr>,
<expr>(<name>traverseproc</name>)<name>_grouper_traverse</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>PyObject_SelfIter</name></expr>,
<expr>(<name>iternextfunc</name>)<name>_grouper_next</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>PyObject_GC_Del</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LINKCELLS</name></cpp:macro> <cpp:value>57</cpp:value></cpp:define>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>PyObject_HEAD</name>
<name>PyObject</name> *</type><name>it</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>numread</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>nextlink</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PyObject</name> *<argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>LINKCELLS</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></struct></type> <name>teedataobject</name>;</typedef>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>PyObject_HEAD</name>
<name>teedataobject</name> *</type><name>dataobj</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>index</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>weakreflist</name></decl>;</decl_stmt>
}</block></struct></type> <name>teeobject</name>;</typedef>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>teedataobject_type</name></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>teedataobject_new</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>it</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>teedataobject</name> *</type><name>tdo</name></decl>;</decl_stmt>
<expr_stmt><expr><name>tdo</name> = <call><name>PyObject_GC_New</name><argument_list>(<argument><expr><name>teedataobject</name></expr></argument>, <argument><expr>&amp;<name>teedataobject_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>tdo</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>tdo</name>-&gt;<name>numread</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>tdo</name>-&gt;<name>nextlink</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tdo</name>-&gt;<name>it</name></name> = <name>it</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyObject_GC_Track</name><argument_list>(<argument><expr><name>tdo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *)<name>tdo</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>teedataobject_jumplink</name><parameter_list>(<param><decl><type><name>teedataobject</name> *</type><name>tdo</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name><name>tdo</name>-&gt;<name>nextlink</name></name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><name><name>tdo</name>-&gt;<name>nextlink</name></name> = <call><name>teedataobject_new</name><argument_list>(<argument><expr><name><name>tdo</name>-&gt;<name>it</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name><name>tdo</name>-&gt;<name>nextlink</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>tdo</name>-&gt;<name>nextlink</name></name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>teedataobject_getitem</name><parameter_list>(<param><decl><type><name>teedataobject</name> *</type><name>tdo</name></decl></param>, <param><decl><type><name>int</name></type> <name>i</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>value</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>i</name> &lt; <name>LINKCELLS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>i</name> &lt; <name><name>tdo</name>-&gt;<name>numread</name></name></expr>)</condition><then>
<expr_stmt><expr><name>value</name> = <name><name>tdo</name>-&gt;<name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></then>
<else>else <block>{
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>i</name> == <name><name>tdo</name>-&gt;<name>numread</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>value</name> = <call><name>PyIter_Next</name><argument_list>(<argument><expr><name><name>tdo</name>-&gt;<name>it</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>value</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>tdo</name>-&gt;<name>numread</name></name>++</expr>;</expr_stmt>
<expr_stmt><expr><name><name>tdo</name>-&gt;<name>values</name><index>[<expr><name>i</name></expr>]</index></name> = <name>value</name></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>value</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>teedataobject_traverse</name><parameter_list>(<param><decl><type><name>teedataobject</name> *</type><name>tdo</name></decl></param>, <param><decl><type><name>visitproc</name></type> <name>visit</name></decl></param>, <param><decl><type><name>void</name> *</type> <name>arg</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>tdo</name>-&gt;<name>it</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>tdo</name>-&gt;<name>numread</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>tdo</name>-&gt;<name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>tdo</name>-&gt;<name>nextlink</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>teedataobject_clear</name><parameter_list>(<param><decl><type><name>teedataobject</name> *</type><name>tdo</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>tdo</name>-&gt;<name>it</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name>=0</expr> ;</init> <condition><expr><name>i</name>&lt;<name><name>tdo</name>-&gt;<name>numread</name></name></expr> ;</condition> <incr><expr><name>i</name>++</expr></incr>)
<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>tdo</name>-&gt;<name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>tdo</name>-&gt;<name>nextlink</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>teedataobject_dealloc</name><parameter_list>(<param><decl><type><name>teedataobject</name> *</type><name>tdo</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>PyObject_GC_UnTrack</name><argument_list>(<argument><expr><name>tdo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>teedataobject_clear</name><argument_list>(<argument><expr><name>tdo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyObject_GC_Del</name><argument_list>(<argument><expr><name>tdo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>teedataobject_doc</name></expr></argument>, <argument><expr>"Data container common to multiple tee objects."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>teedataobject_type</name> <init>= <expr><block>{
<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
"itertools.tee_dataobject"</expr>,
<expr><sizeof>sizeof<argument_list>(<argument><expr><name>teedataobject</name></expr></argument>)</argument_list></sizeof></expr>,
<expr>0</expr>,
<expr>(<name>destructor</name>)<name>teedataobject_dealloc</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>PyObject_GenericGetAttr</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_HAVE_GC</name></expr>,
<expr><name>teedataobject_doc</name></expr>,
<expr>(<name>traverseproc</name>)<name>teedataobject_traverse</name></expr>,
<expr>(<name>inquiry</name>)<name>teedataobject_clear</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>PyObject_GC_Del</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>tee_type</name></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>tee_next</name><parameter_list>(<param><decl><type><name>teeobject</name> *</type><name>to</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>value</name></decl>, *<decl><type ref="prev"/><name>link</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>to</name>-&gt;<name>index</name></name> &gt;= <name>LINKCELLS</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>link</name> = <call><name>teedataobject_jumplink</name><argument_list>(<argument><expr><name><name>to</name>-&gt;<name>dataobj</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name><name>to</name>-&gt;<name>dataobj</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>to</name>-&gt;<name>dataobj</name></name> = (<name>teedataobject</name> *)<name>link</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>to</name>-&gt;<name>index</name></name> = 0</expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>value</name> = <call><name>teedataobject_getitem</name><argument_list>(<argument><expr><name><name>to</name>-&gt;<name>dataobj</name></name></expr></argument>, <argument><expr><name><name>to</name>-&gt;<name>index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>value</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>to</name>-&gt;<name>index</name></name>++</expr>;</expr_stmt>
<return>return <expr><name>value</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>tee_traverse</name><parameter_list>(<param><decl><type><name>teeobject</name> *</type><name>to</name></decl></param>, <param><decl><type><name>visitproc</name></type> <name>visit</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name><name>to</name>-&gt;<name>dataobj</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>tee_copy</name><parameter_list>(<param><decl><type><name>teeobject</name> *</type><name>to</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>teeobject</name> *</type><name>newto</name></decl>;</decl_stmt>
<expr_stmt><expr><name>newto</name> = <call><name>PyObject_GC_New</name><argument_list>(<argument><expr><name>teeobject</name></expr></argument>, <argument><expr>&amp;<name>tee_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>newto</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name><name>to</name>-&gt;<name>dataobj</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newto</name>-&gt;<name>dataobj</name></name> = <name><name>to</name>-&gt;<name>dataobj</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newto</name>-&gt;<name>index</name></name> = <name><name>to</name>-&gt;<name>index</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newto</name>-&gt;<name>weakreflist</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyObject_GC_Track</name><argument_list>(<argument><expr><name>newto</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *)<name>newto</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>teecopy_doc</name></expr></argument>, <argument><expr>"Returns an independent iterator."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>tee_fromiterable</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>iterable</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>teeobject</name> *</type><name>to</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>it</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>it</name> = <call><name>PyObject_GetIter</name><argument_list>(<argument><expr><name>iterable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>it</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>PyObject_TypeCheck</name><argument_list>(<argument><expr><name>it</name></expr></argument>, <argument><expr>&amp;<name>tee_type</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>to</name> = (<name>teeobject</name> *)<call><name>tee_copy</name><argument_list>(<argument><expr>(<name>teeobject</name> *)<name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>done</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>to</name> = <call><name>PyObject_GC_New</name><argument_list>(<argument><expr><name>teeobject</name></expr></argument>, <argument><expr>&amp;<name>tee_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>to</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>done</name>;</goto></then></if>
<expr_stmt><expr><name><name>to</name>-&gt;<name>dataobj</name></name> = (<name>teedataobject</name> *)<call><name>teedataobject_new</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name><name>to</name>-&gt;<name>dataobj</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyObject_GC_Del</name><argument_list>(<argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>to</name> = <name>NULL</name></expr>;</expr_stmt>
<goto>goto <name>done</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name><name>to</name>-&gt;<name>index</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>to</name>-&gt;<name>weakreflist</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyObject_GC_Track</name><argument_list>(<argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>done</name>:</label>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *)<name>to</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>tee_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kw</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>iterable</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"tee"</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>&amp;<name>iterable</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>tee_fromiterable</name><argument_list>(<argument><expr><name>iterable</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>tee_clear</name><parameter_list>(<param><decl><type><name>teeobject</name> *</type><name>to</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name><name>to</name>-&gt;<name>weakreflist</name></name> != <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyObject_ClearWeakRefs</name><argument_list>(<argument><expr>(<name>PyObject</name> *) <name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>to</name>-&gt;<name>dataobj</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>tee_dealloc</name><parameter_list>(<param><decl><type><name>teeobject</name> *</type><name>to</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>PyObject_GC_UnTrack</name><argument_list>(<argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>tee_clear</name><argument_list>(<argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyObject_GC_Del</name><argument_list>(<argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>teeobject_doc</name></expr></argument>,
<argument><expr>"Iterator wrapped to make it copyable"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>tee_methods</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr>"__copy__"</expr>, <expr>(<name>PyCFunction</name>)<name>tee_copy</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>teecopy_doc</name></expr>}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>tee_type</name> <init>= <expr><block>{
<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
"itertools.tee"</expr>,
<expr><sizeof>sizeof<argument_list>(<argument><expr><name>teeobject</name></expr></argument>)</argument_list></sizeof></expr>,
<expr>0</expr>,
<expr>(<name>destructor</name>)<name>tee_dealloc</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_HAVE_GC</name></expr>,
<expr><name>teeobject_doc</name></expr>,
<expr>(<name>traverseproc</name>)<name>tee_traverse</name></expr>,
<expr>(<name>inquiry</name>)<name>tee_clear</name></expr>,
<expr>0</expr>,
<expr><call><name>offsetof</name><argument_list>(<argument><expr><name>teeobject</name></expr></argument>, <argument><expr><name>weakreflist</name></expr></argument>)</argument_list></call></expr>,
<expr><name>PyObject_SelfIter</name></expr>,
<expr>(<name>iternextfunc</name>)<name>tee_next</name></expr>,
<expr><name>tee_methods</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>tee_new</name></expr>,
<expr><name>PyObject_GC_Del</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>tee</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name><init>=<expr>2</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>it</name></decl>, *<decl><type ref="prev"/><name>iterable</name></decl>, *<decl><type ref="prev"/><name>copyable</name></decl>, *<decl><type ref="prev"/><name>result</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O|n"</expr></argument>, <argument><expr>&amp;<name>iterable</name></expr></argument>, <argument><expr>&amp;<name>n</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>n</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"n must be &gt;= 0"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>result</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>n</name> == 0</expr>)</condition><then>
<return>return <expr><name>result</name></expr>;</return></then></if>
<expr_stmt><expr><name>it</name> = <call><name>PyObject_GetIter</name><argument_list>(<argument><expr><name>iterable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>it</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>!<call><name>PyObject_HasAttrString</name><argument_list>(<argument><expr><name>it</name></expr></argument>, <argument><expr>"__copy__"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>copyable</name> = <call><name>tee_fromiterable</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>copyable</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
}</block></then> <else>else
<expr_stmt><expr><name>copyable</name> = <name>it</name></expr>;</expr_stmt></else></if>
<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>copyable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name>=1</expr> ;</init> <condition><expr><name>i</name>&lt;<name>n</name></expr> ;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><name>copyable</name> = <call><name>PyObject_CallMethod</name><argument_list>(<argument><expr><name>copyable</name></expr></argument>, <argument><expr>"__copy__"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>copyable</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>copyable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>tee_doc</name></expr></argument>,
<argument><expr>"tee(iterable, n=2) --&gt; tuple of n independent iterators."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>PyObject_HEAD</name>
<name>PyObject</name> *</type><name>it</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>saved</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>firstpass</name></decl>;</decl_stmt>
}</block></struct></type> <name>cycleobject</name>;</typedef>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>cycle_type</name></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>cycle_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>it</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>iterable</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>saved</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>cycleobject</name> *</type><name>lz</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>type</name> == &amp;<name>cycle_type</name> &amp;&amp; !<call><name>_PyArg_NoKeywords</name><argument_list>(<argument><expr>"cycle()"</expr></argument>, <argument><expr><name>kwds</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"cycle"</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>&amp;<name>iterable</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>it</name> = <call><name>PyObject_GetIter</name><argument_list>(<argument><expr><name>iterable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>it</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>saved</name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>saved</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>lz</name> = (<name>cycleobject</name> *)<call><name><name>type</name>-&gt;<name>tp_alloc</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>lz</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>saved</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>lz</name>-&gt;<name>it</name></name> = <name>it</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lz</name>-&gt;<name>saved</name></name> = <name>saved</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lz</name>-&gt;<name>firstpass</name></name> = 0</expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *)<name>lz</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>cycle_dealloc</name><parameter_list>(<param><decl><type><name>cycleobject</name> *</type><name>lz</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>PyObject_GC_UnTrack</name><argument_list>(<argument><expr><name>lz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>saved</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>it</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>lz</name></expr></argument>)</argument_list></call>-&gt;<call><name>tp_free</name><argument_list>(<argument><expr><name>lz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>cycle_traverse</name><parameter_list>(<param><decl><type><name>cycleobject</name> *</type><name>lz</name></decl></param>, <param><decl><type><name>visitproc</name></type> <name>visit</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>it</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>saved</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>cycle_next</name><parameter_list>(<param><decl><type><name>cycleobject</name> *</type><name>lz</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>item</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>it</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>tmp</name></decl>;</decl_stmt>
<while>while <condition>(<expr>1</expr>)</condition> <block>{
<expr_stmt><expr><name>item</name> = <call><name>PyIter_Next</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>it</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>item</name> != <name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<name><name>lz</name>-&gt;<name>firstpass</name></name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyList_Append</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>saved</name></name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>item</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_StopIteration</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
<else>else
<return>return <expr><name>NULL</name></expr>;</return></else></if>
}</block></then></if>
<if>if <condition>(<expr><call><name>PyList_Size</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>saved</name></name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>it</name> = <call><name>PyObject_GetIter</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>saved</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>it</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>tmp</name> = <name><name>lz</name>-&gt;<name>it</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lz</name>-&gt;<name>it</name></name> = <name>it</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lz</name>-&gt;<name>firstpass</name></name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></while>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>cycle_doc</name></expr></argument>,
<argument><expr>"cycle(iterable) --&gt; cycle object\n\
\n\
Return elements from the iterable until it is exhausted.\n\
Then repeat the sequence indefinitely."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>cycle_type</name> <init>= <expr><block>{
<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
"itertools.cycle"</expr>,
<expr><sizeof>sizeof<argument_list>(<argument><expr><name>cycleobject</name></expr></argument>)</argument_list></sizeof></expr>,
<expr>0</expr>,
<expr>(<name>destructor</name>)<name>cycle_dealloc</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>PyObject_GenericGetAttr</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_HAVE_GC</name> |
<name>Py_TPFLAGS_BASETYPE</name></expr>,
<expr><name>cycle_doc</name></expr>,
<expr>(<name>traverseproc</name>)<name>cycle_traverse</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>PyObject_SelfIter</name></expr>,
<expr>(<name>iternextfunc</name>)<name>cycle_next</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>cycle_new</name></expr>,
<expr><name>PyObject_GC_Del</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>PyObject_HEAD</name>
<name>PyObject</name> *</type><name>func</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>it</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>start</name></decl>;</decl_stmt>
}</block></struct></type> <name>dropwhileobject</name>;</typedef>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>dropwhile_type</name></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>dropwhile_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>func</name></decl>, *<decl><type ref="prev"/><name>seq</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>it</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dropwhileobject</name> *</type><name>lz</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>type</name> == &amp;<name>dropwhile_type</name> &amp;&amp; !<call><name>_PyArg_NoKeywords</name><argument_list>(<argument><expr>"dropwhile()"</expr></argument>, <argument><expr><name>kwds</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"dropwhile"</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>&amp;<name>func</name></expr></argument>, <argument><expr>&amp;<name>seq</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>it</name> = <call><name>PyObject_GetIter</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>it</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>lz</name> = (<name>dropwhileobject</name> *)<call><name><name>type</name>-&gt;<name>tp_alloc</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>lz</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lz</name>-&gt;<name>func</name></name> = <name>func</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lz</name>-&gt;<name>it</name></name> = <name>it</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lz</name>-&gt;<name>start</name></name> = 0</expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *)<name>lz</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dropwhile_dealloc</name><parameter_list>(<param><decl><type><name>dropwhileobject</name> *</type><name>lz</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>PyObject_GC_UnTrack</name><argument_list>(<argument><expr><name>lz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>func</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>it</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>lz</name></expr></argument>)</argument_list></call>-&gt;<call><name>tp_free</name><argument_list>(<argument><expr><name>lz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>dropwhile_traverse</name><parameter_list>(<param><decl><type><name>dropwhileobject</name> *</type><name>lz</name></decl></param>, <param><decl><type><name>visitproc</name></type> <name>visit</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>it</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>func</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>dropwhile_next</name><parameter_list>(<param><decl><type><name>dropwhileobject</name> *</type><name>lz</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>item</name></decl>, *<decl><type ref="prev"/><name>good</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>it</name> <init>= <expr><name><name>lz</name>-&gt;<name>it</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>ok</name></decl>;</decl_stmt>
<function_decl><type><name>PyObject</name> *</type>(*<name>iternext</name>)<parameter_list>(<param><decl><type><name>PyObject</name> *</type></decl></param>)</parameter_list>;</function_decl>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyIter_Check</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>iternext</name> = *<call><name>Py_TYPE</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call>-&gt;<name>tp_iternext</name></expr>;</expr_stmt>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<expr_stmt><expr><name>item</name> = <call><name>iternext</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>item</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name><name>lz</name>-&gt;<name>start</name></name> == 1</expr>)</condition><then>
<return>return <expr><name>item</name></expr>;</return></then></if>
<expr_stmt><expr><name>good</name> = <call><name>PyObject_CallFunctionObjArgs</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>func</name></name></expr></argument>, <argument><expr><name>item</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>good</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>ok</name> = <call><name>PyObject_IsTrue</name><argument_list>(<argument><expr><name>good</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>good</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>ok</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>lz</name>-&gt;<name>start</name></name> = 1</expr>;</expr_stmt>
<return>return <expr><name>item</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>dropwhile_doc</name></expr></argument>,
<argument><expr>"dropwhile(predicate, iterable) --&gt; dropwhile object\n\
\n\
Drop items from the iterable while predicate(item) is true.\n\
Afterwards, return every element until the iterable is exhausted."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>dropwhile_type</name> <init>= <expr><block>{
<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
"itertools.dropwhile"</expr>,
<expr><sizeof>sizeof<argument_list>(<argument><expr><name>dropwhileobject</name></expr></argument>)</argument_list></sizeof></expr>,
<expr>0</expr>,
<expr>(<name>destructor</name>)<name>dropwhile_dealloc</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>PyObject_GenericGetAttr</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_HAVE_GC</name> |
<name>Py_TPFLAGS_BASETYPE</name></expr>,
<expr><name>dropwhile_doc</name></expr>,
<expr>(<name>traverseproc</name>)<name>dropwhile_traverse</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>PyObject_SelfIter</name></expr>,
<expr>(<name>iternextfunc</name>)<name>dropwhile_next</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>dropwhile_new</name></expr>,
<expr><name>PyObject_GC_Del</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>PyObject_HEAD</name>
<name>PyObject</name> *</type><name>func</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>it</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>stop</name></decl>;</decl_stmt>
}</block></struct></type> <name>takewhileobject</name>;</typedef>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>takewhile_type</name></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>takewhile_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>func</name></decl>, *<decl><type ref="prev"/><name>seq</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>it</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>takewhileobject</name> *</type><name>lz</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>type</name> == &amp;<name>takewhile_type</name> &amp;&amp; !<call><name>_PyArg_NoKeywords</name><argument_list>(<argument><expr>"takewhile()"</expr></argument>, <argument><expr><name>kwds</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"takewhile"</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>&amp;<name>func</name></expr></argument>, <argument><expr>&amp;<name>seq</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>it</name> = <call><name>PyObject_GetIter</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>it</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>lz</name> = (<name>takewhileobject</name> *)<call><name><name>type</name>-&gt;<name>tp_alloc</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>lz</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lz</name>-&gt;<name>func</name></name> = <name>func</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lz</name>-&gt;<name>it</name></name> = <name>it</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lz</name>-&gt;<name>stop</name></name> = 0</expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *)<name>lz</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>takewhile_dealloc</name><parameter_list>(<param><decl><type><name>takewhileobject</name> *</type><name>lz</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>PyObject_GC_UnTrack</name><argument_list>(<argument><expr><name>lz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>func</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>it</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>lz</name></expr></argument>)</argument_list></call>-&gt;<call><name>tp_free</name><argument_list>(<argument><expr><name>lz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>takewhile_traverse</name><parameter_list>(<param><decl><type><name>takewhileobject</name> *</type><name>lz</name></decl></param>, <param><decl><type><name>visitproc</name></type> <name>visit</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>it</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>func</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>takewhile_next</name><parameter_list>(<param><decl><type><name>takewhileobject</name> *</type><name>lz</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>item</name></decl>, *<decl><type ref="prev"/><name>good</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>it</name> <init>= <expr><name><name>lz</name>-&gt;<name>it</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>ok</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>lz</name>-&gt;<name>stop</name></name> == 1</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyIter_Check</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>item</name> = (*<call><name>Py_TYPE</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call>-&gt;<name>tp_iternext</name>)(<name>it</name>)</expr>;</expr_stmt>
<if>if <condition>(<expr><name>item</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>good</name> = <call><name>PyObject_CallFunctionObjArgs</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>func</name></name></expr></argument>, <argument><expr><name>item</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>good</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>ok</name> = <call><name>PyObject_IsTrue</name><argument_list>(<argument><expr><name>good</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>good</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ok</name></expr>)</condition><then>
<return>return <expr><name>item</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lz</name>-&gt;<name>stop</name></name> = 1</expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>takewhile_doc</name></expr></argument>,
<argument><expr>"takewhile(predicate, iterable) --&gt; takewhile object\n\
\n\
Return successive entries from an iterable as long as the \n\
predicate evaluates to true for each entry."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>takewhile_type</name> <init>= <expr><block>{
<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
"itertools.takewhile"</expr>,
<expr><sizeof>sizeof<argument_list>(<argument><expr><name>takewhileobject</name></expr></argument>)</argument_list></sizeof></expr>,
<expr>0</expr>,
<expr>(<name>destructor</name>)<name>takewhile_dealloc</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>PyObject_GenericGetAttr</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_HAVE_GC</name> |
<name>Py_TPFLAGS_BASETYPE</name></expr>,
<expr><name>takewhile_doc</name></expr>,
<expr>(<name>traverseproc</name>)<name>takewhile_traverse</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>PyObject_SelfIter</name></expr>,
<expr>(<name>iternextfunc</name>)<name>takewhile_next</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>takewhile_new</name></expr>,
<expr><name>PyObject_GC_Del</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>PyObject_HEAD</name>
<name>PyObject</name> *</type><name>it</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>next</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>stop</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>step</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>cnt</name></decl>;</decl_stmt>
}</block></struct></type> <name>isliceobject</name>;</typedef>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>islice_type</name></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>islice_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>seq</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>start</name><init>=<expr>0</expr></init>, <name>stop</name><init>=<expr>-1</expr></init>, <name>step</name><init>=<expr>1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>it</name></decl>, *<decl><type ref="prev"/><name>a1</name><init>=<expr><name>NULL</name></expr></init>, *<name>a2</name><init>=<expr><name>NULL</name></expr></init>, *<name>a3</name><init>=<expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>numargs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>isliceobject</name> *</type><name>lz</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>type</name> == &amp;<name>islice_type</name> &amp;&amp; !<call><name>_PyArg_NoKeywords</name><argument_list>(<argument><expr>"islice()"</expr></argument>, <argument><expr><name>kwds</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"islice"</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>4</expr></argument>, <argument><expr>&amp;<name>seq</name></expr></argument>, <argument><expr>&amp;<name>a1</name></expr></argument>, <argument><expr>&amp;<name>a2</name></expr></argument>, <argument><expr>&amp;<name>a3</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>numargs</name> = <call><name>PyTuple_Size</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>numargs</name> == 2</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>a1</name> != <name>Py_None</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>stop</name> = <call><name>PyInt_AsSsize_t</name><argument_list>(<argument><expr><name>a1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>stop</name> == -1</expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"Stop argument for islice() must be a non-negative integer or None."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
}</block></then></if>
}</block></then> <else>else <block>{
<if>if <condition>(<expr><name>a1</name> != <name>Py_None</name></expr>)</condition><then>
<expr_stmt><expr><name>start</name> = <call><name>PyInt_AsSsize_t</name><argument_list>(<argument><expr><name>a1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>start</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>a2</name> != <name>Py_None</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>stop</name> = <call><name>PyInt_AsSsize_t</name><argument_list>(<argument><expr><name>a2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>stop</name> == -1</expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"Stop argument for islice() must be a non-negative integer or None."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
}</block></then></if>
}</block></else></if>
<if>if <condition>(<expr><name>start</name>&lt;0 || <name>stop</name>&lt;-1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"Indices for islice() must be non-negative integers or None."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>a3</name> != <name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>a3</name> != <name>Py_None</name></expr>)</condition><then>
<expr_stmt><expr><name>step</name> = <call><name>PyInt_AsSsize_t</name><argument_list>(<argument><expr><name>a3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>step</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
}</block></then></if>
<if>if <condition>(<expr><name>step</name>&lt;1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"Step for islice() must be a positive integer or None."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>it</name> = <call><name>PyObject_GetIter</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>it</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>lz</name> = (<name>isliceobject</name> *)<call><name><name>type</name>-&gt;<name>tp_alloc</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>lz</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>lz</name>-&gt;<name>it</name></name> = <name>it</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lz</name>-&gt;<name>next</name></name> = <name>start</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lz</name>-&gt;<name>stop</name></name> = <name>stop</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lz</name>-&gt;<name>step</name></name> = <name>step</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lz</name>-&gt;<name>cnt</name></name> = 0L</expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *)<name>lz</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>islice_dealloc</name><parameter_list>(<param><decl><type><name>isliceobject</name> *</type><name>lz</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>PyObject_GC_UnTrack</name><argument_list>(<argument><expr><name>lz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>it</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>lz</name></expr></argument>)</argument_list></call>-&gt;<call><name>tp_free</name><argument_list>(<argument><expr><name>lz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>islice_traverse</name><parameter_list>(<param><decl><type><name>isliceobject</name> *</type><name>lz</name></decl></param>, <param><decl><type><name>visitproc</name></type> <name>visit</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>it</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>islice_next</name><parameter_list>(<param><decl><type><name>isliceobject</name> *</type><name>lz</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>item</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>it</name> <init>= <expr><name><name>lz</name>-&gt;<name>it</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>oldnext</name></decl>;</decl_stmt>
<function_decl><type><name>PyObject</name> *</type>(*<name>iternext</name>)<parameter_list>(<param><decl><type><name>PyObject</name> *</type></decl></param>)</parameter_list>;</function_decl>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyIter_Check</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>iternext</name> = *<call><name>Py_TYPE</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call>-&gt;<name>tp_iternext</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name><name>lz</name>-&gt;<name>cnt</name></name> &lt; <name><name>lz</name>-&gt;<name>next</name></name></expr>)</condition> <block>{
<expr_stmt><expr><name>item</name> = <call><name>iternext</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>item</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lz</name>-&gt;<name>cnt</name></name>++</expr>;</expr_stmt>
}</block></while>
<if>if <condition>(<expr><name><name>lz</name>-&gt;<name>stop</name></name> != -1 &amp;&amp; <name><name>lz</name>-&gt;<name>cnt</name></name> &gt;= <name><name>lz</name>-&gt;<name>stop</name></name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyIter_Check</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>item</name> = <call><name>iternext</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>item</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>lz</name>-&gt;<name>cnt</name></name>++</expr>;</expr_stmt>
<expr_stmt><expr><name>oldnext</name> = <name><name>lz</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lz</name>-&gt;<name>next</name></name> += <name><name>lz</name>-&gt;<name>step</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>lz</name>-&gt;<name>next</name></name> &lt; <name>oldnext</name></expr>)</condition><then>
<expr_stmt><expr><name><name>lz</name>-&gt;<name>next</name></name> = <name><name>lz</name>-&gt;<name>stop</name></name></expr>;</expr_stmt></then></if>
<return>return <expr><name>item</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>islice_doc</name></expr></argument>,
<argument><expr>"islice(iterable, [start,] stop [, step]) --&gt; islice object\n\
\n\
Return an iterator whose next() method returns selected values from an\n\
iterable. If start is specified, will skip all preceding elements;\n\
otherwise, start defaults to zero. Step defaults to one. If\n\
specified as another value, step determines how many values are \n\
skipped between successive calls. Works like a slice() on a list\n\
but returns an iterator."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>islice_type</name> <init>= <expr><block>{
<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
"itertools.islice"</expr>,
<expr><sizeof>sizeof<argument_list>(<argument><expr><name>isliceobject</name></expr></argument>)</argument_list></sizeof></expr>,
<expr>0</expr>,
<expr>(<name>destructor</name>)<name>islice_dealloc</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>PyObject_GenericGetAttr</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_HAVE_GC</name> |
<name>Py_TPFLAGS_BASETYPE</name></expr>,
<expr><name>islice_doc</name></expr>,
<expr>(<name>traverseproc</name>)<name>islice_traverse</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>PyObject_SelfIter</name></expr>,
<expr>(<name>iternextfunc</name>)<name>islice_next</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>islice_new</name></expr>,
<expr><name>PyObject_GC_Del</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>PyObject_HEAD</name>
<name>PyObject</name> *</type><name>func</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>it</name></decl>;</decl_stmt>
}</block></struct></type> <name>starmapobject</name>;</typedef>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>starmap_type</name></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>starmap_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>func</name></decl>, *<decl><type ref="prev"/><name>seq</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>it</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>starmapobject</name> *</type><name>lz</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>type</name> == &amp;<name>starmap_type</name> &amp;&amp; !<call><name>_PyArg_NoKeywords</name><argument_list>(<argument><expr>"starmap()"</expr></argument>, <argument><expr><name>kwds</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"starmap"</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>&amp;<name>func</name></expr></argument>, <argument><expr>&amp;<name>seq</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>it</name> = <call><name>PyObject_GetIter</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>it</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>lz</name> = (<name>starmapobject</name> *)<call><name><name>type</name>-&gt;<name>tp_alloc</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>lz</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lz</name>-&gt;<name>func</name></name> = <name>func</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lz</name>-&gt;<name>it</name></name> = <name>it</name></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *)<name>lz</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>starmap_dealloc</name><parameter_list>(<param><decl><type><name>starmapobject</name> *</type><name>lz</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>PyObject_GC_UnTrack</name><argument_list>(<argument><expr><name>lz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>func</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>it</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>lz</name></expr></argument>)</argument_list></call>-&gt;<call><name>tp_free</name><argument_list>(<argument><expr><name>lz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>starmap_traverse</name><parameter_list>(<param><decl><type><name>starmapobject</name> *</type><name>lz</name></decl></param>, <param><decl><type><name>visitproc</name></type> <name>visit</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>it</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>func</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>starmap_next</name><parameter_list>(<param><decl><type><name>starmapobject</name> *</type><name>lz</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>args</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>it</name> <init>= <expr><name><name>lz</name>-&gt;<name>it</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyIter_Check</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>args</name> = (*<call><name>Py_TYPE</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call>-&gt;<name>tp_iternext</name>)(<name>it</name>)</expr>;</expr_stmt>
<if>if <condition>(<expr><name>args</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>PyTuple_CheckExact</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>newargs</name> <init>= <expr><call><name>PySequence_Tuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>newargs</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>args</name> = <name>newargs</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>result</name> = <call><name>PyObject_Call</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>func</name></name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>starmap_doc</name></expr></argument>,
<argument><expr>"starmap(function, sequence) --&gt; starmap object\n\
\n\
Return an iterator whose values are returned from the function evaluated\n\
with a argument tuple taken from the given sequence."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>starmap_type</name> <init>= <expr><block>{
<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
"itertools.starmap"</expr>,
<expr><sizeof>sizeof<argument_list>(<argument><expr><name>starmapobject</name></expr></argument>)</argument_list></sizeof></expr>,
<expr>0</expr>,
<expr>(<name>destructor</name>)<name>starmap_dealloc</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>PyObject_GenericGetAttr</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_HAVE_GC</name> |
<name>Py_TPFLAGS_BASETYPE</name></expr>,
<expr><name>starmap_doc</name></expr>,
<expr>(<name>traverseproc</name>)<name>starmap_traverse</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>PyObject_SelfIter</name></expr>,
<expr>(<name>iternextfunc</name>)<name>starmap_next</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>starmap_new</name></expr>,
<expr><name>PyObject_GC_Del</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>PyObject_HEAD</name>
<name>PyObject</name> *</type><name>iters</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>func</name></decl>;</decl_stmt>
}</block></struct></type> <name>imapobject</name>;</typedef>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>imap_type</name></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>imap_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>it</name></decl>, *<decl><type ref="prev"/><name>iters</name></decl>, *<decl><type ref="prev"/><name>func</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>imapobject</name> *</type><name>lz</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>numargs</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>type</name> == &amp;<name>imap_type</name> &amp;&amp; !<call><name>_PyArg_NoKeywords</name><argument_list>(<argument><expr>"imap()"</expr></argument>, <argument><expr><name>kwds</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>numargs</name> = <call><name>PyTuple_Size</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>numargs</name> &lt; 2</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"imap() must have at least two arguments."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>iters</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr><name>numargs</name>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>iters</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<for>for (<init><expr><name>i</name>=1</expr> ;</init> <condition><expr><name>i</name>&lt;<name>numargs</name></expr> ;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><name>it</name> = <call><name>PyObject_GetIter</name><argument_list>(<argument><expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>it</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>iters</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>iters</name></expr></argument>, <argument><expr><name>i</name>-1</expr></argument>, <argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><name>lz</name> = (<name>imapobject</name> *)<call><name><name>type</name>-&gt;<name>tp_alloc</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>lz</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>iters</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>lz</name>-&gt;<name>iters</name></name> = <name>iters</name></expr>;</expr_stmt>
<expr_stmt><expr><name>func</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lz</name>-&gt;<name>func</name></name> = <name>func</name></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *)<name>lz</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>imap_dealloc</name><parameter_list>(<param><decl><type><name>imapobject</name> *</type><name>lz</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>PyObject_GC_UnTrack</name><argument_list>(<argument><expr><name>lz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>iters</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>func</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>lz</name></expr></argument>)</argument_list></call>-&gt;<call><name>tp_free</name><argument_list>(<argument><expr><name>lz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>imap_traverse</name><parameter_list>(<param><decl><type><name>imapobject</name> *</type><name>lz</name></decl></param>, <param><decl><type><name>visitproc</name></type> <name>visit</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>iters</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>func</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>imap_next</name><parameter_list>(<param><decl><type><name>imapobject</name> *</type><name>lz</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>val</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>argtuple</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>numargs</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><name>numargs</name> = <call><name>PyTuple_Size</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>iters</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>argtuple</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr><name>numargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>argtuple</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<for>for (<init><expr><name>i</name>=0</expr> ;</init> <condition><expr><name>i</name>&lt;<name>numargs</name></expr> ;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><name>val</name> = <call><name>PyIter_Next</name><argument_list>(<argument><expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>iters</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>val</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>argtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>argtuple</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<if>if <condition>(<expr><name><name>lz</name>-&gt;<name>func</name></name> == <name>Py_None</name></expr>)</condition><then>
<return>return <expr><name>argtuple</name></expr>;</return></then></if>
<expr_stmt><expr><name>result</name> = <call><name>PyObject_Call</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>func</name></name></expr></argument>, <argument><expr><name>argtuple</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>argtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>imap_doc</name></expr></argument>,
<argument><expr>"imap(func, *iterables) --&gt; imap object\n\
\n\
Make an iterator that computes the function using arguments from\n\
each of the iterables. Like map() except that it returns\n\
an iterator instead of a list and that it stops when the shortest\n\
iterable is exhausted instead of filling in None for shorter\n\
iterables."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>imap_type</name> <init>= <expr><block>{
<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
"itertools.imap"</expr>,
<expr><sizeof>sizeof<argument_list>(<argument><expr><name>imapobject</name></expr></argument>)</argument_list></sizeof></expr>,
<expr>0</expr>,
<expr>(<name>destructor</name>)<name>imap_dealloc</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>PyObject_GenericGetAttr</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_HAVE_GC</name> |
<name>Py_TPFLAGS_BASETYPE</name></expr>,
<expr><name>imap_doc</name></expr>,
<expr>(<name>traverseproc</name>)<name>imap_traverse</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>PyObject_SelfIter</name></expr>,
<expr>(<name>iternextfunc</name>)<name>imap_next</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>imap_new</name></expr>,
<expr><name>PyObject_GC_Del</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>PyObject_HEAD</name>
<name>PyObject</name> *</type><name>source</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>active</name></decl>;</decl_stmt>
}</block></struct></type> <name>chainobject</name>;</typedef>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>chain_type</name></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>chain_new_internal</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>source</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>chainobject</name> *</type><name>lz</name></decl>;</decl_stmt>
<expr_stmt><expr><name>lz</name> = (<name>chainobject</name> *)<call><name><name>type</name>-&gt;<name>tp_alloc</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>lz</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>lz</name>-&gt;<name>source</name></name> = <name>source</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lz</name>-&gt;<name>active</name></name> = <name>NULL</name></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *)<name>lz</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>chain_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>source</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>type</name> == &amp;<name>chain_type</name> &amp;&amp; !<call><name>_PyArg_NoKeywords</name><argument_list>(<argument><expr>"chain()"</expr></argument>, <argument><expr><name>kwds</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>source</name> = <call><name>PyObject_GetIter</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>source</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>chain_new_internal</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>chain_new_from_iterable</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>source</name></decl>;</decl_stmt>
<expr_stmt><expr><name>source</name> = <call><name>PyObject_GetIter</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>source</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>chain_new_internal</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>chain_dealloc</name><parameter_list>(<param><decl><type><name>chainobject</name> *</type><name>lz</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>PyObject_GC_UnTrack</name><argument_list>(<argument><expr><name>lz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>active</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>source</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>lz</name></expr></argument>)</argument_list></call>-&gt;<call><name>tp_free</name><argument_list>(<argument><expr><name>lz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>chain_traverse</name><parameter_list>(<param><decl><type><name>chainobject</name> *</type><name>lz</name></decl></param>, <param><decl><type><name>visitproc</name></type> <name>visit</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>source</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>active</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>chain_next</name><parameter_list>(<param><decl><type><name>chainobject</name> *</type><name>lz</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>item</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>lz</name>-&gt;<name>source</name></name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name><name>lz</name>-&gt;<name>active</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>iterable</name> <init>= <expr><call><name>PyIter_Next</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>source</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>iterable</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>source</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>lz</name>-&gt;<name>active</name></name> = <call><name>PyObject_GetIter</name><argument_list>(<argument><expr><name>iterable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>iterable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>lz</name>-&gt;<name>active</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>source</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
}</block></then></if>
<expr_stmt><expr><name>item</name> = <call><name>PyIter_Next</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>active</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>item</name> != <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>item</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_StopIteration</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
<else>else
<return>return <expr><name>NULL</name></expr>;</return></else></if>
}</block></then></if>
<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>active</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>chain_next</name><argument_list>(<argument><expr><name>lz</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>chain_doc</name></expr></argument>,
<argument><expr>"chain(*iterables) --&gt; chain object\n\
\n\
Return a chain object whose .next() method returns elements from the\n\
first iterable until it is exhausted, then elements from the next\n\
iterable, until all of the iterables are exhausted."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>chain_from_iterable_doc</name></expr></argument>,
<argument><expr>"chain.from_iterable(iterable) --&gt; chain object\n\
\n\
Alternate chain() contructor taking a single iterable argument\n\
that evaluates lazily."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>chain_methods</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{
<expr>"from_iterable"</expr>, <expr>(<name>PyCFunction</name>) <name>chain_new_from_iterable</name></expr>, <expr><name>METH_O</name> | <name>METH_CLASS</name></expr>,
<expr><name>chain_from_iterable_doc</name></expr>
}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>chain_type</name> <init>= <expr><block>{
<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
"itertools.chain"</expr>,
<expr><sizeof>sizeof<argument_list>(<argument><expr><name>chainobject</name></expr></argument>)</argument_list></sizeof></expr>,
<expr>0</expr>,
<expr>(<name>destructor</name>)<name>chain_dealloc</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>PyObject_GenericGetAttr</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_HAVE_GC</name> |
<name>Py_TPFLAGS_BASETYPE</name></expr>,
<expr><name>chain_doc</name></expr>,
<expr>(<name>traverseproc</name>)<name>chain_traverse</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>PyObject_SelfIter</name></expr>,
<expr>(<name>iternextfunc</name>)<name>chain_next</name></expr>,
<expr><name>chain_methods</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>chain_new</name></expr>,
<expr><name>PyObject_GC_Del</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>PyObject_HEAD</name>
<name>PyObject</name> *</type><name>pools</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name> *</type><name>indices</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>stopped</name></decl>;</decl_stmt>
}</block></struct></type> <name>productobject</name>;</typedef>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>product_type</name></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>product_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>productobject</name> *</type><name>lz</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>nargs</name></decl>, <decl><type ref="prev"/><name>npools</name></decl>, <decl><type ref="prev"/><name>repeat</name><init>=<expr>1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>pools</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name> *</type><name>indices</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>kwds</name> != <name>NULL</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name><name>kwlist</name><index>[]</index></name> <init>= <expr><block>{<expr>"repeat"</expr>, <expr>0</expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>tmpargs</name> <init>= <expr><call><name>PyTuple_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>tmpargs</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>tmpargs</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>, <argument><expr>"|n:product"</expr></argument>, <argument><expr><name>kwlist</name></expr></argument>, <argument><expr>&amp;<name>repeat</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tmpargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tmpargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>repeat</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"repeat argument cannot be negative"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
}</block></then></if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>nargs</name> = (<name>repeat</name> == 0) ? 0 : <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>npools</name> = <name>nargs</name> * <name>repeat</name></expr>;</expr_stmt>
<expr_stmt><expr><name>indices</name> = <call><name>PyMem_Malloc</name><argument_list>(<argument><expr><name>npools</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>Py_ssize_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>indices</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>error</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>pools</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr><name>npools</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>pools</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<for>for (<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name> &lt; <name>nargs</name></expr> ;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>item</name> <init>= <expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>pool</name> <init>= <expr><call><name>PySequence_Tuple</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>pool</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>pools</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>indices</name><index>[<expr><name>i</name></expr>]</index></name> = 0</expr>;</expr_stmt>
}</block></for>
<for>for ( <init>;</init> <condition><expr><name>i</name> &lt; <name>npools</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>pool</name> <init>= <expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>pools</name></expr></argument>, <argument><expr><name>i</name> - <name>nargs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>pools</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>indices</name><index>[<expr><name>i</name></expr>]</index></name> = 0</expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><name>lz</name> = (<name>productobject</name> *)<call><name><name>type</name>-&gt;<name>tp_alloc</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>lz</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<expr_stmt><expr><name><name>lz</name>-&gt;<name>pools</name></name> = <name>pools</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lz</name>-&gt;<name>indices</name></name> = <name>indices</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lz</name>-&gt;<name>result</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lz</name>-&gt;<name>stopped</name></name> = 0</expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *)<name>lz</name></expr>;</return>
<label><name>error</name>:</label>
<if>if <condition>(<expr><name>indices</name> != <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>indices</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>pools</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>product_dealloc</name><parameter_list>(<param><decl><type><name>productobject</name> *</type><name>lz</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>PyObject_GC_UnTrack</name><argument_list>(<argument><expr><name>lz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>pools</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>result</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>indices</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>lz</name></expr></argument>)</argument_list></call>-&gt;<call><name>tp_free</name><argument_list>(<argument><expr><name>lz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>product_traverse</name><parameter_list>(<param><decl><type><name>productobject</name> *</type><name>lz</name></decl></param>, <param><decl><type><name>visitproc</name></type> <name>visit</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>pools</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>result</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>product_next</name><parameter_list>(<param><decl><type><name>productobject</name> *</type><name>lz</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>pool</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>elem</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>oldelem</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>pools</name> <init>= <expr><name><name>lz</name>-&gt;<name>pools</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name><name>lz</name>-&gt;<name>result</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>npools</name> <init>= <expr><call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>pools</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>lz</name>-&gt;<name>stopped</name></name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>result</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr><name>npools</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>empty</name>;</goto></then></if>
<expr_stmt><expr><name><name>lz</name>-&gt;<name>result</name></name> = <name>result</name></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name> &lt; <name>npools</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><name>pool</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>pools</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
<goto>goto <name>empty</name>;</goto></then></if>
<expr_stmt><expr><name>elem</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name> *</type><name>indices</name> <init>= <expr><name><name>lz</name>-&gt;<name>indices</name></name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>Py_REFCNT</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> &gt; 1</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>old_result</name> <init>= <expr><name>result</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>result</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr><name>npools</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>empty</name>;</goto></then></if>
<expr_stmt><expr><name><name>lz</name>-&gt;<name>result</name></name> = <name>result</name></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name> &lt; <name>npools</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><name>elem</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>old_result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>old_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><name>npools</name>==0 || <call><name>Py_REFCNT</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> == 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name>=<name>npools</name>-1</expr> ;</init> <condition><expr><name>i</name> &gt;= 0</expr> ;</condition> <incr><expr><name>i</name>--</expr></incr>) <block>{
<expr_stmt><expr><name>pool</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>pools</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>indices</name><index>[<expr><name>i</name></expr>]</index></name>++</expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>indices</name><index>[<expr><name>i</name></expr>]</index></name> == <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>indices</name><index>[<expr><name>i</name></expr>]</index></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>elem</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>oldelem</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>oldelem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>elem</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>indices</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>oldelem</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>oldelem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
}</block></else></if>
}</block></for>
<if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then>
<goto>goto <name>empty</name>;</goto></then></if>
}</block></else></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
<label><name>empty</name>:</label>
<expr_stmt><expr><name><name>lz</name>-&gt;<name>stopped</name></name> = 1</expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>product_doc</name></expr></argument>,
<argument><expr>"product(*iterables) --&gt; product object\n\
\n\
Cartesian product of input iterables. Equivalent to nested for-loops.\n\n\
For example, product(A, B) returns the same as: ((x,y) for x in A for y in B).\n\
The leftmost iterators are in the outermost for-loop, so the output tuples\n\
cycle in a manner similar to an odometer (with the rightmost element changing\n\
on every iteration).\n\n\
product('ab', range(3)) --&gt; ('a',0) ('a',1) ('a',2) ('b',0) ('b',1) ('b',2)\n\
product((0,1), (0,1), (0,1)) --&gt; (0,0,0) (0,0,1) (0,1,0) (0,1,1) (1,0,0) ..."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>product_type</name> <init>= <expr><block>{
<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
"itertools.product"</expr>,
<expr><sizeof>sizeof<argument_list>(<argument><expr><name>productobject</name></expr></argument>)</argument_list></sizeof></expr>,
<expr>0</expr>,
<expr>(<name>destructor</name>)<name>product_dealloc</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>PyObject_GenericGetAttr</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_HAVE_GC</name> |
<name>Py_TPFLAGS_BASETYPE</name></expr>,
<expr><name>product_doc</name></expr>,
<expr>(<name>traverseproc</name>)<name>product_traverse</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>PyObject_SelfIter</name></expr>,
<expr>(<name>iternextfunc</name>)<name>product_next</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>product_new</name></expr>,
<expr><name>PyObject_GC_Del</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>PyObject_HEAD</name>
<name>PyObject</name> *</type><name>pool</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name> *</type><name>indices</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>stopped</name></decl>;</decl_stmt>
}</block></struct></type> <name>combinationsobject</name>;</typedef>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>combinations_type</name></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>combinations_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>combinationsobject</name> *</type><name>co</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>pool</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>iterable</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name> *</type><name>indices</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>kwargs</name><index>[]</index></name> <init>= <expr><block>{<expr>"iterable"</expr>, <expr>"r"</expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>, <argument><expr>"On:combinations"</expr></argument>, <argument><expr><name>kwargs</name></expr></argument>,
<argument><expr>&amp;<name>iterable</name></expr></argument>, <argument><expr>&amp;<name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>pool</name> = <call><name>PySequence_Tuple</name><argument_list>(<argument><expr><name>iterable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>pool</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<expr_stmt><expr><name>n</name> = <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>r</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"r must be non-negative"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>error</name>;</goto>
}</block></then></if>
<if>if <condition>(<expr><name>r</name> &gt; <name>n</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"r cannot be bigger than the iterable"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>error</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>indices</name> = <call><name>PyMem_Malloc</name><argument_list>(<argument><expr><name>r</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>Py_ssize_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>indices</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>error</name>;</goto>
}</block></then></if>
<for>for (<init><expr><name>i</name>=0</expr> ;</init> <condition><expr><name>i</name>&lt;<name>r</name></expr> ;</condition> <incr><expr><name>i</name>++</expr></incr>)
<expr_stmt><expr><name><name>indices</name><index>[<expr><name>i</name></expr>]</index></name> = <name>i</name></expr>;</expr_stmt></for>
<expr_stmt><expr><name>co</name> = (<name>combinationsobject</name> *)<call><name><name>type</name>-&gt;<name>tp_alloc</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>co</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<expr_stmt><expr><name><name>co</name>-&gt;<name>pool</name></name> = <name>pool</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>co</name>-&gt;<name>indices</name></name> = <name>indices</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>co</name>-&gt;<name>result</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>co</name>-&gt;<name>r</name></name> = <name>r</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>co</name>-&gt;<name>stopped</name></name> = 0</expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *)<name>co</name></expr>;</return>
<label><name>error</name>:</label>
<if>if <condition>(<expr><name>indices</name> != <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>indices</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>combinations_dealloc</name><parameter_list>(<param><decl><type><name>combinationsobject</name> *</type><name>co</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>PyObject_GC_UnTrack</name><argument_list>(<argument><expr><name>co</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>co</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>co</name>-&gt;<name>result</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name><name>co</name>-&gt;<name>indices</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>co</name></expr></argument>)</argument_list></call>-&gt;<call><name>tp_free</name><argument_list>(<argument><expr><name>co</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>combinations_traverse</name><parameter_list>(<param><decl><type><name>combinationsobject</name> *</type><name>co</name></decl></param>, <param><decl><type><name>visitproc</name></type> <name>visit</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>co</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>co</name>-&gt;<name>result</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>combinations_next</name><parameter_list>(<param><decl><type><name>combinationsobject</name> *</type><name>co</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>elem</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>oldelem</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>pool</name> <init>= <expr><name><name>co</name>-&gt;<name>pool</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name> *</type><name>indices</name> <init>= <expr><name><name>co</name>-&gt;<name>indices</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name><name>co</name>-&gt;<name>result</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n</name> <init>= <expr><call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>r</name> <init>= <expr><name><name>co</name>-&gt;<name>r</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>index</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>co</name>-&gt;<name>stopped</name></name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>result</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>empty</name>;</goto></then></if>
<expr_stmt><expr><name><name>co</name>-&gt;<name>result</name></name> = <name>result</name></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>r</name></expr> ;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><name>index</name> = <name><name>indices</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>elem</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
}</block></then> <else>else <block>{
<if>if <condition>(<expr><call><name>Py_REFCNT</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> &gt; 1</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>old_result</name> <init>= <expr><name>result</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>result</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>empty</name>;</goto></then></if>
<expr_stmt><expr><name><name>co</name>-&gt;<name>result</name></name> = <name>result</name></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>r</name></expr> ;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><name>elem</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>old_result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>old_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>r</name> == 0 || <call><name>Py_REFCNT</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> == 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name>=<name>r</name>-1</expr> ;</init> <condition><expr><name>i</name> &gt;= 0 &amp;&amp; <name><name>indices</name><index>[<expr><name>i</name></expr>]</index></name> == <name>i</name>+<name>n</name>-<name>r</name></expr> ;</condition> <incr><expr><name>i</name>--</expr></incr>)
<empty_stmt>;</empty_stmt></for>
<if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then>
<goto>goto <name>empty</name>;</goto></then></if>
<expr_stmt><expr><name><name>indices</name><index>[<expr><name>i</name></expr>]</index></name>++</expr>;</expr_stmt>
<for>for (<init><expr><name>j</name>=<name>i</name>+1</expr> ;</init> <condition><expr><name>j</name>&lt;<name>r</name></expr> ;</condition> <incr><expr><name>j</name>++</expr></incr>)
<expr_stmt><expr><name><name>indices</name><index>[<expr><name>j</name></expr>]</index></name> = <name><name>indices</name><index>[<expr><name>j</name>-1</expr>]</index></name> + 1</expr>;</expr_stmt></for>
<for>for ( <init>;</init> <condition><expr><name>i</name>&lt;<name>r</name></expr> ;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><name>index</name> = <name><name>indices</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>elem</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>oldelem</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>oldelem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
}</block></else></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
<label><name>empty</name>:</label>
<expr_stmt><expr><name><name>co</name>-&gt;<name>stopped</name></name> = 1</expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>combinations_doc</name></expr></argument>,
<argument><expr>"combinations(iterable[, r]) --&gt; combinations object\n\
\n\
Return successive r-length combinations of elements in the iterable.\n\n\
combinations(range(4), 3) --&gt; (0,1,2), (0,1,3), (0,2,3), (1,2,3)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>combinations_type</name> <init>= <expr><block>{
<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
"itertools.combinations"</expr>,
<expr><sizeof>sizeof<argument_list>(<argument><expr><name>combinationsobject</name></expr></argument>)</argument_list></sizeof></expr>,
<expr>0</expr>,
<expr>(<name>destructor</name>)<name>combinations_dealloc</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>PyObject_GenericGetAttr</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_HAVE_GC</name> |
<name>Py_TPFLAGS_BASETYPE</name></expr>,
<expr><name>combinations_doc</name></expr>,
<expr>(<name>traverseproc</name>)<name>combinations_traverse</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>PyObject_SelfIter</name></expr>,
<expr>(<name>iternextfunc</name>)<name>combinations_next</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>combinations_new</name></expr>,
<expr><name>PyObject_GC_Del</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>PyObject_HEAD</name>
<name>PyObject</name> *</type><name>pool</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name> *</type><name>indices</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name> *</type><name>cycles</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>stopped</name></decl>;</decl_stmt>
}</block></struct></type> <name>permutationsobject</name>;</typedef>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>permutations_type</name></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>permutations_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>permutationsobject</name> *</type><name>po</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>robj</name> <init>= <expr><name>Py_None</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>pool</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>iterable</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name> *</type><name>indices</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name> *</type><name>cycles</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>kwargs</name><index>[]</index></name> <init>= <expr><block>{<expr>"iterable"</expr>, <expr>"r"</expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>, <argument><expr>"O|O:permutations"</expr></argument>, <argument><expr><name>kwargs</name></expr></argument>,
<argument><expr>&amp;<name>iterable</name></expr></argument>, <argument><expr>&amp;<name>robj</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>pool</name> = <call><name>PySequence_Tuple</name><argument_list>(<argument><expr><name>iterable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>pool</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<expr_stmt><expr><name>n</name> = <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>r</name> = <name>n</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>robj</name> != <name>Py_None</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>r</name> = <call><name>PyInt_AsSsize_t</name><argument_list>(<argument><expr><name>robj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>r</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
}</block></then></if>
<if>if <condition>(<expr><name>r</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"r must be non-negative"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>error</name>;</goto>
}</block></then></if>
<if>if <condition>(<expr><name>r</name> &gt; <name>n</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"r cannot be bigger than the iterable"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>error</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>indices</name> = <call><name>PyMem_Malloc</name><argument_list>(<argument><expr><name>n</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>Py_ssize_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>cycles</name> = <call><name>PyMem_Malloc</name><argument_list>(<argument><expr><name>r</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>Py_ssize_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>indices</name> == <name>NULL</name> || <name>cycles</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>error</name>;</goto>
}</block></then></if>
<for>for (<init><expr><name>i</name>=0</expr> ;</init> <condition><expr><name>i</name>&lt;<name>n</name></expr> ;</condition> <incr><expr><name>i</name>++</expr></incr>)
<expr_stmt><expr><name><name>indices</name><index>[<expr><name>i</name></expr>]</index></name> = <name>i</name></expr>;</expr_stmt></for>
<for>for (<init><expr><name>i</name>=0</expr> ;</init> <condition><expr><name>i</name>&lt;<name>r</name></expr> ;</condition> <incr><expr><name>i</name>++</expr></incr>)
<expr_stmt><expr><name><name>cycles</name><index>[<expr><name>i</name></expr>]</index></name> = <name>n</name> - <name>i</name></expr>;</expr_stmt></for>
<expr_stmt><expr><name>po</name> = (<name>permutationsobject</name> *)<call><name><name>type</name>-&gt;<name>tp_alloc</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>po</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<expr_stmt><expr><name><name>po</name>-&gt;<name>pool</name></name> = <name>pool</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>po</name>-&gt;<name>indices</name></name> = <name>indices</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>po</name>-&gt;<name>cycles</name></name> = <name>cycles</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>po</name>-&gt;<name>result</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>po</name>-&gt;<name>r</name></name> = <name>r</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>po</name>-&gt;<name>stopped</name></name> = 0</expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *)<name>po</name></expr>;</return>
<label><name>error</name>:</label>
<if>if <condition>(<expr><name>indices</name> != <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>indices</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>cycles</name> != <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>cycles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>permutations_dealloc</name><parameter_list>(<param><decl><type><name>permutationsobject</name> *</type><name>po</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>PyObject_GC_UnTrack</name><argument_list>(<argument><expr><name>po</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>po</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>po</name>-&gt;<name>result</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name><name>po</name>-&gt;<name>indices</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name><name>po</name>-&gt;<name>cycles</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>po</name></expr></argument>)</argument_list></call>-&gt;<call><name>tp_free</name><argument_list>(<argument><expr><name>po</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>permutations_traverse</name><parameter_list>(<param><decl><type><name>permutationsobject</name> *</type><name>po</name></decl></param>, <param><decl><type><name>visitproc</name></type> <name>visit</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>po</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>po</name>-&gt;<name>result</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>permutations_next</name><parameter_list>(<param><decl><type><name>permutationsobject</name> *</type><name>po</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>elem</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>oldelem</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>pool</name> <init>= <expr><name><name>po</name>-&gt;<name>pool</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name> *</type><name>indices</name> <init>= <expr><name><name>po</name>-&gt;<name>indices</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name> *</type><name>cycles</name> <init>= <expr><name><name>po</name>-&gt;<name>cycles</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name><name>po</name>-&gt;<name>result</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n</name> <init>= <expr><call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>r</name> <init>= <expr><name><name>po</name>-&gt;<name>r</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>k</name></decl>, <decl><type ref="prev"/><name>index</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>po</name>-&gt;<name>stopped</name></name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>result</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>empty</name>;</goto></then></if>
<expr_stmt><expr><name><name>po</name>-&gt;<name>result</name></name> = <name>result</name></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>r</name></expr> ;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><name>index</name> = <name><name>indices</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>elem</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
}</block></then> <else>else <block>{
<if>if <condition>(<expr><name>n</name> == 0</expr>)</condition><then>
<goto>goto <name>empty</name>;</goto></then></if>
<if>if <condition>(<expr><call><name>Py_REFCNT</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> &gt; 1</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>old_result</name> <init>= <expr><name>result</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>result</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>empty</name>;</goto></then></if>
<expr_stmt><expr><name><name>po</name>-&gt;<name>result</name></name> = <name>result</name></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name>&lt;<name>r</name></expr> ;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><name>elem</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>old_result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>old_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>r</name> == 0 || <call><name>Py_REFCNT</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> == 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name>=<name>r</name>-1</expr> ;</init> <condition><expr><name>i</name>&gt;=0</expr> ;</condition> <incr><expr><name>i</name>--</expr></incr>) <block>{
<expr_stmt><expr><name><name>cycles</name><index>[<expr><name>i</name></expr>]</index></name> -= 1</expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>cycles</name><index>[<expr><name>i</name></expr>]</index></name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>index</name> = <name><name>indices</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<for>for (<init><expr><name>j</name>=<name>i</name></expr> ;</init> <condition><expr><name>j</name>&lt;<name>n</name>-1</expr> ;</condition> <incr><expr><name>j</name>++</expr></incr>)
<expr_stmt><expr><name><name>indices</name><index>[<expr><name>j</name></expr>]</index></name> = <name><name>indices</name><index>[<expr><name>j</name>+1</expr>]</index></name></expr>;</expr_stmt></for>
<expr_stmt><expr><name><name>indices</name><index>[<expr><name>n</name>-1</expr>]</index></name> = <name>index</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>cycles</name><index>[<expr><name>i</name></expr>]</index></name> = <name>n</name> - <name>i</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>j</name> = <name><name>cycles</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>index</name> = <name><name>indices</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>indices</name><index>[<expr><name>i</name></expr>]</index></name> = <name><name>indices</name><index>[<expr><name>n</name>-<name>j</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>indices</name><index>[<expr><name>n</name>-<name>j</name></expr>]</index></name> = <name>index</name></expr>;</expr_stmt>
<for>for (<init><expr><name>k</name>=<name>i</name></expr>;</init> <condition><expr><name>k</name>&lt;<name>r</name></expr> ;</condition> <incr><expr><name>k</name>++</expr></incr>) <block>{
<expr_stmt><expr><name>index</name> = <name><name>indices</name><index>[<expr><name>k</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>elem</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>oldelem</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>oldelem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<break>break;</break>
}</block></else></if>
}</block></for>
<if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then>
<goto>goto <name>empty</name>;</goto></then></if>
}</block></else></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
<label><name>empty</name>:</label>
<expr_stmt><expr><name><name>po</name>-&gt;<name>stopped</name></name> = 1</expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>permutations_doc</name></expr></argument>,
<argument><expr>"permutations(iterable[, r]) --&gt; permutations object\n\
\n\
Return successive r-length permutations of elements in the iterable.\n\n\
permutations(range(3), 2) --&gt; (0,1), (0,2), (1,0), (1,2), (2,0), (2,1)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>permutations_type</name> <init>= <expr><block>{
<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
"itertools.permutations"</expr>,
<expr><sizeof>sizeof<argument_list>(<argument><expr><name>permutationsobject</name></expr></argument>)</argument_list></sizeof></expr>,
<expr>0</expr>,
<expr>(<name>destructor</name>)<name>permutations_dealloc</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>PyObject_GenericGetAttr</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_HAVE_GC</name> |
<name>Py_TPFLAGS_BASETYPE</name></expr>,
<expr><name>permutations_doc</name></expr>,
<expr>(<name>traverseproc</name>)<name>permutations_traverse</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>PyObject_SelfIter</name></expr>,
<expr>(<name>iternextfunc</name>)<name>permutations_next</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>permutations_new</name></expr>,
<expr><name>PyObject_GC_Del</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>PyObject_HEAD</name>
<name>PyObject</name> *</type><name>func</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>it</name></decl>;</decl_stmt>
}</block></struct></type> <name>ifilterobject</name>;</typedef>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>ifilter_type</name></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>ifilter_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>func</name></decl>, *<decl><type ref="prev"/><name>seq</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>it</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ifilterobject</name> *</type><name>lz</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>type</name> == &amp;<name>ifilter_type</name> &amp;&amp; !<call><name>_PyArg_NoKeywords</name><argument_list>(<argument><expr>"ifilter()"</expr></argument>, <argument><expr><name>kwds</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"ifilter"</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>&amp;<name>func</name></expr></argument>, <argument><expr>&amp;<name>seq</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>it</name> = <call><name>PyObject_GetIter</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>it</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>lz</name> = (<name>ifilterobject</name> *)<call><name><name>type</name>-&gt;<name>tp_alloc</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>lz</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lz</name>-&gt;<name>func</name></name> = <name>func</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lz</name>-&gt;<name>it</name></name> = <name>it</name></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *)<name>lz</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ifilter_dealloc</name><parameter_list>(<param><decl><type><name>ifilterobject</name> *</type><name>lz</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>PyObject_GC_UnTrack</name><argument_list>(<argument><expr><name>lz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>func</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>it</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>lz</name></expr></argument>)</argument_list></call>-&gt;<call><name>tp_free</name><argument_list>(<argument><expr><name>lz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>ifilter_traverse</name><parameter_list>(<param><decl><type><name>ifilterobject</name> *</type><name>lz</name></decl></param>, <param><decl><type><name>visitproc</name></type> <name>visit</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>it</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>func</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>ifilter_next</name><parameter_list>(<param><decl><type><name>ifilterobject</name> *</type><name>lz</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>item</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>it</name> <init>= <expr><name><name>lz</name>-&gt;<name>it</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>ok</name></decl>;</decl_stmt>
<function_decl><type><name>PyObject</name> *</type>(*<name>iternext</name>)<parameter_list>(<param><decl><type><name>PyObject</name> *</type></decl></param>)</parameter_list>;</function_decl>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyIter_Check</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>iternext</name> = *<call><name>Py_TYPE</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call>-&gt;<name>tp_iternext</name></expr>;</expr_stmt>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<expr_stmt><expr><name>item</name> = <call><name>iternext</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>item</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name><name>lz</name>-&gt;<name>func</name></name> == <name>Py_None</name> || <name><name>lz</name>-&gt;<name>func</name></name> == (<name>PyObject</name> *)&amp;<name>PyBool_Type</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>ok</name> = <call><name>PyObject_IsTrue</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>good</name></decl>;</decl_stmt>
<expr_stmt><expr><name>good</name> = <call><name>PyObject_CallFunctionObjArgs</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>func</name></name></expr></argument>,
<argument><expr><name>item</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>good</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>ok</name> = <call><name>PyObject_IsTrue</name><argument_list>(<argument><expr><name>good</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>good</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<if>if <condition>(<expr><name>ok</name></expr>)</condition><then>
<return>return <expr><name>item</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>ifilter_doc</name></expr></argument>,
<argument><expr>"ifilter(function or None, sequence) --&gt; ifilter object\n\
\n\
Return those items of sequence for which function(item) is true.\n\
If function is None, return the items that are true."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>ifilter_type</name> <init>= <expr><block>{
<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
"itertools.ifilter"</expr>,
<expr><sizeof>sizeof<argument_list>(<argument><expr><name>ifilterobject</name></expr></argument>)</argument_list></sizeof></expr>,
<expr>0</expr>,
<expr>(<name>destructor</name>)<name>ifilter_dealloc</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>PyObject_GenericGetAttr</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_HAVE_GC</name> |
<name>Py_TPFLAGS_BASETYPE</name></expr>,
<expr><name>ifilter_doc</name></expr>,
<expr>(<name>traverseproc</name>)<name>ifilter_traverse</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>PyObject_SelfIter</name></expr>,
<expr>(<name>iternextfunc</name>)<name>ifilter_next</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>ifilter_new</name></expr>,
<expr><name>PyObject_GC_Del</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>PyObject_HEAD</name>
<name>PyObject</name> *</type><name>func</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>it</name></decl>;</decl_stmt>
}</block></struct></type> <name>ifilterfalseobject</name>;</typedef>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>ifilterfalse_type</name></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>ifilterfalse_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>func</name></decl>, *<decl><type ref="prev"/><name>seq</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>it</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ifilterfalseobject</name> *</type><name>lz</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>type</name> == &amp;<name>ifilterfalse_type</name> &amp;&amp;
!<call><name>_PyArg_NoKeywords</name><argument_list>(<argument><expr>"ifilterfalse()"</expr></argument>, <argument><expr><name>kwds</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"ifilterfalse"</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>&amp;<name>func</name></expr></argument>, <argument><expr>&amp;<name>seq</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>it</name> = <call><name>PyObject_GetIter</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>it</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>lz</name> = (<name>ifilterfalseobject</name> *)<call><name><name>type</name>-&gt;<name>tp_alloc</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>lz</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lz</name>-&gt;<name>func</name></name> = <name>func</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lz</name>-&gt;<name>it</name></name> = <name>it</name></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *)<name>lz</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ifilterfalse_dealloc</name><parameter_list>(<param><decl><type><name>ifilterfalseobject</name> *</type><name>lz</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>PyObject_GC_UnTrack</name><argument_list>(<argument><expr><name>lz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>func</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>it</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>lz</name></expr></argument>)</argument_list></call>-&gt;<call><name>tp_free</name><argument_list>(<argument><expr><name>lz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>ifilterfalse_traverse</name><parameter_list>(<param><decl><type><name>ifilterfalseobject</name> *</type><name>lz</name></decl></param>, <param><decl><type><name>visitproc</name></type> <name>visit</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>it</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>func</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>ifilterfalse_next</name><parameter_list>(<param><decl><type><name>ifilterfalseobject</name> *</type><name>lz</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>item</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>it</name> <init>= <expr><name><name>lz</name>-&gt;<name>it</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>ok</name></decl>;</decl_stmt>
<function_decl><type><name>PyObject</name> *</type>(*<name>iternext</name>)<parameter_list>(<param><decl><type><name>PyObject</name> *</type></decl></param>)</parameter_list>;</function_decl>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyIter_Check</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>iternext</name> = *<call><name>Py_TYPE</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call>-&gt;<name>tp_iternext</name></expr>;</expr_stmt>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<expr_stmt><expr><name>item</name> = <call><name>iternext</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>item</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name><name>lz</name>-&gt;<name>func</name></name> == <name>Py_None</name> || <name><name>lz</name>-&gt;<name>func</name></name> == (<name>PyObject</name> *)&amp;<name>PyBool_Type</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>ok</name> = <call><name>PyObject_IsTrue</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>good</name></decl>;</decl_stmt>
<expr_stmt><expr><name>good</name> = <call><name>PyObject_CallFunctionObjArgs</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>func</name></name></expr></argument>,
<argument><expr><name>item</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>good</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>ok</name> = <call><name>PyObject_IsTrue</name><argument_list>(<argument><expr><name>good</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>good</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<if>if <condition>(<expr>!<name>ok</name></expr>)</condition><then>
<return>return <expr><name>item</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>ifilterfalse_doc</name></expr></argument>,
<argument><expr>"ifilterfalse(function or None, sequence) --&gt; ifilterfalse object\n\
\n\
Return those items of sequence for which function(item) is false.\n\
If function is None, return the items that are false."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>ifilterfalse_type</name> <init>= <expr><block>{
<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
"itertools.ifilterfalse"</expr>,
<expr><sizeof>sizeof<argument_list>(<argument><expr><name>ifilterfalseobject</name></expr></argument>)</argument_list></sizeof></expr>,
<expr>0</expr>,
<expr>(<name>destructor</name>)<name>ifilterfalse_dealloc</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>PyObject_GenericGetAttr</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_HAVE_GC</name> |
<name>Py_TPFLAGS_BASETYPE</name></expr>,
<expr><name>ifilterfalse_doc</name></expr>,
<expr>(<name>traverseproc</name>)<name>ifilterfalse_traverse</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>PyObject_SelfIter</name></expr>,
<expr>(<name>iternextfunc</name>)<name>ifilterfalse_next</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>ifilterfalse_new</name></expr>,
<expr><name>PyObject_GC_Del</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>PyObject_HEAD</name>
<name>Py_ssize_t</name></type> <name>cnt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>long_cnt</name></decl>;</decl_stmt>
}</block></struct></type> <name>countobject</name>;</typedef>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>count_type</name></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>count_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>countobject</name> *</type><name>lz</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>cnt</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>cnt_arg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>long_cnt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>type</name> == &amp;<name>count_type</name> &amp;&amp; !<call><name>_PyArg_NoKeywords</name><argument_list>(<argument><expr>"count()"</expr></argument>, <argument><expr><name>kwds</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"count"</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>&amp;<name>cnt_arg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>cnt_arg</name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>cnt</name> = <call><name>PyInt_AsSsize_t</name><argument_list>(<argument><expr><name>cnt_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>cnt</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>PyLong_Check</name><argument_list>(<argument><expr><name>cnt_arg</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"an integer is required"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>long_cnt</name> = <name>cnt_arg</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>long_cnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>cnt</name> = <name>PY_SSIZE_T_MAX</name></expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
<expr_stmt><expr><name>lz</name> = (<name>countobject</name> *)<call><name>PyObject_New</name><argument_list>(<argument><expr><name>countobject</name></expr></argument>, <argument><expr>&amp;<name>count_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>lz</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>long_cnt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>lz</name>-&gt;<name>cnt</name></name> = <name>cnt</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lz</name>-&gt;<name>long_cnt</name></name> = <name>long_cnt</name></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *)<name>lz</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>count_dealloc</name><parameter_list>(<param><decl><type><name>countobject</name> *</type><name>lz</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>long_cnt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyObject_Del</name><argument_list>(<argument><expr><name>lz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>count_nextlong</name><parameter_list>(<param><decl><type><name>countobject</name> *</type><name>lz</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>one</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>cnt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>stepped_up</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>lz</name>-&gt;<name>long_cnt</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>lz</name>-&gt;<name>long_cnt</name></name> = <call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><name>PY_SSIZE_T_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>lz</name>-&gt;<name>long_cnt</name></name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
}</block></then></if>
<if>if <condition>(<expr><name>one</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>one</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>one</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
}</block></then></if>
<expr_stmt><expr><name>cnt</name> = <name><name>lz</name>-&gt;<name>long_cnt</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>cnt</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>stepped_up</name> = <call><name>PyNumber_Add</name><argument_list>(<argument><expr><name>cnt</name></expr></argument>, <argument><expr><name>one</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>stepped_up</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>lz</name>-&gt;<name>long_cnt</name></name> = <name>stepped_up</name></expr>;</expr_stmt>
<return>return <expr><name>cnt</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>count_next</name><parameter_list>(<param><decl><type><name>countobject</name> *</type><name>lz</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name><name>lz</name>-&gt;<name>cnt</name></name> == <name>PY_SSIZE_T_MAX</name></expr>)</condition><then>
<return>return <expr><call><name>count_nextlong</name><argument_list>(<argument><expr><name>lz</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<return>return <expr><call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>cnt</name></name>++</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>count_repr</name><parameter_list>(<param><decl><type><name>countobject</name> *</type><name>lz</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>cnt_repr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>lz</name>-&gt;<name>cnt</name></name> != <name>PY_SSIZE_T_MAX</name></expr>)</condition><then>
<return>return <expr><call><name>PyString_FromFormat</name><argument_list>(<argument><expr>"count(%zd)"</expr></argument>, <argument><expr><name><name>lz</name>-&gt;<name>cnt</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>cnt_repr</name> = <call><name>PyObject_Repr</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>long_cnt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>cnt_repr</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>result</name> = <call><name>PyString_FromFormat</name><argument_list>(<argument><expr>"count(%s)"</expr></argument>, <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>cnt_repr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>cnt_repr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>count_doc</name></expr></argument>,
<argument><expr>"count([firstval]) --&gt; count object\n\
\n\
Return a count object whose .next() method returns consecutive\n\
integers starting from zero or, if specified, from firstval."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>count_type</name> <init>= <expr><block>{
<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
"itertools.count"</expr>,
<expr><sizeof>sizeof<argument_list>(<argument><expr><name>countobject</name></expr></argument>)</argument_list></sizeof></expr>,
<expr>0</expr>,
<expr>(<name>destructor</name>)<name>count_dealloc</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>(<name>reprfunc</name>)<name>count_repr</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>PyObject_GenericGetAttr</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>Py_TPFLAGS_DEFAULT</name></expr>,
<expr><name>count_doc</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>PyObject_SelfIter</name></expr>,
<expr>(<name>iternextfunc</name>)<name>count_next</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>count_new</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>PyObject_HEAD</name>
<name>Py_ssize_t</name></type> <name>tuplesize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>ittuple</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
}</block></struct></type> <name>izipobject</name>;</typedef>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>izip_type</name></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>izip_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>izipobject</name> *</type><name>lz</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>ittuple</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>tuplesize</name> <init>= <expr><call><name>PySequence_Length</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>type</name> == &amp;<name>izip_type</name> &amp;&amp; !<call><name>_PyArg_NoKeywords</name><argument_list>(<argument><expr>"izip()"</expr></argument>, <argument><expr><name>kwds</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ittuple</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr><name>tuplesize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ittuple</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<for>for (<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name> &lt; <name>tuplesize</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>item</name> <init>= <expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>it</name> <init>= <expr><call><name>PyObject_GetIter</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>it</name> == <name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"izip argument #%zd must support iteration"</expr></argument>,
<argument><expr><name>i</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>ittuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>ittuple</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><name>result</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr><name>tuplesize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>ittuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<for>for (<init><expr><name>i</name>=0</expr> ;</init> <condition><expr><name>i</name> &lt; <name>tuplesize</name></expr> ;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><name>lz</name> = (<name>izipobject</name> *)<call><name><name>type</name>-&gt;<name>tp_alloc</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>lz</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>ittuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>lz</name>-&gt;<name>ittuple</name></name> = <name>ittuple</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lz</name>-&gt;<name>tuplesize</name></name> = <name>tuplesize</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lz</name>-&gt;<name>result</name></name> = <name>result</name></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *)<name>lz</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>izip_dealloc</name><parameter_list>(<param><decl><type><name>izipobject</name> *</type><name>lz</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>PyObject_GC_UnTrack</name><argument_list>(<argument><expr><name>lz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>ittuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>result</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>lz</name></expr></argument>)</argument_list></call>-&gt;<call><name>tp_free</name><argument_list>(<argument><expr><name>lz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>izip_traverse</name><parameter_list>(<param><decl><type><name>izipobject</name> *</type><name>lz</name></decl></param>, <param><decl><type><name>visitproc</name></type> <name>visit</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>ittuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>result</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>izip_next</name><parameter_list>(<param><decl><type><name>izipobject</name> *</type><name>lz</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>tuplesize</name> <init>= <expr><name><name>lz</name>-&gt;<name>tuplesize</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name><name>lz</name>-&gt;<name>result</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>it</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>item</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>olditem</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>tuplesize</name> == 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>Py_REFCNT</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> == 1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name>=0</expr> ;</init> <condition><expr><name>i</name> &lt; <name>tuplesize</name></expr> ;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><name>it</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>ittuple</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyIter_Check</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>item</name> = (*<call><name>Py_TYPE</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call>-&gt;<name>tp_iternext</name>)(<name>it</name>)</expr>;</expr_stmt>
<if>if <condition>(<expr><name>item</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>olditem</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>olditem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>result</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr><name>tuplesize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<for>for (<init><expr><name>i</name>=0</expr> ;</init> <condition><expr><name>i</name> &lt; <name>tuplesize</name></expr> ;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><name>it</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>ittuple</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyIter_Check</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>item</name> = (*<call><name>Py_TYPE</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call>-&gt;<name>tp_iternext</name>)(<name>it</name>)</expr>;</expr_stmt>
<if>if <condition>(<expr><name>item</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
}</block></else></if>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>izip_doc</name></expr></argument>,
<argument><expr>"izip(iter1 [,iter2 [...]]) --&gt; izip object\n\
\n\
Return a izip object whose .next() method returns a tuple where\n\
the i-th element comes from the i-th iterable argument. The .next()\n\
method continues until the shortest iterable in the argument sequence\n\
is exhausted and then it raises StopIteration. Works like the zip()\n\
function but consumes less memory by returning an iterator instead of\n\
a list."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>izip_type</name> <init>= <expr><block>{
<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
"itertools.izip"</expr>,
<expr><sizeof>sizeof<argument_list>(<argument><expr><name>izipobject</name></expr></argument>)</argument_list></sizeof></expr>,
<expr>0</expr>,
<expr>(<name>destructor</name>)<name>izip_dealloc</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>PyObject_GenericGetAttr</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_HAVE_GC</name> |
<name>Py_TPFLAGS_BASETYPE</name></expr>,
<expr><name>izip_doc</name></expr>,
<expr>(<name>traverseproc</name>)<name>izip_traverse</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>PyObject_SelfIter</name></expr>,
<expr>(<name>iternextfunc</name>)<name>izip_next</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>izip_new</name></expr>,
<expr><name>PyObject_GC_Del</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>PyObject_HEAD</name>
<name>PyObject</name> *</type><name>element</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>cnt</name></decl>;</decl_stmt>
}</block></struct></type> <name>repeatobject</name>;</typedef>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>repeat_type</name></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>repeat_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>repeatobject</name> *</type><name>ro</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>element</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>cnt</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>type</name> == &amp;<name>repeat_type</name> &amp;&amp; !<call><name>_PyArg_NoKeywords</name><argument_list>(<argument><expr>"repeat()"</expr></argument>, <argument><expr><name>kwds</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O|n:repeat"</expr></argument>, <argument><expr>&amp;<name>element</name></expr></argument>, <argument><expr>&amp;<name>cnt</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>PyTuple_Size</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> == 2 &amp;&amp; <name>cnt</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>cnt</name> = 0</expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>ro</name> = (<name>repeatobject</name> *)<call><name><name>type</name>-&gt;<name>tp_alloc</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ro</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>element</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ro</name>-&gt;<name>element</name></name> = <name>element</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ro</name>-&gt;<name>cnt</name></name> = <name>cnt</name></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *)<name>ro</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>repeat_dealloc</name><parameter_list>(<param><decl><type><name>repeatobject</name> *</type><name>ro</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>PyObject_GC_UnTrack</name><argument_list>(<argument><expr><name>ro</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>ro</name>-&gt;<name>element</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>ro</name></expr></argument>)</argument_list></call>-&gt;<call><name>tp_free</name><argument_list>(<argument><expr><name>ro</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>repeat_traverse</name><parameter_list>(<param><decl><type><name>repeatobject</name> *</type><name>ro</name></decl></param>, <param><decl><type><name>visitproc</name></type> <name>visit</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>ro</name>-&gt;<name>element</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>repeat_next</name><parameter_list>(<param><decl><type><name>repeatobject</name> *</type><name>ro</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name><name>ro</name>-&gt;<name>cnt</name></name> == 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name><name>ro</name>-&gt;<name>cnt</name></name> &gt; 0</expr>)</condition><then>
<expr_stmt><expr><name><name>ro</name>-&gt;<name>cnt</name></name>--</expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name><name>ro</name>-&gt;<name>element</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>ro</name>-&gt;<name>element</name></name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>repeat_repr</name><parameter_list>(<param><decl><type><name>repeatobject</name> *</type><name>ro</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>, *<decl><type ref="prev"/><name>objrepr</name></decl>;</decl_stmt>
<expr_stmt><expr><name>objrepr</name> = <call><name>PyObject_Repr</name><argument_list>(<argument><expr><name><name>ro</name>-&gt;<name>element</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>objrepr</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name><name>ro</name>-&gt;<name>cnt</name></name> == -1</expr>)</condition><then>
<expr_stmt><expr><name>result</name> = <call><name>PyString_FromFormat</name><argument_list>(<argument><expr>"repeat(%s)"</expr></argument>,
<argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>objrepr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>result</name> = <call><name>PyString_FromFormat</name><argument_list>(<argument><expr>"repeat(%s, %zd)"</expr></argument>,
<argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>objrepr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>ro</name>-&gt;<name>cnt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>objrepr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>repeat_len</name><parameter_list>(<param><decl><type><name>repeatobject</name> *</type><name>ro</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name><name>ro</name>-&gt;<name>cnt</name></name> == -1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"len() of unsized object"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>PyInt_FromSize_t</name><argument_list>(<argument><expr><name><name>ro</name>-&gt;<name>cnt</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>length_hint_doc</name></expr></argument>, <argument><expr>"Private method returning an estimate of len(list(it))."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>repeat_methods</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr>"__length_hint__"</expr>, <expr>(<name>PyCFunction</name>)<name>repeat_len</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>length_hint_doc</name></expr>}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>repeat_doc</name></expr></argument>,
<argument><expr>"repeat(element [,times]) -&gt; create an iterator which returns the element\n\
for the specified number of times. If not specified, returns the element\n\
endlessly."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>repeat_type</name> <init>= <expr><block>{
<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
"itertools.repeat"</expr>,
<expr><sizeof>sizeof<argument_list>(<argument><expr><name>repeatobject</name></expr></argument>)</argument_list></sizeof></expr>,
<expr>0</expr>,
<expr>(<name>destructor</name>)<name>repeat_dealloc</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>(<name>reprfunc</name>)<name>repeat_repr</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>PyObject_GenericGetAttr</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_HAVE_GC</name> |
<name>Py_TPFLAGS_BASETYPE</name></expr>,
<expr><name>repeat_doc</name></expr>,
<expr>(<name>traverseproc</name>)<name>repeat_traverse</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>PyObject_SelfIter</name></expr>,
<expr>(<name>iternextfunc</name>)<name>repeat_next</name></expr>,
<expr><name>repeat_methods</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>repeat_new</name></expr>,
<expr><name>PyObject_GC_Del</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>PyObject_HEAD</name>
<name>Py_ssize_t</name></type> <name>tuplesize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>numactive</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>ittuple</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>fillvalue</name></decl>;</decl_stmt>
}</block></struct></type> <name>iziplongestobject</name>;</typedef>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>iziplongest_type</name></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>izip_longest_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>iziplongestobject</name> *</type><name>lz</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>ittuple</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>fillvalue</name> <init>= <expr><name>Py_None</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>tuplesize</name> <init>= <expr><call><name>PySequence_Length</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>kwds</name> != <name>NULL</name> &amp;&amp; <call><name>PyDict_CheckExact</name><argument_list>(<argument><expr><name>kwds</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>PyDict_Size</name><argument_list>(<argument><expr><name>kwds</name></expr></argument>)</argument_list></call> &gt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>fillvalue</name> = <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>kwds</name></expr></argument>, <argument><expr>"fillvalue"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>fillvalue</name> == <name>NULL</name> || <call><name>PyDict_Size</name><argument_list>(<argument><expr><name>kwds</name></expr></argument>)</argument_list></call> &gt; 1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"izip_longest() got an unexpected keyword argument"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
}</block></then></if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ittuple</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr><name>tuplesize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ittuple</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<for>for (<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name> &lt; <name>tuplesize</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>item</name> <init>= <expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>it</name> <init>= <expr><call><name>PyObject_GetIter</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>it</name> == <name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"izip_longest argument #%zd must support iteration"</expr></argument>,
<argument><expr><name>i</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>ittuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>ittuple</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><name>result</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr><name>tuplesize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>ittuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<for>for (<init><expr><name>i</name>=0</expr> ;</init> <condition><expr><name>i</name> &lt; <name>tuplesize</name></expr> ;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><name>lz</name> = (<name>iziplongestobject</name> *)<call><name><name>type</name>-&gt;<name>tp_alloc</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>lz</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>ittuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>lz</name>-&gt;<name>ittuple</name></name> = <name>ittuple</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lz</name>-&gt;<name>tuplesize</name></name> = <name>tuplesize</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lz</name>-&gt;<name>numactive</name></name> = <name>tuplesize</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lz</name>-&gt;<name>result</name></name> = <name>result</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>fillvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lz</name>-&gt;<name>fillvalue</name></name> = <name>fillvalue</name></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *)<name>lz</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>izip_longest_dealloc</name><parameter_list>(<param><decl><type><name>iziplongestobject</name> *</type><name>lz</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>PyObject_GC_UnTrack</name><argument_list>(<argument><expr><name>lz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>ittuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>result</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>fillvalue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>lz</name></expr></argument>)</argument_list></call>-&gt;<call><name>tp_free</name><argument_list>(<argument><expr><name>lz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>izip_longest_traverse</name><parameter_list>(<param><decl><type><name>iziplongestobject</name> *</type><name>lz</name></decl></param>, <param><decl><type><name>visitproc</name></type> <name>visit</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>ittuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>result</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>fillvalue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>izip_longest_next</name><parameter_list>(<param><decl><type><name>iziplongestobject</name> *</type><name>lz</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>tuplesize</name> <init>= <expr><name><name>lz</name>-&gt;<name>tuplesize</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name><name>lz</name>-&gt;<name>result</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>it</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>item</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>olditem</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>tuplesize</name> == 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name><name>lz</name>-&gt;<name>numactive</name></name> == 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>Py_REFCNT</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> == 1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name>=0</expr> ;</init> <condition><expr><name>i</name> &lt; <name>tuplesize</name></expr> ;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><name>it</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>ittuple</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>it</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>fillvalue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>item</name> = <name><name>lz</name>-&gt;<name>fillvalue</name></name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyIter_Check</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>item</name> = (*<call><name>Py_TYPE</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call>-&gt;<name>tp_iternext</name>)(<name>it</name>)</expr>;</expr_stmt>
<if>if <condition>(<expr><name>item</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>lz</name>-&gt;<name>numactive</name></name> -= 1</expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>lz</name>-&gt;<name>numactive</name></name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>fillvalue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>item</name> = <name><name>lz</name>-&gt;<name>fillvalue</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>ittuple</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
}</block></then></if>
}</block></else></if>
<expr_stmt><expr><name>olditem</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>olditem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>result</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr><name>tuplesize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<for>for (<init><expr><name>i</name>=0</expr> ;</init> <condition><expr><name>i</name> &lt; <name>tuplesize</name></expr> ;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><name>it</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>ittuple</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>it</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>fillvalue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>item</name> = <name><name>lz</name>-&gt;<name>fillvalue</name></name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyIter_Check</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>item</name> = (*<call><name>Py_TYPE</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call>-&gt;<name>tp_iternext</name>)(<name>it</name>)</expr>;</expr_stmt>
<if>if <condition>(<expr><name>item</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>lz</name>-&gt;<name>numactive</name></name> -= 1</expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>lz</name>-&gt;<name>numactive</name></name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>fillvalue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>item</name> = <name><name>lz</name>-&gt;<name>fillvalue</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name><name>lz</name>-&gt;<name>ittuple</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
}</block></then></if>
}</block></else></if>
<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
}</block></else></if>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>izip_longest_doc</name></expr></argument>,
<argument><expr>"izip_longest(iter1 [,iter2 [...]], [fillvalue=None]) --&gt; izip_longest object\n\
\n\
Return an izip_longest object whose .next() method returns a tuple where\n\
the i-th element comes from the i-th iterable argument. The .next()\n\
method continues until the longest iterable in the argument sequence\n\
is exhausted and then it raises StopIteration. When the shorter iterables\n\
are exhausted, the fillvalue is substituted in their place. The fillvalue\n\
defaults to None or can be specified by a keyword argument.\n\
"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>iziplongest_type</name> <init>= <expr><block>{
<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
"itertools.izip_longest"</expr>,
<expr><sizeof>sizeof<argument_list>(<argument><expr><name>iziplongestobject</name></expr></argument>)</argument_list></sizeof></expr>,
<expr>0</expr>,
<expr>(<name>destructor</name>)<name>izip_longest_dealloc</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>PyObject_GenericGetAttr</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_HAVE_GC</name> |
<name>Py_TPFLAGS_BASETYPE</name></expr>,
<expr><name>izip_longest_doc</name></expr>,
<expr>(<name>traverseproc</name>)<name>izip_longest_traverse</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>PyObject_SelfIter</name></expr>,
<expr>(<name>iternextfunc</name>)<name>izip_longest_next</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>izip_longest_new</name></expr>,
<expr><name>PyObject_GC_Del</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>module_doc</name></expr></argument>,
<argument><expr>"Functional tools for creating and using iterators.\n\
\n\
Infinite iterators:\n\
count([n]) --&gt; n, n+1, n+2, ...\n\
cycle(p) --&gt; p0, p1, ... plast, p0, p1, ...\n\
repeat(elem [,n]) --&gt; elem, elem, elem, ... endlessly or up to n times\n\
\n\
Iterators terminating on the shortest input sequence:\n\
izip(p, q, ...) --&gt; (p[0], q[0]), (p[1], q[1]), ... \n\
izip_longest(p, q, ...) --&gt; (p[0], q[0]), (p[1], q[1]), ... \n\
ifilter(pred, seq) --&gt; elements of seq where pred(elem) is True\n\
ifilterfalse(pred, seq) --&gt; elements of seq where pred(elem) is False\n\
islice(seq, [start,] stop [, step]) --&gt; elements from\n\
seq[start:stop:step]\n\
imap(fun, p, q, ...) --&gt; fun(p0, q0), fun(p1, q1), ...\n\
starmap(fun, seq) --&gt; fun(*seq[0]), fun(*seq[1]), ...\n\
tee(it, n=2) --&gt; (it1, it2 , ... itn) splits one iterator into n\n\
chain(p, q, ...) --&gt; p0, p1, ... plast, q0, q1, ... \n\
takewhile(pred, seq) --&gt; seq[0], seq[1], until pred fails\n\
dropwhile(pred, seq) --&gt; seq[n], seq[n+1], starting when pred fails\n\
groupby(iterable[, keyfunc]) --&gt; sub-iterators grouped by value of keyfunc(v)\n\
"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>module_methods</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr>"tee"</expr>, <expr>(<name>PyCFunction</name>)<name>tee</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>tee_doc</name></expr>}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<function><type><name>PyMODINIT_FUNC</name></type>
<name>inititertools</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyTypeObject</name> *</type><name><name>typelist</name><index>[]</index></name> <init>= <expr><block>{
<expr>&amp;<name>combinations_type</name></expr>,
<expr>&amp;<name>cycle_type</name></expr>,
<expr>&amp;<name>dropwhile_type</name></expr>,
<expr>&amp;<name>takewhile_type</name></expr>,
<expr>&amp;<name>islice_type</name></expr>,
<expr>&amp;<name>starmap_type</name></expr>,
<expr>&amp;<name>imap_type</name></expr>,
<expr>&amp;<name>chain_type</name></expr>,
<expr>&amp;<name>ifilter_type</name></expr>,
<expr>&amp;<name>ifilterfalse_type</name></expr>,
<expr>&amp;<name>count_type</name></expr>,
<expr>&amp;<name>izip_type</name></expr>,
<expr>&amp;<name>iziplongest_type</name></expr>,
<expr>&amp;<name>permutations_type</name></expr>,
<expr>&amp;<name>product_type</name></expr>,
<expr>&amp;<name>repeat_type</name></expr>,
<expr>&amp;<name>groupby_type</name></expr>,
<expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr>&amp;<name>teedataobject_type</name></expr></argument>)</argument_list></call> = &amp;<name>PyType_Type</name></expr>;</expr_stmt>
<expr_stmt><expr><name>m</name> = <call><name>Py_InitModule3</name><argument_list>(<argument><expr>"itertools"</expr></argument>, <argument><expr><name>module_methods</name></expr></argument>, <argument><expr><name>module_doc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>m</name> == <name>NULL</name></expr>)</condition><then>
<return>return;</return></then></if>
<for>for (<init><expr><name>i</name>=0</expr> ;</init> <condition><expr><name><name>typelist</name><index>[<expr><name>i</name></expr>]</index></name> != <name>NULL</name></expr> ;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<if>if <condition>(<expr><call><name>PyType_Ready</name><argument_list>(<argument><expr><name><name>typelist</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><name>name</name> = <call><name>strchr</name><argument_list>(<argument><expr><name><name>typelist</name><index>[<expr><name>i</name></expr>]</index></name>-&gt;<name>tp_name</name></expr></argument>, <argument><expr>'.'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr><name>name</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name><name>typelist</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr><name>name</name>+1</expr></argument>, <argument><expr>(<name>PyObject</name> *)<name><name>typelist</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<if>if <condition>(<expr><call><name>PyType_Ready</name><argument_list>(<argument><expr>&amp;<name>teedataobject_type</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return;</return></then></if>
<if>if <condition>(<expr><call><name>PyType_Ready</name><argument_list>(<argument><expr>&amp;<name>tee_type</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return;</return></then></if>
<if>if <condition>(<expr><call><name>PyType_Ready</name><argument_list>(<argument><expr>&amp;<name>_grouper_type</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return;</return></then></if>
}</block></function>
</unit>
