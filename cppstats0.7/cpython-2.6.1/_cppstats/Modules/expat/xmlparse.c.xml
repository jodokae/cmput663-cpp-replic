<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="Modules/expat/xmlparse.c"><cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_BUILDING_EXPAT</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>COMPILED_FROM_DSP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"winconfig.h"</cpp:file></cpp:include>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MACOS_CLASSIC</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"macconfig.h"</cpp:file></cpp:include>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__amigaos4__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"amigaconfig.h"</cpp:file></cpp:include>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_EXPAT_CONFIG_H</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;expat_config.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stddef.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"expat.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_ENCODE_MAX</name></cpp:macro> <cpp:value>XML_UTF16_ENCODE_MAX</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XmlConvert</name></cpp:macro> <cpp:value>XmlUtf16Convert</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XmlGetInternalEncoding</name></cpp:macro> <cpp:value>XmlGetUtf16InternalEncoding</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XmlGetInternalEncodingNS</name></cpp:macro> <cpp:value>XmlGetUtf16InternalEncodingNS</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XmlEncode</name></cpp:macro> <cpp:value>XmlUtf16Encode</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MUST_CONVERT</name><parameter_list>(<param><type><name>enc</name></type></param>, <param><type><name>s</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(!(enc)-&gt;isUtf16 || (((unsigned long)s) &amp; 1))</cpp:value></cpp:define>
<typedef>typedef <type><name>unsigned</name> <name>short</name></type> <name>ICHAR</name>;</typedef>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_ENCODE_MAX</name></cpp:macro> <cpp:value>XML_UTF8_ENCODE_MAX</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XmlConvert</name></cpp:macro> <cpp:value>XmlUtf8Convert</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XmlGetInternalEncoding</name></cpp:macro> <cpp:value>XmlGetUtf8InternalEncoding</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XmlGetInternalEncodingNS</name></cpp:macro> <cpp:value>XmlGetUtf8InternalEncodingNS</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XmlEncode</name></cpp:macro> <cpp:value>XmlUtf8Encode</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MUST_CONVERT</name><parameter_list>(<param><type><name>enc</name></type></param>, <param><type><name>s</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(!(enc)-&gt;isUtf8)</cpp:value></cpp:define>
<typedef>typedef <type><name>char</name></type> <name>ICHAR</name>;</typedef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>XML_NS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XmlInitEncodingNS</name></cpp:macro> <cpp:value>XmlInitEncoding</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XmlInitUnknownEncodingNS</name></cpp:macro> <cpp:value>XmlInitUnknownEncoding</cpp:value></cpp:define>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>XmlGetInternalEncodingNS</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XmlGetInternalEncodingNS</name></cpp:macro> <cpp:value>XmlGetInternalEncoding</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XmlParseXmlDeclNS</name></cpp:macro> <cpp:value>XmlParseXmlDecl</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_UNICODE_WCHAR_T</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_T</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(const wchar_t)x</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_L</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>L ##x</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_T</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(const unsigned short)x</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_L</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>x</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_T</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>x</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>XML_L</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>x</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ROUND_UP</name><parameter_list>(<param><type><name>n</name></type></param>, <param><type><name>sz</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(((n) + ((sz) - 1)) &amp; ~((sz) - 1))</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>HAVE_MEMMOVE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_BCOPY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>memmove</name><parameter_list>(<param><type><name>d</name></type></param>,<param><type><name>s</name></type></param>,<param><type><name>l</name></type></param>)</parameter_list></cpp:macro> <cpp:value>bcopy((s),(d),(l))</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:error>#<cpp:directive>error</cpp:directive> memmove does not exist on this platform, nor is a substitute available</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"xmltok.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"xmlrole.h"</cpp:file></cpp:include>
<typedef>typedef <type><specifier>const</specifier> <name>XML_Char</name> *</type><name>KEY</name>;</typedef>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>KEY</name></type> <name>name</name></decl>;</decl_stmt>
}</block></struct></type> <name>NAMED</name>;</typedef>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>NAMED</name> **</type><name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>power</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>used</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Memory_Handling_Suite</name> *</type><name>mem</name></decl>;</decl_stmt>
}</block></struct></type> <name>HASH_TABLE</name>;</typedef>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHAR_HASH</name><parameter_list>(<param><type><name>h</name></type></param>, <param><type><name>c</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(((h) * 0xF4243) ^ (unsigned short)(c))</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHAR_HASH</name><parameter_list>(<param><type><name>h</name></type></param>, <param><type><name>c</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(((h) * 0xF4243) ^ (unsigned char)(c))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SECOND_HASH</name><parameter_list>(<param><type><name>hash</name></type></param>, <param><type><name>mask</name></type></param>, <param><type><name>power</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((((hash) &amp; ~(mask)) &gt;&gt; ((power) - 1)) &amp; ((mask) &gt;&gt; 2))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PROBE_STEP</name><parameter_list>(<param><type><name>hash</name></type></param>, <param><type><name>mask</name></type></param>, <param><type><name>power</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((unsigned char)((SECOND_HASH(hash, mask, power)) | 1))</cpp:value></cpp:define>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>NAMED</name> **</type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>NAMED</name> **</type><name>end</name></decl>;</decl_stmt>
}</block></struct></type> <name>HASH_TABLE_ITER</name>;</typedef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INIT_TAG_BUF_SIZE</name></cpp:macro> <cpp:value>32</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INIT_DATA_BUF_SIZE</name></cpp:macro> <cpp:value>1024</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INIT_ATTS_SIZE</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INIT_ATTS_VERSION</name></cpp:macro> <cpp:value>0xFFFFFFFF</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INIT_BLOCK_SIZE</name></cpp:macro> <cpp:value>1024</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INIT_BUFFER_SIZE</name></cpp:macro> <cpp:value>1024</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPAND_SPARE</name></cpp:macro> <cpp:value>24</cpp:value></cpp:define>
<typedef>typedef <type><struct>struct <name>binding</name> <block>{
<decl_stmt><decl><type>struct <name>prefix</name> *</type><name>prefix</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>binding</name> *</type><name>nextTagBinding</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>binding</name> *</type><name>prevPrefixBinding</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> struct <name>attribute_id</name> *</type><name>attId</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Char</name> *</type><name>uri</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>uriLen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>uriAlloc</name></decl>;</decl_stmt>
}</block></struct></type> <name>BINDING</name>;</typedef>
<typedef>typedef <type><struct>struct <name>prefix</name> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BINDING</name> *</type><name>binding</name></decl>;</decl_stmt>
}</block></struct></type> <name>PREFIX</name>;</typedef>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>localPart</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>prefix</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>strLen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>uriLen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>prefixLen</name></decl>;</decl_stmt>
}</block></struct></type> <name>TAG_NAME</name>;</typedef>
<typedef>typedef <type><struct>struct <name>tag</name> <block>{
<decl_stmt><decl><type>struct <name>tag</name> *</type><name>parent</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>rawName</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>rawNameLength</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TAG_NAME</name></type> <name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>bufEnd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BINDING</name> *</type><name>bindings</name></decl>;</decl_stmt>
}</block></struct></type> <name>TAG</name>;</typedef>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>textPtr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>textLen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>processed</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>systemId</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>base</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>publicId</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>notation</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Bool</name></type> <name>open</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Bool</name></type> <name>is_param</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Bool</name></type> <name>is_internal</name></decl>;</decl_stmt>
}</block></struct></type> <name>ENTITY</name>;</typedef>
<typedef>typedef <type><struct>struct <block>{
<enum>enum <name>XML_Content_Type</name> <name>type</name>;</enum>
<enum>enum <name>XML_Content_Quant</name> <name>quant</name>;</enum>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type> <name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>firstchild</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>lastchild</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>childcnt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nextsib</name></decl>;</decl_stmt>
}</block></struct></type> <name>CONTENT_SCAFFOLD</name>;</typedef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INIT_SCAFFOLD_ELEMENTS</name></cpp:macro> <cpp:value>32</cpp:value></cpp:define>
<typedef>typedef <type><struct>struct <name>block</name> <block>{
<decl_stmt><decl><type>struct <name>block</name> *</type><name>next</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Char</name></type> <name><name>s</name><index>[<expr>1</expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>BLOCK</name>;</typedef>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>BLOCK</name> *</type><name>blocks</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BLOCK</name> *</type><name>freeBlocks</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Char</name> *</type><name>ptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Char</name> *</type><name>start</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Memory_Handling_Suite</name> *</type><name>mem</name></decl>;</decl_stmt>
}</block></struct></type> <name>STRING_POOL</name>;</typedef>
<typedef>typedef <type><struct>struct <name>attribute_id</name> <block>{
<decl_stmt><decl><type><name>XML_Char</name> *</type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PREFIX</name> *</type><name>prefix</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Bool</name></type> <name>maybeTokenized</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Bool</name></type> <name>xmlns</name></decl>;</decl_stmt>
}</block></struct></type> <name>ATTRIBUTE_ID</name>;</typedef>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>ATTRIBUTE_ID</name> *</type><name>id</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Bool</name></type> <name>isCdata</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>value</name></decl>;</decl_stmt>
}</block></struct></type> <name>DEFAULT_ATTRIBUTE</name>;</typedef>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>version</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>hash</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>uriName</name></decl>;</decl_stmt>
}</block></struct></type> <name>NS_ATT</name>;</typedef>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PREFIX</name> *</type><name>prefix</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ATTRIBUTE_ID</name> *</type><name>idAtt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nDefaultAtts</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>allocDefaultAtts</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DEFAULT_ATTRIBUTE</name> *</type><name>defaultAtts</name></decl>;</decl_stmt>
}</block></struct></type> <name>ELEMENT_TYPE</name>;</typedef>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>HASH_TABLE</name></type> <name>generalEntities</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HASH_TABLE</name></type> <name>elementTypes</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HASH_TABLE</name></type> <name>attributeIds</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HASH_TABLE</name></type> <name>prefixes</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>STRING_POOL</name></type> <name>pool</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>STRING_POOL</name></type> <name>entityValuePool</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Bool</name></type> <name>keepProcessing</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Bool</name></type> <name>hasParamEntityRefs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Bool</name></type> <name>standalone</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>XML_Bool</name></type> <name>paramEntityRead</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HASH_TABLE</name></type> <name>paramEntities</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>PREFIX</name></type> <name>defaultPrefix</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Bool</name></type> <name>in_eldecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CONTENT_SCAFFOLD</name> *</type><name>scaffold</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>contentStringLen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>scaffSize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>scaffCount</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>scaffLevel</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name> *</type><name>scaffIndex</name></decl>;</decl_stmt>
}</block></struct></type> <name>DTD</name>;</typedef>
<typedef>typedef <type><struct>struct <name>open_internal_entity</name> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>internalEventPtr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>internalEventEndPtr</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>open_internal_entity</name> *</type><name>next</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ENTITY</name> *</type><name>entity</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>startTagLevel</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Bool</name></type> <name>betweenDecl</name></decl>;</decl_stmt>
}</block></struct></type> <name>OPEN_INTERNAL_ENTITY</name>;</typedef>
<typedef>typedef <type><enum>enum <name>XML_Error</name> <name>PTRCALL</name> <name>Processor</name><expr_stmt><expr>(<name>XML_Parser</name> <name>parser</name>,
const <name>char</name> *<name>start</name>,
const <name>char</name> *<name>end</name>,
const <name>char</name> **<name>endPtr</name>)</expr>;</expr_stmt></enum></type></typedef>
<decl_stmt><decl><type><specifier>static</specifier> <name>Processor</name></type> <name>prologProcessor</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>Processor</name></type> <name>prologInitProcessor</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>Processor</name></type> <name>contentProcessor</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>Processor</name></type> <name>cdataSectionProcessor</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <name>Processor</name></type> <name>ignoreSectionProcessor</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>Processor</name></type> <name>externalParEntProcessor</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>Processor</name></type> <name>externalParEntInitProcessor</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>Processor</name></type> <name>entityValueProcessor</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>Processor</name></type> <name>entityValueInitProcessor</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><specifier>static</specifier> <name>Processor</name></type> <name>epilogProcessor</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>Processor</name></type> <name>errorProcessor</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>Processor</name></type> <name>externalEntityInitProcessor</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>Processor</name></type> <name>externalEntityInitProcessor2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>Processor</name></type> <name>externalEntityInitProcessor3</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>Processor</name></type> <name>externalEntityContentProcessor</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>Processor</name></type> <name>internalEntityProcessor</name></decl>;</decl_stmt>
<enum><specifier>static</specifier> enum <name>XML_Error</name>
<name>handleUnknownEncoding</name><expr_stmt><expr>(<name>XML_Parser</name> <name>parser</name>, const <name>XML_Char</name> *<name>encodingName</name>)</expr>;</expr_stmt></enum>
<enum><specifier>static</specifier> enum <name>XML_Error</name>
<name>processXmlDecl</name><expr_stmt><expr>(<name>XML_Parser</name> <name>parser</name>, <name>int</name> <name>isGeneralTextEntity</name>,
const <name>char</name> *<name>s</name>, const <name>char</name> *<name>next</name>)</expr>;</expr_stmt></enum>
<enum><specifier>static</specifier> enum <name>XML_Error</name>
<name>initializeEncoding</name><expr_stmt><expr>(<name>XML_Parser</name> <name>parser</name>)</expr>;</expr_stmt></enum>
<enum><specifier>static</specifier> enum <name>XML_Error</name>
<name>doProlog</name><expr_stmt><expr>(<name>XML_Parser</name> <name>parser</name>, const <name>ENCODING</name> *<name>enc</name>, const <name>char</name> *<name>s</name>,
const <name>char</name> *<name>end</name>, <name>int</name> <name>tok</name>, const <name>char</name> *<name>next</name>, const <name>char</name> **<name>nextPtr</name>,
<name>XML_Bool</name> <name>haveMore</name>)</expr>;</expr_stmt></enum>
<enum><specifier>static</specifier> enum <name>XML_Error</name>
<name>processInternalEntity</name><expr_stmt><expr>(<name>XML_Parser</name> <name>parser</name>, <name>ENTITY</name> *<name>entity</name>,
<name>XML_Bool</name> <name>betweenDecl</name>)</expr>;</expr_stmt></enum>
<enum><specifier>static</specifier> enum <name>XML_Error</name>
<name>doContent</name><expr_stmt><expr>(<name>XML_Parser</name> <name>parser</name>, <name>int</name> <name>startTagLevel</name>, const <name>ENCODING</name> *<name>enc</name>,
const <name>char</name> *<name>start</name>, const <name>char</name> *<name>end</name>, const <name>char</name> **<name>endPtr</name>,
<name>XML_Bool</name> <name>haveMore</name>)</expr>;</expr_stmt></enum>
<enum><specifier>static</specifier> enum <name>XML_Error</name>
<name>doCdataSection</name><expr_stmt><expr>(<name>XML_Parser</name> <name>parser</name>, const <name>ENCODING</name> *, const <name>char</name> **<name>startPtr</name>,
const <name>char</name> *<name>end</name>, const <name>char</name> **<name>nextPtr</name>, <name>XML_Bool</name> <name>haveMore</name>)</expr>;</expr_stmt></enum>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<enum><specifier>static</specifier> enum <name>XML_Error</name>
<name>doIgnoreSection</name><expr_stmt><expr>(<name>XML_Parser</name> <name>parser</name>, const <name>ENCODING</name> *, const <name>char</name> **<name>startPtr</name>,
const <name>char</name> *<name>end</name>, const <name>char</name> **<name>nextPtr</name>, <name>XML_Bool</name> <name>haveMore</name>)</expr>;</expr_stmt></enum>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<enum><specifier>static</specifier> enum <name>XML_Error</name>
<name>storeAtts</name><expr_stmt><expr>(<name>XML_Parser</name> <name>parser</name>, const <name>ENCODING</name> *, const <name>char</name> *<name>s</name>,
<name>TAG_NAME</name> *<name>tagNamePtr</name>, <name>BINDING</name> **<name>bindingsPtr</name>)</expr>;</expr_stmt></enum>
<enum><specifier>static</specifier> enum <name>XML_Error</name>
<name>addBinding</name><expr_stmt><expr>(<name>XML_Parser</name> <name>parser</name>, <name>PREFIX</name> *<name>prefix</name>, const <name>ATTRIBUTE_ID</name> *<name>attId</name>,
const <name>XML_Char</name> *<name>uri</name>, <name>BINDING</name> **<name>bindingsPtr</name>)</expr>;</expr_stmt></enum>
<function_decl><type><specifier>static</specifier> <name>int</name></type>
<name>defineAttribute</name><parameter_list>(<param><decl><type><name>ELEMENT_TYPE</name> *</type><name>type</name></decl></param>, <param><decl><type><name>ATTRIBUTE_ID</name> *</type></decl></param>, <param><decl><type><name>XML_Bool</name></type> <name>isCdata</name></decl></param>,
<param><decl><type><name>XML_Bool</name></type> <name>isId</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>dfltValue</name></decl></param>, <param><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></param>)</parameter_list>;</function_decl>
<enum><specifier>static</specifier> enum <name>XML_Error</name>
<name>storeAttributeValue</name><expr_stmt><expr>(<name>XML_Parser</name> <name>parser</name>, const <name>ENCODING</name> *, <name>XML_Bool</name> <name>isCdata</name>,
const <name>char</name> *, const <name>char</name> *, <name>STRING_POOL</name> *)</expr>;</expr_stmt></enum>
<enum><specifier>static</specifier> enum <name>XML_Error</name>
<name>appendAttributeValue</name><expr_stmt><expr>(<name>XML_Parser</name> <name>parser</name>, const <name>ENCODING</name> *, <name>XML_Bool</name> <name>isCdata</name>,
const <name>char</name> *, const <name>char</name> *, <name>STRING_POOL</name> *)</expr>;</expr_stmt></enum>
<function_decl><type><specifier>static</specifier> <name>ATTRIBUTE_ID</name> *</type>
<name>getAttributeId</name><parameter_list>(<param><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>start</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>end</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>
<name>setElementTypePrefix</name><parameter_list>(<param><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></param>, <param><decl><type><name>ELEMENT_TYPE</name> *</type></decl></param>)</parameter_list>;</function_decl>
<enum><specifier>static</specifier> enum <name>XML_Error</name>
<name>storeEntityValue</name><expr_stmt><expr>(<name>XML_Parser</name> <name>parser</name>, const <name>ENCODING</name> *<name>enc</name>, const <name>char</name> *<name>start</name>,
const <name>char</name> *<name>end</name>)</expr>;</expr_stmt></enum>
<function_decl><type><specifier>static</specifier> <name>int</name></type>
<name>reportProcessingInstruction</name><parameter_list>(<param><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>start</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>end</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>
<name>reportComment</name><parameter_list>(<param><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>start</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>end</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>
<name>reportDefault</name><parameter_list>(<param><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>start</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>end</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>XML_Char</name> *</type> <name>getContext</name><parameter_list>(<param><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>XML_Bool</name></type>
<name>setContext</name><parameter_list>(<param><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>context</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name> <name>FASTCALL</name></type> <name>normalizePublicId</name><parameter_list>(<param><decl><type><name>XML_Char</name> *</type><name>s</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>DTD</name> *</type> <name>dtdCreate</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>XML_Memory_Handling_Suite</name> *</type><name>ms</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dtdReset</name><parameter_list>(<param><decl><type><name>DTD</name> *</type><name>p</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>XML_Memory_Handling_Suite</name> *</type><name>ms</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>
<name>dtdDestroy</name><parameter_list>(<param><decl><type><name>DTD</name> *</type><name>p</name></decl></param>, <param><decl><type><name>XML_Bool</name></type> <name>isDocEntity</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>XML_Memory_Handling_Suite</name> *</type><name>ms</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>
<name>dtdCopy</name><parameter_list>(<param><decl><type><name>DTD</name> *</type><name>newDtd</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>DTD</name> *</type><name>oldDtd</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>XML_Memory_Handling_Suite</name> *</type><name>ms</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>
<name>copyEntityTable</name><parameter_list>(<param><decl><type><name>HASH_TABLE</name> *</type></decl></param>, <param><decl><type><name>STRING_POOL</name> *</type></decl></param>, <param><decl><type><specifier>const</specifier></type> <name>HASH_TABLE</name> *</decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>NAMED</name> *</type>
<name>lookup</name><parameter_list>(<param><decl><type><name>HASH_TABLE</name> *</type><name>table</name></decl></param>, <param><decl><type><name>KEY</name></type> <name>name</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>createSize</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name> <name>FASTCALL</name></type>
<name>hashTableInit</name><parameter_list>(<param><decl><type><name>HASH_TABLE</name> *</type></decl></param>, <param><decl><type><specifier>const</specifier> <name>XML_Memory_Handling_Suite</name> *</type><name>ms</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name> <name>FASTCALL</name></type> <name>hashTableClear</name><parameter_list>(<param><decl><type><name>HASH_TABLE</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name> <name>FASTCALL</name></type> <name>hashTableDestroy</name><parameter_list>(<param><decl><type><name>HASH_TABLE</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name> <name>FASTCALL</name></type>
<name>hashTableIterInit</name><parameter_list>(<param><decl><type><name>HASH_TABLE_ITER</name> *</type></decl></param>, <param><decl><type><specifier>const</specifier></type> <name>HASH_TABLE</name> *</decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>NAMED</name> * <name>FASTCALL</name></type> <name>hashTableIterNext</name><parameter_list>(<param><decl><type><name>HASH_TABLE_ITER</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name> <name>FASTCALL</name></type>
<name>poolInit</name><parameter_list>(<param><decl><type><name>STRING_POOL</name> *</type></decl></param>, <param><decl><type><specifier>const</specifier> <name>XML_Memory_Handling_Suite</name> *</type><name>ms</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name> <name>FASTCALL</name></type> <name>poolClear</name><parameter_list>(<param><decl><type><name>STRING_POOL</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name> <name>FASTCALL</name></type> <name>poolDestroy</name><parameter_list>(<param><decl><type><name>STRING_POOL</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>XML_Char</name> *</type>
<name>poolAppend</name><parameter_list>(<param><decl><type><name>STRING_POOL</name> *</type><name>pool</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ptr</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>end</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>XML_Char</name> *</type>
<name>poolStoreString</name><parameter_list>(<param><decl><type><name>STRING_POOL</name> *</type><name>pool</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ptr</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>end</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>XML_Bool</name> <name>FASTCALL</name></type> <name>poolGrow</name><parameter_list>(<param><decl><type><name>STRING_POOL</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>XML_Char</name> * <name>FASTCALL</name></type>
<name>poolCopyString</name><parameter_list>(<param><decl><type><name>STRING_POOL</name> *</type><name>pool</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>s</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>XML_Char</name> *</type>
<name>poolCopyStringN</name><parameter_list>(<param><decl><type><name>STRING_POOL</name> *</type><name>pool</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>s</name></decl></param>, <param><decl><type><name>int</name></type> <name>n</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>XML_Char</name> * <name>FASTCALL</name></type>
<name>poolAppendString</name><parameter_list>(<param><decl><type><name>STRING_POOL</name> *</type><name>pool</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>s</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name> <name>FASTCALL</name></type> <name>nextScaffoldPart</name><parameter_list>(<param><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>XML_Content</name> *</type> <name>build_model</name><parameter_list>(<param><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ELEMENT_TYPE</name> *</type>
<name>getElementType</name><parameter_list>(<param><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ptr</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>end</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>XML_Parser</name></type>
<name>parserCreate</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>encodingName</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>XML_Memory_Handling_Suite</name> *</type><name>memsuite</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>nameSep</name></decl></param>,
<param><decl><type><name>DTD</name> *</type><name>dtd</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type>
<name>parserInit</name><parameter_list>(<param><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>encodingName</name></decl></param>)</parameter_list>;</function_decl>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>poolStart</name><parameter_list>(<param><type><name>pool</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((pool)-&gt;start)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>poolEnd</name><parameter_list>(<param><type><name>pool</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((pool)-&gt;ptr)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>poolLength</name><parameter_list>(<param><type><name>pool</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((pool)-&gt;ptr - (pool)-&gt;start)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>poolChop</name><parameter_list>(<param><type><name>pool</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((void)--(pool-&gt;ptr))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>poolLastChar</name><parameter_list>(<param><type><name>pool</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(((pool)-&gt;ptr)[-1])</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>poolDiscard</name><parameter_list>(<param><type><name>pool</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((pool)-&gt;ptr = (pool)-&gt;start)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>poolFinish</name><parameter_list>(<param><type><name>pool</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((pool)-&gt;start = (pool)-&gt;ptr)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>poolAppendChar</name><parameter_list>(<param><type><name>pool</name></type></param>, <param><type><name>c</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(((pool)-&gt;ptr == (pool)-&gt;end &amp;&amp; !poolGrow(pool)) ? 0 : ((*((pool)-&gt;ptr)++ = c), 1))</cpp:value></cpp:define>
<struct>struct <name>XML_ParserStruct</name> <block>{
<decl_stmt><decl><type><name>void</name> *</type><name>m_userData</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> *</type><name>m_handlerArg</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>m_buffer</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Memory_Handling_Suite</name></type> <name>m_mem</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>m_bufferPtr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>m_bufferEnd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>m_bufferLim</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Index</name></type> <name>m_parseEndByteIndex</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>m_parseEndPtr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Char</name> *</type><name>m_dataBuf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Char</name> *</type><name>m_dataBufEnd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_StartElementHandler</name></type> <name>m_startElementHandler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_EndElementHandler</name></type> <name>m_endElementHandler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_CharacterDataHandler</name></type> <name>m_characterDataHandler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_ProcessingInstructionHandler</name></type> <name>m_processingInstructionHandler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_CommentHandler</name></type> <name>m_commentHandler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_StartCdataSectionHandler</name></type> <name>m_startCdataSectionHandler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_EndCdataSectionHandler</name></type> <name>m_endCdataSectionHandler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_DefaultHandler</name></type> <name>m_defaultHandler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_StartDoctypeDeclHandler</name></type> <name>m_startDoctypeDeclHandler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_EndDoctypeDeclHandler</name></type> <name>m_endDoctypeDeclHandler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_UnparsedEntityDeclHandler</name></type> <name>m_unparsedEntityDeclHandler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_NotationDeclHandler</name></type> <name>m_notationDeclHandler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_StartNamespaceDeclHandler</name></type> <name>m_startNamespaceDeclHandler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_EndNamespaceDeclHandler</name></type> <name>m_endNamespaceDeclHandler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_NotStandaloneHandler</name></type> <name>m_notStandaloneHandler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_ExternalEntityRefHandler</name></type> <name>m_externalEntityRefHandler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Parser</name></type> <name>m_externalEntityRefHandlerArg</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_SkippedEntityHandler</name></type> <name>m_skippedEntityHandler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_UnknownEncodingHandler</name></type> <name>m_unknownEncodingHandler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_ElementDeclHandler</name></type> <name>m_elementDeclHandler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_AttlistDeclHandler</name></type> <name>m_attlistDeclHandler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_EntityDeclHandler</name></type> <name>m_entityDeclHandler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_XmlDeclHandler</name></type> <name>m_xmlDeclHandler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>m_encoding</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>INIT_ENCODING</name></type> <name>m_initEncoding</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>m_internalEncoding</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>m_protocolEncodingName</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Bool</name></type> <name>m_ns</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Bool</name></type> <name>m_ns_triplets</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> *</type><name>m_unknownEncodingMem</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> *</type><name>m_unknownEncodingData</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> *</type><name>m_unknownEncodingHandlerData</name></decl>;</decl_stmt>
<function_decl><type><name>void</name></type> (<name>XMLCALL</name> *<name>m_unknownEncodingRelease</name>)<parameter_list>(<param><decl><type><name>void</name> *</type></decl></param>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>PROLOG_STATE</name></type> <name>m_prologState</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Processor</name> *</type><name>m_processor</name></decl>;</decl_stmt>
<enum>enum <name>XML_Error</name> <name>m_errorCode</name>;</enum>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>m_eventPtr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>m_eventEndPtr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>m_positionPtr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OPEN_INTERNAL_ENTITY</name> *</type><name>m_openInternalEntities</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OPEN_INTERNAL_ENTITY</name> *</type><name>m_freeInternalEntities</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Bool</name></type> <name>m_defaultExpandInternalEntities</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>m_tagLevel</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ENTITY</name> *</type><name>m_declEntity</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>m_doctypeName</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>m_doctypeSysid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>m_doctypePubid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>m_declAttributeType</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>m_declNotationName</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>m_declNotationPublicId</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ELEMENT_TYPE</name> *</type><name>m_declElementType</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ATTRIBUTE_ID</name> *</type><name>m_declAttributeId</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Bool</name></type> <name>m_declAttributeIsCdata</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Bool</name></type> <name>m_declAttributeIsId</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DTD</name> *</type><name>m_dtd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>m_curBase</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TAG</name> *</type><name>m_tagStack</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TAG</name> *</type><name>m_freeTagList</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BINDING</name> *</type><name>m_inheritedBindings</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BINDING</name> *</type><name>m_freeBindingList</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>m_attsSize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>m_nSpecifiedAtts</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>m_idAttIndex</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ATTRIBUTE</name> *</type><name>m_atts</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>NS_ATT</name> *</type><name>m_nsAtts</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>m_nsAttsVersion</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>m_nsAttsPower</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>POSITION</name></type> <name>m_position</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>STRING_POOL</name></type> <name>m_tempPool</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>STRING_POOL</name></type> <name>m_temp2Pool</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>m_groupConnector</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>m_groupSize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Char</name></type> <name>m_namespaceSeparator</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Parser</name></type> <name>m_parentParser</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_ParsingStatus</name></type> <name>m_parsingStatus</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>XML_Bool</name></type> <name>m_isParamEntity</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Bool</name></type> <name>m_useForeignDTD</name></decl>;</decl_stmt>
<enum>enum <name>XML_ParamEntityParsing</name> <name>m_paramEntityParsing</name>;</enum>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block>;</struct>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MALLOC</name><parameter_list>(<param><type><name>s</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(parser-&gt;m_mem.malloc_fcn((s)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REALLOC</name><parameter_list>(<param><type><name>p</name></type></param>,<param><type><name>s</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(parser-&gt;m_mem.realloc_fcn((p),(s)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FREE</name><parameter_list>(<param><type><name>p</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(parser-&gt;m_mem.free_fcn((p)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>userData</name></cpp:macro> <cpp:value>(parser-&gt;m_userData)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>handlerArg</name></cpp:macro> <cpp:value>(parser-&gt;m_handlerArg)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>startElementHandler</name></cpp:macro> <cpp:value>(parser-&gt;m_startElementHandler)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>endElementHandler</name></cpp:macro> <cpp:value>(parser-&gt;m_endElementHandler)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>characterDataHandler</name></cpp:macro> <cpp:value>(parser-&gt;m_characterDataHandler)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>processingInstructionHandler</name></cpp:macro> <cpp:value>(parser-&gt;m_processingInstructionHandler)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>commentHandler</name></cpp:macro> <cpp:value>(parser-&gt;m_commentHandler)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>startCdataSectionHandler</name></cpp:macro> <cpp:value>(parser-&gt;m_startCdataSectionHandler)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>endCdataSectionHandler</name></cpp:macro> <cpp:value>(parser-&gt;m_endCdataSectionHandler)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>defaultHandler</name></cpp:macro> <cpp:value>(parser-&gt;m_defaultHandler)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>startDoctypeDeclHandler</name></cpp:macro> <cpp:value>(parser-&gt;m_startDoctypeDeclHandler)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>endDoctypeDeclHandler</name></cpp:macro> <cpp:value>(parser-&gt;m_endDoctypeDeclHandler)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>unparsedEntityDeclHandler</name></cpp:macro> <cpp:value>(parser-&gt;m_unparsedEntityDeclHandler)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>notationDeclHandler</name></cpp:macro> <cpp:value>(parser-&gt;m_notationDeclHandler)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>startNamespaceDeclHandler</name></cpp:macro> <cpp:value>(parser-&gt;m_startNamespaceDeclHandler)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>endNamespaceDeclHandler</name></cpp:macro> <cpp:value>(parser-&gt;m_endNamespaceDeclHandler)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>notStandaloneHandler</name></cpp:macro> <cpp:value>(parser-&gt;m_notStandaloneHandler)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>externalEntityRefHandler</name></cpp:macro> <cpp:value>(parser-&gt;m_externalEntityRefHandler)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>externalEntityRefHandlerArg</name></cpp:macro> <cpp:value>(parser-&gt;m_externalEntityRefHandlerArg)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>internalEntityRefHandler</name></cpp:macro> <cpp:value>(parser-&gt;m_internalEntityRefHandler)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>skippedEntityHandler</name></cpp:macro> <cpp:value>(parser-&gt;m_skippedEntityHandler)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>unknownEncodingHandler</name></cpp:macro> <cpp:value>(parser-&gt;m_unknownEncodingHandler)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>elementDeclHandler</name></cpp:macro> <cpp:value>(parser-&gt;m_elementDeclHandler)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>attlistDeclHandler</name></cpp:macro> <cpp:value>(parser-&gt;m_attlistDeclHandler)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>entityDeclHandler</name></cpp:macro> <cpp:value>(parser-&gt;m_entityDeclHandler)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>xmlDeclHandler</name></cpp:macro> <cpp:value>(parser-&gt;m_xmlDeclHandler)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>encoding</name></cpp:macro> <cpp:value>(parser-&gt;m_encoding)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>initEncoding</name></cpp:macro> <cpp:value>(parser-&gt;m_initEncoding)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>internalEncoding</name></cpp:macro> <cpp:value>(parser-&gt;m_internalEncoding)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>unknownEncodingMem</name></cpp:macro> <cpp:value>(parser-&gt;m_unknownEncodingMem)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>unknownEncodingData</name></cpp:macro> <cpp:value>(parser-&gt;m_unknownEncodingData)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>unknownEncodingHandlerData</name></cpp:macro> <cpp:value>(parser-&gt;m_unknownEncodingHandlerData)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>unknownEncodingRelease</name></cpp:macro> <cpp:value>(parser-&gt;m_unknownEncodingRelease)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>protocolEncodingName</name></cpp:macro> <cpp:value>(parser-&gt;m_protocolEncodingName)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ns</name></cpp:macro> <cpp:value>(parser-&gt;m_ns)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ns_triplets</name></cpp:macro> <cpp:value>(parser-&gt;m_ns_triplets)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>prologState</name></cpp:macro> <cpp:value>(parser-&gt;m_prologState)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>processor</name></cpp:macro> <cpp:value>(parser-&gt;m_processor)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>errorCode</name></cpp:macro> <cpp:value>(parser-&gt;m_errorCode)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>eventPtr</name></cpp:macro> <cpp:value>(parser-&gt;m_eventPtr)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>eventEndPtr</name></cpp:macro> <cpp:value>(parser-&gt;m_eventEndPtr)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>positionPtr</name></cpp:macro> <cpp:value>(parser-&gt;m_positionPtr)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>position</name></cpp:macro> <cpp:value>(parser-&gt;m_position)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>openInternalEntities</name></cpp:macro> <cpp:value>(parser-&gt;m_openInternalEntities)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>freeInternalEntities</name></cpp:macro> <cpp:value>(parser-&gt;m_freeInternalEntities)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>defaultExpandInternalEntities</name></cpp:macro> <cpp:value>(parser-&gt;m_defaultExpandInternalEntities)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>tagLevel</name></cpp:macro> <cpp:value>(parser-&gt;m_tagLevel)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>buffer</name></cpp:macro> <cpp:value>(parser-&gt;m_buffer)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>bufferPtr</name></cpp:macro> <cpp:value>(parser-&gt;m_bufferPtr)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>bufferEnd</name></cpp:macro> <cpp:value>(parser-&gt;m_bufferEnd)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>parseEndByteIndex</name></cpp:macro> <cpp:value>(parser-&gt;m_parseEndByteIndex)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>parseEndPtr</name></cpp:macro> <cpp:value>(parser-&gt;m_parseEndPtr)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>bufferLim</name></cpp:macro> <cpp:value>(parser-&gt;m_bufferLim)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>dataBuf</name></cpp:macro> <cpp:value>(parser-&gt;m_dataBuf)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>dataBufEnd</name></cpp:macro> <cpp:value>(parser-&gt;m_dataBufEnd)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_dtd</name></cpp:macro> <cpp:value>(parser-&gt;m_dtd)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>curBase</name></cpp:macro> <cpp:value>(parser-&gt;m_curBase)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>declEntity</name></cpp:macro> <cpp:value>(parser-&gt;m_declEntity)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>doctypeName</name></cpp:macro> <cpp:value>(parser-&gt;m_doctypeName)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>doctypeSysid</name></cpp:macro> <cpp:value>(parser-&gt;m_doctypeSysid)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>doctypePubid</name></cpp:macro> <cpp:value>(parser-&gt;m_doctypePubid)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>declAttributeType</name></cpp:macro> <cpp:value>(parser-&gt;m_declAttributeType)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>declNotationName</name></cpp:macro> <cpp:value>(parser-&gt;m_declNotationName)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>declNotationPublicId</name></cpp:macro> <cpp:value>(parser-&gt;m_declNotationPublicId)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>declElementType</name></cpp:macro> <cpp:value>(parser-&gt;m_declElementType)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>declAttributeId</name></cpp:macro> <cpp:value>(parser-&gt;m_declAttributeId)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>declAttributeIsCdata</name></cpp:macro> <cpp:value>(parser-&gt;m_declAttributeIsCdata)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>declAttributeIsId</name></cpp:macro> <cpp:value>(parser-&gt;m_declAttributeIsId)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>freeTagList</name></cpp:macro> <cpp:value>(parser-&gt;m_freeTagList)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>freeBindingList</name></cpp:macro> <cpp:value>(parser-&gt;m_freeBindingList)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>inheritedBindings</name></cpp:macro> <cpp:value>(parser-&gt;m_inheritedBindings)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>tagStack</name></cpp:macro> <cpp:value>(parser-&gt;m_tagStack)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>atts</name></cpp:macro> <cpp:value>(parser-&gt;m_atts)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>attsSize</name></cpp:macro> <cpp:value>(parser-&gt;m_attsSize)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>nSpecifiedAtts</name></cpp:macro> <cpp:value>(parser-&gt;m_nSpecifiedAtts)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>idAttIndex</name></cpp:macro> <cpp:value>(parser-&gt;m_idAttIndex)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>nsAtts</name></cpp:macro> <cpp:value>(parser-&gt;m_nsAtts)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>nsAttsVersion</name></cpp:macro> <cpp:value>(parser-&gt;m_nsAttsVersion)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>nsAttsPower</name></cpp:macro> <cpp:value>(parser-&gt;m_nsAttsPower)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>tempPool</name></cpp:macro> <cpp:value>(parser-&gt;m_tempPool)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>temp2Pool</name></cpp:macro> <cpp:value>(parser-&gt;m_temp2Pool)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>groupConnector</name></cpp:macro> <cpp:value>(parser-&gt;m_groupConnector)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>groupSize</name></cpp:macro> <cpp:value>(parser-&gt;m_groupSize)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>namespaceSeparator</name></cpp:macro> <cpp:value>(parser-&gt;m_namespaceSeparator)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>parentParser</name></cpp:macro> <cpp:value>(parser-&gt;m_parentParser)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ps_parsing</name></cpp:macro> <cpp:value>(parser-&gt;m_parsingStatus.parsing)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ps_finalBuffer</name></cpp:macro> <cpp:value>(parser-&gt;m_parsingStatus.finalBuffer)</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>isParamEntity</name></cpp:macro> <cpp:value>(parser-&gt;m_isParamEntity)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>useForeignDTD</name></cpp:macro> <cpp:value>(parser-&gt;m_useForeignDTD)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>paramEntityParsing</name></cpp:macro> <cpp:value>(parser-&gt;m_paramEntityParsing)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>XML_Parser</name> <name>XMLCALL</name></type>
<name>XML_ParserCreate</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>encodingName</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>XML_ParserCreate_MM</name><argument_list>(<argument><expr><name>encodingName</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>XML_Parser</name> <name>XMLCALL</name></type>
<name>XML_ParserCreateNS</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>encodingName</name></decl></param>, <param><decl><type><name>XML_Char</name></type> <name>nsSep</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>XML_Char</name></type> <name><name>tmp</name><index>[<expr>2</expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr>*<name>tmp</name> = <name>nsSep</name></expr>;</expr_stmt>
<return>return <expr><call><name>XML_ParserCreate_MM</name><argument_list>(<argument><expr><name>encodingName</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>XML_Char</name></type> <name><name>implicitContext</name><index>[]</index></name> <init>= <expr><block>{
<expr>'x'</expr>, <expr>'m'</expr>, <expr>'l'</expr>, <expr>'='</expr>, <expr>'h'</expr>, <expr>'t'</expr>, <expr>'t'</expr>, <expr>'p'</expr>, <expr>':'</expr>, <expr>'/'</expr>, <expr>'/'</expr>,
<expr>'w'</expr>, <expr>'w'</expr>, <expr>'w'</expr>, <expr>'.'</expr>, <expr>'w'</expr>, <expr>'3'</expr>, <expr>'.'</expr>, <expr>'o'</expr>, <expr>'r'</expr>, <expr>'g'</expr>, <expr>'/'</expr>,
<expr>'X'</expr>, <expr>'M'</expr>, <expr>'L'</expr>, <expr>'/'</expr>, <expr>'1'</expr>, <expr>'9'</expr>, <expr>'9'</expr>, <expr>'8'</expr>, <expr>'/'</expr>,
<expr>'n'</expr>, <expr>'a'</expr>, <expr>'m'</expr>, <expr>'e'</expr>, <expr>'s'</expr>, <expr>'p'</expr>, <expr>'a'</expr>, <expr>'c'</expr>, <expr>'e'</expr>, <expr>'\0'</expr>
}</block></expr></init></decl>;</decl_stmt>
<function><type><name>XML_Parser</name> <name>XMLCALL</name></type>
<name>XML_ParserCreate_MM</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>encodingName</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>XML_Memory_Handling_Suite</name> *</type><name>memsuite</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>nameSep</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>XML_Parser</name></type> <name>parser</name> <init>= <expr><call><name>parserCreate</name><argument_list>(<argument><expr><name>encodingName</name></expr></argument>, <argument><expr><name>memsuite</name></expr></argument>, <argument><expr><name>nameSep</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>parser</name> != <name>NULL</name> &amp;&amp; <name>ns</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<call><name>setContext</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>implicitContext</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>XML_ParserFree</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
}</block></then></if>
<return>return <expr><name>parser</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>XML_Parser</name></type>
<name>parserCreate</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>encodingName</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>XML_Memory_Handling_Suite</name> *</type><name>memsuite</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>nameSep</name></decl></param>,
<param><decl><type><name>DTD</name> *</type><name>dtd</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>XML_Parser</name></type> <name>parser</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>memsuite</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>XML_Memory_Handling_Suite</name> *</type><name>mtemp</name></decl>;</decl_stmt>
<expr_stmt><expr><name>parser</name> = (<name>XML_Parser</name>)
<call><name><name>memsuite</name>-&gt;<name>malloc_fcn</name></name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument>struct <expr><name>XML_ParserStruct</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>parser</name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>mtemp</name> = (<name>XML_Memory_Handling_Suite</name> *)&amp;(<name><name>parser</name>-&gt;<name>m_mem</name></name>)</expr>;</expr_stmt>
<expr_stmt><expr><name><name>mtemp</name>-&gt;<name>malloc_fcn</name></name> = <name><name>memsuite</name>-&gt;<name>malloc_fcn</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mtemp</name>-&gt;<name>realloc_fcn</name></name> = <name><name>memsuite</name>-&gt;<name>realloc_fcn</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mtemp</name>-&gt;<name>free_fcn</name></name> = <name><name>memsuite</name>-&gt;<name>free_fcn</name></name></expr>;</expr_stmt>
}</block></then></if>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>XML_Memory_Handling_Suite</name> *</type><name>mtemp</name></decl>;</decl_stmt>
<expr_stmt><expr><name>parser</name> = (<name>XML_Parser</name>)<call><name>malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument>struct <expr><name>XML_ParserStruct</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>parser</name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>mtemp</name> = (<name>XML_Memory_Handling_Suite</name> *)&amp;(<name><name>parser</name>-&gt;<name>m_mem</name></name>)</expr>;</expr_stmt>
<expr_stmt><expr><name><name>mtemp</name>-&gt;<name>malloc_fcn</name></name> = <name>malloc</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mtemp</name>-&gt;<name>realloc_fcn</name></name> = <name>realloc</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mtemp</name>-&gt;<name>free_fcn</name></name> = <name>free</name></expr>;</expr_stmt>
}</block></then></if>
}</block></else></if>
<if>if <condition>(<expr>!<name>parser</name></expr>)</condition><then>
<return>return <expr><name>parser</name></expr>;</return></then></if>
<expr_stmt><expr><name>buffer</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>bufferLim</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>attsSize</name> = <name>INIT_ATTS_SIZE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>atts</name> = (<name>ATTRIBUTE</name> *)<call><name>MALLOC</name><argument_list>(<argument><expr><name>attsSize</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>ATTRIBUTE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>atts</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>dataBuf</name> = (<name>XML_Char</name> *)<call><name>MALLOC</name><argument_list>(<argument><expr><name>INIT_DATA_BUF_SIZE</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>XML_Char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>dataBuf</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>atts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>dataBufEnd</name> = <name>dataBuf</name> + <name>INIT_DATA_BUF_SIZE</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>dtd</name></expr>)</condition><then>
<expr_stmt><expr><name>_dtd</name> = <name>dtd</name></expr>;</expr_stmt></then>
<else>else <block>{
<expr_stmt><expr><name>_dtd</name> = <call><name>dtdCreate</name><argument_list>(<argument><expr>&amp;<name><name>parser</name>-&gt;<name>m_mem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>_dtd</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>dataBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>atts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
}</block></else></if>
<expr_stmt><expr><name>freeBindingList</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>freeTagList</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>freeInternalEntities</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>groupSize</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>groupConnector</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>unknownEncodingHandler</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>unknownEncodingHandlerData</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>namespaceSeparator</name> = '!'</expr>;</expr_stmt>
<expr_stmt><expr><name>ns</name> = <name>XML_FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ns_triplets</name> = <name>XML_FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>nsAtts</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>nsAttsVersion</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>nsAttsPower</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><call><name>poolInit</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>, <argument><expr>&amp;(<name><name>parser</name>-&gt;<name>m_mem</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>poolInit</name><argument_list>(<argument><expr>&amp;<name>temp2Pool</name></expr></argument>, <argument><expr>&amp;(<name><name>parser</name>-&gt;<name>m_mem</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>parserInit</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>encodingName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>encodingName</name> &amp;&amp; !<name>protocolEncodingName</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>XML_ParserFree</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>nameSep</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>ns</name> = <name>XML_TRUE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>internalEncoding</name> = <call><name>XmlGetInternalEncodingNS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>namespaceSeparator</name> = *<name>nameSep</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>internalEncoding</name> = <call><name>XmlGetInternalEncoding</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<return>return <expr><name>parser</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>parserInit</name><parameter_list>(<param><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>encodingName</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>processor</name> = <name>prologInitProcessor</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XmlPrologStateInit</name><argument_list>(<argument><expr>&amp;<name>prologState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>protocolEncodingName</name> = (<name>encodingName</name> != <name>NULL</name>
? <call><name>poolCopyString</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>, <argument><expr><name>encodingName</name></expr></argument>)</argument_list></call>
: <name>NULL</name>)</expr>;</expr_stmt>
<expr_stmt><expr><name>curBase</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XmlInitEncoding</name><argument_list>(<argument><expr>&amp;<name>initEncoding</name></expr></argument>, <argument><expr>&amp;<name>encoding</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>userData</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>handlerArg</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>startElementHandler</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>endElementHandler</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>characterDataHandler</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>processingInstructionHandler</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>commentHandler</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>startCdataSectionHandler</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>endCdataSectionHandler</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>defaultHandler</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>startDoctypeDeclHandler</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>endDoctypeDeclHandler</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>unparsedEntityDeclHandler</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>notationDeclHandler</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>startNamespaceDeclHandler</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>endNamespaceDeclHandler</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>notStandaloneHandler</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>externalEntityRefHandler</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>externalEntityRefHandlerArg</name> = <name>parser</name></expr>;</expr_stmt>
<expr_stmt><expr><name>skippedEntityHandler</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>elementDeclHandler</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>attlistDeclHandler</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>entityDeclHandler</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>xmlDeclHandler</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>bufferPtr</name> = <name>buffer</name></expr>;</expr_stmt>
<expr_stmt><expr><name>bufferEnd</name> = <name>buffer</name></expr>;</expr_stmt>
<expr_stmt><expr><name>parseEndByteIndex</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>parseEndPtr</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>declElementType</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>declAttributeId</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>declEntity</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>doctypeName</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>doctypeSysid</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>doctypePubid</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>declAttributeType</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>declNotationName</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>declNotationPublicId</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>declAttributeIsCdata</name> = <name>XML_FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>declAttributeIsId</name> = <name>XML_FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>position</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>POSITION</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>errorCode</name> = <name>XML_ERROR_NONE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>eventPtr</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>eventEndPtr</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>positionPtr</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>openInternalEntities</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>defaultExpandInternalEntities</name> = <name>XML_TRUE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>tagLevel</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>tagStack</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>inheritedBindings</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>nSpecifiedAtts</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>unknownEncodingMem</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>unknownEncodingRelease</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>unknownEncodingData</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>parentParser</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ps_parsing</name> = <name>XML_INITIALIZED</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>isParamEntity</name> = <name>XML_FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>useForeignDTD</name> = <name>XML_FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>paramEntityParsing</name> = <name>XML_PARAM_ENTITY_PARSING_NEVER</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name> <name>FASTCALL</name></type>
<name>moveToFreeBindingList</name><parameter_list>(<param><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></param>, <param><decl><type><name>BINDING</name> *</type><name>bindings</name></decl></param>)</parameter_list> <block>{
<while>while <condition>(<expr><name>bindings</name></expr>)</condition> <block>{
<decl_stmt><decl><type><name>BINDING</name> *</type><name>b</name> <init>= <expr><name>bindings</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>bindings</name> = <name><name>bindings</name>-&gt;<name>nextTagBinding</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name>-&gt;<name>nextTagBinding</name></name> = <name>freeBindingList</name></expr>;</expr_stmt>
<expr_stmt><expr><name>freeBindingList</name> = <name>b</name></expr>;</expr_stmt>
}</block></while>
}</block></function>
<function><type><name>XML_Bool</name> <name>XMLCALL</name></type>
<name>XML_ParserReset</name><parameter_list>(<param><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>encodingName</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>TAG</name> *</type><name>tStk</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OPEN_INTERNAL_ENTITY</name> *</type><name>openEntityList</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>parentParser</name></expr>)</condition><then>
<return>return <expr><name>XML_FALSE</name></expr>;</return></then></if>
<expr_stmt><expr><name>tStk</name> = <name>tagStack</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>tStk</name></expr>)</condition> <block>{
<decl_stmt><decl><type><name>TAG</name> *</type><name>tag</name> <init>= <expr><name>tStk</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>tStk</name> = <name><name>tStk</name>-&gt;<name>parent</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tag</name>-&gt;<name>parent</name></name> = <name>freeTagList</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>moveToFreeBindingList</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name><name>tag</name>-&gt;<name>bindings</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tag</name>-&gt;<name>bindings</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>freeTagList</name> = <name>tag</name></expr>;</expr_stmt>
}</block></while>
<expr_stmt><expr><name>openEntityList</name> = <name>openInternalEntities</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>openEntityList</name></expr>)</condition> <block>{
<decl_stmt><decl><type><name>OPEN_INTERNAL_ENTITY</name> *</type><name>openEntity</name> <init>= <expr><name>openEntityList</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>openEntityList</name> = <name><name>openEntity</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>openEntity</name>-&gt;<name>next</name></name> = <name>freeInternalEntities</name></expr>;</expr_stmt>
<expr_stmt><expr><name>freeInternalEntities</name> = <name>openEntity</name></expr>;</expr_stmt>
}</block></while>
<expr_stmt><expr><call><name>moveToFreeBindingList</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>inheritedBindings</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>unknownEncodingMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>unknownEncodingRelease</name></expr>)</condition><then>
<expr_stmt><expr><call><name>unknownEncodingRelease</name><argument_list>(<argument><expr><name>unknownEncodingData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>poolClear</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>poolClear</name><argument_list>(<argument><expr>&amp;<name>temp2Pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>parserInit</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>encodingName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dtdReset</name><argument_list>(<argument><expr><name>_dtd</name></expr></argument>, <argument><expr>&amp;<name><name>parser</name>-&gt;<name>m_mem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>setContext</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>implicitContext</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<enum>enum <name>XML_Status</name> <name>XMLCALL</name>
<name>XML_SetEncoding</name><expr_stmt><expr>(<name>XML_Parser</name> <name>parser</name>, const <name>XML_Char</name> *<name>encodingName</name>) <block>{
<if>if <condition>(<expr><name>ps_parsing</name> == <name>XML_PARSING</name> || <name>ps_parsing</name> == <name>XML_SUSPENDED</name></expr>)</condition><then>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return></then></if></block></expr></expr_stmt></enum>
<if>if <condition>(<expr><name>encodingName</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><name>protocolEncodingName</name> = <name>NULL</name></expr>;</expr_stmt></then>
<else>else <block>{
<expr_stmt><expr><name>protocolEncodingName</name> = <call><name>poolCopyString</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>, <argument><expr><name>encodingName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>protocolEncodingName</name></expr>)</condition><then>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return></then></if>
}</block></else></if>
<return>return <expr><name>XML_STATUS_OK</name></expr>;</return>
}
XML_Parser <function><type><name>XMLCALL</name></type>
<name>XML_ExternalEntityParserCreate</name><parameter_list>(<param><decl><type><name>XML_Parser</name></type> <name>oldParser</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>context</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>encodingName</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>XML_Parser</name></type> <name>parser</name> <init>= <expr><name>oldParser</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DTD</name> *</type><name>newDtd</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DTD</name> *</type><name>oldDtd</name> <init>= <expr><name>_dtd</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_StartElementHandler</name></type> <name>oldStartElementHandler</name> <init>= <expr><name>startElementHandler</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_EndElementHandler</name></type> <name>oldEndElementHandler</name> <init>= <expr><name>endElementHandler</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_CharacterDataHandler</name></type> <name>oldCharacterDataHandler</name> <init>= <expr><name>characterDataHandler</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_ProcessingInstructionHandler</name></type> <name>oldProcessingInstructionHandler</name>
<init>= <expr><name>processingInstructionHandler</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_CommentHandler</name></type> <name>oldCommentHandler</name> <init>= <expr><name>commentHandler</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_StartCdataSectionHandler</name></type> <name>oldStartCdataSectionHandler</name>
<init>= <expr><name>startCdataSectionHandler</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_EndCdataSectionHandler</name></type> <name>oldEndCdataSectionHandler</name>
<init>= <expr><name>endCdataSectionHandler</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_DefaultHandler</name></type> <name>oldDefaultHandler</name> <init>= <expr><name>defaultHandler</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_UnparsedEntityDeclHandler</name></type> <name>oldUnparsedEntityDeclHandler</name>
<init>= <expr><name>unparsedEntityDeclHandler</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_NotationDeclHandler</name></type> <name>oldNotationDeclHandler</name> <init>= <expr><name>notationDeclHandler</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_StartNamespaceDeclHandler</name></type> <name>oldStartNamespaceDeclHandler</name>
<init>= <expr><name>startNamespaceDeclHandler</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_EndNamespaceDeclHandler</name></type> <name>oldEndNamespaceDeclHandler</name>
<init>= <expr><name>endNamespaceDeclHandler</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_NotStandaloneHandler</name></type> <name>oldNotStandaloneHandler</name> <init>= <expr><name>notStandaloneHandler</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_ExternalEntityRefHandler</name></type> <name>oldExternalEntityRefHandler</name>
<init>= <expr><name>externalEntityRefHandler</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_SkippedEntityHandler</name></type> <name>oldSkippedEntityHandler</name> <init>= <expr><name>skippedEntityHandler</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_UnknownEncodingHandler</name></type> <name>oldUnknownEncodingHandler</name>
<init>= <expr><name>unknownEncodingHandler</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_ElementDeclHandler</name></type> <name>oldElementDeclHandler</name> <init>= <expr><name>elementDeclHandler</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_AttlistDeclHandler</name></type> <name>oldAttlistDeclHandler</name> <init>= <expr><name>attlistDeclHandler</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_EntityDeclHandler</name></type> <name>oldEntityDeclHandler</name> <init>= <expr><name>entityDeclHandler</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_XmlDeclHandler</name></type> <name>oldXmlDeclHandler</name> <init>= <expr><name>xmlDeclHandler</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ELEMENT_TYPE</name> *</type> <name>oldDeclElementType</name> <init>= <expr><name>declElementType</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> *</type><name>oldUserData</name> <init>= <expr><name>userData</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> *</type><name>oldHandlerArg</name> <init>= <expr><name>handlerArg</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Bool</name></type> <name>oldDefaultExpandInternalEntities</name> <init>= <expr><name>defaultExpandInternalEntities</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Parser</name></type> <name>oldExternalEntityRefHandlerArg</name> <init>= <expr><name>externalEntityRefHandlerArg</name></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<enum>enum <name>XML_ParamEntityParsing</name> <name>oldParamEntityParsing</name> <expr_stmt><expr>= <name>paramEntityParsing</name></expr>;</expr_stmt></enum>
<decl_stmt><decl><type><name>int</name></type> <name>oldInEntityValue</name> <init>= <expr><name><name>prologState</name>.<name>inEntityValue</name></name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>XML_Bool</name></type> <name>oldns_triplets</name> <init>= <expr><name>ns_triplets</name></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr>!<name>context</name></expr>)</condition><then>
<expr_stmt><expr><name>newDtd</name> = <name>oldDtd</name></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><name>ns</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>XML_Char</name></type> <name><name>tmp</name><index>[<expr>2</expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr>*<name>tmp</name> = <name>namespaceSeparator</name></expr>;</expr_stmt>
<expr_stmt><expr><name>parser</name> = <call><name>parserCreate</name><argument_list>(<argument><expr><name>encodingName</name></expr></argument>, <argument><expr>&amp;<name><name>parser</name>-&gt;<name>m_mem</name></name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>newDtd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>parser</name> = <call><name>parserCreate</name><argument_list>(<argument><expr><name>encodingName</name></expr></argument>, <argument><expr>&amp;<name><name>parser</name>-&gt;<name>m_mem</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>newDtd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<if>if <condition>(<expr>!<name>parser</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>startElementHandler</name> = <name>oldStartElementHandler</name></expr>;</expr_stmt>
<expr_stmt><expr><name>endElementHandler</name> = <name>oldEndElementHandler</name></expr>;</expr_stmt>
<expr_stmt><expr><name>characterDataHandler</name> = <name>oldCharacterDataHandler</name></expr>;</expr_stmt>
<expr_stmt><expr><name>processingInstructionHandler</name> = <name>oldProcessingInstructionHandler</name></expr>;</expr_stmt>
<expr_stmt><expr><name>commentHandler</name> = <name>oldCommentHandler</name></expr>;</expr_stmt>
<expr_stmt><expr><name>startCdataSectionHandler</name> = <name>oldStartCdataSectionHandler</name></expr>;</expr_stmt>
<expr_stmt><expr><name>endCdataSectionHandler</name> = <name>oldEndCdataSectionHandler</name></expr>;</expr_stmt>
<expr_stmt><expr><name>defaultHandler</name> = <name>oldDefaultHandler</name></expr>;</expr_stmt>
<expr_stmt><expr><name>unparsedEntityDeclHandler</name> = <name>oldUnparsedEntityDeclHandler</name></expr>;</expr_stmt>
<expr_stmt><expr><name>notationDeclHandler</name> = <name>oldNotationDeclHandler</name></expr>;</expr_stmt>
<expr_stmt><expr><name>startNamespaceDeclHandler</name> = <name>oldStartNamespaceDeclHandler</name></expr>;</expr_stmt>
<expr_stmt><expr><name>endNamespaceDeclHandler</name> = <name>oldEndNamespaceDeclHandler</name></expr>;</expr_stmt>
<expr_stmt><expr><name>notStandaloneHandler</name> = <name>oldNotStandaloneHandler</name></expr>;</expr_stmt>
<expr_stmt><expr><name>externalEntityRefHandler</name> = <name>oldExternalEntityRefHandler</name></expr>;</expr_stmt>
<expr_stmt><expr><name>skippedEntityHandler</name> = <name>oldSkippedEntityHandler</name></expr>;</expr_stmt>
<expr_stmt><expr><name>unknownEncodingHandler</name> = <name>oldUnknownEncodingHandler</name></expr>;</expr_stmt>
<expr_stmt><expr><name>elementDeclHandler</name> = <name>oldElementDeclHandler</name></expr>;</expr_stmt>
<expr_stmt><expr><name>attlistDeclHandler</name> = <name>oldAttlistDeclHandler</name></expr>;</expr_stmt>
<expr_stmt><expr><name>entityDeclHandler</name> = <name>oldEntityDeclHandler</name></expr>;</expr_stmt>
<expr_stmt><expr><name>xmlDeclHandler</name> = <name>oldXmlDeclHandler</name></expr>;</expr_stmt>
<expr_stmt><expr><name>declElementType</name> = <name>oldDeclElementType</name></expr>;</expr_stmt>
<expr_stmt><expr><name>userData</name> = <name>oldUserData</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>oldUserData</name> == <name>oldHandlerArg</name></expr>)</condition><then>
<expr_stmt><expr><name>handlerArg</name> = <name>userData</name></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>handlerArg</name> = <name>parser</name></expr>;</expr_stmt></else></if>
<if>if <condition>(<expr><name>oldExternalEntityRefHandlerArg</name> != <name>oldParser</name></expr>)</condition><then>
<expr_stmt><expr><name>externalEntityRefHandlerArg</name> = <name>oldExternalEntityRefHandlerArg</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>defaultExpandInternalEntities</name> = <name>oldDefaultExpandInternalEntities</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ns_triplets</name> = <name>oldns_triplets</name></expr>;</expr_stmt>
<expr_stmt><expr><name>parentParser</name> = <name>oldParser</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>paramEntityParsing</name> = <name>oldParamEntityParsing</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>prologState</name>.<name>inEntityValue</name></name> = <name>oldInEntityValue</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>context</name></expr>)</condition><then> <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr>!<call><name>dtdCopy</name><argument_list>(<argument><expr><name>_dtd</name></expr></argument>, <argument><expr><name>oldDtd</name></expr></argument>, <argument><expr>&amp;<name><name>parser</name>-&gt;<name>m_mem</name></name></expr></argument>)</argument_list></call>
|| !<call><name>setContext</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>XML_ParserFree</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>processor</name> = <name>externalEntityInitProcessor</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>isParamEntity</name> = <name>XML_TRUE</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>XmlPrologStateInitExternalEntity</name><argument_list>(<argument><expr>&amp;<name>prologState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>processor</name> = <name>externalParEntInitProcessor</name></expr>;</expr_stmt>
}</block></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><name>parser</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name> <name>FASTCALL</name></type>
<name>destroyBindings</name><parameter_list>(<param><decl><type><name>BINDING</name> *</type><name>bindings</name></decl></param>, <param><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></param>)</parameter_list> <block>{
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<decl_stmt><decl><type><name>BINDING</name> *</type><name>b</name> <init>= <expr><name>bindings</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>b</name></expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr><name>bindings</name> = <name><name>b</name>-&gt;<name>nextTagBinding</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>uri</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
}</block></function>
<function><type><name>void</name> <name>XMLCALL</name></type>
<name>XML_ParserFree</name><parameter_list>(<param><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>TAG</name> *</type><name>tagList</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>OPEN_INTERNAL_ENTITY</name> *</type><name>entityList</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>parser</name> == <name>NULL</name></expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><name>tagList</name> = <name>tagStack</name></expr>;</expr_stmt>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<decl_stmt><decl><type><name>TAG</name> *</type><name>p</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>tagList</name> == <name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>freeTagList</name> == <name>NULL</name></expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr><name>tagList</name> = <name>freeTagList</name></expr>;</expr_stmt>
<expr_stmt><expr><name>freeTagList</name> = <name>NULL</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>p</name> = <name>tagList</name></expr>;</expr_stmt>
<expr_stmt><expr><name>tagList</name> = <name><name>tagList</name>-&gt;<name>parent</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name><name>p</name>-&gt;<name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>destroyBindings</name><argument_list>(<argument><expr><name><name>p</name>-&gt;<name>bindings</name></name></expr></argument>, <argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><name>entityList</name> = <name>openInternalEntities</name></expr>;</expr_stmt>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<decl_stmt><decl><type><name>OPEN_INTERNAL_ENTITY</name> *</type><name>openEntity</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>entityList</name> == <name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>freeInternalEntities</name> == <name>NULL</name></expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr><name>entityList</name> = <name>freeInternalEntities</name></expr>;</expr_stmt>
<expr_stmt><expr><name>freeInternalEntities</name> = <name>NULL</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>openEntity</name> = <name>entityList</name></expr>;</expr_stmt>
<expr_stmt><expr><name>entityList</name> = <name><name>entityList</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>openEntity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><call><name>destroyBindings</name><argument_list>(<argument><expr><name>freeBindingList</name></expr></argument>, <argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>destroyBindings</name><argument_list>(<argument><expr><name>inheritedBindings</name></expr></argument>, <argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>poolDestroy</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>poolDestroy</name><argument_list>(<argument><expr>&amp;<name>temp2Pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr>!<name>isParamEntity</name> &amp;&amp; <name>_dtd</name></expr>)</condition><then>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if>if <condition>(<expr><name>_dtd</name></expr>)</condition><then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>dtdDestroy</name><argument_list>(<argument><expr><name>_dtd</name></expr></argument>, <argument><expr>(<name>XML_Bool</name>)!<name>parentParser</name></expr></argument>, <argument><expr>&amp;<name><name>parser</name>-&gt;<name>m_mem</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></then></if>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr>(<name>void</name> *)<name>atts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>groupConnector</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>dataBuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>nsAtts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>unknownEncodingMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>unknownEncodingRelease</name></expr>)</condition><then>
<expr_stmt><expr><call><name>unknownEncodingRelease</name><argument_list>(<argument><expr><name>unknownEncodingData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><name>void</name> <name>XMLCALL</name></type>
<name>XML_UseParserAsHandlerArg</name><parameter_list>(<param><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>handlerArg</name> = <name>parser</name></expr>;</expr_stmt>
}</block></function>
<enum>enum <name>XML_Error</name> <name>XMLCALL</name>
<name>XML_UseForeignDTD</name><expr_stmt><expr>(<name>XML_Parser</name> <name>parser</name>, <name>XML_Bool</name> <name>useDTD</name>) <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>ps_parsing</name> == <name>XML_PARSING</name> || <name>ps_parsing</name> == <name>XML_SUSPENDED</name></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_CANT_CHANGE_FEATURE_ONCE_PARSING</name></expr>;</return></then></if>
<name>useForeignDTD</name> = <name>useDTD</name></block></expr>;</expr_stmt></enum>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<return>return <expr><name>XML_ERROR_FEATURE_REQUIRES_XML_DTD</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}
void <function><type><name>XMLCALL</name></type>
<name>XML_SetReturnNSTriplet</name><parameter_list>(<param><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></param>, <param><decl><type><name>int</name></type> <name>do_nst</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name>ps_parsing</name> == <name>XML_PARSING</name> || <name>ps_parsing</name> == <name>XML_SUSPENDED</name></expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><name>ns_triplets</name> = <name>do_nst</name> ? <name>XML_TRUE</name> : <name>XML_FALSE</name></expr>;</expr_stmt>
}</block></function>
<function><type><name>void</name> <name>XMLCALL</name></type>
<name>XML_SetUserData</name><parameter_list>(<param><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></param>, <param><decl><type><name>void</name> *</type><name>p</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name>handlerArg</name> == <name>userData</name></expr>)</condition><then>
<expr_stmt><expr><name>handlerArg</name> = <name>userData</name> = <name>p</name></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>userData</name> = <name>p</name></expr>;</expr_stmt></else></if>
}</block></function>
<enum>enum <name>XML_Status</name> <name>XMLCALL</name>
<name>XML_SetBase</name><expr_stmt><expr>(<name>XML_Parser</name> <name>parser</name>, const <name>XML_Char</name> *<name>p</name>) <block>{
<if>if <condition>(<expr><name>p</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>p</name> = <call><name>poolCopyString</name><argument_list>(<argument><expr>&amp;<name><name>_dtd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>p</name></expr>)</condition><then>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return></then></if>
<expr_stmt><expr><name>curBase</name> = <name>p</name></expr>;</expr_stmt>
<expr_stmt/></block></then></if>}</block></expr></expr_stmt></enum> <else>else
<expr_stmt><expr><name>curBase</name> = <name>NULL</name></expr>;</expr_stmt></else>
<return>return <expr><name>XML_STATUS_OK</name></expr>;</return>
}
const <function><type><name>XML_Char</name> * <name>XMLCALL</name></type>
<name>XML_GetBase</name><parameter_list>(<param><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></param>)</parameter_list> <block>{
<return>return <expr><name>curBase</name></expr>;</return>
}</block></function>
<function><type><name>int</name> <name>XMLCALL</name></type>
<name>XML_GetSpecifiedAttributeCount</name><parameter_list>(<param><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></param>)</parameter_list> <block>{
<return>return <expr><name>nSpecifiedAtts</name></expr>;</return>
}</block></function>
<function><type><name>int</name> <name>XMLCALL</name></type>
<name>XML_GetIdAttributeIndex</name><parameter_list>(<param><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></param>)</parameter_list> <block>{
<return>return <expr><name>idAttIndex</name></expr>;</return>
}</block></function>
<function><type><name>void</name> <name>XMLCALL</name></type>
<name>XML_SetElementHandler</name><parameter_list>(<param><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></param>,
<param><decl><type><name>XML_StartElementHandler</name></type> <name>start</name></decl></param>,
<param><decl><type><name>XML_EndElementHandler</name></type> <name>end</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>startElementHandler</name> = <name>start</name></expr>;</expr_stmt>
<expr_stmt><expr><name>endElementHandler</name> = <name>end</name></expr>;</expr_stmt>
}</block></function>
<function><type><name>void</name> <name>XMLCALL</name></type>
<name>XML_SetStartElementHandler</name><parameter_list>(<param><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></param>,
<param><decl><type><name>XML_StartElementHandler</name></type> <name>start</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>startElementHandler</name> = <name>start</name></expr>;</expr_stmt>
}</block></function>
<function><type><name>void</name> <name>XMLCALL</name></type>
<name>XML_SetEndElementHandler</name><parameter_list>(<param><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></param>,
<param><decl><type><name>XML_EndElementHandler</name></type> <name>end</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>endElementHandler</name> = <name>end</name></expr>;</expr_stmt>
}</block></function>
<function><type><name>void</name> <name>XMLCALL</name></type>
<name>XML_SetCharacterDataHandler</name><parameter_list>(<param><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></param>,
<param><decl><type><name>XML_CharacterDataHandler</name></type> <name>handler</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>characterDataHandler</name> = <name>handler</name></expr>;</expr_stmt>
}</block></function>
<function><type><name>void</name> <name>XMLCALL</name></type>
<name>XML_SetProcessingInstructionHandler</name><parameter_list>(<param><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></param>,
<param><decl><type><name>XML_ProcessingInstructionHandler</name></type> <name>handler</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>processingInstructionHandler</name> = <name>handler</name></expr>;</expr_stmt>
}</block></function>
<function><type><name>void</name> <name>XMLCALL</name></type>
<name>XML_SetCommentHandler</name><parameter_list>(<param><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></param>,
<param><decl><type><name>XML_CommentHandler</name></type> <name>handler</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>commentHandler</name> = <name>handler</name></expr>;</expr_stmt>
}</block></function>
<function><type><name>void</name> <name>XMLCALL</name></type>
<name>XML_SetCdataSectionHandler</name><parameter_list>(<param><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></param>,
<param><decl><type><name>XML_StartCdataSectionHandler</name></type> <name>start</name></decl></param>,
<param><decl><type><name>XML_EndCdataSectionHandler</name></type> <name>end</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>startCdataSectionHandler</name> = <name>start</name></expr>;</expr_stmt>
<expr_stmt><expr><name>endCdataSectionHandler</name> = <name>end</name></expr>;</expr_stmt>
}</block></function>
<function><type><name>void</name> <name>XMLCALL</name></type>
<name>XML_SetStartCdataSectionHandler</name><parameter_list>(<param><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></param>,
<param><decl><type><name>XML_StartCdataSectionHandler</name></type> <name>start</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>startCdataSectionHandler</name> = <name>start</name></expr>;</expr_stmt>
}</block></function>
<function><type><name>void</name> <name>XMLCALL</name></type>
<name>XML_SetEndCdataSectionHandler</name><parameter_list>(<param><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></param>,
<param><decl><type><name>XML_EndCdataSectionHandler</name></type> <name>end</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>endCdataSectionHandler</name> = <name>end</name></expr>;</expr_stmt>
}</block></function>
<function><type><name>void</name> <name>XMLCALL</name></type>
<name>XML_SetDefaultHandler</name><parameter_list>(<param><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></param>,
<param><decl><type><name>XML_DefaultHandler</name></type> <name>handler</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>defaultHandler</name> = <name>handler</name></expr>;</expr_stmt>
<expr_stmt><expr><name>defaultExpandInternalEntities</name> = <name>XML_FALSE</name></expr>;</expr_stmt>
}</block></function>
<function><type><name>void</name> <name>XMLCALL</name></type>
<name>XML_SetDefaultHandlerExpand</name><parameter_list>(<param><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></param>,
<param><decl><type><name>XML_DefaultHandler</name></type> <name>handler</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>defaultHandler</name> = <name>handler</name></expr>;</expr_stmt>
<expr_stmt><expr><name>defaultExpandInternalEntities</name> = <name>XML_TRUE</name></expr>;</expr_stmt>
}</block></function>
<function><type><name>void</name> <name>XMLCALL</name></type>
<name>XML_SetDoctypeDeclHandler</name><parameter_list>(<param><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></param>,
<param><decl><type><name>XML_StartDoctypeDeclHandler</name></type> <name>start</name></decl></param>,
<param><decl><type><name>XML_EndDoctypeDeclHandler</name></type> <name>end</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>startDoctypeDeclHandler</name> = <name>start</name></expr>;</expr_stmt>
<expr_stmt><expr><name>endDoctypeDeclHandler</name> = <name>end</name></expr>;</expr_stmt>
}</block></function>
<function><type><name>void</name> <name>XMLCALL</name></type>
<name>XML_SetStartDoctypeDeclHandler</name><parameter_list>(<param><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></param>,
<param><decl><type><name>XML_StartDoctypeDeclHandler</name></type> <name>start</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>startDoctypeDeclHandler</name> = <name>start</name></expr>;</expr_stmt>
}</block></function>
<function><type><name>void</name> <name>XMLCALL</name></type>
<name>XML_SetEndDoctypeDeclHandler</name><parameter_list>(<param><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></param>,
<param><decl><type><name>XML_EndDoctypeDeclHandler</name></type> <name>end</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>endDoctypeDeclHandler</name> = <name>end</name></expr>;</expr_stmt>
}</block></function>
<function><type><name>void</name> <name>XMLCALL</name></type>
<name>XML_SetUnparsedEntityDeclHandler</name><parameter_list>(<param><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></param>,
<param><decl><type><name>XML_UnparsedEntityDeclHandler</name></type> <name>handler</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>unparsedEntityDeclHandler</name> = <name>handler</name></expr>;</expr_stmt>
}</block></function>
<function><type><name>void</name> <name>XMLCALL</name></type>
<name>XML_SetNotationDeclHandler</name><parameter_list>(<param><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></param>,
<param><decl><type><name>XML_NotationDeclHandler</name></type> <name>handler</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>notationDeclHandler</name> = <name>handler</name></expr>;</expr_stmt>
}</block></function>
<function><type><name>void</name> <name>XMLCALL</name></type>
<name>XML_SetNamespaceDeclHandler</name><parameter_list>(<param><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></param>,
<param><decl><type><name>XML_StartNamespaceDeclHandler</name></type> <name>start</name></decl></param>,
<param><decl><type><name>XML_EndNamespaceDeclHandler</name></type> <name>end</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>startNamespaceDeclHandler</name> = <name>start</name></expr>;</expr_stmt>
<expr_stmt><expr><name>endNamespaceDeclHandler</name> = <name>end</name></expr>;</expr_stmt>
}</block></function>
<function><type><name>void</name> <name>XMLCALL</name></type>
<name>XML_SetStartNamespaceDeclHandler</name><parameter_list>(<param><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></param>,
<param><decl><type><name>XML_StartNamespaceDeclHandler</name></type> <name>start</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>startNamespaceDeclHandler</name> = <name>start</name></expr>;</expr_stmt>
}</block></function>
<function><type><name>void</name> <name>XMLCALL</name></type>
<name>XML_SetEndNamespaceDeclHandler</name><parameter_list>(<param><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></param>,
<param><decl><type><name>XML_EndNamespaceDeclHandler</name></type> <name>end</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>endNamespaceDeclHandler</name> = <name>end</name></expr>;</expr_stmt>
}</block></function>
<function><type><name>void</name> <name>XMLCALL</name></type>
<name>XML_SetNotStandaloneHandler</name><parameter_list>(<param><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></param>,
<param><decl><type><name>XML_NotStandaloneHandler</name></type> <name>handler</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>notStandaloneHandler</name> = <name>handler</name></expr>;</expr_stmt>
}</block></function>
<function><type><name>void</name> <name>XMLCALL</name></type>
<name>XML_SetExternalEntityRefHandler</name><parameter_list>(<param><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></param>,
<param><decl><type><name>XML_ExternalEntityRefHandler</name></type> <name>handler</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>externalEntityRefHandler</name> = <name>handler</name></expr>;</expr_stmt>
}</block></function>
<function><type><name>void</name> <name>XMLCALL</name></type>
<name>XML_SetExternalEntityRefHandlerArg</name><parameter_list>(<param><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name>arg</name></expr>)</condition><then>
<expr_stmt><expr><name>externalEntityRefHandlerArg</name> = (<name>XML_Parser</name>)<name>arg</name></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>externalEntityRefHandlerArg</name> = <name>parser</name></expr>;</expr_stmt></else></if>
}</block></function>
<function><type><name>void</name> <name>XMLCALL</name></type>
<name>XML_SetSkippedEntityHandler</name><parameter_list>(<param><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></param>,
<param><decl><type><name>XML_SkippedEntityHandler</name></type> <name>handler</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>skippedEntityHandler</name> = <name>handler</name></expr>;</expr_stmt>
}</block></function>
<function><type><name>void</name> <name>XMLCALL</name></type>
<name>XML_SetUnknownEncodingHandler</name><parameter_list>(<param><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></param>,
<param><decl><type><name>XML_UnknownEncodingHandler</name></type> <name>handler</name></decl></param>,
<param><decl><type><name>void</name> *</type><name>data</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>unknownEncodingHandler</name> = <name>handler</name></expr>;</expr_stmt>
<expr_stmt><expr><name>unknownEncodingHandlerData</name> = <name>data</name></expr>;</expr_stmt>
}</block></function>
<function><type><name>void</name> <name>XMLCALL</name></type>
<name>XML_SetElementDeclHandler</name><parameter_list>(<param><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></param>,
<param><decl><type><name>XML_ElementDeclHandler</name></type> <name>eldecl</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>elementDeclHandler</name> = <name>eldecl</name></expr>;</expr_stmt>
}</block></function>
<function><type><name>void</name> <name>XMLCALL</name></type>
<name>XML_SetAttlistDeclHandler</name><parameter_list>(<param><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></param>,
<param><decl><type><name>XML_AttlistDeclHandler</name></type> <name>attdecl</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>attlistDeclHandler</name> = <name>attdecl</name></expr>;</expr_stmt>
}</block></function>
<function><type><name>void</name> <name>XMLCALL</name></type>
<name>XML_SetEntityDeclHandler</name><parameter_list>(<param><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></param>,
<param><decl><type><name>XML_EntityDeclHandler</name></type> <name>handler</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>entityDeclHandler</name> = <name>handler</name></expr>;</expr_stmt>
}</block></function>
<function><type><name>void</name> <name>XMLCALL</name></type>
<name>XML_SetXmlDeclHandler</name><parameter_list>(<param><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></param>,
<param><decl><type><name>XML_XmlDeclHandler</name></type> <name>handler</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>xmlDeclHandler</name> = <name>handler</name></expr>;</expr_stmt>
}</block></function>
<decl_stmt><decl><type><name>int</name> <name>XMLCALL</name></type>
<name>XML_SetParamEntityParsing</name><argument_list>(<argument><expr><name>XML_Parser</name> <name>parser</name></expr></argument>,
<argument>enum <expr><name>XML_ParamEntityParsing</name> <name>peParsing</name></expr></argument>)</argument_list> <block>{
<if>if <condition>(<expr><name>ps_parsing</name> == <name>XML_PARSING</name> || <name>ps_parsing</name> == <name>XML_SUSPENDED</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>paramEntityParsing</name> = <name>peParsing</name></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<return>return <expr><name>peParsing</name> == <name>XML_PARAM_ENTITY_PARSING_NEVER</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></decl></decl_stmt>
<enum>enum <name>XML_Status</name> <name>XMLCALL</name>
<name>XML_Parse</name><expr_stmt><expr>(<name>XML_Parser</name> <name>parser</name>, const <name>char</name> *<name>s</name>, <name>int</name> <name>len</name>, <name>int</name> <name>isFinal</name>) <block>{
<switch>switch <condition>(<expr><name>ps_parsing</name></expr>)</condition> <block>{
<case>case <expr><name>XML_SUSPENDED</name></expr>:
<expr_stmt><expr><name>errorCode</name> = <name>XML_ERROR_SUSPENDED</name></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return>
</case><case>case <expr><name>XML_FINISHED</name></expr>:
<expr_stmt><expr><name>errorCode</name> = <name>XML_ERROR_FINISHED</name></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return>
</case><default>default:
<expr_stmt><expr><name>ps_parsing</name> = <name>XML_PARSING</name></expr>;</expr_stmt>
<expr_stmt/></default></block></switch>}</block></expr></expr_stmt></enum>
<if>if <condition>(<expr><name>len</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>ps_finalBuffer</name> = (<name>XML_Bool</name>)<name>isFinal</name></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>isFinal</name></expr>)</condition><then>
<return>return <expr><name>XML_STATUS_OK</name></expr>;</return></then></if>
<expr_stmt><expr><name>positionPtr</name> = <name>bufferPtr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>parseEndPtr</name> = <name>bufferEnd</name></expr>;</expr_stmt>
<expr_stmt><expr><name>errorCode</name> = <call><name>processor</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>bufferPtr</name></expr></argument>, <argument><expr><name>parseEndPtr</name></expr></argument>, <argument><expr>&amp;<name>bufferPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>errorCode</name> == <name>XML_ERROR_NONE</name></expr>)</condition><then> <block>{
<switch>switch <condition>(<expr><name>ps_parsing</name></expr>)</condition> <block>{
<case>case <expr><name>XML_SUSPENDED</name></expr>:
<expr_stmt><expr><call><name>XmlUpdatePosition</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>positionPtr</name></expr></argument>, <argument><expr><name>bufferPtr</name></expr></argument>, <argument><expr>&amp;<name>position</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>positionPtr</name> = <name>bufferPtr</name></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_SUSPENDED</name></expr>;</return>
</case><case>case <expr><name>XML_INITIALIZED</name></expr>:
</case><case>case <expr><name>XML_PARSING</name></expr>:
<expr_stmt><expr><name>ps_parsing</name> = <name>XML_FINISHED</name></expr>;</expr_stmt>
</case><default>default:
<return>return <expr><name>XML_STATUS_OK</name></expr>;</return>
</default>}</block></switch>
}</block></then></if>
<expr_stmt><expr><name>eventEndPtr</name> = <name>eventPtr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>processor</name> = <name>errorProcessor</name></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return>
}</block></then>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>XML_CONTEXT_BYTES</name></expr></argument>)</argument_list></call></expr></cpp:if>
<else>else <if>if <condition>(<expr><name>bufferPtr</name> == <name>bufferEnd</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nLeftOver</name></decl>;</decl_stmt>
<enum>enum <name>XML_Error</name> <name>result</name>;</enum>
<expr_stmt><expr><name>parseEndByteIndex</name> += <name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><name>positionPtr</name> = <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ps_finalBuffer</name> = (<name>XML_Bool</name>)<name>isFinal</name></expr>;</expr_stmt>
<expr_stmt><expr><name>errorCode</name> = <call><name>processor</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>parseEndPtr</name> = <name>s</name> + <name>len</name></expr></argument>, <argument><expr>&amp;<name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>errorCode</name> != <name>XML_ERROR_NONE</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>eventEndPtr</name> = <name>eventPtr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>processor</name> = <name>errorProcessor</name></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return>
}</block></then> <else>else <block>{
<switch>switch <condition>(<expr><name>ps_parsing</name></expr>)</condition> <block>{
<case>case <expr><name>XML_SUSPENDED</name></expr>:
<expr_stmt><expr><name>result</name> = <name>XML_STATUS_SUSPENDED</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>XML_INITIALIZED</name></expr>:
</case><case>case <expr><name>XML_PARSING</name></expr>:
<expr_stmt><expr><name>result</name> = <name>XML_STATUS_OK</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>isFinal</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>ps_parsing</name> = <name>XML_FINISHED</name></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></then></if>
</case>}</block></switch>
}</block></else></if>
<expr_stmt><expr><call><name>XmlUpdatePosition</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>positionPtr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr>&amp;<name>position</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>nLeftOver</name> = <name>s</name> + <name>len</name> - <name>end</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>nLeftOver</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>buffer</name> == <name>NULL</name> || <name>nLeftOver</name> &gt; <name>bufferLim</name> - <name>buffer</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>temp</name></decl>;</decl_stmt>
<expr_stmt><expr><name>temp</name> = (<name>buffer</name> == <name>NULL</name>
? (<name>char</name> *)<call><name>MALLOC</name><argument_list>(<argument><expr><name>len</name> * 2</expr></argument>)</argument_list></call>
: (<name>char</name> *)<call><name>REALLOC</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>len</name> * 2</expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
<if>if <condition>(<expr><name>temp</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>errorCode</name> = <name>XML_ERROR_NO_MEMORY</name></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>buffer</name> = <name>temp</name></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>buffer</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>errorCode</name> = <name>XML_ERROR_NO_MEMORY</name></expr>;</expr_stmt>
<expr_stmt><expr><name>eventPtr</name> = <name>eventEndPtr</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>processor</name> = <name>errorProcessor</name></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>bufferLim</name> = <name>buffer</name> + <name>len</name> * 2</expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>nLeftOver</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>bufferPtr</name> = <name>buffer</name></expr>;</expr_stmt>
<expr_stmt><expr><name>bufferEnd</name> = <name>buffer</name> + <name>nLeftOver</name></expr>;</expr_stmt>
<expr_stmt><expr><name>positionPtr</name> = <name>bufferPtr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>parseEndPtr</name> = <name>bufferEnd</name></expr>;</expr_stmt>
<expr_stmt><expr><name>eventPtr</name> = <name>bufferPtr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>eventEndPtr</name> = <name>bufferPtr</name></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<else>else <block>{
<decl_stmt><decl><type><name>void</name> *</type><name>buff</name> <init>= <expr><call><name>XML_GetBuffer</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>buff</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return></then>
<else>else <block>{
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>XML_ParseBuffer</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>isFinal</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></else></if>
}</block></else></if></else></if>
}
enum <function><type><name>XML_Status</name> <name>XMLCALL</name></type>
<name>XML_ParseBuffer</name><parameter_list>(<param><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></param>, <param><decl><type><name>int</name></type> <name>len</name></decl></param>, <param><decl><type><name>int</name></type> <name>isFinal</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>start</name></decl>;</decl_stmt>
<enum>enum <name>XML_Status</name> <name>result</name> <expr_stmt><expr>= <name>XML_STATUS_OK</name></expr>;</expr_stmt></enum>
<switch>switch <condition>(<expr><name>ps_parsing</name></expr>)</condition> <block>{
<case>case <expr><name>XML_SUSPENDED</name></expr>:
<expr_stmt><expr><name>errorCode</name> = <name>XML_ERROR_SUSPENDED</name></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return>
</case><case>case <expr><name>XML_FINISHED</name></expr>:
<expr_stmt><expr><name>errorCode</name> = <name>XML_ERROR_FINISHED</name></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return>
</case><default>default:
<expr_stmt><expr><name>ps_parsing</name> = <name>XML_PARSING</name></expr>;</expr_stmt>
</default>}</block></switch>
<expr_stmt><expr><name>start</name> = <name>bufferPtr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>positionPtr</name> = <name>start</name></expr>;</expr_stmt>
<expr_stmt><expr><name>bufferEnd</name> += <name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><name>parseEndPtr</name> = <name>bufferEnd</name></expr>;</expr_stmt>
<expr_stmt><expr><name>parseEndByteIndex</name> += <name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ps_finalBuffer</name> = (<name>XML_Bool</name>)<name>isFinal</name></expr>;</expr_stmt>
<expr_stmt><expr><name>errorCode</name> = <call><name>processor</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>parseEndPtr</name></expr></argument>, <argument><expr>&amp;<name>bufferPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>errorCode</name> != <name>XML_ERROR_NONE</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>eventEndPtr</name> = <name>eventPtr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>processor</name> = <name>errorProcessor</name></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return>
}</block></then> <else>else <block>{
<switch>switch <condition>(<expr><name>ps_parsing</name></expr>)</condition> <block>{
<case>case <expr><name>XML_SUSPENDED</name></expr>:
<expr_stmt><expr><name>result</name> = <name>XML_STATUS_SUSPENDED</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>XML_INITIALIZED</name></expr>:
</case><case>case <expr><name>XML_PARSING</name></expr>:
<if>if <condition>(<expr><name>isFinal</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>ps_parsing</name> = <name>XML_FINISHED</name></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></then></if>
</case><default>default: <empty_stmt>;</empty_stmt>
</default>}</block></switch>
}</block></else></if>
<expr_stmt><expr><call><name>XmlUpdatePosition</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>positionPtr</name></expr></argument>, <argument><expr><name>bufferPtr</name></expr></argument>, <argument><expr>&amp;<name>position</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>positionPtr</name> = <name>bufferPtr</name></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<function><type><name>void</name> * <name>XMLCALL</name></type>
<name>XML_GetBuffer</name><parameter_list>(<param><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></param>, <param><decl><type><name>int</name></type> <name>len</name></decl></param>)</parameter_list> <block>{
<switch>switch <condition>(<expr><name>ps_parsing</name></expr>)</condition> <block>{
<case>case <expr><name>XML_SUSPENDED</name></expr>:
<expr_stmt><expr><name>errorCode</name> = <name>XML_ERROR_SUSPENDED</name></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</case><case>case <expr><name>XML_FINISHED</name></expr>:
<expr_stmt><expr><name>errorCode</name> = <name>XML_ERROR_FINISHED</name></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</case><default>default:
<empty_stmt>;</empty_stmt>
</default>}</block></switch>
<if>if <condition>(<expr><name>len</name> &gt; <name>bufferLim</name> - <name>bufferEnd</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>neededSize</name> <init>= <expr><name>len</name> + <call>(<name>int</name>)<argument_list>(<argument><expr><name>bufferEnd</name> - <name>bufferPtr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_CONTEXT_BYTES</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>keep</name> <init>= <expr><call>(<name>int</name>)<argument_list>(<argument><expr><name>bufferPtr</name> - <name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>keep</name> &gt; <name>XML_CONTEXT_BYTES</name></expr>)</condition><then>
<expr_stmt><expr><name>keep</name> = <name>XML_CONTEXT_BYTES</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>neededSize</name> += <name>keep</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><name>neededSize</name> &lt;= <name>bufferLim</name> - <name>buffer</name></expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_CONTEXT_BYTES</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>keep</name> &lt; <name>bufferPtr</name> - <name>buffer</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>offset</name> <init>= <expr><call>(<name>int</name>)<argument_list>(<argument><expr><name>bufferPtr</name> - <name>buffer</name></expr></argument>)</argument_list></call> - <name>keep</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr>&amp;<name><name>buffer</name><index>[<expr><name>offset</name></expr>]</index></name></expr></argument>, <argument><expr><name>bufferEnd</name> - <name>bufferPtr</name> + <name>keep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>bufferEnd</name> -= <name>offset</name></expr>;</expr_stmt>
<expr_stmt><expr><name>bufferPtr</name> -= <name>offset</name></expr>;</expr_stmt>
}</block></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>bufferPtr</name></expr></argument>, <argument><expr><name>bufferEnd</name> - <name>bufferPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>bufferEnd</name> = <name>buffer</name> + (<name>bufferEnd</name> - <name>bufferPtr</name>)</expr>;</expr_stmt>
<expr_stmt><expr><name>bufferPtr</name> = <name>buffer</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>newBuf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bufferSize</name> <init>= <expr><call>(<name>int</name>)<argument_list>(<argument><expr><name>bufferLim</name> - <name>bufferPtr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>bufferSize</name> == 0</expr>)</condition><then>
<expr_stmt><expr><name>bufferSize</name> = <name>INIT_BUFFER_SIZE</name></expr>;</expr_stmt></then></if>
<do>do <block>{
<expr_stmt><expr><name>bufferSize</name> *= 2</expr>;</expr_stmt>
}</block> while <condition>(<expr><name>bufferSize</name> &lt; <name>neededSize</name></expr>)</condition>;</do>
<expr_stmt><expr><name>newBuf</name> = (<name>char</name> *)<call><name>MALLOC</name><argument_list>(<argument><expr><name>bufferSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>newBuf</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>errorCode</name> = <name>XML_ERROR_NO_MEMORY</name></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>bufferLim</name> = <name>newBuf</name> + <name>bufferSize</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_CONTEXT_BYTES</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>bufferPtr</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>keep</name> <init>= <expr><call>(<name>int</name>)<argument_list>(<argument><expr><name>bufferPtr</name> - <name>buffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>keep</name> &gt; <name>XML_CONTEXT_BYTES</name></expr>)</condition><then>
<expr_stmt><expr><name>keep</name> = <name>XML_CONTEXT_BYTES</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>newBuf</name></expr></argument>, <argument><expr>&amp;<name><name>bufferPtr</name><index>[<expr>-<name>keep</name></expr>]</index></name></expr></argument>, <argument><expr><name>bufferEnd</name> - <name>bufferPtr</name> + <name>keep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>buffer</name> = <name>newBuf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>bufferEnd</name> = <name>buffer</name> + (<name>bufferEnd</name> - <name>bufferPtr</name>) + <name>keep</name></expr>;</expr_stmt>
<expr_stmt><expr><name>bufferPtr</name> = <name>buffer</name> + <name>keep</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>bufferEnd</name> = <name>newBuf</name> + (<name>bufferEnd</name> - <name>bufferPtr</name>)</expr>;</expr_stmt>
<expr_stmt><expr><name>bufferPtr</name> = <name>buffer</name> = <name>newBuf</name></expr>;</expr_stmt>
}</block></else></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if>if <condition>(<expr><name>bufferPtr</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>newBuf</name></expr></argument>, <argument><expr><name>bufferPtr</name></expr></argument>, <argument><expr><name>bufferEnd</name> - <name>bufferPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>bufferEnd</name> = <name>newBuf</name> + (<name>bufferEnd</name> - <name>bufferPtr</name>)</expr>;</expr_stmt>
<expr_stmt><expr><name>bufferPtr</name> = <name>buffer</name> = <name>newBuf</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></else></if>
}</block></then></if>
<return>return <expr><name>bufferEnd</name></expr>;</return>
}</block></function>
<enum>enum <name>XML_Status</name> <name>XMLCALL</name>
<name>XML_StopParser</name><expr_stmt><expr>(<name>XML_Parser</name> <name>parser</name>, <name>XML_Bool</name> <name>resumable</name>) <block>{
<switch>switch <condition>(<expr><name>ps_parsing</name></expr>)</condition> <block>{
<case>case <expr><name>XML_SUSPENDED</name></expr>:
<if>if <condition>(<expr><name>resumable</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>errorCode</name> = <name>XML_ERROR_SUSPENDED</name></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return>
<expr_stmt/></block></then></if></case></block></switch>}</block>
<name>ps_parsing</name> = <name>XML_FINISHED</name></expr>;</expr_stmt></enum>
<break>break;</break>
<case>case <expr><name>XML_FINISHED</name></expr>:
<expr_stmt><expr><name>errorCode</name> = <name>XML_ERROR_FINISHED</name></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return>
</case><default>default:
<if>if <condition>(<expr><name>resumable</name></expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>isParamEntity</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>errorCode</name> = <name>XML_ERROR_SUSPEND_PE</name></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>ps_parsing</name> = <name>XML_SUSPENDED</name></expr>;</expr_stmt>
}</block></then> <else>else
<expr_stmt><expr><name>ps_parsing</name> = <name>XML_FINISHED</name></expr>;</expr_stmt></else></if>
</default>}
return <expr_stmt><expr><name>XML_STATUS_OK</name></expr>;</expr_stmt>
}
enum <function><type><name>XML_Status</name> <name>XMLCALL</name></type>
<name>XML_ResumeParser</name><parameter_list>(<param><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></param>)</parameter_list> <block>{
<enum>enum <name>XML_Status</name> <name>result</name> <expr_stmt><expr>= <name>XML_STATUS_OK</name></expr>;</expr_stmt></enum>
<if>if <condition>(<expr><name>ps_parsing</name> != <name>XML_SUSPENDED</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>errorCode</name> = <name>XML_ERROR_NOT_SUSPENDED</name></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>ps_parsing</name> = <name>XML_PARSING</name></expr>;</expr_stmt>
<expr_stmt><expr><name>errorCode</name> = <call><name>processor</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>bufferPtr</name></expr></argument>, <argument><expr><name>parseEndPtr</name></expr></argument>, <argument><expr>&amp;<name>bufferPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>errorCode</name> != <name>XML_ERROR_NONE</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>eventEndPtr</name> = <name>eventPtr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>processor</name> = <name>errorProcessor</name></expr>;</expr_stmt>
<return>return <expr><name>XML_STATUS_ERROR</name></expr>;</return>
}</block></then> <else>else <block>{
<switch>switch <condition>(<expr><name>ps_parsing</name></expr>)</condition> <block>{
<case>case <expr><name>XML_SUSPENDED</name></expr>:
<expr_stmt><expr><name>result</name> = <name>XML_STATUS_SUSPENDED</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>XML_INITIALIZED</name></expr>:
</case><case>case <expr><name>XML_PARSING</name></expr>:
<if>if <condition>(<expr><name>ps_finalBuffer</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>ps_parsing</name> = <name>XML_FINISHED</name></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></then></if>
</case><default>default:
<empty_stmt>;</empty_stmt>
</default>}</block></switch>
}</block></else></if>
<expr_stmt><expr><call><name>XmlUpdatePosition</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>positionPtr</name></expr></argument>, <argument><expr><name>bufferPtr</name></expr></argument>, <argument><expr>&amp;<name>position</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>positionPtr</name> = <name>bufferPtr</name></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<function><type><name>void</name> <name>XMLCALL</name></type>
<name>XML_GetParsingStatus</name><parameter_list>(<param><decl><type><name>XML_Parser</name></type> <name>parser</name></decl></param>, <param><decl><type><name>XML_ParsingStatus</name> *</type><name>status</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>status</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>status</name> = <name><name>parser</name>-&gt;<name>m_parsingStatus</name></name></expr>;</expr_stmt>
}</block></function>
<enum>enum <name>XML_Error</name> <name>XMLCALL</name>
<name>XML_GetErrorCode</name><expr_stmt><expr>(<name>XML_Parser</name> <name>parser</name>) <block>{
<return>return <expr><name>errorCode</name></expr>;</return>
}</block></expr></expr_stmt>
<decl><name>XML_Index</name> <name>XMLCALL</name>
<name>XML_GetCurrentByteIndex</name><argument_list>(<argument><expr><name>XML_Parser</name> <name>parser</name></expr></argument>)</argument_list> <block>{
<if>if <condition>(<expr><name>eventPtr</name></expr>)</condition><then>
<return>return <expr><name>parseEndByteIndex</name> - (<name>parseEndPtr</name> - <name>eventPtr</name>)</expr>;</return></then></if>
<return>return <expr>-1</expr>;</return>
}</block></decl>
<decl><name>int</name> <name>XMLCALL</name>
<name>XML_GetCurrentByteCount</name><argument_list>(<argument><expr><name>XML_Parser</name> <name>parser</name></expr></argument>)</argument_list> <block>{
<if>if <condition>(<expr><name>eventEndPtr</name> &amp;&amp; <name>eventPtr</name></expr>)</condition><then>
<return>return <expr><call>(<name>int</name>)<argument_list>(<argument><expr><name>eventEndPtr</name> - <name>eventPtr</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<return>return <expr>0</expr>;</return>
}</block></decl>
<decl>const <name>char</name> * <name>XMLCALL</name>
<name>XML_GetInputContext</name><argument_list>(<argument><expr><name>XML_Parser</name> <name>parser</name></expr></argument>, <argument><expr><name>int</name> *<name>offset</name></expr></argument>, <argument><expr><name>int</name> *<name>size</name></expr></argument>)</argument_list> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_CONTEXT_BYTES</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>eventPtr</name> &amp;&amp; <name>buffer</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>offset</name> = <call>(<name>int</name>)<argument_list>(<argument><expr><name>eventPtr</name> - <name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>size</name> = <call>(<name>int</name>)<argument_list>(<argument><expr><name>bufferEnd</name> - <name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>buffer</name></expr>;</return>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr>(<name>char</name> *) 0</expr>;</return>
}</block></decl>
<decl><name>XML_Size</name> <name>XMLCALL</name>
<name>XML_GetCurrentLineNumber</name><argument_list>(<argument><expr><name>XML_Parser</name> <name>parser</name></expr></argument>)</argument_list> <block>{
<if>if <condition>(<expr><name>eventPtr</name> &amp;&amp; <name>eventPtr</name> &gt;= <name>positionPtr</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>XmlUpdatePosition</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>positionPtr</name></expr></argument>, <argument><expr><name>eventPtr</name></expr></argument>, <argument><expr>&amp;<name>position</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>positionPtr</name> = <name>eventPtr</name></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name><name>position</name>.<name>lineNumber</name></name> + 1</expr>;</return>
}</block></decl>
<decl><name>XML_Size</name> <name>XMLCALL</name>
<name>XML_GetCurrentColumnNumber</name><argument_list>(<argument><expr><name>XML_Parser</name> <name>parser</name></expr></argument>)</argument_list> <block>{
<if>if <condition>(<expr><name>eventPtr</name> &amp;&amp; <name>eventPtr</name> &gt;= <name>positionPtr</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>XmlUpdatePosition</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>positionPtr</name></expr></argument>, <argument><expr><name>eventPtr</name></expr></argument>, <argument><expr>&amp;<name>position</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>positionPtr</name> = <name>eventPtr</name></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name><name>position</name>.<name>columnNumber</name></name></expr>;</return>
}</block></decl>
<decl><name>void</name> <name>XMLCALL</name>
<name>XML_FreeContentModel</name><argument_list>(<argument><expr><name>XML_Parser</name> <name>parser</name></expr></argument>, <argument><expr><name>XML_Content</name> *<name>model</name></expr></argument>)</argument_list> <block>{
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>model</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></decl>
<decl><name>void</name> * <name>XMLCALL</name>
<name>XML_MemMalloc</name><argument_list>(<argument><expr><name>XML_Parser</name> <name>parser</name></expr></argument>, <argument><expr><name>size_t</name> <name>size</name></expr></argument>)</argument_list> <block>{
<return>return <expr><call><name>MALLOC</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></decl>
<decl><name>void</name> * <name>XMLCALL</name>
<name>XML_MemRealloc</name><argument_list>(<argument><expr><name>XML_Parser</name> <name>parser</name></expr></argument>, <argument><expr><name>void</name> *<name>ptr</name></expr></argument>, <argument><expr><name>size_t</name> <name>size</name></expr></argument>)</argument_list> <block>{
<return>return <expr><call><name>REALLOC</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></decl>
<decl><name>void</name> <name>XMLCALL</name>
<name>XML_MemFree</name><argument_list>(<argument><expr><name>XML_Parser</name> <name>parser</name></expr></argument>, <argument><expr><name>void</name> *<name>ptr</name></expr></argument>)</argument_list> <block>{
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></decl>
<decl><name>void</name> <name>XMLCALL</name>
<name>XML_DefaultCurrent</name><argument_list>(<argument><expr><name>XML_Parser</name> <name>parser</name></expr></argument>)</argument_list> <block>{
<if>if <condition>(<expr><name>defaultHandler</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>openInternalEntities</name></expr>)</condition><then>
<expr_stmt><expr><call><name>reportDefault</name><argument_list>(<argument><expr><name>parser</name></expr></argument>,
<argument><expr><name>internalEncoding</name></expr></argument>,
<argument><expr><name><name>openInternalEntities</name>-&gt;<name>internalEventPtr</name></name></expr></argument>,
<argument><expr><name><name>openInternalEntities</name>-&gt;<name>internalEventEndPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><call><name>reportDefault</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>eventPtr</name></expr></argument>, <argument><expr><name>eventEndPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
}</block></then></if>
}</block></decl>
<decl>const <name>XML_LChar</name> * <name>XMLCALL</name>
<name>XML_ErrorString</name><argument_list>(<argument>enum <expr><name>XML_Error</name> <name>code</name></expr></argument>)</argument_list> <block>{
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>XML_LChar</name>* <specifier>const</specifier></type> <name><name>message</name><index>[]</index></name> <init>= <expr><block>{
<expr>0</expr>,
<expr><call><name>XML_L</name><argument_list>(<argument><expr>"out of memory"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>XML_L</name><argument_list>(<argument><expr>"syntax error"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>XML_L</name><argument_list>(<argument><expr>"no element found"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>XML_L</name><argument_list>(<argument><expr>"not well-formed (invalid token)"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>XML_L</name><argument_list>(<argument><expr>"unclosed token"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>XML_L</name><argument_list>(<argument><expr>"partial character"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>XML_L</name><argument_list>(<argument><expr>"mismatched tag"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>XML_L</name><argument_list>(<argument><expr>"duplicate attribute"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>XML_L</name><argument_list>(<argument><expr>"junk after document element"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>XML_L</name><argument_list>(<argument><expr>"illegal parameter entity reference"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>XML_L</name><argument_list>(<argument><expr>"undefined entity"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>XML_L</name><argument_list>(<argument><expr>"recursive entity reference"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>XML_L</name><argument_list>(<argument><expr>"asynchronous entity"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>XML_L</name><argument_list>(<argument><expr>"reference to invalid character number"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>XML_L</name><argument_list>(<argument><expr>"reference to binary entity"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>XML_L</name><argument_list>(<argument><expr>"reference to external entity in attribute"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>XML_L</name><argument_list>(<argument><expr>"XML or text declaration not at start of entity"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>XML_L</name><argument_list>(<argument><expr>"unknown encoding"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>XML_L</name><argument_list>(<argument><expr>"encoding specified in XML declaration is incorrect"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>XML_L</name><argument_list>(<argument><expr>"unclosed CDATA section"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>XML_L</name><argument_list>(<argument><expr>"error in processing external entity reference"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>XML_L</name><argument_list>(<argument><expr>"document is not standalone"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>XML_L</name><argument_list>(<argument><expr>"unexpected parser state - please send a bug report"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>XML_L</name><argument_list>(<argument><expr>"entity declared in parameter entity"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>XML_L</name><argument_list>(<argument><expr>"requested feature requires XML_DTD support in Expat"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>XML_L</name><argument_list>(<argument><expr>"cannot change setting once parsing has begun"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>XML_L</name><argument_list>(<argument><expr>"unbound prefix"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>XML_L</name><argument_list>(<argument><expr>"must not undeclare prefix"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>XML_L</name><argument_list>(<argument><expr>"incomplete markup in parameter entity"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>XML_L</name><argument_list>(<argument><expr>"XML declaration not well-formed"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>XML_L</name><argument_list>(<argument><expr>"text declaration not well-formed"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>XML_L</name><argument_list>(<argument><expr>"illegal character(s) in public id"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>XML_L</name><argument_list>(<argument><expr>"parser suspended"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>XML_L</name><argument_list>(<argument><expr>"parser not suspended"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>XML_L</name><argument_list>(<argument><expr>"parsing aborted"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>XML_L</name><argument_list>(<argument><expr>"parsing finished"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>XML_L</name><argument_list>(<argument><expr>"cannot suspend in external parameter entity"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>XML_L</name><argument_list>(<argument><expr>"reserved prefix (xml) must not be undeclared or bound to another namespace name"</expr></argument>)</argument_list></call></expr>,
<expr><call><name>XML_L</name><argument_list>(<argument><expr>"reserved prefix (xmlns) must not be declared or undeclared"</expr></argument>)</argument_list></call></expr>,
<macro><name>XML_L</name><argument_list>(<argument>"prefix must not be bound to one of the reserved namespace names"</argument>)</argument_list></macro>
}</block></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>code</name> &gt; 0 &amp;&amp; <name>code</name> &lt; <sizeof>sizeof<argument_list>(<argument><expr><name>message</name></expr></argument>)</argument_list></sizeof>/<sizeof>sizeof<argument_list>(<argument><expr><name><name>message</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>)</condition><then>
<return>return <expr><name><name>message</name><index>[<expr><name>code</name></expr>]</index></name></expr>;</return></then></if>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></decl>
<decl>const <name>XML_LChar</name> * <name>XMLCALL</name>
<name>XML_ExpatVersion</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list> <block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>V1</name><parameter_list>(<param><type><name>a</name></type></param>,<param><type><name>b</name></type></param>,<param><type><name>c</name></type></param>)</parameter_list></cpp:macro> <cpp:value>XML_L(#a)XML_L(".")XML_L(#b)XML_L(".")XML_L(#c)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>V2</name><parameter_list>(<param><type><name>a</name></type></param>,<param><type><name>b</name></type></param>,<param><type><name>c</name></type></param>)</parameter_list></cpp:macro> <cpp:value>XML_L("expat_")V1(a,b,c)</cpp:value></cpp:define>
<return>return <expr><call><name>V2</name><argument_list>(<argument><expr><name>XML_MAJOR_VERSION</name></expr></argument>, <argument><expr><name>XML_MINOR_VERSION</name></expr></argument>, <argument><expr><name>XML_MICRO_VERSION</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>V1</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>V2</name></cpp:undef>
}</block></decl>
<decl><name>XML_Expat_Version</name> <name>XMLCALL</name>
<name>XML_ExpatVersionInfo</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list> <block>{
<decl_stmt><decl><type><name>XML_Expat_Version</name></type> <name>version</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>version</name>.<name>major</name></name> = <name>XML_MAJOR_VERSION</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>version</name>.<name>minor</name></name> = <name>XML_MINOR_VERSION</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>version</name>.<name>micro</name></name> = <name>XML_MICRO_VERSION</name></expr>;</expr_stmt>
<return>return <expr><name>version</name></expr>;</return>
}</block></decl>
<decl>const <name>XML_Feature</name> * <name>XMLCALL</name>
<name>XML_GetFeatureList</name><argument_list>(<argument><expr><name>void</name></expr></argument>)</argument_list> <block>{
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>XML_Feature</name></type> <name><name>features</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{
<expr><name>XML_FEATURE_SIZEOF_XML_CHAR</name></expr>, <expr><call><name>XML_L</name><argument_list>(<argument><expr>"sizeof(XML_Char)"</expr></argument>)</argument_list></call></expr>,
<expr>sizeof(<name>XML_Char</name>)</expr>
}</block></expr>,
<expr><block>{
<expr><name>XML_FEATURE_SIZEOF_XML_LCHAR</name></expr>, <expr><call><name>XML_L</name><argument_list>(<argument><expr>"sizeof(XML_LChar)"</expr></argument>)</argument_list></call></expr>,
<expr>sizeof(<name>XML_LChar</name>)</expr>
}</block></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr><name>XML_FEATURE_UNICODE</name></expr>, <expr><call><name>XML_L</name><argument_list>(<argument><expr>"XML_UNICODE"</expr></argument>)</argument_list></call></expr>, <expr>0</expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_UNICODE_WCHAR_T</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr><name>XML_FEATURE_UNICODE_WCHAR_T</name></expr>, <expr><call><name>XML_L</name><argument_list>(<argument><expr>"XML_UNICODE_WCHAR_T"</expr></argument>)</argument_list></call></expr>, <expr>0</expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr><name>XML_FEATURE_DTD</name></expr>, <expr><call><name>XML_L</name><argument_list>(<argument><expr>"XML_DTD"</expr></argument>)</argument_list></call></expr>, <expr>0</expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_CONTEXT_BYTES</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{
<expr><name>XML_FEATURE_CONTEXT_BYTES</name></expr>, <expr><call><name>XML_L</name><argument_list>(<argument><expr>"XML_CONTEXT_BYTES"</expr></argument>)</argument_list></call></expr>,
<expr><name>XML_CONTEXT_BYTES</name></expr>
}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_MIN_SIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr><name>XML_FEATURE_MIN_SIZE</name></expr>, <expr><call><name>XML_L</name><argument_list>(<argument><expr>"XML_MIN_SIZE"</expr></argument>)</argument_list></call></expr>, <expr>0</expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_NS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr><name>XML_FEATURE_NS</name></expr>, <expr><call><name>XML_L</name><argument_list>(<argument><expr>"XML_NS"</expr></argument>)</argument_list></call></expr>, <expr>0</expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr><block>{<expr><name>XML_FEATURE_END</name></expr>, <expr><name>NULL</name></expr>, <expr>0</expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<return>return <expr><name>features</name></expr>;</return>
}</block></decl>
<decl>static <name>XML_Bool</name>
<name>storeRawNames</name><argument_list>(<argument><expr><name>XML_Parser</name> <name>parser</name></expr></argument>)</argument_list> <block>{
<decl_stmt><decl><type><name>TAG</name> *</type><name>tag</name> <init>= <expr><name>tagStack</name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>tag</name></expr>)</condition> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>bufSize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nameLen</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>XML_Char</name></expr></argument>)</argument_list></sizeof> * (<name><name>tag</name>-&gt;<name>name</name>.<name>strLen</name></name> + 1)</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>rawNameBuf</name> <init>= <expr><name><name>tag</name>-&gt;<name>buf</name></name> + <name>nameLen</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>tag</name>-&gt;<name>rawName</name></name> == <name>rawNameBuf</name></expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr><name>bufSize</name> = <name>nameLen</name> + <call><name>ROUND_UP</name><argument_list>(<argument><expr><name><name>tag</name>-&gt;<name>rawNameLength</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>XML_Char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>bufSize</name> &gt; <name><name>tag</name>-&gt;<name>bufEnd</name></name> - <name><name>tag</name>-&gt;<name>buf</name></name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>temp</name> <init>= <expr>(<name>char</name> *)<call><name>REALLOC</name><argument_list>(<argument><expr><name><name>tag</name>-&gt;<name>buf</name></name></expr></argument>, <argument><expr><name>bufSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>temp</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>XML_FALSE</name></expr>;</return></then></if>
<if>if <condition>(<expr><name><name>tag</name>-&gt;<name>name</name>.<name>str</name></name> == (<name>XML_Char</name> *)<name><name>tag</name>-&gt;<name>buf</name></name></expr>)</condition><then>
<expr_stmt><expr><name><name>tag</name>-&gt;<name>name</name>.<name>str</name></name> = (<name>XML_Char</name> *)<name>temp</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name><name>tag</name>-&gt;<name>name</name>.<name>localPart</name></name></expr>)</condition><then>
<expr_stmt><expr><name><name>tag</name>-&gt;<name>name</name>.<name>localPart</name></name> = (<name>XML_Char</name> *)<name>temp</name> + (<name><name>tag</name>-&gt;<name>name</name>.<name>localPart</name></name> -
(<name>XML_Char</name> *)<name><name>tag</name>-&gt;<name>buf</name></name>)</expr>;</expr_stmt></then></if>
<expr_stmt><expr><name><name>tag</name>-&gt;<name>buf</name></name> = <name>temp</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tag</name>-&gt;<name>bufEnd</name></name> = <name>temp</name> + <name>bufSize</name></expr>;</expr_stmt>
<expr_stmt><expr><name>rawNameBuf</name> = <name>temp</name> + <name>nameLen</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>rawNameBuf</name></expr></argument>, <argument><expr><name><name>tag</name>-&gt;<name>rawName</name></name></expr></argument>, <argument><expr><name><name>tag</name>-&gt;<name>rawNameLength</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tag</name>-&gt;<name>rawName</name></name> = <name>rawNameBuf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>tag</name> = <name><name>tag</name>-&gt;<name>parent</name></name></expr>;</expr_stmt>
}</block></while>
<return>return <expr><name>XML_TRUE</name></expr>;</return>
}</block></decl>
<decl>static enum <name>XML_Error</name> <name>PTRCALL</name>
<name>contentProcessor</name><argument_list>(<argument><expr><name>XML_Parser</name> <name>parser</name></expr></argument>,
<argument><expr>const <name>char</name> *<name>start</name></expr></argument>,
<argument><expr>const <name>char</name> *<name>end</name></expr></argument>,
<argument><expr>const <name>char</name> **<name>endPtr</name></expr></argument>)</argument_list> <block>{
<enum>enum <name>XML_Error</name> <name>result</name> <expr_stmt><expr>= <call><name>doContent</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>,
<argument><expr><name>endPtr</name></expr></argument>, <argument><expr>(<name>XML_Bool</name>)!<name>ps_finalBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></enum>
<if>if <condition>(<expr><name>result</name> == <name>XML_ERROR_NONE</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<call><name>storeRawNames</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></then></if>
}</block></then></if>
<return>return <expr><name>result</name></expr>;</return>
}</block></decl>
<decl>static enum <name>XML_Error</name> <name>PTRCALL</name>
<name>externalEntityInitProcessor</name><argument_list>(<argument><expr><name>XML_Parser</name> <name>parser</name></expr></argument>,
<argument><expr>const <name>char</name> *<name>start</name></expr></argument>,
<argument><expr>const <name>char</name> *<name>end</name></expr></argument>,
<argument><expr>const <name>char</name> **<name>endPtr</name></expr></argument>)</argument_list> <block>{
<enum>enum <name>XML_Error</name> <name>result</name> <expr_stmt><expr>= <call><name>initializeEncoding</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></enum>
<if>if <condition>(<expr><name>result</name> != <name>XML_ERROR_NONE</name></expr>)</condition><then>
<return>return <expr><name>result</name></expr>;</return></then></if>
<expr_stmt><expr><name>processor</name> = <name>externalEntityInitProcessor2</name></expr>;</expr_stmt>
<return>return <expr><call><name>externalEntityInitProcessor2</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>endPtr</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></decl>
<decl>static enum <name>XML_Error</name> <name>PTRCALL</name>
<name>externalEntityInitProcessor2</name><argument_list>(<argument><expr><name>XML_Parser</name> <name>parser</name></expr></argument>,
<argument><expr>const <name>char</name> *<name>start</name></expr></argument>,
<argument><expr>const <name>char</name> *<name>end</name></expr></argument>,
<argument><expr>const <name>char</name> **<name>endPtr</name></expr></argument>)</argument_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>next</name> <init>= <expr><name>start</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tok</name> <init>= <expr><call><name>XmlContentTok</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr>&amp;<name>next</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name>tok</name></expr>)</condition> <block>{
<case>case <expr><name>XML_TOK_BOM</name></expr>:
<if>if <condition>(<expr><name>next</name> == <name>end</name> &amp;&amp; !<name>ps_finalBuffer</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>endPtr</name> = <name>next</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>start</name> = <name>next</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>XML_TOK_PARTIAL</name></expr>:
<if>if <condition>(<expr>!<name>ps_finalBuffer</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>endPtr</name> = <name>start</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>eventPtr</name> = <name>start</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_UNCLOSED_TOKEN</name></expr>;</return>
</case><case>case <expr><name>XML_TOK_PARTIAL_CHAR</name></expr>:
<if>if <condition>(<expr>!<name>ps_finalBuffer</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>endPtr</name> = <name>start</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>eventPtr</name> = <name>start</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_PARTIAL_CHAR</name></expr>;</return>
</case>}</block></switch>
<expr_stmt><expr><name>processor</name> = <name>externalEntityInitProcessor3</name></expr>;</expr_stmt>
<return>return <expr><call><name>externalEntityInitProcessor3</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>endPtr</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></decl>
<decl>static enum <name>XML_Error</name> <name>PTRCALL</name>
<name>externalEntityInitProcessor3</name><argument_list>(<argument><expr><name>XML_Parser</name> <name>parser</name></expr></argument>,
<argument><expr>const <name>char</name> *<name>start</name></expr></argument>,
<argument><expr>const <name>char</name> *<name>end</name></expr></argument>,
<argument><expr>const <name>char</name> **<name>endPtr</name></expr></argument>)</argument_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>tok</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>next</name> <init>= <expr><name>start</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>eventPtr</name> = <name>start</name></expr>;</expr_stmt>
<expr_stmt><expr><name>tok</name> = <call><name>XmlContentTok</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr>&amp;<name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>eventEndPtr</name> = <name>next</name></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>tok</name></expr>)</condition> <block>{
<case>case <expr><name>XML_TOK_XML_DECL</name></expr>: <block>{
<enum>enum <name>XML_Error</name> <name>result</name>;</enum>
<expr_stmt><expr><name>result</name> = <call><name>processXmlDecl</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> != <name>XML_ERROR_NONE</name></expr>)</condition><then>
<return>return <expr><name>result</name></expr>;</return></then></if>
<switch>switch <condition>(<expr><name>ps_parsing</name></expr>)</condition> <block>{
<case>case <expr><name>XML_SUSPENDED</name></expr>:
<expr_stmt><expr>*<name>endPtr</name> = <name>next</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
</case><case>case <expr><name>XML_FINISHED</name></expr>:
<return>return <expr><name>XML_ERROR_ABORTED</name></expr>;</return>
</case><default>default:
<expr_stmt><expr><name>start</name> = <name>next</name></expr>;</expr_stmt>
</default>}</block></switch>
}</block>
<break>break;</break>
</case><case>case <expr><name>XML_TOK_PARTIAL</name></expr>:
<if>if <condition>(<expr>!<name>ps_finalBuffer</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>endPtr</name> = <name>start</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
}</block></then></if>
<return>return <expr><name>XML_ERROR_UNCLOSED_TOKEN</name></expr>;</return>
</case><case>case <expr><name>XML_TOK_PARTIAL_CHAR</name></expr>:
<if>if <condition>(<expr>!<name>ps_finalBuffer</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>endPtr</name> = <name>start</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
}</block></then></if>
<return>return <expr><name>XML_ERROR_PARTIAL_CHAR</name></expr>;</return>
</case>}</block></switch>
<expr_stmt><expr><name>processor</name> = <name>externalEntityContentProcessor</name></expr>;</expr_stmt>
<expr_stmt><expr><name>tagLevel</name> = 1</expr>;</expr_stmt>
<return>return <expr><call><name>externalEntityContentProcessor</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>endPtr</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></decl>
<decl>static enum <name>XML_Error</name> <name>PTRCALL</name>
<name>externalEntityContentProcessor</name><argument_list>(<argument><expr><name>XML_Parser</name> <name>parser</name></expr></argument>,
<argument><expr>const <name>char</name> *<name>start</name></expr></argument>,
<argument><expr>const <name>char</name> *<name>end</name></expr></argument>,
<argument><expr>const <name>char</name> **<name>endPtr</name></expr></argument>)</argument_list> <block>{
<enum>enum <name>XML_Error</name> <name>result</name> <expr_stmt><expr>= <call><name>doContent</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>,
<argument><expr><name>endPtr</name></expr></argument>, <argument><expr>(<name>XML_Bool</name>)!<name>ps_finalBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></enum>
<if>if <condition>(<expr><name>result</name> == <name>XML_ERROR_NONE</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<call><name>storeRawNames</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></then></if>
}</block></then></if>
<return>return <expr><name>result</name></expr>;</return>
}</block></decl>
<decl>static enum <name>XML_Error</name>
<name>doContent</name><argument_list>(<argument><expr><name>XML_Parser</name> <name>parser</name></expr></argument>,
<argument><expr><name>int</name> <name>startTagLevel</name></expr></argument>,
<argument><expr>const <name>ENCODING</name> *<name>enc</name></expr></argument>,
<argument><expr>const <name>char</name> *<name>s</name></expr></argument>,
<argument><expr>const <name>char</name> *<name>end</name></expr></argument>,
<argument><expr>const <name>char</name> **<name>nextPtr</name></expr></argument>,
<argument><expr><name>XML_Bool</name> <name>haveMore</name></expr></argument>)</argument_list> <block>{
<decl_stmt><decl><type><name>DTD</name> * <specifier>const</specifier></type> <name>dtd</name> <init>= <expr><name>_dtd</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> **</type><name>eventPP</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> **</type><name>eventEndPP</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>enc</name> == <name>encoding</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>eventPP</name> = &amp;<name>eventPtr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>eventEndPP</name> = &amp;<name>eventEndPtr</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>eventPP</name> = &amp;(<name><name>openInternalEntities</name>-&gt;<name>internalEventPtr</name></name>)</expr>;</expr_stmt>
<expr_stmt><expr><name>eventEndPP</name> = &amp;(<name><name>openInternalEntities</name>-&gt;<name>internalEventEndPtr</name></name>)</expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr>*<name>eventPP</name> = <name>s</name></expr>;</expr_stmt>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>next</name> <init>= <expr><name>s</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tok</name> <init>= <expr><call><name>XmlContentTok</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr>&amp;<name>next</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr>*<name>eventEndPP</name> = <name>next</name></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>tok</name></expr>)</condition> <block>{
<case>case <expr><name>XML_TOK_TRAILING_CR</name></expr>:
<if>if <condition>(<expr><name>haveMore</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>nextPtr</name> = <name>s</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr>*<name>eventEndPP</name> = <name>end</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>characterDataHandler</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>XML_Char</name></type> <name>c</name> <init>= <expr>0xA</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>characterDataHandler</name><argument_list>(<argument><expr><name>handlerArg</name></expr></argument>, <argument><expr>&amp;<name>c</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>defaultHandler</name></expr>)</condition><then>
<expr_stmt><expr><call><name>reportDefault</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if>
<if>if <condition>(<expr><name>startTagLevel</name> == 0</expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_ELEMENTS</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>tagLevel</name> != <name>startTagLevel</name></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_ASYNC_ENTITY</name></expr>;</return></then></if>
<expr_stmt><expr>*<name>nextPtr</name> = <name>end</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
</case><case>case <expr><name>XML_TOK_NONE</name></expr>:
<if>if <condition>(<expr><name>haveMore</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>nextPtr</name> = <name>s</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>startTagLevel</name> &gt; 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>tagLevel</name> != <name>startTagLevel</name></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_ASYNC_ENTITY</name></expr>;</return></then></if>
<expr_stmt><expr>*<name>nextPtr</name> = <name>s</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
}</block></then></if>
<return>return <expr><name>XML_ERROR_NO_ELEMENTS</name></expr>;</return>
</case><case>case <expr><name>XML_TOK_INVALID</name></expr>:
<expr_stmt><expr>*<name>eventPP</name> = <name>next</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_INVALID_TOKEN</name></expr>;</return>
</case><case>case <expr><name>XML_TOK_PARTIAL</name></expr>:
<if>if <condition>(<expr><name>haveMore</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>nextPtr</name> = <name>s</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
}</block></then></if>
<return>return <expr><name>XML_ERROR_UNCLOSED_TOKEN</name></expr>;</return>
</case><case>case <expr><name>XML_TOK_PARTIAL_CHAR</name></expr>:
<if>if <condition>(<expr><name>haveMore</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>nextPtr</name> = <name>s</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
}</block></then></if>
<return>return <expr><name>XML_ERROR_PARTIAL_CHAR</name></expr>;</return>
</case><case>case <expr><name>XML_TOK_ENTITY_REF</name></expr>: <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ENTITY</name> *</type><name>entity</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Char</name></type> <name>ch</name> <init>= <expr>(<name>XML_Char</name>) <call><name>XmlPredefinedEntityName</name><argument_list>(<argument><expr><name>enc</name></expr></argument>,
<argument><expr><name>s</name> + <name><name>enc</name>-&gt;<name>minBytesPerChar</name></name></expr></argument>,
<argument><expr><name>next</name> - <name><name>enc</name>-&gt;<name>minBytesPerChar</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>ch</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>characterDataHandler</name></expr>)</condition><then>
<expr_stmt><expr><call><name>characterDataHandler</name><argument_list>(<argument><expr><name>handlerArg</name></expr></argument>, <argument><expr>&amp;<name>ch</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name>defaultHandler</name></expr>)</condition><then>
<expr_stmt><expr><call><name>reportDefault</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if>
<break>break;</break>
}</block></then></if>
<expr_stmt><expr><name>name</name> = <call><name>poolStoreString</name><argument_list>(<argument><expr>&amp;<name><name>dtd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>enc</name></expr></argument>,
<argument><expr><name>s</name> + <name><name>enc</name>-&gt;<name>minBytesPerChar</name></name></expr></argument>,
<argument><expr><name>next</name> - <name><name>enc</name>-&gt;<name>minBytesPerChar</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>name</name></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></then></if>
<expr_stmt><expr><name>entity</name> = (<name>ENTITY</name> *)<call><name>lookup</name><argument_list>(<argument><expr>&amp;<name><name>dtd</name>-&gt;<name>generalEntities</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>poolDiscard</name><argument_list>(<argument><expr>&amp;<name><name>dtd</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name><name>dtd</name>-&gt;<name>hasParamEntityRefs</name></name> || <name><name>dtd</name>-&gt;<name>standalone</name></name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<name>entity</name></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_UNDEFINED_ENTITY</name></expr>;</return></then>
<else>else <if>if <condition>(<expr>!<name><name>entity</name>-&gt;<name>is_internal</name></name></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_ENTITY_DECLARED_IN_PE</name></expr>;</return></then></if></else></if>
}</block></then> <else>else <if>if <condition>(<expr>!<name>entity</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>skippedEntityHandler</name></expr>)</condition><then>
<expr_stmt><expr><call><name>skippedEntityHandler</name><argument_list>(<argument><expr><name>handlerArg</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name>defaultHandler</name></expr>)</condition><then>
<expr_stmt><expr><call><name>reportDefault</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if>
<break>break;</break>
}</block></then></if></else></if>
<if>if <condition>(<expr><name><name>entity</name>-&gt;<name>open</name></name></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_RECURSIVE_ENTITY_REF</name></expr>;</return></then></if>
<if>if <condition>(<expr><name><name>entity</name>-&gt;<name>notation</name></name></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_BINARY_ENTITY_REF</name></expr>;</return></then></if>
<if>if <condition>(<expr><name><name>entity</name>-&gt;<name>textPtr</name></name></expr>)</condition><then> <block>{
<enum>enum <name>XML_Error</name> <name>result</name>;</enum>
<if>if <condition>(<expr>!<name>defaultExpandInternalEntities</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>skippedEntityHandler</name></expr>)</condition><then>
<expr_stmt><expr><call><name>skippedEntityHandler</name><argument_list>(<argument><expr><name>handlerArg</name></expr></argument>, <argument><expr><name><name>entity</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name>defaultHandler</name></expr>)</condition><then>
<expr_stmt><expr><call><name>reportDefault</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if>
<break>break;</break>
}</block></then></if>
<expr_stmt><expr><name>result</name> = <call><name>processInternalEntity</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>entity</name></expr></argument>, <argument><expr><name>XML_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> != <name>XML_ERROR_NONE</name></expr>)</condition><then>
<return>return <expr><name>result</name></expr>;</return></then></if>
}</block></then> <else>else <if>if <condition>(<expr><name>externalEntityRefHandler</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>context</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>entity</name>-&gt;<name>open</name></name> = <name>XML_TRUE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>context</name> = <call><name>getContext</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>entity</name>-&gt;<name>open</name></name> = <name>XML_FALSE</name></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>context</name></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>externalEntityRefHandler</name><argument_list>(<argument><expr><name>externalEntityRefHandlerArg</name></expr></argument>,
<argument><expr><name>context</name></expr></argument>,
<argument><expr><name><name>entity</name>-&gt;<name>base</name></name></expr></argument>,
<argument><expr><name><name>entity</name>-&gt;<name>systemId</name></name></expr></argument>,
<argument><expr><name><name>entity</name>-&gt;<name>publicId</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_EXTERNAL_ENTITY_HANDLING</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>poolDiscard</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>defaultHandler</name></expr>)</condition><then>
<expr_stmt><expr><call><name>reportDefault</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if></else></if>
<break>break;</break>
}</block>
</case><case>case <expr><name>XML_TOK_START_TAG_NO_ATTS</name></expr>:
</case><case>case <expr><name>XML_TOK_START_TAG_WITH_ATTS</name></expr>: <block>{
<decl_stmt><decl><type><name>TAG</name> *</type><name>tag</name></decl>;</decl_stmt>
<enum>enum <name>XML_Error</name> <name>result</name>;</enum>
<decl_stmt><decl><type><name>XML_Char</name> *</type><name>toPtr</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>freeTagList</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>tag</name> = <name>freeTagList</name></expr>;</expr_stmt>
<expr_stmt><expr><name>freeTagList</name> = <name><name>freeTagList</name>-&gt;<name>parent</name></name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>tag</name> = (<name>TAG</name> *)<call><name>MALLOC</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TAG</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>tag</name></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>tag</name>-&gt;<name>buf</name></name> = (<name>char</name> *)<call><name>MALLOC</name><argument_list>(<argument><expr><name>INIT_TAG_BUF_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name><name>tag</name>-&gt;<name>buf</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>tag</name>-&gt;<name>bufEnd</name></name> = <name><name>tag</name>-&gt;<name>buf</name></name> + <name>INIT_TAG_BUF_SIZE</name></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><name><name>tag</name>-&gt;<name>bindings</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tag</name>-&gt;<name>parent</name></name> = <name>tagStack</name></expr>;</expr_stmt>
<expr_stmt><expr><name>tagStack</name> = <name>tag</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tag</name>-&gt;<name>name</name>.<name>localPart</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tag</name>-&gt;<name>name</name>.<name>prefix</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tag</name>-&gt;<name>rawName</name></name> = <name>s</name> + <name><name>enc</name>-&gt;<name>minBytesPerChar</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tag</name>-&gt;<name>rawNameLength</name></name> = <call><name>XmlNameLength</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name><name>tag</name>-&gt;<name>rawName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>++<name>tagLevel</name></expr>;</expr_stmt>
<block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>rawNameEnd</name> <init>= <expr><name><name>tag</name>-&gt;<name>rawName</name></name> + <name><name>tag</name>-&gt;<name>rawNameLength</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fromPtr</name> <init>= <expr><name><name>tag</name>-&gt;<name>rawName</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>toPtr</name> = (<name>XML_Char</name> *)<name><name>tag</name>-&gt;<name>buf</name></name></expr>;</expr_stmt>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<decl_stmt><decl><type><name>int</name></type> <name>bufSize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>convLen</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>XmlConvert</name><argument_list>(<argument><expr><name>enc</name></expr></argument>,
<argument><expr>&amp;<name>fromPtr</name></expr></argument>, <argument><expr><name>rawNameEnd</name></expr></argument>,
<argument><expr>(<name>ICHAR</name> **)&amp;<name>toPtr</name></expr></argument>, <argument><expr>(<name>ICHAR</name> *)<name><name>tag</name>-&gt;<name>bufEnd</name></name> - 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>convLen</name> = <call>(<name>int</name>)<argument_list>(<argument><expr><name>toPtr</name> - (<name>XML_Char</name> *)<name><name>tag</name>-&gt;<name>buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>fromPtr</name> == <name>rawNameEnd</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>tag</name>-&gt;<name>name</name>.<name>strLen</name></name> = <name>convLen</name></expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
<expr_stmt><expr><name>bufSize</name> = <call>(<name>int</name>)<argument_list>(<argument><expr><name><name>tag</name>-&gt;<name>bufEnd</name></name> - <name><name>tag</name>-&gt;<name>buf</name></name></expr></argument>)</argument_list></call> &lt;&lt; 1</expr>;</expr_stmt>
<block>{
<decl_stmt><decl><type><name>char</name> *</type><name>temp</name> <init>= <expr>(<name>char</name> *)<call><name>REALLOC</name><argument_list>(<argument><expr><name><name>tag</name>-&gt;<name>buf</name></name></expr></argument>, <argument><expr><name>bufSize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>temp</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>tag</name>-&gt;<name>buf</name></name> = <name>temp</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tag</name>-&gt;<name>bufEnd</name></name> = <name>temp</name> + <name>bufSize</name></expr>;</expr_stmt>
<expr_stmt><expr><name>toPtr</name> = (<name>XML_Char</name> *)<name>temp</name> + <name>convLen</name></expr>;</expr_stmt>
}</block>
}</block></for>
}</block>
<expr_stmt><expr><name><name>tag</name>-&gt;<name>name</name>.<name>str</name></name> = (<name>XML_Char</name> *)<name><name>tag</name>-&gt;<name>buf</name></name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>toPtr</name> = <call><name>XML_T</name><argument_list>(<argument><expr>'\0'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> = <call><name>storeAtts</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr>&amp;(<name><name>tag</name>-&gt;<name>name</name></name>)</expr></argument>, <argument><expr>&amp;(<name><name>tag</name>-&gt;<name>bindings</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name></expr>)</condition><then>
<return>return <expr><name>result</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>startElementHandler</name></expr>)</condition><then>
<expr_stmt><expr><call><name>startElementHandler</name><argument_list>(<argument><expr><name>handlerArg</name></expr></argument>, <argument><expr><name><name>tag</name>-&gt;<name>name</name>.<name>str</name></name></expr></argument>,
<argument><expr>(const <name>XML_Char</name> **)<name>atts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name>defaultHandler</name></expr>)</condition><then>
<expr_stmt><expr><call><name>reportDefault</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if>
<expr_stmt><expr><call><name>poolClear</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
}</block>
</case><case>case <expr><name>XML_TOK_EMPTY_ELEMENT_NO_ATTS</name></expr>:
</case><case>case <expr><name>XML_TOK_EMPTY_ELEMENT_WITH_ATTS</name></expr>: <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>rawName</name> <init>= <expr><name>s</name> + <name><name>enc</name>-&gt;<name>minBytesPerChar</name></name></expr></init></decl>;</decl_stmt>
<enum>enum <name>XML_Error</name> <name>result</name>;</enum>
<decl_stmt><decl><type><name>BINDING</name> *</type><name>bindings</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Bool</name></type> <name>noElmHandlers</name> <init>= <expr><name>XML_TRUE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TAG_NAME</name></type> <name>name</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>name</name>.<name>str</name></name> = <call><name>poolStoreString</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>rawName</name></expr></argument>,
<argument><expr><name>rawName</name> + <call><name>XmlNameLength</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>rawName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name><name>name</name>.<name>str</name></name></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>poolFinish</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> = <call><name>storeAtts</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>, <argument><expr>&amp;<name>bindings</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name></expr>)</condition><then>
<return>return <expr><name>result</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>poolFinish</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>startElementHandler</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>startElementHandler</name><argument_list>(<argument><expr><name>handlerArg</name></expr></argument>, <argument><expr><name><name>name</name>.<name>str</name></name></expr></argument>, <argument><expr>(const <name>XML_Char</name> **)<name>atts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>noElmHandlers</name> = <name>XML_FALSE</name></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>endElementHandler</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>startElementHandler</name></expr>)</condition><then>
<expr_stmt><expr>*<name>eventPP</name> = *<name>eventEndPP</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>endElementHandler</name><argument_list>(<argument><expr><name>handlerArg</name></expr></argument>, <argument><expr><name><name>name</name>.<name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>noElmHandlers</name> = <name>XML_FALSE</name></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>noElmHandlers</name> &amp;&amp; <name>defaultHandler</name></expr>)</condition><then>
<expr_stmt><expr><call><name>reportDefault</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>poolClear</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>bindings</name></expr>)</condition> <block>{
<decl_stmt><decl><type><name>BINDING</name> *</type><name>b</name> <init>= <expr><name>bindings</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>endNamespaceDeclHandler</name></expr>)</condition><then>
<expr_stmt><expr><call><name>endNamespaceDeclHandler</name><argument_list>(<argument><expr><name>handlerArg</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>prefix</name>-&gt;<name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>bindings</name> = <name><name>bindings</name>-&gt;<name>nextTagBinding</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name>-&gt;<name>nextTagBinding</name></name> = <name>freeBindingList</name></expr>;</expr_stmt>
<expr_stmt><expr><name>freeBindingList</name> = <name>b</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name>-&gt;<name>prefix</name>-&gt;<name>binding</name></name> = <name><name>b</name>-&gt;<name>prevPrefixBinding</name></name></expr>;</expr_stmt>
}</block></while>
}</block>
<if>if <condition>(<expr><name>tagLevel</name> == 0</expr>)</condition><then>
<return>return <expr><call><name>epilogProcessor</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>next</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>nextPtr</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<break>break;</break>
</case><case>case <expr><name>XML_TOK_END_TAG</name></expr>:
<if>if <condition>(<expr><name>tagLevel</name> == <name>startTagLevel</name></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_ASYNC_ENTITY</name></expr>;</return></then>
<else>else <block>{
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>rawName</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>TAG</name> *</type><name>tag</name> <init>= <expr><name>tagStack</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>tagStack</name> = <name><name>tag</name>-&gt;<name>parent</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tag</name>-&gt;<name>parent</name></name> = <name>freeTagList</name></expr>;</expr_stmt>
<expr_stmt><expr><name>freeTagList</name> = <name>tag</name></expr>;</expr_stmt>
<expr_stmt><expr><name>rawName</name> = <name>s</name> + <name><name>enc</name>-&gt;<name>minBytesPerChar</name></name>*2</expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> = <call><name>XmlNameLength</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>rawName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>len</name> != <name><name>tag</name>-&gt;<name>rawNameLength</name></name>
|| <call><name>memcmp</name><argument_list>(<argument><expr><name><name>tag</name>-&gt;<name>rawName</name></name></expr></argument>, <argument><expr><name>rawName</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>eventPP</name> = <name>rawName</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_TAG_MISMATCH</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr>--<name>tagLevel</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>endElementHandler</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>localPart</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>prefix</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Char</name> *</type><name>uri</name></decl>;</decl_stmt>
<expr_stmt><expr><name>localPart</name> = <name><name>tag</name>-&gt;<name>name</name>.<name>localPart</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ns</name> &amp;&amp; <name>localPart</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>uri</name> = (<name>XML_Char</name> *)<name><name>tag</name>-&gt;<name>name</name>.<name>str</name></name> + <name><name>tag</name>-&gt;<name>name</name>.<name>uriLen</name></name></expr>;</expr_stmt>
<while>while <condition>(<expr>*<name>localPart</name></expr>)</condition> <expr_stmt><expr>*<name>uri</name>++ = *<name>localPart</name>++</expr>;</expr_stmt></while>
<expr_stmt><expr><name>prefix</name> = (<name>XML_Char</name> *)<name><name>tag</name>-&gt;<name>name</name>.<name>prefix</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ns_triplets</name> &amp;&amp; <name>prefix</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>uri</name>++ = <name>namespaceSeparator</name></expr>;</expr_stmt>
<while>while <condition>(<expr>*<name>prefix</name></expr>)</condition> <expr_stmt><expr>*<name>uri</name>++ = *<name>prefix</name>++</expr>;</expr_stmt></while>
}</block></then></if>
<expr_stmt><expr>*<name>uri</name> = <call><name>XML_T</name><argument_list>(<argument><expr>'\0'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>endElementHandler</name><argument_list>(<argument><expr><name>handlerArg</name></expr></argument>, <argument><expr><name><name>tag</name>-&gt;<name>name</name>.<name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>defaultHandler</name></expr>)</condition><then>
<expr_stmt><expr><call><name>reportDefault</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if>
<while>while <condition>(<expr><name><name>tag</name>-&gt;<name>bindings</name></name></expr>)</condition> <block>{
<decl_stmt><decl><type><name>BINDING</name> *</type><name>b</name> <init>= <expr><name><name>tag</name>-&gt;<name>bindings</name></name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>endNamespaceDeclHandler</name></expr>)</condition><then>
<expr_stmt><expr><call><name>endNamespaceDeclHandler</name><argument_list>(<argument><expr><name>handlerArg</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>prefix</name>-&gt;<name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name><name>tag</name>-&gt;<name>bindings</name></name> = <name><name>tag</name>-&gt;<name>bindings</name>-&gt;<name>nextTagBinding</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name>-&gt;<name>nextTagBinding</name></name> = <name>freeBindingList</name></expr>;</expr_stmt>
<expr_stmt><expr><name>freeBindingList</name> = <name>b</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name>-&gt;<name>prefix</name>-&gt;<name>binding</name></name> = <name><name>b</name>-&gt;<name>prevPrefixBinding</name></name></expr>;</expr_stmt>
}</block></while>
<if>if <condition>(<expr><name>tagLevel</name> == 0</expr>)</condition><then>
<return>return <expr><call><name>epilogProcessor</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>next</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>nextPtr</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
}</block></else></if>
<break>break;</break>
</case><case>case <expr><name>XML_TOK_CHAR_REF</name></expr>: <block>{
<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>XmlCharRefNumber</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>n</name> &lt; 0</expr>)</condition><then>
<return>return <expr><name>XML_ERROR_BAD_CHAR_REF</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>characterDataHandler</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>XML_Char</name></type> <name><name>buf</name><index>[<expr><name>XML_ENCODE_MAX</name></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>characterDataHandler</name><argument_list>(<argument><expr><name>handlerArg</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>XmlEncode</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>(<name>ICHAR</name> *)<name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>defaultHandler</name></expr>)</condition><then>
<expr_stmt><expr><call><name>reportDefault</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if>
}</block>
<break>break;</break>
</case><case>case <expr><name>XML_TOK_XML_DECL</name></expr>:
<return>return <expr><name>XML_ERROR_MISPLACED_XML_PI</name></expr>;</return>
</case><case>case <expr><name>XML_TOK_DATA_NEWLINE</name></expr>:
<if>if <condition>(<expr><name>characterDataHandler</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>XML_Char</name></type> <name>c</name> <init>= <expr>0xA</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>characterDataHandler</name><argument_list>(<argument><expr><name>handlerArg</name></expr></argument>, <argument><expr>&amp;<name>c</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>defaultHandler</name></expr>)</condition><then>
<expr_stmt><expr><call><name>reportDefault</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if>
<break>break;</break>
</case><case>case <expr><name>XML_TOK_CDATA_SECT_OPEN</name></expr>: <block>{
<enum>enum <name>XML_Error</name> <name>result</name>;</enum>
<if>if <condition>(<expr><name>startCdataSectionHandler</name></expr>)</condition><then>
<expr_stmt><expr><call><name>startCdataSectionHandler</name><argument_list>(<argument><expr><name>handlerArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
else if (characterDataHandler)
characterDataHandler(handlerArg, dataBuf, 0);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<else>else <if>if <condition>(<expr><name>defaultHandler</name></expr>)</condition><then>
<expr_stmt><expr><call><name>reportDefault</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if>
<expr_stmt><expr><name>result</name> = <call><name>doCdataSection</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr>&amp;<name>next</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>nextPtr</name></expr></argument>, <argument><expr><name>haveMore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> != <name>XML_ERROR_NONE</name></expr>)</condition><then>
<return>return <expr><name>result</name></expr>;</return></then>
<else>else <if>if <condition>(<expr>!<name>next</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>processor</name> = <name>cdataSectionProcessor</name></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></then></if></else></if>
}</block>
<break>break;</break>
</case><case>case <expr><name>XML_TOK_TRAILING_RSQB</name></expr>:
<if>if <condition>(<expr><name>haveMore</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>nextPtr</name> = <name>s</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>characterDataHandler</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>MUST_CONVERT</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>ICHAR</name> *</type><name>dataPtr</name> <init>= <expr>(<name>ICHAR</name> *)<name>dataBuf</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>XmlConvert</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr>&amp;<name>dataPtr</name></expr></argument>, <argument><expr>(<name>ICHAR</name> *)<name>dataBufEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>characterDataHandler</name><argument_list>(<argument><expr><name>handlerArg</name></expr></argument>, <argument><expr><name>dataBuf</name></expr></argument>,
<argument><expr><call>(<name>int</name>)<argument_list>(<argument><expr><name>dataPtr</name> - (<name>ICHAR</name> *)<name>dataBuf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else
<expr_stmt><expr><call><name>characterDataHandler</name><argument_list>(<argument><expr><name>handlerArg</name></expr></argument>,
<argument><expr>(<name>XML_Char</name> *)<name>s</name></expr></argument>,
<argument><expr><call>(<name>int</name>)<argument_list>(<argument><expr>(<name>XML_Char</name> *)<name>end</name> - (<name>XML_Char</name> *)<name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
}</block></then> <else>else <if>if <condition>(<expr><name>defaultHandler</name></expr>)</condition><then>
<expr_stmt><expr><call><name>reportDefault</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if>
<if>if <condition>(<expr><name>startTagLevel</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>eventPP</name> = <name>end</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NO_ELEMENTS</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>tagLevel</name> != <name>startTagLevel</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>eventPP</name> = <name>end</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_ASYNC_ENTITY</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr>*<name>nextPtr</name> = <name>end</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
</case><case>case <expr><name>XML_TOK_DATA_CHARS</name></expr>:
<if>if <condition>(<expr><name>characterDataHandler</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>MUST_CONVERT</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<decl_stmt><decl><type><name>ICHAR</name> *</type><name>dataPtr</name> <init>= <expr>(<name>ICHAR</name> *)<name>dataBuf</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>XmlConvert</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>, <argument><expr>&amp;<name>dataPtr</name></expr></argument>, <argument><expr>(<name>ICHAR</name> *)<name>dataBufEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>eventEndPP</name> = <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>characterDataHandler</name><argument_list>(<argument><expr><name>handlerArg</name></expr></argument>, <argument><expr><name>dataBuf</name></expr></argument>,
<argument><expr><call>(<name>int</name>)<argument_list>(<argument><expr><name>dataPtr</name> - (<name>ICHAR</name> *)<name>dataBuf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>s</name> == <name>next</name></expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr>*<name>eventPP</name> = <name>s</name></expr>;</expr_stmt>
}</block></for>
}</block></then> <else>else
<expr_stmt><expr><call><name>characterDataHandler</name><argument_list>(<argument><expr><name>handlerArg</name></expr></argument>,
<argument><expr>(<name>XML_Char</name> *)<name>s</name></expr></argument>,
<argument><expr><call>(<name>int</name>)<argument_list>(<argument><expr>(<name>XML_Char</name> *)<name>next</name> - (<name>XML_Char</name> *)<name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
}</block></then> <else>else <if>if <condition>(<expr><name>defaultHandler</name></expr>)</condition><then>
<expr_stmt><expr><call><name>reportDefault</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if>
<break>break;</break>
</case><case>case <expr><name>XML_TOK_PI</name></expr>:
<if>if <condition>(<expr>!<call><name>reportProcessingInstruction</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></then></if>
<break>break;</break>
</case><case>case <expr><name>XML_TOK_COMMENT</name></expr>:
<if>if <condition>(<expr>!<call><name>reportComment</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></then></if>
<break>break;</break>
</case><default>default:
<if>if <condition>(<expr><name>defaultHandler</name></expr>)</condition><then>
<expr_stmt><expr><call><name>reportDefault</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<break>break;</break>
</default>}</block></switch>
<expr_stmt><expr>*<name>eventPP</name> = <name>s</name> = <name>next</name></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>ps_parsing</name></expr>)</condition> <block>{
<case>case <expr><name>XML_SUSPENDED</name></expr>:
<expr_stmt><expr>*<name>nextPtr</name> = <name>next</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
</case><case>case <expr><name>XML_FINISHED</name></expr>:
<return>return <expr><name>XML_ERROR_ABORTED</name></expr>;</return>
</case><default>default:
<empty_stmt>;</empty_stmt>
</default>}</block></switch>
}</block></for>
}</block></decl>
<decl>static enum <name>XML_Error</name>
<name>storeAtts</name><argument_list>(<argument><expr><name>XML_Parser</name> <name>parser</name></expr></argument>, <argument><expr>const <name>ENCODING</name> *<name>enc</name></expr></argument>,
<argument><expr>const <name>char</name> *<name>attStr</name></expr></argument>, <argument><expr><name>TAG_NAME</name> *<name>tagNamePtr</name></expr></argument>,
<argument><expr><name>BINDING</name> **<name>bindingsPtr</name></expr></argument>)</argument_list> <block>{
<decl_stmt><decl><type><name>DTD</name> * <specifier>const</specifier></type> <name>dtd</name> <init>= <expr><name>_dtd</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ELEMENT_TYPE</name> *</type><name>elementType</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nDefaultAtts</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> **</type><name>appAtts</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>attIndex</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>prefixLen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Char</name> *</type><name>uri</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nPrefixes</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BINDING</name> *</type><name>binding</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>localPart</name></decl>;</decl_stmt>
<expr_stmt><expr><name>elementType</name> = (<name>ELEMENT_TYPE</name> *)<call><name>lookup</name><argument_list>(<argument><expr>&amp;<name><name>dtd</name>-&gt;<name>elementTypes</name></name></expr></argument>, <argument><expr><name><name>tagNamePtr</name>-&gt;<name>str</name></name></expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>elementType</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>name</name> <init>= <expr><call><name>poolCopyString</name><argument_list>(<argument><expr>&amp;<name><name>dtd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>tagNamePtr</name>-&gt;<name>str</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>name</name></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></then></if>
<expr_stmt><expr><name>elementType</name> = (<name>ELEMENT_TYPE</name> *)<call><name>lookup</name><argument_list>(<argument><expr>&amp;<name><name>dtd</name>-&gt;<name>elementTypes</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ELEMENT_TYPE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>elementType</name></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>ns</name> &amp;&amp; !<call><name>setElementTypePrefix</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>elementType</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></then></if>
}</block></then></if>
<expr_stmt><expr><name>nDefaultAtts</name> = <name><name>elementType</name>-&gt;<name>nDefaultAtts</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> = <call><name>XmlGetAttributes</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>attStr</name></expr></argument>, <argument><expr><name>attsSize</name></expr></argument>, <argument><expr><name>atts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>n</name> + <name>nDefaultAtts</name> &gt; <name>attsSize</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>oldAttsSize</name> <init>= <expr><name>attsSize</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ATTRIBUTE</name> *</type><name>temp</name></decl>;</decl_stmt>
<expr_stmt><expr><name>attsSize</name> = <name>n</name> + <name>nDefaultAtts</name> + <name>INIT_ATTS_SIZE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>temp</name> = (<name>ATTRIBUTE</name> *)<call><name>REALLOC</name><argument_list>(<argument><expr>(<name>void</name> *)<name>atts</name></expr></argument>, <argument><expr><name>attsSize</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>ATTRIBUTE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>temp</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></then></if>
<expr_stmt><expr><name>atts</name> = <name>temp</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>n</name> &gt; <name>oldAttsSize</name></expr>)</condition><then>
<expr_stmt><expr><call><name>XmlGetAttributes</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>attStr</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>atts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></then></if>
<expr_stmt><expr><name>appAtts</name> = (const <name>XML_Char</name> **)<name>atts</name></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>ATTRIBUTE_ID</name> *</type><name>attId</name> <init>= <expr><call><name>getAttributeId</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name><name>atts</name><index>[<expr><name>i</name></expr>]</index></name>.<name>name</name></expr></argument>,
<argument><expr><name><name>atts</name><index>[<expr><name>i</name></expr>]</index></name>.<name>name</name>
+ <call><name>XmlNameLength</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name><name>atts</name><index>[<expr><name>i</name></expr>]</index></name>.<name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>attId</name></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></then></if>
<if>if <condition>(<expr>(<name><name>attId</name>-&gt;<name>name</name></name>)<index>[<expr>-1</expr>]</index></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>enc</name> == <name>encoding</name></expr>)</condition><then>
<expr_stmt><expr><name>eventPtr</name> = <name><name>atts</name><index>[<expr><name>i</name></expr>]</index></name>.<name>name</name></expr>;</expr_stmt></then></if>
<return>return <expr><name>XML_ERROR_DUPLICATE_ATTRIBUTE</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr>(<name><name>attId</name>-&gt;<name>name</name></name>)<index>[<expr>-1</expr>]</index> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name><name>appAtts</name><index>[<expr><name>attIndex</name>++</expr>]</index></name> = <name><name>attId</name>-&gt;<name>name</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name><name>atts</name><index>[<expr><name>i</name></expr>]</index></name>.<name>normalized</name></expr>)</condition><then> <block>{
<enum>enum <name>XML_Error</name> <name>result</name>;</enum>
<decl_stmt><decl><type><name>XML_Bool</name></type> <name>isCdata</name> <init>= <expr><name>XML_TRUE</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>attId</name>-&gt;<name>maybeTokenized</name></name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
<for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name>nDefaultAtts</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
<if>if <condition>(<expr><name>attId</name> == <name><name>elementType</name>-&gt;<name>defaultAtts</name><index>[<expr><name>j</name></expr>]</index></name>.<name>id</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>isCdata</name> = <name><name>elementType</name>-&gt;<name>defaultAtts</name><index>[<expr><name>j</name></expr>]</index></name>.<name>isCdata</name></expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
}</block></for>
}</block></then></if>
<expr_stmt><expr><name>result</name> = <call><name>storeAttributeValue</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>isCdata</name></expr></argument>,
<argument><expr><name><name>atts</name><index>[<expr><name>i</name></expr>]</index></name>.<name>valuePtr</name></expr></argument>, <argument><expr><name><name>atts</name><index>[<expr><name>i</name></expr>]</index></name>.<name>valueEnd</name></expr></argument>,
<argument><expr>&amp;<name>tempPool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name></expr>)</condition><then>
<return>return <expr><name>result</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>appAtts</name><index>[<expr><name>attIndex</name></expr>]</index></name> = <call><name>poolStart</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>poolFinish</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name><name>appAtts</name><index>[<expr><name>attIndex</name></expr>]</index></name> = <call><name>poolStoreString</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name><name>atts</name><index>[<expr><name>i</name></expr>]</index></name>.<name>valuePtr</name></expr></argument>,
<argument><expr><name><name>atts</name><index>[<expr><name>i</name></expr>]</index></name>.<name>valueEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>appAtts</name><index>[<expr><name>attIndex</name></expr>]</index></name> == 0</expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>poolFinish</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<if>if <condition>(<expr><name><name>attId</name>-&gt;<name>prefix</name></name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>attId</name>-&gt;<name>xmlns</name></name></expr>)</condition><then> <block>{
<enum>enum <name>XML_Error</name> <name>result</name> <expr_stmt><expr>= <call><name>addBinding</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name><name>attId</name>-&gt;<name>prefix</name></name></expr></argument>, <argument><expr><name>attId</name></expr></argument>,
<argument><expr><name><name>appAtts</name><index>[<expr><name>attIndex</name></expr>]</index></name></expr></argument>, <argument><expr><name>bindingsPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></enum>
<if>if <condition>(<expr><name>result</name></expr>)</condition><then>
<return>return <expr><name>result</name></expr>;</return></then></if>
<expr_stmt><expr>--<name>attIndex</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>attIndex</name>++</expr>;</expr_stmt>
<expr_stmt><expr><name>nPrefixes</name>++</expr>;</expr_stmt>
<expr_stmt><expr>(<name><name>attId</name>-&gt;<name>name</name></name>)<index>[<expr>-1</expr>]</index> = 2</expr>;</expr_stmt>
}</block></else></if>
}</block></then> <else>else
<expr_stmt><expr><name>attIndex</name>++</expr>;</expr_stmt></else></if>
}</block></for>
<expr_stmt><expr><name>nSpecifiedAtts</name> = <name>attIndex</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>elementType</name>-&gt;<name>idAtt</name></name> &amp;&amp; (<name><name>elementType</name>-&gt;<name>idAtt</name>-&gt;<name>name</name></name>)<index>[<expr>-1</expr>]</index></expr>)</condition><then> <block>{
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>attIndex</name></expr>;</condition> <incr><expr><name>i</name> += 2</expr></incr>)
<if>if <condition>(<expr><name><name>appAtts</name><index>[<expr><name>i</name></expr>]</index></name> == <name><name>elementType</name>-&gt;<name>idAtt</name>-&gt;<name>name</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>idAttIndex</name> = <name>i</name></expr>;</expr_stmt>
<break>break;</break>
}</block></then></if></for>
}</block></then> <else>else
<expr_stmt><expr><name>idAttIndex</name> = -1</expr>;</expr_stmt></else></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>nDefaultAtts</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>DEFAULT_ATTRIBUTE</name> *</type><name>da</name> <init>= <expr><name><name>elementType</name>-&gt;<name>defaultAtts</name></name> + <name>i</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!(<name><name>da</name>-&gt;<name>id</name>-&gt;<name>name</name></name>)<index>[<expr>-1</expr>]</index> &amp;&amp; <name><name>da</name>-&gt;<name>value</name></name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>da</name>-&gt;<name>id</name>-&gt;<name>prefix</name></name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>da</name>-&gt;<name>id</name>-&gt;<name>xmlns</name></name></expr>)</condition><then> <block>{
<enum>enum <name>XML_Error</name> <name>result</name> <expr_stmt><expr>= <call><name>addBinding</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name><name>da</name>-&gt;<name>id</name>-&gt;<name>prefix</name></name></expr></argument>, <argument><expr><name><name>da</name>-&gt;<name>id</name></name></expr></argument>,
<argument><expr><name><name>da</name>-&gt;<name>value</name></name></expr></argument>, <argument><expr><name>bindingsPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></enum>
<if>if <condition>(<expr><name>result</name></expr>)</condition><then>
<return>return <expr><name>result</name></expr>;</return></then></if>
}</block></then> <else>else <block>{
<expr_stmt><expr>(<name><name>da</name>-&gt;<name>id</name>-&gt;<name>name</name></name>)<index>[<expr>-1</expr>]</index> = 2</expr>;</expr_stmt>
<expr_stmt><expr><name>nPrefixes</name>++</expr>;</expr_stmt>
<expr_stmt><expr><name><name>appAtts</name><index>[<expr><name>attIndex</name>++</expr>]</index></name> = <name><name>da</name>-&gt;<name>id</name>-&gt;<name>name</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>appAtts</name><index>[<expr><name>attIndex</name>++</expr>]</index></name> = <name><name>da</name>-&gt;<name>value</name></name></expr>;</expr_stmt>
}</block></else></if>
}</block></then> <else>else <block>{
<expr_stmt><expr>(<name><name>da</name>-&gt;<name>id</name>-&gt;<name>name</name></name>)<index>[<expr>-1</expr>]</index> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name><name>appAtts</name><index>[<expr><name>attIndex</name>++</expr>]</index></name> = <name><name>da</name>-&gt;<name>id</name>-&gt;<name>name</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>appAtts</name><index>[<expr><name>attIndex</name>++</expr>]</index></name> = <name><name>da</name>-&gt;<name>value</name></name></expr>;</expr_stmt>
}</block></else></if>
}</block></then></if>
}</block></for>
<expr_stmt><expr><name><name>appAtts</name><index>[<expr><name>attIndex</name></expr>]</index></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> = 0</expr>;</expr_stmt>
<if>if <condition>(<expr><name>nPrefixes</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>version</name> <init>= <expr><name>nsAttsVersion</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nsAttsSize</name> <init>= <expr>(<name>int</name>)1 &lt;&lt; <name>nsAttsPower</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>(<name>nPrefixes</name> &lt;&lt; 1) &gt;&gt; <name>nsAttsPower</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>NS_ATT</name> *</type><name>temp</name></decl>;</decl_stmt>
<while>while <condition>(<expr><name>nPrefixes</name> &gt;&gt; <name>nsAttsPower</name>++</expr>)</condition><empty_stmt>;</empty_stmt></while>
<if>if <condition>(<expr><name>nsAttsPower</name> &lt; 3</expr>)</condition><then>
<expr_stmt><expr><name>nsAttsPower</name> = 3</expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>nsAttsSize</name> = (<name>int</name>)1 &lt;&lt; <name>nsAttsPower</name></expr>;</expr_stmt>
<expr_stmt><expr><name>temp</name> = (<name>NS_ATT</name> *)<call><name>REALLOC</name><argument_list>(<argument><expr><name>nsAtts</name></expr></argument>, <argument><expr><name>nsAttsSize</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>NS_ATT</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>temp</name></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></then></if>
<expr_stmt><expr><name>nsAtts</name> = <name>temp</name></expr>;</expr_stmt>
<expr_stmt><expr><name>version</name> = 0</expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr>!<name>version</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>version</name> = <name>INIT_ATTS_VERSION</name></expr>;</expr_stmt>
<for>for (<init><expr><name>j</name> = <name>nsAttsSize</name></expr>;</init> <condition><expr><name>j</name> != 0</expr>;</condition> <incr/>)
<expr_stmt><expr><name><name>nsAtts</name><index>[<expr>--<name>j</name></expr>]</index></name>.<name>version</name> = <name>version</name></expr>;</expr_stmt></for>
}</block></then></if>
<expr_stmt><expr><name>nsAttsVersion</name> = --<name>version</name></expr>;</expr_stmt>
<for>for (<init>;</init> <condition><expr><name>i</name> &lt; <name>attIndex</name></expr>;</condition> <incr><expr><name>i</name> += 2</expr></incr>) <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>s</name> <init>= <expr><name><name>appAtts</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>s</name><index>[<expr>-1</expr>]</index></name> == 2</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>ATTRIBUTE_ID</name> *</type><name>id</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>BINDING</name> *</type><name>b</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>uriHash</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<expr_stmt><expr>((<name>XML_Char</name> *)<name>s</name>)<index>[<expr>-1</expr>]</index> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>id</name> = (<name>ATTRIBUTE_ID</name> *)<call><name>lookup</name><argument_list>(<argument><expr>&amp;<name><name>dtd</name>-&gt;<name>attributeIds</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>id</name></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></then></if>
<expr_stmt><expr><name>b</name> = <name><name>id</name>-&gt;<name>prefix</name>-&gt;<name>binding</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>b</name></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_UNBOUND_PREFIX</name></expr>;</return></then></if>
<for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name><name>b</name>-&gt;<name>uriLen</name></name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name></type> <name>c</name> <init>= <expr><name><name>b</name>-&gt;<name>uri</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>poolAppendChar</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></then></if>
<expr_stmt><expr><name>uriHash</name> = <call><name>CHAR_HASH</name><argument_list>(<argument><expr><name>uriHash</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<while>while <condition>(<expr>*<name>s</name>++ != <call><name>XML_T</name><argument_list>(<argument><expr>':'</expr></argument>)</argument_list></call></expr>)</condition>
<empty_stmt>;</empty_stmt></while>
<do>do <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name></type> <name>c</name> <init>= <expr>*<name>s</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>poolAppendChar</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>, <argument><expr>*<name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></then></if>
<expr_stmt><expr><name>uriHash</name> = <call><name>CHAR_HASH</name><argument_list>(<argument><expr><name>uriHash</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block> while <condition>(<expr>*<name>s</name>++</expr>)</condition>;</do>
<block>{
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>step</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>mask</name> <init>= <expr><name>nsAttsSize</name> - 1</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>j</name> = <name>uriHash</name> &amp; <name>mask</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name><name>nsAtts</name><index>[<expr><name>j</name></expr>]</index></name>.<name>version</name> == <name>version</name></expr>)</condition> <block>{
<if>if <condition>(<expr><name>uriHash</name> == <name><name>nsAtts</name><index>[<expr><name>j</name></expr>]</index></name>.<name>hash</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>s1</name> <init>= <expr><call><name>poolStart</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>s2</name> <init>= <expr><name><name>nsAtts</name><index>[<expr><name>j</name></expr>]</index></name>.<name>uriName</name></expr></init></decl>;</decl_stmt>
<for>for (<init>;</init> <condition><expr>*<name>s1</name> == *<name>s2</name> &amp;&amp; *<name>s1</name> != 0</expr>;</condition> <incr><expr><name>s1</name>++</expr>, <expr><name>s2</name>++</expr></incr>)<empty_stmt>;</empty_stmt></for>
<if>if <condition>(<expr>*<name>s1</name> == 0</expr>)</condition><then>
<return>return <expr><name>XML_ERROR_DUPLICATE_ATTRIBUTE</name></expr>;</return></then></if>
}</block></then></if>
<if>if <condition>(<expr>!<name>step</name></expr>)</condition><then>
<expr_stmt><expr><name>step</name> = <call><name>PROBE_STEP</name><argument_list>(<argument><expr><name>uriHash</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>, <argument><expr><name>nsAttsPower</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>j</name> &lt; <name>step</name> ? (<name>j</name> += <name>nsAttsSize</name> - <name>step</name>) : (<name>j</name> -= <name>step</name>)</expr>;</expr_stmt>
}</block></while>
}</block>
<if>if <condition>(<expr><name>ns_triplets</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>tempPool</name>.<name>ptr</name><index>[<expr>-1</expr>]</index></name> = <name>namespaceSeparator</name></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> = <name><name>b</name>-&gt;<name>prefix</name>-&gt;<name>name</name></name></expr>;</expr_stmt>
<do>do <block>{
<if>if <condition>(<expr>!<call><name>poolAppendChar</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>, <argument><expr>*<name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></then></if>
}</block> while <condition>(<expr>*<name>s</name>++</expr>)</condition>;</do>
}</block></then></if>
<expr_stmt><expr><name>s</name> = <call><name>poolStart</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>poolFinish</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>appAtts</name><index>[<expr><name>i</name></expr>]</index></name> = <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>nsAtts</name><index>[<expr><name>j</name></expr>]</index></name>.<name>version</name> = <name>version</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>nsAtts</name><index>[<expr><name>j</name></expr>]</index></name>.<name>hash</name> = <name>uriHash</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>nsAtts</name><index>[<expr><name>j</name></expr>]</index></name>.<name>uriName</name> = <name>s</name></expr>;</expr_stmt>
<if>if <condition>(<expr>!--<name>nPrefixes</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>i</name> += 2</expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
}</block></then> <else>else
<expr_stmt><expr>((<name>XML_Char</name> *)<name>s</name>)<index>[<expr>-1</expr>]</index> = 0</expr>;</expr_stmt></else></if>
}</block></for>
}</block></then></if>
<for>for (<init>;</init> <condition><expr><name>i</name> &lt; <name>attIndex</name></expr>;</condition> <incr><expr><name>i</name> += 2</expr></incr>)
<expr_stmt><expr>(<call>(<name>XML_Char</name> *)<argument_list>(<argument><expr><name><name>appAtts</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call>)<index>[<expr>-1</expr>]</index> = 0</expr>;</expr_stmt></for>
<for>for (<init><expr><name>binding</name> = *<name>bindingsPtr</name></expr>;</init> <condition><expr><name>binding</name></expr>;</condition> <incr><expr><name>binding</name> = <name><name>binding</name>-&gt;<name>nextTagBinding</name></name></expr></incr>)
<expr_stmt><expr><name><name>binding</name>-&gt;<name>attId</name>-&gt;<name>name</name><index>[<expr>-1</expr>]</index></name> = 0</expr>;</expr_stmt></for>
<if>if <condition>(<expr>!<name>ns</name></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return></then></if>
<if>if <condition>(<expr><name><name>elementType</name>-&gt;<name>prefix</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>binding</name> = <name><name>elementType</name>-&gt;<name>prefix</name>-&gt;<name>binding</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>binding</name></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_UNBOUND_PREFIX</name></expr>;</return></then></if>
<expr_stmt><expr><name>localPart</name> = <name><name>tagNamePtr</name>-&gt;<name>str</name></name></expr>;</expr_stmt>
<while>while <condition>(<expr>*<name>localPart</name>++ != <call><name>XML_T</name><argument_list>(<argument><expr>':'</expr></argument>)</argument_list></call></expr>)</condition>
<empty_stmt>;</empty_stmt></while>
}</block></then> <else>else <if>if <condition>(<expr><name><name>dtd</name>-&gt;<name>defaultPrefix</name>.<name>binding</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>binding</name> = <name><name>dtd</name>-&gt;<name>defaultPrefix</name>.<name>binding</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>localPart</name> = <name><name>tagNamePtr</name>-&gt;<name>str</name></name></expr>;</expr_stmt>
}</block></then> <else>else
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return></else></if></else></if>
<expr_stmt><expr><name>prefixLen</name> = 0</expr>;</expr_stmt>
<if>if <condition>(<expr><name>ns_triplets</name> &amp;&amp; <name><name>binding</name>-&gt;<name>prefix</name>-&gt;<name>name</name></name></expr>)</condition><then> <block>{
<for>for (<init>;</init> <condition><expr><name><name>binding</name>-&gt;<name>prefix</name>-&gt;<name>name</name><index>[<expr><name>prefixLen</name>++</expr>]</index></name></expr>;</condition><incr/>)
<empty_stmt>;</empty_stmt></for>
}</block></then></if>
<expr_stmt><expr><name><name>tagNamePtr</name>-&gt;<name>localPart</name></name> = <name>localPart</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tagNamePtr</name>-&gt;<name>uriLen</name></name> = <name><name>binding</name>-&gt;<name>uriLen</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tagNamePtr</name>-&gt;<name>prefix</name></name> = <name><name>binding</name>-&gt;<name>prefix</name>-&gt;<name>name</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tagNamePtr</name>-&gt;<name>prefixLen</name></name> = <name>prefixLen</name></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name><name>localPart</name><index>[<expr><name>i</name>++</expr>]</index></name></expr>;</condition><incr/>)
<empty_stmt>;</empty_stmt></for>
<expr_stmt><expr><name>n</name> = <name>i</name> + <name><name>binding</name>-&gt;<name>uriLen</name></name> + <name>prefixLen</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>n</name> &gt; <name><name>binding</name>-&gt;<name>uriAlloc</name></name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>TAG</name> *</type><name>p</name></decl>;</decl_stmt>
<expr_stmt><expr><name>uri</name> = (<name>XML_Char</name> *)<call><name>MALLOC</name><argument_list>(<argument><expr>(<name>n</name> + <name>EXPAND_SPARE</name>) * <sizeof>sizeof<argument_list>(<argument><expr><name>XML_Char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>uri</name></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>binding</name>-&gt;<name>uriAlloc</name></name> = <name>n</name> + <name>EXPAND_SPARE</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>uri</name></expr></argument>, <argument><expr><name><name>binding</name>-&gt;<name>uri</name></name></expr></argument>, <argument><expr><name><name>binding</name>-&gt;<name>uriLen</name></name> * <sizeof>sizeof<argument_list>(<argument><expr><name>XML_Char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>p</name> = <name>tagStack</name></expr>;</init> <condition><expr><name>p</name></expr>;</condition> <incr><expr><name>p</name> = <name><name>p</name>-&gt;<name>parent</name></name></expr></incr>)
<if>if <condition>(<expr><name><name>p</name>-&gt;<name>name</name>.<name>str</name></name> == <name><name>binding</name>-&gt;<name>uri</name></name></expr>)</condition><then>
<expr_stmt><expr><name><name>p</name>-&gt;<name>name</name>.<name>str</name></name> = <name>uri</name></expr>;</expr_stmt></then></if></for>
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name><name>binding</name>-&gt;<name>uri</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>binding</name>-&gt;<name>uri</name></name> = <name>uri</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>uri</name> = <name><name>binding</name>-&gt;<name>uri</name></name> + <name><name>binding</name>-&gt;<name>uriLen</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>uri</name></expr></argument>, <argument><expr><name>localPart</name></expr></argument>, <argument><expr><name>i</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>XML_Char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>prefixLen</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>uri</name> += <name>i</name> - 1</expr>;</expr_stmt>
<expr_stmt><expr>*<name>uri</name> = <name>namespaceSeparator</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>uri</name> + 1</expr></argument>, <argument><expr><name><name>binding</name>-&gt;<name>prefix</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>prefixLen</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>XML_Char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name><name>tagNamePtr</name>-&gt;<name>str</name></name> = <name><name>binding</name>-&gt;<name>uri</name></name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
}</block></decl>
<decl>static enum <name>XML_Error</name>
<name>addBinding</name><argument_list>(<argument><expr><name>XML_Parser</name> <name>parser</name></expr></argument>, <argument><expr><name>PREFIX</name> *<name>prefix</name></expr></argument>, <argument><expr>const <name>ATTRIBUTE_ID</name> *<name>attId</name></expr></argument>,
<argument><expr>const <name>XML_Char</name> *<name>uri</name></expr></argument>, <argument><expr><name>BINDING</name> **<name>bindingsPtr</name></expr></argument>)</argument_list> <block>{
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>XML_Char</name></type> <name><name>xmlNamespace</name><index>[]</index></name> <init>= <expr><block>{
<expr>'h'</expr>, <expr>'t'</expr>, <expr>'t'</expr>, <expr>'p'</expr>, <expr>':'</expr>, <expr>'/'</expr>, <expr>'/'</expr>,
<expr>'w'</expr>, <expr>'w'</expr>, <expr>'w'</expr>, <expr>'.'</expr>, <expr>'w'</expr>, <expr>'3'</expr>, <expr>'.'</expr>, <expr>'o'</expr>, <expr>'r'</expr>, <expr>'g'</expr>, <expr>'/'</expr>,
<expr>'X'</expr>, <expr>'M'</expr>, <expr>'L'</expr>, <expr>'/'</expr>, <expr>'1'</expr>, <expr>'9'</expr>, <expr>'9'</expr>, <expr>'8'</expr>, <expr>'/'</expr>,
<expr>'n'</expr>, <expr>'a'</expr>, <expr>'m'</expr>, <expr>'e'</expr>, <expr>'s'</expr>, <expr>'p'</expr>, <expr>'a'</expr>, <expr>'c'</expr>, <expr>'e'</expr>, <expr>'\0'</expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>xmlLen</name> <init>=
<expr>(<name>int</name>)<sizeof>sizeof<argument_list>(<argument><expr><name>xmlNamespace</name></expr></argument>)</argument_list></sizeof>/<sizeof>sizeof<argument_list>(<argument><expr><name>XML_Char</name></expr></argument>)</argument_list></sizeof> - 1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>XML_Char</name></type> <name><name>xmlnsNamespace</name><index>[]</index></name> <init>= <expr><block>{
<expr>'h'</expr>, <expr>'t'</expr>, <expr>'t'</expr>, <expr>'p'</expr>, <expr>':'</expr>, <expr>'/'</expr>, <expr>'/'</expr>,
<expr>'w'</expr>, <expr>'w'</expr>, <expr>'w'</expr>, <expr>'.'</expr>, <expr>'w'</expr>, <expr>'3'</expr>, <expr>'.'</expr>, <expr>'o'</expr>, <expr>'r'</expr>, <expr>'g'</expr>, <expr>'/'</expr>,
<expr>'2'</expr>, <expr>'0'</expr>, <expr>'0'</expr>, <expr>'0'</expr>, <expr>'/'</expr>, <expr>'x'</expr>, <expr>'m'</expr>, <expr>'l'</expr>, <expr>'n'</expr>, <expr>'s'</expr>, <expr>'/'</expr>, <expr>'\0'</expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>xmlnsLen</name> <init>=
<expr>(<name>int</name>)<sizeof>sizeof<argument_list>(<argument><expr><name>xmlnsNamespace</name></expr></argument>)</argument_list></sizeof>/<sizeof>sizeof<argument_list>(<argument><expr><name>XML_Char</name></expr></argument>)</argument_list></sizeof> - 1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Bool</name></type> <name>mustBeXML</name> <init>= <expr><name>XML_FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Bool</name></type> <name>isXML</name> <init>= <expr><name>XML_TRUE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Bool</name></type> <name>isXMLNS</name> <init>= <expr><name>XML_TRUE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BINDING</name> *</type><name>b</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
<if>if <condition>(<expr>*<name>uri</name> == <call><name>XML_T</name><argument_list>(<argument><expr>'\0'</expr></argument>)</argument_list></call> &amp;&amp; <name><name>prefix</name>-&gt;<name>name</name></name></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_UNDECLARING_PREFIX</name></expr>;</return></then></if>
<if>if <condition>(<expr><name><name>prefix</name>-&gt;<name>name</name></name>
&amp;&amp; <name><name>prefix</name>-&gt;<name>name</name><index>[<expr>0</expr>]</index></name> == <call><name>XML_T</name><argument_list>(<argument><expr>'x'</expr></argument>)</argument_list></call>
&amp;&amp; <name><name>prefix</name>-&gt;<name>name</name><index>[<expr>1</expr>]</index></name> == <call><name>XML_T</name><argument_list>(<argument><expr>'m'</expr></argument>)</argument_list></call>
&amp;&amp; <name><name>prefix</name>-&gt;<name>name</name><index>[<expr>2</expr>]</index></name> == <call><name>XML_T</name><argument_list>(<argument><expr>'l'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>prefix</name>-&gt;<name>name</name><index>[<expr>3</expr>]</index></name> == <call><name>XML_T</name><argument_list>(<argument><expr>'n'</expr></argument>)</argument_list></call>
&amp;&amp; <name><name>prefix</name>-&gt;<name>name</name><index>[<expr>4</expr>]</index></name> == <call><name>XML_T</name><argument_list>(<argument><expr>'s'</expr></argument>)</argument_list></call>
&amp;&amp; <name><name>prefix</name>-&gt;<name>name</name><index>[<expr>5</expr>]</index></name> == <call><name>XML_T</name><argument_list>(<argument><expr>'\0'</expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_RESERVED_PREFIX_XMLNS</name></expr>;</return></then></if>
<if>if <condition>(<expr><name><name>prefix</name>-&gt;<name>name</name><index>[<expr>3</expr>]</index></name> == <call><name>XML_T</name><argument_list>(<argument><expr>'\0'</expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>mustBeXML</name> = <name>XML_TRUE</name></expr>;</expr_stmt></then></if>
}</block></then></if>
<for>for (<init><expr><name>len</name> = 0</expr>;</init> <condition><expr><name><name>uri</name><index>[<expr><name>len</name></expr>]</index></name></expr>;</condition> <incr><expr><name>len</name>++</expr></incr>) <block>{
<if>if <condition>(<expr><name>isXML</name> &amp;&amp; (<name>len</name> &gt; <name>xmlLen</name> || <name><name>uri</name><index>[<expr><name>len</name></expr>]</index></name> != <name><name>xmlNamespace</name><index>[<expr><name>len</name></expr>]</index></name>)</expr>)</condition><then>
<expr_stmt><expr><name>isXML</name> = <name>XML_FALSE</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr>!<name>mustBeXML</name> &amp;&amp; <name>isXMLNS</name>
&amp;&amp; (<name>len</name> &gt; <name>xmlnsLen</name> || <name><name>uri</name><index>[<expr><name>len</name></expr>]</index></name> != <name><name>xmlnsNamespace</name><index>[<expr><name>len</name></expr>]</index></name>)</expr>)</condition><then>
<expr_stmt><expr><name>isXMLNS</name> = <name>XML_FALSE</name></expr>;</expr_stmt></then></if>
}</block></for>
<expr_stmt><expr><name>isXML</name> = <name>isXML</name> &amp;&amp; <name>len</name> == <name>xmlLen</name></expr>;</expr_stmt>
<expr_stmt><expr><name>isXMLNS</name> = <name>isXMLNS</name> &amp;&amp; <name>len</name> == <name>xmlnsLen</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>mustBeXML</name> != <name>isXML</name></expr>)</condition><then>
<return>return <expr><name>mustBeXML</name> ? <name>XML_ERROR_RESERVED_PREFIX_XML</name>
: <name>XML_ERROR_RESERVED_NAMESPACE_URI</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>isXMLNS</name></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_RESERVED_NAMESPACE_URI</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>namespaceSeparator</name></expr>)</condition><then>
<expr_stmt><expr><name>len</name>++</expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>freeBindingList</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>b</name> = <name>freeBindingList</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>len</name> &gt; <name><name>b</name>-&gt;<name>uriAlloc</name></name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>XML_Char</name> *</type><name>temp</name> <init>= <expr>(<name>XML_Char</name> *)<call><name>REALLOC</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>uri</name></name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>XML_Char</name></expr></argument>)</argument_list></sizeof> * (<name>len</name> + <name>EXPAND_SPARE</name>)</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>temp</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>b</name>-&gt;<name>uri</name></name> = <name>temp</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name>-&gt;<name>uriAlloc</name></name> = <name>len</name> + <name>EXPAND_SPARE</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>freeBindingList</name> = <name><name>b</name>-&gt;<name>nextTagBinding</name></name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>b</name> = (<name>BINDING</name> *)<call><name>MALLOC</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>BINDING</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>b</name></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>b</name>-&gt;<name>uri</name></name> = (<name>XML_Char</name> *)<call><name>MALLOC</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>XML_Char</name></expr></argument>)</argument_list></sizeof> * (<name>len</name> + <name>EXPAND_SPARE</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name><name>b</name>-&gt;<name>uri</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>FREE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>b</name>-&gt;<name>uriAlloc</name></name> = <name>len</name> + <name>EXPAND_SPARE</name></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><name><name>b</name>-&gt;<name>uriLen</name></name> = <name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>uri</name></name></expr></argument>, <argument><expr><name>uri</name></expr></argument>, <argument><expr><name>len</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>XML_Char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>namespaceSeparator</name></expr>)</condition><then>
<expr_stmt><expr><name><name>b</name>-&gt;<name>uri</name><index>[<expr><name>len</name> - 1</expr>]</index></name> = <name>namespaceSeparator</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name><name>b</name>-&gt;<name>prefix</name></name> = <name>prefix</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name>-&gt;<name>attId</name></name> = <name>attId</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name>-&gt;<name>prevPrefixBinding</name></name> = <name><name>prefix</name>-&gt;<name>binding</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr>*<name>uri</name> == <call><name>XML_T</name><argument_list>(<argument><expr>'\0'</expr></argument>)</argument_list></call> &amp;&amp; <name>prefix</name> == &amp;<name><name>_dtd</name>-&gt;<name>defaultPrefix</name></name></expr>)</condition><then>
<expr_stmt><expr><name><name>prefix</name>-&gt;<name>binding</name></name> = <name>NULL</name></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name><name>prefix</name>-&gt;<name>binding</name></name> = <name>b</name></expr>;</expr_stmt></else></if>
<expr_stmt><expr><name><name>b</name>-&gt;<name>nextTagBinding</name></name> = *<name>bindingsPtr</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>bindingsPtr</name> = <name>b</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>attId</name> &amp;&amp; <name>startNamespaceDeclHandler</name></expr>)</condition><then>
<expr_stmt><expr><call><name>startNamespaceDeclHandler</name><argument_list>(<argument><expr><name>handlerArg</name></expr></argument>, <argument><expr><name><name>prefix</name>-&gt;<name>name</name></name></expr></argument>,
<argument><expr><name><name>prefix</name>-&gt;<name>binding</name></name> ? <name>uri</name> : 0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
}</block></decl>
<decl>static enum <name>XML_Error</name> <name>PTRCALL</name>
<name>cdataSectionProcessor</name><argument_list>(<argument><expr><name>XML_Parser</name> <name>parser</name></expr></argument>,
<argument><expr>const <name>char</name> *<name>start</name></expr></argument>,
<argument><expr>const <name>char</name> *<name>end</name></expr></argument>,
<argument><expr>const <name>char</name> **<name>endPtr</name></expr></argument>)</argument_list> <block>{
<enum>enum <name>XML_Error</name> <name>result</name> <expr_stmt><expr>= <call><name>doCdataSection</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>, <argument><expr>&amp;<name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>,
<argument><expr><name>endPtr</name></expr></argument>, <argument><expr>(<name>XML_Bool</name>)!<name>ps_finalBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></enum>
<if>if <condition>(<expr><name>result</name> != <name>XML_ERROR_NONE</name></expr>)</condition><then>
<return>return <expr><name>result</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>start</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>parentParser</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>processor</name> = <name>externalEntityContentProcessor</name></expr>;</expr_stmt>
<return>return <expr><call><name>externalEntityContentProcessor</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>endPtr</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>processor</name> = <name>contentProcessor</name></expr>;</expr_stmt>
<return>return <expr><call><name>contentProcessor</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>endPtr</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></else></if>
}</block></then></if>
<return>return <expr><name>result</name></expr>;</return>
}</block></decl>
<decl>static enum <name>XML_Error</name>
<name>doCdataSection</name><argument_list>(<argument><expr><name>XML_Parser</name> <name>parser</name></expr></argument>,
<argument><expr>const <name>ENCODING</name> *<name>enc</name></expr></argument>,
<argument><expr>const <name>char</name> **<name>startPtr</name></expr></argument>,
<argument><expr>const <name>char</name> *<name>end</name></expr></argument>,
<argument><expr>const <name>char</name> **<name>nextPtr</name></expr></argument>,
<argument><expr><name>XML_Bool</name> <name>haveMore</name></expr></argument>)</argument_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name> <init>= <expr>*<name>startPtr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> **</type><name>eventPP</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> **</type><name>eventEndPP</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>enc</name> == <name>encoding</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>eventPP</name> = &amp;<name>eventPtr</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>eventPP</name> = <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><name>eventEndPP</name> = &amp;<name>eventEndPtr</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>eventPP</name> = &amp;(<name><name>openInternalEntities</name>-&gt;<name>internalEventPtr</name></name>)</expr>;</expr_stmt>
<expr_stmt><expr><name>eventEndPP</name> = &amp;(<name><name>openInternalEntities</name>-&gt;<name>internalEventEndPtr</name></name>)</expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr>*<name>eventPP</name> = <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>startPtr</name> = <name>NULL</name></expr>;</expr_stmt>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>next</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tok</name> <init>= <expr><call><name>XmlCdataSectionTok</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr>&amp;<name>next</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr>*<name>eventEndPP</name> = <name>next</name></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>tok</name></expr>)</condition> <block>{
<case>case <expr><name>XML_TOK_CDATA_SECT_CLOSE</name></expr>:
<if>if <condition>(<expr><name>endCdataSectionHandler</name></expr>)</condition><then>
<expr_stmt><expr><call><name>endCdataSectionHandler</name><argument_list>(<argument><expr><name>handlerArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
else if (characterDataHandler)
characterDataHandler(handlerArg, dataBuf, 0);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<else>else <if>if <condition>(<expr><name>defaultHandler</name></expr>)</condition><then>
<expr_stmt><expr><call><name>reportDefault</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if>
<expr_stmt><expr>*<name>startPtr</name> = <name>next</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>nextPtr</name> = <name>next</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ps_parsing</name> == <name>XML_FINISHED</name></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_ABORTED</name></expr>;</return></then>
<else>else
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return></else></if>
</case><case>case <expr><name>XML_TOK_DATA_NEWLINE</name></expr>:
<if>if <condition>(<expr><name>characterDataHandler</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>XML_Char</name></type> <name>c</name> <init>= <expr>0xA</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>characterDataHandler</name><argument_list>(<argument><expr><name>handlerArg</name></expr></argument>, <argument><expr>&amp;<name>c</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>defaultHandler</name></expr>)</condition><then>
<expr_stmt><expr><call><name>reportDefault</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if>
<break>break;</break>
</case><case>case <expr><name>XML_TOK_DATA_CHARS</name></expr>:
<if>if <condition>(<expr><name>characterDataHandler</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>MUST_CONVERT</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<decl_stmt><decl><type><name>ICHAR</name> *</type><name>dataPtr</name> <init>= <expr>(<name>ICHAR</name> *)<name>dataBuf</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>XmlConvert</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>, <argument><expr>&amp;<name>dataPtr</name></expr></argument>, <argument><expr>(<name>ICHAR</name> *)<name>dataBufEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>eventEndPP</name> = <name>next</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>characterDataHandler</name><argument_list>(<argument><expr><name>handlerArg</name></expr></argument>, <argument><expr><name>dataBuf</name></expr></argument>,
<argument><expr><call>(<name>int</name>)<argument_list>(<argument><expr><name>dataPtr</name> - (<name>ICHAR</name> *)<name>dataBuf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>s</name> == <name>next</name></expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr>*<name>eventPP</name> = <name>s</name></expr>;</expr_stmt>
}</block></for>
}</block></then> <else>else
<expr_stmt><expr><call><name>characterDataHandler</name><argument_list>(<argument><expr><name>handlerArg</name></expr></argument>,
<argument><expr>(<name>XML_Char</name> *)<name>s</name></expr></argument>,
<argument><expr><call>(<name>int</name>)<argument_list>(<argument><expr>(<name>XML_Char</name> *)<name>next</name> - (<name>XML_Char</name> *)<name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
}</block></then> <else>else <if>if <condition>(<expr><name>defaultHandler</name></expr>)</condition><then>
<expr_stmt><expr><call><name>reportDefault</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if>
<break>break;</break>
</case><case>case <expr><name>XML_TOK_INVALID</name></expr>:
<expr_stmt><expr>*<name>eventPP</name> = <name>next</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_INVALID_TOKEN</name></expr>;</return>
</case><case>case <expr><name>XML_TOK_PARTIAL_CHAR</name></expr>:
<if>if <condition>(<expr><name>haveMore</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>nextPtr</name> = <name>s</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
}</block></then></if>
<return>return <expr><name>XML_ERROR_PARTIAL_CHAR</name></expr>;</return>
</case><case>case <expr><name>XML_TOK_PARTIAL</name></expr>:
</case><case>case <expr><name>XML_TOK_NONE</name></expr>:
<if>if <condition>(<expr><name>haveMore</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>nextPtr</name> = <name>s</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
}</block></then></if>
<return>return <expr><name>XML_ERROR_UNCLOSED_CDATA_SECTION</name></expr>;</return>
</case><default>default:
<expr_stmt><expr>*<name>eventPP</name> = <name>next</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_UNEXPECTED_STATE</name></expr>;</return>
</default>}</block></switch>
<expr_stmt><expr>*<name>eventPP</name> = <name>s</name> = <name>next</name></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>ps_parsing</name></expr>)</condition> <block>{
<case>case <expr><name>XML_SUSPENDED</name></expr>:
<expr_stmt><expr>*<name>nextPtr</name> = <name>next</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
</case><case>case <expr><name>XML_FINISHED</name></expr>:
<return>return <expr><name>XML_ERROR_ABORTED</name></expr>;</return>
</case><default>default:
<empty_stmt>;</empty_stmt>
</default>}</block></switch>
}</block></for>
}</block></decl>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl>static enum <name>XML_Error</name> <name>PTRCALL</name>
<name>ignoreSectionProcessor</name><argument_list>(<argument><expr><name>XML_Parser</name> <name>parser</name></expr></argument>,
<argument><expr>const <name>char</name> *<name>start</name></expr></argument>,
<argument><expr>const <name>char</name> *<name>end</name></expr></argument>,
<argument><expr>const <name>char</name> **<name>endPtr</name></expr></argument>)</argument_list> <block>{
<enum>enum <name>XML_Error</name> <name>result</name> <expr_stmt><expr>= <call><name>doIgnoreSection</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>, <argument><expr>&amp;<name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>,
<argument><expr><name>endPtr</name></expr></argument>, <argument><expr>(<name>XML_Bool</name>)!<name>ps_finalBuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></enum>
<if>if <condition>(<expr><name>result</name> != <name>XML_ERROR_NONE</name></expr>)</condition><then>
<return>return <expr><name>result</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>start</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>processor</name> = <name>prologProcessor</name></expr>;</expr_stmt>
<return>return <expr><call><name>prologProcessor</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>endPtr</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<return>return <expr><name>result</name></expr>;</return>
}</block></decl>
<decl>static enum <name>XML_Error</name>
<name>doIgnoreSection</name><argument_list>(<argument><expr><name>XML_Parser</name> <name>parser</name></expr></argument>,
<argument><expr>const <name>ENCODING</name> *<name>enc</name></expr></argument>,
<argument><expr>const <name>char</name> **<name>startPtr</name></expr></argument>,
<argument><expr>const <name>char</name> *<name>end</name></expr></argument>,
<argument><expr>const <name>char</name> **<name>nextPtr</name></expr></argument>,
<argument><expr><name>XML_Bool</name> <name>haveMore</name></expr></argument>)</argument_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>next</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tok</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name> <init>= <expr>*<name>startPtr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> **</type><name>eventPP</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> **</type><name>eventEndPP</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>enc</name> == <name>encoding</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>eventPP</name> = &amp;<name>eventPtr</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>eventPP</name> = <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><name>eventEndPP</name> = &amp;<name>eventEndPtr</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>eventPP</name> = &amp;(<name><name>openInternalEntities</name>-&gt;<name>internalEventPtr</name></name>)</expr>;</expr_stmt>
<expr_stmt><expr><name>eventEndPP</name> = &amp;(<name><name>openInternalEntities</name>-&gt;<name>internalEventEndPtr</name></name>)</expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr>*<name>eventPP</name> = <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>startPtr</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>tok</name> = <call><name>XmlIgnoreSectionTok</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr>&amp;<name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>eventEndPP</name> = <name>next</name></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>tok</name></expr>)</condition> <block>{
<case>case <expr><name>XML_TOK_IGNORE_SECT</name></expr>:
<if>if <condition>(<expr><name>defaultHandler</name></expr>)</condition><then>
<expr_stmt><expr><call><name>reportDefault</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr>*<name>startPtr</name> = <name>next</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>nextPtr</name> = <name>next</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ps_parsing</name> == <name>XML_FINISHED</name></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_ABORTED</name></expr>;</return></then>
<else>else
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return></else></if>
</case><case>case <expr><name>XML_TOK_INVALID</name></expr>:
<expr_stmt><expr>*<name>eventPP</name> = <name>next</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_INVALID_TOKEN</name></expr>;</return>
</case><case>case <expr><name>XML_TOK_PARTIAL_CHAR</name></expr>:
<if>if <condition>(<expr><name>haveMore</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>nextPtr</name> = <name>s</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
}</block></then></if>
<return>return <expr><name>XML_ERROR_PARTIAL_CHAR</name></expr>;</return>
</case><case>case <expr><name>XML_TOK_PARTIAL</name></expr>:
</case><case>case <expr><name>XML_TOK_NONE</name></expr>:
<if>if <condition>(<expr><name>haveMore</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>nextPtr</name> = <name>s</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
}</block></then></if>
<return>return <expr><name>XML_ERROR_SYNTAX</name></expr>;</return>
</case><default>default:
<expr_stmt><expr>*<name>eventPP</name> = <name>next</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_UNEXPECTED_STATE</name></expr>;</return>
</default>}</block></switch>
}</block></decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl>static enum <name>XML_Error</name>
<name>initializeEncoding</name><argument_list>(<argument><expr><name>XML_Parser</name> <name>parser</name></expr></argument>)</argument_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>char</name></type> <name><name>encodingBuf</name><index>[<expr>128</expr>]</index></name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>protocolEncodingName</name></expr>)</condition><then>
<expr_stmt><expr><name>s</name> = <name>NULL</name></expr>;</expr_stmt></then>
<else>else <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name><name>protocolEncodingName</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<if>if <condition>(<expr><name>i</name> == <sizeof>sizeof<argument_list>(<argument><expr><name>encodingBuf</name></expr></argument>)</argument_list></sizeof> - 1
|| (<name><name>protocolEncodingName</name><index>[<expr><name>i</name></expr>]</index></name> &amp; ~0x7f) != 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>encodingBuf</name><index>[<expr>0</expr>]</index></name> = '\0'</expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
<expr_stmt><expr><name><name>encodingBuf</name><index>[<expr><name>i</name></expr>]</index></name> = (<name>char</name>)<name><name>protocolEncodingName</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><name><name>encodingBuf</name><index>[<expr><name>i</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> = <name>encodingBuf</name></expr>;</expr_stmt>
}</block></else></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>s</name> = <name>protocolEncodingName</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr>(<name>ns</name> ? <name>XmlInitEncodingNS</name> : <name>XmlInitEncoding</name>)(&amp;<name>initEncoding</name>, &amp;<name>encoding</name>, <name>s</name>)</expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return></then></if>
<return>return <expr><call><name>handleUnknownEncoding</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>protocolEncodingName</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></decl>
<decl>static enum <name>XML_Error</name>
<name>processXmlDecl</name><argument_list>(<argument><expr><name>XML_Parser</name> <name>parser</name></expr></argument>, <argument><expr><name>int</name> <name>isGeneralTextEntity</name></expr></argument>,
<argument><expr>const <name>char</name> *<name>s</name></expr></argument>, <argument><expr>const <name>char</name> *<name>next</name></expr></argument>)</argument_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>encodingName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>storedEncName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>newEncoding</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>version</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>versionend</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>storedversion</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>standalone</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!(<name>ns</name>
? <name>XmlParseXmlDeclNS</name>
: <name>XmlParseXmlDecl</name>)(<name>isGeneralTextEntity</name>,
<name>encoding</name>,
<name>s</name>,
<name>next</name>,
&amp;<name>eventPtr</name>,
&amp;<name>version</name>,
&amp;<name>versionend</name>,
&amp;<name>encodingName</name>,
&amp;<name>newEncoding</name>,
&amp;<name>standalone</name>)</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>isGeneralTextEntity</name></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_TEXT_DECL</name></expr>;</return></then>
<else>else
<return>return <expr><name>XML_ERROR_XML_DECL</name></expr>;</return></else></if>
}</block></then></if>
<if>if <condition>(<expr>!<name>isGeneralTextEntity</name> &amp;&amp; <name>standalone</name> == 1</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>_dtd</name>-&gt;<name>standalone</name></name> = <name>XML_TRUE</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>paramEntityParsing</name> == <name>XML_PARAM_ENTITY_PARSING_UNLESS_STANDALONE</name></expr>)</condition><then>
<expr_stmt><expr><name>paramEntityParsing</name> = <name>XML_PARAM_ENTITY_PARSING_NEVER</name></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></then></if>
<if>if <condition>(<expr><name>xmlDeclHandler</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>encodingName</name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>storedEncName</name> = <call><name>poolStoreString</name><argument_list>(<argument><expr>&amp;<name>temp2Pool</name></expr></argument>,
<argument><expr><name>encoding</name></expr></argument>,
<argument><expr><name>encodingName</name></expr></argument>,
<argument><expr><name>encodingName</name>
+ <call><name>XmlNameLength</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>encodingName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>storedEncName</name></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>poolFinish</name><argument_list>(<argument><expr>&amp;<name>temp2Pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>version</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>storedversion</name> = <call><name>poolStoreString</name><argument_list>(<argument><expr>&amp;<name>temp2Pool</name></expr></argument>,
<argument><expr><name>encoding</name></expr></argument>,
<argument><expr><name>version</name></expr></argument>,
<argument><expr><name>versionend</name> - <name><name>encoding</name>-&gt;<name>minBytesPerChar</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>storedversion</name></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></then></if>
}</block></then></if>
<expr_stmt><expr><call><name>xmlDeclHandler</name><argument_list>(<argument><expr><name>handlerArg</name></expr></argument>, <argument><expr><name>storedversion</name></expr></argument>, <argument><expr><name>storedEncName</name></expr></argument>, <argument><expr><name>standalone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>defaultHandler</name></expr>)</condition><then>
<expr_stmt><expr><call><name>reportDefault</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if>
<if>if <condition>(<expr><name>protocolEncodingName</name> == <name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>newEncoding</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>newEncoding</name>-&gt;<name>minBytesPerChar</name></name> != <name><name>encoding</name>-&gt;<name>minBytesPerChar</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>eventPtr</name> = <name>encodingName</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_INCORRECT_ENCODING</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>encoding</name> = <name>newEncoding</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>encodingName</name></expr>)</condition><then> <block>{
<enum>enum <name>XML_Error</name> <name>result</name>;</enum>
<if>if <condition>(<expr>!<name>storedEncName</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>storedEncName</name> = <call><name>poolStoreString</name><argument_list>(
<argument><expr>&amp;<name>temp2Pool</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>encodingName</name></expr></argument>,
<argument><expr><name>encodingName</name> + <call><name>XmlNameLength</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>encodingName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>storedEncName</name></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></then></if>
}</block></then></if>
<expr_stmt><expr><name>result</name> = <call><name>handleUnknownEncoding</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>storedEncName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>poolClear</name><argument_list>(<argument><expr>&amp;<name>temp2Pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> == <name>XML_ERROR_UNKNOWN_ENCODING</name></expr>)</condition><then>
<expr_stmt><expr><name>eventPtr</name> = <name>encodingName</name></expr>;</expr_stmt></then></if>
<return>return <expr><name>result</name></expr>;</return>
}</block></then></if></else></if>
}</block></then></if>
<if>if <condition>(<expr><name>storedEncName</name> || <name>storedversion</name></expr>)</condition><then>
<expr_stmt><expr><call><name>poolClear</name><argument_list>(<argument><expr>&amp;<name>temp2Pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
}</block></decl>
<decl>static enum <name>XML_Error</name>
<name>handleUnknownEncoding</name><argument_list>(<argument><expr><name>XML_Parser</name> <name>parser</name></expr></argument>, <argument><expr>const <name>XML_Char</name> *<name>encodingName</name></expr></argument>)</argument_list> <block>{
<if>if <condition>(<expr><name>unknownEncodingHandler</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>XML_Encoding</name></type> <name>info</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; 256</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
<expr_stmt><expr><name><name>info</name>.<name>map</name><index>[<expr><name>i</name></expr>]</index></name> = -1</expr>;</expr_stmt></for>
<expr_stmt><expr><name><name>info</name>.<name>convert</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>info</name>.<name>data</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>info</name>.<name>release</name></name> = <name>NULL</name></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>unknownEncodingHandler</name><argument_list>(<argument><expr><name>unknownEncodingHandlerData</name></expr></argument>, <argument><expr><name>encodingName</name></expr></argument>,
<argument><expr>&amp;<name>info</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>ENCODING</name> *</type><name>enc</name></decl>;</decl_stmt>
<expr_stmt><expr><name>unknownEncodingMem</name> = <call><name>MALLOC</name><argument_list>(<argument><expr><call><name>XmlSizeOfUnknownEncoding</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>unknownEncodingMem</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>info</name>.<name>release</name></name></expr>)</condition><then>
<expr_stmt><expr><call><name><name>info</name>.<name>release</name></name><argument_list>(<argument><expr><name><name>info</name>.<name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>enc</name> = (<name>ns</name>
? <name>XmlInitUnknownEncodingNS</name>
: <name>XmlInitUnknownEncoding</name>)(<name>unknownEncodingMem</name>,
<name><name>info</name>.<name>map</name></name>,
<name><name>info</name>.<name>convert</name></name>,
<name><name>info</name>.<name>data</name></name>)</expr>;</expr_stmt>
<if>if <condition>(<expr><name>enc</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>unknownEncodingData</name> = <name><name>info</name>.<name>data</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>unknownEncodingRelease</name> = <name><name>info</name>.<name>release</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>encoding</name> = <name>enc</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
}</block></then></if>
}</block></then></if>
<if>if <condition>(<expr><name><name>info</name>.<name>release</name></name> != <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name><name>info</name>.<name>release</name></name><argument_list>(<argument><expr><name><name>info</name>.<name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></then></if>
<return>return <expr><name>XML_ERROR_UNKNOWN_ENCODING</name></expr>;</return>
}</block></decl>
<decl>static enum <name>XML_Error</name> <name>PTRCALL</name>
<name>prologInitProcessor</name><argument_list>(<argument><expr><name>XML_Parser</name> <name>parser</name></expr></argument>,
<argument><expr>const <name>char</name> *<name>s</name></expr></argument>,
<argument><expr>const <name>char</name> *<name>end</name></expr></argument>,
<argument><expr>const <name>char</name> **<name>nextPtr</name></expr></argument>)</argument_list> <block>{
<enum>enum <name>XML_Error</name> <name>result</name> <expr_stmt><expr>= <call><name>initializeEncoding</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></enum>
<if>if <condition>(<expr><name>result</name> != <name>XML_ERROR_NONE</name></expr>)</condition><then>
<return>return <expr><name>result</name></expr>;</return></then></if>
<expr_stmt><expr><name>processor</name> = <name>prologProcessor</name></expr>;</expr_stmt>
<return>return <expr><call><name>prologProcessor</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>nextPtr</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></decl>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl>static enum <name>XML_Error</name> <name>PTRCALL</name>
<name>externalParEntInitProcessor</name><argument_list>(<argument><expr><name>XML_Parser</name> <name>parser</name></expr></argument>,
<argument><expr>const <name>char</name> *<name>s</name></expr></argument>,
<argument><expr>const <name>char</name> *<name>end</name></expr></argument>,
<argument><expr>const <name>char</name> **<name>nextPtr</name></expr></argument>)</argument_list> <block>{
<enum>enum <name>XML_Error</name> <name>result</name> <expr_stmt><expr>= <call><name>initializeEncoding</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></enum>
<if>if <condition>(<expr><name>result</name> != <name>XML_ERROR_NONE</name></expr>)</condition><then>
<return>return <expr><name>result</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>_dtd</name>-&gt;<name>paramEntityRead</name></name> = <name>XML_TRUE</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>prologState</name>.<name>inEntityValue</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>processor</name> = <name>entityValueInitProcessor</name></expr>;</expr_stmt>
<return>return <expr><call><name>entityValueInitProcessor</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>nextPtr</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>processor</name> = <name>externalParEntProcessor</name></expr>;</expr_stmt>
<return>return <expr><call><name>externalParEntProcessor</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>nextPtr</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></else></if>
}</block></decl>
<decl>static enum <name>XML_Error</name> <name>PTRCALL</name>
<name>entityValueInitProcessor</name><argument_list>(<argument><expr><name>XML_Parser</name> <name>parser</name></expr></argument>,
<argument><expr>const <name>char</name> *<name>s</name></expr></argument>,
<argument><expr>const <name>char</name> *<name>end</name></expr></argument>,
<argument><expr>const <name>char</name> **<name>nextPtr</name></expr></argument>)</argument_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>tok</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>start</name> <init>= <expr><name>s</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>next</name> <init>= <expr><name>start</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>eventPtr</name> = <name>start</name></expr>;</expr_stmt>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<expr_stmt><expr><name>tok</name> = <call><name>XmlPrologTok</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr>&amp;<name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>eventEndPtr</name> = <name>next</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>tok</name> &lt;= 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<name>ps_finalBuffer</name> &amp;&amp; <name>tok</name> != <name>XML_TOK_INVALID</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>nextPtr</name> = <name>s</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
}</block></then></if>
<switch>switch <condition>(<expr><name>tok</name></expr>)</condition> <block>{
<case>case <expr><name>XML_TOK_INVALID</name></expr>:
<return>return <expr><name>XML_ERROR_INVALID_TOKEN</name></expr>;</return>
</case><case>case <expr><name>XML_TOK_PARTIAL</name></expr>:
<return>return <expr><name>XML_ERROR_UNCLOSED_TOKEN</name></expr>;</return>
</case><case>case <expr><name>XML_TOK_PARTIAL_CHAR</name></expr>:
<return>return <expr><name>XML_ERROR_PARTIAL_CHAR</name></expr>;</return>
</case><case>case <expr><name>XML_TOK_NONE</name></expr>:
</case><default>default:
<break>break;</break>
</default>}</block></switch>
<return>return <expr><call><name>storeEntityValue</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><name>tok</name> == <name>XML_TOK_XML_DECL</name></expr>)</condition><then> <block>{
<enum>enum <name>XML_Error</name> <name>result</name>;</enum>
<expr_stmt><expr><name>result</name> = <call><name>processXmlDecl</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> != <name>XML_ERROR_NONE</name></expr>)</condition><then>
<return>return <expr><name>result</name></expr>;</return></then></if>
<switch>switch <condition>(<expr><name>ps_parsing</name></expr>)</condition> <block>{
<case>case <expr><name>XML_SUSPENDED</name></expr>:
<expr_stmt><expr>*<name>nextPtr</name> = <name>next</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
</case><case>case <expr><name>XML_FINISHED</name></expr>:
<return>return <expr><name>XML_ERROR_ABORTED</name></expr>;</return>
</case><default>default:
<expr_stmt><expr>*<name>nextPtr</name> = <name>next</name></expr>;</expr_stmt>
</default>}</block></switch>
<expr_stmt><expr><name>processor</name> = <name>entityValueProcessor</name></expr>;</expr_stmt>
<return>return <expr><call><name>entityValueProcessor</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>next</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>nextPtr</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then>
<else>else <if>if <condition>(<expr><name>tok</name> == <name>XML_TOK_BOM</name> &amp;&amp; <name>next</name> == <name>end</name> &amp;&amp; !<name>ps_finalBuffer</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>nextPtr</name> = <name>next</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
}</block></then></if></else></if></else></if>
<expr_stmt><expr><name>start</name> = <name>next</name></expr>;</expr_stmt>
<expr_stmt><expr><name>eventPtr</name> = <name>start</name></expr>;</expr_stmt>
}</block></for>
}</block></decl>
<decl>static enum <name>XML_Error</name> <name>PTRCALL</name>
<name>externalParEntProcessor</name><argument_list>(<argument><expr><name>XML_Parser</name> <name>parser</name></expr></argument>,
<argument><expr>const <name>char</name> *<name>s</name></expr></argument>,
<argument><expr>const <name>char</name> *<name>end</name></expr></argument>,
<argument><expr>const <name>char</name> **<name>nextPtr</name></expr></argument>)</argument_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>next</name> <init>= <expr><name>s</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tok</name></decl>;</decl_stmt>
<expr_stmt><expr><name>tok</name> = <call><name>XmlPrologTok</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr>&amp;<name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>tok</name> &lt;= 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<name>ps_finalBuffer</name> &amp;&amp; <name>tok</name> != <name>XML_TOK_INVALID</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>nextPtr</name> = <name>s</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
}</block></then></if>
<switch>switch <condition>(<expr><name>tok</name></expr>)</condition> <block>{
<case>case <expr><name>XML_TOK_INVALID</name></expr>:
<return>return <expr><name>XML_ERROR_INVALID_TOKEN</name></expr>;</return>
</case><case>case <expr><name>XML_TOK_PARTIAL</name></expr>:
<return>return <expr><name>XML_ERROR_UNCLOSED_TOKEN</name></expr>;</return>
</case><case>case <expr><name>XML_TOK_PARTIAL_CHAR</name></expr>:
<return>return <expr><name>XML_ERROR_PARTIAL_CHAR</name></expr>;</return>
</case><case>case <expr><name>XML_TOK_NONE</name></expr>:
</case><default>default:
<break>break;</break>
</default>}</block></switch>
}</block></then>
<else>else <if>if <condition>(<expr><name>tok</name> == <name>XML_TOK_BOM</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>s</name> = <name>next</name></expr>;</expr_stmt>
<expr_stmt><expr><name>tok</name> = <call><name>XmlPrologTok</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr>&amp;<name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if></else></if>
<expr_stmt><expr><name>processor</name> = <name>prologProcessor</name></expr>;</expr_stmt>
<return>return <expr><call><name>doProlog</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>tok</name></expr></argument>, <argument><expr><name>next</name></expr></argument>,
<argument><expr><name>nextPtr</name></expr></argument>, <argument><expr>(<name>XML_Bool</name>)!<name>ps_finalBuffer</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></decl>
<decl>static enum <name>XML_Error</name> <name>PTRCALL</name>
<name>entityValueProcessor</name><argument_list>(<argument><expr><name>XML_Parser</name> <name>parser</name></expr></argument>,
<argument><expr>const <name>char</name> *<name>s</name></expr></argument>,
<argument><expr>const <name>char</name> *<name>end</name></expr></argument>,
<argument><expr>const <name>char</name> **<name>nextPtr</name></expr></argument>)</argument_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>start</name> <init>= <expr><name>s</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>next</name> <init>= <expr><name>s</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ENCODING</name> *</type><name>enc</name> <init>= <expr><name>encoding</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tok</name></decl>;</decl_stmt>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<expr_stmt><expr><name>tok</name> = <call><name>XmlPrologTok</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr>&amp;<name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>tok</name> &lt;= 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<name>ps_finalBuffer</name> &amp;&amp; <name>tok</name> != <name>XML_TOK_INVALID</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>nextPtr</name> = <name>s</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
}</block></then></if>
<switch>switch <condition>(<expr><name>tok</name></expr>)</condition> <block>{
<case>case <expr><name>XML_TOK_INVALID</name></expr>:
<return>return <expr><name>XML_ERROR_INVALID_TOKEN</name></expr>;</return>
</case><case>case <expr><name>XML_TOK_PARTIAL</name></expr>:
<return>return <expr><name>XML_ERROR_UNCLOSED_TOKEN</name></expr>;</return>
</case><case>case <expr><name>XML_TOK_PARTIAL_CHAR</name></expr>:
<return>return <expr><name>XML_ERROR_PARTIAL_CHAR</name></expr>;</return>
</case><case>case <expr><name>XML_TOK_NONE</name></expr>:
</case><default>default:
<break>break;</break>
</default>}</block></switch>
<return>return <expr><call><name>storeEntityValue</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>start</name> = <name>next</name></expr>;</expr_stmt>
}</block></for>
}</block></decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl>static enum <name>XML_Error</name> <name>PTRCALL</name>
<name>prologProcessor</name><argument_list>(<argument><expr><name>XML_Parser</name> <name>parser</name></expr></argument>,
<argument><expr>const <name>char</name> *<name>s</name></expr></argument>,
<argument><expr>const <name>char</name> *<name>end</name></expr></argument>,
<argument><expr>const <name>char</name> **<name>nextPtr</name></expr></argument>)</argument_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>next</name> <init>= <expr><name>s</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tok</name> <init>= <expr><call><name>XmlPrologTok</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr>&amp;<name>next</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>doProlog</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>tok</name></expr></argument>, <argument><expr><name>next</name></expr></argument>,
<argument><expr><name>nextPtr</name></expr></argument>, <argument><expr>(<name>XML_Bool</name>)!<name>ps_finalBuffer</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></decl>
<decl>static enum <name>XML_Error</name>
<name>doProlog</name><argument_list>(<argument><expr><name>XML_Parser</name> <name>parser</name></expr></argument>,
<argument><expr>const <name>ENCODING</name> *<name>enc</name></expr></argument>,
<argument><expr>const <name>char</name> *<name>s</name></expr></argument>,
<argument><expr>const <name>char</name> *<name>end</name></expr></argument>,
<argument><expr><name>int</name> <name>tok</name></expr></argument>,
<argument><expr>const <name>char</name> *<name>next</name></expr></argument>,
<argument><expr>const <name>char</name> **<name>nextPtr</name></expr></argument>,
<argument><expr><name>XML_Bool</name> <name>haveMore</name></expr></argument>)</argument_list> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>XML_Char</name></type> <name><name>externalSubsetName</name><index>[]</index></name> <init>= <expr><block>{ <expr>'#'</expr> , <expr>'\0'</expr> }</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>XML_Char</name></type> <name><name>atypeCDATA</name><index>[]</index></name> <init>= <expr><block>{ <expr>'C'</expr>, <expr>'D'</expr>, <expr>'A'</expr>, <expr>'T'</expr>, <expr>'A'</expr>, <expr>'\0'</expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>XML_Char</name></type> <name><name>atypeID</name><index>[]</index></name> <init>= <expr><block>{ <expr>'I'</expr>, <expr>'D'</expr>, <expr>'\0'</expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>XML_Char</name></type> <name><name>atypeIDREF</name><index>[]</index></name> <init>= <expr><block>{ <expr>'I'</expr>, <expr>'D'</expr>, <expr>'R'</expr>, <expr>'E'</expr>, <expr>'F'</expr>, <expr>'\0'</expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>XML_Char</name></type> <name><name>atypeIDREFS</name><index>[]</index></name> <init>= <expr><block>{ <expr>'I'</expr>, <expr>'D'</expr>, <expr>'R'</expr>, <expr>'E'</expr>, <expr>'F'</expr>, <expr>'S'</expr>, <expr>'\0'</expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>XML_Char</name></type> <name><name>atypeENTITY</name><index>[]</index></name> <init>= <expr><block>{ <expr>'E'</expr>, <expr>'N'</expr>, <expr>'T'</expr>, <expr>'I'</expr>, <expr>'T'</expr>, <expr>'Y'</expr>, <expr>'\0'</expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>XML_Char</name></type> <name><name>atypeENTITIES</name><index>[]</index></name> <init>=
<expr><block>{ <expr>'E'</expr>, <expr>'N'</expr>, <expr>'T'</expr>, <expr>'I'</expr>, <expr>'T'</expr>, <expr>'I'</expr>, <expr>'E'</expr>, <expr>'S'</expr>, <expr>'\0'</expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>XML_Char</name></type> <name><name>atypeNMTOKEN</name><index>[]</index></name> <init>= <expr><block>{
<expr>'N'</expr>, <expr>'M'</expr>, <expr>'T'</expr>, <expr>'O'</expr>, <expr>'K'</expr>, <expr>'E'</expr>, <expr>'N'</expr>, <expr>'\0'</expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>XML_Char</name></type> <name><name>atypeNMTOKENS</name><index>[]</index></name> <init>= <expr><block>{
<expr>'N'</expr>, <expr>'M'</expr>, <expr>'T'</expr>, <expr>'O'</expr>, <expr>'K'</expr>, <expr>'E'</expr>, <expr>'N'</expr>, <expr>'S'</expr>, <expr>'\0'</expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>XML_Char</name></type> <name><name>notationPrefix</name><index>[]</index></name> <init>= <expr><block>{
<expr>'N'</expr>, <expr>'O'</expr>, <expr>'T'</expr>, <expr>'A'</expr>, <expr>'T'</expr>, <expr>'I'</expr>, <expr>'O'</expr>, <expr>'N'</expr>, <expr>'('</expr>, <expr>'\0'</expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>XML_Char</name></type> <name><name>enumValueSep</name><index>[]</index></name> <init>= <expr><block>{ <expr>'|'</expr>, <expr>'\0'</expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>XML_Char</name></type> <name><name>enumValueStart</name><index>[]</index></name> <init>= <expr><block>{ <expr>'('</expr>, <expr>'\0'</expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>DTD</name> * <specifier>const</specifier></type> <name>dtd</name> <init>= <expr><name>_dtd</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> **</type><name>eventPP</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> **</type><name>eventEndPP</name></decl>;</decl_stmt>
<enum>enum <name>XML_Content_Quant</name> <name>quant</name>;</enum>
<if>if <condition>(<expr><name>enc</name> == <name>encoding</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>eventPP</name> = &amp;<name>eventPtr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>eventEndPP</name> = &amp;<name>eventEndPtr</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>eventPP</name> = &amp;(<name><name>openInternalEntities</name>-&gt;<name>internalEventPtr</name></name>)</expr>;</expr_stmt>
<expr_stmt><expr><name>eventEndPP</name> = &amp;(<name><name>openInternalEntities</name>-&gt;<name>internalEventEndPtr</name></name>)</expr>;</expr_stmt>
}</block></else></if>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<decl_stmt><decl><type><name>int</name></type> <name>role</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Bool</name></type> <name>handleDefault</name> <init>= <expr><name>XML_TRUE</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr>*<name>eventPP</name> = <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>eventEndPP</name> = <name>next</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>tok</name> &lt;= 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>haveMore</name> &amp;&amp; <name>tok</name> != <name>XML_TOK_INVALID</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>nextPtr</name> = <name>s</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
}</block></then></if>
<switch>switch <condition>(<expr><name>tok</name></expr>)</condition> <block>{
<case>case <expr><name>XML_TOK_INVALID</name></expr>:
<expr_stmt><expr>*<name>eventPP</name> = <name>next</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_INVALID_TOKEN</name></expr>;</return>
</case><case>case <expr><name>XML_TOK_PARTIAL</name></expr>:
<return>return <expr><name>XML_ERROR_UNCLOSED_TOKEN</name></expr>;</return>
</case><case>case <expr><name>XML_TOK_PARTIAL_CHAR</name></expr>:
<return>return <expr><name>XML_ERROR_PARTIAL_CHAR</name></expr>;</return>
</case><case>case <expr><name>XML_TOK_NONE</name></expr>:
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>enc</name> != <name>encoding</name> &amp;&amp; !<name><name>openInternalEntities</name>-&gt;<name>betweenDecl</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>nextPtr</name> = <name>s</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>isParamEntity</name> || <name>enc</name> != <name>encoding</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>XmlTokenRole</name><argument_list>(<argument><expr>&amp;<name>prologState</name></expr></argument>, <argument><expr><name>XML_TOK_NONE</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call>
== <name>XML_ROLE_ERROR</name></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_INCOMPLETE_PE</name></expr>;</return></then></if>
<expr_stmt><expr>*<name>nextPtr</name> = <name>s</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><name>XML_ERROR_NO_ELEMENTS</name></expr>;</return>
</case><default>default:
<expr_stmt><expr><name>tok</name> = -<name>tok</name></expr>;</expr_stmt>
<expr_stmt><expr><name>next</name> = <name>end</name></expr>;</expr_stmt>
<break>break;</break>
</default>}</block></switch>
}</block></then></if>
<expr_stmt><expr><name>role</name> = <call><name>XmlTokenRole</name><argument_list>(<argument><expr>&amp;<name>prologState</name></expr></argument>, <argument><expr><name>tok</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>role</name></expr>)</condition> <block>{
<case>case <expr><name>XML_ROLE_XML_DECL</name></expr>: <block>{
<enum>enum <name>XML_Error</name> <name>result</name> <expr_stmt><expr>= <call><name>processXmlDecl</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></enum>
<if>if <condition>(<expr><name>result</name> != <name>XML_ERROR_NONE</name></expr>)</condition><then>
<return>return <expr><name>result</name></expr>;</return></then></if>
<expr_stmt><expr><name>enc</name> = <name>encoding</name></expr>;</expr_stmt>
<expr_stmt><expr><name>handleDefault</name> = <name>XML_FALSE</name></expr>;</expr_stmt>
}</block>
<break>break;</break>
</case><case>case <expr><name>XML_ROLE_DOCTYPE_NAME</name></expr>:
<if>if <condition>(<expr><name>startDoctypeDeclHandler</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>doctypeName</name> = <call><name>poolStoreString</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>doctypeName</name></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>poolFinish</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>doctypePubid</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>handleDefault</name> = <name>XML_FALSE</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>doctypeSysid</name> = <name>NULL</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>XML_ROLE_DOCTYPE_INTERNAL_SUBSET</name></expr>:
<if>if <condition>(<expr><name>startDoctypeDeclHandler</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>startDoctypeDeclHandler</name><argument_list>(<argument><expr><name>handlerArg</name></expr></argument>, <argument><expr><name>doctypeName</name></expr></argument>, <argument><expr><name>doctypeSysid</name></expr></argument>,
<argument><expr><name>doctypePubid</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>doctypeName</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>poolClear</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>handleDefault</name> = <name>XML_FALSE</name></expr>;</expr_stmt>
}</block></then></if>
<break>break;</break>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
</case><case>case <expr><name>XML_ROLE_TEXT_DECL</name></expr>: <block>{
<enum>enum <name>XML_Error</name> <name>result</name> <expr_stmt><expr>= <call><name>processXmlDecl</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></enum>
<if>if <condition>(<expr><name>result</name> != <name>XML_ERROR_NONE</name></expr>)</condition><then>
<return>return <expr><name>result</name></expr>;</return></then></if>
<expr_stmt><expr><name>enc</name> = <name>encoding</name></expr>;</expr_stmt>
<expr_stmt><expr><name>handleDefault</name> = <name>XML_FALSE</name></expr>;</expr_stmt>
}</block>
<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</case><case>case <expr><name>XML_ROLE_DOCTYPE_PUBLIC_ID</name></expr>:
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>useForeignDTD</name> = <name>XML_FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>declEntity</name> = (<name>ENTITY</name> *)<call><name>lookup</name><argument_list>(<argument><expr>&amp;<name><name>dtd</name>-&gt;<name>paramEntities</name></name></expr></argument>,
<argument><expr><name>externalSubsetName</name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ENTITY</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>declEntity</name></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name><name>dtd</name>-&gt;<name>hasParamEntityRefs</name></name> = <name>XML_TRUE</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>startDoctypeDeclHandler</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<call><name>XmlIsPublicId</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>, <argument><expr><name>eventPP</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_PUBLICID</name></expr>;</return></then></if>
<expr_stmt><expr><name>doctypePubid</name> = <call><name>poolStoreString</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>,
<argument><expr><name>s</name> + <name><name>enc</name>-&gt;<name>minBytesPerChar</name></name></expr></argument>,
<argument><expr><name>next</name> - <name><name>enc</name>-&gt;<name>minBytesPerChar</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>doctypePubid</name></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>normalizePublicId</name><argument_list>(<argument><expr>(<name>XML_Char</name> *)<name>doctypePubid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>poolFinish</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>handleDefault</name> = <name>XML_FALSE</name></expr>;</expr_stmt>
<goto>goto <name>alreadyChecked</name>;</goto>
}</block></then></if>
</case><case>case <expr><name>XML_ROLE_ENTITY_PUBLIC_ID</name></expr>:
<if>if <condition>(<expr>!<call><name>XmlIsPublicId</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>, <argument><expr><name>eventPP</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_PUBLICID</name></expr>;</return></then></if>
<label><name>alreadyChecked</name>:</label>
<if>if <condition>(<expr><name><name>dtd</name>-&gt;<name>keepProcessing</name></name> &amp;&amp; <name>declEntity</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>XML_Char</name> *</type><name>tem</name> <init>= <expr><call><name>poolStoreString</name><argument_list>(<argument><expr>&amp;<name><name>dtd</name>-&gt;<name>pool</name></name></expr></argument>,
<argument><expr><name>enc</name></expr></argument>,
<argument><expr><name>s</name> + <name><name>enc</name>-&gt;<name>minBytesPerChar</name></name></expr></argument>,
<argument><expr><name>next</name> - <name><name>enc</name>-&gt;<name>minBytesPerChar</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>tem</name></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>normalizePublicId</name><argument_list>(<argument><expr><name>tem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>declEntity</name>-&gt;<name>publicId</name></name> = <name>tem</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>poolFinish</name><argument_list>(<argument><expr>&amp;<name><name>dtd</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>entityDeclHandler</name></expr>)</condition><then>
<expr_stmt><expr><name>handleDefault</name> = <name>XML_FALSE</name></expr>;</expr_stmt></then></if>
}</block></then></if>
<break>break;</break>
</case><case>case <expr><name>XML_ROLE_DOCTYPE_CLOSE</name></expr>:
<if>if <condition>(<expr><name>doctypeName</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>startDoctypeDeclHandler</name><argument_list>(<argument><expr><name>handlerArg</name></expr></argument>, <argument><expr><name>doctypeName</name></expr></argument>,
<argument><expr><name>doctypeSysid</name></expr></argument>, <argument><expr><name>doctypePubid</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>poolClear</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>handleDefault</name> = <name>XML_FALSE</name></expr>;</expr_stmt>
}</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>doctypeSysid</name> || <name>useForeignDTD</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>XML_Bool</name></type> <name>hadParamEntityRefs</name> <init>= <expr><name><name>dtd</name>-&gt;<name>hasParamEntityRefs</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>dtd</name>-&gt;<name>hasParamEntityRefs</name></name> = <name>XML_TRUE</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>paramEntityParsing</name> &amp;&amp; <name>externalEntityRefHandler</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>ENTITY</name> *</type><name>entity</name> <init>= <expr>(<name>ENTITY</name> *)<call><name>lookup</name><argument_list>(<argument><expr>&amp;<name><name>dtd</name>-&gt;<name>paramEntities</name></name></expr></argument>,
<argument><expr><name>externalSubsetName</name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ENTITY</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>entity</name></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>useForeignDTD</name></expr>)</condition><then>
<expr_stmt><expr><name><name>entity</name>-&gt;<name>base</name></name> = <name>curBase</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name><name>dtd</name>-&gt;<name>paramEntityRead</name></name> = <name>XML_FALSE</name></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>externalEntityRefHandler</name><argument_list>(<argument><expr><name>externalEntityRefHandlerArg</name></expr></argument>,
<argument><expr>0</expr></argument>,
<argument><expr><name><name>entity</name>-&gt;<name>base</name></name></expr></argument>,
<argument><expr><name><name>entity</name>-&gt;<name>systemId</name></name></expr></argument>,
<argument><expr><name><name>entity</name>-&gt;<name>publicId</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_EXTERNAL_ENTITY_HANDLING</name></expr>;</return></then></if>
<if>if <condition>(<expr><name><name>dtd</name>-&gt;<name>paramEntityRead</name></name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<name><name>dtd</name>-&gt;<name>standalone</name></name> &amp;&amp;
<name>notStandaloneHandler</name> &amp;&amp;
!<call><name>notStandaloneHandler</name><argument_list>(<argument><expr><name>handlerArg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NOT_STANDALONE</name></expr>;</return></then></if>
}</block></then>
<else>else <if>if <condition>(<expr>!<name>doctypeSysid</name></expr>)</condition><then>
<expr_stmt><expr><name><name>dtd</name>-&gt;<name>hasParamEntityRefs</name></name> = <name>hadParamEntityRefs</name></expr>;</expr_stmt></then></if></else></if>
}</block></then></if>
<expr_stmt><expr><name>useForeignDTD</name> = <name>XML_FALSE</name></expr>;</expr_stmt>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><name>endDoctypeDeclHandler</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>endDoctypeDeclHandler</name><argument_list>(<argument><expr><name>handlerArg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>handleDefault</name> = <name>XML_FALSE</name></expr>;</expr_stmt>
}</block></then></if>
<break>break;</break>
</case><case>case <expr><name>XML_ROLE_INSTANCE_START</name></expr>:
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>useForeignDTD</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>XML_Bool</name></type> <name>hadParamEntityRefs</name> <init>= <expr><name><name>dtd</name>-&gt;<name>hasParamEntityRefs</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>dtd</name>-&gt;<name>hasParamEntityRefs</name></name> = <name>XML_TRUE</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>paramEntityParsing</name> &amp;&amp; <name>externalEntityRefHandler</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>ENTITY</name> *</type><name>entity</name> <init>= <expr>(<name>ENTITY</name> *)<call><name>lookup</name><argument_list>(<argument><expr>&amp;<name><name>dtd</name>-&gt;<name>paramEntities</name></name></expr></argument>,
<argument><expr><name>externalSubsetName</name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ENTITY</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>entity</name></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>entity</name>-&gt;<name>base</name></name> = <name>curBase</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dtd</name>-&gt;<name>paramEntityRead</name></name> = <name>XML_FALSE</name></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>externalEntityRefHandler</name><argument_list>(<argument><expr><name>externalEntityRefHandlerArg</name></expr></argument>,
<argument><expr>0</expr></argument>,
<argument><expr><name><name>entity</name>-&gt;<name>base</name></name></expr></argument>,
<argument><expr><name><name>entity</name>-&gt;<name>systemId</name></name></expr></argument>,
<argument><expr><name><name>entity</name>-&gt;<name>publicId</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_EXTERNAL_ENTITY_HANDLING</name></expr>;</return></then></if>
<if>if <condition>(<expr><name><name>dtd</name>-&gt;<name>paramEntityRead</name></name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<name><name>dtd</name>-&gt;<name>standalone</name></name> &amp;&amp;
<name>notStandaloneHandler</name> &amp;&amp;
!<call><name>notStandaloneHandler</name><argument_list>(<argument><expr><name>handlerArg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NOT_STANDALONE</name></expr>;</return></then></if>
}</block></then>
<else>else
<expr_stmt><expr><name><name>dtd</name>-&gt;<name>hasParamEntityRefs</name></name> = <name>hadParamEntityRefs</name></expr>;</expr_stmt></else></if>
}</block></then></if>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>processor</name> = <name>contentProcessor</name></expr>;</expr_stmt>
<return>return <expr><call><name>contentProcessor</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>nextPtr</name></expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>XML_ROLE_ATTLIST_ELEMENT_NAME</name></expr>:
<expr_stmt><expr><name>declElementType</name> = <call><name>getElementType</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>declElementType</name></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></then></if>
<goto>goto <name>checkAttListDeclHandler</name>;</goto>
</case><case>case <expr><name>XML_ROLE_ATTRIBUTE_NAME</name></expr>:
<expr_stmt><expr><name>declAttributeId</name> = <call><name>getAttributeId</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>declAttributeId</name></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></then></if>
<expr_stmt><expr><name>declAttributeIsCdata</name> = <name>XML_FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>declAttributeType</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>declAttributeIsId</name> = <name>XML_FALSE</name></expr>;</expr_stmt>
<goto>goto <name>checkAttListDeclHandler</name>;</goto>
</case><case>case <expr><name>XML_ROLE_ATTRIBUTE_TYPE_CDATA</name></expr>:
<expr_stmt><expr><name>declAttributeIsCdata</name> = <name>XML_TRUE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>declAttributeType</name> = <name>atypeCDATA</name></expr>;</expr_stmt>
<goto>goto <name>checkAttListDeclHandler</name>;</goto>
</case><case>case <expr><name>XML_ROLE_ATTRIBUTE_TYPE_ID</name></expr>:
<expr_stmt><expr><name>declAttributeIsId</name> = <name>XML_TRUE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>declAttributeType</name> = <name>atypeID</name></expr>;</expr_stmt>
<goto>goto <name>checkAttListDeclHandler</name>;</goto>
</case><case>case <expr><name>XML_ROLE_ATTRIBUTE_TYPE_IDREF</name></expr>:
<expr_stmt><expr><name>declAttributeType</name> = <name>atypeIDREF</name></expr>;</expr_stmt>
<goto>goto <name>checkAttListDeclHandler</name>;</goto>
</case><case>case <expr><name>XML_ROLE_ATTRIBUTE_TYPE_IDREFS</name></expr>:
<expr_stmt><expr><name>declAttributeType</name> = <name>atypeIDREFS</name></expr>;</expr_stmt>
<goto>goto <name>checkAttListDeclHandler</name>;</goto>
</case><case>case <expr><name>XML_ROLE_ATTRIBUTE_TYPE_ENTITY</name></expr>:
<expr_stmt><expr><name>declAttributeType</name> = <name>atypeENTITY</name></expr>;</expr_stmt>
<goto>goto <name>checkAttListDeclHandler</name>;</goto>
</case><case>case <expr><name>XML_ROLE_ATTRIBUTE_TYPE_ENTITIES</name></expr>:
<expr_stmt><expr><name>declAttributeType</name> = <name>atypeENTITIES</name></expr>;</expr_stmt>
<goto>goto <name>checkAttListDeclHandler</name>;</goto>
</case><case>case <expr><name>XML_ROLE_ATTRIBUTE_TYPE_NMTOKEN</name></expr>:
<expr_stmt><expr><name>declAttributeType</name> = <name>atypeNMTOKEN</name></expr>;</expr_stmt>
<goto>goto <name>checkAttListDeclHandler</name>;</goto>
</case><case>case <expr><name>XML_ROLE_ATTRIBUTE_TYPE_NMTOKENS</name></expr>:
<expr_stmt><expr><name>declAttributeType</name> = <name>atypeNMTOKENS</name></expr>;</expr_stmt>
<label><name>checkAttListDeclHandler</name>:</label>
<if>if <condition>(<expr><name><name>dtd</name>-&gt;<name>keepProcessing</name></name> &amp;&amp; <name>attlistDeclHandler</name></expr>)</condition><then>
<expr_stmt><expr><name>handleDefault</name> = <name>XML_FALSE</name></expr>;</expr_stmt></then></if>
<break>break;</break>
</case><case>case <expr><name>XML_ROLE_ATTRIBUTE_ENUM_VALUE</name></expr>:
</case><case>case <expr><name>XML_ROLE_ATTRIBUTE_NOTATION_VALUE</name></expr>:
<if>if <condition>(<expr><name><name>dtd</name>-&gt;<name>keepProcessing</name></name> &amp;&amp; <name>attlistDeclHandler</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>prefix</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>declAttributeType</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>prefix</name> = <name>enumValueSep</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>prefix</name> = (<name>role</name> == <name>XML_ROLE_ATTRIBUTE_NOTATION_VALUE</name>
? <name>notationPrefix</name>
: <name>enumValueStart</name>)</expr>;</expr_stmt>
}</block></else></if>
<if>if <condition>(<expr>!<call><name>poolAppendString</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>poolAppend</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></then></if>
<expr_stmt><expr><name>declAttributeType</name> = <name><name>tempPool</name>.<name>start</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>handleDefault</name> = <name>XML_FALSE</name></expr>;</expr_stmt>
}</block></then></if>
<break>break;</break>
</case><case>case <expr><name>XML_ROLE_IMPLIED_ATTRIBUTE_VALUE</name></expr>:
</case><case>case <expr><name>XML_ROLE_REQUIRED_ATTRIBUTE_VALUE</name></expr>:
<if>if <condition>(<expr><name><name>dtd</name>-&gt;<name>keepProcessing</name></name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<call><name>defineAttribute</name><argument_list>(<argument><expr><name>declElementType</name></expr></argument>, <argument><expr><name>declAttributeId</name></expr></argument>,
<argument><expr><name>declAttributeIsCdata</name></expr></argument>, <argument><expr><name>declAttributeIsId</name></expr></argument>,
<argument><expr>0</expr></argument>, <argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>attlistDeclHandler</name> &amp;&amp; <name>declAttributeType</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>*<name>declAttributeType</name> == <call><name>XML_T</name><argument_list>(<argument><expr>'('</expr></argument>)</argument_list></call>
|| (*<name>declAttributeType</name> == <call><name>XML_T</name><argument_list>(<argument><expr>'N'</expr></argument>)</argument_list></call>
&amp;&amp; <name><name>declAttributeType</name><index>[<expr>1</expr>]</index></name> == <call><name>XML_T</name><argument_list>(<argument><expr>'O'</expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<call><name>poolAppendChar</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>, <argument><expr><call><name>XML_T</name><argument_list>(<argument><expr>')'</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
|| !<call><name>poolAppendChar</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>, <argument><expr><call><name>XML_T</name><argument_list>(<argument><expr>'\0'</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></then></if>
<expr_stmt><expr><name>declAttributeType</name> = <name><name>tempPool</name>.<name>start</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>poolFinish</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr>*<name>eventEndPP</name> = <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>attlistDeclHandler</name><argument_list>(<argument><expr><name>handlerArg</name></expr></argument>, <argument><expr><name><name>declElementType</name>-&gt;<name>name</name></name></expr></argument>,
<argument><expr><name><name>declAttributeId</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>declAttributeType</name></expr></argument>,
<argument><expr>0</expr></argument>, <argument><expr><name>role</name> == <name>XML_ROLE_REQUIRED_ATTRIBUTE_VALUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>poolClear</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>handleDefault</name> = <name>XML_FALSE</name></expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
<break>break;</break>
</case><case>case <expr><name>XML_ROLE_DEFAULT_ATTRIBUTE_VALUE</name></expr>:
</case><case>case <expr><name>XML_ROLE_FIXED_ATTRIBUTE_VALUE</name></expr>:
<if>if <condition>(<expr><name><name>dtd</name>-&gt;<name>keepProcessing</name></name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>attVal</name></decl>;</decl_stmt>
<enum>enum <name>XML_Error</name> <name>result</name> <expr_stmt><expr>=
<call><name>storeAttributeValue</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>declAttributeIsCdata</name></expr></argument>,
<argument><expr><name>s</name> + <name><name>enc</name>-&gt;<name>minBytesPerChar</name></name></expr></argument>,
<argument><expr><name>next</name> - <name><name>enc</name>-&gt;<name>minBytesPerChar</name></name></expr></argument>,
<argument><expr>&amp;<name><name>dtd</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></enum>
<if>if <condition>(<expr><name>result</name></expr>)</condition><then>
<return>return <expr><name>result</name></expr>;</return></then></if>
<expr_stmt><expr><name>attVal</name> = <call><name>poolStart</name><argument_list>(<argument><expr>&amp;<name><name>dtd</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>poolFinish</name><argument_list>(<argument><expr>&amp;<name><name>dtd</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>defineAttribute</name><argument_list>(<argument><expr><name>declElementType</name></expr></argument>, <argument><expr><name>declAttributeId</name></expr></argument>,
<argument><expr><name>declAttributeIsCdata</name></expr></argument>, <argument><expr><name>XML_FALSE</name></expr></argument>, <argument><expr><name>attVal</name></expr></argument>, <argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>attlistDeclHandler</name> &amp;&amp; <name>declAttributeType</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>*<name>declAttributeType</name> == <call><name>XML_T</name><argument_list>(<argument><expr>'('</expr></argument>)</argument_list></call>
|| (*<name>declAttributeType</name> == <call><name>XML_T</name><argument_list>(<argument><expr>'N'</expr></argument>)</argument_list></call>
&amp;&amp; <name><name>declAttributeType</name><index>[<expr>1</expr>]</index></name> == <call><name>XML_T</name><argument_list>(<argument><expr>'O'</expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<call><name>poolAppendChar</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>, <argument><expr><call><name>XML_T</name><argument_list>(<argument><expr>')'</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
|| !<call><name>poolAppendChar</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>, <argument><expr><call><name>XML_T</name><argument_list>(<argument><expr>'\0'</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></then></if>
<expr_stmt><expr><name>declAttributeType</name> = <name><name>tempPool</name>.<name>start</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>poolFinish</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr>*<name>eventEndPP</name> = <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>attlistDeclHandler</name><argument_list>(<argument><expr><name>handlerArg</name></expr></argument>, <argument><expr><name><name>declElementType</name>-&gt;<name>name</name></name></expr></argument>,
<argument><expr><name><name>declAttributeId</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>declAttributeType</name></expr></argument>,
<argument><expr><name>attVal</name></expr></argument>,
<argument><expr><name>role</name> == <name>XML_ROLE_FIXED_ATTRIBUTE_VALUE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>poolClear</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>handleDefault</name> = <name>XML_FALSE</name></expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
<break>break;</break>
</case><case>case <expr><name>XML_ROLE_ENTITY_VALUE</name></expr>:
<if>if <condition>(<expr><name><name>dtd</name>-&gt;<name>keepProcessing</name></name></expr>)</condition><then> <block>{
<enum>enum <name>XML_Error</name> <name>result</name> <expr_stmt><expr>= <call><name>storeEntityValue</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>,
<argument><expr><name>s</name> + <name><name>enc</name>-&gt;<name>minBytesPerChar</name></name></expr></argument>,
<argument><expr><name>next</name> - <name><name>enc</name>-&gt;<name>minBytesPerChar</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></enum>
<if>if <condition>(<expr><name>declEntity</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>declEntity</name>-&gt;<name>textPtr</name></name> = <call><name>poolStart</name><argument_list>(<argument><expr>&amp;<name><name>dtd</name>-&gt;<name>entityValuePool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>declEntity</name>-&gt;<name>textLen</name></name> = <call>(<name>int</name>)<argument_list>(<argument><expr><call><name>poolLength</name><argument_list>(<argument><expr>&amp;<name><name>dtd</name>-&gt;<name>entityValuePool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>poolFinish</name><argument_list>(<argument><expr>&amp;<name><name>dtd</name>-&gt;<name>entityValuePool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>entityDeclHandler</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>eventEndPP</name> = <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>entityDeclHandler</name><argument_list>(<argument><expr><name>handlerArg</name></expr></argument>,
<argument><expr><name><name>declEntity</name>-&gt;<name>name</name></name></expr></argument>,
<argument><expr><name><name>declEntity</name>-&gt;<name>is_param</name></name></expr></argument>,
<argument><expr><name><name>declEntity</name>-&gt;<name>textPtr</name></name></expr></argument>,
<argument><expr><name><name>declEntity</name>-&gt;<name>textLen</name></name></expr></argument>,
<argument><expr><name>curBase</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>handleDefault</name> = <name>XML_FALSE</name></expr>;</expr_stmt>
}</block></then></if>
}</block></then> <else>else
<expr_stmt><expr><call><name>poolDiscard</name><argument_list>(<argument><expr>&amp;<name><name>dtd</name>-&gt;<name>entityValuePool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<if>if <condition>(<expr><name>result</name> != <name>XML_ERROR_NONE</name></expr>)</condition><then>
<return>return <expr><name>result</name></expr>;</return></then></if>
}</block></then></if>
<break>break;</break>
</case><case>case <expr><name>XML_ROLE_DOCTYPE_SYSTEM_ID</name></expr>:
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>useForeignDTD</name> = <name>XML_FALSE</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name><name>dtd</name>-&gt;<name>hasParamEntityRefs</name></name> = <name>XML_TRUE</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>startDoctypeDeclHandler</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>doctypeSysid</name> = <call><name>poolStoreString</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>,
<argument><expr><name>s</name> + <name><name>enc</name>-&gt;<name>minBytesPerChar</name></name></expr></argument>,
<argument><expr><name>next</name> - <name><name>enc</name>-&gt;<name>minBytesPerChar</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>doctypeSysid</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>poolFinish</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>handleDefault</name> = <name>XML_FALSE</name></expr>;</expr_stmt>
}</block></then>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<else>else
<expr_stmt><expr><name>doctypeSysid</name> = <name>externalSubsetName</name></expr>;</expr_stmt></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr>!<name><name>dtd</name>-&gt;<name>standalone</name></name>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
&amp;&amp; !<name>paramEntityParsing</name>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
&amp;&amp; <name>notStandaloneHandler</name>
&amp;&amp; !<call><name>notStandaloneHandler</name><argument_list>(<argument><expr><name>handlerArg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NOT_STANDALONE</name></expr>;</return></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<break>break;</break>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if>if <condition>(<expr>!<name>declEntity</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>declEntity</name> = (<name>ENTITY</name> *)<call><name>lookup</name><argument_list>(<argument><expr>&amp;<name><name>dtd</name>-&gt;<name>paramEntities</name></name></expr></argument>,
<argument><expr><name>externalSubsetName</name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ENTITY</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>declEntity</name></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>declEntity</name>-&gt;<name>publicId</name></name> = <name>NULL</name></expr>;</expr_stmt>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</case><case>case <expr><name>XML_ROLE_ENTITY_SYSTEM_ID</name></expr>:
<if>if <condition>(<expr><name><name>dtd</name>-&gt;<name>keepProcessing</name></name> &amp;&amp; <name>declEntity</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>declEntity</name>-&gt;<name>systemId</name></name> = <call><name>poolStoreString</name><argument_list>(<argument><expr>&amp;<name><name>dtd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>enc</name></expr></argument>,
<argument><expr><name>s</name> + <name><name>enc</name>-&gt;<name>minBytesPerChar</name></name></expr></argument>,
<argument><expr><name>next</name> - <name><name>enc</name>-&gt;<name>minBytesPerChar</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name><name>declEntity</name>-&gt;<name>systemId</name></name></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>declEntity</name>-&gt;<name>base</name></name> = <name>curBase</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>poolFinish</name><argument_list>(<argument><expr>&amp;<name><name>dtd</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>entityDeclHandler</name></expr>)</condition><then>
<expr_stmt><expr><name>handleDefault</name> = <name>XML_FALSE</name></expr>;</expr_stmt></then></if>
}</block></then></if>
<break>break;</break>
</case><case>case <expr><name>XML_ROLE_ENTITY_COMPLETE</name></expr>:
<if>if <condition>(<expr><name><name>dtd</name>-&gt;<name>keepProcessing</name></name> &amp;&amp; <name>declEntity</name> &amp;&amp; <name>entityDeclHandler</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>eventEndPP</name> = <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>entityDeclHandler</name><argument_list>(<argument><expr><name>handlerArg</name></expr></argument>,
<argument><expr><name><name>declEntity</name>-&gt;<name>name</name></name></expr></argument>,
<argument><expr><name><name>declEntity</name>-&gt;<name>is_param</name></name></expr></argument>,
<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>,
<argument><expr><name><name>declEntity</name>-&gt;<name>base</name></name></expr></argument>,
<argument><expr><name><name>declEntity</name>-&gt;<name>systemId</name></name></expr></argument>,
<argument><expr><name><name>declEntity</name>-&gt;<name>publicId</name></name></expr></argument>,
<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>handleDefault</name> = <name>XML_FALSE</name></expr>;</expr_stmt>
}</block></then></if>
<break>break;</break>
</case><case>case <expr><name>XML_ROLE_ENTITY_NOTATION_NAME</name></expr>:
<if>if <condition>(<expr><name><name>dtd</name>-&gt;<name>keepProcessing</name></name> &amp;&amp; <name>declEntity</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>declEntity</name>-&gt;<name>notation</name></name> = <call><name>poolStoreString</name><argument_list>(<argument><expr>&amp;<name><name>dtd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name><name>declEntity</name>-&gt;<name>notation</name></name></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>poolFinish</name><argument_list>(<argument><expr>&amp;<name><name>dtd</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>unparsedEntityDeclHandler</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>eventEndPP</name> = <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>unparsedEntityDeclHandler</name><argument_list>(<argument><expr><name>handlerArg</name></expr></argument>,
<argument><expr><name><name>declEntity</name>-&gt;<name>name</name></name></expr></argument>,
<argument><expr><name><name>declEntity</name>-&gt;<name>base</name></name></expr></argument>,
<argument><expr><name><name>declEntity</name>-&gt;<name>systemId</name></name></expr></argument>,
<argument><expr><name><name>declEntity</name>-&gt;<name>publicId</name></name></expr></argument>,
<argument><expr><name><name>declEntity</name>-&gt;<name>notation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>handleDefault</name> = <name>XML_FALSE</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>entityDeclHandler</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>eventEndPP</name> = <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>entityDeclHandler</name><argument_list>(<argument><expr><name>handlerArg</name></expr></argument>,
<argument><expr><name><name>declEntity</name>-&gt;<name>name</name></name></expr></argument>,
<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>,
<argument><expr><name><name>declEntity</name>-&gt;<name>base</name></name></expr></argument>,
<argument><expr><name><name>declEntity</name>-&gt;<name>systemId</name></name></expr></argument>,
<argument><expr><name><name>declEntity</name>-&gt;<name>publicId</name></name></expr></argument>,
<argument><expr><name><name>declEntity</name>-&gt;<name>notation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>handleDefault</name> = <name>XML_FALSE</name></expr>;</expr_stmt>
}</block></then></if></else></if>
}</block></then></if>
<break>break;</break>
</case><case>case <expr><name>XML_ROLE_GENERAL_ENTITY_NAME</name></expr>: <block>{
<if>if <condition>(<expr><call><name>XmlPredefinedEntityName</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>declEntity</name> = <name>NULL</name></expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
<if>if <condition>(<expr><name><name>dtd</name>-&gt;<name>keepProcessing</name></name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>name</name> <init>= <expr><call><name>poolStoreString</name><argument_list>(<argument><expr>&amp;<name><name>dtd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>name</name></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></then></if>
<expr_stmt><expr><name>declEntity</name> = (<name>ENTITY</name> *)<call><name>lookup</name><argument_list>(<argument><expr>&amp;<name><name>dtd</name>-&gt;<name>generalEntities</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ENTITY</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>declEntity</name></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></then></if>
<if>if <condition>(<expr><name><name>declEntity</name>-&gt;<name>name</name></name> != <name>name</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>poolDiscard</name><argument_list>(<argument><expr>&amp;<name><name>dtd</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>declEntity</name> = <name>NULL</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>poolFinish</name><argument_list>(<argument><expr>&amp;<name><name>dtd</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>declEntity</name>-&gt;<name>publicId</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>declEntity</name>-&gt;<name>is_param</name></name> = <name>XML_FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>declEntity</name>-&gt;<name>is_internal</name></name> = !(<name>parentParser</name> || <name>openInternalEntities</name>)</expr>;</expr_stmt>
<if>if <condition>(<expr><name>entityDeclHandler</name></expr>)</condition><then>
<expr_stmt><expr><name>handleDefault</name> = <name>XML_FALSE</name></expr>;</expr_stmt></then></if>
}</block></else></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>poolDiscard</name><argument_list>(<argument><expr>&amp;<name><name>dtd</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>declEntity</name> = <name>NULL</name></expr>;</expr_stmt>
}</block></else></if>
}</block>
<break>break;</break>
</case><case>case <expr><name>XML_ROLE_PARAM_ENTITY_NAME</name></expr>:
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name><name>dtd</name>-&gt;<name>keepProcessing</name></name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>name</name> <init>= <expr><call><name>poolStoreString</name><argument_list>(<argument><expr>&amp;<name><name>dtd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>name</name></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></then></if>
<expr_stmt><expr><name>declEntity</name> = (<name>ENTITY</name> *)<call><name>lookup</name><argument_list>(<argument><expr>&amp;<name><name>dtd</name>-&gt;<name>paramEntities</name></name></expr></argument>,
<argument><expr><name>name</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ENTITY</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>declEntity</name></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></then></if>
<if>if <condition>(<expr><name><name>declEntity</name>-&gt;<name>name</name></name> != <name>name</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>poolDiscard</name><argument_list>(<argument><expr>&amp;<name><name>dtd</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>declEntity</name> = <name>NULL</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>poolFinish</name><argument_list>(<argument><expr>&amp;<name><name>dtd</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>declEntity</name>-&gt;<name>publicId</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>declEntity</name>-&gt;<name>is_param</name></name> = <name>XML_TRUE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>declEntity</name>-&gt;<name>is_internal</name></name> = !(<name>parentParser</name> || <name>openInternalEntities</name>)</expr>;</expr_stmt>
<if>if <condition>(<expr><name>entityDeclHandler</name></expr>)</condition><then>
<expr_stmt><expr><name>handleDefault</name> = <name>XML_FALSE</name></expr>;</expr_stmt></then></if>
}</block></else></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>poolDiscard</name><argument_list>(<argument><expr>&amp;<name><name>dtd</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>declEntity</name> = <name>NULL</name></expr>;</expr_stmt>
}</block></else></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>declEntity</name> = <name>NULL</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<break>break;</break>
</case><case>case <expr><name>XML_ROLE_NOTATION_NAME</name></expr>:
<expr_stmt><expr><name>declNotationPublicId</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>declNotationName</name> = <name>NULL</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>notationDeclHandler</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>declNotationName</name> = <call><name>poolStoreString</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>declNotationName</name></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>poolFinish</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>handleDefault</name> = <name>XML_FALSE</name></expr>;</expr_stmt>
}</block></then></if>
<break>break;</break>
</case><case>case <expr><name>XML_ROLE_NOTATION_PUBLIC_ID</name></expr>:
<if>if <condition>(<expr>!<call><name>XmlIsPublicId</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>, <argument><expr><name>eventPP</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_PUBLICID</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>declNotationName</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>XML_Char</name> *</type><name>tem</name> <init>= <expr><call><name>poolStoreString</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>,
<argument><expr><name>enc</name></expr></argument>,
<argument><expr><name>s</name> + <name><name>enc</name>-&gt;<name>minBytesPerChar</name></name></expr></argument>,
<argument><expr><name>next</name> - <name><name>enc</name>-&gt;<name>minBytesPerChar</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>tem</name></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>normalizePublicId</name><argument_list>(<argument><expr><name>tem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>declNotationPublicId</name> = <name>tem</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>poolFinish</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>handleDefault</name> = <name>XML_FALSE</name></expr>;</expr_stmt>
}</block></then></if>
<break>break;</break>
</case><case>case <expr><name>XML_ROLE_NOTATION_SYSTEM_ID</name></expr>:
<if>if <condition>(<expr><name>declNotationName</name> &amp;&amp; <name>notationDeclHandler</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>systemId</name>
<init>= <expr><call><name>poolStoreString</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>,
<argument><expr><name>s</name> + <name><name>enc</name>-&gt;<name>minBytesPerChar</name></name></expr></argument>,
<argument><expr><name>next</name> - <name><name>enc</name>-&gt;<name>minBytesPerChar</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>systemId</name></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></then></if>
<expr_stmt><expr>*<name>eventEndPP</name> = <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>notationDeclHandler</name><argument_list>(<argument><expr><name>handlerArg</name></expr></argument>,
<argument><expr><name>declNotationName</name></expr></argument>,
<argument><expr><name>curBase</name></expr></argument>,
<argument><expr><name>systemId</name></expr></argument>,
<argument><expr><name>declNotationPublicId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>handleDefault</name> = <name>XML_FALSE</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>poolClear</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>XML_ROLE_NOTATION_NO_SYSTEM_ID</name></expr>:
<if>if <condition>(<expr><name>declNotationPublicId</name> &amp;&amp; <name>notationDeclHandler</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>eventEndPP</name> = <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>notationDeclHandler</name><argument_list>(<argument><expr><name>handlerArg</name></expr></argument>,
<argument><expr><name>declNotationName</name></expr></argument>,
<argument><expr><name>curBase</name></expr></argument>,
<argument><expr>0</expr></argument>,
<argument><expr><name>declNotationPublicId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>handleDefault</name> = <name>XML_FALSE</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>poolClear</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>XML_ROLE_ERROR</name></expr>:
<switch>switch <condition>(<expr><name>tok</name></expr>)</condition> <block>{
<case>case <expr><name>XML_TOK_PARAM_ENTITY_REF</name></expr>:
<return>return <expr><name>XML_ERROR_PARAM_ENTITY_REF</name></expr>;</return>
</case><case>case <expr><name>XML_TOK_XML_DECL</name></expr>:
<return>return <expr><name>XML_ERROR_MISPLACED_XML_PI</name></expr>;</return>
</case><default>default:
<return>return <expr><name>XML_ERROR_SYNTAX</name></expr>;</return>
</default>}</block></switch>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
</case><case>case <expr><name>XML_ROLE_IGNORE_SECT</name></expr>: <block>{
<enum>enum <name>XML_Error</name> <name>result</name>;</enum>
<if>if <condition>(<expr><name>defaultHandler</name></expr>)</condition><then>
<expr_stmt><expr><call><name>reportDefault</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>handleDefault</name> = <name>XML_FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> = <call><name>doIgnoreSection</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr>&amp;<name>next</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>nextPtr</name></expr></argument>, <argument><expr><name>haveMore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> != <name>XML_ERROR_NONE</name></expr>)</condition><then>
<return>return <expr><name>result</name></expr>;</return></then>
<else>else <if>if <condition>(<expr>!<name>next</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>processor</name> = <name>ignoreSectionProcessor</name></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></then></if></else></if>
}</block>
<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</case><case>case <expr><name>XML_ROLE_GROUP_OPEN</name></expr>:
<if>if <condition>(<expr><name><name>prologState</name>.<name>level</name></name> &gt;= <name>groupSize</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>groupSize</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>temp</name> <init>= <expr>(<name>char</name> *)<call><name>REALLOC</name><argument_list>(<argument><expr><name>groupConnector</name></expr></argument>, <argument><expr><name>groupSize</name> *= 2</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>temp</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></then></if>
<expr_stmt><expr><name>groupConnector</name> = <name>temp</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>dtd</name>-&gt;<name>scaffIndex</name></name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name> *</type><name>temp</name> <init>= <expr>(<name>int</name> *)<call><name>REALLOC</name><argument_list>(<argument><expr><name><name>dtd</name>-&gt;<name>scaffIndex</name></name></expr></argument>,
<argument><expr><name>groupSize</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>temp</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>dtd</name>-&gt;<name>scaffIndex</name></name> = <name>temp</name></expr>;</expr_stmt>
}</block></then></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>groupConnector</name> = (<name>char</name> *)<call><name>MALLOC</name><argument_list>(<argument><expr><name>groupSize</name> = 32</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>groupConnector</name></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></then></if>
}</block></else></if>
}</block></then></if>
<expr_stmt><expr><name><name>groupConnector</name><index>[<expr><name><name>prologState</name>.<name>level</name></name></expr>]</index></name> = 0</expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>dtd</name>-&gt;<name>in_eldecl</name></name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>myindex</name> <init>= <expr><call><name>nextScaffoldPart</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>myindex</name> &lt; 0</expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>dtd</name>-&gt;<name>scaffIndex</name><index>[<expr><name><name>dtd</name>-&gt;<name>scaffLevel</name></name></expr>]</index></name> = <name>myindex</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dtd</name>-&gt;<name>scaffLevel</name></name>++</expr>;</expr_stmt>
<expr_stmt><expr><name><name>dtd</name>-&gt;<name>scaffold</name><index>[<expr><name>myindex</name></expr>]</index></name>.<name>type</name> = <name>XML_CTYPE_SEQ</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>elementDeclHandler</name></expr>)</condition><then>
<expr_stmt><expr><name>handleDefault</name> = <name>XML_FALSE</name></expr>;</expr_stmt></then></if>
}</block></then></if>
<break>break;</break>
</case><case>case <expr><name>XML_ROLE_GROUP_SEQUENCE</name></expr>:
<if>if <condition>(<expr><name><name>groupConnector</name><index>[<expr><name><name>prologState</name>.<name>level</name></name></expr>]</index></name> == '|'</expr>)</condition><then>
<return>return <expr><name>XML_ERROR_SYNTAX</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>groupConnector</name><index>[<expr><name><name>prologState</name>.<name>level</name></name></expr>]</index></name> = ','</expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>dtd</name>-&gt;<name>in_eldecl</name></name> &amp;&amp; <name>elementDeclHandler</name></expr>)</condition><then>
<expr_stmt><expr><name>handleDefault</name> = <name>XML_FALSE</name></expr>;</expr_stmt></then></if>
<break>break;</break>
</case><case>case <expr><name>XML_ROLE_GROUP_CHOICE</name></expr>:
<if>if <condition>(<expr><name><name>groupConnector</name><index>[<expr><name><name>prologState</name>.<name>level</name></name></expr>]</index></name> == ','</expr>)</condition><then>
<return>return <expr><name>XML_ERROR_SYNTAX</name></expr>;</return></then></if>
<if>if <condition>(<expr><name><name>dtd</name>-&gt;<name>in_eldecl</name></name>
&amp;&amp; !<name><name>groupConnector</name><index>[<expr><name><name>prologState</name>.<name>level</name></name></expr>]</index></name>
&amp;&amp; (<name><name>dtd</name>-&gt;<name>scaffold</name><index>[<expr><name><name>dtd</name>-&gt;<name>scaffIndex</name><index>[<expr><name><name>dtd</name>-&gt;<name>scaffLevel</name></name> - 1</expr>]</index></name></expr>]</index></name>.<name>type</name>
!= <name>XML_CTYPE_MIXED</name>)</expr>
)</condition><then> <block>{
<expr_stmt><expr><name><name>dtd</name>-&gt;<name>scaffold</name><index>[<expr><name><name>dtd</name>-&gt;<name>scaffIndex</name><index>[<expr><name><name>dtd</name>-&gt;<name>scaffLevel</name></name> - 1</expr>]</index></name></expr>]</index></name>.<name>type</name>
= <name>XML_CTYPE_CHOICE</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>elementDeclHandler</name></expr>)</condition><then>
<expr_stmt><expr><name>handleDefault</name> = <name>XML_FALSE</name></expr>;</expr_stmt></then></if>
}</block></then></if>
<expr_stmt><expr><name><name>groupConnector</name><index>[<expr><name><name>prologState</name>.<name>level</name></name></expr>]</index></name> = '|'</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>XML_ROLE_PARAM_ENTITY_REF</name></expr>:
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
</case><case>case <expr><name>XML_ROLE_INNER_PARAM_ENTITY_REF</name></expr>:
<expr_stmt><expr><name><name>dtd</name>-&gt;<name>hasParamEntityRefs</name></name> = <name>XML_TRUE</name></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>paramEntityParsing</name></expr>)</condition><then>
<expr_stmt><expr><name><name>dtd</name>-&gt;<name>keepProcessing</name></name> = <name><name>dtd</name>-&gt;<name>standalone</name></name></expr>;</expr_stmt></then>
<else>else <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ENTITY</name> *</type><name>entity</name></decl>;</decl_stmt>
<expr_stmt><expr><name>name</name> = <call><name>poolStoreString</name><argument_list>(<argument><expr>&amp;<name><name>dtd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>enc</name></expr></argument>,
<argument><expr><name>s</name> + <name><name>enc</name>-&gt;<name>minBytesPerChar</name></name></expr></argument>,
<argument><expr><name>next</name> - <name><name>enc</name>-&gt;<name>minBytesPerChar</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>name</name></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></then></if>
<expr_stmt><expr><name>entity</name> = (<name>ENTITY</name> *)<call><name>lookup</name><argument_list>(<argument><expr>&amp;<name><name>dtd</name>-&gt;<name>paramEntities</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>poolDiscard</name><argument_list>(<argument><expr>&amp;<name><name>dtd</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>prologState</name>.<name>documentEntity</name></name> &amp;&amp;
(<name><name>dtd</name>-&gt;<name>standalone</name></name>
? !<name>openInternalEntities</name>
: !<name><name>dtd</name>-&gt;<name>hasParamEntityRefs</name></name>)</expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<name>entity</name></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_UNDEFINED_ENTITY</name></expr>;</return></then>
<else>else <if>if <condition>(<expr>!<name><name>entity</name>-&gt;<name>is_internal</name></name></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_ENTITY_DECLARED_IN_PE</name></expr>;</return></then></if></else></if>
}</block></then> <else>else <if>if <condition>(<expr>!<name>entity</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>dtd</name>-&gt;<name>keepProcessing</name></name> = <name><name>dtd</name>-&gt;<name>standalone</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr>(<name>role</name> == <name>XML_ROLE_PARAM_ENTITY_REF</name>) &amp;&amp; <name>skippedEntityHandler</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>skippedEntityHandler</name><argument_list>(<argument><expr><name>handlerArg</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>handleDefault</name> = <name>XML_FALSE</name></expr>;</expr_stmt>
}</block></then></if>
<break>break;</break>
}</block></then></if></else></if>
<if>if <condition>(<expr><name><name>entity</name>-&gt;<name>open</name></name></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_RECURSIVE_ENTITY_REF</name></expr>;</return></then></if>
<if>if <condition>(<expr><name><name>entity</name>-&gt;<name>textPtr</name></name></expr>)</condition><then> <block>{
<enum>enum <name>XML_Error</name> <name>result</name>;</enum>
<decl_stmt><decl><type><name>XML_Bool</name></type> <name>betweenDecl</name> <init>=
<expr>(<name>role</name> == <name>XML_ROLE_PARAM_ENTITY_REF</name> ? <name>XML_TRUE</name> : <name>XML_FALSE</name>)</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>result</name> = <call><name>processInternalEntity</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>entity</name></expr></argument>, <argument><expr><name>betweenDecl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> != <name>XML_ERROR_NONE</name></expr>)</condition><then>
<return>return <expr><name>result</name></expr>;</return></then></if>
<expr_stmt><expr><name>handleDefault</name> = <name>XML_FALSE</name></expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
<if>if <condition>(<expr><name>externalEntityRefHandler</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>dtd</name>-&gt;<name>paramEntityRead</name></name> = <name>XML_FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>entity</name>-&gt;<name>open</name></name> = <name>XML_TRUE</name></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>externalEntityRefHandler</name><argument_list>(<argument><expr><name>externalEntityRefHandlerArg</name></expr></argument>,
<argument><expr>0</expr></argument>,
<argument><expr><name><name>entity</name>-&gt;<name>base</name></name></expr></argument>,
<argument><expr><name><name>entity</name>-&gt;<name>systemId</name></name></expr></argument>,
<argument><expr><name><name>entity</name>-&gt;<name>publicId</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>entity</name>-&gt;<name>open</name></name> = <name>XML_FALSE</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_EXTERNAL_ENTITY_HANDLING</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>entity</name>-&gt;<name>open</name></name> = <name>XML_FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>handleDefault</name> = <name>XML_FALSE</name></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name><name>dtd</name>-&gt;<name>paramEntityRead</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>dtd</name>-&gt;<name>keepProcessing</name></name> = <name><name>dtd</name>-&gt;<name>standalone</name></name></expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><name><name>dtd</name>-&gt;<name>keepProcessing</name></name> = <name><name>dtd</name>-&gt;<name>standalone</name></name></expr>;</expr_stmt>
<break>break;</break>
}</block></else></if>
}</block></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr>!<name><name>dtd</name>-&gt;<name>standalone</name></name> &amp;&amp;
<name>notStandaloneHandler</name> &amp;&amp;
!<call><name>notStandaloneHandler</name><argument_list>(<argument><expr><name>handlerArg</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NOT_STANDALONE</name></expr>;</return></then></if>
<break>break;</break>
</case><case>case <expr><name>XML_ROLE_ELEMENT_NAME</name></expr>:
<if>if <condition>(<expr><name>elementDeclHandler</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>declElementType</name> = <call><name>getElementType</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>declElementType</name></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>dtd</name>-&gt;<name>scaffLevel</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>dtd</name>-&gt;<name>scaffCount</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>dtd</name>-&gt;<name>in_eldecl</name></name> = <name>XML_TRUE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>handleDefault</name> = <name>XML_FALSE</name></expr>;</expr_stmt>
}</block></then></if>
<break>break;</break>
</case><case>case <expr><name>XML_ROLE_CONTENT_ANY</name></expr>:
</case><case>case <expr><name>XML_ROLE_CONTENT_EMPTY</name></expr>:
<if>if <condition>(<expr><name><name>dtd</name>-&gt;<name>in_eldecl</name></name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>elementDeclHandler</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>XML_Content</name> *</type> <name>content</name> <init>= <expr>(<name>XML_Content</name> *) <call><name>MALLOC</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>XML_Content</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>content</name></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>content</name>-&gt;<name>quant</name></name> = <name>XML_CQUANT_NONE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>content</name>-&gt;<name>name</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>content</name>-&gt;<name>numchildren</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>content</name>-&gt;<name>children</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>content</name>-&gt;<name>type</name></name> = ((<name>role</name> == <name>XML_ROLE_CONTENT_ANY</name>) ?
<name>XML_CTYPE_ANY</name> :
<name>XML_CTYPE_EMPTY</name>)</expr>;</expr_stmt>
<expr_stmt><expr>*<name>eventEndPP</name> = <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>elementDeclHandler</name><argument_list>(<argument><expr><name>handlerArg</name></expr></argument>, <argument><expr><name><name>declElementType</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>content</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>handleDefault</name> = <name>XML_FALSE</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name><name>dtd</name>-&gt;<name>in_eldecl</name></name> = <name>XML_FALSE</name></expr>;</expr_stmt>
}</block></then></if>
<break>break;</break>
</case><case>case <expr><name>XML_ROLE_CONTENT_PCDATA</name></expr>:
<if>if <condition>(<expr><name><name>dtd</name>-&gt;<name>in_eldecl</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>dtd</name>-&gt;<name>scaffold</name><index>[<expr><name><name>dtd</name>-&gt;<name>scaffIndex</name><index>[<expr><name><name>dtd</name>-&gt;<name>scaffLevel</name></name> - 1</expr>]</index></name></expr>]</index></name>.<name>type</name>
= <name>XML_CTYPE_MIXED</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>elementDeclHandler</name></expr>)</condition><then>
<expr_stmt><expr><name>handleDefault</name> = <name>XML_FALSE</name></expr>;</expr_stmt></then></if>
}</block></then></if>
<break>break;</break>
</case><case>case <expr><name>XML_ROLE_CONTENT_ELEMENT</name></expr>:
<expr_stmt><expr><name>quant</name> = <name>XML_CQUANT_NONE</name></expr>;</expr_stmt>
<goto>goto <name>elementContent</name>;</goto>
</case><case>case <expr><name>XML_ROLE_CONTENT_ELEMENT_OPT</name></expr>:
<expr_stmt><expr><name>quant</name> = <name>XML_CQUANT_OPT</name></expr>;</expr_stmt>
<goto>goto <name>elementContent</name>;</goto>
</case><case>case <expr><name>XML_ROLE_CONTENT_ELEMENT_REP</name></expr>:
<expr_stmt><expr><name>quant</name> = <name>XML_CQUANT_REP</name></expr>;</expr_stmt>
<goto>goto <name>elementContent</name>;</goto>
</case><case>case <expr><name>XML_ROLE_CONTENT_ELEMENT_PLUS</name></expr>:
<expr_stmt><expr><name>quant</name> = <name>XML_CQUANT_PLUS</name></expr>;</expr_stmt>
<label><name>elementContent</name>:</label>
<if>if <condition>(<expr><name><name>dtd</name>-&gt;<name>in_eldecl</name></name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>ELEMENT_TYPE</name> *</type><name>el</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nameLen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>nxt</name> <init>= <expr>(<name>quant</name> == <name>XML_CQUANT_NONE</name>
? <name>next</name>
: <name>next</name> - <name><name>enc</name>-&gt;<name>minBytesPerChar</name></name>)</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>myindex</name> <init>= <expr><call><name>nextScaffoldPart</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>myindex</name> &lt; 0</expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>dtd</name>-&gt;<name>scaffold</name><index>[<expr><name>myindex</name></expr>]</index></name>.<name>type</name> = <name>XML_CTYPE_NAME</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dtd</name>-&gt;<name>scaffold</name><index>[<expr><name>myindex</name></expr>]</index></name>.<name>quant</name> = <name>quant</name></expr>;</expr_stmt>
<expr_stmt><expr><name>el</name> = <call><name>getElementType</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>nxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>el</name></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></then></if>
<expr_stmt><expr><name>name</name> = <name><name>el</name>-&gt;<name>name</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dtd</name>-&gt;<name>scaffold</name><index>[<expr><name>myindex</name></expr>]</index></name>.<name>name</name> = <name>name</name></expr>;</expr_stmt>
<expr_stmt><expr><name>nameLen</name> = 0</expr>;</expr_stmt>
<for>for (<init>;</init> <condition><expr><name><name>name</name><index>[<expr><name>nameLen</name>++</expr>]</index></name></expr>;</condition> <incr/>)<empty_stmt>;</empty_stmt></for>
<expr_stmt><expr><name><name>dtd</name>-&gt;<name>contentStringLen</name></name> += <name>nameLen</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>elementDeclHandler</name></expr>)</condition><then>
<expr_stmt><expr><name>handleDefault</name> = <name>XML_FALSE</name></expr>;</expr_stmt></then></if>
}</block></then></if>
<break>break;</break>
</case><case>case <expr><name>XML_ROLE_GROUP_CLOSE</name></expr>:
<expr_stmt><expr><name>quant</name> = <name>XML_CQUANT_NONE</name></expr>;</expr_stmt>
<goto>goto <name>closeGroup</name>;</goto>
</case><case>case <expr><name>XML_ROLE_GROUP_CLOSE_OPT</name></expr>:
<expr_stmt><expr><name>quant</name> = <name>XML_CQUANT_OPT</name></expr>;</expr_stmt>
<goto>goto <name>closeGroup</name>;</goto>
</case><case>case <expr><name>XML_ROLE_GROUP_CLOSE_REP</name></expr>:
<expr_stmt><expr><name>quant</name> = <name>XML_CQUANT_REP</name></expr>;</expr_stmt>
<goto>goto <name>closeGroup</name>;</goto>
</case><case>case <expr><name>XML_ROLE_GROUP_CLOSE_PLUS</name></expr>:
<expr_stmt><expr><name>quant</name> = <name>XML_CQUANT_PLUS</name></expr>;</expr_stmt>
<label><name>closeGroup</name>:</label>
<if>if <condition>(<expr><name><name>dtd</name>-&gt;<name>in_eldecl</name></name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>elementDeclHandler</name></expr>)</condition><then>
<expr_stmt><expr><name>handleDefault</name> = <name>XML_FALSE</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name><name>dtd</name>-&gt;<name>scaffLevel</name></name>--</expr>;</expr_stmt>
<expr_stmt><expr><name><name>dtd</name>-&gt;<name>scaffold</name><index>[<expr><name><name>dtd</name>-&gt;<name>scaffIndex</name><index>[<expr><name><name>dtd</name>-&gt;<name>scaffLevel</name></name></expr>]</index></name></expr>]</index></name>.<name>quant</name> = <name>quant</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>dtd</name>-&gt;<name>scaffLevel</name></name> == 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<name>handleDefault</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>XML_Content</name> *</type><name>model</name> <init>= <expr><call><name>build_model</name><argument_list>(<argument><expr><name>parser</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>model</name></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></then></if>
<expr_stmt><expr>*<name>eventEndPP</name> = <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>elementDeclHandler</name><argument_list>(<argument><expr><name>handlerArg</name></expr></argument>, <argument><expr><name><name>declElementType</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>model</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name><name>dtd</name>-&gt;<name>in_eldecl</name></name> = <name>XML_FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dtd</name>-&gt;<name>contentStringLen</name></name> = 0</expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
<break>break;</break>
</case><case>case <expr><name>XML_ROLE_PI</name></expr>:
<if>if <condition>(<expr>!<call><name>reportProcessingInstruction</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></then></if>
<expr_stmt><expr><name>handleDefault</name> = <name>XML_FALSE</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>XML_ROLE_COMMENT</name></expr>:
<if>if <condition>(<expr>!<call><name>reportComment</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></then></if>
<expr_stmt><expr><name>handleDefault</name> = <name>XML_FALSE</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>XML_ROLE_NONE</name></expr>:
<switch>switch <condition>(<expr><name>tok</name></expr>)</condition> <block>{
<case>case <expr><name>XML_TOK_BOM</name></expr>:
<expr_stmt><expr><name>handleDefault</name> = <name>XML_FALSE</name></expr>;</expr_stmt>
<break>break;</break>
</case>}</block></switch>
<break>break;</break>
</case><case>case <expr><name>XML_ROLE_DOCTYPE_NONE</name></expr>:
<if>if <condition>(<expr><name>startDoctypeDeclHandler</name></expr>)</condition><then>
<expr_stmt><expr><name>handleDefault</name> = <name>XML_FALSE</name></expr>;</expr_stmt></then></if>
<break>break;</break>
</case><case>case <expr><name>XML_ROLE_ENTITY_NONE</name></expr>:
<if>if <condition>(<expr><name><name>dtd</name>-&gt;<name>keepProcessing</name></name> &amp;&amp; <name>entityDeclHandler</name></expr>)</condition><then>
<expr_stmt><expr><name>handleDefault</name> = <name>XML_FALSE</name></expr>;</expr_stmt></then></if>
<break>break;</break>
</case><case>case <expr><name>XML_ROLE_NOTATION_NONE</name></expr>:
<if>if <condition>(<expr><name>notationDeclHandler</name></expr>)</condition><then>
<expr_stmt><expr><name>handleDefault</name> = <name>XML_FALSE</name></expr>;</expr_stmt></then></if>
<break>break;</break>
</case><case>case <expr><name>XML_ROLE_ATTLIST_NONE</name></expr>:
<if>if <condition>(<expr><name><name>dtd</name>-&gt;<name>keepProcessing</name></name> &amp;&amp; <name>attlistDeclHandler</name></expr>)</condition><then>
<expr_stmt><expr><name>handleDefault</name> = <name>XML_FALSE</name></expr>;</expr_stmt></then></if>
<break>break;</break>
</case><case>case <expr><name>XML_ROLE_ELEMENT_NONE</name></expr>:
<if>if <condition>(<expr><name>elementDeclHandler</name></expr>)</condition><then>
<expr_stmt><expr><name>handleDefault</name> = <name>XML_FALSE</name></expr>;</expr_stmt></then></if>
<break>break;</break>
</case>}</block></switch>
<if>if <condition>(<expr><name>handleDefault</name> &amp;&amp; <name>defaultHandler</name></expr>)</condition><then>
<expr_stmt><expr><call><name>reportDefault</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<switch>switch <condition>(<expr><name>ps_parsing</name></expr>)</condition> <block>{
<case>case <expr><name>XML_SUSPENDED</name></expr>:
<expr_stmt><expr>*<name>nextPtr</name> = <name>next</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
</case><case>case <expr><name>XML_FINISHED</name></expr>:
<return>return <expr><name>XML_ERROR_ABORTED</name></expr>;</return>
</case><default>default:
<expr_stmt><expr><name>s</name> = <name>next</name></expr>;</expr_stmt>
<expr_stmt><expr><name>tok</name> = <call><name>XmlPrologTok</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr>&amp;<name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</default>}</block></switch>
}</block></for>
}</block></decl>
<decl>static enum <name>XML_Error</name> <name>PTRCALL</name>
<name>epilogProcessor</name><argument_list>(<argument><expr><name>XML_Parser</name> <name>parser</name></expr></argument>,
<argument><expr>const <name>char</name> *<name>s</name></expr></argument>,
<argument><expr>const <name>char</name> *<name>end</name></expr></argument>,
<argument><expr>const <name>char</name> **<name>nextPtr</name></expr></argument>)</argument_list> <block>{
<expr_stmt><expr><name>processor</name> = <name>epilogProcessor</name></expr>;</expr_stmt>
<expr_stmt><expr><name>eventPtr</name> = <name>s</name></expr>;</expr_stmt>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>next</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tok</name> <init>= <expr><call><name>XmlPrologTok</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr>&amp;<name>next</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>eventEndPtr</name> = <name>next</name></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>tok</name></expr>)</condition> <block>{
<case>case <expr>-<name>XML_TOK_PROLOG_S</name></expr>:
<if>if <condition>(<expr><name>defaultHandler</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>reportDefault</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ps_parsing</name> == <name>XML_FINISHED</name></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_ABORTED</name></expr>;</return></then></if>
}</block></then></if>
<expr_stmt><expr>*<name>nextPtr</name> = <name>next</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
</case><case>case <expr><name>XML_TOK_NONE</name></expr>:
<expr_stmt><expr>*<name>nextPtr</name> = <name>s</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
</case><case>case <expr><name>XML_TOK_PROLOG_S</name></expr>:
<if>if <condition>(<expr><name>defaultHandler</name></expr>)</condition><then>
<expr_stmt><expr><call><name>reportDefault</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<break>break;</break>
</case><case>case <expr><name>XML_TOK_PI</name></expr>:
<if>if <condition>(<expr>!<call><name>reportProcessingInstruction</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></then></if>
<break>break;</break>
</case><case>case <expr><name>XML_TOK_COMMENT</name></expr>:
<if>if <condition>(<expr>!<call><name>reportComment</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></then></if>
<break>break;</break>
</case><case>case <expr><name>XML_TOK_INVALID</name></expr>:
<expr_stmt><expr><name>eventPtr</name> = <name>next</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_INVALID_TOKEN</name></expr>;</return>
</case><case>case <expr><name>XML_TOK_PARTIAL</name></expr>:
<if>if <condition>(<expr>!<name>ps_finalBuffer</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>nextPtr</name> = <name>s</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
}</block></then></if>
<return>return <expr><name>XML_ERROR_UNCLOSED_TOKEN</name></expr>;</return>
</case><case>case <expr><name>XML_TOK_PARTIAL_CHAR</name></expr>:
<if>if <condition>(<expr>!<name>ps_finalBuffer</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>nextPtr</name> = <name>s</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
}</block></then></if>
<return>return <expr><name>XML_ERROR_PARTIAL_CHAR</name></expr>;</return>
</case><default>default:
<return>return <expr><name>XML_ERROR_JUNK_AFTER_DOC_ELEMENT</name></expr>;</return>
</default>}</block></switch>
<expr_stmt><expr><name>eventPtr</name> = <name>s</name> = <name>next</name></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>ps_parsing</name></expr>)</condition> <block>{
<case>case <expr><name>XML_SUSPENDED</name></expr>:
<expr_stmt><expr>*<name>nextPtr</name> = <name>next</name></expr>;</expr_stmt>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
</case><case>case <expr><name>XML_FINISHED</name></expr>:
<return>return <expr><name>XML_ERROR_ABORTED</name></expr>;</return>
</case><default>default:
<empty_stmt>;</empty_stmt>
</default>}</block></switch>
}</block></for>
}</block></decl>
<decl>static enum <name>XML_Error</name>
<name>processInternalEntity</name><argument_list>(<argument><expr><name>XML_Parser</name> <name>parser</name></expr></argument>, <argument><expr><name>ENTITY</name> *<name>entity</name></expr></argument>,
<argument><expr><name>XML_Bool</name> <name>betweenDecl</name></expr></argument>)</argument_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>textStart</name></decl></decl_stmt>, <expr_stmt><expr>*<name>textEnd</name></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>next</name></decl>;</decl_stmt>
<enum>enum <name>XML_Error</name> <name>result</name>;</enum>
<decl_stmt><decl><type><name>OPEN_INTERNAL_ENTITY</name> *</type><name>openEntity</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>freeInternalEntities</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>openEntity</name> = <name>freeInternalEntities</name></expr>;</expr_stmt>
<expr_stmt><expr><name>freeInternalEntities</name> = <name><name>openEntity</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>openEntity</name> = (<name>OPEN_INTERNAL_ENTITY</name> *)<call><name>MALLOC</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OPEN_INTERNAL_ENTITY</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>openEntity</name></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></then></if>
}</block></else></if>
<expr_stmt><expr><name><name>entity</name>-&gt;<name>open</name></name> = <name>XML_TRUE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>entity</name>-&gt;<name>processed</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>openEntity</name>-&gt;<name>next</name></name> = <name>openInternalEntities</name></expr>;</expr_stmt>
<expr_stmt><expr><name>openInternalEntities</name> = <name>openEntity</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>openEntity</name>-&gt;<name>entity</name></name> = <name>entity</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>openEntity</name>-&gt;<name>startTagLevel</name></name> = <name>tagLevel</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>openEntity</name>-&gt;<name>betweenDecl</name></name> = <name>betweenDecl</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>openEntity</name>-&gt;<name>internalEventPtr</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>openEntity</name>-&gt;<name>internalEventEndPtr</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>textStart</name> = (<name>char</name> *)<name><name>entity</name>-&gt;<name>textPtr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>textEnd</name> = <call>(<name>char</name> *)<argument_list>(<argument><expr><name><name>entity</name>-&gt;<name>textPtr</name></name> + <name><name>entity</name>-&gt;<name>textLen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name><name>entity</name>-&gt;<name>is_param</name></name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>tok</name> <init>= <expr><call><name>XmlPrologTok</name><argument_list>(<argument><expr><name>internalEncoding</name></expr></argument>, <argument><expr><name>textStart</name></expr></argument>, <argument><expr><name>textEnd</name></expr></argument>, <argument><expr>&amp;<name>next</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>result</name> = <call><name>doProlog</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>internalEncoding</name></expr></argument>, <argument><expr><name>textStart</name></expr></argument>, <argument><expr><name>textEnd</name></expr></argument>, <argument><expr><name>tok</name></expr></argument>,
<argument><expr><name>next</name></expr></argument>, <argument><expr>&amp;<name>next</name></expr></argument>, <argument><expr><name>XML_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>result</name> = <call><name>doContent</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>tagLevel</name></expr></argument>, <argument><expr><name>internalEncoding</name></expr></argument>, <argument><expr><name>textStart</name></expr></argument>,
<argument><expr><name>textEnd</name></expr></argument>, <argument><expr>&amp;<name>next</name></expr></argument>, <argument><expr><name>XML_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<if>if <condition>(<expr><name>result</name> == <name>XML_ERROR_NONE</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>textEnd</name> != <name>next</name> &amp;&amp; <name>ps_parsing</name> == <name>XML_SUSPENDED</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>entity</name>-&gt;<name>processed</name></name> = <call>(<name>int</name>)<argument_list>(<argument><expr><name>next</name> - <name>textStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>processor</name> = <name>internalEntityProcessor</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name><name>entity</name>-&gt;<name>open</name></name> = <name>XML_FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>openInternalEntities</name> = <name><name>openEntity</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>openEntity</name>-&gt;<name>next</name></name> = <name>freeInternalEntities</name></expr>;</expr_stmt>
<expr_stmt><expr><name>freeInternalEntities</name> = <name>openEntity</name></expr>;</expr_stmt>
}</block></else></if>
}</block></then></if>
<return>return <expr><name>result</name></expr>;</return>
}</block></decl>
<decl>static enum <name>XML_Error</name> <name>PTRCALL</name>
<name>internalEntityProcessor</name><argument_list>(<argument><expr><name>XML_Parser</name> <name>parser</name></expr></argument>,
<argument><expr>const <name>char</name> *<name>s</name></expr></argument>,
<argument><expr>const <name>char</name> *<name>end</name></expr></argument>,
<argument><expr>const <name>char</name> **<name>nextPtr</name></expr></argument>)</argument_list> <block>{
<decl_stmt><decl><type><name>ENTITY</name> *</type><name>entity</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>textStart</name></decl></decl_stmt>, <expr_stmt><expr>*<name>textEnd</name></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>next</name></decl>;</decl_stmt>
<enum>enum <name>XML_Error</name> <name>result</name>;</enum>
<decl_stmt><decl><type><name>OPEN_INTERNAL_ENTITY</name> *</type><name>openEntity</name> <init>= <expr><name>openInternalEntities</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>openEntity</name></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_UNEXPECTED_STATE</name></expr>;</return></then></if>
<expr_stmt><expr><name>entity</name> = <name><name>openEntity</name>-&gt;<name>entity</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>textStart</name> = ((<name>char</name> *)<name><name>entity</name>-&gt;<name>textPtr</name></name>) + <name><name>entity</name>-&gt;<name>processed</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>textEnd</name> = <call>(<name>char</name> *)<argument_list>(<argument><expr><name><name>entity</name>-&gt;<name>textPtr</name></name> + <name><name>entity</name>-&gt;<name>textLen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name><name>entity</name>-&gt;<name>is_param</name></name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>tok</name> <init>= <expr><call><name>XmlPrologTok</name><argument_list>(<argument><expr><name>internalEncoding</name></expr></argument>, <argument><expr><name>textStart</name></expr></argument>, <argument><expr><name>textEnd</name></expr></argument>, <argument><expr>&amp;<name>next</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>result</name> = <call><name>doProlog</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>internalEncoding</name></expr></argument>, <argument><expr><name>textStart</name></expr></argument>, <argument><expr><name>textEnd</name></expr></argument>, <argument><expr><name>tok</name></expr></argument>,
<argument><expr><name>next</name></expr></argument>, <argument><expr>&amp;<name>next</name></expr></argument>, <argument><expr><name>XML_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>result</name> = <call><name>doContent</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name><name>openEntity</name>-&gt;<name>startTagLevel</name></name></expr></argument>, <argument><expr><name>internalEncoding</name></expr></argument>,
<argument><expr><name>textStart</name></expr></argument>, <argument><expr><name>textEnd</name></expr></argument>, <argument><expr>&amp;<name>next</name></expr></argument>, <argument><expr><name>XML_FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<if>if <condition>(<expr><name>result</name> != <name>XML_ERROR_NONE</name></expr>)</condition><then>
<return>return <expr><name>result</name></expr>;</return></then>
<else>else <if>if <condition>(<expr><name>textEnd</name> != <name>next</name> &amp;&amp; <name>ps_parsing</name> == <name>XML_SUSPENDED</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>entity</name>-&gt;<name>processed</name></name> = <call>(<name>int</name>)<argument_list>(<argument><expr><name>next</name> - (<name>char</name> *)<name><name>entity</name>-&gt;<name>textPtr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></then> <else>else <block>{
<expr_stmt><expr><name><name>entity</name>-&gt;<name>open</name></name> = <name>XML_FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>openInternalEntities</name> = <name><name>openEntity</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>openEntity</name>-&gt;<name>next</name></name> = <name>freeInternalEntities</name></expr>;</expr_stmt>
<expr_stmt><expr><name>freeInternalEntities</name> = <name>openEntity</name></expr>;</expr_stmt>
}</block></else></if></else></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name><name>entity</name>-&gt;<name>is_param</name></name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>tok</name></decl>;</decl_stmt>
<expr_stmt><expr><name>processor</name> = <name>prologProcessor</name></expr>;</expr_stmt>
<expr_stmt><expr><name>tok</name> = <call><name>XmlPrologTok</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr>&amp;<name>next</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>doProlog</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>tok</name></expr></argument>, <argument><expr><name>next</name></expr></argument>, <argument><expr><name>nextPtr</name></expr></argument>,
<argument><expr>(<name>XML_Bool</name>)!<name>ps_finalBuffer</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<block>{
<expr_stmt><expr><name>processor</name> = <name>contentProcessor</name></expr>;</expr_stmt>
<return>return <expr><call><name>doContent</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>parentParser</name> ? 1 : 0</expr></argument>, <argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>end</name></expr></argument>,
<argument><expr><name>nextPtr</name></expr></argument>, <argument><expr>(<name>XML_Bool</name>)!<name>ps_finalBuffer</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></else></if>
}</block></decl>
<decl>static enum <name>XML_Error</name> <name>PTRCALL</name>
<name>errorProcessor</name><argument_list>(<argument><expr><name>XML_Parser</name> <name>parser</name></expr></argument>,
<argument><expr>const <name>char</name> *<name>s</name></expr></argument>,
<argument><expr>const <name>char</name> *<name>end</name></expr></argument>,
<argument><expr>const <name>char</name> **<name>nextPtr</name></expr></argument>)</argument_list> <block>{
<return>return <expr><name>errorCode</name></expr>;</return>
}</block></decl>
<decl>static enum <name>XML_Error</name>
<name>storeAttributeValue</name><argument_list>(<argument><expr><name>XML_Parser</name> <name>parser</name></expr></argument>, <argument><expr>const <name>ENCODING</name> *<name>enc</name></expr></argument>, <argument><expr><name>XML_Bool</name> <name>isCdata</name></expr></argument>,
<argument><expr>const <name>char</name> *<name>ptr</name></expr></argument>, <argument><expr>const <name>char</name> *<name>end</name></expr></argument>,
<argument><expr><name>STRING_POOL</name> *<name>pool</name></expr></argument>)</argument_list> <block>{
<enum>enum <name>XML_Error</name> <name>result</name> <expr_stmt><expr>= <call><name>appendAttributeValue</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>isCdata</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>,
<argument><expr><name>end</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></enum>
<if>if <condition>(<expr><name>result</name></expr>)</condition><then>
<return>return <expr><name>result</name></expr>;</return></then></if>
<if>if <condition>(<expr>!<name>isCdata</name> &amp;&amp; <call><name>poolLength</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>poolLastChar</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call> == 0x20</expr>)</condition><then>
<expr_stmt><expr><call><name>poolChop</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr>!<call><name>poolAppendChar</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><call><name>XML_T</name><argument_list>(<argument><expr>'\0'</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></then></if>
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
}</block></decl>
<decl>static enum <name>XML_Error</name>
<name>appendAttributeValue</name><argument_list>(<argument><expr><name>XML_Parser</name> <name>parser</name></expr></argument>, <argument><expr>const <name>ENCODING</name> *<name>enc</name></expr></argument>, <argument><expr><name>XML_Bool</name> <name>isCdata</name></expr></argument>,
<argument><expr>const <name>char</name> *<name>ptr</name></expr></argument>, <argument><expr>const <name>char</name> *<name>end</name></expr></argument>,
<argument><expr><name>STRING_POOL</name> *<name>pool</name></expr></argument>)</argument_list> <block>{
<decl_stmt><decl><type><name>DTD</name> * <specifier>const</specifier></type> <name>dtd</name> <init>= <expr><name>_dtd</name></expr></init></decl>;</decl_stmt>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>next</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tok</name> <init>= <expr><call><name>XmlAttributeValueTok</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr>&amp;<name>next</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name>tok</name></expr>)</condition> <block>{
<case>case <expr><name>XML_TOK_NONE</name></expr>:
<return>return <expr><name>XML_ERROR_NONE</name></expr>;</return>
</case><case>case <expr><name>XML_TOK_INVALID</name></expr>:
<if>if <condition>(<expr><name>enc</name> == <name>encoding</name></expr>)</condition><then>
<expr_stmt><expr><name>eventPtr</name> = <name>next</name></expr>;</expr_stmt></then></if>
<return>return <expr><name>XML_ERROR_INVALID_TOKEN</name></expr>;</return>
</case><case>case <expr><name>XML_TOK_PARTIAL</name></expr>:
<if>if <condition>(<expr><name>enc</name> == <name>encoding</name></expr>)</condition><then>
<expr_stmt><expr><name>eventPtr</name> = <name>ptr</name></expr>;</expr_stmt></then></if>
<return>return <expr><name>XML_ERROR_INVALID_TOKEN</name></expr>;</return>
</case><case>case <expr><name>XML_TOK_CHAR_REF</name></expr>: <block>{
<decl_stmt><decl><type><name>XML_Char</name></type> <name><name>buf</name><index>[<expr><name>XML_ENCODE_MAX</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>XmlCharRefNumber</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>n</name> &lt; 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>enc</name> == <name>encoding</name></expr>)</condition><then>
<expr_stmt><expr><name>eventPtr</name> = <name>ptr</name></expr>;</expr_stmt></then></if>
<return>return <expr><name>XML_ERROR_BAD_CHAR_REF</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>!<name>isCdata</name>
&amp;&amp; <name>n</name> == 0x20
&amp;&amp; (<call><name>poolLength</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call> == 0 || <call><name>poolLastChar</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call> == 0x20)</expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr><name>n</name> = <call><name>XmlEncode</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>(<name>ICHAR</name> *)<name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>n</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>enc</name> == <name>encoding</name></expr>)</condition><then>
<expr_stmt><expr><name>eventPtr</name> = <name>ptr</name></expr>;</expr_stmt></then></if>
<return>return <expr><name>XML_ERROR_BAD_CHAR_REF</name></expr>;</return>
}</block></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<if>if <condition>(<expr>!<call><name>poolAppendChar</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></then></if>
}</block></for>
}</block>
<break>break;</break>
</case><case>case <expr><name>XML_TOK_DATA_CHARS</name></expr>:
<if>if <condition>(<expr>!<call><name>poolAppend</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></then></if>
<break>break;</break>
</case><case>case <expr><name>XML_TOK_TRAILING_CR</name></expr>:
<expr_stmt><expr><name>next</name> = <name>ptr</name> + <name><name>enc</name>-&gt;<name>minBytesPerChar</name></name></expr>;</expr_stmt>
</case><case>case <expr><name>XML_TOK_ATTRIBUTE_VALUE_S</name></expr>:
</case><case>case <expr><name>XML_TOK_DATA_NEWLINE</name></expr>:
<if>if <condition>(<expr>!<name>isCdata</name> &amp;&amp; (<call><name>poolLength</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call> == 0 || <call><name>poolLastChar</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call> == 0x20)</expr>)</condition><then>
<break>break;</break></then></if>
<if>if <condition>(<expr>!<call><name>poolAppendChar</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>0x20</expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></then></if>
<break>break;</break>
</case><case>case <expr><name>XML_TOK_ENTITY_REF</name></expr>: <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ENTITY</name> *</type><name>entity</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>checkEntityDecl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Char</name></type> <name>ch</name> <init>= <expr>(<name>XML_Char</name>) <call><name>XmlPredefinedEntityName</name><argument_list>(<argument><expr><name>enc</name></expr></argument>,
<argument><expr><name>ptr</name> + <name><name>enc</name>-&gt;<name>minBytesPerChar</name></name></expr></argument>,
<argument><expr><name>next</name> - <name><name>enc</name>-&gt;<name>minBytesPerChar</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>ch</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<call><name>poolAppendChar</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></then></if>
<break>break;</break>
}</block></then></if>
<expr_stmt><expr><name>name</name> = <call><name>poolStoreString</name><argument_list>(<argument><expr>&amp;<name>temp2Pool</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>,
<argument><expr><name>ptr</name> + <name><name>enc</name>-&gt;<name>minBytesPerChar</name></name></expr></argument>,
<argument><expr><name>next</name> - <name><name>enc</name>-&gt;<name>minBytesPerChar</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>name</name></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></then></if>
<expr_stmt><expr><name>entity</name> = (<name>ENTITY</name> *)<call><name>lookup</name><argument_list>(<argument><expr>&amp;<name><name>dtd</name>-&gt;<name>generalEntities</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>poolDiscard</name><argument_list>(<argument><expr>&amp;<name>temp2Pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>pool</name> == &amp;<name><name>dtd</name>-&gt;<name>pool</name></name></expr>)</condition><then>
<expr_stmt><expr><name>checkEntityDecl</name> =
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<name><name>prologState</name>.<name>documentEntity</name></name> &amp;&amp;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
(<name><name>dtd</name>-&gt;<name>standalone</name></name>
? !<name>openInternalEntities</name>
: !<name><name>dtd</name>-&gt;<name>hasParamEntityRefs</name></name>)</expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>checkEntityDecl</name> = !<name><name>dtd</name>-&gt;<name>hasParamEntityRefs</name></name> || <name><name>dtd</name>-&gt;<name>standalone</name></name></expr>;</expr_stmt></else></if>
<if>if <condition>(<expr><name>checkEntityDecl</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<name>entity</name></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_UNDEFINED_ENTITY</name></expr>;</return></then>
<else>else <if>if <condition>(<expr>!<name><name>entity</name>-&gt;<name>is_internal</name></name></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_ENTITY_DECLARED_IN_PE</name></expr>;</return></then></if></else></if>
}</block></then> <else>else <if>if <condition>(<expr>!<name>entity</name></expr>)</condition><then> <block>{
<break>break;</break>
}</block></then></if></else></if>
<if>if <condition>(<expr><name><name>entity</name>-&gt;<name>open</name></name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>enc</name> == <name>encoding</name></expr>)</condition><then>
<expr_stmt><expr><name>eventPtr</name> = <name>ptr</name></expr>;</expr_stmt></then></if>
<return>return <expr><name>XML_ERROR_RECURSIVE_ENTITY_REF</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name><name>entity</name>-&gt;<name>notation</name></name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>enc</name> == <name>encoding</name></expr>)</condition><then>
<expr_stmt><expr><name>eventPtr</name> = <name>ptr</name></expr>;</expr_stmt></then></if>
<return>return <expr><name>XML_ERROR_BINARY_ENTITY_REF</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>!<name><name>entity</name>-&gt;<name>textPtr</name></name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>enc</name> == <name>encoding</name></expr>)</condition><then>
<expr_stmt><expr><name>eventPtr</name> = <name>ptr</name></expr>;</expr_stmt></then></if>
<return>return <expr><name>XML_ERROR_ATTRIBUTE_EXTERNAL_ENTITY_REF</name></expr>;</return>
}</block></then> <else>else <block>{
<enum>enum <name>XML_Error</name> <name>result</name>;</enum>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>textEnd</name> <init>= <expr><name><name>entity</name>-&gt;<name>textPtr</name></name> + <name><name>entity</name>-&gt;<name>textLen</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>entity</name>-&gt;<name>open</name></name> = <name>XML_TRUE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> = <call><name>appendAttributeValue</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>internalEncoding</name></expr></argument>, <argument><expr><name>isCdata</name></expr></argument>,
<argument><expr>(<name>char</name> *)<name><name>entity</name>-&gt;<name>textPtr</name></name></expr></argument>,
<argument><expr>(<name>char</name> *)<name>textEnd</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>entity</name>-&gt;<name>open</name></name> = <name>XML_FALSE</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name></expr>)</condition><then>
<return>return <expr><name>result</name></expr>;</return></then></if>
}</block></else></if>
}</block>
<break>break;</break>
</case><default>default:
<if>if <condition>(<expr><name>enc</name> == <name>encoding</name></expr>)</condition><then>
<expr_stmt><expr><name>eventPtr</name> = <name>ptr</name></expr>;</expr_stmt></then></if>
<return>return <expr><name>XML_ERROR_UNEXPECTED_STATE</name></expr>;</return>
</default>}</block></switch>
<expr_stmt><expr><name>ptr</name> = <name>next</name></expr>;</expr_stmt>
}</block></for>
}</block></decl>
<decl>static enum <name>XML_Error</name>
<name>storeEntityValue</name><argument_list>(<argument><expr><name>XML_Parser</name> <name>parser</name></expr></argument>,
<argument><expr>const <name>ENCODING</name> *<name>enc</name></expr></argument>,
<argument><expr>const <name>char</name> *<name>entityTextPtr</name></expr></argument>,
<argument><expr>const <name>char</name> *<name>entityTextEnd</name></expr></argument>)</argument_list> <block>{
<decl_stmt><decl><type><name>DTD</name> * <specifier>const</specifier></type> <name>dtd</name> <init>= <expr><name>_dtd</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>STRING_POOL</name> *</type><name>pool</name> <init>= <expr>&amp;(<name><name>dtd</name>-&gt;<name>entityValuePool</name></name>)</expr></init></decl>;</decl_stmt>
<enum>enum <name>XML_Error</name> <name>result</name> <expr_stmt><expr>= <name>XML_ERROR_NONE</name></expr>;</expr_stmt></enum>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>oldInEntityValue</name> <init>= <expr><name><name>prologState</name>.<name>inEntityValue</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>prologState</name>.<name>inEntityValue</name></name> = 1</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr>!<name><name>pool</name>-&gt;<name>blocks</name></name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<call><name>poolGrow</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>XML_ERROR_NO_MEMORY</name></expr>;</return></then></if>
}</block></then></if>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>next</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tok</name> <init>= <expr><call><name>XmlEntityValueTok</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>entityTextPtr</name></expr></argument>, <argument><expr><name>entityTextEnd</name></expr></argument>, <argument><expr>&amp;<name>next</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name>tok</name></expr>)</condition> <block>{
<case>case <expr><name>XML_TOK_PARAM_ENTITY_REF</name></expr>:
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>isParamEntity</name> || <name>enc</name> != <name>encoding</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ENTITY</name> *</type><name>entity</name></decl>;</decl_stmt>
<expr_stmt><expr><name>name</name> = <call><name>poolStoreString</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>,
<argument><expr><name>entityTextPtr</name> + <name><name>enc</name>-&gt;<name>minBytesPerChar</name></name></expr></argument>,
<argument><expr><name>next</name> - <name><name>enc</name>-&gt;<name>minBytesPerChar</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>name</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>result</name> = <name>XML_ERROR_NO_MEMORY</name></expr>;</expr_stmt>
<goto>goto <name>endEntityValue</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>entity</name> = (<name>ENTITY</name> *)<call><name>lookup</name><argument_list>(<argument><expr>&amp;<name><name>dtd</name>-&gt;<name>paramEntities</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>poolDiscard</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>entity</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>dtd</name>-&gt;<name>keepProcessing</name></name> = <name><name>dtd</name>-&gt;<name>standalone</name></name></expr>;</expr_stmt>
<goto>goto <name>endEntityValue</name>;</goto>
}</block></then></if>
<if>if <condition>(<expr><name><name>entity</name>-&gt;<name>open</name></name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>enc</name> == <name>encoding</name></expr>)</condition><then>
<expr_stmt><expr><name>eventPtr</name> = <name>entityTextPtr</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>result</name> = <name>XML_ERROR_RECURSIVE_ENTITY_REF</name></expr>;</expr_stmt>
<goto>goto <name>endEntityValue</name>;</goto>
}</block></then></if>
<if>if <condition>(<expr><name><name>entity</name>-&gt;<name>systemId</name></name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>externalEntityRefHandler</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>dtd</name>-&gt;<name>paramEntityRead</name></name> = <name>XML_FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>entity</name>-&gt;<name>open</name></name> = <name>XML_TRUE</name></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>externalEntityRefHandler</name><argument_list>(<argument><expr><name>externalEntityRefHandlerArg</name></expr></argument>,
<argument><expr>0</expr></argument>,
<argument><expr><name><name>entity</name>-&gt;<name>base</name></name></expr></argument>,
<argument><expr><name><name>entity</name>-&gt;<name>systemId</name></name></expr></argument>,
<argument><expr><name><name>entity</name>-&gt;<name>publicId</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>entity</name>-&gt;<name>open</name></name> = <name>XML_FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> = <name>XML_ERROR_EXTERNAL_ENTITY_HANDLING</name></expr>;</expr_stmt>
<goto>goto <name>endEntityValue</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name><name>entity</name>-&gt;<name>open</name></name> = <name>XML_FALSE</name></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name><name>dtd</name>-&gt;<name>paramEntityRead</name></name></expr>)</condition><then>
<expr_stmt><expr><name><name>dtd</name>-&gt;<name>keepProcessing</name></name> = <name><name>dtd</name>-&gt;<name>standalone</name></name></expr>;</expr_stmt></then></if>
}</block></then> <else>else
<expr_stmt><expr><name><name>dtd</name>-&gt;<name>keepProcessing</name></name> = <name><name>dtd</name>-&gt;<name>standalone</name></name></expr>;</expr_stmt></else></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><name><name>entity</name>-&gt;<name>open</name></name> = <name>XML_TRUE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> = <call><name>storeEntityValue</name><argument_list>(<argument><expr><name>parser</name></expr></argument>,
<argument><expr><name>internalEncoding</name></expr></argument>,
<argument><expr>(<name>char</name> *)<name><name>entity</name>-&gt;<name>textPtr</name></name></expr></argument>,
<argument><expr><call>(<name>char</name> *)<argument_list>(<argument><expr><name><name>entity</name>-&gt;<name>textPtr</name></name>
+ <name><name>entity</name>-&gt;<name>textLen</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>entity</name>-&gt;<name>open</name></name> = <name>XML_FALSE</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name></expr>)</condition><then>
<goto>goto <name>endEntityValue</name>;</goto></then></if>
}</block></else></if>
<break>break;</break>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>eventPtr</name> = <name>entityTextPtr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> = <name>XML_ERROR_PARAM_ENTITY_REF</name></expr>;</expr_stmt>
<goto>goto <name>endEntityValue</name>;</goto>
</case><case>case <expr><name>XML_TOK_NONE</name></expr>:
<expr_stmt><expr><name>result</name> = <name>XML_ERROR_NONE</name></expr>;</expr_stmt>
<goto>goto <name>endEntityValue</name>;</goto>
</case><case>case <expr><name>XML_TOK_ENTITY_REF</name></expr>:
</case><case>case <expr><name>XML_TOK_DATA_CHARS</name></expr>:
<if>if <condition>(<expr>!<call><name>poolAppend</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>entityTextPtr</name></expr></argument>, <argument><expr><name>next</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>result</name> = <name>XML_ERROR_NO_MEMORY</name></expr>;</expr_stmt>
<goto>goto <name>endEntityValue</name>;</goto>
}</block></then></if>
<break>break;</break>
</case><case>case <expr><name>XML_TOK_TRAILING_CR</name></expr>:
<expr_stmt><expr><name>next</name> = <name>entityTextPtr</name> + <name><name>enc</name>-&gt;<name>minBytesPerChar</name></name></expr>;</expr_stmt>
</case><case>case <expr><name>XML_TOK_DATA_NEWLINE</name></expr>:
<if>if <condition>(<expr><name><name>pool</name>-&gt;<name>end</name></name> == <name><name>pool</name>-&gt;<name>ptr</name></name> &amp;&amp; !<call><name>poolGrow</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>result</name> = <name>XML_ERROR_NO_MEMORY</name></expr>;</expr_stmt>
<goto>goto <name>endEntityValue</name>;</goto>
}</block></then></if>
<expr_stmt><expr>*(<name><name>pool</name>-&gt;<name>ptr</name></name>)++ = 0xA</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>XML_TOK_CHAR_REF</name></expr>: <block>{
<decl_stmt><decl><type><name>XML_Char</name></type> <name><name>buf</name><index>[<expr><name>XML_ENCODE_MAX</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>XmlCharRefNumber</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>entityTextPtr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>n</name> &lt; 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>enc</name> == <name>encoding</name></expr>)</condition><then>
<expr_stmt><expr><name>eventPtr</name> = <name>entityTextPtr</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>result</name> = <name>XML_ERROR_BAD_CHAR_REF</name></expr>;</expr_stmt>
<goto>goto <name>endEntityValue</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>n</name> = <call><name>XmlEncode</name><argument_list>(<argument><expr><name>n</name></expr></argument>, <argument><expr>(<name>ICHAR</name> *)<name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>n</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>enc</name> == <name>encoding</name></expr>)</condition><then>
<expr_stmt><expr><name>eventPtr</name> = <name>entityTextPtr</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>result</name> = <name>XML_ERROR_BAD_CHAR_REF</name></expr>;</expr_stmt>
<goto>goto <name>endEntityValue</name>;</goto>
}</block></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<if>if <condition>(<expr><name><name>pool</name>-&gt;<name>end</name></name> == <name><name>pool</name>-&gt;<name>ptr</name></name> &amp;&amp; !<call><name>poolGrow</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>result</name> = <name>XML_ERROR_NO_MEMORY</name></expr>;</expr_stmt>
<goto>goto <name>endEntityValue</name>;</goto>
}</block></then></if>
<expr_stmt><expr>*(<name><name>pool</name>-&gt;<name>ptr</name></name>)++ = <name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
}</block></for>
}</block>
<break>break;</break>
</case><case>case <expr><name>XML_TOK_PARTIAL</name></expr>:
<if>if <condition>(<expr><name>enc</name> == <name>encoding</name></expr>)</condition><then>
<expr_stmt><expr><name>eventPtr</name> = <name>entityTextPtr</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>result</name> = <name>XML_ERROR_INVALID_TOKEN</name></expr>;</expr_stmt>
<goto>goto <name>endEntityValue</name>;</goto>
</case><case>case <expr><name>XML_TOK_INVALID</name></expr>:
<if>if <condition>(<expr><name>enc</name> == <name>encoding</name></expr>)</condition><then>
<expr_stmt><expr><name>eventPtr</name> = <name>next</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>result</name> = <name>XML_ERROR_INVALID_TOKEN</name></expr>;</expr_stmt>
<goto>goto <name>endEntityValue</name>;</goto>
</case><default>default:
<if>if <condition>(<expr><name>enc</name> == <name>encoding</name></expr>)</condition><then>
<expr_stmt><expr><name>eventPtr</name> = <name>entityTextPtr</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>result</name> = <name>XML_ERROR_UNEXPECTED_STATE</name></expr>;</expr_stmt>
<goto>goto <name>endEntityValue</name>;</goto>
</default>}</block></switch>
<expr_stmt><expr><name>entityTextPtr</name> = <name>next</name></expr>;</expr_stmt>
}</block></for>
<label><name>endEntityValue</name>:</label>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>prologState</name>.<name>inEntityValue</name></name> = <name>oldInEntityValue</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><name>result</name></expr>;</return>
}</block></decl>
<decl>static <name>void</name> <name>FASTCALL</name>
<name>normalizeLines</name><argument_list>(<argument><expr><name>XML_Char</name> *<name>s</name></expr></argument>)</argument_list> <block>{
<decl_stmt><decl><type><name>XML_Char</name> *</type><name>p</name></decl>;</decl_stmt>
<for>for (<init>;</init><condition>;</condition> <incr><expr><name>s</name>++</expr></incr>) <block>{
<if>if <condition>(<expr>*<name>s</name> == <call><name>XML_T</name><argument_list>(<argument><expr>'\0'</expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return;</return></then></if>
<if>if <condition>(<expr>*<name>s</name> == 0xD</expr>)</condition><then>
<break>break;</break></then></if>
}</block></for>
<expr_stmt><expr><name>p</name> = <name>s</name></expr>;</expr_stmt>
<do>do <block>{
<if>if <condition>(<expr>*<name>s</name> == 0xD</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>p</name>++ = 0xA</expr>;</expr_stmt>
<if>if <condition>(<expr>*++<name>s</name> == 0xA</expr>)</condition><then>
<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt></then></if>
}</block></then> <else>else
<expr_stmt><expr>*<name>p</name>++ = *<name>s</name>++</expr>;</expr_stmt></else></if>
}</block> while <condition>(<expr>*<name>s</name></expr>)</condition>;</do>
<expr_stmt><expr>*<name>p</name> = <call><name>XML_T</name><argument_list>(<argument><expr>'\0'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></decl>
<decl>static <name>int</name>
<name>reportProcessingInstruction</name><argument_list>(<argument><expr><name>XML_Parser</name> <name>parser</name></expr></argument>, <argument><expr>const <name>ENCODING</name> *<name>enc</name></expr></argument>,
<argument><expr>const <name>char</name> *<name>start</name></expr></argument>, <argument><expr>const <name>char</name> *<name>end</name></expr></argument>)</argument_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>target</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Char</name> *</type><name>data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>tem</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>processingInstructionHandler</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>defaultHandler</name></expr>)</condition><then>
<expr_stmt><expr><call><name>reportDefault</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr>1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>start</name> += <name><name>enc</name>-&gt;<name>minBytesPerChar</name></name> * 2</expr>;</expr_stmt>
<expr_stmt><expr><name>tem</name> = <name>start</name> + <call><name>XmlNameLength</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>target</name> = <call><name>poolStoreString</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>tem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>target</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><call><name>poolFinish</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>data</name> = <call><name>poolStoreString</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>,
<argument><expr><call><name>XmlSkipS</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>tem</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>end</name> - <name><name>enc</name>-&gt;<name>minBytesPerChar</name></name>*2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>data</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><call><name>normalizeLines</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>processingInstructionHandler</name><argument_list>(<argument><expr><name>handlerArg</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>poolClear</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></decl>
<decl>static <name>int</name>
<name>reportComment</name><argument_list>(<argument><expr><name>XML_Parser</name> <name>parser</name></expr></argument>, <argument><expr>const <name>ENCODING</name> *<name>enc</name></expr></argument>,
<argument><expr>const <name>char</name> *<name>start</name></expr></argument>, <argument><expr>const <name>char</name> *<name>end</name></expr></argument>)</argument_list> <block>{
<decl_stmt><decl><type><name>XML_Char</name> *</type><name>data</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>commentHandler</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>defaultHandler</name></expr>)</condition><then>
<expr_stmt><expr><call><name>reportDefault</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr>1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>data</name> = <call><name>poolStoreString</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>,
<argument><expr><name>enc</name></expr></argument>,
<argument><expr><name>start</name> + <name><name>enc</name>-&gt;<name>minBytesPerChar</name></name> * 4</expr></argument>,
<argument><expr><name>end</name> - <name><name>enc</name>-&gt;<name>minBytesPerChar</name></name> * 3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>data</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><call><name>normalizeLines</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>commentHandler</name><argument_list>(<argument><expr><name>handlerArg</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>poolClear</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></decl>
<decl>static <name>void</name>
<name>reportDefault</name><argument_list>(<argument><expr><name>XML_Parser</name> <name>parser</name></expr></argument>, <argument><expr>const <name>ENCODING</name> *<name>enc</name></expr></argument>,
<argument><expr>const <name>char</name> *<name>s</name></expr></argument>, <argument><expr>const <name>char</name> *<name>end</name></expr></argument>)</argument_list> <block>{
<if>if <condition>(<expr><call><name>MUST_CONVERT</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> **</type><name>eventPP</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> **</type><name>eventEndPP</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>enc</name> == <name>encoding</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>eventPP</name> = &amp;<name>eventPtr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>eventEndPP</name> = &amp;<name>eventEndPtr</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>eventPP</name> = &amp;(<name><name>openInternalEntities</name>-&gt;<name>internalEventPtr</name></name>)</expr>;</expr_stmt>
<expr_stmt><expr><name>eventEndPP</name> = &amp;(<name><name>openInternalEntities</name>-&gt;<name>internalEventEndPtr</name></name>)</expr>;</expr_stmt>
}</block></else></if>
<do>do <block>{
<decl_stmt><decl><type><name>ICHAR</name> *</type><name>dataPtr</name> <init>= <expr>(<name>ICHAR</name> *)<name>dataBuf</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>XmlConvert</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr>&amp;<name>dataPtr</name></expr></argument>, <argument><expr>(<name>ICHAR</name> *)<name>dataBufEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>eventEndPP</name> = <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>defaultHandler</name><argument_list>(<argument><expr><name>handlerArg</name></expr></argument>, <argument><expr><name>dataBuf</name></expr></argument>, <argument><expr><call>(<name>int</name>)<argument_list>(<argument><expr><name>dataPtr</name> - (<name>ICHAR</name> *)<name>dataBuf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>eventPP</name> = <name>s</name></expr>;</expr_stmt>
}</block> while <condition>(<expr><name>s</name> != <name>end</name></expr>)</condition>;</do>
}</block></then> <else>else
<expr_stmt><expr><call><name>defaultHandler</name><argument_list>(<argument><expr><name>handlerArg</name></expr></argument>, <argument><expr>(<name>XML_Char</name> *)<name>s</name></expr></argument>, <argument><expr><call>(<name>int</name>)<argument_list>(<argument><expr>(<name>XML_Char</name> *)<name>end</name> - (<name>XML_Char</name> *)<name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
}</block></decl>
<decl>static <name>int</name>
<name>defineAttribute</name><argument_list>(<argument><expr><name>ELEMENT_TYPE</name> *<name>type</name></expr></argument>, <argument><expr><name>ATTRIBUTE_ID</name> *<name>attId</name></expr></argument>, <argument><expr><name>XML_Bool</name> <name>isCdata</name></expr></argument>,
<argument><expr><name>XML_Bool</name> <name>isId</name></expr></argument>, <argument><expr>const <name>XML_Char</name> *<name>value</name></expr></argument>, <argument><expr><name>XML_Parser</name> <name>parser</name></expr></argument>)</argument_list> <block>{
<decl_stmt><decl><type><name>DEFAULT_ATTRIBUTE</name> *</type><name>att</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>value</name> || <name>isId</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>type</name>-&gt;<name>nDefaultAtts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
<if>if <condition>(<expr><name>attId</name> == <name><name>type</name>-&gt;<name>defaultAtts</name><index>[<expr><name>i</name></expr>]</index></name>.<name>id</name></expr>)</condition><then>
<return>return <expr>1</expr>;</return></then></if></for>
<if>if <condition>(<expr><name>isId</name> &amp;&amp; !<name><name>type</name>-&gt;<name>idAtt</name></name> &amp;&amp; !<name><name>attId</name>-&gt;<name>xmlns</name></name></expr>)</condition><then>
<expr_stmt><expr><name><name>type</name>-&gt;<name>idAtt</name></name> = <name>attId</name></expr>;</expr_stmt></then></if>
}</block></then></if>
<if>if <condition>(<expr><name><name>type</name>-&gt;<name>nDefaultAtts</name></name> == <name><name>type</name>-&gt;<name>allocDefaultAtts</name></name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>type</name>-&gt;<name>allocDefaultAtts</name></name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>type</name>-&gt;<name>allocDefaultAtts</name></name> = 8</expr>;</expr_stmt>
<expr_stmt><expr><name><name>type</name>-&gt;<name>defaultAtts</name></name> = (<name>DEFAULT_ATTRIBUTE</name> *)<call><name>MALLOC</name><argument_list>(<argument><expr><name><name>type</name>-&gt;<name>allocDefaultAtts</name></name>
* <sizeof>sizeof<argument_list>(<argument><expr><name>DEFAULT_ATTRIBUTE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name><name>type</name>-&gt;<name>defaultAtts</name></name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>DEFAULT_ATTRIBUTE</name> *</type><name>temp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><name><name>type</name>-&gt;<name>allocDefaultAtts</name></name> * 2</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>temp</name> = (<name>DEFAULT_ATTRIBUTE</name> *)
<call><name>REALLOC</name><argument_list>(<argument><expr><name><name>type</name>-&gt;<name>defaultAtts</name></name></expr></argument>, <argument><expr>(<name>count</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>DEFAULT_ATTRIBUTE</name></expr></argument>)</argument_list></sizeof>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>temp</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><name><name>type</name>-&gt;<name>allocDefaultAtts</name></name> = <name>count</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>type</name>-&gt;<name>defaultAtts</name></name> = <name>temp</name></expr>;</expr_stmt>
}</block></else></if>
}</block></then></if>
<expr_stmt><expr><name>att</name> = <name><name>type</name>-&gt;<name>defaultAtts</name></name> + <name><name>type</name>-&gt;<name>nDefaultAtts</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>att</name>-&gt;<name>id</name></name> = <name>attId</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>att</name>-&gt;<name>value</name></name> = <name>value</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>att</name>-&gt;<name>isCdata</name></name> = <name>isCdata</name></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>isCdata</name></expr>)</condition><then>
<expr_stmt><expr><name><name>attId</name>-&gt;<name>maybeTokenized</name></name> = <name>XML_TRUE</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name><name>type</name>-&gt;<name>nDefaultAtts</name></name> += 1</expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></decl>
<decl>static <name>int</name>
<name>setElementTypePrefix</name><argument_list>(<argument><expr><name>XML_Parser</name> <name>parser</name></expr></argument>, <argument><expr><name>ELEMENT_TYPE</name> *<name>elementType</name></expr></argument>)</argument_list> <block>{
<decl_stmt><decl><type><name>DTD</name> * <specifier>const</specifier></type> <name>dtd</name> <init>= <expr><name>_dtd</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>name</name></decl>;</decl_stmt>
<for>for (<init><expr><name>name</name> = <name><name>elementType</name>-&gt;<name>name</name></name></expr>;</init> <condition><expr>*<name>name</name></expr>;</condition> <incr><expr><name>name</name>++</expr></incr>) <block>{
<if>if <condition>(<expr>*<name>name</name> == <call><name>XML_T</name><argument_list>(<argument><expr>':'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PREFIX</name> *</type><name>prefix</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>s</name></decl>;</decl_stmt>
<for>for (<init><expr><name>s</name> = <name><name>elementType</name>-&gt;<name>name</name></name></expr>;</init> <condition><expr><name>s</name> != <name>name</name></expr>;</condition> <incr><expr><name>s</name>++</expr></incr>) <block>{
<if>if <condition>(<expr>!<call><name>poolAppendChar</name><argument_list>(<argument><expr>&amp;<name><name>dtd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>*<name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
}</block></for>
<if>if <condition>(<expr>!<call><name>poolAppendChar</name><argument_list>(<argument><expr>&amp;<name><name>dtd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><call><name>XML_T</name><argument_list>(<argument><expr>'\0'</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><name>prefix</name> = (<name>PREFIX</name> *)<call><name>lookup</name><argument_list>(<argument><expr>&amp;<name><name>dtd</name>-&gt;<name>prefixes</name></name></expr></argument>, <argument><expr><call><name>poolStart</name><argument_list>(<argument><expr>&amp;<name><name>dtd</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PREFIX</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>prefix</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<if>if <condition>(<expr><name><name>prefix</name>-&gt;<name>name</name></name> == <call><name>poolStart</name><argument_list>(<argument><expr>&amp;<name><name>dtd</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><call><name>poolFinish</name><argument_list>(<argument><expr>&amp;<name><name>dtd</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><call><name>poolDiscard</name><argument_list>(<argument><expr>&amp;<name><name>dtd</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<expr_stmt><expr><name><name>elementType</name>-&gt;<name>prefix</name></name> = <name>prefix</name></expr>;</expr_stmt>
}</block></then></if>
}</block></for>
<return>return <expr>1</expr>;</return>
}</block></decl>
<decl>static <name>ATTRIBUTE_ID</name> *
<name>getAttributeId</name><argument_list>(<argument><expr><name>XML_Parser</name> <name>parser</name></expr></argument>, <argument><expr>const <name>ENCODING</name> *<name>enc</name></expr></argument>,
<argument><expr>const <name>char</name> *<name>start</name></expr></argument>, <argument><expr>const <name>char</name> *<name>end</name></expr></argument>)</argument_list> <block>{
<decl_stmt><decl><type><name>DTD</name> * <specifier>const</specifier></type> <name>dtd</name> <init>= <expr><name>_dtd</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ATTRIBUTE_ID</name> *</type><name>id</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>name</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>poolAppendChar</name><argument_list>(<argument><expr>&amp;<name><name>dtd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><call><name>XML_T</name><argument_list>(<argument><expr>'\0'</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>name</name> = <call><name>poolStoreString</name><argument_list>(<argument><expr>&amp;<name><name>dtd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>name</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr>++<name>name</name></expr>;</expr_stmt>
<expr_stmt><expr><name>id</name> = (<name>ATTRIBUTE_ID</name> *)<call><name>lookup</name><argument_list>(<argument><expr>&amp;<name><name>dtd</name>-&gt;<name>attributeIds</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ATTRIBUTE_ID</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>id</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name><name>id</name>-&gt;<name>name</name></name> != <name>name</name></expr>)</condition><then>
<expr_stmt><expr><call><name>poolDiscard</name><argument_list>(<argument><expr>&amp;<name><name>dtd</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else <block>{
<expr_stmt><expr><call><name>poolFinish</name><argument_list>(<argument><expr>&amp;<name><name>dtd</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>ns</name></expr>)</condition><then>
<empty_stmt>;</empty_stmt></then>
<else>else <if>if <condition>(<expr><name><name>name</name><index>[<expr>0</expr>]</index></name> == <call><name>XML_T</name><argument_list>(<argument><expr>'x'</expr></argument>)</argument_list></call>
&amp;&amp; <name><name>name</name><index>[<expr>1</expr>]</index></name> == <call><name>XML_T</name><argument_list>(<argument><expr>'m'</expr></argument>)</argument_list></call>
&amp;&amp; <name><name>name</name><index>[<expr>2</expr>]</index></name> == <call><name>XML_T</name><argument_list>(<argument><expr>'l'</expr></argument>)</argument_list></call>
&amp;&amp; <name><name>name</name><index>[<expr>3</expr>]</index></name> == <call><name>XML_T</name><argument_list>(<argument><expr>'n'</expr></argument>)</argument_list></call>
&amp;&amp; <name><name>name</name><index>[<expr>4</expr>]</index></name> == <call><name>XML_T</name><argument_list>(<argument><expr>'s'</expr></argument>)</argument_list></call>
&amp;&amp; (<name><name>name</name><index>[<expr>5</expr>]</index></name> == <call><name>XML_T</name><argument_list>(<argument><expr>'\0'</expr></argument>)</argument_list></call> || <name><name>name</name><index>[<expr>5</expr>]</index></name> == <call><name>XML_T</name><argument_list>(<argument><expr>':'</expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>name</name><index>[<expr>5</expr>]</index></name> == <call><name>XML_T</name><argument_list>(<argument><expr>'\0'</expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name><name>id</name>-&gt;<name>prefix</name></name> = &amp;<name><name>dtd</name>-&gt;<name>defaultPrefix</name></name></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name><name>id</name>-&gt;<name>prefix</name></name> = (<name>PREFIX</name> *)<call><name>lookup</name><argument_list>(<argument><expr>&amp;<name><name>dtd</name>-&gt;<name>prefixes</name></name></expr></argument>, <argument><expr><name>name</name> + 6</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PREFIX</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<expr_stmt><expr><name><name>id</name>-&gt;<name>xmlns</name></name> = <name>XML_TRUE</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name><name>name</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<if>if <condition>(<expr><name><name>name</name><index>[<expr><name>i</name></expr>]</index></name> == <call><name>XML_T</name><argument_list>(<argument><expr>':'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
<for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name>i</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
<if>if <condition>(<expr>!<call><name>poolAppendChar</name><argument_list>(<argument><expr>&amp;<name><name>dtd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>name</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
}</block></for>
<if>if <condition>(<expr>!<call><name>poolAppendChar</name><argument_list>(<argument><expr>&amp;<name><name>dtd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><call><name>XML_T</name><argument_list>(<argument><expr>'\0'</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>id</name>-&gt;<name>prefix</name></name> = (<name>PREFIX</name> *)<call><name>lookup</name><argument_list>(<argument><expr>&amp;<name><name>dtd</name>-&gt;<name>prefixes</name></name></expr></argument>, <argument><expr><call><name>poolStart</name><argument_list>(<argument><expr>&amp;<name><name>dtd</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PREFIX</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name><name>id</name>-&gt;<name>prefix</name></name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name><name>id</name>-&gt;<name>prefix</name>-&gt;<name>name</name></name> == <call><name>poolStart</name><argument_list>(<argument><expr>&amp;<name><name>dtd</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><call><name>poolFinish</name><argument_list>(<argument><expr>&amp;<name><name>dtd</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><call><name>poolDiscard</name><argument_list>(<argument><expr>&amp;<name><name>dtd</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<break>break;</break>
}</block></then></if>
}</block></for>
}</block></else></if></else></if>
}</block></else></if>
<return>return <expr><name>id</name></expr>;</return>
}</block></decl>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONTEXT_SEP</name></cpp:macro> <cpp:value>XML_T('\f')</cpp:value></cpp:define>
<decl>static const <name>XML_Char</name> *
<name>getContext</name><argument_list>(<argument><expr><name>XML_Parser</name> <name>parser</name></expr></argument>)</argument_list> <block>{
<decl_stmt><decl><type><name>DTD</name> * <specifier>const</specifier></type> <name>dtd</name> <init>= <expr><name>_dtd</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HASH_TABLE_ITER</name></type> <name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Bool</name></type> <name>needSep</name> <init>= <expr><name>XML_FALSE</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>dtd</name>-&gt;<name>defaultPrefix</name>.<name>binding</name></name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>poolAppendChar</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>, <argument><expr><call><name>XML_T</name><argument_list>(<argument><expr>'='</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>len</name> = <name><name>dtd</name>-&gt;<name>defaultPrefix</name>.<name>binding</name>-&gt;<name>uriLen</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>namespaceSeparator</name></expr>)</condition><then>
<expr_stmt><expr><name>len</name>--</expr>;</expr_stmt></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
<if>if <condition>(<expr>!<call><name>poolAppendChar</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>, <argument><expr><name><name>dtd</name>-&gt;<name>defaultPrefix</name>.<name>binding</name>-&gt;<name>uri</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if></for>
<expr_stmt><expr><name>needSep</name> = <name>XML_TRUE</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>hashTableIterInit</name><argument_list>(<argument><expr>&amp;<name>iter</name></expr></argument>, <argument><expr>&amp;(<name><name>dtd</name>-&gt;<name>prefixes</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PREFIX</name> *</type><name>prefix</name> <init>= <expr>(<name>PREFIX</name> *)<call><name>hashTableIterNext</name><argument_list>(<argument><expr>&amp;<name>iter</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>prefix</name></expr>)</condition><then>
<break>break;</break></then></if>
<if>if <condition>(<expr>!<name><name>prefix</name>-&gt;<name>binding</name></name></expr>)</condition><then>
<continue>continue;</continue></then></if>
<if>if <condition>(<expr><name>needSep</name> &amp;&amp; !<call><name>poolAppendChar</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>, <argument><expr><name>CONTEXT_SEP</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<for>for (<init><expr><name>s</name> = <name><name>prefix</name>-&gt;<name>name</name></name></expr>;</init> <condition><expr>*<name>s</name></expr>;</condition> <incr><expr><name>s</name>++</expr></incr>)
<if>if <condition>(<expr>!<call><name>poolAppendChar</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>, <argument><expr>*<name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if></for>
<if>if <condition>(<expr>!<call><name>poolAppendChar</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>, <argument><expr><call><name>XML_T</name><argument_list>(<argument><expr>'='</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>len</name> = <name><name>prefix</name>-&gt;<name>binding</name>-&gt;<name>uriLen</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>namespaceSeparator</name></expr>)</condition><then>
<expr_stmt><expr><name>len</name>--</expr>;</expr_stmt></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
<if>if <condition>(<expr>!<call><name>poolAppendChar</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>, <argument><expr><name><name>prefix</name>-&gt;<name>binding</name>-&gt;<name>uri</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if></for>
<expr_stmt><expr><name>needSep</name> = <name>XML_TRUE</name></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><call><name>hashTableIterInit</name><argument_list>(<argument><expr>&amp;<name>iter</name></expr></argument>, <argument><expr>&amp;(<name><name>dtd</name>-&gt;<name>generalEntities</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ENTITY</name> *</type><name>e</name> <init>= <expr>(<name>ENTITY</name> *)<call><name>hashTableIterNext</name><argument_list>(<argument><expr>&amp;<name>iter</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>e</name></expr>)</condition><then>
<break>break;</break></then></if>
<if>if <condition>(<expr>!<name><name>e</name>-&gt;<name>open</name></name></expr>)</condition><then>
<continue>continue;</continue></then></if>
<if>if <condition>(<expr><name>needSep</name> &amp;&amp; !<call><name>poolAppendChar</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>, <argument><expr><name>CONTEXT_SEP</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<for>for (<init><expr><name>s</name> = <name><name>e</name>-&gt;<name>name</name></name></expr>;</init> <condition><expr>*<name>s</name></expr>;</condition> <incr><expr><name>s</name>++</expr></incr>)
<if>if <condition>(<expr>!<call><name>poolAppendChar</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>, <argument><expr>*<name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if></for>
<expr_stmt><expr><name>needSep</name> = <name>XML_TRUE</name></expr>;</expr_stmt>
}</block></for>
<if>if <condition>(<expr>!<call><name>poolAppendChar</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>, <argument><expr><call><name>XML_T</name><argument_list>(<argument><expr>'\0'</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><name><name>tempPool</name>.<name>start</name></name></expr>;</return>
}</block></decl>
<decl>static <name>XML_Bool</name>
<name>setContext</name><argument_list>(<argument><expr><name>XML_Parser</name> <name>parser</name></expr></argument>, <argument><expr>const <name>XML_Char</name> *<name>context</name></expr></argument>)</argument_list> <block>{
<decl_stmt><decl><type><name>DTD</name> * <specifier>const</specifier></type> <name>dtd</name> <init>= <expr><name>_dtd</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>s</name> <init>= <expr><name>context</name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr>*<name>context</name> != <call><name>XML_T</name><argument_list>(<argument><expr>'\0'</expr></argument>)</argument_list></call></expr>)</condition> <block>{
<if>if <condition>(<expr>*<name>s</name> == <name>CONTEXT_SEP</name> || *<name>s</name> == <call><name>XML_T</name><argument_list>(<argument><expr>'\0'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>ENTITY</name> *</type><name>e</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>poolAppendChar</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>, <argument><expr><call><name>XML_T</name><argument_list>(<argument><expr>'\0'</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>XML_FALSE</name></expr>;</return></then></if>
<expr_stmt><expr><name>e</name> = (<name>ENTITY</name> *)<call><name>lookup</name><argument_list>(<argument><expr>&amp;<name><name>dtd</name>-&gt;<name>generalEntities</name></name></expr></argument>, <argument><expr><call><name>poolStart</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>e</name></expr>)</condition><then>
<expr_stmt><expr><name><name>e</name>-&gt;<name>open</name></name> = <name>XML_TRUE</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr>*<name>s</name> != <call><name>XML_T</name><argument_list>(<argument><expr>'\0'</expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>context</name> = <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>poolDiscard</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr>*<name>s</name> == <call><name>XML_T</name><argument_list>(<argument><expr>'='</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PREFIX</name> *</type><name>prefix</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>poolLength</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
<expr_stmt><expr><name>prefix</name> = &amp;<name><name>dtd</name>-&gt;<name>defaultPrefix</name></name></expr>;</expr_stmt></then>
<else>else <block>{
<if>if <condition>(<expr>!<call><name>poolAppendChar</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>, <argument><expr><call><name>XML_T</name><argument_list>(<argument><expr>'\0'</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>XML_FALSE</name></expr>;</return></then></if>
<expr_stmt><expr><name>prefix</name> = (<name>PREFIX</name> *)<call><name>lookup</name><argument_list>(<argument><expr>&amp;<name><name>dtd</name>-&gt;<name>prefixes</name></name></expr></argument>, <argument><expr><call><name>poolStart</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PREFIX</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>prefix</name></expr>)</condition><then>
<return>return <expr><name>XML_FALSE</name></expr>;</return></then></if>
<if>if <condition>(<expr><name><name>prefix</name>-&gt;<name>name</name></name> == <call><name>poolStart</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>prefix</name>-&gt;<name>name</name></name> = <call><name>poolCopyString</name><argument_list>(<argument><expr>&amp;<name><name>dtd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>prefix</name>-&gt;<name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name><name>prefix</name>-&gt;<name>name</name></name></expr>)</condition><then>
<return>return <expr><name>XML_FALSE</name></expr>;</return></then></if>
}</block></then></if>
<expr_stmt><expr><call><name>poolDiscard</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<for>for (<init><expr><name>context</name> = <name>s</name> + 1</expr>;</init>
<condition><expr>*<name>context</name> != <name>CONTEXT_SEP</name> &amp;&amp; *<name>context</name> != <call><name>XML_T</name><argument_list>(<argument><expr>'\0'</expr></argument>)</argument_list></call></expr>;</condition>
<incr><expr><name>context</name>++</expr></incr>)
<if>if <condition>(<expr>!<call><name>poolAppendChar</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>, <argument><expr>*<name>context</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>XML_FALSE</name></expr>;</return></then></if></for>
<if>if <condition>(<expr>!<call><name>poolAppendChar</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>, <argument><expr><call><name>XML_T</name><argument_list>(<argument><expr>'\0'</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>XML_FALSE</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>addBinding</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>poolStart</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr>&amp;<name>inheritedBindings</name></expr></argument>)</argument_list></call> != <name>XML_ERROR_NONE</name></expr>)</condition><then>
<return>return <expr><name>XML_FALSE</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>poolDiscard</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>*<name>context</name> != <call><name>XML_T</name><argument_list>(<argument><expr>'\0'</expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr>++<name>context</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>s</name> = <name>context</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<if>if <condition>(<expr>!<call><name>poolAppendChar</name><argument_list>(<argument><expr>&amp;<name>tempPool</name></expr></argument>, <argument><expr>*<name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>XML_FALSE</name></expr>;</return></then></if>
<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt>
}</block></else></if></else></if>
}</block></while>
<return>return <expr><name>XML_TRUE</name></expr>;</return>
}</block></decl>
<decl>static <name>void</name> <name>FASTCALL</name>
<name>normalizePublicId</name><argument_list>(<argument><expr><name>XML_Char</name> *<name>publicId</name></expr></argument>)</argument_list> <block>{
<decl_stmt><decl><type><name>XML_Char</name> *</type><name>p</name> <init>= <expr><name>publicId</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Char</name> *</type><name>s</name></decl>;</decl_stmt>
<for>for (<init><expr><name>s</name> = <name>publicId</name></expr>;</init> <condition><expr>*<name>s</name></expr>;</condition> <incr><expr><name>s</name>++</expr></incr>) <block>{
<switch>switch <condition>(<expr>*<name>s</name></expr>)</condition> <block>{
<case>case <expr>0x20</expr>:
</case><case>case <expr>0xD</expr>:
</case><case>case <expr>0xA</expr>:
<if>if <condition>(<expr><name>p</name> != <name>publicId</name> &amp;&amp; <name><name>p</name><index>[<expr>-1</expr>]</index></name> != 0x20</expr>)</condition><then>
<expr_stmt><expr>*<name>p</name>++ = 0x20</expr>;</expr_stmt></then></if>
<break>break;</break>
</case><default>default:
<expr_stmt><expr>*<name>p</name>++ = *<name>s</name></expr>;</expr_stmt>
</default>}</block></switch>
}</block></for>
<if>if <condition>(<expr><name>p</name> != <name>publicId</name> &amp;&amp; <name><name>p</name><index>[<expr>-1</expr>]</index></name> == 0x20</expr>)</condition><then>
<expr_stmt><expr>--<name>p</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr>*<name>p</name> = <call><name>XML_T</name><argument_list>(<argument><expr>'\0'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></decl>
<decl>static <name>DTD</name> *
<name>dtdCreate</name><argument_list>(<argument><expr>const <name>XML_Memory_Handling_Suite</name> *<name>ms</name></expr></argument>)</argument_list> <block>{
<decl_stmt><decl><type><name>DTD</name> *</type><name>p</name> <init>= <expr>(<name>DTD</name> *)<call><name><name>ms</name>-&gt;<name>malloc_fcn</name></name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DTD</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>p</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>p</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>poolInit</name><argument_list>(<argument><expr>&amp;(<name><name>p</name>-&gt;<name>pool</name></name>)</expr></argument>, <argument><expr><name>ms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>poolInit</name><argument_list>(<argument><expr>&amp;(<name><name>p</name>-&gt;<name>entityValuePool</name></name>)</expr></argument>, <argument><expr><name>ms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hashTableInit</name><argument_list>(<argument><expr>&amp;(<name><name>p</name>-&gt;<name>generalEntities</name></name>)</expr></argument>, <argument><expr><name>ms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hashTableInit</name><argument_list>(<argument><expr>&amp;(<name><name>p</name>-&gt;<name>elementTypes</name></name>)</expr></argument>, <argument><expr><name>ms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hashTableInit</name><argument_list>(<argument><expr>&amp;(<name><name>p</name>-&gt;<name>attributeIds</name></name>)</expr></argument>, <argument><expr><name>ms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hashTableInit</name><argument_list>(<argument><expr>&amp;(<name><name>p</name>-&gt;<name>prefixes</name></name>)</expr></argument>, <argument><expr><name>ms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>p</name>-&gt;<name>paramEntityRead</name></name> = <name>XML_FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hashTableInit</name><argument_list>(<argument><expr>&amp;(<name><name>p</name>-&gt;<name>paramEntities</name></name>)</expr></argument>, <argument><expr><name>ms</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name><name>p</name>-&gt;<name>defaultPrefix</name>.<name>name</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name>-&gt;<name>defaultPrefix</name>.<name>binding</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name>-&gt;<name>in_eldecl</name></name> = <name>XML_FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name>-&gt;<name>scaffIndex</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name>-&gt;<name>scaffold</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name>-&gt;<name>scaffLevel</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name>-&gt;<name>scaffSize</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name>-&gt;<name>scaffCount</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name>-&gt;<name>contentStringLen</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name>-&gt;<name>keepProcessing</name></name> = <name>XML_TRUE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name>-&gt;<name>hasParamEntityRefs</name></name> = <name>XML_FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name>-&gt;<name>standalone</name></name> = <name>XML_FALSE</name></expr>;</expr_stmt>
<return>return <expr><name>p</name></expr>;</return>
}</block></decl>
<decl>static <name>void</name>
<name>dtdReset</name><argument_list>(<argument><expr><name>DTD</name> *<name>p</name></expr></argument>, <argument><expr>const <name>XML_Memory_Handling_Suite</name> *<name>ms</name></expr></argument>)</argument_list> <block>{
<decl_stmt><decl><type><name>HASH_TABLE_ITER</name></type> <name>iter</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>hashTableIterInit</name><argument_list>(<argument><expr>&amp;<name>iter</name></expr></argument>, <argument><expr>&amp;(<name><name>p</name>-&gt;<name>elementTypes</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<decl_stmt><decl><type><name>ELEMENT_TYPE</name> *</type><name>e</name> <init>= <expr>(<name>ELEMENT_TYPE</name> *)<call><name>hashTableIterNext</name><argument_list>(<argument><expr>&amp;<name>iter</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>e</name></expr>)</condition><then>
<break>break;</break></then></if>
<if>if <condition>(<expr><name><name>e</name>-&gt;<name>allocDefaultAtts</name></name> != 0</expr>)</condition><then>
<expr_stmt><expr><call><name><name>ms</name>-&gt;<name>free_fcn</name></name><argument_list>(<argument><expr><name><name>e</name>-&gt;<name>defaultAtts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></for>
<expr_stmt><expr><call><name>hashTableClear</name><argument_list>(<argument><expr>&amp;(<name><name>p</name>-&gt;<name>generalEntities</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>p</name>-&gt;<name>paramEntityRead</name></name> = <name>XML_FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hashTableClear</name><argument_list>(<argument><expr>&amp;(<name><name>p</name>-&gt;<name>paramEntities</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>hashTableClear</name><argument_list>(<argument><expr>&amp;(<name><name>p</name>-&gt;<name>elementTypes</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hashTableClear</name><argument_list>(<argument><expr>&amp;(<name><name>p</name>-&gt;<name>attributeIds</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hashTableClear</name><argument_list>(<argument><expr>&amp;(<name><name>p</name>-&gt;<name>prefixes</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>poolClear</name><argument_list>(<argument><expr>&amp;(<name><name>p</name>-&gt;<name>pool</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>poolClear</name><argument_list>(<argument><expr>&amp;(<name><name>p</name>-&gt;<name>entityValuePool</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name>-&gt;<name>defaultPrefix</name>.<name>name</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name>-&gt;<name>defaultPrefix</name>.<name>binding</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name>-&gt;<name>in_eldecl</name></name> = <name>XML_FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>ms</name>-&gt;<name>free_fcn</name></name><argument_list>(<argument><expr><name><name>p</name>-&gt;<name>scaffIndex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name>-&gt;<name>scaffIndex</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>ms</name>-&gt;<name>free_fcn</name></name><argument_list>(<argument><expr><name><name>p</name>-&gt;<name>scaffold</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name>-&gt;<name>scaffold</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name>-&gt;<name>scaffLevel</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name>-&gt;<name>scaffSize</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name>-&gt;<name>scaffCount</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name>-&gt;<name>contentStringLen</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name>-&gt;<name>keepProcessing</name></name> = <name>XML_TRUE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name>-&gt;<name>hasParamEntityRefs</name></name> = <name>XML_FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name>-&gt;<name>standalone</name></name> = <name>XML_FALSE</name></expr>;</expr_stmt>
}</block></decl>
<decl>static <name>void</name>
<name>dtdDestroy</name><argument_list>(<argument><expr><name>DTD</name> *<name>p</name></expr></argument>, <argument><expr><name>XML_Bool</name> <name>isDocEntity</name></expr></argument>, <argument><expr>const <name>XML_Memory_Handling_Suite</name> *<name>ms</name></expr></argument>)</argument_list> <block>{
<decl_stmt><decl><type><name>HASH_TABLE_ITER</name></type> <name>iter</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>hashTableIterInit</name><argument_list>(<argument><expr>&amp;<name>iter</name></expr></argument>, <argument><expr>&amp;(<name><name>p</name>-&gt;<name>elementTypes</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<decl_stmt><decl><type><name>ELEMENT_TYPE</name> *</type><name>e</name> <init>= <expr>(<name>ELEMENT_TYPE</name> *)<call><name>hashTableIterNext</name><argument_list>(<argument><expr>&amp;<name>iter</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>e</name></expr>)</condition><then>
<break>break;</break></then></if>
<if>if <condition>(<expr><name><name>e</name>-&gt;<name>allocDefaultAtts</name></name> != 0</expr>)</condition><then>
<expr_stmt><expr><call><name><name>ms</name>-&gt;<name>free_fcn</name></name><argument_list>(<argument><expr><name><name>e</name>-&gt;<name>defaultAtts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></for>
<expr_stmt><expr><call><name>hashTableDestroy</name><argument_list>(<argument><expr>&amp;(<name><name>p</name>-&gt;<name>generalEntities</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>hashTableDestroy</name><argument_list>(<argument><expr>&amp;(<name><name>p</name>-&gt;<name>paramEntities</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>hashTableDestroy</name><argument_list>(<argument><expr>&amp;(<name><name>p</name>-&gt;<name>elementTypes</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hashTableDestroy</name><argument_list>(<argument><expr>&amp;(<name><name>p</name>-&gt;<name>attributeIds</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>hashTableDestroy</name><argument_list>(<argument><expr>&amp;(<name><name>p</name>-&gt;<name>prefixes</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>poolDestroy</name><argument_list>(<argument><expr>&amp;(<name><name>p</name>-&gt;<name>pool</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>poolDestroy</name><argument_list>(<argument><expr>&amp;(<name><name>p</name>-&gt;<name>entityValuePool</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>isDocEntity</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name><name>ms</name>-&gt;<name>free_fcn</name></name><argument_list>(<argument><expr><name><name>p</name>-&gt;<name>scaffIndex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name><name>ms</name>-&gt;<name>free_fcn</name></name><argument_list>(<argument><expr><name><name>p</name>-&gt;<name>scaffold</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name><name>ms</name>-&gt;<name>free_fcn</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></decl>
<decl>static <name>int</name>
<name>dtdCopy</name><argument_list>(<argument><expr><name>DTD</name> *<name>newDtd</name></expr></argument>, <argument><expr>const <name>DTD</name> *<name>oldDtd</name></expr></argument>, <argument><expr>const <name>XML_Memory_Handling_Suite</name> *<name>ms</name></expr></argument>)</argument_list> <block>{
<decl_stmt><decl><type><name>HASH_TABLE_ITER</name></type> <name>iter</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>hashTableIterInit</name><argument_list>(<argument><expr>&amp;<name>iter</name></expr></argument>, <argument><expr>&amp;(<name><name>oldDtd</name>-&gt;<name>prefixes</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>PREFIX</name> *</type><name>oldP</name> <init>= <expr>(<name>PREFIX</name> *)<call><name>hashTableIterNext</name><argument_list>(<argument><expr>&amp;<name>iter</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>oldP</name></expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr><name>name</name> = <call><name>poolCopyString</name><argument_list>(<argument><expr>&amp;(<name><name>newDtd</name>-&gt;<name>pool</name></name>)</expr></argument>, <argument><expr><name><name>oldP</name>-&gt;<name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>name</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>lookup</name><argument_list>(<argument><expr>&amp;(<name><name>newDtd</name>-&gt;<name>prefixes</name></name>)</expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PREFIX</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
}</block></for>
<expr_stmt><expr><call><name>hashTableIterInit</name><argument_list>(<argument><expr>&amp;<name>iter</name></expr></argument>, <argument><expr>&amp;(<name><name>oldDtd</name>-&gt;<name>attributeIds</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<decl_stmt><decl><type><name>ATTRIBUTE_ID</name> *</type><name>newA</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ATTRIBUTE_ID</name> *</type><name>oldA</name> <init>= <expr>(<name>ATTRIBUTE_ID</name> *)<call><name>hashTableIterNext</name><argument_list>(<argument><expr>&amp;<name>iter</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>oldA</name></expr>)</condition><then>
<break>break;</break></then></if>
<if>if <condition>(<expr>!<call><name>poolAppendChar</name><argument_list>(<argument><expr>&amp;(<name><name>newDtd</name>-&gt;<name>pool</name></name>)</expr></argument>, <argument><expr><call><name>XML_T</name><argument_list>(<argument><expr>'\0'</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><name>name</name> = <call><name>poolCopyString</name><argument_list>(<argument><expr>&amp;(<name><name>newDtd</name>-&gt;<name>pool</name></name>)</expr></argument>, <argument><expr><name><name>oldA</name>-&gt;<name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>name</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr>++<name>name</name></expr>;</expr_stmt>
<expr_stmt><expr><name>newA</name> = (<name>ATTRIBUTE_ID</name> *)<call><name>lookup</name><argument_list>(<argument><expr>&amp;(<name><name>newDtd</name>-&gt;<name>attributeIds</name></name>)</expr></argument>, <argument><expr><name>name</name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ATTRIBUTE_ID</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>newA</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><name><name>newA</name>-&gt;<name>maybeTokenized</name></name> = <name><name>oldA</name>-&gt;<name>maybeTokenized</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>oldA</name>-&gt;<name>prefix</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>newA</name>-&gt;<name>xmlns</name></name> = <name><name>oldA</name>-&gt;<name>xmlns</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>oldA</name>-&gt;<name>prefix</name></name> == &amp;<name><name>oldDtd</name>-&gt;<name>defaultPrefix</name></name></expr>)</condition><then>
<expr_stmt><expr><name><name>newA</name>-&gt;<name>prefix</name></name> = &amp;<name><name>newDtd</name>-&gt;<name>defaultPrefix</name></name></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name><name>newA</name>-&gt;<name>prefix</name></name> = (<name>PREFIX</name> *)<call><name>lookup</name><argument_list>(<argument><expr>&amp;(<name><name>newDtd</name>-&gt;<name>prefixes</name></name>)</expr></argument>,
<argument><expr><name><name>oldA</name>-&gt;<name>prefix</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
}</block></then></if>
}</block></for>
<expr_stmt><expr><call><name>hashTableIterInit</name><argument_list>(<argument><expr>&amp;<name>iter</name></expr></argument>, <argument><expr>&amp;(<name><name>oldDtd</name>-&gt;<name>elementTypes</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ELEMENT_TYPE</name> *</type><name>newE</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ELEMENT_TYPE</name> *</type><name>oldE</name> <init>= <expr>(<name>ELEMENT_TYPE</name> *)<call><name>hashTableIterNext</name><argument_list>(<argument><expr>&amp;<name>iter</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>oldE</name></expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr><name>name</name> = <call><name>poolCopyString</name><argument_list>(<argument><expr>&amp;(<name><name>newDtd</name>-&gt;<name>pool</name></name>)</expr></argument>, <argument><expr><name><name>oldE</name>-&gt;<name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>name</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><name>newE</name> = (<name>ELEMENT_TYPE</name> *)<call><name>lookup</name><argument_list>(<argument><expr>&amp;(<name><name>newDtd</name>-&gt;<name>elementTypes</name></name>)</expr></argument>, <argument><expr><name>name</name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ELEMENT_TYPE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>newE</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<if>if <condition>(<expr><name><name>oldE</name>-&gt;<name>nDefaultAtts</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>newE</name>-&gt;<name>defaultAtts</name></name> = (<name>DEFAULT_ATTRIBUTE</name> *)
<call><name><name>ms</name>-&gt;<name>malloc_fcn</name></name><argument_list>(<argument><expr><name><name>oldE</name>-&gt;<name>nDefaultAtts</name></name> * <sizeof>sizeof<argument_list>(<argument><expr><name>DEFAULT_ATTRIBUTE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name><name>newE</name>-&gt;<name>defaultAtts</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name><name>ms</name>-&gt;<name>free_fcn</name></name><argument_list>(<argument><expr><name>newE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
}</block></then></if>
<if>if <condition>(<expr><name><name>oldE</name>-&gt;<name>idAtt</name></name></expr>)</condition><then>
<expr_stmt><expr><name><name>newE</name>-&gt;<name>idAtt</name></name> = (<name>ATTRIBUTE_ID</name> *)
<call><name>lookup</name><argument_list>(<argument><expr>&amp;(<name><name>newDtd</name>-&gt;<name>attributeIds</name></name>)</expr></argument>, <argument><expr><name><name>oldE</name>-&gt;<name>idAtt</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name><name>newE</name>-&gt;<name>allocDefaultAtts</name></name> = <name><name>newE</name>-&gt;<name>nDefaultAtts</name></name> = <name><name>oldE</name>-&gt;<name>nDefaultAtts</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>oldE</name>-&gt;<name>prefix</name></name></expr>)</condition><then>
<expr_stmt><expr><name><name>newE</name>-&gt;<name>prefix</name></name> = (<name>PREFIX</name> *)<call><name>lookup</name><argument_list>(<argument><expr>&amp;(<name><name>newDtd</name>-&gt;<name>prefixes</name></name>)</expr></argument>,
<argument><expr><name><name>oldE</name>-&gt;<name>prefix</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>newE</name>-&gt;<name>nDefaultAtts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><name><name>newE</name>-&gt;<name>defaultAtts</name><index>[<expr><name>i</name></expr>]</index></name>.<name>id</name> = (<name>ATTRIBUTE_ID</name> *)
<call><name>lookup</name><argument_list>(<argument><expr>&amp;(<name><name>newDtd</name>-&gt;<name>attributeIds</name></name>)</expr></argument>, <argument><expr><name><name>oldE</name>-&gt;<name>defaultAtts</name><index>[<expr><name>i</name></expr>]</index></name>.<name><name>id</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newE</name>-&gt;<name>defaultAtts</name><index>[<expr><name>i</name></expr>]</index></name>.<name>isCdata</name> = <name><name>oldE</name>-&gt;<name>defaultAtts</name><index>[<expr><name>i</name></expr>]</index></name>.<name>isCdata</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>oldE</name>-&gt;<name>defaultAtts</name><index>[<expr><name>i</name></expr>]</index></name>.<name>value</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>newE</name>-&gt;<name>defaultAtts</name><index>[<expr><name>i</name></expr>]</index></name>.<name>value</name>
= <call><name>poolCopyString</name><argument_list>(<argument><expr>&amp;(<name><name>newDtd</name>-&gt;<name>pool</name></name>)</expr></argument>, <argument><expr><name><name>oldE</name>-&gt;<name>defaultAtts</name><index>[<expr><name>i</name></expr>]</index></name>.<name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name><name>newE</name>-&gt;<name>defaultAtts</name><index>[<expr><name>i</name></expr>]</index></name>.<name>value</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
}</block></then> <else>else
<expr_stmt><expr><name><name>newE</name>-&gt;<name>defaultAtts</name><index>[<expr><name>i</name></expr>]</index></name>.<name>value</name> = <name>NULL</name></expr>;</expr_stmt></else></if>
}</block></for>
}</block></for>
<if>if <condition>(<expr>!<call><name>copyEntityTable</name><argument_list>(<argument><expr>&amp;(<name><name>newDtd</name>-&gt;<name>generalEntities</name></name>)</expr></argument>,
<argument><expr>&amp;(<name><name>newDtd</name>-&gt;<name>pool</name></name>)</expr></argument>,
<argument><expr>&amp;(<name><name>oldDtd</name>-&gt;<name>generalEntities</name></name>)</expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>XML_DTD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr>!<call><name>copyEntityTable</name><argument_list>(<argument><expr>&amp;(<name><name>newDtd</name>-&gt;<name>paramEntities</name></name>)</expr></argument>,
<argument><expr>&amp;(<name><name>newDtd</name>-&gt;<name>pool</name></name>)</expr></argument>,
<argument><expr>&amp;(<name><name>oldDtd</name>-&gt;<name>paramEntities</name></name>)</expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><name><name>newDtd</name>-&gt;<name>paramEntityRead</name></name> = <name><name>oldDtd</name>-&gt;<name>paramEntityRead</name></name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name><name>newDtd</name>-&gt;<name>keepProcessing</name></name> = <name><name>oldDtd</name>-&gt;<name>keepProcessing</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newDtd</name>-&gt;<name>hasParamEntityRefs</name></name> = <name><name>oldDtd</name>-&gt;<name>hasParamEntityRefs</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newDtd</name>-&gt;<name>standalone</name></name> = <name><name>oldDtd</name>-&gt;<name>standalone</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newDtd</name>-&gt;<name>in_eldecl</name></name> = <name><name>oldDtd</name>-&gt;<name>in_eldecl</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newDtd</name>-&gt;<name>scaffold</name></name> = <name><name>oldDtd</name>-&gt;<name>scaffold</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newDtd</name>-&gt;<name>contentStringLen</name></name> = <name><name>oldDtd</name>-&gt;<name>contentStringLen</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newDtd</name>-&gt;<name>scaffSize</name></name> = <name><name>oldDtd</name>-&gt;<name>scaffSize</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newDtd</name>-&gt;<name>scaffLevel</name></name> = <name><name>oldDtd</name>-&gt;<name>scaffLevel</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newDtd</name>-&gt;<name>scaffIndex</name></name> = <name><name>oldDtd</name>-&gt;<name>scaffIndex</name></name></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></decl>
<decl>static <name>int</name>
<name>copyEntityTable</name><argument_list>(<argument><expr><name>HASH_TABLE</name> *<name>newTable</name></expr></argument>,
<argument><expr><name>STRING_POOL</name> *<name>newPool</name></expr></argument>,
<argument><expr>const <name>HASH_TABLE</name> *<name>oldTable</name></expr></argument>)</argument_list> <block>{
<decl_stmt><decl><type><name>HASH_TABLE_ITER</name></type> <name>iter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>cachedOldBase</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>cachedNewBase</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>hashTableIterInit</name><argument_list>(<argument><expr>&amp;<name>iter</name></expr></argument>, <argument><expr><name>oldTable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<decl_stmt><decl><type><name>ENTITY</name> *</type><name>newE</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>ENTITY</name> *</type><name>oldE</name> <init>= <expr>(<name>ENTITY</name> *)<call><name>hashTableIterNext</name><argument_list>(<argument><expr>&amp;<name>iter</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>oldE</name></expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr><name>name</name> = <call><name>poolCopyString</name><argument_list>(<argument><expr><name>newPool</name></expr></argument>, <argument><expr><name><name>oldE</name>-&gt;<name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>name</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><name>newE</name> = (<name>ENTITY</name> *)<call><name>lookup</name><argument_list>(<argument><expr><name>newTable</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ENTITY</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>newE</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<if>if <condition>(<expr><name><name>oldE</name>-&gt;<name>systemId</name></name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>tem</name> <init>= <expr><call><name>poolCopyString</name><argument_list>(<argument><expr><name>newPool</name></expr></argument>, <argument><expr><name><name>oldE</name>-&gt;<name>systemId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>tem</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><name><name>newE</name>-&gt;<name>systemId</name></name> = <name>tem</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>oldE</name>-&gt;<name>base</name></name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>oldE</name>-&gt;<name>base</name></name> == <name>cachedOldBase</name></expr>)</condition><then>
<expr_stmt><expr><name><name>newE</name>-&gt;<name>base</name></name> = <name>cachedNewBase</name></expr>;</expr_stmt></then>
<else>else <block>{
<expr_stmt><expr><name>cachedOldBase</name> = <name><name>oldE</name>-&gt;<name>base</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>tem</name> = <call><name>poolCopyString</name><argument_list>(<argument><expr><name>newPool</name></expr></argument>, <argument><expr><name>cachedOldBase</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>tem</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><name>cachedNewBase</name> = <name><name>newE</name>-&gt;<name>base</name></name> = <name>tem</name></expr>;</expr_stmt>
}</block></else></if>
}</block></then></if>
<if>if <condition>(<expr><name><name>oldE</name>-&gt;<name>publicId</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>tem</name> = <call><name>poolCopyString</name><argument_list>(<argument><expr><name>newPool</name></expr></argument>, <argument><expr><name><name>oldE</name>-&gt;<name>publicId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>tem</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><name><name>newE</name>-&gt;<name>publicId</name></name> = <name>tem</name></expr>;</expr_stmt>
}</block></then></if>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>tem</name> <init>= <expr><call><name>poolCopyStringN</name><argument_list>(<argument><expr><name>newPool</name></expr></argument>, <argument><expr><name><name>oldE</name>-&gt;<name>textPtr</name></name></expr></argument>,
<argument><expr><name><name>oldE</name>-&gt;<name>textLen</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>tem</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><name><name>newE</name>-&gt;<name>textPtr</name></name> = <name>tem</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newE</name>-&gt;<name>textLen</name></name> = <name><name>oldE</name>-&gt;<name>textLen</name></name></expr>;</expr_stmt>
}</block></else></if>
<if>if <condition>(<expr><name><name>oldE</name>-&gt;<name>notation</name></name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>tem</name> <init>= <expr><call><name>poolCopyString</name><argument_list>(<argument><expr><name>newPool</name></expr></argument>, <argument><expr><name><name>oldE</name>-&gt;<name>notation</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>tem</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><name><name>newE</name>-&gt;<name>notation</name></name> = <name>tem</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name><name>newE</name>-&gt;<name>is_param</name></name> = <name><name>oldE</name>-&gt;<name>is_param</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newE</name>-&gt;<name>is_internal</name></name> = <name><name>oldE</name>-&gt;<name>is_internal</name></name></expr>;</expr_stmt>
}</block></for>
<return>return <expr>1</expr>;</return>
}</block></decl>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INIT_POWER</name></cpp:macro> <cpp:value>6</cpp:value></cpp:define>
<decl>static <name>XML_Bool</name> <name>FASTCALL</name>
<name>keyeq</name><argument_list>(<argument><expr><name>KEY</name> <name>s1</name></expr></argument>, <argument><expr><name>KEY</name> <name>s2</name></expr></argument>)</argument_list> <block>{
<for>for (<init>;</init> <condition><expr>*<name>s1</name> == *<name>s2</name></expr>;</condition> <incr><expr><name>s1</name>++</expr>, <expr><name>s2</name>++</expr></incr>)
<if>if <condition>(<expr>*<name>s1</name> == 0</expr>)</condition><then>
<return>return <expr><name>XML_TRUE</name></expr>;</return></then></if></for>
<return>return <expr><name>XML_FALSE</name></expr>;</return>
}</block></decl>
<decl>static <name>unsigned</name> <name>long</name> <name>FASTCALL</name>
<name>hash</name><argument_list>(<argument><expr><name>KEY</name> <name>s</name></expr></argument>)</argument_list> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>h</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr>*<name>s</name></expr>)</condition>
<expr_stmt><expr><name>h</name> = <call><name>CHAR_HASH</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr>*<name>s</name>++</expr></argument>)</argument_list></call></expr>;</expr_stmt></while>
<return>return <expr><name>h</name></expr>;</return>
}</block></decl>
<decl>static <name>NAMED</name> *
<name>lookup</name><argument_list>(<argument><expr><name>HASH_TABLE</name> *<name>table</name></expr></argument>, <argument><expr><name>KEY</name> <name>name</name></expr></argument>, <argument><expr><name>size_t</name> <name>createSize</name></expr></argument>)</argument_list> <block>{
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>table</name>-&gt;<name>size</name></name> == 0</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>size_t</name></type> <name>tsize</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>createSize</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>table</name>-&gt;<name>power</name></name> = <name>INIT_POWER</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>table</name>-&gt;<name>size</name></name> = (<name>size_t</name>)1 &lt;&lt; <name>INIT_POWER</name></expr>;</expr_stmt>
<expr_stmt><expr><name>tsize</name> = <name><name>table</name>-&gt;<name>size</name></name> * <sizeof>sizeof<argument_list>(<argument><expr><name>NAMED</name> *</expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<expr_stmt><expr><name><name>table</name>-&gt;<name>v</name></name> = (<name>NAMED</name> **)<call><name><name>table</name>-&gt;<name>mem</name>-&gt;<name>malloc_fcn</name></name><argument_list>(<argument><expr><name>tsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name><name>table</name>-&gt;<name>v</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>table</name>-&gt;<name>size</name></name> = 0</expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>table</name>-&gt;<name>v</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>tsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> = <call><name>hash</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call> &amp; ((<name>unsigned</name> <name>long</name>)<name><name>table</name>-&gt;<name>size</name></name> - 1)</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>h</name> <init>= <expr><call><name>hash</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>mask</name> <init>= <expr>(<name>unsigned</name> <name>long</name>)<name><name>table</name>-&gt;<name>size</name></name> - 1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>step</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>i</name> = <name>h</name> &amp; <name>mask</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name><name>table</name>-&gt;<name>v</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{
<if>if <condition>(<expr><call><name>keyeq</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>table</name>-&gt;<name>v</name><index>[<expr><name>i</name></expr>]</index></name>-&gt;<name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name><name>table</name>-&gt;<name>v</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return></then></if>
<if>if <condition>(<expr>!<name>step</name></expr>)</condition><then>
<expr_stmt><expr><name>step</name> = <call><name>PROBE_STEP</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>mask</name></expr></argument>, <argument><expr><name><name>table</name>-&gt;<name>power</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>i</name> &lt; <name>step</name> ? (<name>i</name> += <name><name>table</name>-&gt;<name>size</name></name> - <name>step</name>) : (<name>i</name> -= <name>step</name>)</expr>;</expr_stmt>
}</block></while>
<if>if <condition>(<expr>!<name>createSize</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name><name>table</name>-&gt;<name>used</name></name> &gt;&gt; (<name><name>table</name>-&gt;<name>power</name></name> - 1)</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>newPower</name> <init>= <expr><name><name>table</name>-&gt;<name>power</name></name> + 1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>newSize</name> <init>= <expr>(<name>size_t</name>)1 &lt;&lt; <name>newPower</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>newMask</name> <init>= <expr>(<name>unsigned</name> <name>long</name>)<name>newSize</name> - 1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>tsize</name> <init>= <expr><name>newSize</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>NAMED</name> *</expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>NAMED</name> **</type><name>newV</name> <init>= <expr>(<name>NAMED</name> **)<call><name><name>table</name>-&gt;<name>mem</name>-&gt;<name>malloc_fcn</name></name><argument_list>(<argument><expr><name>tsize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>newV</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>newV</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>tsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>table</name>-&gt;<name>size</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
<if>if <condition>(<expr><name><name>table</name>-&gt;<name>v</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>newHash</name> <init>= <expr><call><name>hash</name><argument_list>(<argument><expr><name><name>table</name>-&gt;<name>v</name><index>[<expr><name>i</name></expr>]</index></name>-&gt;<name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>j</name> <init>= <expr><name>newHash</name> &amp; <name>newMask</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>step</name> = 0</expr>;</expr_stmt>
<while>while <condition>(<expr><name><name>newV</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition> <block>{
<if>if <condition>(<expr>!<name>step</name></expr>)</condition><then>
<expr_stmt><expr><name>step</name> = <call><name>PROBE_STEP</name><argument_list>(<argument><expr><name>newHash</name></expr></argument>, <argument><expr><name>newMask</name></expr></argument>, <argument><expr><name>newPower</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>j</name> &lt; <name>step</name> ? (<name>j</name> += <name>newSize</name> - <name>step</name>) : (<name>j</name> -= <name>step</name>)</expr>;</expr_stmt>
}</block></while>
<expr_stmt><expr><name><name>newV</name><index>[<expr><name>j</name></expr>]</index></name> = <name><name>table</name>-&gt;<name>v</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
}</block></then></if></for>
<expr_stmt><expr><call><name><name>table</name>-&gt;<name>mem</name>-&gt;<name>free_fcn</name></name><argument_list>(<argument><expr><name><name>table</name>-&gt;<name>v</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>table</name>-&gt;<name>v</name></name> = <name>newV</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>table</name>-&gt;<name>power</name></name> = <name>newPower</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>table</name>-&gt;<name>size</name></name> = <name>newSize</name></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> = <name>h</name> &amp; <name>newMask</name></expr>;</expr_stmt>
<expr_stmt><expr><name>step</name> = 0</expr>;</expr_stmt>
<while>while <condition>(<expr><name><name>table</name>-&gt;<name>v</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{
<if>if <condition>(<expr>!<name>step</name></expr>)</condition><then>
<expr_stmt><expr><name>step</name> = <call><name>PROBE_STEP</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr><name>newMask</name></expr></argument>, <argument><expr><name>newPower</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>i</name> &lt; <name>step</name> ? (<name>i</name> += <name>newSize</name> - <name>step</name>) : (<name>i</name> -= <name>step</name>)</expr>;</expr_stmt>
}</block></while>
}</block></then></if>
}</block></else></if>
<expr_stmt><expr><name><name>table</name>-&gt;<name>v</name><index>[<expr><name>i</name></expr>]</index></name> = (<name>NAMED</name> *)<call><name><name>table</name>-&gt;<name>mem</name>-&gt;<name>malloc_fcn</name></name><argument_list>(<argument><expr><name>createSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name><name>table</name>-&gt;<name>v</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>table</name>-&gt;<name>v</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>createSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>table</name>-&gt;<name>v</name><index>[<expr><name>i</name></expr>]</index></name>-&gt;<name>name</name> = <name>name</name></expr>;</expr_stmt>
<expr_stmt><expr>(<name><name>table</name>-&gt;<name>used</name></name>)++</expr>;</expr_stmt>
<return>return <expr><name><name>table</name>-&gt;<name>v</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return>
}</block></decl>
<decl>static <name>void</name> <name>FASTCALL</name>
<name>hashTableClear</name><argument_list>(<argument><expr><name>HASH_TABLE</name> *<name>table</name></expr></argument>)</argument_list> <block>{
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>table</name>-&gt;<name>size</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><call><name><name>table</name>-&gt;<name>mem</name>-&gt;<name>free_fcn</name></name><argument_list>(<argument><expr><name><name>table</name>-&gt;<name>v</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>table</name>-&gt;<name>v</name><index>[<expr><name>i</name></expr>]</index></name> = <name>NULL</name></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><name><name>table</name>-&gt;<name>used</name></name> = 0</expr>;</expr_stmt>
}</block></decl>
<decl>static <name>void</name> <name>FASTCALL</name>
<name>hashTableDestroy</name><argument_list>(<argument><expr><name>HASH_TABLE</name> *<name>table</name></expr></argument>)</argument_list> <block>{
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>table</name>-&gt;<name>size</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
<expr_stmt><expr><call><name><name>table</name>-&gt;<name>mem</name>-&gt;<name>free_fcn</name></name><argument_list>(<argument><expr><name><name>table</name>-&gt;<name>v</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
<expr_stmt><expr><call><name><name>table</name>-&gt;<name>mem</name>-&gt;<name>free_fcn</name></name><argument_list>(<argument><expr><name><name>table</name>-&gt;<name>v</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></decl>
<decl>static <name>void</name> <name>FASTCALL</name>
<name>hashTableInit</name><argument_list>(<argument><expr><name>HASH_TABLE</name> *<name>p</name></expr></argument>, <argument><expr>const <name>XML_Memory_Handling_Suite</name> *<name>ms</name></expr></argument>)</argument_list> <block>{
<expr_stmt><expr><name><name>p</name>-&gt;<name>power</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name>-&gt;<name>size</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name>-&gt;<name>used</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name>-&gt;<name>v</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name>-&gt;<name>mem</name></name> = <name>ms</name></expr>;</expr_stmt>
}</block></decl>
<decl>static <name>void</name> <name>FASTCALL</name>
<name>hashTableIterInit</name><argument_list>(<argument><expr><name>HASH_TABLE_ITER</name> *<name>iter</name></expr></argument>, <argument><expr>const <name>HASH_TABLE</name> *<name>table</name></expr></argument>)</argument_list> <block>{
<expr_stmt><expr><name><name>iter</name>-&gt;<name>p</name></name> = <name><name>table</name>-&gt;<name>v</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>iter</name>-&gt;<name>end</name></name> = <name><name>iter</name>-&gt;<name>p</name></name> + <name><name>table</name>-&gt;<name>size</name></name></expr>;</expr_stmt>
}</block></decl>
<decl>static <name>NAMED</name> * <name>FASTCALL</name>
<name>hashTableIterNext</name><argument_list>(<argument><expr><name>HASH_TABLE_ITER</name> *<name>iter</name></expr></argument>)</argument_list> <block>{
<while>while <condition>(<expr><name><name>iter</name>-&gt;<name>p</name></name> != <name><name>iter</name>-&gt;<name>end</name></name></expr>)</condition> <block>{
<decl_stmt><decl><type><name>NAMED</name> *</type><name>tem</name> <init>= <expr>*(<name><name>iter</name>-&gt;<name>p</name></name>)++</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>tem</name></expr>)</condition><then>
<return>return <expr><name>tem</name></expr>;</return></then></if>
}</block></while>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></decl>
<decl>static <name>void</name> <name>FASTCALL</name>
<name>poolInit</name><argument_list>(<argument><expr><name>STRING_POOL</name> *<name>pool</name></expr></argument>, <argument><expr>const <name>XML_Memory_Handling_Suite</name> *<name>ms</name></expr></argument>)</argument_list> <block>{
<expr_stmt><expr><name><name>pool</name>-&gt;<name>blocks</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pool</name>-&gt;<name>freeBlocks</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pool</name>-&gt;<name>start</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pool</name>-&gt;<name>ptr</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pool</name>-&gt;<name>end</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pool</name>-&gt;<name>mem</name></name> = <name>ms</name></expr>;</expr_stmt>
}</block></decl>
<decl>static <name>void</name> <name>FASTCALL</name>
<name>poolClear</name><argument_list>(<argument><expr><name>STRING_POOL</name> *<name>pool</name></expr></argument>)</argument_list> <block>{
<if>if <condition>(<expr>!<name><name>pool</name>-&gt;<name>freeBlocks</name></name></expr>)</condition><then>
<expr_stmt><expr><name><name>pool</name>-&gt;<name>freeBlocks</name></name> = <name><name>pool</name>-&gt;<name>blocks</name></name></expr>;</expr_stmt></then>
<else>else <block>{
<decl_stmt><decl><type><name>BLOCK</name> *</type><name>p</name> <init>= <expr><name><name>pool</name>-&gt;<name>blocks</name></name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>p</name></expr>)</condition> <block>{
<decl_stmt><decl><type><name>BLOCK</name> *</type><name>tem</name> <init>= <expr><name><name>p</name>-&gt;<name>next</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>p</name>-&gt;<name>next</name></name> = <name><name>pool</name>-&gt;<name>freeBlocks</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pool</name>-&gt;<name>freeBlocks</name></name> = <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> = <name>tem</name></expr>;</expr_stmt>
}</block></while>
}</block></else></if>
<expr_stmt><expr><name><name>pool</name>-&gt;<name>blocks</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pool</name>-&gt;<name>start</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pool</name>-&gt;<name>ptr</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pool</name>-&gt;<name>end</name></name> = <name>NULL</name></expr>;</expr_stmt>
}</block></decl>
<decl>static <name>void</name> <name>FASTCALL</name>
<name>poolDestroy</name><argument_list>(<argument><expr><name>STRING_POOL</name> *<name>pool</name></expr></argument>)</argument_list> <block>{
<decl_stmt><decl><type><name>BLOCK</name> *</type><name>p</name> <init>= <expr><name><name>pool</name>-&gt;<name>blocks</name></name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>p</name></expr>)</condition> <block>{
<decl_stmt><decl><type><name>BLOCK</name> *</type><name>tem</name> <init>= <expr><name><name>p</name>-&gt;<name>next</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>pool</name>-&gt;<name>mem</name>-&gt;<name>free_fcn</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> = <name>tem</name></expr>;</expr_stmt>
}</block></while>
<expr_stmt><expr><name>p</name> = <name><name>pool</name>-&gt;<name>freeBlocks</name></name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>p</name></expr>)</condition> <block>{
<decl_stmt><decl><type><name>BLOCK</name> *</type><name>tem</name> <init>= <expr><name><name>p</name>-&gt;<name>next</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name><name>pool</name>-&gt;<name>mem</name>-&gt;<name>free_fcn</name></name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> = <name>tem</name></expr>;</expr_stmt>
}</block></while>
}</block></decl>
<decl>static <name>XML_Char</name> *
<name>poolAppend</name><argument_list>(<argument><expr><name>STRING_POOL</name> *<name>pool</name></expr></argument>, <argument><expr>const <name>ENCODING</name> *<name>enc</name></expr></argument>,
<argument><expr>const <name>char</name> *<name>ptr</name></expr></argument>, <argument><expr>const <name>char</name> *<name>end</name></expr></argument>)</argument_list> <block>{
<if>if <condition>(<expr>!<name><name>pool</name>-&gt;<name>ptr</name></name> &amp;&amp; !<call><name>poolGrow</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<expr_stmt><expr><call><name>XmlConvert</name><argument_list>(<argument><expr><name>enc</name></expr></argument>, <argument><expr>&amp;<name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr>(<name>ICHAR</name> **)&amp;(<name><name>pool</name>-&gt;<name>ptr</name></name>)</expr></argument>, <argument><expr>(<name>ICHAR</name> *)<name><name>pool</name>-&gt;<name>end</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ptr</name> == <name>end</name></expr>)</condition><then>
<break>break;</break></then></if>
<if>if <condition>(<expr>!<call><name>poolGrow</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
}</block></for>
<return>return <expr><name><name>pool</name>-&gt;<name>start</name></name></expr>;</return>
}</block></decl>
<decl>static const <name>XML_Char</name> * <name>FASTCALL</name>
<name>poolCopyString</name><argument_list>(<argument><expr><name>STRING_POOL</name> *<name>pool</name></expr></argument>, <argument><expr>const <name>XML_Char</name> *<name>s</name></expr></argument>)</argument_list> <block>{
<do>do <block>{
<if>if <condition>(<expr>!<call><name>poolAppendChar</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>*<name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
}</block> while <condition>(<expr>*<name>s</name>++</expr>)</condition>;</do>
<expr_stmt><expr><name>s</name> = <name><name>pool</name>-&gt;<name>start</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>poolFinish</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>s</name></expr>;</return>
}</block></decl>
<decl>static const <name>XML_Char</name> *
<name>poolCopyStringN</name><argument_list>(<argument><expr><name>STRING_POOL</name> *<name>pool</name></expr></argument>, <argument><expr>const <name>XML_Char</name> *<name>s</name></expr></argument>, <argument><expr><name>int</name> <name>n</name></expr></argument>)</argument_list> <block>{
<if>if <condition>(<expr>!<name><name>pool</name>-&gt;<name>ptr</name></name> &amp;&amp; !<call><name>poolGrow</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<for>for (<init>;</init> <condition><expr><name>n</name> &gt; 0</expr>;</condition> <incr><expr>--<name>n</name></expr>, <expr><name>s</name>++</expr></incr>) <block>{
<if>if <condition>(<expr>!<call><name>poolAppendChar</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>*<name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
}</block></for>
<expr_stmt><expr><name>s</name> = <name><name>pool</name>-&gt;<name>start</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>poolFinish</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>s</name></expr>;</return>
}</block></decl>
<decl>static const <name>XML_Char</name> * <name>FASTCALL</name>
<name>poolAppendString</name><argument_list>(<argument><expr><name>STRING_POOL</name> *<name>pool</name></expr></argument>, <argument><expr>const <name>XML_Char</name> *<name>s</name></expr></argument>)</argument_list> <block>{
<while>while <condition>(<expr>*<name>s</name></expr>)</condition> <block>{
<if>if <condition>(<expr>!<call><name>poolAppendChar</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>*<name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt>
}</block></while>
<return>return <expr><name><name>pool</name>-&gt;<name>start</name></name></expr>;</return>
}</block></decl>
<decl>static <name>XML_Char</name> *
<name>poolStoreString</name><argument_list>(<argument><expr><name>STRING_POOL</name> *<name>pool</name></expr></argument>, <argument><expr>const <name>ENCODING</name> *<name>enc</name></expr></argument>,
<argument><expr>const <name>char</name> *<name>ptr</name></expr></argument>, <argument><expr>const <name>char</name> *<name>end</name></expr></argument>)</argument_list> <block>{
<if>if <condition>(<expr>!<call><name>poolAppend</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name><name>pool</name>-&gt;<name>ptr</name></name> == <name><name>pool</name>-&gt;<name>end</name></name> &amp;&amp; !<call><name>poolGrow</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr>*(<name><name>pool</name>-&gt;<name>ptr</name></name>)++ = 0</expr>;</expr_stmt>
<return>return <expr><name><name>pool</name>-&gt;<name>start</name></name></expr>;</return>
}</block></decl>
<decl>static <name>XML_Bool</name> <name>FASTCALL</name>
<name>poolGrow</name><argument_list>(<argument><expr><name>STRING_POOL</name> *<name>pool</name></expr></argument>)</argument_list> <block>{
<if>if <condition>(<expr><name><name>pool</name>-&gt;<name>freeBlocks</name></name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>pool</name>-&gt;<name>start</name></name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>pool</name>-&gt;<name>blocks</name></name> = <name><name>pool</name>-&gt;<name>freeBlocks</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pool</name>-&gt;<name>freeBlocks</name></name> = <name><name>pool</name>-&gt;<name>freeBlocks</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pool</name>-&gt;<name>blocks</name>-&gt;<name>next</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pool</name>-&gt;<name>start</name></name> = <name><name>pool</name>-&gt;<name>blocks</name>-&gt;<name>s</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pool</name>-&gt;<name>end</name></name> = <name><name>pool</name>-&gt;<name>start</name></name> + <name><name>pool</name>-&gt;<name>blocks</name>-&gt;<name>size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pool</name>-&gt;<name>ptr</name></name> = <name><name>pool</name>-&gt;<name>start</name></name></expr>;</expr_stmt>
<return>return <expr><name>XML_TRUE</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name><name>pool</name>-&gt;<name>end</name></name> - <name><name>pool</name>-&gt;<name>start</name></name> &lt; <name><name>pool</name>-&gt;<name>freeBlocks</name>-&gt;<name>size</name></name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>BLOCK</name> *</type><name>tem</name> <init>= <expr><name><name>pool</name>-&gt;<name>freeBlocks</name>-&gt;<name>next</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>pool</name>-&gt;<name>freeBlocks</name>-&gt;<name>next</name></name> = <name><name>pool</name>-&gt;<name>blocks</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pool</name>-&gt;<name>blocks</name></name> = <name><name>pool</name>-&gt;<name>freeBlocks</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pool</name>-&gt;<name>freeBlocks</name></name> = <name>tem</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>pool</name>-&gt;<name>blocks</name>-&gt;<name>s</name></name></expr></argument>, <argument><expr><name><name>pool</name>-&gt;<name>start</name></name></expr></argument>,
<argument><expr>(<name><name>pool</name>-&gt;<name>end</name></name> - <name><name>pool</name>-&gt;<name>start</name></name>) * <sizeof>sizeof<argument_list>(<argument><expr><name>XML_Char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pool</name>-&gt;<name>ptr</name></name> = <name><name>pool</name>-&gt;<name>blocks</name>-&gt;<name>s</name></name> + (<name><name>pool</name>-&gt;<name>ptr</name></name> - <name><name>pool</name>-&gt;<name>start</name></name>)</expr>;</expr_stmt>
<expr_stmt><expr><name><name>pool</name>-&gt;<name>start</name></name> = <name><name>pool</name>-&gt;<name>blocks</name>-&gt;<name>s</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pool</name>-&gt;<name>end</name></name> = <name><name>pool</name>-&gt;<name>start</name></name> + <name><name>pool</name>-&gt;<name>blocks</name>-&gt;<name>size</name></name></expr>;</expr_stmt>
<return>return <expr><name>XML_TRUE</name></expr>;</return>
}</block></then></if>
}</block></then></if>
<if>if <condition>(<expr><name><name>pool</name>-&gt;<name>blocks</name></name> &amp;&amp; <name><name>pool</name>-&gt;<name>start</name></name> == <name><name>pool</name>-&gt;<name>blocks</name>-&gt;<name>s</name></name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>blockSize</name> <init>= <expr><call>(<name>int</name>)<argument_list>(<argument><expr><name><name>pool</name>-&gt;<name>end</name></name> - <name><name>pool</name>-&gt;<name>start</name></name></expr></argument>)</argument_list></call>*2</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>pool</name>-&gt;<name>blocks</name></name> = (<name>BLOCK</name> *)
<call><name><name>pool</name>-&gt;<name>mem</name>-&gt;<name>realloc_fcn</name></name><argument_list>(<argument><expr><name><name>pool</name>-&gt;<name>blocks</name></name></expr></argument>,
<argument><expr>(<call><name>offsetof</name><argument_list>(<argument><expr><name>BLOCK</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call>
+ <name>blockSize</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>XML_Char</name></expr></argument>)</argument_list></sizeof>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>pool</name>-&gt;<name>blocks</name></name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>XML_FALSE</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>pool</name>-&gt;<name>blocks</name>-&gt;<name>size</name></name> = <name>blockSize</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pool</name>-&gt;<name>ptr</name></name> = <name><name>pool</name>-&gt;<name>blocks</name>-&gt;<name>s</name></name> + (<name><name>pool</name>-&gt;<name>ptr</name></name> - <name><name>pool</name>-&gt;<name>start</name></name>)</expr>;</expr_stmt>
<expr_stmt><expr><name><name>pool</name>-&gt;<name>start</name></name> = <name><name>pool</name>-&gt;<name>blocks</name>-&gt;<name>s</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pool</name>-&gt;<name>end</name></name> = <name><name>pool</name>-&gt;<name>start</name></name> + <name>blockSize</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>BLOCK</name> *</type><name>tem</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>blockSize</name> <init>= <expr><call>(<name>int</name>)<argument_list>(<argument><expr><name><name>pool</name>-&gt;<name>end</name></name> - <name><name>pool</name>-&gt;<name>start</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>blockSize</name> &lt; <name>INIT_BLOCK_SIZE</name></expr>)</condition><then>
<expr_stmt><expr><name>blockSize</name> = <name>INIT_BLOCK_SIZE</name></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>blockSize</name> *= 2</expr>;</expr_stmt></else></if>
<expr_stmt><expr><name>tem</name> = (<name>BLOCK</name> *)<call><name><name>pool</name>-&gt;<name>mem</name>-&gt;<name>malloc_fcn</name></name><argument_list>(<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>BLOCK</name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call>
+ <name>blockSize</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>XML_Char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>tem</name></expr>)</condition><then>
<return>return <expr><name>XML_FALSE</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>tem</name>-&gt;<name>size</name></name> = <name>blockSize</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tem</name>-&gt;<name>next</name></name> = <name><name>pool</name>-&gt;<name>blocks</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pool</name>-&gt;<name>blocks</name></name> = <name>tem</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>pool</name>-&gt;<name>ptr</name></name> != <name><name>pool</name>-&gt;<name>start</name></name></expr>)</condition><then>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>tem</name>-&gt;<name>s</name></name></expr></argument>, <argument><expr><name><name>pool</name>-&gt;<name>start</name></name></expr></argument>,
<argument><expr>(<name><name>pool</name>-&gt;<name>ptr</name></name> - <name><name>pool</name>-&gt;<name>start</name></name>) * <sizeof>sizeof<argument_list>(<argument><expr><name>XML_Char</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name><name>pool</name>-&gt;<name>ptr</name></name> = <name><name>tem</name>-&gt;<name>s</name></name> + (<name><name>pool</name>-&gt;<name>ptr</name></name> - <name><name>pool</name>-&gt;<name>start</name></name>)</expr>;</expr_stmt>
<expr_stmt><expr><name><name>pool</name>-&gt;<name>start</name></name> = <name><name>tem</name>-&gt;<name>s</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pool</name>-&gt;<name>end</name></name> = <name><name>tem</name>-&gt;<name>s</name></name> + <name>blockSize</name></expr>;</expr_stmt>
}</block></else></if>
<return>return <expr><name>XML_TRUE</name></expr>;</return>
}</block></decl>
<decl>static <name>int</name> <name>FASTCALL</name>
<name>nextScaffoldPart</name><argument_list>(<argument><expr><name>XML_Parser</name> <name>parser</name></expr></argument>)</argument_list> <block>{
<decl_stmt><decl><type><name>DTD</name> * <specifier>const</specifier></type> <name>dtd</name> <init>= <expr><name>_dtd</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CONTENT_SCAFFOLD</name> *</type> <name>me</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>next</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name><name>dtd</name>-&gt;<name>scaffIndex</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>dtd</name>-&gt;<name>scaffIndex</name></name> = (<name>int</name> *)<call><name>MALLOC</name><argument_list>(<argument><expr><name>groupSize</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name><name>dtd</name>-&gt;<name>scaffIndex</name></name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><name><name>dtd</name>-&gt;<name>scaffIndex</name><index>[<expr>0</expr>]</index></name> = 0</expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name><name>dtd</name>-&gt;<name>scaffCount</name></name> &gt;= <name><name>dtd</name>-&gt;<name>scaffSize</name></name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>CONTENT_SCAFFOLD</name> *</type><name>temp</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>dtd</name>-&gt;<name>scaffold</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>temp</name> = (<name>CONTENT_SCAFFOLD</name> *)
<call><name>REALLOC</name><argument_list>(<argument><expr><name><name>dtd</name>-&gt;<name>scaffold</name></name></expr></argument>, <argument><expr><name><name>dtd</name>-&gt;<name>scaffSize</name></name> * 2 * <sizeof>sizeof<argument_list>(<argument><expr><name>CONTENT_SCAFFOLD</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>temp</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><name><name>dtd</name>-&gt;<name>scaffSize</name></name> *= 2</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>temp</name> = (<name>CONTENT_SCAFFOLD</name> *)<call><name>MALLOC</name><argument_list>(<argument><expr><name>INIT_SCAFFOLD_ELEMENTS</name>
* <sizeof>sizeof<argument_list>(<argument><expr><name>CONTENT_SCAFFOLD</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>temp</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><name><name>dtd</name>-&gt;<name>scaffSize</name></name> = <name>INIT_SCAFFOLD_ELEMENTS</name></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><name><name>dtd</name>-&gt;<name>scaffold</name></name> = <name>temp</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>next</name> = <name><name>dtd</name>-&gt;<name>scaffCount</name></name>++</expr>;</expr_stmt>
<expr_stmt><expr><name>me</name> = &amp;<name><name>dtd</name>-&gt;<name>scaffold</name><index>[<expr><name>next</name></expr>]</index></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>dtd</name>-&gt;<name>scaffLevel</name></name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>CONTENT_SCAFFOLD</name> *</type><name>parent</name> <init>= <expr>&amp;<name><name>dtd</name>-&gt;<name>scaffold</name><index>[<expr><name><name>dtd</name>-&gt;<name>scaffIndex</name><index>[<expr><name><name>dtd</name>-&gt;<name>scaffLevel</name></name>-1</expr>]</index></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>parent</name>-&gt;<name>lastchild</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>dtd</name>-&gt;<name>scaffold</name><index>[<expr><name><name>parent</name>-&gt;<name>lastchild</name></name></expr>]</index></name>.<name>nextsib</name> = <name>next</name></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr>!<name><name>parent</name>-&gt;<name>childcnt</name></name></expr>)</condition><then>
<expr_stmt><expr><name><name>parent</name>-&gt;<name>firstchild</name></name> = <name>next</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name><name>parent</name>-&gt;<name>lastchild</name></name> = <name>next</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parent</name>-&gt;<name>childcnt</name></name>++</expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name><name>me</name>-&gt;<name>firstchild</name></name> = <name><name>me</name>-&gt;<name>lastchild</name></name> = <name><name>me</name>-&gt;<name>childcnt</name></name> = <name><name>me</name>-&gt;<name>nextsib</name></name> = 0</expr>;</expr_stmt>
<return>return <expr><name>next</name></expr>;</return>
}</block></decl>
<decl>static <name>void</name>
<name>build_node</name><argument_list>(<argument><expr><name>XML_Parser</name> <name>parser</name></expr></argument>,
<argument><expr><name>int</name> <name>src_node</name></expr></argument>,
<argument><expr><name>XML_Content</name> *<name>dest</name></expr></argument>,
<argument><expr><name>XML_Content</name> **<name>contpos</name></expr></argument>,
<argument><expr><name>XML_Char</name> **<name>strpos</name></expr></argument>)</argument_list> <block>{
<decl_stmt><decl><type><name>DTD</name> * <specifier>const</specifier></type> <name>dtd</name> <init>= <expr><name>_dtd</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>dest</name>-&gt;<name>type</name></name> = <name><name>dtd</name>-&gt;<name>scaffold</name><index>[<expr><name>src_node</name></expr>]</index></name>.<name>type</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dest</name>-&gt;<name>quant</name></name> = <name><name>dtd</name>-&gt;<name>scaffold</name><index>[<expr><name>src_node</name></expr>]</index></name>.<name>quant</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>dest</name>-&gt;<name>type</name></name> == <name>XML_CTYPE_NAME</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>src</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>dest</name>-&gt;<name>name</name></name> = *<name>strpos</name></expr>;</expr_stmt>
<expr_stmt><expr><name>src</name> = <name><name>dtd</name>-&gt;<name>scaffold</name><index>[<expr><name>src_node</name></expr>]</index></name>.<name>name</name></expr>;</expr_stmt>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<expr_stmt><expr>*(*<name>strpos</name>)++ = *<name>src</name></expr>;</expr_stmt>
<if>if <condition>(<expr>!*<name>src</name></expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr><name>src</name>++</expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><name><name>dest</name>-&gt;<name>numchildren</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>dest</name>-&gt;<name>children</name></name> = <name>NULL</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>cn</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>dest</name>-&gt;<name>numchildren</name></name> = <name><name>dtd</name>-&gt;<name>scaffold</name><index>[<expr><name>src_node</name></expr>]</index></name>.<name>childcnt</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dest</name>-&gt;<name>children</name></name> = *<name>contpos</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>contpos</name> += <name><name>dest</name>-&gt;<name>numchildren</name></name></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>, <expr><name>cn</name> = <name><name>dtd</name>-&gt;<name>scaffold</name><index>[<expr><name>src_node</name></expr>]</index></name>.<name>firstchild</name></expr>;</init>
<condition><expr><name>i</name> &lt; <name><name>dest</name>-&gt;<name>numchildren</name></name></expr>;</condition>
<incr><expr><name>i</name>++</expr>, <expr><name>cn</name> = <name><name>dtd</name>-&gt;<name>scaffold</name><index>[<expr><name>cn</name></expr>]</index></name>.<name>nextsib</name></expr></incr>) <block>{
<expr_stmt><expr><call><name>build_node</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>cn</name></expr></argument>, <argument><expr>&amp;(<name><name>dest</name>-&gt;<name>children</name><index>[<expr><name>i</name></expr>]</index></name>)</expr></argument>, <argument><expr><name>contpos</name></expr></argument>, <argument><expr><name>strpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><name><name>dest</name>-&gt;<name>name</name></name> = <name>NULL</name></expr>;</expr_stmt>
}</block></else></if>
}</block></decl>
<decl>static <name>XML_Content</name> *
<name>build_model</name> <argument_list>(<argument><expr><name>XML_Parser</name> <name>parser</name></expr></argument>)</argument_list> <block>{
<decl_stmt><decl><type><name>DTD</name> * <specifier>const</specifier></type> <name>dtd</name> <init>= <expr><name>_dtd</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Content</name> *</type><name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Content</name> *</type><name>cpos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>XML_Char</name> *</type> <name>str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>allocsize</name> <init>= <expr>(<name><name>dtd</name>-&gt;<name>scaffCount</name></name> * <sizeof>sizeof<argument_list>(<argument><expr><name>XML_Content</name></expr></argument>)</argument_list></sizeof>
+ (<name><name>dtd</name>-&gt;<name>contentStringLen</name></name> * <sizeof>sizeof<argument_list>(<argument><expr><name>XML_Char</name></expr></argument>)</argument_list></sizeof>))</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>ret</name> = (<name>XML_Content</name> *)<call><name>MALLOC</name><argument_list>(<argument><expr><name>allocsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>ret</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>str</name> = <call>(<name>XML_Char</name> *) <argument_list>(<argument><expr>&amp;<name><name>ret</name><index>[<expr><name><name>dtd</name>-&gt;<name>scaffCount</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>cpos</name> = &amp;<name><name>ret</name><index>[<expr>1</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>build_node</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>ret</name></expr></argument>, <argument><expr>&amp;<name>cpos</name></expr></argument>, <argument><expr>&amp;<name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
}</block></decl>
<decl>static <name>ELEMENT_TYPE</name> *
<name>getElementType</name><argument_list>(<argument><expr><name>XML_Parser</name> <name>parser</name></expr></argument>,
<argument><expr>const <name>ENCODING</name> *<name>enc</name></expr></argument>,
<argument><expr>const <name>char</name> *<name>ptr</name></expr></argument>,
<argument><expr>const <name>char</name> *<name>end</name></expr></argument>)</argument_list> <block>{
<decl_stmt><decl><type><name>DTD</name> * <specifier>const</specifier></type> <name>dtd</name> <init>= <expr><name>_dtd</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>name</name> <init>= <expr><call><name>poolStoreString</name><argument_list>(<argument><expr>&amp;<name><name>dtd</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ELEMENT_TYPE</name> *</type><name>ret</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>name</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>ret</name> = (<name>ELEMENT_TYPE</name> *) <call><name>lookup</name><argument_list>(<argument><expr>&amp;<name><name>dtd</name>-&gt;<name>elementTypes</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ELEMENT_TYPE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>ret</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name><name>ret</name>-&gt;<name>name</name></name> != <name>name</name></expr>)</condition><then>
<expr_stmt><expr><call><name>poolDiscard</name><argument_list>(<argument><expr>&amp;<name><name>dtd</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else <block>{
<expr_stmt><expr><call><name>poolFinish</name><argument_list>(<argument><expr>&amp;<name><name>dtd</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>setElementTypePrefix</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
}</block></else></if>
<return>return <expr><name>ret</name></expr>;</return>
}</block></decl>
<decl/></enum></unit>
