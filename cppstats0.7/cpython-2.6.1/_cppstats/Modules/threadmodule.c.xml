<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="Modules/threadmodule.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>WITH_THREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:error>#<cpp:directive>error</cpp:directive> "Error! The rest of Python is not compiled with thread support."</cpp:error>
<cpp:error>#<cpp:directive>error</cpp:directive> "Rerun configure, adding a --with-threads option."</cpp:error>
<cpp:error>#<cpp:directive>error</cpp:directive> "Then run `make clean' followed by `make'."</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pythread.h"</cpp:file></cpp:include>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>ThreadError</name></decl>;</decl_stmt>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>PyObject_HEAD</name>
<name>PyThread_type_lock</name></type> <name>lock_lock</name></decl>;</decl_stmt>
}</block></struct></type> <name>lockobject</name>;</typedef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>lock_dealloc</name><parameter_list>(<param><decl><type><name>lockobject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>lock_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyThread_acquire_lock</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>lock_lock</name></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyThread_release_lock</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>lock_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyThread_free_lock</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>lock_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyObject_Del</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>lock_PyThread_acquire_lock</name><parameter_list>(<param><decl><type><name>lockobject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|i:acquire"</expr></argument>, <argument><expr>&amp;<name>i</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>i</name> <init>= <expr><call><name>PyThread_acquire_lock</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>lock_lock</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name>i</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>acquire_doc</name></expr></argument>,
<argument><expr>"acquire([wait]) -&gt; None or bool\n\
(acquire_lock() is an obsolete synonym)\n\
\n\
Lock the lock. Without argument, this blocks if the lock is already\n\
locked (even by the same thread), waiting for another thread to release\n\
the lock, and return None once the lock is acquired.\n\
With an argument, this will only block if the argument is true,\n\
and the return value reflects whether the lock is acquired.\n\
The blocking operation is not interruptible."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>lock_PyThread_release_lock</name><parameter_list>(<param><decl><type><name>lockobject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><call><name>PyThread_acquire_lock</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>lock_lock</name></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyThread_release_lock</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>lock_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>ThreadError</name></expr></argument>, <argument><expr>"release unlocked lock"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>PyThread_release_lock</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>lock_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>release_doc</name></expr></argument>,
<argument><expr>"release()\n\
(release_lock() is an obsolete synonym)\n\
\n\
Release the lock, allowing another thread that is blocked waiting for\n\
the lock to acquire the lock. The lock must be in the locked state,\n\
but it needn't be locked by the same thread that unlocks it."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>lock_locked_lock</name><parameter_list>(<param><decl><type><name>lockobject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><call><name>PyThread_acquire_lock</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>lock_lock</name></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyThread_release_lock</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>lock_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>0L</expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>1L</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>locked_doc</name></expr></argument>,
<argument><expr>"locked() -&gt; bool\n\
(locked_lock() is an obsolete synonym)\n\
\n\
Return whether the lock is in the locked state."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>lock_methods</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{
<expr>"acquire_lock"</expr>, <expr>(<name>PyCFunction</name>)<name>lock_PyThread_acquire_lock</name></expr>,
<expr><name>METH_VARARGS</name></expr>, <expr><name>acquire_doc</name></expr>
}</block></expr>,
<expr><block>{
<expr>"acquire"</expr>, <expr>(<name>PyCFunction</name>)<name>lock_PyThread_acquire_lock</name></expr>,
<expr><name>METH_VARARGS</name></expr>, <expr><name>acquire_doc</name></expr>
}</block></expr>,
<expr><block>{
<expr>"release_lock"</expr>, <expr>(<name>PyCFunction</name>)<name>lock_PyThread_release_lock</name></expr>,
<expr><name>METH_NOARGS</name></expr>, <expr><name>release_doc</name></expr>
}</block></expr>,
<expr><block>{
<expr>"release"</expr>, <expr>(<name>PyCFunction</name>)<name>lock_PyThread_release_lock</name></expr>,
<expr><name>METH_NOARGS</name></expr>, <expr><name>release_doc</name></expr>
}</block></expr>,
<expr><block>{
<expr>"locked_lock"</expr>, <expr>(<name>PyCFunction</name>)<name>lock_locked_lock</name></expr>,
<expr><name>METH_NOARGS</name></expr>, <expr><name>locked_doc</name></expr>
}</block></expr>,
<expr><block>{
<expr>"locked"</expr>, <expr>(<name>PyCFunction</name>)<name>lock_locked_lock</name></expr>,
<expr><name>METH_NOARGS</name></expr>, <expr><name>locked_doc</name></expr>
}</block></expr>,
<expr><block>{
<expr>"__enter__"</expr>, <expr>(<name>PyCFunction</name>)<name>lock_PyThread_acquire_lock</name></expr>,
<expr><name>METH_VARARGS</name></expr>, <expr><name>acquire_doc</name></expr>
}</block></expr>,
<expr><block>{
<expr>"__exit__"</expr>, <expr>(<name>PyCFunction</name>)<name>lock_PyThread_release_lock</name></expr>,
<expr><name>METH_VARARGS</name></expr>, <expr><name>release_doc</name></expr>
}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>lock_getattr</name><parameter_list>(<param><decl><type><name>lockobject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>char</name> *</type><name>name</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>Py_FindMethod</name><argument_list>(<argument><expr><name>lock_methods</name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>Locktype</name> <init>= <expr><block>{
<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr>&amp;<name>PyType_Type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
"thread.lock"</expr>,
<expr><sizeof>sizeof<argument_list>(<argument><expr><name>lockobject</name></expr></argument>)</argument_list></sizeof></expr>,
<expr>0</expr>,
<expr>(<name>destructor</name>)<name>lock_dealloc</name></expr>,
<expr>0</expr>,
<expr>(<name>getattrfunc</name>)<name>lock_getattr</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>lockobject</name> *</type>
<name>newlockobject</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>lockobject</name> *</type><name>self</name></decl>;</decl_stmt>
<expr_stmt><expr><name>self</name> = <call><name>PyObject_New</name><argument_list>(<argument><expr><name>lockobject</name></expr></argument>, <argument><expr>&amp;<name>Locktype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>self</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>self</name>-&gt;<name>lock_lock</name></name> = <call><name>PyThread_allocate_lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>lock_lock</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyObject_Del</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>self</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>ThreadError</name></expr></argument>, <argument><expr>"can't allocate lock"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>self</name></expr>;</return>
}</block></function>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"structmember.h"</cpp:file></cpp:include>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>PyObject_HEAD</name>
<name>PyObject</name> *</type><name>key</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>args</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>kw</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>dict</name></decl>;</decl_stmt>
}</block></struct></type> <name>localobject</name>;</typedef>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>local_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kw</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>localobject</name> *</type><name>self</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>tdict</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>type</name>-&gt;<name>tp_init</name></name> == <name><name>PyBaseObject_Type</name>.<name>tp_init</name></name>
&amp;&amp; ((<name>args</name> &amp;&amp; <call><name>PyObject_IsTrue</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call>)
|| (<name>kw</name> &amp;&amp; <call><name>PyObject_IsTrue</name><argument_list>(<argument><expr><name>kw</name></expr></argument>)</argument_list></call>))</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"Initialization arguments are not supported"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>self</name> = (<name>localobject</name> *)<call><name><name>type</name>-&gt;<name>tp_alloc</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>self</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>args</name></name> = <name>args</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name>kw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>kw</name></name> = <name>kw</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>dict</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>key</name></name> = <call><name>PyString_FromFormat</name><argument_list>(<argument><expr>"thread.local.%p"</expr></argument>, <argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>key</name></name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>err</name>;</goto></then></if>
<expr_stmt><expr><name><name>self</name>-&gt;<name>dict</name></name> = <call><name>PyDict_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>dict</name></name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>err</name>;</goto></then></if>
<expr_stmt><expr><name>tdict</name> = <call><name>PyThreadState_GetDict</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>tdict</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
<argument><expr>"Couldn't get thread-state dictionary"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>err</name>;</goto>
}</block></then></if>
<if>if <condition>(<expr><call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>tdict</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>key</name></name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>dict</name></name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<goto>goto <name>err</name>;</goto></then></if>
<return>return <expr>(<name>PyObject</name> *)<name>self</name></expr>;</return>
<label><name>err</name>:</label>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>local_traverse</name><parameter_list>(<param><decl><type><name>localobject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>visitproc</name></type> <name>visit</name></decl></param>, <param><decl><type><name>void</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>kw</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_VISIT</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>dict</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>local_clear</name><parameter_list>(<param><decl><type><name>localobject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>kw</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>dict</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>local_dealloc</name><parameter_list>(<param><decl><type><name>localobject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyThreadState</name> *</type><name>tstate</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>key</name></name>
&amp;&amp; (<name>tstate</name> = <call><name>PyThreadState_Get</name><argument_list>()</argument_list></call>)
&amp;&amp; <name><name>tstate</name>-&gt;<name>interp</name></name></expr>)</condition><then> <block>{
<for>for(<init><expr><name>tstate</name> = <call><name>PyInterpreterState_ThreadHead</name><argument_list>(<argument><expr><name><name>tstate</name>-&gt;<name>interp</name></name></expr></argument>)</argument_list></call></expr>;</init>
<condition><expr><name>tstate</name></expr>;</condition>
<incr><expr><name>tstate</name> = <call><name>PyThreadState_Next</name><argument_list>(<argument><expr><name>tstate</name></expr></argument>)</argument_list></call></expr></incr>)
<if>if <condition>(<expr><name><name>tstate</name>-&gt;<name>dict</name></name> &amp;&amp;
<call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name><name>tstate</name>-&gt;<name>dict</name></name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>key</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><call><name>PyDict_DelItem</name><argument_list>(<argument><expr><name><name>tstate</name>-&gt;<name>dict</name></name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></for>
}</block></then></if>
<expr_stmt><expr><call><name>local_clear</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call>-&gt;<call><name>tp_free</name><argument_list>(<argument><expr>(<name>PyObject</name>*)<name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>_ldict</name><parameter_list>(<param><decl><type><name>localobject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>tdict</name></decl>, *<decl><type ref="prev"/><name>ldict</name></decl>;</decl_stmt>
<expr_stmt><expr><name>tdict</name> = <call><name>PyThreadState_GetDict</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>tdict</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
<argument><expr>"Couldn't get thread-state dictionary"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>ldict</name> = <call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name>tdict</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ldict</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>ldict</name> = <call><name>PyDict_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ldict</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then>
<else>else <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>tdict</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>key</name></name></expr></argument>, <argument><expr><name>ldict</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>ldict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
}</block></else></if>
<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>dict</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>ldict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>dict</name></name> = <name>ldict</name></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call>-&gt;<name>tp_init</name> != <name><name>PyBaseObject_Type</name>.<name>tp_init</name></name> &amp;&amp;
<call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call>-&gt;<call><name>tp_init</name><argument_list>(<argument><expr>(<name>PyObject</name>*)<name>self</name></expr></argument>,
<argument><expr><name><name>self</name>-&gt;<name>args</name></name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>kw</name></name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyDict_DelItem</name><argument_list>(<argument><expr><name>tdict</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>key</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
}</block></then></if>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>dict</name></name> != <name>ldict</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>dict</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>ldict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>dict</name></name> = <name>ldict</name></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>ldict</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>local_setattro</name><parameter_list>(<param><decl><type><name>localobject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>name</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>ldict</name></decl>;</decl_stmt>
<expr_stmt><expr><name>ldict</name> = <call><name>_ldict</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ldict</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<return>return <expr><call><name>PyObject_GenericSetAttr</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>local_getdict</name><parameter_list>(<param><decl><type><name>localobject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>void</name> *</type><name>closure</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>dict</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_AttributeError</name></expr></argument>, <argument><expr>"__dict__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>dict</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>self</name>-&gt;<name>dict</name></name></expr>;</return>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyGetSetDef</name></type> <name><name>local_getset</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{
<expr>"__dict__"</expr>, <expr>(<name>getter</name>)<name>local_getdict</name></expr>, <expr>(<name>setter</name>)<name>NULL</name></expr>,
<expr>"Local-data dictionary"</expr>, <expr><name>NULL</name></expr>
}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>local_getattro</name><parameter_list>(<param><decl><type><name>localobject</name> *</type></decl></param>, <param><decl><type><name>PyObject</name> *</type></decl></param>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>localtype</name> <init>= <expr><block>{
<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
"thread._local"</expr>,
<expr><sizeof>sizeof<argument_list>(<argument><expr><name>localobject</name></expr></argument>)</argument_list></sizeof></expr>,
<expr>0</expr>,
<expr>(<name>destructor</name>)<name>local_dealloc</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>(<name>getattrofunc</name>)<name>local_getattro</name></expr>,
<expr>(<name>setattrofunc</name>)<name>local_setattro</name></expr>,
<expr>0</expr>,
<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_BASETYPE</name></expr>,
<expr>"Thread-local data"</expr>,
<expr>(<name>traverseproc</name>)<name>local_traverse</name></expr>,
<expr>(<name>inquiry</name>)<name>local_clear</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>local_getset</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><call><name>offsetof</name><argument_list>(<argument><expr><name>localobject</name></expr></argument>, <argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>local_new</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>local_getattro</name><parameter_list>(<param><decl><type><name>localobject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>name</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>ldict</name></decl>, *<decl><type ref="prev"/><name>value</name></decl>;</decl_stmt>
<expr_stmt><expr><name>ldict</name> = <call><name>_ldict</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ldict</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> != &amp;<name>localtype</name></expr>)</condition><then>
<return>return <expr><call><name>PyObject_GenericGetAttr</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>value</name> = <call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name>ldict</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>value</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><call><name>PyObject_GenericGetAttr</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>value</name></expr>;</return>
}</block></function>
<struct>struct <name>bootstate</name> <block>{
<decl_stmt><decl><type><name>PyInterpreterState</name> *</type><name>interp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>func</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>args</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>keyw</name></decl>;</decl_stmt>
}</block>;</struct>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>t_bootstrap</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>boot_raw</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>bootstate</name> *</type><name>boot</name> <init>= <expr>(struct <name>bootstate</name> *) <name>boot_raw</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyThreadState</name> *</type><name>tstate</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name></decl>;</decl_stmt>
<expr_stmt><expr><name>tstate</name> = <call><name>PyThreadState_New</name><argument_list>(<argument><expr><name><name>boot</name>-&gt;<name>interp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyEval_AcquireThread</name><argument_list>(<argument><expr><name>tstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>res</name> = <call><name>PyEval_CallObjectWithKeywords</name><argument_list>(
<argument><expr><name><name>boot</name>-&gt;<name>func</name></name></expr></argument>, <argument><expr><name><name>boot</name>-&gt;<name>args</name></name></expr></argument>, <argument><expr><name><name>boot</name>-&gt;<name>keyw</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>res</name> == <name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_SystemExit</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
<else>else <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>file</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(
<argument><expr>"Unhandled exception in thread started by "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>file</name> = <call><name>PySys_GetObject</name><argument_list>(<argument><expr>"stderr"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>file</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyFile_WriteObject</name><argument_list>(<argument><expr><name><name>boot</name>-&gt;<name>func</name></name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><call><name>PyObject_Print</name><argument_list>(<argument><expr><name><name>boot</name>-&gt;<name>func</name></name></expr></argument>, <argument><expr><name>stderr</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_PrintEx</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
}</block></then> <else>else
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name><name>boot</name>-&gt;<name>func</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name><name>boot</name>-&gt;<name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>boot</name>-&gt;<name>keyw</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyMem_DEL</name><argument_list>(<argument><expr><name>boot_raw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyThreadState_Clear</name><argument_list>(<argument><expr><name>tstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyThreadState_DeleteCurrent</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyThread_exit_thread</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>thread_PyThread_start_new_thread</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>fargs</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>func</name></decl>, *<decl><type ref="prev"/><name>args</name></decl>, *<decl><type ref="prev"/><name>keyw</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>bootstate</name> *</type><name>boot</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>ident</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>fargs</name></expr></argument>, <argument><expr>"start_new_thread"</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>3</expr></argument>,
<argument><expr>&amp;<name>func</name></expr></argument>, <argument><expr>&amp;<name>args</name></expr></argument>, <argument><expr>&amp;<name>keyw</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>PyCallable_Check</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"first arg must be callable"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>!<call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"2nd arg must be a tuple"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>keyw</name> != <name>NULL</name> &amp;&amp; !<call><name>PyDict_Check</name><argument_list>(<argument><expr><name>keyw</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"optional 3rd arg must be a dictionary"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>boot</name> = <call><name>PyMem_NEW</name><argument_list>(<argument>struct <expr><name>bootstate</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>boot</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name><name>boot</name>-&gt;<name>interp</name></name> = <call><name>PyThreadState_GET</name><argument_list>()</argument_list></call>-&gt;<name>interp</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>boot</name>-&gt;<name>func</name></name> = <name>func</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>boot</name>-&gt;<name>args</name></name> = <name>args</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>boot</name>-&gt;<name>keyw</name></name> = <name>keyw</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name>keyw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyEval_InitThreads</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ident</name> = <call><name>PyThread_start_new_thread</name><argument_list>(<argument><expr><name>t_bootstrap</name></expr></argument>, <argument><expr>(<name>void</name>*) <name>boot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ident</name> == -1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>ThreadError</name></expr></argument>, <argument><expr>"can't start new thread"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>keyw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyMem_DEL</name><argument_list>(<argument><expr><name>boot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>ident</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>start_new_doc</name></expr></argument>,
<argument><expr>"start_new_thread(function, args[, kwargs])\n\
(start_new() is an obsolete synonym)\n\
\n\
Start a new thread and return its identifier. The thread will call the\n\
function with positional arguments from the tuple args and keyword arguments\n\
taken from the optional dictionary kwargs. The thread exits when the\n\
function returns; the return value is ignored. The thread will also exit\n\
when the function raises an unhandled exception; a stack trace will be\n\
printed unless the exception is SystemExit.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>thread_PyThread_exit_thread</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>PyErr_SetNone</name><argument_list>(<argument><expr><name>PyExc_SystemExit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>exit_doc</name></expr></argument>,
<argument><expr>"exit()\n\
(PyThread_exit_thread() is an obsolete synonym)\n\
\n\
This is synonymous to ``raise SystemExit''. It will cause the current\n\
thread to exit silently unless the exception is caught."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>thread_PyThread_interrupt_main</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type> <name>self</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>PyErr_SetInterrupt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>interrupt_doc</name></expr></argument>,
<argument><expr>"interrupt_main()\n\
\n\
Raise a KeyboardInterrupt in the main thread.\n\
A subthread can use this function to interrupt the main thread."</expr></argument>
)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>NO_EXIT_PROG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>thread_PyThread_exit_prog</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>sts</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:exit_prog"</expr></argument>, <argument><expr>&amp;<name>sts</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>Py_Exit</name><argument_list>(<argument><expr><name>sts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{ }</block></for>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><specifier>static</specifier> <name>lockobject</name> *</type><name>newlockobject</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>;</function_decl>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>thread_PyThread_allocate_lock</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<return>return <expr>(<name>PyObject</name> *) <call><name>newlockobject</name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>allocate_doc</name></expr></argument>,
<argument><expr>"allocate_lock() -&gt; lock object\n\
(allocate() is an obsolete synonym)\n\
\n\
Create a new lock object. See LockType.__doc__ for information about locks."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>thread_get_ident</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>long</name></type> <name>ident</name></decl>;</decl_stmt>
<expr_stmt><expr><name>ident</name> = <call><name>PyThread_get_thread_ident</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ident</name> == -1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>ThreadError</name></expr></argument>, <argument><expr>"no current thread ident"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>ident</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>get_ident_doc</name></expr></argument>,
<argument><expr>"get_ident() -&gt; integer\n\
\n\
Return a non-zero integer that uniquely identifies the current thread\n\
amongst other threads that exist simultaneously.\n\
This may be used to identify per-thread resources.\n\
Even though on some platforms threads identities may appear to be\n\
allocated consecutive numbers starting at 1, this behavior should not\n\
be relied upon, and the number should be seen purely as a magic cookie.\n\
A thread's identity may be reused for another thread after it exits."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>thread_stack_size</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>size_t</name></type> <name>old_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>new_size</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|n:stack_size"</expr></argument>, <argument><expr>&amp;<name>new_size</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>new_size</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"size must be 0 or a positive value"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>old_size</name> = <call><name>PyThread_get_stacksize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rc</name> = <call><name>PyThread_set_stacksize</name><argument_list>(<argument><expr>(<name>size_t</name>) <name>new_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rc</name> == -1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"size not valid: %zd bytes"</expr></argument>,
<argument><expr><name>new_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>rc</name> == -2</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>ThreadError</name></expr></argument>,
<argument><expr>"setting stack size not supported"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr>(<name>Py_ssize_t</name>) <name>old_size</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>stack_size_doc</name></expr></argument>,
<argument><expr>"stack_size([size]) -&gt; size\n\
\n\
Return the thread stack size used when creating new threads. The\n\
optional size argument specifies the stack size (in bytes) to be used\n\
for subsequently created threads, and must be 0 (use platform or\n\
configured default) or a positive integer value of at least 32,768 (32k).\n\
If changing the thread stack size is unsupported, a ThreadError\n\
exception is raised. If the specified size is invalid, a ValueError\n\
exception is raised, and the stack size is unmodified. 32k bytes\n\
currently the minimum supported stack size value to guarantee\n\
sufficient stack space for the interpreter itself.\n\
\n\
Note that some platforms may have particular restrictions on values for\n\
the stack size, such as requiring a minimum stack size larger than 32kB or\n\
requiring allocation in multiples of the system memory page size\n\
- platform documentation should be referred to for more information\n\
(4kB pages are common; using multiples of 4096 for the stack size is\n\
the suggested approach in the absence of more specific information)."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>thread_methods</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{
<expr>"start_new_thread"</expr>, <expr>(<name>PyCFunction</name>)<name>thread_PyThread_start_new_thread</name></expr>,
<expr><name>METH_VARARGS</name></expr>,
<expr><name>start_new_doc</name></expr>
}</block></expr>,
<expr><block>{
<expr>"start_new"</expr>, <expr>(<name>PyCFunction</name>)<name>thread_PyThread_start_new_thread</name></expr>,
<expr><name>METH_VARARGS</name></expr>,
<expr><name>start_new_doc</name></expr>
}</block></expr>,
<expr><block>{
<expr>"allocate_lock"</expr>, <expr>(<name>PyCFunction</name>)<name>thread_PyThread_allocate_lock</name></expr>,
<expr><name>METH_NOARGS</name></expr>, <expr><name>allocate_doc</name></expr>
}</block></expr>,
<expr><block>{
<expr>"allocate"</expr>, <expr>(<name>PyCFunction</name>)<name>thread_PyThread_allocate_lock</name></expr>,
<expr><name>METH_NOARGS</name></expr>, <expr><name>allocate_doc</name></expr>
}</block></expr>,
<expr><block>{
<expr>"exit_thread"</expr>, <expr>(<name>PyCFunction</name>)<name>thread_PyThread_exit_thread</name></expr>,
<expr><name>METH_NOARGS</name></expr>, <expr><name>exit_doc</name></expr>
}</block></expr>,
<expr><block>{
<expr>"exit"</expr>, <expr>(<name>PyCFunction</name>)<name>thread_PyThread_exit_thread</name></expr>,
<expr><name>METH_NOARGS</name></expr>, <expr><name>exit_doc</name></expr>
}</block></expr>,
<expr><block>{
<expr>"interrupt_main"</expr>, <expr>(<name>PyCFunction</name>)<name>thread_PyThread_interrupt_main</name></expr>,
<expr><name>METH_NOARGS</name></expr>, <expr><name>interrupt_doc</name></expr>
}</block></expr>,
<expr><block>{
<expr>"get_ident"</expr>, <expr>(<name>PyCFunction</name>)<name>thread_get_ident</name></expr>,
<expr><name>METH_NOARGS</name></expr>, <expr><name>get_ident_doc</name></expr>
}</block></expr>,
<expr><block>{
<expr>"stack_size"</expr>, <expr>(<name>PyCFunction</name>)<name>thread_stack_size</name></expr>,
<expr><name>METH_VARARGS</name></expr>,
<expr><name>stack_size_doc</name></expr>
}</block></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>NO_EXIT_PROG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{
<expr>"exit_prog"</expr>, <expr>(<name>PyCFunction</name>)<name>thread_PyThread_exit_prog</name></expr>,
<expr><name>METH_VARARGS</name></expr>
}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>thread_doc</name></expr></argument>,
<argument><expr>"This module provides primitive operations to write multi-threaded programs.\n\
The 'threading' module provides a more convenient interface."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>lock_doc</name></expr></argument>,
<argument><expr>"A lock object is a synchronization primitive. To create a lock,\n\
call the PyThread_allocate_lock() function. Methods are:\n\
\n\
acquire() -- lock the lock, possibly blocking until it can be obtained\n\
release() -- unlock of the lock\n\
locked() -- test whether the lock is currently locked\n\
\n\
A lock is not owned by the thread that locked it; another thread may\n\
unlock it. A thread attempting to lock a lock that it has already locked\n\
will block until another thread unlocks it. Deadlocks may ensue."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><name>PyMODINIT_FUNC</name></type>
<name>initthread</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name></decl>, *<decl><type ref="prev"/><name>d</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyType_Ready</name><argument_list>(<argument><expr>&amp;<name>localtype</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><name>m</name> = <call><name>Py_InitModule3</name><argument_list>(<argument><expr>"thread"</expr></argument>, <argument><expr><name>thread_methods</name></expr></argument>, <argument><expr><name>thread_doc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>m</name> == <name>NULL</name></expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><name>d</name> = <call><name>PyModule_GetDict</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ThreadError</name> = <call><name>PyErr_NewException</name><argument_list>(<argument><expr>"thread.error"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"error"</expr></argument>, <argument><expr><name>ThreadError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>Locktype</name>.<name>tp_doc</name></name> = <name>lock_doc</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>&amp;<name>Locktype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"LockType"</expr></argument>, <argument><expr>(<name>PyObject</name> *)&amp;<name>Locktype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>&amp;<name>localtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"_local"</expr></argument>, <argument><expr>(<name>PyObject</name> *)&amp;<name>localtype</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><call><name>PyThread_init_thread</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>
</unit>
