<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="Modules/mathmodule.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"longintrepr.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_OSF_SOURCE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><specifier>extern</specifier> <name>double</name></type> <name>copysign</name><parameter_list>(<param><decl><type><name>double</name></type></decl></param>, <param><decl><type><name>double</name></type></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>is_error</name><parameter_list>(<param><decl><type><name>double</name></type> <name>x</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>errno</name> == <name>EDOM</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"math domain error"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name>errno</name> == <name>ERANGE</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>fabs</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> &lt; 1.0</expr>)</condition><then>
<expr_stmt><expr><name>result</name> = 0</expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
<argument><expr>"math range error"</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
}</block></then> <else>else
<expr_stmt><expr><call><name>PyErr_SetFromErrno</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>double</name></type>
<name>m_atan2</name><parameter_list>(<param><decl><type><name>double</name></type> <name>y</name></decl></param>, <param><decl><type><name>double</name></type> <name>x</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><call><name>Py_IS_NAN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> || <call><name>Py_IS_NAN</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>Py_NAN</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>Py_IS_INFINITY</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>Py_IS_INFINITY</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>copysign</name><argument_list>(<argument><expr>1.</expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call> == 1.</expr>)</condition><then>
<return>return <expr><call><name>copysign</name><argument_list>(<argument><expr>0.25*<name>Py_MATH_PI</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</return></then>
<else>else
<return>return <expr><call><name>copysign</name><argument_list>(<argument><expr>0.75*<name>Py_MATH_PI</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></then></if>
<return>return <expr><call><name>copysign</name><argument_list>(<argument><expr>0.5*<name>Py_MATH_PI</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><call><name>Py_IS_INFINITY</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> || <name>y</name> == 0.</expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>copysign</name><argument_list>(<argument><expr>1.</expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call> == 1.</expr>)</condition><then>
<return>return <expr><call><name>copysign</name><argument_list>(<argument><expr>0.</expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</return></then>
<else>else
<return>return <expr><call><name>copysign</name><argument_list>(<argument><expr><name>Py_MATH_PI</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></then></if>
<return>return <expr><call><name>atan2</name><argument_list>(<argument><expr><name>y</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>math_1</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>, <param><function_decl><type><name>double</name></type> (*<name>func</name>) <parameter_list>(<param><decl><type><name>double</name></type></decl></param>)</parameter_list></function_decl></param>, <param><decl><type><name>int</name></type> <name>can_overflow</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>double</name></type> <name>x</name></decl>, <decl><type ref="prev"/><name>r</name></decl>;</decl_stmt>
<expr_stmt><expr><name>x</name> = <call><name>PyFloat_AsDouble</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>x</name> == -1.0 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
<macro><name>PyFPE_START_PROTECT</name><argument_list>(<argument>"in math_1"</argument>, <argument>return 0</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<expr_stmt><expr><name>r</name> = <call>(*<name>func</name>)<argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyFPE_END_PROTECT</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>Py_IS_NAN</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<call><name>Py_IS_NAN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>errno</name> = <name>EDOM</name></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt></else></if>
}</block></then> <else>else <if>if <condition>(<expr><call><name>Py_IS_INFINITY</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>Py_IS_FINITE</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>errno</name> = <name>can_overflow</name> ? <name>ERANGE</name> : <name>EDOM</name></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt></else></if>
}</block></then></if></else></if>
<if>if <condition>(<expr><name>errno</name> &amp;&amp; <call><name>is_error</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then>
<else>else
<return>return <expr><call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>math_2</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><function_decl><type><name>double</name></type> (*<name>func</name>) <parameter_list>(<param><decl><type><name>double</name></type></decl></param>, <param><decl><type><name>double</name></type></decl></param>)</parameter_list></function_decl></param>, <param><decl><type><name>char</name> *</type><name>funcname</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>ox</name></decl>, *<decl><type ref="prev"/><name>oy</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>x</name></decl>, <decl><type ref="prev"/><name>y</name></decl>, <decl><type ref="prev"/><name>r</name></decl>;</decl_stmt>
<if>if <condition>(<expr>! <call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>funcname</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>&amp;<name>ox</name></expr></argument>, <argument><expr>&amp;<name>oy</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>x</name> = <call><name>PyFloat_AsDouble</name><argument_list>(<argument><expr><name>ox</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>y</name> = <call><name>PyFloat_AsDouble</name><argument_list>(<argument><expr><name>oy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>(<name>x</name> == -1.0 || <name>y</name> == -1.0) &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
<macro><name>PyFPE_START_PROTECT</name><argument_list>(<argument>"in math_2"</argument>, <argument>return 0</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<expr_stmt><expr><name>r</name> = <call>(*<name>func</name>)<argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyFPE_END_PROTECT</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>Py_IS_NAN</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<call><name>Py_IS_NAN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>Py_IS_NAN</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>errno</name> = <name>EDOM</name></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt></else></if>
}</block></then> <else>else <if>if <condition>(<expr><call><name>Py_IS_INFINITY</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>Py_IS_FINITE</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>Py_IS_FINITE</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>errno</name> = <name>ERANGE</name></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt></else></if>
}</block></then></if></else></if>
<if>if <condition>(<expr><name>errno</name> &amp;&amp; <call><name>is_error</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then>
<else>else
<return>return <expr><call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FUNC1</name><parameter_list>(<param><type><name>funcname</name></type></param>, <param><type><name>func</name></type></param>, <param><type><name>can_overflow</name></type></param>, <param><type><name>docstring</name></type></param>)</parameter_list></cpp:macro> <cpp:value>static PyObject * math_##funcname(PyObject *self, PyObject *args) { return math_1(args, func, can_overflow); }PyDoc_STRVAR(math_##funcname##_doc, docstring);</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FUNC2</name><parameter_list>(<param><type><name>funcname</name></type></param>, <param><type><name>func</name></type></param>, <param><type><name>docstring</name></type></param>)</parameter_list></cpp:macro> <cpp:value>static PyObject * math_##funcname(PyObject *self, PyObject *args) { return math_2(args, func, #funcname); }PyDoc_STRVAR(math_##funcname##_doc, docstring);</cpp:value></cpp:define>
<macro><name>FUNC1</name><argument_list>(<argument>acos</argument>, <argument>acos</argument>, <argument>0</argument>,
<argument>"acos(x)\n\nReturn the arc cosine (measured in radians) of x."</argument>)</argument_list></macro>
<macro><name>FUNC1</name><argument_list>(<argument>acosh</argument>, <argument>acosh</argument>, <argument>0</argument>,
<argument>"acosh(x)\n\nReturn the hyperbolic arc cosine (measured in radians) of x."</argument>)</argument_list></macro>
<macro><name>FUNC1</name><argument_list>(<argument>asin</argument>, <argument>asin</argument>, <argument>0</argument>,
<argument>"asin(x)\n\nReturn the arc sine (measured in radians) of x."</argument>)</argument_list></macro>
<macro><name>FUNC1</name><argument_list>(<argument>asinh</argument>, <argument>asinh</argument>, <argument>0</argument>,
<argument>"asinh(x)\n\nReturn the hyperbolic arc sine (measured in radians) of x."</argument>)</argument_list></macro>
<macro><name>FUNC1</name><argument_list>(<argument>atan</argument>, <argument>atan</argument>, <argument>0</argument>,
<argument>"atan(x)\n\nReturn the arc tangent (measured in radians) of x."</argument>)</argument_list></macro>
<macro><name>FUNC2</name><argument_list>(<argument>atan2</argument>, <argument>m_atan2</argument>,
<argument>"atan2(y, x)\n\nReturn the arc tangent (measured in radians) of y/x.\n"
"Unlike atan(y/x), the signs of both x and y are considered."</argument>)</argument_list></macro>
<macro><name>FUNC1</name><argument_list>(<argument>atanh</argument>, <argument>atanh</argument>, <argument>0</argument>,
<argument>"atanh(x)\n\nReturn the hyperbolic arc tangent (measured in radians) of x."</argument>)</argument_list></macro>
<macro><name>FUNC1</name><argument_list>(<argument>ceil</argument>, <argument>ceil</argument>, <argument>0</argument>,
<argument>"ceil(x)\n\nReturn the ceiling of x as a float.\n"
"This is the smallest integral value &gt;= x."</argument>)</argument_list></macro>
<macro><name>FUNC2</name><argument_list>(<argument>copysign</argument>, <argument>copysign</argument>,
<argument>"copysign(x,y)\n\nReturn x with the sign of y."</argument>)</argument_list></macro>
<macro><name>FUNC1</name><argument_list>(<argument>cos</argument>, <argument>cos</argument>, <argument>0</argument>,
<argument>"cos(x)\n\nReturn the cosine of x (measured in radians)."</argument>)</argument_list></macro>
<macro><name>FUNC1</name><argument_list>(<argument>cosh</argument>, <argument>cosh</argument>, <argument>1</argument>,
<argument>"cosh(x)\n\nReturn the hyperbolic cosine of x."</argument>)</argument_list></macro>
<macro><name>FUNC1</name><argument_list>(<argument>exp</argument>, <argument>exp</argument>, <argument>1</argument>,
<argument>"exp(x)\n\nReturn e raised to the power of x."</argument>)</argument_list></macro>
<macro><name>FUNC1</name><argument_list>(<argument>fabs</argument>, <argument>fabs</argument>, <argument>0</argument>,
<argument>"fabs(x)\n\nReturn the absolute value of the float x."</argument>)</argument_list></macro>
<macro><name>FUNC1</name><argument_list>(<argument>floor</argument>, <argument>floor</argument>, <argument>0</argument>,
<argument>"floor(x)\n\nReturn the floor of x as a float.\n"
"This is the largest integral value &lt;= x."</argument>)</argument_list></macro>
<macro><name>FUNC1</name><argument_list>(<argument>log1p</argument>, <argument>log1p</argument>, <argument>1</argument>,
<argument>"log1p(x)\n\nReturn the natural logarithm of 1+x (base e).\n\
The result is computed in a way which is accurate for x near zero."</argument>)</argument_list></macro>
<macro><name>FUNC1</name><argument_list>(<argument>sin</argument>, <argument>sin</argument>, <argument>0</argument>,
<argument>"sin(x)\n\nReturn the sine of x (measured in radians)."</argument>)</argument_list></macro>
<macro><name>FUNC1</name><argument_list>(<argument>sinh</argument>, <argument>sinh</argument>, <argument>1</argument>,
<argument>"sinh(x)\n\nReturn the hyperbolic sine of x."</argument>)</argument_list></macro>
<macro><name>FUNC1</name><argument_list>(<argument>sqrt</argument>, <argument>sqrt</argument>, <argument>0</argument>,
<argument>"sqrt(x)\n\nReturn the square root of x."</argument>)</argument_list></macro>
<macro><name>FUNC1</name><argument_list>(<argument>tan</argument>, <argument>tan</argument>, <argument>0</argument>,
<argument>"tan(x)\n\nReturn the tangent of x (measured in radians)."</argument>)</argument_list></macro>
<macro><name>FUNC1</name><argument_list>(<argument>tanh</argument>, <argument>tanh</argument>, <argument>0</argument>,
<argument>"tanh(x)\n\nReturn the hyperbolic tangent of x."</argument>)</argument_list></macro>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_PARTIALS</name></cpp:macro> <cpp:value>32</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>_fsum_realloc</name><parameter_list>(<param><decl><type><name>double</name> **</type><name>p_ptr</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>n</name></decl></param>,
<param><decl><type><name>double</name> *</type><name>ps</name></decl></param>, <param><decl><type><name>Py_ssize_t</name> *</type><name>m_ptr</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>void</name> *</type><name>v</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>m</name> <init>= <expr>*<name>m_ptr</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>m</name> += <name>m</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>n</name> &lt; <name>m</name> &amp;&amp; <name>m</name> &lt; (<name>PY_SSIZE_T_MAX</name> / <sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof>)</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>double</name> *</type><name>p</name> <init>= <expr>*<name>p_ptr</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>p</name> == <name>ps</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>v</name> = <call><name>PyMem_Malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof> * <name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> != <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>ps</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof> * <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></then> <else>else
<expr_stmt><expr><name>v</name> = <call><name>PyMem_Realloc</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof> * <name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
}</block></then></if>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_MemoryError</name></expr></argument>, <argument><expr>"math.fsum partials"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></then></if>
<expr_stmt><expr>*<name>p_ptr</name> = (<name>double</name>*) <name>v</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>m_ptr</name> = <name>m</name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>math_fsum</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>seq</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>item</name></decl>, *<decl><type ref="prev"/><name>iter</name></decl>, *<decl><type ref="prev"/><name>sum</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>n</name> <init>= <expr>0</expr></init>, <name>m</name> <init>= <expr><name>NUM_PARTIALS</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>x</name></decl>, <decl><type ref="prev"/><name>y</name></decl>, <decl><type ref="prev"/><name>t</name></decl>, <decl><type ref="prev"/><name><name>ps</name><index>[<expr><name>NUM_PARTIALS</name></expr>]</index></name></decl>, *<decl><type ref="prev"/><name>p</name> <init>= <expr><name>ps</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>xsave</name></decl>, <decl><type ref="prev"/><name>special_sum</name> <init>= <expr>0.0</expr></init>, <name>inf_sum</name> <init>= <expr>0.0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>volatile</specifier> <name>double</name></type> <name>hi</name></decl>, <decl><type ref="prev"/><name>yr</name></decl>, <decl><type ref="prev"/><name>lo</name></decl>;</decl_stmt>
<expr_stmt><expr><name>iter</name> = <call><name>PyObject_GetIter</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>iter</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<macro><name>PyFPE_START_PROTECT</name><argument_list>(<argument>"fsum"</argument>, <argument>Py_DECREF(iter); return NULL</argument>)</argument_list></macro>
<for>for(<init>;</init><condition>;</condition><incr/>) <block>{
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>0 &lt;= <name>n</name> &amp;&amp; <name>n</name> &lt;= <name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>(<name>m</name> == <name>NUM_PARTIALS</name> &amp;&amp; <name>p</name> == <name>ps</name>) ||
(<name>m</name> &gt; <name>NUM_PARTIALS</name> &amp;&amp; <name>p</name> != <name>NULL</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>item</name> = <call><name>PyIter_Next</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>item</name> == <name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<goto>goto <name>_fsum_error</name>;</goto></then></if>
<break>break;</break>
}</block></then></if>
<expr_stmt><expr><name>x</name> = <call><name>PyFloat_AsDouble</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<goto>goto <name>_fsum_error</name>;</goto></then></if>
<expr_stmt><expr><name>xsave</name> = <name>x</name></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = <name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
<expr_stmt><expr><name>y</name> = <name><name>p</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>fabs</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> &lt; <call><name>fabs</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>t</name> = <name>x</name></expr>;</expr_stmt>
<expr_stmt><expr><name>x</name> = <name>y</name></expr>;</expr_stmt>
<expr_stmt><expr><name>y</name> = <name>t</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>hi</name> = <name>x</name> + <name>y</name></expr>;</expr_stmt>
<expr_stmt><expr><name>yr</name> = <name>hi</name> - <name>x</name></expr>;</expr_stmt>
<expr_stmt><expr><name>lo</name> = <name>y</name> - <name>yr</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>lo</name> != 0.0</expr>)</condition><then>
<expr_stmt><expr><name><name>p</name><index>[<expr><name>i</name>++</expr>]</index></name> = <name>lo</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>x</name> = <name>hi</name></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><name>n</name> = <name>i</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>x</name> != 0.0</expr>)</condition><then> <block>{
<if>if <condition>(<expr>! <call><name>Py_IS_FINITE</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>Py_IS_FINITE</name><argument_list>(<argument><expr><name>xsave</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
<argument><expr>"intermediate overflow in fsum"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>_fsum_error</name>;</goto>
}</block></then></if>
<if>if <condition>(<expr><call><name>Py_IS_INFINITY</name><argument_list>(<argument><expr><name>xsave</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>inf_sum</name> += <name>xsave</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>special_sum</name> += <name>xsave</name></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> = 0</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>n</name> &gt;= <name>m</name> &amp;&amp; <call><name>_fsum_realloc</name><argument_list>(<argument><expr>&amp;<name>p</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>ps</name></expr></argument>, <argument><expr>&amp;<name>m</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<goto>goto <name>_fsum_error</name>;</goto></then>
<else>else
<expr_stmt><expr><name><name>p</name><index>[<expr><name>n</name>++</expr>]</index></name> = <name>x</name></expr>;</expr_stmt></else></if></else></if>
}</block></then></if>
}</block></for>
<if>if <condition>(<expr><name>special_sum</name> != 0.0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>Py_IS_NAN</name><argument_list>(<argument><expr><name>inf_sum</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"-inf + inf in fsum"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>sum</name> = <call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr><name>special_sum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<goto>goto <name>_fsum_error</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>hi</name> = 0.0</expr>;</expr_stmt>
<if>if <condition>(<expr><name>n</name> &gt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>hi</name> = <name><name>p</name><index>[<expr>--<name>n</name></expr>]</index></name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>n</name> &gt; 0</expr>)</condition> <block>{
<expr_stmt><expr><name>x</name> = <name>hi</name></expr>;</expr_stmt>
<expr_stmt><expr><name>y</name> = <name><name>p</name><index>[<expr>--<name>n</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>fabs</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call> &lt; <call><name>fabs</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>hi</name> = <name>x</name> + <name>y</name></expr>;</expr_stmt>
<expr_stmt><expr><name>yr</name> = <name>hi</name> - <name>x</name></expr>;</expr_stmt>
<expr_stmt><expr><name>lo</name> = <name>y</name> - <name>yr</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>lo</name> != 0.0</expr>)</condition><then>
<break>break;</break></then></if>
}</block></while>
<if>if <condition>(<expr><name>n</name> &gt; 0 &amp;&amp; ((<name>lo</name> &lt; 0.0 &amp;&amp; <name><name>p</name><index>[<expr><name>n</name>-1</expr>]</index></name> &lt; 0.0) ||
(<name>lo</name> &gt; 0.0 &amp;&amp; <name><name>p</name><index>[<expr><name>n</name>-1</expr>]</index></name> &gt; 0.0))</expr>)</condition><then> <block>{
<expr_stmt><expr><name>y</name> = <name>lo</name> * 2.0</expr>;</expr_stmt>
<expr_stmt><expr><name>x</name> = <name>hi</name> + <name>y</name></expr>;</expr_stmt>
<expr_stmt><expr><name>yr</name> = <name>x</name> - <name>hi</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>y</name> == <name>yr</name></expr>)</condition><then>
<expr_stmt><expr><name>hi</name> = <name>x</name></expr>;</expr_stmt></then></if>
}</block></then></if>
}</block></then></if>
<expr_stmt><expr><name>sum</name> = <call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>_fsum_error</name>:</label>
<macro><name>PyFPE_END_PROTECT</name><argument_list>(<argument>hi</argument>)</argument_list></macro>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>p</name> != <name>ps</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>sum</name></expr>;</return>
}</block></function>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>NUM_PARTIALS</name></cpp:undef>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>math_fsum_doc</name></expr></argument>,
<argument><expr>"sum(iterable)\n\n\
Return an accurate floating point sum of values in the iterable.\n\
Assumes IEEE-754 floating point arithmetic."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>math_factorial</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>long</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>x</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>, *<decl><type ref="prev"/><name>iobj</name></decl>, *<decl><type ref="prev"/><name>newresult</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyFloat_Check</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>double</name></type> <name>dx</name> <init>= <expr><call><name>PyFloat_AS_DOUBLE</name><argument_list>(<argument><expr>(<name>PyFloatObject</name> *)<name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>dx</name> != <call><name>floor</name><argument_list>(<argument><expr><name>dx</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"factorial() only accepts integral values"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
}</block></then></if>
<expr_stmt><expr><name>x</name> = <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>x</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>x</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"factorial() not defined for negative values"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>result</name> = (<name>PyObject</name> *)<call><name>PyInt_FromLong</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<for>for (<init><expr><name>i</name>=1</expr> ;</init> <condition><expr><name>i</name>&lt;=<name>x</name></expr> ;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><name>iobj</name> = (<name>PyObject</name> *)<call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>iobj</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<expr_stmt><expr><name>newresult</name> = <call><name>PyNumber_Multiply</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>iobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>newresult</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> = <name>newresult</name></expr>;</expr_stmt>
}</block></for>
<return>return <expr><name>result</name></expr>;</return>
<label><name>error</name>:</label>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>math_factorial_doc</name></expr></argument>, <argument><expr>"Return n!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>math_trunc</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>number</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>PyObject_CallMethod</name><argument_list>(<argument><expr><name>number</name></expr></argument>, <argument><expr>"__trunc__"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>math_trunc_doc</name></expr></argument>,
<argument><expr>"trunc(x:Real) -&gt; Integral\n"
"\n"
"Truncates x to the nearest Integral toward 0. Uses the __trunc__ magic method."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>math_frexp</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>x</name> <init>= <expr><call><name>PyFloat_AsDouble</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>x</name> == -1.0 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>Py_IS_NAN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> || <call><name>Py_IS_INFINITY</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> || !<name>x</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>i</name> = 0</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<macro><name>PyFPE_START_PROTECT</name><argument_list>(<argument>"in math_frexp"</argument>, <argument>return 0</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<expr_stmt><expr><name>x</name> = <call><name>frexp</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr>&amp;<name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyFPE_END_PROTECT</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(di)"</expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>math_frexp_doc</name></expr></argument>,
<argument><expr>"frexp(x)\n"
"\n"
"Return the mantissa and exponent of x, as pair (m, e).\n"
"m is a float and e is an int, such that x = m * 2.**e.\n"
"If x is 0, m and e are both 0. Else 0.5 &lt;= abs(m) &lt; 1.0."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>math_ldexp</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>double</name></type> <name>x</name></decl>, <decl><type ref="prev"/><name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>oexp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>exp</name></decl>;</decl_stmt>
<if>if <condition>(<expr>! <call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"dO:ldexp"</expr></argument>, <argument><expr>&amp;<name>x</name></expr></argument>, <argument><expr>&amp;<name>oexp</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>PyLong_Check</name><argument_list>(<argument><expr><name>oexp</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>exp</name> = <call><name>PyLong_AsLong</name><argument_list>(<argument><expr><name>oexp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>exp</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>oexp</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>exp</name> = <name>LONG_MIN</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>exp</name> = <name>LONG_MAX</name></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<return>return <expr><name>NULL</name></expr>;</return>
}</block></else></if>
}</block></then></if>
}</block></then> <else>else <if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>oexp</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>exp</name> = <call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><name>oexp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"Expected an int or long as second argument "
"to ldexp."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></else></if></else></if>
<if>if <condition>(<expr><name>x</name> == 0. || !<call><name>Py_IS_FINITE</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>r</name> = <name>x</name></expr>;</expr_stmt>
<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>exp</name> &gt; <name>INT_MAX</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>r</name> = <call><name>copysign</name><argument_list>(<argument><expr><name>Py_HUGE_VAL</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>errno</name> = <name>ERANGE</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>exp</name> &lt; <name>INT_MIN</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>r</name> = <call><name>copysign</name><argument_list>(<argument><expr>0.</expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
<macro><name>PyFPE_START_PROTECT</name><argument_list>(<argument>"in math_ldexp"</argument>, <argument>return 0</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<expr_stmt><expr><name>r</name> = <call><name>ldexp</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr>(<name>int</name>)<name>exp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyFPE_END_PROTECT</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>Py_IS_INFINITY</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>errno</name> = <name>ERANGE</name></expr>;</expr_stmt></then></if>
}</block></else></if></else></if></else></if>
<if>if <condition>(<expr><name>errno</name> &amp;&amp; <call><name>is_error</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>math_ldexp_doc</name></expr></argument>,
<argument><expr>"ldexp(x, i) -&gt; x * (2**i)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>math_modf</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>double</name></type> <name>y</name></decl>, <decl><type ref="prev"/><name>x</name> <init>= <expr><call><name>PyFloat_AsDouble</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>x</name> == -1.0 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>Py_IS_FINITE</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>Py_IS_INFINITY</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(dd)"</expr></argument>, <argument><expr><call><name>copysign</name><argument_list>(<argument><expr>0.</expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return></then>
<else>else <if>if <condition>(<expr><call><name>Py_IS_NAN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(dd)"</expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return></then></if></else></if>
}</block></then></if>
<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
<macro><name>PyFPE_START_PROTECT</name><argument_list>(<argument>"in math_modf"</argument>, <argument>return 0</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<expr_stmt><expr><name>x</name> = <call><name>modf</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr>&amp;<name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyFPE_END_PROTECT</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(dd)"</expr></argument>, <argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>math_modf_doc</name></expr></argument>,
<argument><expr>"modf(x)\n"
"\n"
"Return the fractional and integer parts of x. Both results carry the sign\n"
"of x. The integer part is returned as a real."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>loghelper</name><parameter_list>(<param><decl><type><name>PyObject</name>*</type> <name>arg</name></decl></param>, <param><function_decl><type><name>double</name></type> (*<name>func</name>)<parameter_list>(<param><decl><type><name>double</name></type></decl></param>)</parameter_list></function_decl></param>, <param><decl><type><name>char</name> *</type><name>funcname</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><call><name>PyLong_Check</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>double</name></type> <name>x</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>e</name></decl>;</decl_stmt>
<expr_stmt><expr><name>x</name> = <call><name>_PyLong_AsScaledDouble</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr>&amp;<name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>x</name> &lt;= 0.0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"math domain error"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>x</name> = <call><name>func</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> + (<macro><name>e</name></macro> * (<name>double</name>)<name>PyLong_SHIFT</name>) * <call><name>func</name><argument_list>(<argument><expr>2.0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>math_1</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>func</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>math_log</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>arg</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>base</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>num</name></decl>, *<decl><type ref="prev"/><name>den</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>ans</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"log"</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>&amp;<name>arg</name></expr></argument>, <argument><expr>&amp;<name>base</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>num</name> = <call><name>loghelper</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>log</name></expr></argument>, <argument><expr>"log"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>num</name> == <name>NULL</name> || <name>base</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>num</name></expr>;</return></then></if>
<expr_stmt><expr><name>den</name> = <call><name>loghelper</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>log</name></expr></argument>, <argument><expr>"log"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>den</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>ans</name> = <call><name>PyNumber_Divide</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><name>den</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>den</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ans</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>math_log_doc</name></expr></argument>,
<argument><expr>"log(x[, base]) -&gt; the logarithm of x to the given base.\n\
If the base not specified, returns the natural logarithm (base e) of x."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>math_log10</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>loghelper</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>log10</name></expr></argument>, <argument><expr>"log10"</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>math_log10_doc</name></expr></argument>,
<argument><expr>"log10(x) -&gt; the base 10 logarithm of x."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>math_fmod</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>ox</name></decl>, *<decl><type ref="prev"/><name>oy</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>r</name></decl>, <decl><type ref="prev"/><name>x</name></decl>, <decl><type ref="prev"/><name>y</name></decl>;</decl_stmt>
<if>if <condition>(<expr>! <call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"fmod"</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>&amp;<name>ox</name></expr></argument>, <argument><expr>&amp;<name>oy</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>x</name> = <call><name>PyFloat_AsDouble</name><argument_list>(<argument><expr><name>ox</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>y</name> = <call><name>PyFloat_AsDouble</name><argument_list>(<argument><expr><name>oy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>(<name>x</name> == -1.0 || <name>y</name> == -1.0) &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>Py_IS_INFINITY</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>Py_IS_FINITE</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
<macro><name>PyFPE_START_PROTECT</name><argument_list>(<argument>"in math_fmod"</argument>, <argument>return 0</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<expr_stmt><expr><name>r</name> = <call><name>fmod</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyFPE_END_PROTECT</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>Py_IS_NAN</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<call><name>Py_IS_NAN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>Py_IS_NAN</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>errno</name> = <name>EDOM</name></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt></else></if>
}</block></then></if>
<if>if <condition>(<expr><name>errno</name> &amp;&amp; <call><name>is_error</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then>
<else>else
<return>return <expr><call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>math_fmod_doc</name></expr></argument>,
<argument><expr>"fmod(x,y)\n\nReturn fmod(x, y), according to platform C."
" x % y may differ."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>math_hypot</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>ox</name></decl>, *<decl><type ref="prev"/><name>oy</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>r</name></decl>, <decl><type ref="prev"/><name>x</name></decl>, <decl><type ref="prev"/><name>y</name></decl>;</decl_stmt>
<if>if <condition>(<expr>! <call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"hypot"</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>&amp;<name>ox</name></expr></argument>, <argument><expr>&amp;<name>oy</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>x</name> = <call><name>PyFloat_AsDouble</name><argument_list>(<argument><expr><name>ox</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>y</name> = <call><name>PyFloat_AsDouble</name><argument_list>(<argument><expr><name>oy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>(<name>x</name> == -1.0 || <name>y</name> == -1.0) &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>Py_IS_INFINITY</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr><call><name>fabs</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>Py_IS_INFINITY</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr><call><name>fabs</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
<macro><name>PyFPE_START_PROTECT</name><argument_list>(<argument>"in math_hypot"</argument>, <argument>return 0</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<expr_stmt><expr><name>r</name> = <call><name>hypot</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyFPE_END_PROTECT</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>Py_IS_NAN</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<call><name>Py_IS_NAN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>Py_IS_NAN</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>errno</name> = <name>EDOM</name></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt></else></if>
}</block></then> <else>else <if>if <condition>(<expr><call><name>Py_IS_INFINITY</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>Py_IS_FINITE</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>Py_IS_FINITE</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>errno</name> = <name>ERANGE</name></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt></else></if>
}</block></then></if></else></if>
<if>if <condition>(<expr><name>errno</name> &amp;&amp; <call><name>is_error</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then>
<else>else
<return>return <expr><call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>math_hypot_doc</name></expr></argument>,
<argument><expr>"hypot(x,y)\n\nReturn the Euclidean distance, sqrt(x*x + y*y)."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>math_pow</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>ox</name></decl>, *<decl><type ref="prev"/><name>oy</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>r</name></decl>, <decl><type ref="prev"/><name>x</name></decl>, <decl><type ref="prev"/><name>y</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>odd_y</name></decl>;</decl_stmt>
<if>if <condition>(<expr>! <call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"pow"</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>&amp;<name>ox</name></expr></argument>, <argument><expr>&amp;<name>oy</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>x</name> = <call><name>PyFloat_AsDouble</name><argument_list>(<argument><expr><name>ox</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>y</name> = <call><name>PyFloat_AsDouble</name><argument_list>(<argument><expr><name>oy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>(<name>x</name> == -1.0 || <name>y</name> == -1.0) &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>r</name> = 0.</expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>Py_IS_FINITE</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> || !<call><name>Py_IS_FINITE</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>Py_IS_NAN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>r</name> = <name>y</name> == 0. ? 1. : <name>x</name></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><call><name>Py_IS_NAN</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>r</name> = <name>x</name> == 1. ? 1. : <name>y</name></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><call><name>Py_IS_INFINITY</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>odd_y</name> = <call><name>Py_IS_FINITE</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>fmod</name><argument_list>(<argument><expr><call><name>fabs</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>2.0</expr></argument>)</argument_list></call> == 1.0</expr>;</expr_stmt>
<if>if <condition>(<expr><name>y</name> &gt; 0.</expr>)</condition><then>
<expr_stmt><expr><name>r</name> = <name>odd_y</name> ? <name>x</name> : <call><name>fabs</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name>y</name> == 0.</expr>)</condition><then>
<expr_stmt><expr><name>r</name> = 1.</expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>r</name> = <name>odd_y</name> ? <call><name>copysign</name><argument_list>(<argument><expr>0.</expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call> : 0.</expr>;</expr_stmt></else></if></else></if>
}</block></then> <else>else <if>if <condition>(<expr><call><name>Py_IS_INFINITY</name><argument_list>(<argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>fabs</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> == 1.0</expr>)</condition><then>
<expr_stmt><expr><name>r</name> = 1.</expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name>y</name> &gt; 0. &amp;&amp; <call><name>fabs</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> &gt; 1.0</expr>)</condition><then>
<expr_stmt><expr><name>r</name> = <name>y</name></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name>y</name> &lt; 0. &amp;&amp; <call><name>fabs</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> &lt; 1.0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>r</name> = -<name>y</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>x</name> == 0.</expr>)</condition><then>
<expr_stmt><expr><name>errno</name> = <name>EDOM</name></expr>;</expr_stmt></then></if>
}</block></then> <else>else
<expr_stmt><expr><name>r</name> = 0.</expr>;</expr_stmt></else></if></else></if></else></if>
}</block></then></if></else></if></else></if></else></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
<macro><name>PyFPE_START_PROTECT</name><argument_list>(<argument>"in math_pow"</argument>, <argument>return 0</argument>)</argument_list></macro><empty_stmt>;</empty_stmt>
<expr_stmt><expr><name>r</name> = <call><name>pow</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyFPE_END_PROTECT</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>Py_IS_FINITE</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>Py_IS_NAN</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>errno</name> = <name>EDOM</name></expr>;</expr_stmt>
}</block></then>
<else>else <if>if <condition>(<expr><call><name>Py_IS_INFINITY</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>x</name> == 0.</expr>)</condition><then>
<expr_stmt><expr><name>errno</name> = <name>EDOM</name></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>errno</name> = <name>ERANGE</name></expr>;</expr_stmt></else></if>
}</block></then></if></else></if>
}</block></then></if>
}</block></else></if>
<if>if <condition>(<expr><name>errno</name> &amp;&amp; <call><name>is_error</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then>
<else>else
<return>return <expr><call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>math_pow_doc</name></expr></argument>,
<argument><expr>"pow(x,y)\n\nReturn x**y (x to the power of y)."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>double</name></type> <name>degToRad</name> <init>= <expr><name>Py_MATH_PI</name> / 180.0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>double</name></type> <name>radToDeg</name> <init>= <expr>180.0 / <name>Py_MATH_PI</name></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>math_degrees</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>double</name></type> <name>x</name> <init>= <expr><call><name>PyFloat_AsDouble</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>x</name> == -1.0 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr><name>x</name> * <name>radToDeg</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>math_degrees_doc</name></expr></argument>,
<argument><expr>"degrees(x) -&gt; converts angle x from radians to degrees"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>math_radians</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>double</name></type> <name>x</name> <init>= <expr><call><name>PyFloat_AsDouble</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>x</name> == -1.0 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr><name>x</name> * <name>degToRad</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>math_radians_doc</name></expr></argument>,
<argument><expr>"radians(x) -&gt; converts angle x from degrees to radians"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>math_isnan</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>double</name></type> <name>x</name> <init>= <expr><call><name>PyFloat_AsDouble</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>x</name> == -1.0 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<call><name>Py_IS_NAN</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>math_isnan_doc</name></expr></argument>,
<argument><expr>"isnan(x) -&gt; bool\n\
Checks if float x is not a number (NaN)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>math_isinf</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>arg</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>double</name></type> <name>x</name> <init>= <expr><call><name>PyFloat_AsDouble</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>x</name> == -1.0 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<call><name>Py_IS_INFINITY</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>math_isinf_doc</name></expr></argument>,
<argument><expr>"isinf(x) -&gt; bool\n\
Checks if float x is infinite (positive or negative)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>math_methods</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr>"acos"</expr>, <expr><name>math_acos</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>math_acos_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"acosh"</expr>, <expr><name>math_acosh</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>math_acosh_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"asin"</expr>, <expr><name>math_asin</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>math_asin_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"asinh"</expr>, <expr><name>math_asinh</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>math_asinh_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"atan"</expr>, <expr><name>math_atan</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>math_atan_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"atan2"</expr>, <expr><name>math_atan2</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>math_atan2_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"atanh"</expr>, <expr><name>math_atanh</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>math_atanh_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"ceil"</expr>, <expr><name>math_ceil</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>math_ceil_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"copysign"</expr>, <expr><name>math_copysign</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>math_copysign_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"cos"</expr>, <expr><name>math_cos</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>math_cos_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"cosh"</expr>, <expr><name>math_cosh</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>math_cosh_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"degrees"</expr>, <expr><name>math_degrees</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>math_degrees_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"exp"</expr>, <expr><name>math_exp</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>math_exp_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"fabs"</expr>, <expr><name>math_fabs</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>math_fabs_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"factorial"</expr>, <expr><name>math_factorial</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>math_factorial_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"floor"</expr>, <expr><name>math_floor</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>math_floor_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"fmod"</expr>, <expr><name>math_fmod</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>math_fmod_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"frexp"</expr>, <expr><name>math_frexp</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>math_frexp_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"fsum"</expr>, <expr><name>math_fsum</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>math_fsum_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"hypot"</expr>, <expr><name>math_hypot</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>math_hypot_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"isinf"</expr>, <expr><name>math_isinf</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>math_isinf_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"isnan"</expr>, <expr><name>math_isnan</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>math_isnan_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"ldexp"</expr>, <expr><name>math_ldexp</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>math_ldexp_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"log"</expr>, <expr><name>math_log</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>math_log_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"log1p"</expr>, <expr><name>math_log1p</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>math_log1p_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"log10"</expr>, <expr><name>math_log10</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>math_log10_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"modf"</expr>, <expr><name>math_modf</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>math_modf_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"pow"</expr>, <expr><name>math_pow</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>math_pow_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"radians"</expr>, <expr><name>math_radians</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>math_radians_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"sin"</expr>, <expr><name>math_sin</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>math_sin_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"sinh"</expr>, <expr><name>math_sinh</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>math_sinh_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"sqrt"</expr>, <expr><name>math_sqrt</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>math_sqrt_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"tan"</expr>, <expr><name>math_tan</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>math_tan_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"tanh"</expr>, <expr><name>math_tanh</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>math_tanh_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"trunc"</expr>, <expr><name>math_trunc</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>math_trunc_doc</name></expr>}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>module_doc</name></expr></argument>,
<argument><expr>"This module is always available. It provides access to the\n"
"mathematical functions defined by the C standard."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><name>PyMODINIT_FUNC</name></type>
<name>initmath</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name></decl>;</decl_stmt>
<expr_stmt><expr><name>m</name> = <call><name>Py_InitModule3</name><argument_list>(<argument><expr>"math"</expr></argument>, <argument><expr><name>math_methods</name></expr></argument>, <argument><expr><name>module_doc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>m</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>finally</name>;</goto></then></if>
<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"pi"</expr></argument>, <argument><expr><call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr><name>Py_MATH_PI</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"e"</expr></argument>, <argument><expr><call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr><name>Py_MATH_E</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>finally</name>:</label>
<return>return;</return>
}</block></function>
</unit>
