<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="Modules/_sqlite/statement.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"statement.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cursor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"connection.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"microprotocols.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"prepare_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"sqlitecompat.h"</cpp:file></cpp:include>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>pysqlite_check_remaining_sql</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>tail</name></decl></param>)</parameter_list>;</function_decl>
<typedef>typedef <type><enum>enum <block>{
<decl><name>LINECOMMENT_1</name></decl>,
<decl><name>IN_LINECOMMENT</name></decl>,
<decl><name>COMMENTSTART_1</name></decl>,
<decl><name>IN_COMMENT</name></decl>,
<decl><name>COMMENTEND_1</name></decl>,
<decl><name>NORMAL</name></decl>
}</block></enum></type> <name>parse_remaining_sql_state</name>;</typedef>
<typedef>typedef <type><enum>enum <block>{
<decl><name>TYPE_INT</name></decl>,
<decl><name>TYPE_LONG</name></decl>,
<decl><name>TYPE_FLOAT</name></decl>,
<decl><name>TYPE_STRING</name></decl>,
<decl><name>TYPE_UNICODE</name></decl>,
<decl><name>TYPE_BUFFER</name></decl>,
<decl><name>TYPE_UNKNOWN</name></decl>
}</block></enum></type> <name>parameter_type</name>;</typedef>
<function><type><name>int</name></type> <name>pysqlite_statement_create</name><parameter_list>(<param><decl><type><name>pysqlite_Statement</name>*</type> <name>self</name></decl></param>, <param><decl><type><name>pysqlite_Connection</name>*</type> <name>connection</name></decl></param>, <param><decl><type><name>PyObject</name>*</type> <name>sql</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>tail</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name>*</type> <name>sql_str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>*</type> <name>sql_cstr</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>st</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>in_use</name></name> = 0</expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>sql</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>sql_str</name> = <name>sql</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>sql_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>sql</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>sql_str</name> = <call><name>PyUnicode_AsUTF8String</name><argument_list>(<argument><expr><name>sql</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>sql_str</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>rc</name> = <name>PYSQLITE_SQL_WRONG_TYPE</name></expr>;</expr_stmt>
<return>return <expr><name>rc</name></expr>;</return>
}</block></then></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>rc</name> = <name>PYSQLITE_SQL_WRONG_TYPE</name></expr>;</expr_stmt>
<return>return <expr><name>rc</name></expr>;</return>
}</block></else></if></else></if>
<expr_stmt><expr><name><name>self</name>-&gt;<name>in_weakreflist</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>sql</name></name> = <name>sql_str</name></expr>;</expr_stmt>
<expr_stmt><expr><name>sql_cstr</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><name>sql_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>rc</name> <init>= <expr><call><name>sqlite3_prepare</name><argument_list>(<argument><expr><name><name>connection</name>-&gt;<name>db</name></name></expr></argument>,
<argument><expr><name>sql_cstr</name></expr></argument>,
<argument><expr>-1</expr></argument>,
<argument><expr>&amp;<name><name>self</name>-&gt;<name>st</name></name></expr></argument>,
<argument><expr>&amp;<name>tail</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_END_ALLOW_THREADS</name></type>
<name><name>self</name>-&gt;<name>db</name></name> <init>= <expr><name><name>connection</name>-&gt;<name>db</name></name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>rc</name> == <name>SQLITE_OK</name> &amp;&amp; <call><name>pysqlite_check_remaining_sql</name><argument_list>(<argument><expr><name>tail</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr>(<name>void</name>)<call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>st</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>st</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>rc</name> = <name>PYSQLITE_TOO_MUCH_SQL</name></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>rc</name></expr>;</return>
}</block></function>
<function><type><name>int</name></type> <name>pysqlite_statement_bind_parameter</name><parameter_list>(<param><decl><type><name>pysqlite_Statement</name>*</type> <name>self</name></decl></param>, <param><decl><type><name>int</name></type> <name>pos</name></decl></param>, <param><decl><type><name>PyObject</name>*</type> <name>parameter</name></decl></param>, <param><decl><type><name>int</name></type> <name>allow_8bit_chars</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>rc</name> <init>= <expr><name>SQLITE_OK</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>longval</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PY_LONG_LONG</name></type> <name>longlongval</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>buffer</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>*</type> <name>string</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>buflen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name>*</type> <name>stringval</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>parameter_type</name></type> <name>paramtype</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>*</type> <name>c</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>parameter</name> == <name>Py_None</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>rc</name> = <call><name>sqlite3_bind_null</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>st</name></name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>final</name>;</goto>
}</block></then></if>
<if>if <condition>(<expr><call><name>PyInt_CheckExact</name><argument_list>(<argument><expr><name>parameter</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>paramtype</name> = <name>TYPE_INT</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><call><name>PyLong_CheckExact</name><argument_list>(<argument><expr><name>parameter</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>paramtype</name> = <name>TYPE_LONG</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><call><name>PyFloat_CheckExact</name><argument_list>(<argument><expr><name>parameter</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>paramtype</name> = <name>TYPE_FLOAT</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><call><name>PyString_CheckExact</name><argument_list>(<argument><expr><name>parameter</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>paramtype</name> = <name>TYPE_STRING</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><call><name>PyUnicode_CheckExact</name><argument_list>(<argument><expr><name>parameter</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>paramtype</name> = <name>TYPE_UNICODE</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><call><name>PyBuffer_Check</name><argument_list>(<argument><expr><name>parameter</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>paramtype</name> = <name>TYPE_BUFFER</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>parameter</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>paramtype</name> = <name>TYPE_INT</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><call><name>PyLong_Check</name><argument_list>(<argument><expr><name>parameter</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>paramtype</name> = <name>TYPE_LONG</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><call><name>PyFloat_Check</name><argument_list>(<argument><expr><name>parameter</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>paramtype</name> = <name>TYPE_FLOAT</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>parameter</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>paramtype</name> = <name>TYPE_STRING</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>parameter</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>paramtype</name> = <name>TYPE_UNICODE</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>paramtype</name> = <name>TYPE_UNKNOWN</name></expr>;</expr_stmt>
}</block></else></if></else></if></else></if></else></if></else></if></else></if></else></if></else></if></else></if></else></if></else></if>
<if>if <condition>(<expr><name>paramtype</name> == <name>TYPE_STRING</name> &amp;&amp; !<name>allow_8bit_chars</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>string</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>parameter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>c</name> = <name>string</name></expr>;</init> <condition><expr>*<name>c</name> != 0</expr>;</condition> <incr><expr><name>c</name>++</expr></incr>) <block>{
<if>if <condition>(<expr>*<name>c</name> &amp; 0x80</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>pysqlite_ProgrammingError</name></expr></argument>, <argument><expr>"You must not use 8-bit bytestrings unless you use a text_factory that can interpret 8-bit bytestrings (like text_factory = str). It is highly recommended that you instead just switch your application to Unicode strings."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rc</name> = -1</expr>;</expr_stmt>
<goto>goto <name>final</name>;</goto>
}</block></then></if>
}</block></for>
}</block></then></if>
<switch>switch <condition>(<expr><name>paramtype</name></expr>)</condition> <block>{
<case>case <expr><name>TYPE_INT</name></expr>:
<expr_stmt><expr><name>longval</name> = <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>parameter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rc</name> = <call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>st</name></name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr>(<name>sqlite_int64</name>)<name>longval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>TYPE_LONG</name></expr>:
<expr_stmt><expr><name>longlongval</name> = <call><name>PyLong_AsLongLong</name><argument_list>(<argument><expr><name>parameter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rc</name> = <call><name>sqlite3_bind_int64</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>st</name></name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr>(<name>sqlite_int64</name>)<name>longlongval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>TYPE_FLOAT</name></expr>:
<expr_stmt><expr><name>rc</name> = <call><name>sqlite3_bind_double</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>st</name></name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><call><name>PyFloat_AsDouble</name><argument_list>(<argument><expr><name>parameter</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>TYPE_STRING</name></expr>:
<expr_stmt><expr><name>string</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>parameter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rc</name> = <call><name>sqlite3_bind_text</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>st</name></name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>string</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>TYPE_UNICODE</name></expr>:
<expr_stmt><expr><name>stringval</name> = <call><name>PyUnicode_AsUTF8String</name><argument_list>(<argument><expr><name>parameter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>string</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><name>stringval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rc</name> = <call><name>sqlite3_bind_text</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>st</name></name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>string</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>stringval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>TYPE_BUFFER</name></expr>:
<if>if <condition>(<expr><call><name>PyObject_AsCharBuffer</name><argument_list>(<argument><expr><name>parameter</name></expr></argument>, <argument><expr>&amp;<name>buffer</name></expr></argument>, <argument><expr>&amp;<name>buflen</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>rc</name> = <call><name>sqlite3_bind_blob</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>st</name></name></expr></argument>, <argument><expr><name>pos</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>, <argument><expr><name>SQLITE_TRANSIENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"could not convert BLOB to buffer"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rc</name> = -1</expr>;</expr_stmt>
}</block></else></if>
<break>break;</break>
</case><case>case <expr><name>TYPE_UNKNOWN</name></expr>:
<expr_stmt><expr><name>rc</name> = -1</expr>;</expr_stmt>
</case>}</block></switch>
<label><name>final</name>:</label>
<return>return <expr><name>rc</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>_need_adapt</name><parameter_list>(<param><decl><type><name>PyObject</name>*</type> <name>obj</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name>pysqlite_BaseTypeAdapted</name></expr>)</condition><then> <block>{
<return>return <expr>1</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><call><name>PyInt_CheckExact</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> || <call><name>PyLong_CheckExact</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call>
|| <call><name>PyFloat_CheckExact</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> || <call><name>PyString_CheckExact</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call>
|| <call><name>PyUnicode_CheckExact</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call> || <call><name>PyBuffer_Check</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<return>return <expr>0</expr>;</return>
}</block></then> <else>else <block>{
<return>return <expr>1</expr>;</return>
}</block></else></if>
}</block></function>
<function><type><name>void</name></type> <name>pysqlite_statement_bind_parameters</name><parameter_list>(<param><decl><type><name>pysqlite_Statement</name>*</type> <name>self</name></decl></param>, <param><decl><type><name>PyObject</name>*</type> <name>parameters</name></decl></param>, <param><decl><type><name>int</name></type> <name>allow_8bit_chars</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name>*</type> <name>current_param</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name>*</type> <name>adapted</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>binding_name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>num_params_needed</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>num_params</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>num_params_needed</name> <init>= <expr><call><name>sqlite3_bind_parameter_count</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>st</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><call><name>PyTuple_CheckExact</name><argument_list>(<argument><expr><name>parameters</name></expr></argument>)</argument_list></call> || <call><name>PyList_CheckExact</name><argument_list>(<argument><expr><name>parameters</name></expr></argument>)</argument_list></call> || (!<call><name>PyDict_Check</name><argument_list>(<argument><expr><name>parameters</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>PySequence_Check</name><argument_list>(<argument><expr><name>parameters</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PyTuple_CheckExact</name><argument_list>(<argument><expr><name>parameters</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>num_params</name> = <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>parameters</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><call><name>PyList_CheckExact</name><argument_list>(<argument><expr><name>parameters</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>num_params</name> = <call><name>PyList_GET_SIZE</name><argument_list>(<argument><expr><name>parameters</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>num_params</name> = <call><name>PySequence_Size</name><argument_list>(<argument><expr><name>parameters</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if></else></if>
<if>if <condition>(<expr><name>num_params</name> != <name>num_params_needed</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>pysqlite_ProgrammingError</name></expr></argument>, <argument><expr>"Incorrect number of bindings supplied. The current statement uses %d, and there are %d supplied."</expr></argument>,
<argument><expr><name>num_params_needed</name></expr></argument>, <argument><expr><name>num_params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
}</block></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>num_params</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<if>if <condition>(<expr><call><name>PyTuple_CheckExact</name><argument_list>(<argument><expr><name>parameters</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>current_param</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>parameters</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name>current_param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><call><name>PyList_CheckExact</name><argument_list>(<argument><expr><name>parameters</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>current_param</name> = <call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>parameters</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name>current_param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>current_param</name> = <call><name>PySequence_GetItem</name><argument_list>(<argument><expr><name>parameters</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if></else></if>
<if>if <condition>(<expr>!<name>current_param</name></expr>)</condition><then> <block>{
<return>return;</return>
}</block></then></if>
<if>if <condition>(<expr>!<call><name>_need_adapt</name><argument_list>(<argument><expr><name>current_param</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>adapted</name> = <name>current_param</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>adapted</name> = <call><name>pysqlite_microprotocols_adapt</name><argument_list>(<argument><expr><name>current_param</name></expr></argument>, <argument><expr>(<name>PyObject</name>*)&amp;<name>pysqlite_PrepareProtocolType</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>adapted</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>current_param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>adapted</name> = <name>current_param</name></expr>;</expr_stmt>
}</block></else></if>
}</block></else></if>
<expr_stmt><expr><name>rc</name> = <call><name>pysqlite_statement_bind_parameter</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>i</name> + 1</expr></argument>, <argument><expr><name>adapted</name></expr></argument>, <argument><expr><name>allow_8bit_chars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>adapted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rc</name> != <name>SQLITE_OK</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>pysqlite_InterfaceError</name></expr></argument>, <argument><expr>"Error binding parameter %d - probably unsupported type."</expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return;</return>
}</block></then></if>
}</block></for>
}</block></then> <else>else <if>if <condition>(<expr><call><name>PyDict_Check</name><argument_list>(<argument><expr><name>parameters</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<for>for (<init><expr><name>i</name> = 1</expr>;</init> <condition><expr><name>i</name> &lt;= <name>num_params_needed</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>binding_name</name> <init>= <expr><call><name>sqlite3_bind_parameter_name</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>st</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr>!<name>binding_name</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>pysqlite_ProgrammingError</name></expr></argument>, <argument><expr>"Binding %d has no name, but you supplied a dictionary (which has only names)."</expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
}</block></then></if>
<expr_stmt><expr><name>binding_name</name>++</expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyDict_CheckExact</name><argument_list>(<argument><expr><name>parameters</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>current_param</name> = <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>parameters</name></expr></argument>, <argument><expr><name>binding_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name>current_param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>current_param</name> = <call><name>PyMapping_GetItemString</name><argument_list>(<argument><expr><name>parameters</name></expr></argument>, <argument><expr>(<name>char</name>*)<name>binding_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<if>if <condition>(<expr>!<name>current_param</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>pysqlite_ProgrammingError</name></expr></argument>, <argument><expr>"You did not supply a value for binding %d."</expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
}</block></then></if>
<if>if <condition>(<expr>!<call><name>_need_adapt</name><argument_list>(<argument><expr><name>current_param</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>adapted</name> = <name>current_param</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>adapted</name> = <call><name>pysqlite_microprotocols_adapt</name><argument_list>(<argument><expr><name>current_param</name></expr></argument>, <argument><expr>(<name>PyObject</name>*)&amp;<name>pysqlite_PrepareProtocolType</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>adapted</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>current_param</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>adapted</name> = <name>current_param</name></expr>;</expr_stmt>
}</block></else></if>
}</block></else></if>
<expr_stmt><expr><name>rc</name> = <call><name>pysqlite_statement_bind_parameter</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>adapted</name></expr></argument>, <argument><expr><name>allow_8bit_chars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>adapted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rc</name> != <name>SQLITE_OK</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>pysqlite_InterfaceError</name></expr></argument>, <argument><expr>"Error binding parameter :%s - probably unsupported type."</expr></argument>, <argument><expr><name>binding_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return;</return>
}</block></then></if>
}</block></for>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"parameters are of unsupported type"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if></else></if>
}</block></function>
<function><type><name>int</name></type> <name>pysqlite_statement_recompile</name><parameter_list>(<param><decl><type><name>pysqlite_Statement</name>*</type> <name>self</name></decl></param>, <param><decl><type><name>PyObject</name>*</type> <name>params</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>tail</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>*</type> <name>sql_cstr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>sqlite3_stmt</name>*</type> <name>new_st</name></decl>;</decl_stmt>
<expr_stmt><expr><name>sql_cstr</name> = <call><name>PyString_AsString</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>sql</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>rc</name> <init>= <expr><call><name>sqlite3_prepare</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>db</name></name></expr></argument>,
<argument><expr><name>sql_cstr</name></expr></argument>,
<argument><expr>-1</expr></argument>,
<argument><expr>&amp;<name>new_st</name></expr></argument>,
<argument><expr>&amp;<name>tail</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>rc</name> == <name>SQLITE_OK</name></expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SQLITE_VERSION_NUMBER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SQLITE_VERSION_NUMBER</name> &gt;= 3002002</expr></cpp:if>
<if>if <condition>(<expr><call><name>sqlite3_bind_parameter_count</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>st</name></name></expr></argument>)</argument_list></call> &gt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr>(<name>void</name>)<call><name>sqlite3_transfer_bindings</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>st</name></name></expr></argument>, <argument><expr><name>new_st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>statement_bind_parameters</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>params</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr>(<name>void</name>)<call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>st</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>st</name></name> = <name>new_st</name></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>rc</name></expr>;</return>
}</block></function>
<function><type><name>int</name></type> <name>pysqlite_statement_finalize</name><parameter_list>(<param><decl><type><name>pysqlite_Statement</name>*</type> <name>self</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
<expr_stmt><expr><name>rc</name> = <name>SQLITE_OK</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>st</name></name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>rc</name> <init>= <expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>st</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_END_ALLOW_THREADS</name></type>
<name><name>self</name>-&gt;<name>st</name></name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
}</block></then></if>
<expr_stmt><expr><name><name>self</name>-&gt;<name>in_use</name></name> = 0</expr>;</expr_stmt>
<return>return <expr><name>rc</name></expr>;</return>
}</block></function>
<function><type><name>int</name></type> <name>pysqlite_statement_reset</name><parameter_list>(<param><decl><type><name>pysqlite_Statement</name>*</type> <name>self</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
<expr_stmt><expr><name>rc</name> = <name>SQLITE_OK</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>in_use</name></name> &amp;&amp; <name><name>self</name>-&gt;<name>st</name></name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>rc</name> <init>= <expr><call><name>sqlite3_reset</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>st</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>rc</name> == <name>SQLITE_OK</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>self</name>-&gt;<name>in_use</name></name> = 0</expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
<return>return <expr><name>rc</name></expr>;</return>
}</block></function>
<function><type><name>void</name></type> <name>pysqlite_statement_mark_dirty</name><parameter_list>(<param><decl><type><name>pysqlite_Statement</name>*</type> <name>self</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name><name>self</name>-&gt;<name>in_use</name></name> = 1</expr>;</expr_stmt>
}</block></function>
<function><type><name>void</name></type> <name>pysqlite_statement_dealloc</name><parameter_list>(<param><decl><type><name>pysqlite_Statement</name>*</type> <name>self</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>rc</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>st</name></name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>rc</name> <init>= <expr><call><name>sqlite3_finalize</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>st</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>Py_END_ALLOW_THREADS</name></expr></expr_stmt>
}</block></then></if>
<expr_stmt><expr><name><name>self</name>-&gt;<name>st</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>sql</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>in_weakreflist</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyObject_ClearWeakRefs</name><argument_list>(<argument><expr>(<name>PyObject</name>*)<name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call>-&gt;<call><name>tp_free</name><argument_list>(<argument><expr>(<name>PyObject</name>*)<name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>pysqlite_check_remaining_sql</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>tail</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>pos</name> <init>= <expr><name>tail</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>parse_remaining_sql_state</name></type> <name>state</name> <init>= <expr><name>NORMAL</name></expr></init></decl>;</decl_stmt>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<switch>switch <condition>(<expr>*<name>pos</name></expr>)</condition> <block>{
<case>case <expr>0</expr>:
<return>return <expr>0</expr>;</return>
</case><case>case <expr>'-'</expr>:
<if>if <condition>(<expr><name>state</name> == <name>NORMAL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>state</name> = <name>LINECOMMENT_1</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>state</name> == <name>LINECOMMENT_1</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>state</name> = <name>IN_LINECOMMENT</name></expr>;</expr_stmt>
}</block></then></if></else></if>
<break>break;</break>
</case><case>case <expr>' '</expr>:
</case><case>case <expr>'\t'</expr>:
<break>break;</break>
</case><case>case <expr>'\n'</expr>:
</case><case>case <expr>13</expr>:
<if>if <condition>(<expr><name>state</name> == <name>IN_LINECOMMENT</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>state</name> = <name>NORMAL</name></expr>;</expr_stmt>
}</block></then></if>
<break>break;</break>
</case><case>case <expr>'/'</expr>:
<if>if <condition>(<expr><name>state</name> == <name>NORMAL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>state</name> = <name>COMMENTSTART_1</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>state</name> == <name>COMMENTEND_1</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>state</name> = <name>NORMAL</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>state</name> == <name>COMMENTSTART_1</name></expr>)</condition><then> <block>{
<return>return <expr>1</expr>;</return>
}</block></then></if></else></if></else></if>
<break>break;</break>
</case><case>case <expr>'*'</expr>:
<if>if <condition>(<expr><name>state</name> == <name>NORMAL</name></expr>)</condition><then> <block>{
<return>return <expr>1</expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><name>state</name> == <name>LINECOMMENT_1</name></expr>)</condition><then> <block>{
<return>return <expr>1</expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><name>state</name> == <name>COMMENTSTART_1</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>state</name> = <name>IN_COMMENT</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>state</name> == <name>IN_COMMENT</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>state</name> = <name>COMMENTEND_1</name></expr>;</expr_stmt>
}</block></then></if></else></if></else></if></else></if>
<break>break;</break>
</case><default>default:
<if>if <condition>(<expr><name>state</name> == <name>COMMENTEND_1</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>state</name> = <name>IN_COMMENT</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>state</name> == <name>IN_LINECOMMENT</name></expr>)</condition><then> <block>{
}</block></then> <else>else <if>if <condition>(<expr><name>state</name> == <name>IN_COMMENT</name></expr>)</condition><then> <block>{
}</block></then> <else>else <block>{
<return>return <expr>1</expr>;</return>
}</block></else></if></else></if></else></if>
</default>}</block></switch>
<expr_stmt><expr><name>pos</name>++</expr>;</expr_stmt>
}</block></for>
<return>return <expr>0</expr>;</return>
}</block></function>
<decl_stmt><decl><type><name>PyTypeObject</name></type> <name>pysqlite_StatementType</name> <init>= <expr><block>{
<macro><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument>NULL</argument>, <argument>0</argument>)</argument_list></macro>
<expr><name>MODULE_NAME</name> ".Statement"</expr>,
<expr><sizeof>sizeof<argument_list>(<argument><expr><name>pysqlite_Statement</name></expr></argument>)</argument_list></sizeof></expr>,
<expr>0</expr>,
<expr>(<name>destructor</name>)<name>pysqlite_statement_dealloc</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_HAVE_WEAKREFS</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><call><name>offsetof</name><argument_list>(<argument><expr><name>pysqlite_Statement</name></expr></argument>, <argument><expr><name>in_weakreflist</name></expr></argument>)</argument_list></call></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>(<name>initproc</name>)0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>extern</specifier> <name>int</name></type> <name>pysqlite_statement_setup_types</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name><name>pysqlite_StatementType</name>.<name>tp_new</name></name> = <name>PyType_GenericNew</name></expr>;</expr_stmt>
<return>return <expr><call><name>PyType_Ready</name><argument_list>(<argument><expr>&amp;<name>pysqlite_StatementType</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
</unit>
