<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="Modules/_struct.c"><cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PY_SSIZE_T_CLEAN</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"structseq.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"structmember.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>PyStructType</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<name>PY_VERSION_HEX</name> &lt; 0x02050000)</expr></cpp:if>
<typedef>typedef <type><name>int</name></type> <name>Py_ssize_t</name>;</typedef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PY_STRUCT_OVERFLOW_MASKING</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PY_STRUCT_OVERFLOW_MASKING</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>pylong_ulong_mask</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>pyint_zero</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PY_STRUCT_FLOAT_COERCE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PY_STRUCT_FLOAT_COERCE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLOAT_COERCE</name></cpp:macro> <cpp:value>"integer argument expected, got float"</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<typedef>typedef <type><struct>struct <name>_formatdef</name> <block>{
<decl_stmt><decl><type><name>char</name></type> <name>format</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>alignment</name></decl>;</decl_stmt>
<function_decl><type><name>PyObject</name>*</type> (*<name>unpack</name>)<parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>,
<param><decl><type><specifier>const</specifier> struct</type> <name>_formatdef</name> *</decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>int</name></type> (*<name>pack</name>)<parameter_list>(<param><decl><type><name>char</name> *</type></decl></param>, <param><decl><type><name>PyObject</name> *</type></decl></param>,
<param><decl><type><specifier>const</specifier> struct</type> <name>_formatdef</name> *</decl></param>)</parameter_list>;</function_decl>
}</block></struct></type> <name>formatdef</name>;</typedef>
<typedef>typedef <type><struct>struct <name>_formatcode</name> <block>{
<decl_stmt><decl><type><specifier>const</specifier> struct <name>_formatdef</name> *</type><name>fmtdef</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>offset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl>;</decl_stmt>
}</block></struct></type> <name>formatcode</name>;</typedef>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>PyObject_HEAD</name>
<name>Py_ssize_t</name></type> <name>s_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>s_len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>formatcode</name> *</type><name>s_codes</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>s_format</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>weakreflist</name></decl>;</decl_stmt>
}</block></struct></type> <name>PyStructObject</name>;</typedef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyStruct_Check</name><parameter_list>(<param><type><name>op</name></type></param>)</parameter_list></cpp:macro> <cpp:value>PyObject_TypeCheck(op, &amp;PyStructType)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyStruct_CheckExact</name><parameter_list>(<param><type><name>op</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(Py_TYPE(op) == &amp;PyStructType)</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>StructError</name></decl>;</decl_stmt>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>short</name></type> <name>x</name></decl>;</decl_stmt>
}</block></struct></type> <name>st_short</name>;</typedef>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>;</decl_stmt>
}</block></struct></type> <name>st_int</name>;</typedef>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>x</name></decl>;</decl_stmt>
}</block></struct></type> <name>st_long</name>;</typedef>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>float</name></type> <name>x</name></decl>;</decl_stmt>
}</block></struct></type> <name>st_float</name>;</typedef>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>x</name></decl>;</decl_stmt>
}</block></struct></type> <name>st_double</name>;</typedef>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> *</type><name>x</name></decl>;</decl_stmt>
}</block></struct></type> <name>st_void_p</name>;</typedef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SHORT_ALIGN</name></cpp:macro> <cpp:value>(sizeof(st_short) - sizeof(short))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INT_ALIGN</name></cpp:macro> <cpp:value>(sizeof(st_int) - sizeof(int))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LONG_ALIGN</name></cpp:macro> <cpp:value>(sizeof(st_long) - sizeof(long))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLOAT_ALIGN</name></cpp:macro> <cpp:value>(sizeof(st_float) - sizeof(float))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DOUBLE_ALIGN</name></cpp:macro> <cpp:value>(sizeof(st_double) - sizeof(double))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VOID_P_ALIGN</name></cpp:macro> <cpp:value>(sizeof(st_void_p) - sizeof(void *))</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LONG_LONG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PY_LONG_LONG</name></type> <name>x</name></decl>;</decl_stmt>
}</block></struct></type> <name>s_long_long</name>;</typedef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LONG_LONG_ALIGN</name></cpp:macro> <cpp:value>(sizeof(s_long_long) - sizeof(PY_LONG_LONG))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_C99_BOOL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BOOL_TYPE</name></cpp:macro> <cpp:value>_Bool</cpp:value></cpp:define>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>_Bool</name></type> <name>x</name></decl>;</decl_stmt>
}</block></struct></type> <name>s_bool</name>;</typedef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BOOL_ALIGN</name></cpp:macro> <cpp:value>(sizeof(s_bool) - sizeof(BOOL_TYPE))</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BOOL_TYPE</name></cpp:macro> <cpp:value>char</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BOOL_ALIGN</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STRINGIFY</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>#x</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__powerc</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:pragma>#<cpp:directive>pragma</cpp:directive> options align=reset</cpp:pragma>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>get_pylong</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyNumberMethods</name> *</type><name>m</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>v</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>PyLong_FromLong</name><argument_list>(<argument><expr><call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>PyLong_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>v</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>m</name> = <call><name>Py_TYPE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call>-&gt;<name>tp_as_number</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>m</name> != <name>NULL</name> &amp;&amp; <name><name>m</name>-&gt;<name>nb_long</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>v</name> = <call><name><name>m</name>-&gt;<name>nb_long</name></name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>PyLong_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>v</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>StructError</name></expr></argument>,
<argument><expr>"cannot convert argument to long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>get_long</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>long</name> *</type><name>p</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>long</name></type> <name>x</name> <init>= <expr><call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>x</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PY_STRUCT_FLOAT_COERCE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>PyFloat_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>o</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyErr_WarnEx</name><argument_list>(<argument><expr><name>PyExc_DeprecationWarning</name></expr></argument>, <argument><expr><name>FLOAT_COERCE</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><name>o</name> = <call><name>PyNumber_Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>o</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><name>res</name> = <call><name>get_long</name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>StructError</name></expr></argument>,
<argument><expr>"required argument is not an integer"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr>*<name>p</name> = <name>x</name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>get_ulong</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>unsigned</name> <name>long</name> *</type><name>p</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><call><name>PyLong_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>x</name> <init>= <expr><call><name>PyLong_AsUnsignedLong</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>x</name> == <call>(<name>unsigned</name> <name>long</name>)<argument_list>(<argument><expr>-1</expr></argument>)</argument_list></call> &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr>*<name>p</name> = <name>x</name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><call><name>get_long</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>(<name>long</name> *)<name>p</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr>((<name>long</name>)*<name>p</name>) &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>StructError</name></expr></argument>,
<argument><expr>"unsigned argument is &lt; 0"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<return>return <expr>0</expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LONG_LONG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>get_longlong</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PY_LONG_LONG</name> *</type><name>p</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PY_LONG_LONG</name></type> <name>x</name></decl>;</decl_stmt>
<expr_stmt><expr><name>v</name> = <call><name>get_pylong</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyLong_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>x</name> = <call><name>PyLong_AsLongLong</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>x</name> == (<name>PY_LONG_LONG</name>)-1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr>*<name>p</name> = <name>x</name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>get_ulonglong</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>unsigned</name> <name>PY_LONG_LONG</name> *</type><name>p</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>PY_LONG_LONG</name></type> <name>x</name></decl>;</decl_stmt>
<expr_stmt><expr><name>v</name> = <call><name>get_pylong</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyLong_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>x</name> = <call><name>PyLong_AsUnsignedLongLong</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>x</name> == (<name>unsigned</name> <name>PY_LONG_LONG</name>)-1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr>*<name>p</name> = <name>x</name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PY_STRUCT_OVERFLOW_MASKING</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INT_OVERFLOW</name></cpp:macro> <cpp:value>"struct integer overflow masking is deprecated"</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>get_wrapped_long</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>long</name> *</type><name>p</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><call><name>get_long</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PyLong_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> &amp;&amp;
<call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>wrapped</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>x</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PY_STRUCT_FLOAT_COERCE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>PyFloat_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>o</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyErr_WarnEx</name><argument_list>(<argument><expr><name>PyExc_DeprecationWarning</name></expr></argument>, <argument><expr><name>FLOAT_COERCE</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><name>o</name> = <call><name>PyNumber_Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>o</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><name>res</name> = <call><name>get_wrapped_long</name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><call><name>PyErr_WarnEx</name><argument_list>(<argument><expr><name>PyExc_DeprecationWarning</name></expr></argument>, <argument><expr><name>INT_OVERFLOW</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><name>wrapped</name> = <call><name>PyNumber_And</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pylong_ulong_mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>wrapped</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><name>x</name> = (<name>long</name>)<call><name>PyLong_AsUnsignedLong</name><argument_list>(<argument><expr><name>wrapped</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>wrapped</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>x</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr>*<name>p</name> = <name>x</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<return>return <expr>-1</expr>;</return>
}</block></else></if>
}</block></then></if>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>get_wrapped_ulong</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>unsigned</name> <name>long</name> *</type><name>p</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>long</name></type> <name>x</name> <init>= <expr>(<name>long</name>)<call><name>PyLong_AsUnsignedLong</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>x</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>wrapped</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PY_STRUCT_FLOAT_COERCE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>PyFloat_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>o</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyErr_WarnEx</name><argument_list>(<argument><expr><name>PyExc_DeprecationWarning</name></expr></argument>, <argument><expr><name>FLOAT_COERCE</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><name>o</name> = <call><name>PyNumber_Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>o</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><name>res</name> = <call><name>get_wrapped_ulong</name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>wrapped</name> = <call><name>PyNumber_And</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>pylong_ulong_mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>wrapped</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr><call><name>PyErr_WarnEx</name><argument_list>(<argument><expr><name>PyExc_DeprecationWarning</name></expr></argument>, <argument><expr><name>INT_OVERFLOW</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>wrapped</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>x</name> = (<name>long</name>)<call><name>PyLong_AsUnsignedLong</name><argument_list>(<argument><expr><name>wrapped</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>wrapped</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>x</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
}</block></then></if>
<expr_stmt><expr>*<name>p</name> = (<name>unsigned</name> <name>long</name>)<name>x</name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RANGE_ERROR</name><parameter_list>(<param><type><name>x</name></type></param>, <param><type><name>f</name></type></param>, <param><type><name>flag</name></type></param>, <param><type><name>mask</name></type></param>)</parameter_list></cpp:macro> <cpp:value>do { if (_range_error(f, flag) &lt; 0) return -1; else (x) &amp;= (mask); } while (0)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>get_wrapped_long</name></cpp:macro> <cpp:value>get_long</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>get_wrapped_ulong</name></cpp:macro> <cpp:value>get_ulong</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RANGE_ERROR</name><parameter_list>(<param><type><name>x</name></type></param>, <param><type><name>f</name></type></param>, <param><type><name>flag</name></type></param>, <param><type><name>mask</name></type></param>)</parameter_list></cpp:macro> <cpp:value>return _range_error(f, flag)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>unpack_float</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name></decl></param>,
<param><decl><type><name>int</name></type> <name>le</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>double</name></type> <name>x</name></decl>;</decl_stmt>
<expr_stmt><expr><name>x</name> = <call><name>_PyFloat_Unpack4</name><argument_list>(<argument><expr>(<name>unsigned</name> <name>char</name> *)<name>p</name></expr></argument>, <argument><expr><name>le</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>x</name> == -1.0 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>unpack_double</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name></decl></param>,
<param><decl><type><name>int</name></type> <name>le</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>double</name></type> <name>x</name></decl>;</decl_stmt>
<expr_stmt><expr><name>x</name> = <call><name>_PyFloat_Unpack8</name><argument_list>(<argument><expr>(<name>unsigned</name> <name>char</name> *)<name>p</name></expr></argument>, <argument><expr><name>le</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>x</name> == -1.0 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>_range_error</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>formatdef</name> *</type><name>f</name></decl></param>, <param><decl><type><name>int</name></type> <name>is_unsigned</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>ulargest</name> <init>= <expr>(<name>size_t</name>)-1 &gt;&gt; ((<name>SIZEOF_SIZE_T</name> - <name><name>f</name>-&gt;<name>size</name></name>)*8)</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>size</name></name> &gt;= 1 &amp;&amp; <name><name>f</name>-&gt;<name>size</name></name> &lt;= <name>SIZEOF_SIZE_T</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>is_unsigned</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>StructError</name></expr></argument>,
<argument><expr>"'%c' format requires 0 &lt;= number &lt;= %zu"</expr></argument>,
<argument><expr><name><name>f</name>-&gt;<name>format</name></name></expr></argument>,
<argument><expr><name>ulargest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>Py_ssize_t</name></type> <name>largest</name> <init>= <expr><call>(<name>Py_ssize_t</name>)<argument_list>(<argument><expr><name>ulargest</name> &gt;&gt; 1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>StructError</name></expr></argument>,
<argument><expr>"'%c' format requires %zd &lt;= number &lt;= %zd"</expr></argument>,
<argument><expr><name><name>f</name>-&gt;<name>format</name></name></expr></argument>,
<argument><expr>~ <name>largest</name></expr></argument>,
<argument><expr><name>largest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PY_STRUCT_OVERFLOW_MASKING</name></expr></argument>)</argument_list></call></expr></cpp:if>
<block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>ptype</name></decl>, *<decl><type ref="prev"/><name>pvalue</name></decl>, *<decl><type ref="prev"/><name>ptraceback</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>msg</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>rval</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PyErr_Fetch</name><argument_list>(<argument><expr>&amp;<name>ptype</name></expr></argument>, <argument><expr>&amp;<name>pvalue</name></expr></argument>, <argument><expr>&amp;<name>ptraceback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>pvalue</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>msg</name> = <call><name>PyObject_Str</name><argument_list>(<argument><expr><name>pvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>ptype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>pvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>ptraceback</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>msg</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><name>rval</name> = <call><name>PyErr_WarnEx</name><argument_list>(<argument><expr><name>PyExc_DeprecationWarning</name></expr></argument>,
<argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rval</name> == 0</expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr>-1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>nu_char</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>formatdef</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>nu_byte</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>formatdef</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>) *(<name>signed</name> <name>char</name> *)<name>p</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>nu_ubyte</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>formatdef</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>) *(<name>unsigned</name> <name>char</name> *)<name>p</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>nu_short</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>formatdef</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>short</name></type> <name>x</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>(<name>char</name> *)&amp;<name>x</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr>sizeof <name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name>x</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>nu_ushort</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>formatdef</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>x</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>(<name>char</name> *)&amp;<name>x</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr>sizeof <name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name>x</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>nu_int</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>formatdef</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>x</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>(<name>char</name> *)&amp;<name>x</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr>sizeof <name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name>x</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>nu_uint</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>formatdef</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>x</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>(<name>char</name> *)&amp;<name>x</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr>sizeof <name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<name>SIZEOF_LONG</name> &gt; <name>SIZEOF_INT</name>)</expr></cpp:if>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name>x</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if>if <condition>(<expr><name>x</name> &lt;= ((<name>unsigned</name> <name>int</name>)<name>LONG_MAX</name>)</expr>)</condition><then>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name>x</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<return>return <expr><call><name>PyLong_FromUnsignedLong</name><argument_list>(<argument><expr>(<name>unsigned</name> <name>long</name>)<name>x</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>nu_long</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>formatdef</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>long</name></type> <name>x</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>(<name>char</name> *)&amp;<name>x</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr>sizeof <name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>nu_ulong</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>formatdef</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>x</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>(<name>char</name> *)&amp;<name>x</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr>sizeof <name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>x</name> &lt;= <name>LONG_MAX</name></expr>)</condition><then>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name>x</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<return>return <expr><call><name>PyLong_FromUnsignedLong</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LONG_LONG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>nu_longlong</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>formatdef</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PY_LONG_LONG</name></type> <name>x</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>(<name>char</name> *)&amp;<name>x</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr>sizeof <name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>x</name> &gt;= <name>LONG_MIN</name> &amp;&amp; <name>x</name> &lt;= <name>LONG_MAX</name></expr>)</condition><then>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><call><name>Py_SAFE_DOWNCAST</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>PY_LONG_LONG</name></expr></argument>, <argument><expr><name>long</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
<return>return <expr><call><name>PyLong_FromLongLong</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>nu_ulonglong</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>formatdef</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>PY_LONG_LONG</name></type> <name>x</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>(<name>char</name> *)&amp;<name>x</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr>sizeof <name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>x</name> &lt;= <name>LONG_MAX</name></expr>)</condition><then>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><macro><name>Py_SAFE_DOWNCAST</name><argument_list>(<argument>x</argument>, <argument>unsigned PY_LONG_LONG</argument>, <argument>long</argument>)</argument_list></macro></expr></argument>)</argument_list></call></expr>;</return></then></if>
<return>return <expr><call><name>PyLong_FromUnsignedLongLong</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>nu_bool</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>formatdef</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>BOOL_TYPE</name></type> <name>x</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>(<name>char</name> *)&amp;<name>x</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr>sizeof <name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><name>x</name> != 0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>nu_float</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>formatdef</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>float</name></type> <name>x</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>(<name>char</name> *)&amp;<name>x</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr>sizeof <name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr>(<name>double</name>)<name>x</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>nu_double</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>formatdef</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>double</name></type> <name>x</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>(<name>char</name> *)&amp;<name>x</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr>sizeof <name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>nu_void_p</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>formatdef</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>void</name> *</type><name>x</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>(<name>char</name> *)&amp;<name>x</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr>sizeof <name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>PyLong_FromVoidPtr</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>np_byte</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>p</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>formatdef</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>long</name></type> <name>x</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>get_long</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>&amp;<name>x</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr><name>x</name> &lt; -128 || <name>x</name> &gt; 127</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>StructError</name></expr></argument>,
<argument><expr>"byte format requires -128 &lt;= number &lt;= 127"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr>*<name>p</name> = (<name>char</name>)<name>x</name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>np_ubyte</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>p</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>formatdef</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>long</name></type> <name>x</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>get_long</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>&amp;<name>x</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr><name>x</name> &lt; 0 || <name>x</name> &gt; 255</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>StructError</name></expr></argument>,
<argument><expr>"ubyte format requires 0 &lt;= number &lt;= 255"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr>*<name>p</name> = (<name>char</name>)<name>x</name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>np_char</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>p</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>formatdef</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr>!<call><name>PyString_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> || <call><name>PyString_Size</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> != 1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>StructError</name></expr></argument>,
<argument><expr>"char format require string of length 1"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr>*<name>p</name> = *<call><name>PyString_AsString</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>np_short</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>p</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>formatdef</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>long</name></type> <name>x</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>short</name></type> <name>y</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>get_long</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>&amp;<name>x</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr><name>x</name> &lt; <name>SHRT_MIN</name> || <name>x</name> &gt; <name>SHRT_MAX</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>StructError</name></expr></argument>,
<argument><expr>"short format requires " <call><name>STRINGIFY</name><argument_list>(<argument><expr><name>SHRT_MIN</name></expr></argument>)</argument_list></call>
" &lt;= number &lt;= " <call><name>STRINGIFY</name><argument_list>(<argument><expr><name>SHRT_MAX</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>y</name> = (<name>short</name>)<name>x</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>(<name>char</name> *)&amp;<name>y</name></expr></argument>, <argument><expr>sizeof <name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>np_ushort</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>p</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>formatdef</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>long</name></type> <name>x</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>short</name></type> <name>y</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>get_long</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>&amp;<name>x</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr><name>x</name> &lt; 0 || <name>x</name> &gt; <name>USHRT_MAX</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>StructError</name></expr></argument>,
<argument><expr>"short format requires 0 &lt;= number &lt;= " <call><name>STRINGIFY</name><argument_list>(<argument><expr><name>USHRT_MAX</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>y</name> = (<name>unsigned</name> <name>short</name>)<name>x</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>(<name>char</name> *)&amp;<name>y</name></expr></argument>, <argument><expr>sizeof <name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>np_int</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>p</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>formatdef</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>long</name></type> <name>x</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>y</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>get_long</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>&amp;<name>x</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<name>SIZEOF_LONG</name> &gt; <name>SIZEOF_INT</name>)</expr></cpp:if>
<if>if <condition>(<expr>(<name>x</name> &lt; ((<name>long</name>)<name>INT_MIN</name>)) || (<name>x</name> &gt; ((<name>long</name>)<name>INT_MAX</name>))</expr>)</condition><then>
<return>return <expr><call><name>_range_error</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>y</name> = (<name>int</name>)<name>x</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>(<name>char</name> *)&amp;<name>y</name></expr></argument>, <argument><expr>sizeof <name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>np_uint</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>p</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>formatdef</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>x</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>y</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>get_ulong</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>&amp;<name>x</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name>_range_error</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>y</name> = (<name>unsigned</name> <name>int</name>)<name>x</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<name>SIZEOF_LONG</name> &gt; <name>SIZEOF_INT</name>)</expr></cpp:if>
<if>if <condition>(<expr><name>x</name> &gt; ((<name>unsigned</name> <name>long</name>)<name>UINT_MAX</name>)</expr>)</condition><then>
<return>return <expr><call><name>_range_error</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>(<name>char</name> *)&amp;<name>y</name></expr></argument>, <argument><expr>sizeof <name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>np_long</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>p</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>formatdef</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>long</name></type> <name>x</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>get_long</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>&amp;<name>x</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>(<name>char</name> *)&amp;<name>x</name></expr></argument>, <argument><expr>sizeof <name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>np_ulong</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>p</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>formatdef</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>x</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>get_ulong</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>&amp;<name>x</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name>_range_error</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>(<name>char</name> *)&amp;<name>x</name></expr></argument>, <argument><expr>sizeof <name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LONG_LONG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>np_longlong</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>p</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>formatdef</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PY_LONG_LONG</name></type> <name>x</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>get_longlong</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>&amp;<name>x</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>(<name>char</name> *)&amp;<name>x</name></expr></argument>, <argument><expr>sizeof <name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>np_ulonglong</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>p</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>formatdef</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>PY_LONG_LONG</name></type> <name>x</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>get_ulonglong</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>&amp;<name>x</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>(<name>char</name> *)&amp;<name>x</name></expr></argument>, <argument><expr>sizeof <name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>np_bool</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>p</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>formatdef</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>BOOL_TYPE</name></type> <name>y</name></decl>;</decl_stmt>
<expr_stmt><expr><name>y</name> = <call><name>PyObject_IsTrue</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>(<name>char</name> *)&amp;<name>y</name></expr></argument>, <argument><expr>sizeof <name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>np_float</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>p</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>formatdef</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>float</name></type> <name>x</name> <init>= <expr>(<name>float</name>)<call><name>PyFloat_AsDouble</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>x</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>StructError</name></expr></argument>,
<argument><expr>"required argument is not a float"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>(<name>char</name> *)&amp;<name>x</name></expr></argument>, <argument><expr>sizeof <name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>np_double</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>p</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>formatdef</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>double</name></type> <name>x</name> <init>= <expr><call><name>PyFloat_AsDouble</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>x</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>StructError</name></expr></argument>,
<argument><expr>"required argument is not a float"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>(<name>char</name> *)&amp;<name>x</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>np_void_p</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>p</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>formatdef</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>void</name> *</type><name>x</name></decl>;</decl_stmt>
<expr_stmt><expr><name>v</name> = <call><name>get_pylong</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyLong_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>x</name> = <call><name>PyLong_AsVoidPtr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>x</name> == <name>NULL</name> &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>(<name>char</name> *)&amp;<name>x</name></expr></argument>, <argument><expr>sizeof <name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <name>formatdef</name></type> <name><name>native_table</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr>'x'</expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr>, <expr>0</expr>, <expr><name>NULL</name></expr>}</block></expr>,
<expr><block>{<expr>'b'</expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr>, <expr>0</expr>, <expr><name>nu_byte</name></expr>, <expr><name>np_byte</name></expr>}</block></expr>,
<expr><block>{<expr>'B'</expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr>, <expr>0</expr>, <expr><name>nu_ubyte</name></expr>, <expr><name>np_ubyte</name></expr>}</block></expr>,
<expr><block>{<expr>'c'</expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr>, <expr>0</expr>, <expr><name>nu_char</name></expr>, <expr><name>np_char</name></expr>}</block></expr>,
<expr><block>{<expr>'s'</expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr>, <expr>0</expr>, <expr><name>NULL</name></expr>}</block></expr>,
<expr><block>{<expr>'p'</expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name></expr></argument>)</argument_list></sizeof></expr>, <expr>0</expr>, <expr><name>NULL</name></expr>}</block></expr>,
<expr><block>{<expr>'h'</expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>short</name></expr></argument>)</argument_list></sizeof></expr>, <expr><name>SHORT_ALIGN</name></expr>, <expr><name>nu_short</name></expr>, <expr><name>np_short</name></expr>}</block></expr>,
<expr><block>{<expr>'H'</expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>short</name></expr></argument>)</argument_list></sizeof></expr>, <expr><name>SHORT_ALIGN</name></expr>, <expr><name>nu_ushort</name></expr>, <expr><name>np_ushort</name></expr>}</block></expr>,
<expr><block>{<expr>'i'</expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr>, <expr><name>INT_ALIGN</name></expr>, <expr><name>nu_int</name></expr>, <expr><name>np_int</name></expr>}</block></expr>,
<expr><block>{<expr>'I'</expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr>, <expr><name>INT_ALIGN</name></expr>, <expr><name>nu_uint</name></expr>, <expr><name>np_uint</name></expr>}</block></expr>,
<expr><block>{<expr>'l'</expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>long</name></expr></argument>)</argument_list></sizeof></expr>, <expr><name>LONG_ALIGN</name></expr>, <expr><name>nu_long</name></expr>, <expr><name>np_long</name></expr>}</block></expr>,
<expr><block>{<expr>'L'</expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>long</name></expr></argument>)</argument_list></sizeof></expr>, <expr><name>LONG_ALIGN</name></expr>, <expr><name>nu_ulong</name></expr>, <expr><name>np_ulong</name></expr>}</block></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LONG_LONG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>'q'</expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>PY_LONG_LONG</name></expr></argument>)</argument_list></sizeof></expr>, <expr><name>LONG_LONG_ALIGN</name></expr>, <expr><name>nu_longlong</name></expr>, <expr><name>np_longlong</name></expr>}</block></expr>,
<expr><block>{<expr>'Q'</expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>PY_LONG_LONG</name></expr></argument>)</argument_list></sizeof></expr>, <expr><name>LONG_LONG_ALIGN</name></expr>, <expr><name>nu_ulonglong</name></expr>,<expr><name>np_ulonglong</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr><block>{<expr>'?'</expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>BOOL_TYPE</name></expr></argument>)</argument_list></sizeof></expr>, <expr><name>BOOL_ALIGN</name></expr>, <expr><name>nu_bool</name></expr>, <expr><name>np_bool</name></expr>}</block></expr>,
<expr><block>{<expr>'f'</expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>float</name></expr></argument>)</argument_list></sizeof></expr>, <expr><name>FLOAT_ALIGN</name></expr>, <expr><name>nu_float</name></expr>, <expr><name>np_float</name></expr>}</block></expr>,
<expr><block>{<expr>'d'</expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>double</name></expr></argument>)</argument_list></sizeof></expr>, <expr><name>DOUBLE_ALIGN</name></expr>, <expr><name>nu_double</name></expr>, <expr><name>np_double</name></expr>}</block></expr>,
<expr><block>{<expr>'P'</expr>, <expr><sizeof>sizeof<argument_list>(<argument><expr><name>void</name> *</expr></argument>)</argument_list></sizeof></expr>, <expr><name>VOID_P_ALIGN</name></expr>, <expr><name>nu_void_p</name></expr>, <expr><name>np_void_p</name></expr>}</block></expr>,
<expr><block>{<expr>0</expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>bu_int</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>formatdef</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>long</name></type> <name>x</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name> <init>= <expr><name><name>f</name>-&gt;<name>size</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>bytes</name> <init>= <expr>(const <name>unsigned</name> <name>char</name> *)<name>p</name></expr></init></decl>;</decl_stmt>
<do>do <block>{
<expr_stmt><expr><name>x</name> = (<name>x</name>&lt;&lt;8) | *<name>bytes</name>++</expr>;</expr_stmt>
}</block> while <condition>(<expr>--<name>i</name> &gt; 0</expr>)</condition>;</do>
<if>if <condition>(<expr><name>SIZEOF_LONG</name> &gt; <name><name>f</name>-&gt;<name>size</name></name></expr>)</condition><then>
<expr_stmt><expr><name>x</name> |= -(<name>x</name> &amp; (1L &lt;&lt; ((8 * <name><name>f</name>-&gt;<name>size</name></name>) - 1)))</expr>;</expr_stmt></then></if>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>bu_uint</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>formatdef</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>x</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name> <init>= <expr><name><name>f</name>-&gt;<name>size</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>bytes</name> <init>= <expr>(const <name>unsigned</name> <name>char</name> *)<name>p</name></expr></init></decl>;</decl_stmt>
<do>do <block>{
<expr_stmt><expr><name>x</name> = (<name>x</name>&lt;&lt;8) | *<name>bytes</name>++</expr>;</expr_stmt>
}</block> while <condition>(<expr>--<name>i</name> &gt; 0</expr>)</condition>;</do>
<if>if <condition>(<expr><name>x</name> &lt;= <name>LONG_MAX</name></expr>)</condition><then>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name>x</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<return>return <expr><call><name>PyLong_FromUnsignedLong</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>bu_longlong</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>formatdef</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LONG_LONG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>PY_LONG_LONG</name></type> <name>x</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name> <init>= <expr><name><name>f</name>-&gt;<name>size</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>bytes</name> <init>= <expr>(const <name>unsigned</name> <name>char</name> *)<name>p</name></expr></init></decl>;</decl_stmt>
<do>do <block>{
<expr_stmt><expr><name>x</name> = (<name>x</name>&lt;&lt;8) | *<name>bytes</name>++</expr>;</expr_stmt>
}</block> while <condition>(<expr>--<name>i</name> &gt; 0</expr>)</condition>;</do>
<if>if <condition>(<expr><name>SIZEOF_LONG_LONG</name> &gt; <name><name>f</name>-&gt;<name>size</name></name></expr>)</condition><then>
<expr_stmt><expr><name>x</name> |= -(<name>x</name> &amp; ((<name>PY_LONG_LONG</name>)1 &lt;&lt; ((8 * <name><name>f</name>-&gt;<name>size</name></name>) - 1)))</expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>x</name> &gt;= <name>LONG_MIN</name> &amp;&amp; <name>x</name> &lt;= <name>LONG_MAX</name></expr>)</condition><then>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><call><name>Py_SAFE_DOWNCAST</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>PY_LONG_LONG</name></expr></argument>, <argument><expr><name>long</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
<return>return <expr><call><name>PyLong_FromLongLong</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<return>return <expr><call><name>_PyLong_FromByteArray</name><argument_list>(<argument><expr>(const <name>unsigned</name> <name>char</name> *)<name>p</name></expr></argument>,
<argument><expr>8</expr></argument>,
<argument><expr>0</expr></argument>,
<argument><expr>1</expr></argument> )</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>bu_ulonglong</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>formatdef</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LONG_LONG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>unsigned</name> <name>PY_LONG_LONG</name></type> <name>x</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name> <init>= <expr><name><name>f</name>-&gt;<name>size</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>bytes</name> <init>= <expr>(const <name>unsigned</name> <name>char</name> *)<name>p</name></expr></init></decl>;</decl_stmt>
<do>do <block>{
<expr_stmt><expr><name>x</name> = (<name>x</name>&lt;&lt;8) | *<name>bytes</name>++</expr>;</expr_stmt>
}</block> while <condition>(<expr>--<name>i</name> &gt; 0</expr>)</condition>;</do>
<if>if <condition>(<expr><name>x</name> &lt;= <name>LONG_MAX</name></expr>)</condition><then>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><macro><name>Py_SAFE_DOWNCAST</name><argument_list>(<argument>x</argument>, <argument>unsigned PY_LONG_LONG</argument>, <argument>long</argument>)</argument_list></macro></expr></argument>)</argument_list></call></expr>;</return></then></if>
<return>return <expr><call><name>PyLong_FromUnsignedLongLong</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<return>return <expr><call><name>_PyLong_FromByteArray</name><argument_list>(<argument><expr>(const <name>unsigned</name> <name>char</name> *)<name>p</name></expr></argument>,
<argument><expr>8</expr></argument>,
<argument><expr>0</expr></argument>,
<argument><expr>0</expr></argument> )</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>bu_float</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>formatdef</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>unpack_float</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>bu_double</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>formatdef</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>unpack_double</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>bu_bool</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>formatdef</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name></type> <name>x</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>(<name>char</name> *)&amp;<name>x</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr>sizeof <name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><name>x</name> != 0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>bp_int</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>p</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>formatdef</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>long</name></type> <name>x</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>get_wrapped_long</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>&amp;<name>x</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><name>i</name> = <name><name>f</name>-&gt;<name>size</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>i</name> != <name>SIZEOF_LONG</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>(<name>i</name> == 2) &amp;&amp; (<name>x</name> &lt; -32768 || <name>x</name> &gt; 32767)</expr>)</condition><then>
<expr_stmt><expr><call><name>RANGE_ERROR</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0xffffL</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<name>SIZEOF_LONG</name> != 4)</expr></cpp:if>
<else>else <if>if <condition>(<expr>(<name>i</name> == 4) &amp;&amp; (<name>x</name> &lt; -2147483648L || <name>x</name> &gt; 2147483647L)</expr>)</condition><then>
<expr_stmt><expr><call><name>RANGE_ERROR</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0xffffffffL</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PY_STRUCT_OVERFLOW_MASKING</name></expr></argument>)</argument_list></call></expr></cpp:if>
<else>else <if>if <condition>(<expr>(<name>i</name> == 1) &amp;&amp; (<name>x</name> &lt; -128 || <name>x</name> &gt; 127)</expr>)</condition><then>
<expr_stmt><expr><call><name>RANGE_ERROR</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0xffL</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></then></if>
<do>do <block>{
<expr_stmt><expr><name><name>p</name><index>[<expr>--<name>i</name></expr>]</index></name> = (<name>char</name>)<name>x</name></expr>;</expr_stmt>
<expr_stmt><expr><name>x</name> &gt;&gt;= 8</expr>;</expr_stmt>
}</block> while <condition>(<expr><name>i</name> &gt; 0</expr>)</condition>;</do>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>bp_uint</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>p</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>formatdef</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>x</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>get_wrapped_ulong</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>&amp;<name>x</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><name>i</name> = <name><name>f</name>-&gt;<name>size</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>i</name> != <name>SIZEOF_LONG</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>maxint</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>maxint</name> &lt;&lt;= <call>(<name>unsigned</name> <name>long</name>)<argument_list>(<argument><expr><name>i</name> * 8</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>x</name> &gt;= <name>maxint</name></expr>)</condition><then>
<expr_stmt><expr><call><name>RANGE_ERROR</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>maxint</name> - 1</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></then></if>
<do>do <block>{
<expr_stmt><expr><name><name>p</name><index>[<expr>--<name>i</name></expr>]</index></name> = (<name>char</name>)<name>x</name></expr>;</expr_stmt>
<expr_stmt><expr><name>x</name> &gt;&gt;= 8</expr>;</expr_stmt>
}</block> while <condition>(<expr><name>i</name> &gt; 0</expr>)</condition>;</do>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>bp_longlong</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>p</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>formatdef</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
<expr_stmt><expr><name>v</name> = <call><name>get_pylong</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><name>res</name> = <call><name>_PyLong_AsByteArray</name><argument_list>(<argument><expr>(<name>PyLongObject</name> *)<name>v</name></expr></argument>,
<argument><expr>(<name>unsigned</name> <name>char</name> *)<name>p</name></expr></argument>,
<argument><expr>8</expr></argument>,
<argument><expr>0</expr></argument>,
<argument><expr>1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>bp_ulonglong</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>p</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>formatdef</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
<expr_stmt><expr><name>v</name> = <call><name>get_pylong</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><name>res</name> = <call><name>_PyLong_AsByteArray</name><argument_list>(<argument><expr>(<name>PyLongObject</name> *)<name>v</name></expr></argument>,
<argument><expr>(<name>unsigned</name> <name>char</name> *)<name>p</name></expr></argument>,
<argument><expr>8</expr></argument>,
<argument><expr>0</expr></argument>,
<argument><expr>0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>bp_float</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>p</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>formatdef</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>double</name></type> <name>x</name> <init>= <expr><call><name>PyFloat_AsDouble</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>x</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>StructError</name></expr></argument>,
<argument><expr>"required argument is not a float"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<return>return <expr><call><name>_PyFloat_Pack4</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr>(<name>unsigned</name> <name>char</name> *)<name>p</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>bp_double</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>p</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>formatdef</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>double</name></type> <name>x</name> <init>= <expr><call><name>PyFloat_AsDouble</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>x</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>StructError</name></expr></argument>,
<argument><expr>"required argument is not a float"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<return>return <expr><call><name>_PyFloat_Pack8</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr>(<name>unsigned</name> <name>char</name> *)<name>p</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>bp_bool</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>p</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>formatdef</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name></type> <name>y</name></decl>;</decl_stmt>
<expr_stmt><expr><name>y</name> = <call><name>PyObject_IsTrue</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>(<name>char</name> *)&amp;<name>y</name></expr></argument>, <argument><expr>sizeof <name>y</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <name>formatdef</name></type> <name><name>bigendian_table</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr>'x'</expr>, <expr>1</expr>, <expr>0</expr>, <expr><name>NULL</name></expr>}</block></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PY_STRUCT_OVERFLOW_MASKING</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>'b'</expr>, <expr>1</expr>, <expr>0</expr>, <expr><name>nu_byte</name></expr>, <expr><name>bp_int</name></expr>}</block></expr>,
<expr><block>{<expr>'B'</expr>, <expr>1</expr>, <expr>0</expr>, <expr><name>nu_ubyte</name></expr>, <expr><name>bp_uint</name></expr>}</block></expr>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr><block>{<expr>'b'</expr>, <expr>1</expr>, <expr>0</expr>, <expr><name>nu_byte</name></expr>, <expr><name>np_byte</name></expr>}</block></expr>,
<expr><block>{<expr>'B'</expr>, <expr>1</expr>, <expr>0</expr>, <expr><name>nu_ubyte</name></expr>, <expr><name>np_ubyte</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr><block>{<expr>'c'</expr>, <expr>1</expr>, <expr>0</expr>, <expr><name>nu_char</name></expr>, <expr><name>np_char</name></expr>}</block></expr>,
<expr><block>{<expr>'s'</expr>, <expr>1</expr>, <expr>0</expr>, <expr><name>NULL</name></expr>}</block></expr>,
<expr><block>{<expr>'p'</expr>, <expr>1</expr>, <expr>0</expr>, <expr><name>NULL</name></expr>}</block></expr>,
<expr><block>{<expr>'h'</expr>, <expr>2</expr>, <expr>0</expr>, <expr><name>bu_int</name></expr>, <expr><name>bp_int</name></expr>}</block></expr>,
<expr><block>{<expr>'H'</expr>, <expr>2</expr>, <expr>0</expr>, <expr><name>bu_uint</name></expr>, <expr><name>bp_uint</name></expr>}</block></expr>,
<expr><block>{<expr>'i'</expr>, <expr>4</expr>, <expr>0</expr>, <expr><name>bu_int</name></expr>, <expr><name>bp_int</name></expr>}</block></expr>,
<expr><block>{<expr>'I'</expr>, <expr>4</expr>, <expr>0</expr>, <expr><name>bu_uint</name></expr>, <expr><name>bp_uint</name></expr>}</block></expr>,
<expr><block>{<expr>'l'</expr>, <expr>4</expr>, <expr>0</expr>, <expr><name>bu_int</name></expr>, <expr><name>bp_int</name></expr>}</block></expr>,
<expr><block>{<expr>'L'</expr>, <expr>4</expr>, <expr>0</expr>, <expr><name>bu_uint</name></expr>, <expr><name>bp_uint</name></expr>}</block></expr>,
<expr><block>{<expr>'q'</expr>, <expr>8</expr>, <expr>0</expr>, <expr><name>bu_longlong</name></expr>, <expr><name>bp_longlong</name></expr>}</block></expr>,
<expr><block>{<expr>'Q'</expr>, <expr>8</expr>, <expr>0</expr>, <expr><name>bu_ulonglong</name></expr>, <expr><name>bp_ulonglong</name></expr>}</block></expr>,
<expr><block>{<expr>'?'</expr>, <expr>1</expr>, <expr>0</expr>, <expr><name>bu_bool</name></expr>, <expr><name>bp_bool</name></expr>}</block></expr>,
<expr><block>{<expr>'f'</expr>, <expr>4</expr>, <expr>0</expr>, <expr><name>bu_float</name></expr>, <expr><name>bp_float</name></expr>}</block></expr>,
<expr><block>{<expr>'d'</expr>, <expr>8</expr>, <expr>0</expr>, <expr><name>bu_double</name></expr>, <expr><name>bp_double</name></expr>}</block></expr>,
<expr><block>{<expr>0</expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>lu_int</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>formatdef</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>long</name></type> <name>x</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name> <init>= <expr><name><name>f</name>-&gt;<name>size</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>bytes</name> <init>= <expr>(const <name>unsigned</name> <name>char</name> *)<name>p</name></expr></init></decl>;</decl_stmt>
<do>do <block>{
<expr_stmt><expr><name>x</name> = (<name>x</name>&lt;&lt;8) | <name><name>bytes</name><index>[<expr>--<name>i</name></expr>]</index></name></expr>;</expr_stmt>
}</block> while <condition>(<expr><name>i</name> &gt; 0</expr>)</condition>;</do>
<if>if <condition>(<expr><name>SIZEOF_LONG</name> &gt; <name><name>f</name>-&gt;<name>size</name></name></expr>)</condition><then>
<expr_stmt><expr><name>x</name> |= -(<name>x</name> &amp; (1L &lt;&lt; ((8 * <name><name>f</name>-&gt;<name>size</name></name>) - 1)))</expr>;</expr_stmt></then></if>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>lu_uint</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>formatdef</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>x</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name> <init>= <expr><name><name>f</name>-&gt;<name>size</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>bytes</name> <init>= <expr>(const <name>unsigned</name> <name>char</name> *)<name>p</name></expr></init></decl>;</decl_stmt>
<do>do <block>{
<expr_stmt><expr><name>x</name> = (<name>x</name>&lt;&lt;8) | <name><name>bytes</name><index>[<expr>--<name>i</name></expr>]</index></name></expr>;</expr_stmt>
}</block> while <condition>(<expr><name>i</name> &gt; 0</expr>)</condition>;</do>
<if>if <condition>(<expr><name>x</name> &lt;= <name>LONG_MAX</name></expr>)</condition><then>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name>x</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<return>return <expr><call><name>PyLong_FromUnsignedLong</name><argument_list>(<argument><expr>(<name>long</name>)<name>x</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>lu_longlong</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>formatdef</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LONG_LONG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>PY_LONG_LONG</name></type> <name>x</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name> <init>= <expr><name><name>f</name>-&gt;<name>size</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>bytes</name> <init>= <expr>(const <name>unsigned</name> <name>char</name> *)<name>p</name></expr></init></decl>;</decl_stmt>
<do>do <block>{
<expr_stmt><expr><name>x</name> = (<name>x</name>&lt;&lt;8) | <name><name>bytes</name><index>[<expr>--<name>i</name></expr>]</index></name></expr>;</expr_stmt>
}</block> while <condition>(<expr><name>i</name> &gt; 0</expr>)</condition>;</do>
<if>if <condition>(<expr><name>SIZEOF_LONG_LONG</name> &gt; <name><name>f</name>-&gt;<name>size</name></name></expr>)</condition><then>
<expr_stmt><expr><name>x</name> |= -(<name>x</name> &amp; ((<name>PY_LONG_LONG</name>)1 &lt;&lt; ((8 * <name><name>f</name>-&gt;<name>size</name></name>) - 1)))</expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>x</name> &gt;= <name>LONG_MIN</name> &amp;&amp; <name>x</name> &lt;= <name>LONG_MAX</name></expr>)</condition><then>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><call><name>Py_SAFE_DOWNCAST</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>PY_LONG_LONG</name></expr></argument>, <argument><expr><name>long</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
<return>return <expr><call><name>PyLong_FromLongLong</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<return>return <expr><call><name>_PyLong_FromByteArray</name><argument_list>(<argument><expr>(const <name>unsigned</name> <name>char</name> *)<name>p</name></expr></argument>,
<argument><expr>8</expr></argument>,
<argument><expr>1</expr></argument>,
<argument><expr>1</expr></argument> )</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>lu_ulonglong</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>formatdef</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LONG_LONG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>unsigned</name> <name>PY_LONG_LONG</name></type> <name>x</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name> <init>= <expr><name><name>f</name>-&gt;<name>size</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>bytes</name> <init>= <expr>(const <name>unsigned</name> <name>char</name> *)<name>p</name></expr></init></decl>;</decl_stmt>
<do>do <block>{
<expr_stmt><expr><name>x</name> = (<name>x</name>&lt;&lt;8) | <name><name>bytes</name><index>[<expr>--<name>i</name></expr>]</index></name></expr>;</expr_stmt>
}</block> while <condition>(<expr><name>i</name> &gt; 0</expr>)</condition>;</do>
<if>if <condition>(<expr><name>x</name> &lt;= <name>LONG_MAX</name></expr>)</condition><then>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><macro><name>Py_SAFE_DOWNCAST</name><argument_list>(<argument>x</argument>, <argument>unsigned PY_LONG_LONG</argument>, <argument>long</argument>)</argument_list></macro></expr></argument>)</argument_list></call></expr>;</return></then></if>
<return>return <expr><call><name>PyLong_FromUnsignedLongLong</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<return>return <expr><call><name>_PyLong_FromByteArray</name><argument_list>(<argument><expr>(const <name>unsigned</name> <name>char</name> *)<name>p</name></expr></argument>,
<argument><expr>8</expr></argument>,
<argument><expr>1</expr></argument>,
<argument><expr>0</expr></argument> )</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>lu_float</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>formatdef</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>unpack_float</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>lu_double</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>formatdef</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>unpack_double</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>lp_int</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>p</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>formatdef</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>long</name></type> <name>x</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>get_wrapped_long</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>&amp;<name>x</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><name>i</name> = <name><name>f</name>-&gt;<name>size</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>i</name> != <name>SIZEOF_LONG</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>(<name>i</name> == 2) &amp;&amp; (<name>x</name> &lt; -32768 || <name>x</name> &gt; 32767)</expr>)</condition><then>
<expr_stmt><expr><call><name>RANGE_ERROR</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0xffffL</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<name>SIZEOF_LONG</name> != 4)</expr></cpp:if>
<else>else <if>if <condition>(<expr>(<name>i</name> == 4) &amp;&amp; (<name>x</name> &lt; -2147483648L || <name>x</name> &gt; 2147483647L)</expr>)</condition><then>
<expr_stmt><expr><call><name>RANGE_ERROR</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0xffffffffL</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PY_STRUCT_OVERFLOW_MASKING</name></expr></argument>)</argument_list></call></expr></cpp:if>
<else>else <if>if <condition>(<expr>(<name>i</name> == 1) &amp;&amp; (<name>x</name> &lt; -128 || <name>x</name> &gt; 127)</expr>)</condition><then>
<expr_stmt><expr><call><name>RANGE_ERROR</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0xffL</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></then></if>
<do>do <block>{
<expr_stmt><expr>*<name>p</name>++ = (<name>char</name>)<name>x</name></expr>;</expr_stmt>
<expr_stmt><expr><name>x</name> &gt;&gt;= 8</expr>;</expr_stmt>
}</block> while <condition>(<expr>--<name>i</name> &gt; 0</expr>)</condition>;</do>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>lp_uint</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>p</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>formatdef</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>x</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>get_wrapped_ulong</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>&amp;<name>x</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><name>i</name> = <name><name>f</name>-&gt;<name>size</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>i</name> != <name>SIZEOF_LONG</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>maxint</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>maxint</name> &lt;&lt;= <call>(<name>unsigned</name> <name>long</name>)<argument_list>(<argument><expr><name>i</name> * 8</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>x</name> &gt;= <name>maxint</name></expr>)</condition><then>
<expr_stmt><expr><call><name>RANGE_ERROR</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>maxint</name> - 1</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></then></if>
<do>do <block>{
<expr_stmt><expr>*<name>p</name>++ = (<name>char</name>)<name>x</name></expr>;</expr_stmt>
<expr_stmt><expr><name>x</name> &gt;&gt;= 8</expr>;</expr_stmt>
}</block> while <condition>(<expr>--<name>i</name> &gt; 0</expr>)</condition>;</do>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>lp_longlong</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>p</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>formatdef</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
<expr_stmt><expr><name>v</name> = <call><name>get_pylong</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><name>res</name> = <call><name>_PyLong_AsByteArray</name><argument_list>(<argument><expr>(<name>PyLongObject</name>*)<name>v</name></expr></argument>,
<argument><expr>(<name>unsigned</name> <name>char</name> *)<name>p</name></expr></argument>,
<argument><expr>8</expr></argument>,
<argument><expr>1</expr></argument>,
<argument><expr>1</expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>lp_ulonglong</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>p</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>formatdef</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
<expr_stmt><expr><name>v</name> = <call><name>get_pylong</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><name>res</name> = <call><name>_PyLong_AsByteArray</name><argument_list>(<argument><expr>(<name>PyLongObject</name>*)<name>v</name></expr></argument>,
<argument><expr>(<name>unsigned</name> <name>char</name> *)<name>p</name></expr></argument>,
<argument><expr>8</expr></argument>,
<argument><expr>1</expr></argument>,
<argument><expr>0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>lp_float</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>p</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>formatdef</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>double</name></type> <name>x</name> <init>= <expr><call><name>PyFloat_AsDouble</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>x</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>StructError</name></expr></argument>,
<argument><expr>"required argument is not a float"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<return>return <expr><call><name>_PyFloat_Pack4</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr>(<name>unsigned</name> <name>char</name> *)<name>p</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>lp_double</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>p</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>formatdef</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>double</name></type> <name>x</name> <init>= <expr><call><name>PyFloat_AsDouble</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>x</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>StructError</name></expr></argument>,
<argument><expr>"required argument is not a float"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<return>return <expr><call><name>_PyFloat_Pack8</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr>(<name>unsigned</name> <name>char</name> *)<name>p</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <name>formatdef</name></type> <name><name>lilendian_table</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr>'x'</expr>, <expr>1</expr>, <expr>0</expr>, <expr><name>NULL</name></expr>}</block></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PY_STRUCT_OVERFLOW_MASKING</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>'b'</expr>, <expr>1</expr>, <expr>0</expr>, <expr><name>nu_byte</name></expr>, <expr><name>lp_int</name></expr>}</block></expr>,
<expr><block>{<expr>'B'</expr>, <expr>1</expr>, <expr>0</expr>, <expr><name>nu_ubyte</name></expr>, <expr><name>lp_uint</name></expr>}</block></expr>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr><block>{<expr>'b'</expr>, <expr>1</expr>, <expr>0</expr>, <expr><name>nu_byte</name></expr>, <expr><name>np_byte</name></expr>}</block></expr>,
<expr><block>{<expr>'B'</expr>, <expr>1</expr>, <expr>0</expr>, <expr><name>nu_ubyte</name></expr>, <expr><name>np_ubyte</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr><block>{<expr>'c'</expr>, <expr>1</expr>, <expr>0</expr>, <expr><name>nu_char</name></expr>, <expr><name>np_char</name></expr>}</block></expr>,
<expr><block>{<expr>'s'</expr>, <expr>1</expr>, <expr>0</expr>, <expr><name>NULL</name></expr>}</block></expr>,
<expr><block>{<expr>'p'</expr>, <expr>1</expr>, <expr>0</expr>, <expr><name>NULL</name></expr>}</block></expr>,
<expr><block>{<expr>'h'</expr>, <expr>2</expr>, <expr>0</expr>, <expr><name>lu_int</name></expr>, <expr><name>lp_int</name></expr>}</block></expr>,
<expr><block>{<expr>'H'</expr>, <expr>2</expr>, <expr>0</expr>, <expr><name>lu_uint</name></expr>, <expr><name>lp_uint</name></expr>}</block></expr>,
<expr><block>{<expr>'i'</expr>, <expr>4</expr>, <expr>0</expr>, <expr><name>lu_int</name></expr>, <expr><name>lp_int</name></expr>}</block></expr>,
<expr><block>{<expr>'I'</expr>, <expr>4</expr>, <expr>0</expr>, <expr><name>lu_uint</name></expr>, <expr><name>lp_uint</name></expr>}</block></expr>,
<expr><block>{<expr>'l'</expr>, <expr>4</expr>, <expr>0</expr>, <expr><name>lu_int</name></expr>, <expr><name>lp_int</name></expr>}</block></expr>,
<expr><block>{<expr>'L'</expr>, <expr>4</expr>, <expr>0</expr>, <expr><name>lu_uint</name></expr>, <expr><name>lp_uint</name></expr>}</block></expr>,
<expr><block>{<expr>'q'</expr>, <expr>8</expr>, <expr>0</expr>, <expr><name>lu_longlong</name></expr>, <expr><name>lp_longlong</name></expr>}</block></expr>,
<expr><block>{<expr>'Q'</expr>, <expr>8</expr>, <expr>0</expr>, <expr><name>lu_ulonglong</name></expr>, <expr><name>lp_ulonglong</name></expr>}</block></expr>,
<expr><block>{<expr>'?'</expr>, <expr>1</expr>, <expr>0</expr>, <expr><name>bu_bool</name></expr>, <expr><name>bp_bool</name></expr>}</block></expr>,
<expr><block>{<expr>'f'</expr>, <expr>4</expr>, <expr>0</expr>, <expr><name>lu_float</name></expr>, <expr><name>lp_float</name></expr>}</block></expr>,
<expr><block>{<expr>'d'</expr>, <expr>8</expr>, <expr>0</expr>, <expr><name>lu_double</name></expr>, <expr><name>lp_double</name></expr>}</block></expr>,
<expr><block>{<expr>0</expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>formatdef</name> *</type>
<name>whichtable</name><parameter_list>(<param><decl><type><name>char</name> **</type><name>pfmt</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fmt</name> <init>= <expr>(*<name>pfmt</name>)++</expr></init></decl>;</decl_stmt>
<switch>switch <condition>(<expr>*<name>fmt</name></expr>)</condition> <block>{
<case>case <expr>'&lt;'</expr>:
<return>return <expr><name>lilendian_table</name></expr>;</return>
</case><case>case <expr>'&gt;'</expr>:
</case><case>case <expr>'!'</expr>:
<return>return <expr><name>bigendian_table</name></expr>;</return>
</case><case>case <expr>'='</expr>: <block>{
<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>p</name> <init>= <expr>(<name>char</name> *) &amp;<name>n</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>*<name>p</name> == 1</expr>)</condition><then>
<return>return <expr><name>lilendian_table</name></expr>;</return></then>
<else>else
<return>return <expr><name>bigendian_table</name></expr>;</return></else></if>
}</block>
</case><default>default:
<expr_stmt><expr>--*<name>pfmt</name></expr>;</expr_stmt>
</default><case>case <expr>'@'</expr>:
<return>return <expr><name>native_table</name></expr>;</return>
</case>}</block></switch>
}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>formatdef</name> *</type>
<name>getentry</name><parameter_list>(<param><decl><type><name>int</name></type> <name>c</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>formatdef</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<for>for (<init>;</init> <condition><expr><name><name>f</name>-&gt;<name>format</name></name> != '\0'</expr>;</condition> <incr><expr><name>f</name>++</expr></incr>) <block>{
<if>if <condition>(<expr><name><name>f</name>-&gt;<name>format</name></name> == <name>c</name></expr>)</condition><then> <block>{
<return>return <expr><name>f</name></expr>;</return>
}</block></then></if>
}</block></for>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>StructError</name></expr></argument>, <argument><expr>"bad char in struct format"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>align</name><parameter_list>(<param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>, <param><decl><type><name>char</name></type> <name>c</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>formatdef</name> *</type><name>e</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name><name>e</name>-&gt;<name>format</name></name> == <name>c</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>e</name>-&gt;<name>alignment</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>size</name> = ((<name>size</name> + <name><name>e</name>-&gt;<name>alignment</name></name> - 1)
/ <name><name>e</name>-&gt;<name>alignment</name></name>)
* <name><name>e</name>-&gt;<name>alignment</name></name></expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
<return>return <expr><name>size</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>prepare_s</name><parameter_list>(<param><decl><type><name>PyStructObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>formatdef</name> *</type><name>f</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>formatdef</name> *</type><name>e</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>formatcode</name> *</type><name>codes</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fmt</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl>, <decl><type ref="prev"/><name>len</name></decl>, <decl><type ref="prev"/><name>num</name></decl>, <decl><type ref="prev"/><name>itemsize</name></decl>, <decl><type ref="prev"/><name>x</name></decl>;</decl_stmt>
<expr_stmt><expr><name>fmt</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>s_format</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>f</name> = <call><name>whichtable</name><argument_list>(<argument><expr>(<name>char</name> **)&amp;<name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> = <name>fmt</name></expr>;</expr_stmt>
<expr_stmt><expr><name>size</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> = 0</expr>;</expr_stmt>
<while>while <condition>(<expr>(<name>c</name> = *<name>s</name>++) != '\0'</expr>)</condition> <block>{
<if>if <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
<continue>continue;</continue></then></if>
<if>if <condition>(<expr>'0' &lt;= <name>c</name> &amp;&amp; <name>c</name> &lt;= '9'</expr>)</condition><then> <block>{
<expr_stmt><expr><name>num</name> = <name>c</name> - '0'</expr>;</expr_stmt>
<while>while <condition>(<expr>'0' &lt;= (<name>c</name> = *<name>s</name>++) &amp;&amp; <name>c</name> &lt;= '9'</expr>)</condition> <block>{
<expr_stmt><expr><name>x</name> = <name>num</name>*10 + (<name>c</name> - '0')</expr>;</expr_stmt>
<if>if <condition>(<expr><name>x</name>/10 != <name>num</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(
<argument><expr><name>StructError</name></expr></argument>,
<argument><expr>"overflow in item count"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>num</name> = <name>x</name></expr>;</expr_stmt>
}</block></while>
<if>if <condition>(<expr><name>c</name> == '\0'</expr>)</condition><then>
<break>break;</break></then></if>
}</block></then> <else>else
<expr_stmt><expr><name>num</name> = 1</expr>;</expr_stmt></else></if>
<expr_stmt><expr><name>e</name> = <call><name>getentry</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>e</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{
<case>case <expr>'s'</expr>:
</case><case>case <expr>'p'</expr>:
<expr_stmt><expr><name>len</name>++</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'x'</expr>:
<break>break;</break>
</case><default>default:
<expr_stmt><expr><name>len</name> += <name>num</name></expr>;</expr_stmt>
<break>break;</break>
</default>}</block></switch>
<expr_stmt><expr><name>itemsize</name> = <name><name>e</name>-&gt;<name>size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>size</name> = <call><name>align</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>x</name> = <name>num</name> * <name>itemsize</name></expr>;</expr_stmt>
<expr_stmt><expr><name>size</name> += <name>x</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>x</name>/<name>itemsize</name> != <name>num</name> || <name>size</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>StructError</name></expr></argument>,
<argument><expr>"total struct size too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
}</block></while>
<if>if <condition>(<expr>(<name>len</name> + 1) &gt; (<name>PY_SSIZE_T_MAX</name> / <sizeof>sizeof<argument_list>(<argument><expr><name>formatcode</name></expr></argument>)</argument_list></sizeof>)</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>self</name>-&gt;<name>s_size</name></name> = <name>size</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>s_len</name></name> = <name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><name>codes</name> = <call><name>PyMem_MALLOC</name><argument_list>(<argument><expr>(<name>len</name> + 1) * <sizeof>sizeof<argument_list>(<argument><expr><name>formatcode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>codes</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>self</name>-&gt;<name>s_codes</name></name> = <name>codes</name></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> = <name>fmt</name></expr>;</expr_stmt>
<expr_stmt><expr><name>size</name> = 0</expr>;</expr_stmt>
<while>while <condition>(<expr>(<name>c</name> = *<name>s</name>++) != '\0'</expr>)</condition> <block>{
<if>if <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
<continue>continue;</continue></then></if>
<if>if <condition>(<expr>'0' &lt;= <name>c</name> &amp;&amp; <name>c</name> &lt;= '9'</expr>)</condition><then> <block>{
<expr_stmt><expr><name>num</name> = <name>c</name> - '0'</expr>;</expr_stmt>
<while>while <condition>(<expr>'0' &lt;= (<name>c</name> = *<name>s</name>++) &amp;&amp; <name>c</name> &lt;= '9'</expr>)</condition>
<expr_stmt><expr><name>num</name> = <name>num</name>*10 + (<name>c</name> - '0')</expr>;</expr_stmt></while>
<if>if <condition>(<expr><name>c</name> == '\0'</expr>)</condition><then>
<break>break;</break></then></if>
}</block></then> <else>else
<expr_stmt><expr><name>num</name> = 1</expr>;</expr_stmt></else></if>
<expr_stmt><expr><name>e</name> = <call><name>getentry</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>size</name> = <call><name>align</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>c</name> == 's' || <name>c</name> == 'p'</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>codes</name>-&gt;<name>offset</name></name> = <name>size</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>codes</name>-&gt;<name>size</name></name> = <name>num</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>codes</name>-&gt;<name>fmtdef</name></name> = <name>e</name></expr>;</expr_stmt>
<expr_stmt><expr><name>codes</name>++</expr>;</expr_stmt>
<expr_stmt><expr><name>size</name> += <name>num</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>c</name> == 'x'</expr>)</condition><then> <block>{
<expr_stmt><expr><name>size</name> += <name>num</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<while>while <condition>(<expr>--<name>num</name> &gt;= 0</expr>)</condition> <block>{
<expr_stmt><expr><name><name>codes</name>-&gt;<name>offset</name></name> = <name>size</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>codes</name>-&gt;<name>size</name></name> = <name><name>e</name>-&gt;<name>size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>codes</name>-&gt;<name>fmtdef</name></name> = <name>e</name></expr>;</expr_stmt>
<expr_stmt><expr><name>codes</name>++</expr>;</expr_stmt>
<expr_stmt><expr><name>size</name> += <name><name>e</name>-&gt;<name>size</name></name></expr>;</expr_stmt>
}</block></while>
}</block></else></if></else></if>
}</block></while>
<expr_stmt><expr><name><name>codes</name>-&gt;<name>fmtdef</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>codes</name>-&gt;<name>offset</name></name> = <name>size</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>codes</name>-&gt;<name>size</name></name> = 0</expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>s_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>self</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>type</name> != <name>NULL</name> &amp;&amp; <name><name>type</name>-&gt;<name>tp_alloc</name></name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>self</name> = <call><name><name>type</name>-&gt;<name>tp_alloc</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>self</name> != <name>NULL</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyStructObject</name> *</type><name>s</name> <init>= <expr>(<name>PyStructObject</name>*)<name>self</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>s_format</name></name> = <name>Py_None</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>s_codes</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>s_size</name></name> = -1</expr>;</expr_stmt>
<expr_stmt><expr><name><name>s</name>-&gt;<name>s_len</name></name> = -1</expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>self</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>s_init</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyStructObject</name> *</type><name>soself</name> <init>= <expr>(<name>PyStructObject</name> *)<name>self</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>o_format</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>kwlist</name><index>[]</index></name> <init>= <expr><block>{<expr>"format"</expr>, <expr>0</expr>}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyStruct_Check</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>, <argument><expr>"S:Struct"</expr></argument>, <argument><expr><name>kwlist</name></expr></argument>,
<argument><expr>&amp;<name>o_format</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>o_format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>soself</name>-&gt;<name>s_format</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>soself</name>-&gt;<name>s_format</name></name> = <name>o_format</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> = <call><name>prepare_s</name><argument_list>(<argument><expr><name>soself</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>s_dealloc</name><parameter_list>(<param><decl><type><name>PyStructObject</name> *</type><name>s</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>weakreflist</name></name> != <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyObject_ClearWeakRefs</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name><name>s</name>-&gt;<name>s_codes</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyMem_FREE</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>s_codes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>s</name>-&gt;<name>s_format</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call>-&gt;<call><name>tp_free</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>s_unpack_internal</name><parameter_list>(<param><decl><type><name>PyStructObject</name> *</type><name>soself</name></decl></param>, <param><decl><type><name>char</name> *</type><name>startfrom</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>formatcode</name> *</type><name>code</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><call><name>PyTuple_New</name><argument_list>(<argument><expr><name><name>soself</name>-&gt;<name>s_len</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<for>for (<init><expr><name>code</name> = <name><name>soself</name>-&gt;<name>s_codes</name></name></expr>;</init> <condition><expr><name><name>code</name>-&gt;<name>fmtdef</name></name> != <name>NULL</name></expr>;</condition> <incr><expr><name>code</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>formatdef</name> *</type><name>e</name> <init>= <expr><name><name>code</name>-&gt;<name>fmtdef</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>res</name> <init>= <expr><name>startfrom</name> + <name><name>code</name>-&gt;<name>offset</name></name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>e</name>-&gt;<name>format</name></name> == 's'</expr>)</condition><then> <block>{
<expr_stmt><expr><name>v</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name><name>code</name>-&gt;<name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name><name>e</name>-&gt;<name>format</name></name> == 'p'</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n</name> <init>= <expr>*(<name>unsigned</name> <name>char</name>*)<name>res</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>n</name> &gt;= <name><name>code</name>-&gt;<name>size</name></name></expr>)</condition><then>
<expr_stmt><expr><name>n</name> = <name><name>code</name>-&gt;<name>size</name></name> - 1</expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>v</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>res</name> + 1</expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>v</name> = <call><name><name>e</name>-&gt;<name>unpack</name></name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if></else></if>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>fail</name>;</goto></then></if>
<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name>++</expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<return>return <expr><name>result</name></expr>;</return>
<label><name>fail</name>:</label>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>s_unpack__doc__</name></expr></argument>,
<argument><expr>"S.unpack(str) -&gt; (v1, v2, ...)\n\
\n\
Return tuple containing values unpacked according to this Struct's format.\n\
Requires len(str) == self.size. See struct.__doc__ for more on format\n\
strings."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>s_unpack</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>inputstr</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>start</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>args</name><init>=<expr><name>NULL</name></expr></init>, *<name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyStructObject</name> *</type><name>soself</name> <init>= <expr>(<name>PyStructObject</name> *)<name>self</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyStruct_Check</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>soself</name>-&gt;<name>s_codes</name></name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>inputstr</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>fail</name>;</goto></then></if>
<if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>inputstr</name></expr></argument>)</argument_list></call> &amp;&amp;
<call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>inputstr</name></expr></argument>)</argument_list></call> == <name><name>soself</name>-&gt;<name>s_size</name></name></expr>)</condition><then> <block>{
<return>return <expr><call><name>s_unpack_internal</name><argument_list>(<argument><expr><name>soself</name></expr></argument>, <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>inputstr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>args</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><name>inputstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>args</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s#:unpack"</expr></argument>, <argument><expr>&amp;<name>start</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<goto>goto <name>fail</name>;</goto></then></if>
<if>if <condition>(<expr><name><name>soself</name>-&gt;<name>s_size</name></name> != <name>len</name></expr>)</condition><then>
<goto>goto <name>fail</name>;</goto></then></if>
<expr_stmt><expr><name>result</name> = <call><name>s_unpack_internal</name><argument_list>(<argument><expr><name>soself</name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
<label><name>fail</name>:</label>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>StructError</name></expr></argument>,
<argument><expr>"unpack requires a string argument of length %zd"</expr></argument>,
<argument><expr><name><name>soself</name>-&gt;<name>s_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>s_unpack_from__doc__</name></expr></argument>,
<argument><expr>"S.unpack_from(buffer[, offset]) -&gt; (v1, v2, ...)\n\
\n\
Return tuple containing values unpacked according to this Struct's format.\n\
Unlike unpack, unpack_from can unpack values from any object supporting\n\
the buffer API, not just str. Requires len(buffer[offset:]) &gt;= self.size.\n\
See struct.__doc__ for more on format strings."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>s_unpack_from</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>kwlist</name><index>[]</index></name> <init>= <expr><block>{<expr>"buffer"</expr>, <expr>"offset"</expr>, <expr>0</expr>}</block></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<name>PY_VERSION_HEX</name> &lt; 0x02050000)</expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name>fmt</name> <init>= <expr>"z#|i:unpack_from"</expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name>fmt</name> <init>= <expr>"z#|n:unpack_from"</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>buffer_len</name> <init>= <expr>0</expr></init>, <name>offset</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>buffer</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyStructObject</name> *</type><name>soself</name> <init>= <expr>(<name>PyStructObject</name> *)<name>self</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyStruct_Check</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>soself</name>-&gt;<name>s_codes</name></name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>kwlist</name></expr></argument>,
<argument><expr>&amp;<name>buffer</name></expr></argument>, <argument><expr>&amp;<name>buffer_len</name></expr></argument>, <argument><expr>&amp;<name>offset</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>buffer</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>StructError</name></expr></argument>,
<argument><expr>"unpack_from requires a buffer argument"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>offset</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>offset</name> += <name>buffer_len</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>offset</name> &lt; 0 || (<name>buffer_len</name> - <name>offset</name>) &lt; <name><name>soself</name>-&gt;<name>s_size</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>StructError</name></expr></argument>,
<argument><expr>"unpack_from requires a buffer of at least %zd bytes"</expr></argument>,
<argument><expr><name><name>soself</name>-&gt;<name>s_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>s_unpack_internal</name><argument_list>(<argument><expr><name>soself</name></expr></argument>, <argument><expr><name>buffer</name> + <name>offset</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>s_pack_internal</name><parameter_list>(<param><decl><type><name>PyStructObject</name> *</type><name>soself</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>int</name></type> <name>offset</name></decl></param>, <param><decl><type><name>char</name>*</type> <name>buf</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>formatcode</name> *</type><name>code</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>'\0'</expr></argument>, <argument><expr><name><name>soself</name>-&gt;<name>s_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> = <name>offset</name></expr>;</expr_stmt>
<for>for (<init><expr><name>code</name> = <name><name>soself</name>-&gt;<name>s_codes</name></name></expr>;</init> <condition><expr><name><name>code</name>-&gt;<name>fmtdef</name></name> != <name>NULL</name></expr>;</condition> <incr><expr><name>code</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name> <init>= <expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>i</name>++</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>formatdef</name> *</type><name>e</name> <init>= <expr><name><name>code</name>-&gt;<name>fmtdef</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>res</name> <init>= <expr><name>buf</name> + <name><name>code</name>-&gt;<name>offset</name></name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>e</name>-&gt;<name>format</name></name> == 's'</expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<call><name>PyString_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>StructError</name></expr></argument>,
<argument><expr>"argument for 's' must be a string"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>n</name> = <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>n</name> &gt; <name><name>code</name>-&gt;<name>size</name></name></expr>)</condition><then>
<expr_stmt><expr><name>n</name> = <name><name>code</name>-&gt;<name>size</name></name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>n</name> &gt; 0</expr>)</condition><then>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></then> <else>else <if>if <condition>(<expr><name><name>e</name>-&gt;<name>format</name></name> == 'p'</expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<call><name>PyString_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>StructError</name></expr></argument>,
<argument><expr>"argument for 'p' must be a string"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>n</name> = <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>n</name> &gt; (<name><name>code</name>-&gt;<name>size</name></name> - 1)</expr>)</condition><then>
<expr_stmt><expr><name>n</name> = <name><name>code</name>-&gt;<name>size</name></name> - 1</expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>n</name> &gt; 0</expr>)</condition><then>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>res</name> + 1</expr></argument>, <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>n</name> &gt; 255</expr>)</condition><then>
<expr_stmt><expr><name>n</name> = 255</expr>;</expr_stmt></then></if>
<expr_stmt><expr>*<name>res</name> = <macro><name>Py_SAFE_DOWNCAST</name><argument_list>(<argument>n</argument>, <argument>Py_ssize_t</argument>, <argument>unsigned char</argument>)</argument_list></macro></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<if>if <condition>(<expr><call><name><name>e</name>-&gt;<name>pack</name></name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>e</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PyLong_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>StructError</name></expr></argument>,
<argument><expr>"long too large to convert to int"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
}</block></else></if></else></if>
}</block></for>
<return>return <expr>0</expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>s_pack__doc__</name></expr></argument>,
<argument><expr>"S.pack(v1, v2, ...) -&gt; string\n\
\n\
Return a string containing values v1, v2, ... packed according to this\n\
Struct's format. See struct.__doc__ for more on format strings."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>s_pack</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyStructObject</name> *</type><name>soself</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
<expr_stmt><expr><name>soself</name> = (<name>PyStructObject</name> *)<name>self</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyStruct_Check</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>soself</name>-&gt;<name>s_codes</name></name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> != <name><name>soself</name>-&gt;<name>s_len</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>StructError</name></expr></argument>,
<argument><expr>"pack requires exactly %zd arguments"</expr></argument>, <argument><expr><name><name>soself</name>-&gt;<name>s_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>result</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr>(<name>char</name> *)<name>NULL</name></expr></argument>, <argument><expr><name><name>soself</name>-&gt;<name>s_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>( <expr><call><name>s_pack_internal</name><argument_list>(<argument><expr><name>soself</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> != 0</expr> )</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>s_pack_into__doc__</name></expr></argument>,
<argument><expr>"S.pack_into(buffer, offset, v1, v2, ...)\n\
\n\
Pack the values v1, v2, ... according to this Struct's format, write \n\
the packed bytes into the writable buffer buf starting at offset. Note\n\
that the offset is not an optional argument. See struct.__doc__ for \n\
more on format strings."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>s_pack_into</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyStructObject</name> *</type><name>soself</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>buffer</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>buffer_len</name></decl>, <decl><type ref="prev"/><name>offset</name></decl>;</decl_stmt>
<expr_stmt><expr><name>soself</name> = (<name>PyStructObject</name> *)<name>self</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyStruct_Check</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>soself</name>-&gt;<name>s_codes</name></name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> != (<name><name>soself</name>-&gt;<name>s_len</name></name> + 2)</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>StructError</name></expr></argument>,
<argument><expr>"pack_into requires exactly %zd arguments"</expr></argument>,
<argument><expr>(<name><name>soself</name>-&gt;<name>s_len</name></name> + 2)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>( <expr><call><name>PyObject_AsWriteBuffer</name><argument_list>(<argument><expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></argument>,
<argument><expr>(<name>void</name>**)&amp;<name>buffer</name></expr></argument>, <argument><expr>&amp;<name>buffer_len</name></expr></argument>)</argument_list></call> == -1</expr> )</condition><then> <block>{
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>assert</name><argument_list>( <argument><expr><name>buffer_len</name> &gt;= 0</expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>offset</name> = <call><name>PyInt_AsSsize_t</name><argument_list>(<argument><expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>offset</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>offset</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>offset</name> += <name>buffer_len</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>offset</name> &lt; 0 || (<name>buffer_len</name> - <name>offset</name>) &lt; <name><name>soself</name>-&gt;<name>s_size</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>StructError</name></expr></argument>,
<argument><expr>"pack_into requires a buffer of at least %zd bytes"</expr></argument>,
<argument><expr><name><name>soself</name>-&gt;<name>s_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>( <expr><call><name>s_pack_internal</name><argument_list>(<argument><expr><name>soself</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr><name>buffer</name> + <name>offset</name></expr></argument>)</argument_list></call> != 0</expr> )</condition><then> <block>{
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>s_get_format</name><parameter_list>(<param><decl><type><name>PyStructObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>void</name> *</type><name>unused</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>s_format</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name><name>self</name>-&gt;<name>s_format</name></name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>s_get_size</name><parameter_list>(<param><decl><type><name>PyStructObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>void</name> *</type><name>unused</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>s_size</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> struct <name>PyMethodDef</name></type> <name><name>s_methods</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr>"pack"</expr>, <expr><name>s_pack</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>s_pack__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"pack_into"</expr>, <expr><name>s_pack_into</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>s_pack_into__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"unpack"</expr>, <expr><name>s_unpack</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>s_unpack__doc__</name></expr>}</block></expr>,
<expr><block>{
<expr>"unpack_from"</expr>, <expr>(<name>PyCFunction</name>)<name>s_unpack_from</name></expr>, <expr><name>METH_VARARGS</name>|<name>METH_KEYWORDS</name></expr>,
<expr><name>s_unpack_from__doc__</name></expr>
}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>s__doc__</name></expr></argument>, <argument><expr>"Compiled struct object"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OFF</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>offsetof(PyStructObject, x)</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyGetSetDef</name></type> <name><name>s_getsetlist</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr>"format"</expr>, <expr>(<name>getter</name>)<name>s_get_format</name></expr>, <expr>(<name>setter</name>)<name>NULL</name></expr>, <expr>"struct format string"</expr>, <expr><name>NULL</name></expr>}</block></expr>,
<expr><block>{<expr>"size"</expr>, <expr>(<name>getter</name>)<name>s_get_size</name></expr>, <expr>(<name>setter</name>)<name>NULL</name></expr>, <expr>"struct size in bytes"</expr>, <expr><name>NULL</name></expr>}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier>
<name>PyTypeObject</name></type> <name>PyStructType</name> <init>= <expr><block>{
<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
"Struct"</expr>,
<expr><sizeof>sizeof<argument_list>(<argument><expr><name>PyStructObject</name></expr></argument>)</argument_list></sizeof></expr>,
<expr>0</expr>,
<expr>(<name>destructor</name>)<name>s_dealloc</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>PyObject_GenericGetAttr</name></expr>,
<expr><name>PyObject_GenericSetAttr</name></expr>,
<expr>0</expr>,
<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_BASETYPE</name> | <name>Py_TPFLAGS_HAVE_WEAKREFS</name></expr>,
<expr><name>s__doc__</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PyStructObject</name></expr></argument>, <argument><expr><name>weakreflist</name></expr></argument>)</argument_list></call></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>s_methods</name></expr>,
<expr><name>NULL</name></expr>,
<expr><name>s_getsetlist</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>s_init</name></expr>,
<expr><name>PyType_GenericAlloc</name></expr>,
<expr><name>s_new</name></expr>,
<expr><name>PyObject_Del</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXCACHE</name></cpp:macro> <cpp:value>100</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>cache</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>cache_struct</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>fmt</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type> <name>s_object</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>cache</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>cache</name> = <call><name>PyDict_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>cache</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
}</block></then></if>
<expr_stmt><expr><name>s_object</name> = <call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name>cache</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>s_object</name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>s_object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>s_object</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>s_object</name> = <call><name>PyObject_CallFunctionObjArgs</name><argument_list>(<argument><expr><call>(<name>PyObject</name> *)<argument_list>(<argument><expr>&amp;<name>PyStructType</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>s_object</name> != <name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PyDict_Size</name><argument_list>(<argument><expr><name>cache</name></expr></argument>)</argument_list></call> &gt;= <name>MAXCACHE</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyDict_Clear</name><argument_list>(<argument><expr><name>cache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>cache</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>s_object</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then>
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
}</block></then></if>
<return>return <expr><name>s_object</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>clearcache_doc</name></expr></argument>,
<argument><expr>"Clear the internal cache."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>clearcache</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name>cache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>calcsize_doc</name></expr></argument>,
<argument><expr>"Return size of C struct described by format string fmt."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>calcsize</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>fmt</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>s_object</name> <init>= <expr><call><name>cache_struct</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>s_object</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>n</name> = ((<name>PyStructObject</name> *)<name>s_object</name>)-&gt;<name>s_size</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>s_object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>pack_doc</name></expr></argument>,
<argument><expr>"Return string containing values v1, v2, ... packed according to fmt."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>pack</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>s_object</name></decl>, *<decl><type ref="prev"/><name>fmt</name></decl>, *<decl><type ref="prev"/><name>newargs</name></decl>, *<decl><type ref="prev"/><name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n</name> <init>= <expr><call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>n</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"missing format argument"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>fmt</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>newargs</name> = <call><name>PyTuple_GetSlice</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>newargs</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>s_object</name> = <call><name>cache_struct</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>s_object</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>newargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>result</name> = <call><name>s_pack</name><argument_list>(<argument><expr><name>s_object</name></expr></argument>, <argument><expr><name>newargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>newargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>s_object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>pack_into_doc</name></expr></argument>,
<argument><expr>"Pack the values v1, v2, ... according to fmt.\n\
Write the packed bytes into the writable buffer buf starting at offset."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>pack_into</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>s_object</name></decl>, *<decl><type ref="prev"/><name>fmt</name></decl>, *<decl><type ref="prev"/><name>newargs</name></decl>, *<decl><type ref="prev"/><name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n</name> <init>= <expr><call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>n</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"missing format argument"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>fmt</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>newargs</name> = <call><name>PyTuple_GetSlice</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>newargs</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>s_object</name> = <call><name>cache_struct</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>s_object</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>newargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>result</name> = <call><name>s_pack_into</name><argument_list>(<argument><expr><name>s_object</name></expr></argument>, <argument><expr><name>newargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>newargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>s_object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>unpack_doc</name></expr></argument>,
<argument><expr>"Unpack the string containing packed C structure data, according to fmt.\n\
Requires len(string) == calcsize(fmt)."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>unpack</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>s_object</name></decl>, *<decl><type ref="prev"/><name>fmt</name></decl>, *<decl><type ref="prev"/><name>inputstr</name></decl>, *<decl><type ref="prev"/><name>result</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"unpack"</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>2</expr></argument>, <argument><expr>&amp;<name>fmt</name></expr></argument>, <argument><expr>&amp;<name>inputstr</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>s_object</name> = <call><name>cache_struct</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>s_object</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>result</name> = <call><name>s_unpack</name><argument_list>(<argument><expr><name>s_object</name></expr></argument>, <argument><expr><name>inputstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>s_object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>unpack_from_doc</name></expr></argument>,
<argument><expr>"Unpack the buffer, containing packed C structure data, according to\n\
fmt, starting at offset. Requires len(buffer[offset:]) &gt;= calcsize(fmt)."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>unpack_from</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>s_object</name></decl>, *<decl><type ref="prev"/><name>fmt</name></decl>, *<decl><type ref="prev"/><name>newargs</name></decl>, *<decl><type ref="prev"/><name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n</name> <init>= <expr><call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>n</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"missing format argument"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>fmt</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>newargs</name> = <call><name>PyTuple_GetSlice</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>newargs</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>s_object</name> = <call><name>cache_struct</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>s_object</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>newargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>result</name> = <call><name>s_unpack_from</name><argument_list>(<argument><expr><name>s_object</name></expr></argument>, <argument><expr><name>newargs</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>newargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>s_object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> struct <name>PyMethodDef</name></type> <name><name>module_functions</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr>"_clearcache"</expr>, <expr>(<name>PyCFunction</name>)<name>clearcache</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>clearcache_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"calcsize"</expr>, <expr><name>calcsize</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>calcsize_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"pack"</expr>, <expr><name>pack</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>pack_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"pack_into"</expr>, <expr><name>pack_into</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>pack_into_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"unpack"</expr>, <expr><name>unpack</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>unpack_doc</name></expr>}</block></expr>,
<expr><block>{
<expr>"unpack_from"</expr>, <expr>(<name>PyCFunction</name>)<name>unpack_from</name></expr>,
<expr><name>METH_VARARGS</name>|<name>METH_KEYWORDS</name></expr>, <expr><name>unpack_from_doc</name></expr>
}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>module_doc</name></expr></argument>,
<argument><expr>"Functions to convert between Python values and C structs.\n\
Python strings are used to hold the data representing the C struct\n\
and also as format strings to describe the layout of data in the C struct.\n\
\n\
The optional first format char indicates byte order, size and alignment:\n\
@: native order, size &amp; alignment (default)\n\
=: native order, std. size &amp; alignment\n\
&lt;: little-endian, std. size &amp; alignment\n\
&gt;: big-endian, std. size &amp; alignment\n\
!: same as &gt;\n\
\n\
The remaining chars indicate types of args and must match exactly;\n\
these can be preceded by a decimal repeat count:\n\
x: pad byte (no data); c:char; b:signed byte; B:unsigned byte;\n\
h:short; H:unsigned short; i:int; I:unsigned int;\n\
l:long; L:unsigned long; f:float; d:double.\n\
Special cases (preceding decimal count indicates length):\n\
s:string (array of char); p: pascal string (with count byte).\n\
Special case (only available in native format):\n\
P:an integer type that is wide enough to hold a pointer.\n\
Special case (not in native mode unless 'long long' in platform C):\n\
q:long long; Q:unsigned long long\n\
Whitespace between formats is ignored.\n\
\n\
The variable struct.error is an exception raised on errors.\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><name>PyMODINIT_FUNC</name></type>
<name>init_struct</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>ver</name></decl>, *<decl><type ref="prev"/><name>m</name></decl>;</decl_stmt>
<expr_stmt><expr><name>ver</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr>"0.2"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ver</name> == <name>NULL</name></expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><name>m</name> = <call><name>Py_InitModule3</name><argument_list>(<argument><expr>"_struct"</expr></argument>, <argument><expr><name>module_functions</name></expr></argument>, <argument><expr><name>module_doc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>m</name> == <name>NULL</name></expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr>&amp;<name>PyStructType</name></expr></argument>)</argument_list></call> = &amp;<name>PyType_Type</name></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyType_Ready</name><argument_list>(<argument><expr>&amp;<name>PyStructType</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return;</return></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PY_STRUCT_OVERFLOW_MASKING</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>pyint_zero</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>pyint_zero</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>pyint_zero</name> == <name>NULL</name></expr>)</condition><then>
<return>return;</return></then></if>
}</block></then></if>
<if>if <condition>(<expr><name>pylong_ulong_mask</name> == <name>NULL</name></expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>(<name>SIZEOF_LONG</name> == 4)</expr></cpp:if>
<expr_stmt><expr><name>pylong_ulong_mask</name> = <call><name>PyLong_FromString</name><argument_list>(<argument><expr>"FFFFFFFF"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>16</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>pylong_ulong_mask</name> = <call><name>PyLong_FromString</name><argument_list>(<argument><expr>"FFFFFFFFFFFFFFFF"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>16</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><name>pylong_ulong_mask</name> == <name>NULL</name></expr>)</condition><then>
<return>return;</return></then></if>
}</block></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<block>{
<decl_stmt><decl><type><name>int</name></type> <name>one</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>formatdef</name> *</type><name>native</name> <init>= <expr><name>native_table</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>formatdef</name> *</type><name>other</name></decl>, *<decl><type ref="prev"/><name>ptr</name></decl>;</decl_stmt>
<if>if <condition>(<expr>(<name>int</name>)*(<name>unsigned</name> <name>char</name>*)&amp;<name>one</name></expr>)</condition><then>
<expr_stmt><expr><name>other</name> = <name>lilendian_table</name></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>other</name> = <name>bigendian_table</name></expr>;</expr_stmt></else></if>
<while>while <condition>(<expr><name><name>native</name>-&gt;<name>format</name></name> != '\0' &amp;&amp; <name><name>other</name>-&gt;<name>format</name></name> != '\0'</expr>)</condition> <block>{
<expr_stmt><expr><name>ptr</name> = <name>other</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name><name>ptr</name>-&gt;<name>format</name></name> != '\0'</expr>)</condition> <block>{
<if>if <condition>(<expr><name><name>ptr</name>-&gt;<name>format</name></name> == <name><name>native</name>-&gt;<name>format</name></name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>ptr</name> == <name>other</name></expr>)</condition><then>
<expr_stmt><expr><name>other</name>++</expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name><name>ptr</name>-&gt;<name>size</name></name> != <name><name>native</name>-&gt;<name>size</name></name></expr>)</condition><then>
<break>break;</break></then></if>
<if>if <condition>(<expr><name><name>ptr</name>-&gt;<name>format</name></name> == 'd' || <name><name>ptr</name>-&gt;<name>format</name></name> == 'f'</expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr><name><name>ptr</name>-&gt;<name>pack</name></name> = <name><name>native</name>-&gt;<name>pack</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ptr</name>-&gt;<name>unpack</name></name> = <name><name>native</name>-&gt;<name>unpack</name></name></expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
<expr_stmt><expr><name>ptr</name>++</expr>;</expr_stmt>
}</block></while>
<expr_stmt><expr><name>native</name>++</expr>;</expr_stmt>
}</block></while>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><name>StructError</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>StructError</name> = <call><name>PyErr_NewException</name><argument_list>(<argument><expr>"struct.error"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>StructError</name> == <name>NULL</name></expr>)</condition><then>
<return>return;</return></then></if>
}</block></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>StructError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"error"</expr></argument>, <argument><expr><name>StructError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>(<name>PyObject</name>*)&amp;<name>PyStructType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"Struct"</expr></argument>, <argument><expr>(<name>PyObject</name>*)&amp;<name>PyStructType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"__version__"</expr></argument>, <argument><expr><name>ver</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"_PY_STRUCT_RANGE_CHECKING"</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PY_STRUCT_OVERFLOW_MASKING</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"_PY_STRUCT_OVERFLOW_MASKING"</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PY_STRUCT_FLOAT_COERCE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"_PY_STRUCT_FLOAT_COERCE"</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>
</unit>
