<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="Modules/zlib/zlib.h"><cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>ZLIB_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZLIB_H</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"zconf.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call></expr></cpp:if>
<extern>extern "C" <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZLIB_VERSION</name></cpp:macro> <cpp:value>"1.2.3"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZLIB_VERNUM</name></cpp:macro> <cpp:value>0x1230</cpp:value></cpp:define>
<typedef>typedef <macro><name>voidpf</name> <argument_list>(<argument>*alloc_func</argument>)</argument_list></macro> <expr_stmt><expr><call><name>OF</name><argument_list>(<argument><expr>(<name>voidpf</name> <name>opaque</name>, <name>uInt</name> <name>items</name>, <name>uInt</name> <name>size</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt></typedef>
<typedef>typedef <macro><name>void</name> <argument_list>(<argument>*free_func</argument>)</argument_list></macro> <expr_stmt><expr><call><name>OF</name><argument_list>(<argument><expr>(<name>voidpf</name> <name>opaque</name>, <name>voidpf</name> <name>address</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt></typedef>
<struct_decl>struct <name>internal_state</name>;</struct_decl>
<typedef>typedef <type><struct>struct <name>z_stream_s</name> <block>{
<decl_stmt><decl><type><name>Bytef</name> *</type><name>next_in</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uInt</name></type> <name>avail_in</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uLong</name></type> <name>total_in</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Bytef</name> *</type><name>next_out</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uInt</name></type> <name>avail_out</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uLong</name></type> <name>total_out</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>msg</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>internal_state</name> <name>FAR</name> *</type><name>state</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>alloc_func</name></type> <name>zalloc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>free_func</name></type> <name>zfree</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>voidpf</name></type> <name>opaque</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>data_type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uLong</name></type> <name>adler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uLong</name></type> <name>reserved</name></decl>;</decl_stmt>
}</block></struct></type> <name>z_stream</name>;</typedef>
<typedef>typedef <type><name>z_stream</name> <name>FAR</name> *</type><name>z_streamp</name>;</typedef>
<typedef>typedef <type><struct>struct <name>gz_header_s</name> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>text</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uLong</name></type> <name>time</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>xflags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>os</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Bytef</name> *</type><name>extra</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uInt</name></type> <name>extra_len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uInt</name></type> <name>extra_max</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Bytef</name> *</type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uInt</name></type> <name>name_max</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Bytef</name> *</type><name>comment</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>uInt</name></type> <name>comm_max</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>hcrc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>done</name></decl>;</decl_stmt>
}</block></struct></type> <name>gz_header</name>;</typedef>
<typedef>typedef <type><name>gz_header</name> <name>FAR</name> *</type><name>gz_headerp</name>;</typedef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Z_NO_FLUSH</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Z_PARTIAL_FLUSH</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Z_SYNC_FLUSH</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Z_FULL_FLUSH</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Z_FINISH</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Z_BLOCK</name></cpp:macro> <cpp:value>5</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Z_OK</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Z_STREAM_END</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Z_NEED_DICT</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Z_ERRNO</name></cpp:macro> <cpp:value>(-1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Z_STREAM_ERROR</name></cpp:macro> <cpp:value>(-2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Z_DATA_ERROR</name></cpp:macro> <cpp:value>(-3)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Z_MEM_ERROR</name></cpp:macro> <cpp:value>(-4)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Z_BUF_ERROR</name></cpp:macro> <cpp:value>(-5)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Z_VERSION_ERROR</name></cpp:macro> <cpp:value>(-6)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Z_NO_COMPRESSION</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Z_BEST_SPEED</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Z_BEST_COMPRESSION</name></cpp:macro> <cpp:value>9</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Z_DEFAULT_COMPRESSION</name></cpp:macro> <cpp:value>(-1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Z_FILTERED</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Z_HUFFMAN_ONLY</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Z_RLE</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Z_FIXED</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Z_DEFAULT_STRATEGY</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Z_BINARY</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Z_TEXT</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Z_ASCII</name></cpp:macro> <cpp:value>Z_TEXT</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Z_UNKNOWN</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Z_DEFLATED</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>Z_NULL</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>zlib_version</name></cpp:macro> <cpp:value>zlibVersion()</cpp:value></cpp:define>
<decl_stmt><decl><type><name>ZEXTERN</name> <specifier>const</specifier> <name>char</name> * <name>ZEXPORT</name> <name>zlibVersion</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>void</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ZEXTERN</name> <name>int</name> <name>ZEXPORT</name> <name>deflate</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>z_streamp</name> <name>strm</name>, <name>int</name> <name>flush</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ZEXTERN</name> <name>int</name> <name>ZEXPORT</name> <name>deflateEnd</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>z_streamp</name> <name>strm</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ZEXTERN</name> <name>int</name> <name>ZEXPORT</name> <name>inflate</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>z_streamp</name> <name>strm</name>, <name>int</name> <name>flush</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ZEXTERN</name> <name>int</name> <name>ZEXPORT</name> <name>inflateEnd</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>z_streamp</name> <name>strm</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ZEXTERN</name> <name>int</name> <name>ZEXPORT</name> <name>deflateSetDictionary</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>z_streamp</name> <name>strm</name>,
const <name>Bytef</name> *<name>dictionary</name>,
<name>uInt</name> <name>dictLength</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ZEXTERN</name> <name>int</name> <name>ZEXPORT</name> <name>deflateCopy</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>z_streamp</name> <name>dest</name>,
<name>z_streamp</name> <name>source</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ZEXTERN</name> <name>int</name> <name>ZEXPORT</name> <name>deflateReset</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>z_streamp</name> <name>strm</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ZEXTERN</name> <name>int</name> <name>ZEXPORT</name> <name>deflateParams</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>z_streamp</name> <name>strm</name>,
<name>int</name> <name>level</name>,
<name>int</name> <name>strategy</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ZEXTERN</name> <name>int</name> <name>ZEXPORT</name> <name>deflateTune</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>z_streamp</name> <name>strm</name>,
<name>int</name> <name>good_length</name>,
<name>int</name> <name>max_lazy</name>,
<name>int</name> <name>nice_length</name>,
<name>int</name> <name>max_chain</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ZEXTERN</name> <name>uLong</name> <name>ZEXPORT</name> <name>deflateBound</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>z_streamp</name> <name>strm</name>,
<name>uLong</name> <name>sourceLen</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ZEXTERN</name> <name>int</name> <name>ZEXPORT</name> <name>deflatePrime</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>z_streamp</name> <name>strm</name>,
<name>int</name> <name>bits</name>,
<name>int</name> <name>value</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ZEXTERN</name> <name>int</name> <name>ZEXPORT</name> <name>deflateSetHeader</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>z_streamp</name> <name>strm</name>,
<name>gz_headerp</name> <name>head</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ZEXTERN</name> <name>int</name> <name>ZEXPORT</name> <name>inflateSetDictionary</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>z_streamp</name> <name>strm</name>,
const <name>Bytef</name> *<name>dictionary</name>,
<name>uInt</name> <name>dictLength</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ZEXTERN</name> <name>int</name> <name>ZEXPORT</name> <name>inflateSync</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>z_streamp</name> <name>strm</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ZEXTERN</name> <name>int</name> <name>ZEXPORT</name> <name>inflateCopy</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>z_streamp</name> <name>dest</name>,
<name>z_streamp</name> <name>source</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ZEXTERN</name> <name>int</name> <name>ZEXPORT</name> <name>inflateReset</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>z_streamp</name> <name>strm</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ZEXTERN</name> <name>int</name> <name>ZEXPORT</name> <name>inflatePrime</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>z_streamp</name> <name>strm</name>,
<name>int</name> <name>bits</name>,
<name>int</name> <name>value</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ZEXTERN</name> <name>int</name> <name>ZEXPORT</name> <name>inflateGetHeader</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>z_streamp</name> <name>strm</name>,
<name>gz_headerp</name> <name>head</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<typedef>typedef <macro><name>unsigned</name> <argument_list>(<argument>*in_func</argument>)</argument_list></macro> <expr_stmt><expr><call><name>OF</name><argument_list>(<argument><expr>(<name>void</name> <name>FAR</name> *, <name>unsigned</name> <name>char</name> <name>FAR</name> * <name>FAR</name> *)</expr></argument>)</argument_list></call></expr>;</expr_stmt></typedef>
<typedef>typedef <macro><name>int</name> <argument_list>(<argument>*out_func</argument>)</argument_list></macro> <expr_stmt><expr><call><name>OF</name><argument_list>(<argument><expr>(<name>void</name> <name>FAR</name> *, <name>unsigned</name> <name>char</name> <name>FAR</name> *, <name>unsigned</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt></typedef>
<decl_stmt><decl><type><name>ZEXTERN</name> <name>int</name> <name>ZEXPORT</name> <name>inflateBack</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>z_streamp</name> <name>strm</name>,
<name>in_func</name> <name>in</name>, <name>void</name> <name>FAR</name> *<name>in_desc</name>,
<name>out_func</name> <name>out</name>, <name>void</name> <name>FAR</name> *<name>out_desc</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ZEXTERN</name> <name>int</name> <name>ZEXPORT</name> <name>inflateBackEnd</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>z_streamp</name> <name>strm</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ZEXTERN</name> <name>uLong</name> <name>ZEXPORT</name> <name>zlibCompileFlags</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>void</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ZEXTERN</name> <name>int</name> <name>ZEXPORT</name> <name>compress</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>Bytef</name> *<name>dest</name>, <name>uLongf</name> *<name>destLen</name>,
const <name>Bytef</name> *<name>source</name>, <name>uLong</name> <name>sourceLen</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ZEXTERN</name> <name>int</name> <name>ZEXPORT</name> <name>compress2</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>Bytef</name> *<name>dest</name>, <name>uLongf</name> *<name>destLen</name>,
const <name>Bytef</name> *<name>source</name>, <name>uLong</name> <name>sourceLen</name>,
<name>int</name> <name>level</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ZEXTERN</name> <name>uLong</name> <name>ZEXPORT</name> <name>compressBound</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>uLong</name> <name>sourceLen</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ZEXTERN</name> <name>int</name> <name>ZEXPORT</name> <name>uncompress</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>Bytef</name> *<name>dest</name>, <name>uLongf</name> *<name>destLen</name>,
const <name>Bytef</name> *<name>source</name>, <name>uLong</name> <name>sourceLen</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<typedef>typedef <type><name>voidp</name></type> <name>gzFile</name>;</typedef>
<decl_stmt><decl><type><name>ZEXTERN</name> <name>gzFile</name> <name>ZEXPORT</name> <name>gzopen</name></type> <name>OF</name><argument_list>(<argument><expr>(const <name>char</name> *<name>path</name>, const <name>char</name> *<name>mode</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ZEXTERN</name> <name>gzFile</name> <name>ZEXPORT</name> <name>gzdopen</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>int</name> <name>fd</name>, const <name>char</name> *<name>mode</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ZEXTERN</name> <name>int</name> <name>ZEXPORT</name> <name>gzsetparams</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>gzFile</name> <name>file</name>, <name>int</name> <name>level</name>, <name>int</name> <name>strategy</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ZEXTERN</name> <name>int</name> <name>ZEXPORT</name> <name>gzread</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>gzFile</name> <name>file</name>, <name>voidp</name> <name>buf</name>, <name>unsigned</name> <name>len</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ZEXTERN</name> <name>int</name> <name>ZEXPORT</name> <name>gzwrite</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>gzFile</name> <name>file</name>,
<name>voidpc</name> <name>buf</name>, <name>unsigned</name> <name>len</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ZEXTERN</name> <name>int</name> <name>ZEXPORTVA</name> <name>gzprintf</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>gzFile</name> <name>file</name>, const <name>char</name> *<name>format</name>, ...)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ZEXTERN</name> <name>int</name> <name>ZEXPORT</name> <name>gzputs</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>gzFile</name> <name>file</name>, const <name>char</name> *<name>s</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ZEXTERN</name> <name>char</name> * <name>ZEXPORT</name> <name>gzgets</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>gzFile</name> <name>file</name>, <name>char</name> *<name>buf</name>, <name>int</name> <name>len</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ZEXTERN</name> <name>int</name> <name>ZEXPORT</name> <name>gzputc</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>gzFile</name> <name>file</name>, <name>int</name> <name>c</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ZEXTERN</name> <name>int</name> <name>ZEXPORT</name> <name>gzgetc</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>gzFile</name> <name>file</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ZEXTERN</name> <name>int</name> <name>ZEXPORT</name> <name>gzungetc</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>int</name> <name>c</name>, <name>gzFile</name> <name>file</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ZEXTERN</name> <name>int</name> <name>ZEXPORT</name> <name>gzflush</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>gzFile</name> <name>file</name>, <name>int</name> <name>flush</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ZEXTERN</name> <name>z_off_t</name> <name>ZEXPORT</name> <name>gzseek</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>gzFile</name> <name>file</name>,
<name>z_off_t</name> <name>offset</name>, <name>int</name> <name>whence</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ZEXTERN</name> <name>int</name> <name>ZEXPORT</name> <name>gzrewind</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>gzFile</name> <name>file</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ZEXTERN</name> <name>z_off_t</name> <name>ZEXPORT</name> <name>gztell</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>gzFile</name> <name>file</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ZEXTERN</name> <name>int</name> <name>ZEXPORT</name> <name>gzeof</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>gzFile</name> <name>file</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ZEXTERN</name> <name>int</name> <name>ZEXPORT</name> <name>gzdirect</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>gzFile</name> <name>file</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ZEXTERN</name> <name>int</name> <name>ZEXPORT</name> <name>gzclose</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>gzFile</name> <name>file</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ZEXTERN</name> <specifier>const</specifier> <name>char</name> * <name>ZEXPORT</name> <name>gzerror</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>gzFile</name> <name>file</name>, <name>int</name> *<name>errnum</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ZEXTERN</name> <name>void</name> <name>ZEXPORT</name> <name>gzclearerr</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>gzFile</name> <name>file</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ZEXTERN</name> <name>uLong</name> <name>ZEXPORT</name> <name>adler32</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>uLong</name> <name>adler</name>, const <name>Bytef</name> *<name>buf</name>, <name>uInt</name> <name>len</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ZEXTERN</name> <name>uLong</name> <name>ZEXPORT</name> <name>adler32_combine</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>uLong</name> <name>adler1</name>, <name>uLong</name> <name>adler2</name>,
<name>z_off_t</name> <name>len2</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ZEXTERN</name> <name>uLong</name> <name>ZEXPORT</name> <name>crc32</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>uLong</name> <name>crc</name>, const <name>Bytef</name> *<name>buf</name>, <name>uInt</name> <name>len</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ZEXTERN</name> <name>uLong</name> <name>ZEXPORT</name> <name>crc32_combine</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>uLong</name> <name>crc1</name>, <name>uLong</name> <name>crc2</name>, <name>z_off_t</name> <name>len2</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ZEXTERN</name> <name>int</name> <name>ZEXPORT</name> <name>deflateInit_</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>z_streamp</name> <name>strm</name>, <name>int</name> <name>level</name>,
const <name>char</name> *<name>version</name>, <name>int</name> <name>stream_size</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ZEXTERN</name> <name>int</name> <name>ZEXPORT</name> <name>inflateInit_</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>z_streamp</name> <name>strm</name>,
const <name>char</name> *<name>version</name>, <name>int</name> <name>stream_size</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ZEXTERN</name> <name>int</name> <name>ZEXPORT</name> <name>deflateInit2_</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>z_streamp</name> <name>strm</name>, <name>int</name> <name>level</name>, <name>int</name> <name>method</name>,
<name>int</name> <name>windowBits</name>, <name>int</name> <name>memLevel</name>,
<name>int</name> <name>strategy</name>, const <name>char</name> *<name>version</name>,
<name>int</name> <name>stream_size</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ZEXTERN</name> <name>int</name> <name>ZEXPORT</name> <name>inflateInit2_</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>z_streamp</name> <name>strm</name>, <name>int</name> <name>windowBits</name>,
const <name>char</name> *<name>version</name>, <name>int</name> <name>stream_size</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ZEXTERN</name> <name>int</name> <name>ZEXPORT</name> <name>inflateBackInit_</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>z_streamp</name> <name>strm</name>, <name>int</name> <name>windowBits</name>,
<name>unsigned</name> <name>char</name> <name>FAR</name> *<name>window</name>,
const <name>char</name> *<name>version</name>,
<name>int</name> <name>stream_size</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>deflateInit</name><parameter_list>(<param><type><name>strm</name></type></param>, <param><type><name>level</name></type></param>)</parameter_list></cpp:macro> <cpp:value>deflateInit_((strm), (level), ZLIB_VERSION, sizeof(z_stream))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>inflateInit</name><parameter_list>(<param><type><name>strm</name></type></param>)</parameter_list></cpp:macro> <cpp:value>inflateInit_((strm), ZLIB_VERSION, sizeof(z_stream))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>deflateInit2</name><parameter_list>(<param><type><name>strm</name></type></param>, <param><type><name>level</name></type></param>, <param><type><name>method</name></type></param>, <param><type><name>windowBits</name></type></param>, <param><type><name>memLevel</name></type></param>, <param><type><name>strategy</name></type></param>)</parameter_list></cpp:macro> <cpp:value>deflateInit2_((strm),(level),(method),(windowBits),(memLevel),(strategy), ZLIB_VERSION, sizeof(z_stream))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>inflateInit2</name><parameter_list>(<param><type><name>strm</name></type></param>, <param><type><name>windowBits</name></type></param>)</parameter_list></cpp:macro> <cpp:value>inflateInit2_((strm), (windowBits), ZLIB_VERSION, sizeof(z_stream))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>inflateBackInit</name><parameter_list>(<param><type><name>strm</name></type></param>, <param><type><name>windowBits</name></type></param>, <param><type><name>window</name></type></param>)</parameter_list></cpp:macro> <cpp:value>inflateBackInit_((strm), (windowBits), (window), ZLIB_VERSION, sizeof(z_stream))</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>ZUTIL_H</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>NO_DUMMY_DECL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<struct>struct <name>internal_state</name> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>dummy</name></decl>;</decl_stmt>
}</block>;</struct>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>ZEXTERN</name> <specifier>const</specifier> <name>char</name> * <name>ZEXPORT</name> <name>zError</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>int</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ZEXTERN</name> <name>int</name> <name>ZEXPORT</name> <name>inflateSyncPoint</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>z_streamp</name> <name>z</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ZEXTERN</name> <specifier>const</specifier> <name>uLongf</name> * <name>ZEXPORT</name> <name>get_crc_table</name></type> <name>OF</name><argument_list>(<argument><expr>(<name>void</name>)</expr></argument>)</argument_list></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call></expr></cpp:if>
}</block></extern>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
