<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="Modules/selectmodule.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;structmember.h&gt;</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>HAVE_BROKEN_POLL</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>FD_SETSIZE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FD_SETSIZE</name></cpp:macro> <cpp:value>512</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_POLL_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;poll.h&gt;</cpp:file></cpp:include>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYS_POLL_H</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/poll.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__sgi</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><specifier>extern</specifier> <name>void</name></type> <name>bzero</name><parameter_list>(<param><decl><type><name>void</name> *</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYS_TYPES_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>PYCC_GCC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;utils.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;winsock.h&gt;</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SOCKET</name></cpp:macro> <cpp:value>int</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__BEOS__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;net/socket.h&gt;</cpp:file></cpp:include>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__VMS</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;socket.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>SelectError</name></decl>;</decl_stmt>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>obj</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SOCKET</name></type> <name>fd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sentinel</name></decl>;</decl_stmt>
}</block></struct></type> <name>pylist</name>;</typedef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>reap_obj</name><parameter_list>(<param><decl><type><name>pylist</name></type> <name><name>fd2obj</name><index>[<expr><name>FD_SETSIZE</name> + 1</expr>]</index></name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>FD_SETSIZE</name> + 1 &amp;&amp; <name><name>fd2obj</name><index>[<expr><name>i</name></expr>]</index></name>.<name>sentinel</name> &gt;= 0</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>fd2obj</name><index>[<expr><name>i</name></expr>]</index></name>.<name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fd2obj</name><index>[<expr><name>i</name></expr>]</index></name>.<name>obj</name> = <name>NULL</name></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><name><name>fd2obj</name><index>[<expr>0</expr>]</index></name>.<name>sentinel</name> = -1</expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>seq2set</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>seq</name></decl></param>, <param><decl><type><name>fd_set</name> *</type><name>set</name></decl></param>, <param><decl><type><name>pylist</name></type> <name><name>fd2obj</name><index>[<expr><name>FD_SETSIZE</name> + 1</expr>]</index></name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>max</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>index</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name>*</type> <name>fast_seq</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name>*</type> <name>o</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>fd2obj</name><index>[<expr>0</expr>]</index></name>.<name>obj</name> = (<name>PyObject</name>*)0</expr>;</expr_stmt>
<expr_stmt><expr><call><name>FD_ZERO</name><argument_list>(<argument><expr><name>set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>fast_seq</name>=<call><name>PySequence_Fast</name><argument_list>(<argument><expr><name>seq</name></expr></argument>, <argument><expr>"arguments 1-3 must be sequences"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>fast_seq</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><name>len</name> = <call><name>PySequence_Fast_GET_SIZE</name><argument_list>(<argument><expr><name>fast_seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>SOCKET</name></type> <name>v</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!(<name>o</name> = <call><name>PySequence_Fast_GET_ITEM</name><argument_list>(<argument><expr><name>fast_seq</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>v</name> = <call><name>PyObject_AsFileDescriptor</name><argument_list>( <argument><expr><name>o</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == -1</expr>)</condition><then> <goto>goto <name>finally</name>;</goto></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>max</name> = 0</expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if>if <condition>(<expr><name>v</name> &lt; 0 || <name>v</name> &gt;= <name>FD_SETSIZE</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"filedescriptor out of range in select()"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>finally</name>;</goto>
}</block></then></if>
<if>if <condition>(<expr><name>v</name> &gt; <name>max</name></expr>)</condition><then>
<expr_stmt><expr><name>max</name> = <name>v</name></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>FD_SET</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>index</name> &gt;= <name>FD_SETSIZE</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"too many file descriptors in select()"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>finally</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name><name>fd2obj</name><index>[<expr><name>index</name></expr>]</index></name>.<name>obj</name> = <name>o</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fd2obj</name><index>[<expr><name>index</name></expr>]</index></name>.<name>fd</name> = <name>v</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fd2obj</name><index>[<expr><name>index</name></expr>]</index></name>.<name>sentinel</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>fd2obj</name><index>[<expr>++<name>index</name></expr>]</index></name>.<name>sentinel</name> = -1</expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>fast_seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>max</name>+1</expr>;</return>
<label><name>finally</name>:</label>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>fast_seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>set2list</name><parameter_list>(<param><decl><type><name>fd_set</name> *</type><name>set</name></decl></param>, <param><decl><type><name>pylist</name></type> <name><name>fd2obj</name><index>[<expr><name>FD_SETSIZE</name> + 1</expr>]</index></name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>count</name><init>=<expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>list</name></decl>, *<decl><type ref="prev"/><name>o</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>SOCKET</name></type> <name>fd</name></decl>;</decl_stmt>
<for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name><name>fd2obj</name><index>[<expr><name>j</name></expr>]</index></name>.<name>sentinel</name> &gt;= 0</expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
<if>if <condition>(<expr><call><name>FD_ISSET</name><argument_list>(<argument><expr><name><name>fd2obj</name><index>[<expr><name>j</name></expr>]</index></name>.<name>fd</name></expr></argument>, <argument><expr><name>set</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>count</name>++</expr>;</expr_stmt></then></if>
}</block></for>
<expr_stmt><expr><name>list</name> = <call><name>PyList_New</name><argument_list>(<argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>list</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>i</name> = 0</expr>;</expr_stmt>
<for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name><name>fd2obj</name><index>[<expr><name>j</name></expr>]</index></name>.<name>sentinel</name> &gt;= 0</expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
<expr_stmt><expr><name>fd</name> = <name><name>fd2obj</name><index>[<expr><name>j</name></expr>]</index></name>.<name>fd</name></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>FD_ISSET</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>set</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>fd</name> &gt; <name>FD_SETSIZE</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
<argument><expr>"filedescriptor out of range returned in select()"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>finally</name>;</goto>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>o</name> = <name><name>fd2obj</name><index>[<expr><name>j</name></expr>]</index></name>.<name>obj</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fd2obj</name><index>[<expr><name>j</name></expr>]</index></name>.<name>obj</name> = <name>NULL</name></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyList_SetItem</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>o</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<goto>goto <name>finally</name>;</goto></then></if>
<expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
}</block></then></if>
}</block></for>
<return>return <expr><name>list</name></expr>;</return>
<label><name>finally</name>:</label>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SELECT_USES_HEAP</name></cpp:undef>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>FD_SETSIZE</name> &gt; 1024</expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SELECT_USES_HEAP</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>select_select</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SELECT_USES_HEAP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>pylist</name> *</type><name>rfd2obj</name></decl>, *<decl><type ref="prev"/><name>wfd2obj</name></decl>, *<decl><type ref="prev"/><name>efd2obj</name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>pylist</name></type> <name><name>rfd2obj</name><index>[<expr><name>FD_SETSIZE</name> + 1</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>pylist</name></type> <name><name>wfd2obj</name><index>[<expr><name>FD_SETSIZE</name> + 1</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>pylist</name></type> <name><name>efd2obj</name><index>[<expr><name>FD_SETSIZE</name> + 1</expr>]</index></name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>ifdlist</name></decl>, *<decl><type ref="prev"/><name>ofdlist</name></decl>, *<decl><type ref="prev"/><name>efdlist</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>tout</name> <init>= <expr><name>Py_None</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>fd_set</name></type> <name>ifdset</name></decl>, <decl><type ref="prev"/><name>ofdset</name></decl>, <decl><type ref="prev"/><name>efdset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>timeout</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>timeval</name></type> <name>tv</name></decl>, *<decl><type ref="prev"/><name>tvp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>seconds</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>imax</name></decl>, <decl><type ref="prev"/><name>omax</name></decl>, <decl><type ref="prev"/><name>emax</name></decl>, <decl><type ref="prev"/><name>max</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"select"</expr></argument>, <argument><expr>3</expr></argument>, <argument><expr>4</expr></argument>,
<argument><expr>&amp;<name>ifdlist</name></expr></argument>, <argument><expr>&amp;<name>ofdlist</name></expr></argument>, <argument><expr>&amp;<name>efdlist</name></expr></argument>, <argument><expr>&amp;<name>tout</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>tout</name> == <name>Py_None</name></expr>)</condition><then>
<expr_stmt><expr><name>tvp</name> = (struct <name>timeval</name> *)0</expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr>!<call><name>PyNumber_Check</name><argument_list>(<argument><expr><name>tout</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"timeout must be a float or None"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>timeout</name> = <call><name>PyFloat_AsDouble</name><argument_list>(<argument><expr><name>tout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>timeout</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>timeout</name> &gt; (<name>double</name>)<name>LONG_MAX</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
<argument><expr>"timeout period too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>seconds</name> = (<name>long</name>)<name>timeout</name></expr>;</expr_stmt>
<expr_stmt><expr><name>timeout</name> = <name>timeout</name> - (<name>double</name>)<name>seconds</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tv</name>.<name>tv_sec</name></name> = <name>seconds</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tv</name>.<name>tv_usec</name></name> = <call>(<name>long</name>)<argument_list>(<argument><expr><name>timeout</name> * 1E6</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tvp</name> = &amp;<name>tv</name></expr>;</expr_stmt>
}</block></else></if></else></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SELECT_USES_HEAP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>rfd2obj</name> = <call><name>PyMem_NEW</name><argument_list>(<argument><expr><name>pylist</name></expr></argument>, <argument><expr><name>FD_SETSIZE</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>wfd2obj</name> = <call><name>PyMem_NEW</name><argument_list>(<argument><expr><name>pylist</name></expr></argument>, <argument><expr><name>FD_SETSIZE</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>efd2obj</name> = <call><name>PyMem_NEW</name><argument_list>(<argument><expr><name>pylist</name></expr></argument>, <argument><expr><name>FD_SETSIZE</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rfd2obj</name> == <name>NULL</name> || <name>wfd2obj</name> == <name>NULL</name> || <name>efd2obj</name> == <name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>rfd2obj</name></expr>)</condition><then> <expr_stmt><expr><call><name>PyMem_DEL</name><argument_list>(<argument><expr><name>rfd2obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>wfd2obj</name></expr>)</condition><then> <expr_stmt><expr><call><name>PyMem_DEL</name><argument_list>(<argument><expr><name>wfd2obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>efd2obj</name></expr>)</condition><then> <expr_stmt><expr><call><name>PyMem_DEL</name><argument_list>(<argument><expr><name>efd2obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name><name>rfd2obj</name><index>[<expr>0</expr>]</index></name>.<name>sentinel</name> = -1</expr>;</expr_stmt>
<expr_stmt><expr><name><name>wfd2obj</name><index>[<expr>0</expr>]</index></name>.<name>sentinel</name> = -1</expr>;</expr_stmt>
<expr_stmt><expr><name><name>efd2obj</name><index>[<expr>0</expr>]</index></name>.<name>sentinel</name> = -1</expr>;</expr_stmt>
<if>if <condition>(<expr>(<name>imax</name>=<call><name>seq2set</name><argument_list>(<argument><expr><name>ifdlist</name></expr></argument>, <argument><expr>&amp;<name>ifdset</name></expr></argument>, <argument><expr><name>rfd2obj</name></expr></argument>)</argument_list></call>) &lt; 0</expr>)</condition><then>
<goto>goto <name>finally</name>;</goto></then></if>
<if>if <condition>(<expr>(<name>omax</name>=<call><name>seq2set</name><argument_list>(<argument><expr><name>ofdlist</name></expr></argument>, <argument><expr>&amp;<name>ofdset</name></expr></argument>, <argument><expr><name>wfd2obj</name></expr></argument>)</argument_list></call>) &lt; 0</expr>)</condition><then>
<goto>goto <name>finally</name>;</goto></then></if>
<if>if <condition>(<expr>(<name>emax</name>=<call><name>seq2set</name><argument_list>(<argument><expr><name>efdlist</name></expr></argument>, <argument><expr>&amp;<name>efdset</name></expr></argument>, <argument><expr><name>efd2obj</name></expr></argument>)</argument_list></call>) &lt; 0</expr>)</condition><then>
<goto>goto <name>finally</name>;</goto></then></if>
<expr_stmt><expr><name>max</name> = <name>imax</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>omax</name> &gt; <name>max</name></expr>)</condition><then> <expr_stmt><expr><name>max</name> = <name>omax</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>emax</name> &gt; <name>max</name></expr>)</condition><then> <expr_stmt><expr><name>max</name> = <name>emax</name></expr>;</expr_stmt></then></if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>n</name> <init>= <expr><call><name>select</name><argument_list>(<argument><expr><name>max</name></expr></argument>, <argument><expr>&amp;<name>ifdset</name></expr></argument>, <argument><expr>&amp;<name>ofdset</name></expr></argument>, <argument><expr>&amp;<name>efdset</name></expr></argument>, <argument><expr><name>tvp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>n</name> == <name>SOCKET_ERROR</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetExcFromWindowsErr</name><argument_list>(<argument><expr><name>SelectError</name></expr></argument>, <argument><expr><call><name>WSAGetLastError</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if>if <condition>(<expr><name>n</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetFromErrno</name><argument_list>(<argument><expr><name>SelectError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<else>else <if>if <condition>(<expr><name>n</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>ifdlist</name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ifdlist</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>ret</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>3</expr></argument>, <argument><expr><name>ifdlist</name></expr></argument>, <argument><expr><name>ifdlist</name></expr></argument>, <argument><expr><name>ifdlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>ifdlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>ifdlist</name> = <call><name>set2list</name><argument_list>(<argument><expr>&amp;<name>ifdset</name></expr></argument>, <argument><expr><name>rfd2obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ofdlist</name> = <call><name>set2list</name><argument_list>(<argument><expr>&amp;<name>ofdset</name></expr></argument>, <argument><expr><name>wfd2obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>efdlist</name> = <call><name>set2list</name><argument_list>(<argument><expr>&amp;<name>efdset</name></expr></argument>, <argument><expr><name>efd2obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>ret</name> = <name>NULL</name></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>ret</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>3</expr></argument>, <argument><expr><name>ifdlist</name></expr></argument>, <argument><expr><name>ofdlist</name></expr></argument>, <argument><expr><name>efdlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>ifdlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>ofdlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>efdlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if></else></if>
<label><name>finally</name>:</label>
<expr_stmt><expr><call><name>reap_obj</name><argument_list>(<argument><expr><name>rfd2obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>reap_obj</name><argument_list>(<argument><expr><name>wfd2obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>reap_obj</name><argument_list>(<argument><expr><name>efd2obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>SELECT_USES_HEAP</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyMem_DEL</name><argument_list>(<argument><expr><name>rfd2obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyMem_DEL</name><argument_list>(<argument><expr><name>wfd2obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyMem_DEL</name><argument_list>(<argument><expr><name>efd2obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><name>ret</name></expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_POLL</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>HAVE_BROKEN_POLL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>PyObject_HEAD</name>
<name>PyObject</name> *</type><name>dict</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ufd_uptodate</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ufd_len</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>pollfd</name> *</type><name>ufds</name></decl>;</decl_stmt>
}</block></struct></type> <name>pollObject</name>;</typedef>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>poll_Type</name></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>update_ufd_array</name><parameter_list>(<param><decl><type><name>pollObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>pos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>key</name></decl>, *<decl><type ref="prev"/><name>value</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>pollfd</name> *</type><name>old_ufds</name> <init>= <expr><name><name>self</name>-&gt;<name>ufds</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>ufd_len</name></name> = <call><name>PyDict_Size</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>dict</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyMem_RESIZE</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ufds</name></name></expr></argument>, <argument>struct <expr><name>pollfd</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>ufd_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>ufds</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>self</name>-&gt;<name>ufds</name></name> = <name>old_ufds</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>i</name> = <name>pos</name> = 0</expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>PyDict_Next</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>dict</name></name></expr></argument>, <argument><expr>&amp;<name>pos</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr>&amp;<name>value</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<expr_stmt><expr><name><name>self</name>-&gt;<name>ufds</name><index>[<expr><name>i</name></expr>]</index></name>.<name>fd</name> = <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>ufds</name><index>[<expr><name>i</name></expr>]</index></name>.<name>events</name> = (<name>short</name>)<call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
}</block></while>
<expr_stmt><expr><name><name>self</name>-&gt;<name>ufd_uptodate</name></name> = 1</expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>poll_register_doc</name></expr></argument>,
<argument><expr>"register(fd [, eventmask] ) -&gt; None\n\n\
Register a file descriptor with the polling object.\n\
fd -- either an integer, or an object with a fileno() method returning an\n\
int.\n\
events -- an optional bitmask describing the type of events to check for"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>poll_register</name><parameter_list>(<param><decl><type><name>pollObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>o</name></decl>, *<decl><type ref="prev"/><name>key</name></decl>, *<decl><type ref="prev"/><name>value</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>, <decl><type ref="prev"/><name>events</name> <init>= <expr><name>POLLIN</name> | <name>POLLPRI</name> | <name>POLLOUT</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O|i:register"</expr></argument>, <argument><expr>&amp;<name>o</name></expr></argument>, <argument><expr>&amp;<name>events</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>fd</name> = <call><name>PyObject_AsFileDescriptor</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>fd</name> == -1</expr>)</condition><then> <return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>key</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>key</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>value</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>events</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>value</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>err</name> = <call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>dict</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>err</name> &lt; 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>self</name>-&gt;<name>ufd_uptodate</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>poll_modify_doc</name></expr></argument>,
<argument><expr>"modify(fd, eventmask) -&gt; None\n\n\
Modify an already registered file descriptor.\n\
fd -- either an integer, or an object with a fileno() method returning an\n\
int.\n\
events -- an optional bitmask describing the type of events to check for"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>poll_modify</name><parameter_list>(<param><decl><type><name>pollObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>o</name></decl>, *<decl><type ref="prev"/><name>key</name></decl>, *<decl><type ref="prev"/><name>value</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>, <decl><type ref="prev"/><name>events</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"Oi:modify"</expr></argument>, <argument><expr>&amp;<name>o</name></expr></argument>, <argument><expr>&amp;<name>events</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>fd</name> = <call><name>PyObject_AsFileDescriptor</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>fd</name> == -1</expr>)</condition><then> <return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>key</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>key</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>dict</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>errno</name> = <name>ENOENT</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_SetFromErrno</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>value</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>events</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>value</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>err</name> = <call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>dict</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>err</name> &lt; 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>self</name>-&gt;<name>ufd_uptodate</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>poll_unregister_doc</name></expr></argument>,
<argument><expr>"unregister(fd) -&gt; None\n\n\
Remove a file descriptor being tracked by the polling object."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>poll_unregister</name><parameter_list>(<param><decl><type><name>pollObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>o</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>key</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
<expr_stmt><expr><name>fd</name> = <call><name>PyObject_AsFileDescriptor</name><argument_list>( <argument><expr><name>o</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>fd</name> == -1</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>key</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>key</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>PyDict_DelItem</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>dict</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>ufd_uptodate</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>poll_poll_doc</name></expr></argument>,
<argument><expr>"poll( [timeout] ) -&gt; list of (fd, event) 2-tuples\n\n\
Polls the set of registered file descriptors, returning a list containing \n\
any descriptors that have events or errors to report."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>poll_poll</name><parameter_list>(<param><decl><type><name>pollObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result_list</name> <init>= <expr><name>NULL</name></expr></init>, *<name>tout</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>timeout</name> <init>= <expr>0</expr></init>, <name>poll_result</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>value</name> <init>= <expr><name>NULL</name></expr></init>, *<name>num</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"poll"</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>&amp;<name>tout</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>tout</name> == <name>NULL</name> || <name>tout</name> == <name>Py_None</name></expr>)</condition><then>
<expr_stmt><expr><name>timeout</name> = -1</expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr>!<call><name>PyNumber_Check</name><argument_list>(<argument><expr><name>tout</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"timeout must be an integer or None"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>tout</name> = <call><name>PyNumber_Int</name><argument_list>(<argument><expr><name>tout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>tout</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>timeout</name> = <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>tout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>timeout</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
}</block></else></if></else></if>
<if>if <condition>(<expr>!<name><name>self</name>-&gt;<name>ufd_uptodate</name></name></expr>)</condition><then>
<if>if <condition>(<expr><call><name>update_ufd_array</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if></then></if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>poll_result</name> <init>= <expr><call><name>poll</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ufds</name></name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>ufd_len</name></name></expr></argument>, <argument><expr><name>timeout</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>poll_result</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetFromErrno</name><argument_list>(<argument><expr><name>SelectError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>result_list</name> = <call><name>PyList_New</name><argument_list>(<argument><expr><name>poll_result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>result_list</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then>
<else>else <block>{
<for>for (<init><expr><name>i</name> = 0</expr>, <expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name>poll_result</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
<while>while <condition>(<expr>!<name><name>self</name>-&gt;<name>ufds</name><index>[<expr><name>i</name></expr>]</index></name>.<name>revents</name></expr>)</condition> <block>{
<expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
}</block></while>
<expr_stmt><expr><name>value</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>value</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<expr_stmt><expr><name>num</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ufds</name><index>[<expr><name>i</name></expr>]</index></name>.<name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>num</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>error</name>;</goto>
}</block></then></if>
<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>num</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ufds</name><index>[<expr><name>i</name></expr>]</index></name>.<name>revents</name> &amp; 0xffff</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>num</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>error</name>;</goto>
}</block></then></if>
<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>(<call><name>PyList_SetItem</name><argument_list>(<argument><expr><name>result_list</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call>) == -1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>error</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
}</block></for>
}</block></else></if>
<return>return <expr><name>result_list</name></expr>;</return>
<label><name>error</name>:</label>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>poll_methods</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{
<expr>"register"</expr>, <expr>(<name>PyCFunction</name>)<name>poll_register</name></expr>,
<expr><name>METH_VARARGS</name></expr>, <expr><name>poll_register_doc</name></expr>
}</block></expr>,
<expr><block>{
<expr>"modify"</expr>, <expr>(<name>PyCFunction</name>)<name>poll_modify</name></expr>,
<expr><name>METH_VARARGS</name></expr>, <expr><name>poll_modify_doc</name></expr>
}</block></expr>,
<expr><block>{
<expr>"unregister"</expr>, <expr>(<name>PyCFunction</name>)<name>poll_unregister</name></expr>,
<expr><name>METH_O</name></expr>, <expr><name>poll_unregister_doc</name></expr>
}</block></expr>,
<expr><block>{
<expr>"poll"</expr>, <expr>(<name>PyCFunction</name>)<name>poll_poll</name></expr>,
<expr><name>METH_VARARGS</name></expr>, <expr><name>poll_poll_doc</name></expr>
}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>pollObject</name> *</type>
<name>newPollObject</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>pollObject</name> *</type><name>self</name></decl>;</decl_stmt>
<expr_stmt><expr><name>self</name> = <call><name>PyObject_New</name><argument_list>(<argument><expr><name>pollObject</name></expr></argument>, <argument><expr>&amp;<name>poll_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>self</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>self</name>-&gt;<name>ufd_uptodate</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>ufds</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>dict</name></name> = <call><name>PyDict_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>dict</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><name>self</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>poll_dealloc</name><parameter_list>(<param><decl><type><name>pollObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>ufds</name></name> != <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyMem_DEL</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>ufds</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>dict</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyObject_Del</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>poll_getattr</name><parameter_list>(<param><decl><type><name>pollObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>char</name> *</type><name>name</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>Py_FindMethod</name><argument_list>(<argument><expr><name>poll_methods</name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>poll_Type</name> <init>= <expr><block>{
<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
"select.poll"</expr>,
<expr><sizeof>sizeof<argument_list>(<argument><expr><name>pollObject</name></expr></argument>)</argument_list></sizeof></expr>,
<expr>0</expr>,
<expr>(<name>destructor</name>)<name>poll_dealloc</name></expr>,
<expr>0</expr>,
<expr>(<name>getattrfunc</name>)<name>poll_getattr</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>poll_doc</name></expr></argument>,
<argument><expr>"Returns a polling object, which supports registering and\n\
unregistering file descriptors, and then polling them for I/O events."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>select_poll</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>unused</name></decl></param>)</parameter_list> <block>{
<return>return <expr>(<name>PyObject</name> *)<call><name>newPollObject</name><argument_list>()</argument_list></call></expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>int</name></type> <name>select_have_broken_poll</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>poll_test</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name><name>filedes</name><index>[<expr>2</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>pollfd</name></type> <name>poll_struct</name> <init>= <expr><block>{ <expr>0</expr>, <expr><name>POLLIN</name>|<name>POLLPRI</name>|<name>POLLOUT</name></expr>, <expr>0</expr> }</block></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>pipe</name><argument_list>(<argument><expr><name>filedes</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<return>return <expr>1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>poll_struct</name>.<name>fd</name></name> = <name><name>filedes</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>filedes</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>filedes</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>poll_test</name> = <call><name>poll</name><argument_list>(<argument><expr>&amp;<name>poll_struct</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>poll_test</name> &lt; 0</expr>)</condition><then> <block>{
<return>return <expr>1</expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><name>poll_test</name> == 0 &amp;&amp; <name><name>poll_struct</name>.<name>revents</name></name> != <name>POLLNVAL</name></expr>)</condition><then> <block>{
<return>return <expr>1</expr>;</return>
}</block></then></if></else></if>
<return>return <expr>0</expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_EPOLL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYS_EPOLL_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/epoll.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>PyObject_HEAD</name>
<name>SOCKET</name></type> <name>epfd</name></decl>;</decl_stmt>
}</block></struct></type> <name>pyEpoll_Object</name>;</typedef>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>pyEpoll_Type</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pyepoll_CHECK</name><parameter_list>(<param><type><name>op</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(PyObject_TypeCheck((op), &amp;pyEpoll_Type))</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>pyepoll_err_closed</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"I/O operation on closed epoll fd"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pyepoll_internal_close</name><parameter_list>(<param><decl><type><name>pyEpoll_Object</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>save_errno</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>epfd</name></name> &gt;= 0</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>epfd</name> <init>= <expr><name><name>self</name>-&gt;<name>epfd</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>epfd</name></name> = -1</expr>;</expr_stmt>
<macro><name>Py_BEGIN_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><call><name>close</name><argument_list>(<argument><expr><name>epfd</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>save_errno</name> = <name>errno</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>Py_END_ALLOW_THREADS</name></expr></expr_stmt>
}</block></then></if>
<return>return <expr><name>save_errno</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>newPyEpoll_Object</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>int</name></type> <name>sizehint</name></decl></param>, <param><decl><type><name>SOCKET</name></type> <name>fd</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>pyEpoll_Object</name> *</type><name>self</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>sizehint</name> == -1</expr>)</condition><then> <block>{
<expr_stmt><expr><name>sizehint</name> = <name>FD_SETSIZE</name>-1</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>sizehint</name> &lt; 1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"sizehint must be greater zero, got %d"</expr></argument>,
<argument><expr><name>sizehint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if></else></if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>type</name> != <name>NULL</name> &amp;&amp; <name><name>type</name>-&gt;<name>tp_alloc</name></name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>self</name> = (<name>pyEpoll_Object</name> *) <call><name><name>type</name>-&gt;<name>tp_alloc</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>self</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>fd</name> == -1</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name><name>self</name>-&gt;<name>epfd</name></name> <init>= <expr><call><name>epoll_create</name><argument_list>(<argument><expr><name>sizehint</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>Py_END_ALLOW_THREADS</name></expr></expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name><name>self</name>-&gt;<name>epfd</name></name> = <name>fd</name></expr>;</expr_stmt>
}</block></else></if>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>epfd</name></name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_SetFromErrno</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr>(<name>PyObject</name> *)<name>self</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>pyepoll_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>sizehint</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>kwlist</name><index>[]</index></name> <init>= <expr><block>{<expr>"sizehint"</expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>, <argument><expr>"|i:epoll"</expr></argument>, <argument><expr><name>kwlist</name></expr></argument>,
<argument><expr>&amp;<name>sizehint</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>newPyEpoll_Object</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>sizehint</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pyepoll_dealloc</name><parameter_list>(<param><decl><type><name>pyEpoll_Object</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr>(<name>void</name>)<call><name>pyepoll_internal_close</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call>-&gt;<call><name>tp_free</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>pyepoll_close</name><parameter_list>(<param><decl><type><name>pyEpoll_Object</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>errno</name> = <call><name>pyepoll_internal_close</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>errno</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetFromErrno</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>pyepoll_close_doc</name></expr></argument>,
<argument><expr>"close() -&gt; None\n\
\n\
Close the epoll control file descriptor. Further operations on the epoll\n\
object will raise an exception."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>pyepoll_get_closed</name><parameter_list>(<param><decl><type><name>pyEpoll_Object</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>epfd</name></name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>Py_RETURN_TRUE</name></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>Py_RETURN_FALSE</name></expr>;</expr_stmt></else></if>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>pyepoll_fileno</name><parameter_list>(<param><decl><type><name>pyEpoll_Object</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>epfd</name></name> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name>pyepoll_err_closed</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>epfd</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>pyepoll_fileno_doc</name></expr></argument>,
<argument><expr>"fileno() -&gt; int\n\
\n\
Return the epoll control file descriptor."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>pyepoll_fromfd</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>cls</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>SOCKET</name></type> <name>fd</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:fromfd"</expr></argument>, <argument><expr>&amp;<name>fd</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>newPyEpoll_Object</name><argument_list>(<argument><expr>(<name>PyTypeObject</name>*)<name>cls</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>pyepoll_fromfd_doc</name></expr></argument>,
<argument><expr>"fromfd(fd) -&gt; epoll\n\
\n\
Create an epoll object from a given control fd."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>pyepoll_internal_ctl</name><parameter_list>(<param><decl><type><name>int</name></type> <name>epfd</name></decl></param>, <param><decl><type><name>int</name></type> <name>op</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>pfd</name></decl></param>, <param><decl><type><name>unsigned</name> <name>int</name></type> <name>events</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>epoll_event</name></type> <name>ev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>epfd</name> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name>pyepoll_err_closed</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>fd</name> = <call><name>PyObject_AsFileDescriptor</name><argument_list>(<argument><expr><name>pfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>fd</name> == -1</expr>)</condition><then> <block>{
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<switch>switch<condition>(<expr><name>op</name></expr>)</condition> <block>{
<case>case <expr><name>EPOLL_CTL_ADD</name></expr>:
</case><case>case <expr><name>EPOLL_CTL_MOD</name></expr>:
<expr_stmt><expr><name><name>ev</name>.<name>events</name></name> = <name>events</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ev</name>.<name>data</name>.<name>fd</name></name> = <name>fd</name></expr>;</expr_stmt>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>result</name> <init>= <expr><call><name>epoll_ctl</name><argument_list>(<argument><expr><name>epfd</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr>&amp;<name>ev</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<break>break;</break>
</case><case>case <expr><name>EPOLL_CTL_DEL</name></expr>:
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>result</name> <init>= <expr><call><name>epoll_ctl</name><argument_list>(<argument><expr><name>epfd</name></expr></argument>, <argument><expr><name>op</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>, <argument><expr>&amp;<name>ev</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>errno</name> == <name>EBADF</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>result</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
}</block></then></if>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<break>break;</break>
</case><default>default:
<expr_stmt><expr><name>result</name> = -1</expr>;</expr_stmt>
<expr_stmt><expr><name>errno</name> = <name>EINVAL</name></expr>;</expr_stmt>
</default>}</block></switch>
<if>if <condition>(<expr><name>result</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetFromErrno</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>pyepoll_register</name><parameter_list>(<param><decl><type><name>pyEpoll_Object</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>pfd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>events</name> <init>= <expr><name>EPOLLIN</name> | <name>EPOLLOUT</name> | <name>EPOLLPRI</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>kwlist</name><index>[]</index></name> <init>= <expr><block>{<expr>"fd"</expr>, <expr>"eventmask"</expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>, <argument><expr>"O|I:register"</expr></argument>, <argument><expr><name>kwlist</name></expr></argument>,
<argument><expr>&amp;<name>pfd</name></expr></argument>, <argument><expr>&amp;<name>events</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>pyepoll_internal_ctl</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>epfd</name></name></expr></argument>, <argument><expr><name>EPOLL_CTL_ADD</name></expr></argument>, <argument><expr><name>pfd</name></expr></argument>, <argument><expr><name>events</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>pyepoll_register_doc</name></expr></argument>,
<argument><expr>"register(fd[, eventmask]) -&gt; bool\n\
\n\
Registers a new fd or modifies an already registered fd. register() returns\n\
True if a new fd was registered or False if the event mask for fd was modified.\n\
fd is the target file descriptor of the operation.\n\
events is a bit set composed of the various EPOLL constants; the default\n\
is EPOLL_IN | EPOLL_OUT | EPOLL_PRI.\n\
\n\
The epoll interface supports all file descriptors that support poll."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>pyepoll_modify</name><parameter_list>(<param><decl><type><name>pyEpoll_Object</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>pfd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>events</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>kwlist</name><index>[]</index></name> <init>= <expr><block>{<expr>"fd"</expr>, <expr>"eventmask"</expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>, <argument><expr>"OI:modify"</expr></argument>, <argument><expr><name>kwlist</name></expr></argument>,
<argument><expr>&amp;<name>pfd</name></expr></argument>, <argument><expr>&amp;<name>events</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>pyepoll_internal_ctl</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>epfd</name></name></expr></argument>, <argument><expr><name>EPOLL_CTL_MOD</name></expr></argument>, <argument><expr><name>pfd</name></expr></argument>, <argument><expr><name>events</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>pyepoll_modify_doc</name></expr></argument>,
<argument><expr>"modify(fd, eventmask) -&gt; None\n\
\n\
fd is the target file descriptor of the operation\n\
events is a bit set composed of the various EPOLL constants"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>pyepoll_unregister</name><parameter_list>(<param><decl><type><name>pyEpoll_Object</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>pfd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>kwlist</name><index>[]</index></name> <init>= <expr><block>{<expr>"fd"</expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>, <argument><expr>"O:unregister"</expr></argument>, <argument><expr><name>kwlist</name></expr></argument>,
<argument><expr>&amp;<name>pfd</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>pyepoll_internal_ctl</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>epfd</name></name></expr></argument>, <argument><expr><name>EPOLL_CTL_DEL</name></expr></argument>, <argument><expr><name>pfd</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>pyepoll_unregister_doc</name></expr></argument>,
<argument><expr>"unregister(fd) -&gt; None\n\
\n\
fd is the target file descriptor of the operation."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>pyepoll_poll</name><parameter_list>(<param><decl><type><name>pyEpoll_Object</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>double</name></type> <name>dtimeout</name> <init>= <expr>-1.</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>timeout</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>maxevents</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nfds</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>elist</name> <init>= <expr><name>NULL</name></expr></init>, *<name>etuple</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>epoll_event</name> *</type><name>evs</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>kwlist</name><index>[]</index></name> <init>= <expr><block>{<expr>"timeout"</expr>, <expr>"maxevents"</expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>epfd</name></name> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name>pyepoll_err_closed</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>, <argument><expr>"|di:poll"</expr></argument>, <argument><expr><name>kwlist</name></expr></argument>,
<argument><expr>&amp;<name>dtimeout</name></expr></argument>, <argument><expr>&amp;<name>maxevents</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>dtimeout</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>timeout</name> = -1</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>dtimeout</name> * 1000.0 &gt; <name>INT_MAX</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
<argument><expr>"timeout is too large"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>timeout</name> = <call>(<name>int</name>)<argument_list>(<argument><expr><name>dtimeout</name> * 1000.0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if></else></if>
<if>if <condition>(<expr><name>maxevents</name> == -1</expr>)</condition><then> <block>{
<expr_stmt><expr><name>maxevents</name> = <name>FD_SETSIZE</name>-1</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>maxevents</name> &lt; 1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"maxevents must be greater than 0, got %d"</expr></argument>,
<argument><expr><name>maxevents</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if></else></if>
<expr_stmt><expr><name>evs</name> = <call><name>PyMem_New</name><argument_list>(<argument>struct <expr><name>epoll_event</name></expr></argument>, <argument><expr><name>maxevents</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>evs</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>nfds</name> <init>= <expr><call><name>epoll_wait</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>epfd</name></name></expr></argument>, <argument><expr><name>evs</name></expr></argument>, <argument><expr><name>maxevents</name></expr></argument>, <argument><expr><name>timeout</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>nfds</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetFromErrno</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>error</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>elist</name> = <call><name>PyList_New</name><argument_list>(<argument><expr><name>nfds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>elist</name> == <name>NULL</name></expr>)</condition><then> <block>{
<goto>goto <name>error</name>;</goto>
}</block></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>nfds</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><name>etuple</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"iI"</expr></argument>, <argument><expr><name><name>evs</name><index>[<expr><name>i</name></expr>]</index></name>.<name><name>data</name>.<name>fd</name></name></expr></argument>, <argument><expr><name><name>evs</name><index>[<expr><name>i</name></expr>]</index></name>.<name>events</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>etuple</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name>elist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>error</name>;</goto>
}</block></then></if>
<expr_stmt><expr><call><name>PyList_SET_ITEM</name><argument_list>(<argument><expr><name>elist</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>etuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<label><name>error</name>:</label>
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>evs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>elist</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>pyepoll_poll_doc</name></expr></argument>,
<argument><expr>"poll([timeout=-1[, maxevents=-1]]) -&gt; [(fd, events), (...)]\n\
\n\
Wait for events on the epoll file descriptor for a maximum time of timeout\n\
in seconds (as float). -1 makes poll wait indefinitely.\n\
Up to maxevents are returned to the caller."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>pyepoll_methods</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{
<expr>"fromfd"</expr>, <expr>(<name>PyCFunction</name>)<name>pyepoll_fromfd</name></expr>,
<expr><name>METH_VARARGS</name> | <name>METH_CLASS</name></expr>, <expr><name>pyepoll_fromfd_doc</name></expr>
}</block></expr>,
<expr><block>{
<expr>"close"</expr>, <expr>(<name>PyCFunction</name>)<name>pyepoll_close</name></expr>, <expr><name>METH_NOARGS</name></expr>,
<expr><name>pyepoll_close_doc</name></expr>
}</block></expr>,
<expr><block>{
<expr>"fileno"</expr>, <expr>(<name>PyCFunction</name>)<name>pyepoll_fileno</name></expr>, <expr><name>METH_NOARGS</name></expr>,
<expr><name>pyepoll_fileno_doc</name></expr>
}</block></expr>,
<expr><block>{
<expr>"modify"</expr>, <expr>(<name>PyCFunction</name>)<name>pyepoll_modify</name></expr>,
<expr><name>METH_VARARGS</name> | <name>METH_KEYWORDS</name></expr>, <expr><name>pyepoll_modify_doc</name></expr>
}</block></expr>,
<expr><block>{
<expr>"register"</expr>, <expr>(<name>PyCFunction</name>)<name>pyepoll_register</name></expr>,
<expr><name>METH_VARARGS</name> | <name>METH_KEYWORDS</name></expr>, <expr><name>pyepoll_register_doc</name></expr>
}</block></expr>,
<expr><block>{
<expr>"unregister"</expr>, <expr>(<name>PyCFunction</name>)<name>pyepoll_unregister</name></expr>,
<expr><name>METH_VARARGS</name> | <name>METH_KEYWORDS</name></expr>, <expr><name>pyepoll_unregister_doc</name></expr>
}</block></expr>,
<expr><block>{
<expr>"poll"</expr>, <expr>(<name>PyCFunction</name>)<name>pyepoll_poll</name></expr>,
<expr><name>METH_VARARGS</name> | <name>METH_KEYWORDS</name></expr>, <expr><name>pyepoll_poll_doc</name></expr>
}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>,
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyGetSetDef</name></type> <name><name>pyepoll_getsetlist</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{
<expr>"closed"</expr>, <expr>(<name>getter</name>)<name>pyepoll_get_closed</name></expr>, <expr><name>NULL</name></expr>,
<expr>"True if the epoll handler is closed"</expr>
}</block></expr>,
<expr><block>{<expr>0</expr>}</block></expr>,
}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>pyepoll_doc</name></expr></argument>,
<argument><expr>"select.epoll([sizehint=-1])\n\
\n\
Returns an epolling object\n\
\n\
sizehint must be a positive integer or -1 for the default size. The\n\
sizehint is used to optimize internal data structures. It doesn't limit\n\
the maximum number of monitored events."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>pyEpoll_Type</name> <init>= <expr><block>{
<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
"select.epoll"</expr>,
<expr><sizeof>sizeof<argument_list>(<argument><expr><name>pyEpoll_Object</name></expr></argument>)</argument_list></sizeof></expr>,
<expr>0</expr>,
<expr>(<name>destructor</name>)<name>pyepoll_dealloc</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>PyObject_GenericGetAttr</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>Py_TPFLAGS_DEFAULT</name></expr>,
<expr><name>pyepoll_doc</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>pyepoll_methods</name></expr>,
<expr>0</expr>,
<expr><name>pyepoll_getsetlist</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>pyepoll_new</name></expr>,
<expr>0</expr>,
}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_KQUEUE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYS_EVENT_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/event.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>kqueue_event_doc</name></expr></argument>,
<argument><expr>"kevent(ident, filter=KQ_FILTER_READ, flags=KQ_ADD, fflags=0, data=0, udata=0)\n\
\n\
This object is the equivalent of the struct kevent for the C API.\n\
\n\
See the kqueue manpage for more detailed information about the meaning\n\
of the arguments.\n\
\n\
One minor note: while you might hope that udata could store a\n\
reference to a python object, it cannot, because it is impossible to\n\
keep a proper reference count of the object once it's passed into the\n\
kernel. Therefore, I have restricted it to only storing an integer. I\n\
recommend ignoring it and simply using the 'ident' field to key off\n\
of. You could also set up a dictionary on the python side to store a\n\
udata-&gt;object mapping."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<typedef>typedef <type><struct>struct <block>{
<macro><name>PyObject_HEAD</name></macro>
<decl_stmt><decl><type>struct <name>kevent</name></type> <name>e</name></decl>;</decl_stmt>
}</block></struct></type> <name>kqueue_event_Object</name>;</typedef>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>kqueue_event_Type</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kqueue_event_Check</name><parameter_list>(<param><type><name>op</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(PyObject_TypeCheck((op), &amp;kqueue_event_Type))</cpp:value></cpp:define>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>PyObject_HEAD</name>
<name>SOCKET</name></type> <name>kqfd</name></decl>;</decl_stmt>
}</block></struct></type> <name>kqueue_queue_Object</name>;</typedef>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>kqueue_queue_Type</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>kqueue_queue_Check</name><parameter_list>(<param><type><name>op</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(PyObject_TypeCheck((op), &amp;kqueue_queue_Type))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>KQ_OFF</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>offsetof(kqueue_event_Object, x)</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> struct <name>PyMemberDef</name></type> <name><name>kqueue_event_members</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr>"ident"</expr>, <expr><name>T_UINT</name></expr>, <macro><name>KQ_OFF</name><argument_list>(<argument>e.ident</argument>)</argument_list></macro>}</block></expr>,
<expr><block>{<expr>"filter"</expr>, <expr><name>T_SHORT</name></expr>, <macro><name>KQ_OFF</name><argument_list>(<argument>e.filter</argument>)</argument_list></macro>}</block></expr>,
<expr><block>{<expr>"flags"</expr>, <expr><name>T_USHORT</name></expr>, <macro><name>KQ_OFF</name><argument_list>(<argument>e.flags</argument>)</argument_list></macro>}</block></expr>,
<expr><block>{<expr>"fflags"</expr>, <expr><name>T_UINT</name></expr>, <macro><name>KQ_OFF</name><argument_list>(<argument>e.fflags</argument>)</argument_list></macro>}</block></expr>,
<expr><block>{<expr>"data"</expr>, <expr><name>T_INT</name></expr>, <macro><name>KQ_OFF</name><argument_list>(<argument>e.data</argument>)</argument_list></macro>}</block></expr>,
<expr><block>{<expr>"udata"</expr>, <expr><name>T_INT</name></expr>, <macro><name>KQ_OFF</name><argument_list>(<argument>e.udata</argument>)</argument_list></macro>}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>KQ_OFF</name></cpp:undef>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>kqueue_event_repr</name><parameter_list>(<param><decl><type><name>kqueue_event_Object</name> *</type><name>s</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>1024</expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(
<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr>"&lt;select.kevent ident=%lu filter=%d flags=0x%x fflags=0x%x "
"data=0x%lx udata=%p&gt;"</expr></argument>,
<argument><expr><call>(<name>unsigned</name> <name>long</name>)<argument_list>(<argument><expr><name><name>s</name>-&gt;<name>e</name>.<name>ident</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>e</name>.<name>filter</name></name></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>e</name>.<name>flags</name></name></expr></argument>,
<argument><expr><name><name>s</name>-&gt;<name>e</name>.<name>fflags</name></name></expr></argument>, <argument><expr><call>(<name>long</name>)<argument_list>(<argument><expr><name><name>s</name>-&gt;<name>e</name>.<name>data</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>s</name>-&gt;<name>e</name>.<name>udata</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>kqueue_event_init</name><parameter_list>(<param><decl><type><name>kqueue_event_Object</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>pfd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>kwlist</name><index>[]</index></name> <init>= <expr><block>{<expr>"ident"</expr>, <expr>"filter"</expr>, <expr>"flags"</expr>, <expr>"fflags"</expr>,
<expr>"data"</expr>, <expr>"udata"</expr>, <expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>EV_SET</name><argument_list>(<argument><expr>&amp;(<name><name>self</name>-&gt;<name>e</name></name>)</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>EVFILT_READ</name></expr></argument>, <argument><expr><name>EV_ADD</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>, <argument><expr>"O|hhiii:kevent"</expr></argument>, <argument><expr><name>kwlist</name></expr></argument>,
<argument><expr>&amp;<name>pfd</name></expr></argument>, <argument><expr>&amp;(<name><name>self</name>-&gt;<name>e</name>.<name>filter</name></name>)</expr></argument>, <argument><expr>&amp;(<name><name>self</name>-&gt;<name>e</name>.<name>flags</name></name>)</expr></argument>,
<argument><expr>&amp;(<name><name>self</name>-&gt;<name>e</name>.<name>fflags</name></name>)</expr></argument>, <argument><expr>&amp;(<name><name>self</name>-&gt;<name>e</name>.<name>data</name></name>)</expr></argument>, <argument><expr>&amp;(<name><name>self</name>-&gt;<name>e</name>.<name>udata</name></name>)</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>self</name>-&gt;<name>e</name>.<name>ident</name></name> = <call><name>PyObject_AsFileDescriptor</name><argument_list>(<argument><expr><name>pfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>e</name>.<name>ident</name></name> == -1</expr>)</condition><then> <block>{
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>kqueue_event_richcompare</name><parameter_list>(<param><decl><type><name>kqueue_event_Object</name> *</type><name>s</name></decl></param>, <param><decl><type><name>kqueue_event_Object</name> *</type><name>o</name></decl></param>,
<param><decl><type><name>int</name></type> <name>op</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>result</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>kqueue_event_Check</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>op</name> == <name>Py_EQ</name> || <name>op</name> == <name>Py_NE</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name> <init>= <expr><name>op</name> == <name>Py_EQ</name> ? <name>Py_False</name> : <name>Py_True</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"can't compare %.200s to %.200s"</expr></argument>,
<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>, <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>((<name>result</name> = <name><name>s</name>-&gt;<name>e</name>.<name>ident</name></name> - <name><name>o</name>-&gt;<name>e</name>.<name>ident</name></name>) == 0) &amp;&amp;
((<name>result</name> = <name><name>s</name>-&gt;<name>e</name>.<name>filter</name></name> - <name><name>o</name>-&gt;<name>e</name>.<name>filter</name></name>) == 0) &amp;&amp;
((<name>result</name> = <name><name>s</name>-&gt;<name>e</name>.<name>flags</name></name> - <name><name>o</name>-&gt;<name>e</name>.<name>flags</name></name>) == 0) &amp;&amp;
((<name>result</name> = <name><name>s</name>-&gt;<name>e</name>.<name>fflags</name></name> - <name><name>o</name>-&gt;<name>e</name>.<name>fflags</name></name>) == 0) &amp;&amp;
((<name>result</name> = <name><name>s</name>-&gt;<name>e</name>.<name>data</name></name> - <name><name>o</name>-&gt;<name>e</name>.<name>data</name></name>) == 0) &amp;&amp;
((<name>result</name> = <name><name>s</name>-&gt;<name>e</name>.<name>udata</name></name> - <name><name>o</name>-&gt;<name>e</name>.<name>udata</name></name>) == 0)</expr>
)</condition><then> <block>{
<expr_stmt><expr><name>result</name> = 0</expr>;</expr_stmt>
}</block></then></if>
<switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{
<case>case <expr><name>Py_EQ</name></expr>:
<expr_stmt><expr><name>result</name> = (<name>result</name> == 0)</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>Py_NE</name></expr>:
<expr_stmt><expr><name>result</name> = (<name>result</name> != 0)</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>Py_LE</name></expr>:
<expr_stmt><expr><name>result</name> = (<name>result</name> &lt;= 0)</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>Py_GE</name></expr>:
<expr_stmt><expr><name>result</name> = (<name>result</name> &gt;= 0)</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>Py_LT</name></expr>:
<expr_stmt><expr><name>result</name> = (<name>result</name> &lt; 0)</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>Py_GT</name></expr>:
<expr_stmt><expr><name>result</name> = (<name>result</name> &gt; 0)</expr>;</expr_stmt>
<break>break;</break>
</case>}</block></switch>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>kqueue_event_Type</name> <init>= <expr><block>{
<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
"select.kevent"</expr>,
<expr><sizeof>sizeof<argument_list>(<argument><expr><name>kqueue_event_Object</name></expr></argument>)</argument_list></sizeof></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>(<name>reprfunc</name>)<name>kqueue_event_repr</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>Py_TPFLAGS_DEFAULT</name></expr>,
<expr><name>kqueue_event_doc</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>(<name>richcmpfunc</name>)<name>kqueue_event_richcompare</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>kqueue_event_members</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>(<name>initproc</name>)<name>kqueue_event_init</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>kqueue_queue_err_closed</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"I/O operation on closed kqueue fd"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>kqueue_queue_internal_close</name><parameter_list>(<param><decl><type><name>kqueue_queue_Object</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>save_errno</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>kqfd</name></name> &gt;= 0</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>kqfd</name> <init>= <expr><name><name>self</name>-&gt;<name>kqfd</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>self</name>-&gt;<name>kqfd</name></name> = -1</expr>;</expr_stmt>
<macro><name>Py_BEGIN_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><call><name>close</name><argument_list>(<argument><expr><name>kqfd</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>save_errno</name> = <name>errno</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>Py_END_ALLOW_THREADS</name></expr></expr_stmt>
}</block></then></if>
<return>return <expr><name>save_errno</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>newKqueue_Object</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>SOCKET</name></type> <name>fd</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>kqueue_queue_Object</name> *</type><name>self</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>type</name> != <name>NULL</name> &amp;&amp; <name><name>type</name>-&gt;<name>tp_alloc</name></name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>self</name> = (<name>kqueue_queue_Object</name> *) <call><name><name>type</name>-&gt;<name>tp_alloc</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>self</name> == <name>NULL</name></expr>)</condition><then> <block>{
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>fd</name> == -1</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name><name>self</name>-&gt;<name>kqfd</name></name> <init>= <expr><call><name>kqueue</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>Py_END_ALLOW_THREADS</name></expr></expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name><name>self</name>-&gt;<name>kqfd</name></name> = <name>fd</name></expr>;</expr_stmt>
}</block></else></if>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>kqfd</name></name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_SetFromErrno</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr>(<name>PyObject</name> *)<name>self</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>kqueue_queue_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr>(<name>args</name> != <name>NULL</name> &amp;&amp; <call><name>PyObject_Size</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call>) ||
(<name>kwds</name> != <name>NULL</name> &amp;&amp; <call><name>PyObject_Size</name><argument_list>(<argument><expr><name>kwds</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"select.kqueue doesn't accept arguments"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>newKqueue_Object</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>kqueue_queue_dealloc</name><parameter_list>(<param><decl><type><name>kqueue_queue_Object</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>kqueue_queue_internal_close</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call>-&gt;<call><name>tp_free</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>kqueue_queue_close</name><parameter_list>(<param><decl><type><name>kqueue_queue_Object</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>errno</name> = <call><name>kqueue_queue_internal_close</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>errno</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetFromErrno</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>kqueue_queue_close_doc</name></expr></argument>,
<argument><expr>"close() -&gt; None\n\
\n\
Close the kqueue control file descriptor. Further operations on the kqueue\n\
object will raise an exception."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>kqueue_queue_get_closed</name><parameter_list>(<param><decl><type><name>kqueue_queue_Object</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>kqfd</name></name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>Py_RETURN_TRUE</name></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>Py_RETURN_FALSE</name></expr>;</expr_stmt></else></if>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>kqueue_queue_fileno</name><parameter_list>(<param><decl><type><name>kqueue_queue_Object</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>kqfd</name></name> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name>kqueue_queue_err_closed</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>kqfd</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>kqueue_queue_fileno_doc</name></expr></argument>,
<argument><expr>"fileno() -&gt; int\n\
\n\
Return the kqueue control file descriptor."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>kqueue_queue_fromfd</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>cls</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>SOCKET</name></type> <name>fd</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"i:fromfd"</expr></argument>, <argument><expr>&amp;<name>fd</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>newKqueue_Object</name><argument_list>(<argument><expr>(<name>PyTypeObject</name>*)<name>cls</name></expr></argument>, <argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>kqueue_queue_fromfd_doc</name></expr></argument>,
<argument><expr>"fromfd(fd) -&gt; kqueue\n\
\n\
Create a kqueue object from a given control fd."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>kqueue_queue_control</name><parameter_list>(<param><decl><type><name>kqueue_queue_Object</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>nevents</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>gotevents</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nchanges</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>otimeout</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>ch</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>it</name> <init>= <expr><name>NULL</name></expr></init>, *<name>ei</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>kevent</name> *</type><name>evl</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>kevent</name> *</type><name>chl</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>timespec</name></type> <name>timeoutspec</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>timespec</name> *</type><name>ptimeoutspec</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>kqfd</name></name> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name>kqueue_queue_err_closed</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"Oi|O:control"</expr></argument>, <argument><expr>&amp;<name>ch</name></expr></argument>, <argument><expr>&amp;<name>nevents</name></expr></argument>, <argument><expr>&amp;<name>otimeout</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>nevents</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"Length of eventlist must be 0 or positive, got %d"</expr></argument>,
<argument><expr><name>nchanges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>ch</name> != <name>NULL</name> &amp;&amp; <name>ch</name> != <name>Py_None</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>it</name> = <call><name>PyObject_GetIter</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>it</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"changelist is not iterable"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>nchanges</name> = <call><name>PyObject_Size</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>nchanges</name> &lt; 0</expr>)</condition><then> <block>{
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
}</block></then></if>
<if>if <condition>(<expr><name>otimeout</name> == <name>Py_None</name> || <name>otimeout</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>ptimeoutspec</name> = <name>NULL</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><call><name>PyNumber_Check</name><argument_list>(<argument><expr><name>otimeout</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>double</name></type> <name>timeout</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>seconds</name></decl>;</decl_stmt>
<expr_stmt><expr><name>timeout</name> = <call><name>PyFloat_AsDouble</name><argument_list>(<argument><expr><name>otimeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>timeout</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>timeout</name> &gt; (<name>double</name>)<name>LONG_MAX</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
<argument><expr>"timeout period too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>timeout</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"timeout must be positive or None"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>seconds</name> = (<name>long</name>)<name>timeout</name></expr>;</expr_stmt>
<expr_stmt><expr><name>timeout</name> = <name>timeout</name> - (<name>double</name>)<name>seconds</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>timeoutspec</name>.<name>tv_sec</name></name> = <name>seconds</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>timeoutspec</name>.<name>tv_nsec</name></name> = <call>(<name>long</name>)<argument_list>(<argument><expr><name>timeout</name> * 1E9</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ptimeoutspec</name> = &amp;<name>timeoutspec</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"timeout argument must be an number "
"or None, got %.200s"</expr></argument>,
<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>otimeout</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></else></if></else></if>
<if>if <condition>(<expr><name>nchanges</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>chl</name> = <call><name>PyMem_New</name><argument_list>(<argument>struct <expr><name>kevent</name></expr></argument>, <argument><expr><name>nchanges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>chl</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<while>while <condition>(<expr>(<name>ei</name> = <call><name>PyIter_Next</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition> <block>{
<if>if <condition>(<expr>!<call><name>kqueue_event_Check</name><argument_list>(<argument><expr><name>ei</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>ei</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"changelist must be an iterable of "
"select.kevent objects"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>error</name>;</goto>
}</block></then> <else>else <block>{
<expr_stmt><expr><name><name>chl</name><index>[<expr><name>i</name></expr>]</index></name> = ((<name>kqueue_event_Object</name> *)<name>ei</name>)-&gt;<name>e</name></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>ei</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></while>
}</block></then></if>
<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>nevents</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>evl</name> = <call><name>PyMem_New</name><argument_list>(<argument>struct <expr><name>kevent</name></expr></argument>, <argument><expr><name>nevents</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>evl</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
}</block></then></if>
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>gotevents</name> <init>= <expr><call><name>kevent</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>kqfd</name></name></expr></argument>, <argument><expr><name>chl</name></expr></argument>, <argument><expr><name>nchanges</name></expr></argument>,
<argument><expr><name>evl</name></expr></argument>, <argument><expr><name>nevents</name></expr></argument>, <argument><expr><name>ptimeoutspec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>gotevents</name> == -1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetFromErrno</name><argument_list>(<argument><expr><name>PyExc_OSError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>error</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>result</name> = <call><name>PyList_New</name><argument_list>(<argument><expr><name>gotevents</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then> <block>{
<goto>goto <name>error</name>;</goto>
}</block></then></if>
<for>for (<init><expr><name>i</name>=0</expr>;</init> <condition><expr><name>i</name> &lt; <name>gotevents</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>kqueue_event_Object</name> *</type><name>ch</name></decl>;</decl_stmt>
<expr_stmt><expr><name>ch</name> = <call><name>PyObject_New</name><argument_list>(<argument><expr><name>kqueue_event_Object</name></expr></argument>, <argument><expr>&amp;<name>kqueue_event_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ch</name> == <name>NULL</name></expr>)</condition><then> <block>{
<goto>goto <name>error</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name><name>ch</name>-&gt;<name>e</name></name> = <name><name>evl</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyList_SET_ITEM</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>chl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>evl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
<label><name>error</name>:</label>
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>chl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>evl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>kqueue_queue_control_doc</name></expr></argument>,
<argument><expr>"control(changelist, max_events[, timeout=None]) -&gt; eventlist\n\
\n\
Calls the kernel kevent function.\n\
- changelist must be a list of kevent objects describing the changes\n\
to be made to the kernel's watch list or None.\n\
- max_events lets you specify the maximum number of events that the\n\
kernel will return.\n\
- timeout is the maximum time to wait in seconds, or else None,\n\
to wait forever. timeout accepts floats for smaller timeouts, too."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>kqueue_queue_methods</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{
<expr>"fromfd"</expr>, <expr>(<name>PyCFunction</name>)<name>kqueue_queue_fromfd</name></expr>,
<expr><name>METH_VARARGS</name> | <name>METH_CLASS</name></expr>, <expr><name>kqueue_queue_fromfd_doc</name></expr>
}</block></expr>,
<expr><block>{
<expr>"close"</expr>, <expr>(<name>PyCFunction</name>)<name>kqueue_queue_close</name></expr>, <expr><name>METH_NOARGS</name></expr>,
<expr><name>kqueue_queue_close_doc</name></expr>
}</block></expr>,
<expr><block>{
<expr>"fileno"</expr>, <expr>(<name>PyCFunction</name>)<name>kqueue_queue_fileno</name></expr>, <expr><name>METH_NOARGS</name></expr>,
<expr><name>kqueue_queue_fileno_doc</name></expr>
}</block></expr>,
<expr><block>{
<expr>"control"</expr>, <expr>(<name>PyCFunction</name>)<name>kqueue_queue_control</name></expr>,
<expr><name>METH_VARARGS</name></expr> , <expr><name>kqueue_queue_control_doc</name></expr>
}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>,
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyGetSetDef</name></type> <name><name>kqueue_queue_getsetlist</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{
<expr>"closed"</expr>, <expr>(<name>getter</name>)<name>kqueue_queue_get_closed</name></expr>, <expr><name>NULL</name></expr>,
<expr>"True if the kqueue handler is closed"</expr>
}</block></expr>,
<expr><block>{<expr>0</expr>}</block></expr>,
}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>kqueue_queue_doc</name></expr></argument>,
<argument><expr>"Kqueue syscall wrapper.\n\
\n\
For example, to start watching a socket for input:\n\
&gt;&gt;&gt; kq = kqueue()\n\
&gt;&gt;&gt; sock = socket()\n\
&gt;&gt;&gt; sock.connect((host, port))\n\
&gt;&gt;&gt; kq.control([kevent(sock, KQ_FILTER_WRITE, KQ_EV_ADD)], 0)\n\
\n\
To wait one second for it to become writeable:\n\
&gt;&gt;&gt; kq.control(None, 1, 1000)\n\
\n\
To stop listening:\n\
&gt;&gt;&gt; kq.control([kevent(sock, KQ_FILTER_WRITE, KQ_EV_DELETE)], 0)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>kqueue_queue_Type</name> <init>= <expr><block>{
<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
"select.kqueue"</expr>,
<expr><sizeof>sizeof<argument_list>(<argument><expr><name>kqueue_queue_Object</name></expr></argument>)</argument_list></sizeof></expr>,
<expr>0</expr>,
<expr>(<name>destructor</name>)<name>kqueue_queue_dealloc</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>Py_TPFLAGS_DEFAULT</name></expr>,
<expr><name>kqueue_queue_doc</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>kqueue_queue_methods</name></expr>,
<expr>0</expr>,
<expr><name>kqueue_queue_getsetlist</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>kqueue_queue_new</name></expr>,
<expr>0</expr>,
}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>select_doc</name></expr></argument>,
<argument><expr>"select(rlist, wlist, xlist[, timeout]) -&gt; (rlist, wlist, xlist)\n\
\n\
Wait until one or more file descriptors are ready for some kind of I/O.\n\
The first three arguments are sequences of file descriptors to be waited for:\n\
rlist -- wait until ready for reading\n\
wlist -- wait until ready for writing\n\
xlist -- wait for an ``exceptional condition''\n\
If only one kind of condition is required, pass [] for the other lists.\n\
A file descriptor is either a socket or file object, or a small integer\n\
gotten from a fileno() method call on one of those.\n\
\n\
The optional 4th argument specifies a timeout in seconds; it may be\n\
a floating point number to specify fractions of seconds. If it is absent\n\
or None, the call will never time out.\n\
\n\
The return value is a tuple of three lists corresponding to the first three\n\
arguments; each contains the subset of the corresponding file descriptors\n\
that are ready.\n\
\n\
*** IMPORTANT NOTICE ***\n\
On Windows and OpenVMS, only sockets are supported; on Unix, all file\n\
descriptors can be used."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>select_methods</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr>"select"</expr>, <expr><name>select_select</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>select_doc</name></expr>}</block></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_POLL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"poll"</expr>, <expr><name>select_poll</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>poll_doc</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr><block>{<expr>0</expr>, <expr>0</expr>}</block></expr>,
}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>module_doc</name></expr></argument>,
<argument><expr>"This module supports asynchronous I/O on multiple file descriptors.\n\
\n\
*** IMPORTANT NOTICE ***\n\
On Windows and OpenVMS, only sockets are supported; on Unix, all file descriptors."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><name>PyMODINIT_FUNC</name></type>
<name>initselect</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name></decl>;</decl_stmt>
<expr_stmt><expr><name>m</name> = <call><name>Py_InitModule3</name><argument_list>(<argument><expr>"select"</expr></argument>, <argument><expr><name>select_methods</name></expr></argument>, <argument><expr><name>module_doc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>m</name> == <name>NULL</name></expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><name>SelectError</name> = <call><name>PyErr_NewException</name><argument_list>(<argument><expr>"select.error"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>SelectError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"error"</expr></argument>, <argument><expr><name>SelectError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_POLL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>select_have_broken_poll</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PyObject_DelAttrString</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"poll"</expr></argument>)</argument_list></call> == -1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></then> <else>else <block>{
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr>&amp;<name>poll_Type</name></expr></argument>)</argument_list></call> = &amp;<name>PyType_Type</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"POLLIN"</expr></argument>, <argument><expr><name>POLLIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"POLLPRI"</expr></argument>, <argument><expr><name>POLLPRI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"POLLOUT"</expr></argument>, <argument><expr><name>POLLOUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"POLLERR"</expr></argument>, <argument><expr><name>POLLERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"POLLHUP"</expr></argument>, <argument><expr><name>POLLHUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"POLLNVAL"</expr></argument>, <argument><expr><name>POLLNVAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>POLLRDNORM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"POLLRDNORM"</expr></argument>, <argument><expr><name>POLLRDNORM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>POLLRDBAND</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"POLLRDBAND"</expr></argument>, <argument><expr><name>POLLRDBAND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>POLLWRNORM</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"POLLWRNORM"</expr></argument>, <argument><expr><name>POLLWRNORM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>POLLWRBAND</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"POLLWRBAND"</expr></argument>, <argument><expr><name>POLLWRBAND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>POLLMSG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"POLLMSG"</expr></argument>, <argument><expr><name>POLLMSG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_EPOLL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr>&amp;<name>pyEpoll_Type</name></expr></argument>)</argument_list></call> = &amp;<name>PyType_Type</name></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyType_Ready</name><argument_list>(<argument><expr>&amp;<name>pyEpoll_Type</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>&amp;<name>pyEpoll_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"epoll"</expr></argument>, <argument><expr>(<name>PyObject</name> *) &amp;<name>pyEpoll_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"EPOLLIN"</expr></argument>, <argument><expr><name>EPOLLIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"EPOLLOUT"</expr></argument>, <argument><expr><name>EPOLLOUT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"EPOLLPRI"</expr></argument>, <argument><expr><name>EPOLLPRI</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"EPOLLERR"</expr></argument>, <argument><expr><name>EPOLLERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"EPOLLHUP"</expr></argument>, <argument><expr><name>EPOLLHUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"EPOLLET"</expr></argument>, <argument><expr><name>EPOLLET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EPOLLONESHOT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"EPOLLONESHOT"</expr></argument>, <argument><expr><name>EPOLLONESHOT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"EPOLLRDNORM"</expr></argument>, <argument><expr><name>EPOLLRDNORM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"EPOLLRDBAND"</expr></argument>, <argument><expr><name>EPOLLRDBAND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"EPOLLWRNORM"</expr></argument>, <argument><expr><name>EPOLLWRNORM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"EPOLLWRBAND"</expr></argument>, <argument><expr><name>EPOLLWRBAND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"EPOLLMSG"</expr></argument>, <argument><expr><name>EPOLLMSG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_KQUEUE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name><name>kqueue_event_Type</name>.<name>tp_new</name></name> = <name>PyType_GenericNew</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr>&amp;<name>kqueue_event_Type</name></expr></argument>)</argument_list></call> = &amp;<name>PyType_Type</name></expr>;</expr_stmt>
<if>if<condition>(<expr><call><name>PyType_Ready</name><argument_list>(<argument><expr>&amp;<name>kqueue_event_Type</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>&amp;<name>kqueue_event_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"kevent"</expr></argument>, <argument><expr>(<name>PyObject</name> *)&amp;<name>kqueue_event_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr>&amp;<name>kqueue_queue_Type</name></expr></argument>)</argument_list></call> = &amp;<name>PyType_Type</name></expr>;</expr_stmt>
<if>if<condition>(<expr><call><name>PyType_Ready</name><argument_list>(<argument><expr>&amp;<name>kqueue_queue_Type</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>&amp;<name>kqueue_queue_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"kqueue"</expr></argument>, <argument><expr>(<name>PyObject</name> *)&amp;<name>kqueue_queue_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"KQ_FILTER_READ"</expr></argument>, <argument><expr><name>EVFILT_READ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"KQ_FILTER_WRITE"</expr></argument>, <argument><expr><name>EVFILT_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"KQ_FILTER_AIO"</expr></argument>, <argument><expr><name>EVFILT_AIO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"KQ_FILTER_VNODE"</expr></argument>, <argument><expr><name>EVFILT_VNODE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"KQ_FILTER_PROC"</expr></argument>, <argument><expr><name>EVFILT_PROC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EVFILT_NETDEV</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"KQ_FILTER_NETDEV"</expr></argument>, <argument><expr><name>EVFILT_NETDEV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"KQ_FILTER_SIGNAL"</expr></argument>, <argument><expr><name>EVFILT_SIGNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"KQ_FILTER_TIMER"</expr></argument>, <argument><expr><name>EVFILT_TIMER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"KQ_EV_ADD"</expr></argument>, <argument><expr><name>EV_ADD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"KQ_EV_DELETE"</expr></argument>, <argument><expr><name>EV_DELETE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"KQ_EV_ENABLE"</expr></argument>, <argument><expr><name>EV_ENABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"KQ_EV_DISABLE"</expr></argument>, <argument><expr><name>EV_DISABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"KQ_EV_ONESHOT"</expr></argument>, <argument><expr><name>EV_ONESHOT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"KQ_EV_CLEAR"</expr></argument>, <argument><expr><name>EV_CLEAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"KQ_EV_SYSFLAGS"</expr></argument>, <argument><expr><name>EV_SYSFLAGS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"KQ_EV_FLAG1"</expr></argument>, <argument><expr><name>EV_FLAG1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"KQ_EV_EOF"</expr></argument>, <argument><expr><name>EV_EOF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"KQ_EV_ERROR"</expr></argument>, <argument><expr><name>EV_ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"KQ_NOTE_LOWAT"</expr></argument>, <argument><expr><name>NOTE_LOWAT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"KQ_NOTE_DELETE"</expr></argument>, <argument><expr><name>NOTE_DELETE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"KQ_NOTE_WRITE"</expr></argument>, <argument><expr><name>NOTE_WRITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"KQ_NOTE_EXTEND"</expr></argument>, <argument><expr><name>NOTE_EXTEND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"KQ_NOTE_ATTRIB"</expr></argument>, <argument><expr><name>NOTE_ATTRIB</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"KQ_NOTE_LINK"</expr></argument>, <argument><expr><name>NOTE_LINK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"KQ_NOTE_RENAME"</expr></argument>, <argument><expr><name>NOTE_RENAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"KQ_NOTE_REVOKE"</expr></argument>, <argument><expr><name>NOTE_REVOKE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"KQ_NOTE_EXIT"</expr></argument>, <argument><expr><name>NOTE_EXIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"KQ_NOTE_FORK"</expr></argument>, <argument><expr><name>NOTE_FORK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"KQ_NOTE_EXEC"</expr></argument>, <argument><expr><name>NOTE_EXEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"KQ_NOTE_PCTRLMASK"</expr></argument>, <argument><expr><name>NOTE_PCTRLMASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"KQ_NOTE_PDATAMASK"</expr></argument>, <argument><expr><name>NOTE_PDATAMASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"KQ_NOTE_TRACK"</expr></argument>, <argument><expr><name>NOTE_TRACK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"KQ_NOTE_CHILD"</expr></argument>, <argument><expr><name>NOTE_CHILD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"KQ_NOTE_TRACKERR"</expr></argument>, <argument><expr><name>NOTE_TRACKERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EVFILT_NETDEV</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"KQ_NOTE_LINKUP"</expr></argument>, <argument><expr><name>NOTE_LINKUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"KQ_NOTE_LINKDOWN"</expr></argument>, <argument><expr><name>NOTE_LINKDOWN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddIntConstant</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"KQ_NOTE_LINKINV"</expr></argument>, <argument><expr><name>NOTE_LINKINV</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></else></if></block></function>
</unit>
