<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="Python/import.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python-ast.h"</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>Yield</name></cpp:undef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pyarena.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pythonrun.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"errcode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"marshal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"code.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"compile.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"eval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"osdefs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"importdl.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FCNTL_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call></expr></cpp:if>
<extern>extern "C" <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<typedef>typedef <type><name>unsigned</name> <name>short</name></type> <name>mode_t</name>;</typedef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><specifier>extern</specifier> <name>time_t</name></type> <name>PyOS_GetLastModificationTime</name><parameter_list>(<param><decl><type><name>char</name> *</type></decl></param>, <param><decl><type><name>FILE</name> *</type></decl></param>)</parameter_list>;</function_decl>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAGIC</name></cpp:macro> <cpp:value>(62161 | ((long)'\r'&lt;&lt;16) | ((long)'\n'&lt;&lt;24))</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <name>long</name></type> <name>pyc_magic</name> <init>= <expr><name>MAGIC</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>extensions</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> struct <name>_inittab</name></type> <name><name>_PyImport_Inittab</name><index>[]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>_inittab</name> *</type><name>PyImport_Inittab</name> <init>= <expr><name>_PyImport_Inittab</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>filedescr</name> *</type> <name>_PyImport_Filetab</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>RISCOS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> struct <name>filedescr</name></type> <name><name>_PyImport_StandardFiletab</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr>"/py"</expr>, <expr>"U"</expr>, <expr><name>PY_SOURCE</name></expr>}</block></expr>,
<expr><block>{<expr>"/pyc"</expr>, <expr>"rb"</expr>, <expr><name>PY_COMPILED</name></expr>}</block></expr>,
<expr><block>{<expr>0</expr>, <expr>0</expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> struct <name>filedescr</name></type> <name><name>_PyImport_StandardFiletab</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr>".py"</expr>, <expr>"U"</expr>, <expr><name>PY_SOURCE</name></expr>}</block></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>".pyw"</expr>, <expr>"U"</expr>, <expr><name>PY_SOURCE</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr><block>{<expr>".pyc"</expr>, <expr>"rb"</expr>, <expr><name>PY_COMPILED</name></expr>}</block></expr>,
<expr><block>{<expr>0</expr>, <expr>0</expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>void</name></type>
<name>_PyImport_Init</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> struct <name>filedescr</name> *</type><name>scan</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>filedescr</name> *</type><name>filetab</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>countD</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>countS</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_DYNAMIC_LOADING</name></expr></argument>)</argument_list></call></expr></cpp:if>
<for>for (<init><expr><name>scan</name> = <name>_PyImport_DynLoadFiletab</name></expr>;</init> <condition><expr><name><name>scan</name>-&gt;<name>suffix</name></name> != <name>NULL</name></expr>;</condition> <incr><expr>++<name>scan</name></expr></incr>)
<expr_stmt><expr>++<name>countD</name></expr>;</expr_stmt></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<for>for (<init><expr><name>scan</name> = <name>_PyImport_StandardFiletab</name></expr>;</init> <condition><expr><name><name>scan</name>-&gt;<name>suffix</name></name> != <name>NULL</name></expr>;</condition> <incr><expr>++<name>scan</name></expr></incr>)
<expr_stmt><expr>++<name>countS</name></expr>;</expr_stmt></for>
<expr_stmt><expr><name>filetab</name> = <call><name>PyMem_NEW</name><argument_list>(<argument>struct <expr><name>filedescr</name></expr></argument>, <argument><expr><name>countD</name> + <name>countS</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>filetab</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"Can't initialize import file table."</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_DYNAMIC_LOADING</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>filetab</name></expr></argument>, <argument><expr><name>_PyImport_DynLoadFiletab</name></expr></argument>,
<argument><expr><name>countD</name> * <sizeof>sizeof<argument_list>(<argument>struct <expr><name>filedescr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>filetab</name> + <name>countD</name></expr></argument>, <argument><expr><name>_PyImport_StandardFiletab</name></expr></argument>,
<argument><expr><name>countS</name> * <sizeof>sizeof<argument_list>(<argument>struct <expr><name>filedescr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>filetab</name><index>[<expr><name>countD</name> + <name>countS</name></expr>]</index></name>.<name>suffix</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>_PyImport_Filetab</name> = <name>filetab</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>Py_OptimizeFlag</name></expr>)</condition><then> <block>{
<for>for (<init>;</init> <condition><expr><name><name>filetab</name>-&gt;<name>suffix</name></name> != <name>NULL</name></expr>;</condition> <incr><expr><name>filetab</name>++</expr></incr>) <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>RISCOS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>filetab</name>-&gt;<name>suffix</name></name></expr></argument>, <argument><expr>".pyc"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
<expr_stmt><expr><name><name>filetab</name>-&gt;<name>suffix</name></name> = ".pyo"</expr>;</expr_stmt></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>filetab</name>-&gt;<name>suffix</name></name></expr></argument>, <argument><expr>"/pyc"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
<expr_stmt><expr><name><name>filetab</name>-&gt;<name>suffix</name></name> = "/pyo"</expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></for>
}</block></then></if>
<if>if <condition>(<expr><name>Py_UnicodeFlag</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>pyc_magic</name> = <name>MAGIC</name> + 1</expr>;</expr_stmt>
}</block></then></if>
}</block></function>
<function><type><name>void</name></type>
<name>_PyImportHooks_Init</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>, *<decl><type ref="prev"/><name>path_hooks</name> <init>= <expr><name>NULL</name></expr></init>, *<name>zimpimport</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>err</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyType_Ready</name><argument_list>(<argument><expr>&amp;<name>PyNullImporter_Type</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<if>if <condition>(<expr><name>Py_VerboseFlag</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"#installing zipimport hook\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>v</name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<expr_stmt><expr><name>err</name> = <call><name>PySys_SetObject</name><argument_list>(<argument><expr>"meta_path"</expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>err</name></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<expr_stmt><expr><name>v</name> = <call><name>PyDict_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<expr_stmt><expr><name>err</name> = <call><name>PySys_SetObject</name><argument_list>(<argument><expr>"path_importer_cache"</expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>err</name></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<expr_stmt><expr><name>path_hooks</name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>path_hooks</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<expr_stmt><expr><name>err</name> = <call><name>PySys_SetObject</name><argument_list>(<argument><expr>"path_hooks"</expr></argument>, <argument><expr><name>path_hooks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>err</name></expr>)</condition><then> <block>{
<label><name>error</name>:</label>
<expr_stmt><expr><call><name>PyErr_Print</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"initializing sys.meta_path, sys.path_hooks, "
"path_importer_cache, or NullImporter failed"</expr></argument>
)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>zimpimport</name> = <call><name>PyImport_ImportModule</name><argument_list>(<argument><expr>"zipimport"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>zimpimport</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>Py_VerboseFlag</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"#can't import zipimport\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>zipimporter</name> <init>= <expr><call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>zimpimport</name></expr></argument>,
<argument><expr>"zipimporter"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>zimpimport</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>zipimporter</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>Py_VerboseFlag</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(
<argument><expr>"#can't import zipimport.zipimporter\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>err</name> = <call><name>PyList_Append</name><argument_list>(<argument><expr><name>path_hooks</name></expr></argument>, <argument><expr><name>zipimporter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>zipimporter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>err</name></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<if>if <condition>(<expr><name>Py_VerboseFlag</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(
<argument><expr>"#installed zipimport hook\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></else></if>
}</block></else></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>path_hooks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><name>void</name></type>
<name>_PyImport_Fini</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>extensions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>extensions</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyMem_DEL</name><argument_list>(<argument><expr><name>_PyImport_Filetab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>_PyImport_Filetab</name> = <name>NULL</name></expr>;</expr_stmt>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WITH_THREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pythread.h"</cpp:file></cpp:include>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyThread_type_lock</name></type> <name>import_lock</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>long</name></type> <name>import_lock_thread</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>import_lock_level</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>lock_import</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>long</name></type> <name>me</name> <init>= <expr><call><name>PyThread_get_thread_ident</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>me</name> == -1</expr>)</condition><then>
<return>return;</return></then></if>
<if>if <condition>(<expr><name>import_lock</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>import_lock</name> = <call><name>PyThread_allocate_lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>import_lock</name> == <name>NULL</name></expr>)</condition><then>
<return>return;</return></then></if>
}</block></then></if>
<if>if <condition>(<expr><name>import_lock_thread</name> == <name>me</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>import_lock_level</name>++</expr>;</expr_stmt>
<return>return;</return>
}</block></then></if>
<if>if <condition>(<expr><name>import_lock_thread</name> != -1 || !<call><name>PyThread_acquire_lock</name><argument_list>(<argument><expr><name>import_lock</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyThreadState</name> *</type><name>tstate</name> <init>= <expr><call><name>PyEval_SaveThread</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PyThread_acquire_lock</name><argument_list>(<argument><expr><name>import_lock</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyEval_RestoreThread</name><argument_list>(<argument><expr><name>tstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>import_lock_thread</name> = <name>me</name></expr>;</expr_stmt>
<expr_stmt><expr><name>import_lock_level</name> = 1</expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>unlock_import</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>long</name></type> <name>me</name> <init>= <expr><call><name>PyThread_get_thread_ident</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>me</name> == -1 || <name>import_lock</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<if>if <condition>(<expr><name>import_lock_thread</name> != <name>me</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><name>import_lock_level</name>--</expr>;</expr_stmt>
<if>if <condition>(<expr><name>import_lock_level</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>import_lock_thread</name> = -1</expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyThread_release_lock</name><argument_list>(<argument><expr><name>import_lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><name>void</name></type>
<name>_PyImport_ReInitLock</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_AIX</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>import_lock</name> != <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><name>import_lock</name> = <call><name>PyThread_allocate_lock</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>lock_import</name><parameter_list>()</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>unlock_import</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>imp_lock_held</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WITH_THREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><name>import_lock_thread</name> != -1</expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>imp_acquire_lock</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WITH_THREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>lock_import</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>imp_release_lock</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WITH_THREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>unlock_import</name><argument_list>()</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_RuntimeError</name></expr></argument>,
<argument><expr>"not holding the import lock"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>imp_modules_reloading_clear</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyInterpreterState</name> *</type><name>interp</name> <init>= <expr><call><name>PyThreadState_Get</name><argument_list>()</argument_list></call>-&gt;<name>interp</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>interp</name>-&gt;<name>modules_reloading</name></name> != <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyDict_Clear</name><argument_list>(<argument><expr><name><name>interp</name>-&gt;<name>modules_reloading</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>
<function><type><name>PyObject</name> *</type>
<name>PyImport_GetModuleDict</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyInterpreterState</name> *</type><name>interp</name> <init>= <expr><call><name>PyThreadState_GET</name><argument_list>()</argument_list></call>-&gt;<name>interp</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>interp</name>-&gt;<name>modules</name></name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"PyImport_GetModuleDict: no module dictionary!"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name><name>interp</name>-&gt;<name>modules</name></name></expr>;</return>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name>*</type> <name><name>sys_deletes</name><index>[]</index></name> <init>= <expr><block>{
<expr>"path"</expr>, <expr>"argv"</expr>, <expr>"ps1"</expr>, <expr>"ps2"</expr>, <expr>"exitfunc"</expr>,
<expr>"exc_type"</expr>, <expr>"exc_value"</expr>, <expr>"exc_traceback"</expr>,
<expr>"last_type"</expr>, <expr>"last_value"</expr>, <expr>"last_traceback"</expr>,
<expr>"path_hooks"</expr>, <expr>"path_importer_cache"</expr>, <expr>"meta_path"</expr>,
<expr>"flags"</expr>, <expr>"float_info"</expr>,
<expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name>*</type> <name><name>sys_files</name><index>[]</index></name> <init>= <expr><block>{
<expr>"stdin"</expr>, <expr>"__stdin__"</expr>,
<expr>"stdout"</expr>, <expr>"__stdout__"</expr>,
<expr>"stderr"</expr>, <expr>"__stderr__"</expr>,
<expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>
<function><type><name>void</name></type>
<name>PyImport_Cleanup</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>pos</name></decl>, <decl><type ref="prev"/><name>ndone</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>key</name></decl>, *<decl><type ref="prev"/><name>value</name></decl>, *<decl><type ref="prev"/><name>dict</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyInterpreterState</name> *</type><name>interp</name> <init>= <expr><call><name>PyThreadState_GET</name><argument_list>()</argument_list></call>-&gt;<name>interp</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>modules</name> <init>= <expr><name><name>interp</name>-&gt;<name>modules</name></name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>modules</name> == <name>NULL</name></expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><name>value</name> = <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>modules</name></expr></argument>, <argument><expr>"__builtin__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>value</name> != <name>NULL</name> &amp;&amp; <call><name>PyModule_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>dict</name> = <call><name>PyModule_GetDict</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>Py_VerboseFlag</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"#clear __builtin__._\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr>"_"</expr></argument>, <argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>value</name> = <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>modules</name></expr></argument>, <argument><expr>"sys"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>value</name> != <name>NULL</name> &amp;&amp; <call><name>PyModule_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name> **</type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
<expr_stmt><expr><name>dict</name> = <call><name>PyModule_GetDict</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>p</name> = <name>sys_deletes</name></expr>;</init> <condition><expr>*<name>p</name> != <name>NULL</name></expr>;</condition> <incr><expr><name>p</name>++</expr></incr>) <block>{
<if>if <condition>(<expr><name>Py_VerboseFlag</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"#clear sys.%s\n"</expr></argument>, <argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr>*<name>p</name></expr></argument>, <argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<for>for (<init><expr><name>p</name> = <name>sys_files</name></expr>;</init> <condition><expr>*<name>p</name> != <name>NULL</name></expr>;</condition> <incr><expr><name>p</name>+=2</expr></incr>) <block>{
<if>if <condition>(<expr><name>Py_VerboseFlag</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"#restore sys.%s\n"</expr></argument>, <argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>v</name> = <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr>*(<name>p</name>+1)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><name>v</name> = <name>Py_None</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr>*<name>p</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
}</block></then></if>
<expr_stmt><expr><name>value</name> = <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>modules</name></expr></argument>, <argument><expr>"__main__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>value</name> != <name>NULL</name> &amp;&amp; <call><name>PyModule_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>Py_VerboseFlag</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"#cleanup __main__\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>_PyModule_Clear</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>modules</name></expr></argument>, <argument><expr>"__main__"</expr></argument>, <argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<do>do <block>{
<expr_stmt><expr><name>ndone</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>pos</name> = 0</expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>PyDict_Next</name><argument_list>(<argument><expr><name>modules</name></expr></argument>, <argument><expr>&amp;<name>pos</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr>&amp;<name>value</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<if>if <condition>(<expr><name><name>value</name>-&gt;<name>ob_refcnt</name></name> != 1</expr>)</condition><then>
<continue>continue;</continue></then></if>
<if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>PyModule_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>name</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>"__builtin__"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
<continue>continue;</continue></then></if>
<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>"sys"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
<continue>continue;</continue></then></if>
<if>if <condition>(<expr><name>Py_VerboseFlag</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(
<argument><expr>"#cleanup[1] %s\n"</expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>_PyModule_Clear</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>modules</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ndone</name>++</expr>;</expr_stmt>
}</block></then></if>
}</block></while>
}</block> while <condition>(<expr><name>ndone</name> &gt; 0</expr>)</condition>;</do>
<expr_stmt><expr><name>pos</name> = 0</expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>PyDict_Next</name><argument_list>(<argument><expr><name>modules</name></expr></argument>, <argument><expr>&amp;<name>pos</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr>&amp;<name>value</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>PyModule_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>name</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>"__builtin__"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
<continue>continue;</continue></then></if>
<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>"sys"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
<continue>continue;</continue></then></if>
<if>if <condition>(<expr><name>Py_VerboseFlag</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"#cleanup[2] %s\n"</expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>_PyModule_Clear</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>modules</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></while>
<expr_stmt><expr><name>value</name> = <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>modules</name></expr></argument>, <argument><expr>"sys"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>value</name> != <name>NULL</name> &amp;&amp; <call><name>PyModule_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>Py_VerboseFlag</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"#cleanup sys\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>_PyModule_Clear</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>modules</name></expr></argument>, <argument><expr>"sys"</expr></argument>, <argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>value</name> = <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>modules</name></expr></argument>, <argument><expr>"__builtin__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>value</name> != <name>NULL</name> &amp;&amp; <call><name>PyModule_Check</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>Py_VerboseFlag</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"#cleanup __builtin__\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>_PyModule_Clear</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>modules</name></expr></argument>, <argument><expr>"__builtin__"</expr></argument>, <argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>PyDict_Clear</name><argument_list>(<argument><expr><name>modules</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>interp</name>-&gt;<name>modules</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>modules</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name><name>interp</name>-&gt;<name>modules_reloading</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><name>long</name></type>
<name>PyImport_GetMagicNumber</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<return>return <expr><name>pyc_magic</name></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type>
<name>_PyImport_FixupExtension</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>char</name> *</type><name>filename</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>modules</name></decl>, *<decl><type ref="prev"/><name>mod</name></decl>, *<decl><type ref="prev"/><name>dict</name></decl>, *<decl><type ref="prev"/><name>copy</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>extensions</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>extensions</name> = <call><name>PyDict_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>extensions</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
}</block></then></if>
<expr_stmt><expr><name>modules</name> = <call><name>PyImport_GetModuleDict</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>mod</name> = <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>modules</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>mod</name> == <name>NULL</name> || !<call><name>PyModule_Check</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
<argument><expr>"_PyImport_FixupExtension: module %.200s not loaded"</expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>dict</name> = <call><name>PyModule_GetDict</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>dict</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>copy</name> = <call><name>PyDict_Copy</name><argument_list>(<argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>copy</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>extensions</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>copy</name></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type>
<name>_PyImport_FindExtension</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>char</name> *</type><name>filename</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>dict</name></decl>, *<decl><type ref="prev"/><name>mod</name></decl>, *<decl><type ref="prev"/><name>mdict</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>extensions</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>dict</name> = <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>extensions</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>dict</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>mod</name> = <call><name>PyImport_AddModule</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>mod</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>mdict</name> = <call><name>PyModule_GetDict</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>mdict</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>PyDict_Update</name><argument_list>(<argument><expr><name>mdict</name></expr></argument>, <argument><expr><name>dict</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>Py_VerboseFlag</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"import %s #previously loaded (%s)\n"</expr></argument>,
<argument><expr><name>name</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>mod</name></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type>
<name>PyImport_AddModule</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>modules</name> <init>= <expr><call><name>PyImport_GetModuleDict</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name></decl>;</decl_stmt>
<if>if <condition>(<expr>(<name>m</name> = <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>modules</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call>) != <name>NULL</name> &amp;&amp;
<call><name>PyModule_Check</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>m</name></expr>;</return></then></if>
<expr_stmt><expr><name>m</name> = <call><name>PyModule_New</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>m</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>modules</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>m</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_RemoveModule</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>modules</name> <init>= <expr><call><name>PyImport_GetModuleDict</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>modules</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> == <name>NULL</name></expr>)</condition><then>
<return>return;</return></then></if>
<if>if <condition>(<expr><call><name>PyDict_DelItemString</name><argument_list>(<argument><expr><name>modules</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"import: deleting existing key in"
"sys.modules failed"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>
<function><type><name>PyObject</name> *</type>
<name>PyImport_ExecCodeModule</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>co</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>PyImport_ExecCodeModuleEx</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>co</name></expr></argument>, <argument><expr>(<name>char</name> *)<name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type>
<name>PyImport_ExecCodeModuleEx</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>co</name></decl></param>, <param><decl><type><name>char</name> *</type><name>pathname</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>modules</name> <init>= <expr><call><name>PyImport_GetModuleDict</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name></decl>, *<decl><type ref="prev"/><name>d</name></decl>, *<decl><type ref="prev"/><name>v</name></decl>;</decl_stmt>
<expr_stmt><expr><name>m</name> = <call><name>PyImport_AddModule</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>m</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>d</name> = <call><name>PyModule_GetDict</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"__builtins__"</expr></argument>)</argument_list></call> == <name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"__builtins__"</expr></argument>,
<argument><expr><call><name>PyEval_GetBuiltins</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
}</block></then></if>
<expr_stmt><expr><name>v</name> = <name>NULL</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>pathname</name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>v</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
}</block></then></if>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>v</name> = ((<name>PyCodeObject</name> *)<name>co</name>)-&gt;<name>co_filename</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"__file__"</expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>v</name> = <call><name>PyEval_EvalCode</name><argument_list>(<argument><expr>(<name>PyCodeObject</name> *)<name>co</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>(<name>m</name> = <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>modules</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ImportError</name></expr></argument>,
<argument><expr>"Loaded module %.200s not found in sys.modules"</expr></argument>,
<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>m</name></expr>;</return>
<label><name>error</name>:</label>
<expr_stmt><expr><call><name>_RemoveModule</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>char</name> *</type>
<name>make_compiled_pathname</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>pathname</name></decl></param>, <param><decl><type><name>char</name> *</type><name>buf</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>buflen</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>len</name>+2 &gt; <name>buflen</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>len</name> &gt;= 4 &amp;&amp; <call><name>strcmp</name><argument_list>(<argument><expr>&amp;<name><name>pathname</name><index>[<expr><name>len</name>-4</expr>]</index></name></expr></argument>, <argument><expr>".pyw"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
<expr_stmt><expr>--<name>len</name></expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><name>len</name></expr>]</index></name> = <name>Py_OptimizeFlag</name> ? 'o' : 'c'</expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><name>len</name>+1</expr>]</index></name> = '\0'</expr>;</expr_stmt>
<return>return <expr><name>buf</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>FILE</name> *</type>
<name>check_compiled_module</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>pathname</name></decl></param>, <param><decl><type><name>time_t</name></type> <name>mtime</name></decl></param>, <param><decl><type><name>char</name> *</type><name>cpathname</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>FILE</name> *</type><name>fp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>magic</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>pyc_mtime</name></decl>;</decl_stmt>
<expr_stmt><expr><name>fp</name> = <call><name>fopen</name><argument_list>(<argument><expr><name>cpathname</name></expr></argument>, <argument><expr>"rb"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>fp</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>magic</name> = <call><name>PyMarshal_ReadLongFromFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>magic</name> != <name>pyc_magic</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>Py_VerboseFlag</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"#%s has bad magic\n"</expr></argument>, <argument><expr><name>cpathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>pyc_mtime</name> = <call><name>PyMarshal_ReadLongFromFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>pyc_mtime</name> != <name>mtime</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>Py_VerboseFlag</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"#%s has bad mtime\n"</expr></argument>, <argument><expr><name>cpathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>Py_VerboseFlag</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"#%s matches %s\n"</expr></argument>, <argument><expr><name>cpathname</name></expr></argument>, <argument><expr><name>pathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>fp</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyCodeObject</name> *</type>
<name>read_compiled_module</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>cpathname</name></decl></param>, <param><decl><type><name>FILE</name> *</type><name>fp</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>co</name></decl>;</decl_stmt>
<expr_stmt><expr><name>co</name> = <call><name>PyMarshal_ReadLastObjectFromFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>co</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>PyCode_Check</name><argument_list>(<argument><expr><name>co</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ImportError</name></expr></argument>,
<argument><expr>"Non-code object in %.200s"</expr></argument>, <argument><expr><name>cpathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>co</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr>(<name>PyCodeObject</name> *)<name>co</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>load_compiled_module</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>char</name> *</type><name>cpathname</name></decl></param>, <param><decl><type><name>FILE</name> *</type><name>fp</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>long</name></type> <name>magic</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyCodeObject</name> *</type><name>co</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name></decl>;</decl_stmt>
<expr_stmt><expr><name>magic</name> = <call><name>PyMarshal_ReadLongFromFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>magic</name> != <name>pyc_magic</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ImportError</name></expr></argument>,
<argument><expr>"Bad magic number in %.200s"</expr></argument>, <argument><expr><name>cpathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr>(<name>void</name>) <call><name>PyMarshal_ReadLongFromFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>co</name> = <call><name>read_compiled_module</name><argument_list>(<argument><expr><name>cpathname</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>co</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>Py_VerboseFlag</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"import %s #precompiled from %s\n"</expr></argument>,
<argument><expr><name>name</name></expr></argument>, <argument><expr><name>cpathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>m</name> = <call><name>PyImport_ExecCodeModuleEx</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>co</name></expr></argument>, <argument><expr><name>cpathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>co</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>m</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyCodeObject</name> *</type>
<name>parse_source_module</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>pathname</name></decl></param>, <param><decl><type><name>FILE</name> *</type><name>fp</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyCodeObject</name> *</type><name>co</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>mod_ty</name></type> <name>mod</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyCompilerFlags</name></type> <name>flags</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyArena</name> *</type><name>arena</name> <init>= <expr><call><name>PyArena_New</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>arena</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>flags</name>.<name>cf_flags</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>mod</name> = <call><name>PyParser_ASTFromFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>Py_file_input</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>flags</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>mod</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>co</name> = <call><name>PyAST_Compile</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>PyArena_Free</name><argument_list>(<argument><expr><name>arena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>co</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>FILE</name> *</type>
<name>open_exclusive</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>filename</name></decl></param>, <param><decl><type><name>mode_t</name></type> <name>mode</name></decl></param>)</parameter_list> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>O_EXCL</name></expr></argument>)</argument_list></call>&amp;&amp;<call><name>defined</name><argument_list>(<argument><expr><name>O_CREAT</name></expr></argument>)</argument_list></call>&amp;&amp;<call><name>defined</name><argument_list>(<argument><expr><name>O_WRONLY</name></expr></argument>)</argument_list></call>&amp;&amp;<call><name>defined</name><argument_list>(<argument><expr><name>O_TRUNC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
<expr_stmt><expr>(<name>void</name>) <call><name>unlink</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>fd</name> = <call><name>open</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>O_EXCL</name>|<name>O_CREAT</name>|<name>O_WRONLY</name>|<name>O_TRUNC</name>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>O_BINARY</name></expr></argument>)</argument_list></call></expr></cpp:if>
|<name>O_BINARY</name></expr></argument>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__VMS</name></expr></argument>)</argument_list></call></expr></cpp:if>
, <argument><expr><name>mode</name></expr></argument>, <argument><expr>"ctxt=bin"</expr></argument>, <argument><expr>"shr=nil"</expr></argument>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
, <argument><expr><name>mode</name></expr></argument>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>fd</name> &lt; 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>fdopen</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr>"wb"</expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<return>return <expr><call><name>fopen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr>"wb"</expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>write_compiled_module</name><parameter_list>(<param><decl><type><name>PyCodeObject</name> *</type><name>co</name></decl></param>, <param><decl><type><name>char</name> *</type><name>cpathname</name></decl></param>, <param><decl><type>struct <name>stat</name> *</type><name>srcstat</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>FILE</name> *</type><name>fp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>time_t</name></type> <name>mtime</name> <init>= <expr><name><name>srcstat</name>-&gt;<name>st_mtime</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>mode_t</name></type> <name>mode</name> <init>= <expr><name><name>srcstat</name>-&gt;<name>st_mode</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>fp</name> = <call><name>open_exclusive</name><argument_list>(<argument><expr><name>cpathname</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>fp</name> == <name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>Py_VerboseFlag</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(
<argument><expr>"#can't create %s\n"</expr></argument>, <argument><expr><name>cpathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return;</return>
}</block></then></if>
<expr_stmt><expr><call><name>PyMarshal_WriteLongToFile</name><argument_list>(<argument><expr><name>pyc_magic</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>Py_MARSHAL_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyMarshal_WriteLongToFile</name><argument_list>(<argument><expr>0L</expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>Py_MARSHAL_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyMarshal_WriteObjectToFile</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>co</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>Py_MARSHAL_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>fflush</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call> != 0 || <call><name>ferror</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>Py_VerboseFlag</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"#can't write %s\n"</expr></argument>, <argument><expr><name>cpathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>(<name>void</name>) <call><name>unlink</name><argument_list>(<argument><expr><name>cpathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
}</block></then></if>
<expr_stmt><expr><call><name>fseek</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>4L</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>mtime</name> &lt; <name>LONG_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyMarshal_WriteLongToFile</name><argument_list>(<argument><expr>(<name>long</name>)<name>mtime</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>Py_MARSHAL_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>Py_VerboseFlag</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"#wrote %s\n"</expr></argument>, <argument><expr><name>cpathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>load_source_module</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>char</name> *</type><name>pathname</name></decl></param>, <param><decl><type><name>FILE</name> *</type><name>fp</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>stat</name></type> <name>st</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> *</type><name>fpc</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>MAXPATHLEN</name>+1</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>cpathname</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyCodeObject</name> *</type><name>co</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>fstat</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>st</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_RuntimeError</name></expr></argument>,
<argument><expr>"unable to get file status from '%s'"</expr></argument>,
<argument><expr><name>pathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_TIME_T</name> &gt; 4</expr></cpp:if>
<if>if <condition>(<expr><name><name>st</name>.<name>st_mtime</name></name> &gt;&gt; 32</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
<argument><expr>"modification time overflows a 4 byte field"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>cpathname</name> = <call><name>make_compiled_pathname</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>,
<argument><expr>(<name>size_t</name>)<name>MAXPATHLEN</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>cpathname</name> != <name>NULL</name> &amp;&amp;
(<name>fpc</name> = <call><name>check_compiled_module</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr><name><name>st</name>.<name>st_mtime</name></name></expr></argument>, <argument><expr><name>cpathname</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
<expr_stmt><expr><name>co</name> = <call><name>read_compiled_module</name><argument_list>(<argument><expr><name>cpathname</name></expr></argument>, <argument><expr><name>fpc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fpc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>co</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>Py_VerboseFlag</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"import %s #precompiled from %s\n"</expr></argument>,
<argument><expr><name>name</name></expr></argument>, <argument><expr><name>cpathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>pathname</name> = <name>cpathname</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>co</name> = <call><name>parse_source_module</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>co</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>Py_VerboseFlag</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"import %s #from %s\n"</expr></argument>,
<argument><expr><name>name</name></expr></argument>, <argument><expr><name>pathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>cpathname</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>ro</name> <init>= <expr><call><name>PySys_GetObject</name><argument_list>(<argument><expr>"dont_write_bytecode"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>ro</name> == <name>NULL</name> || !<call><name>PyObject_IsTrue</name><argument_list>(<argument><expr><name>ro</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><call><name>write_compiled_module</name><argument_list>(<argument><expr><name>co</name></expr></argument>, <argument><expr><name>cpathname</name></expr></argument>, <argument><expr>&amp;<name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></then></if>
}</block></else></if>
<expr_stmt><expr><name>m</name> = <call><name>PyImport_ExecCodeModuleEx</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>co</name></expr></argument>, <argument><expr><name>pathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>co</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>m</name></expr>;</return>
}</block></function>
<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>load_module</name><parameter_list>(<param><decl><type><name>char</name> *</type></decl></param>, <param><decl><type><name>FILE</name> *</type></decl></param>, <param><decl><type><name>char</name> *</type></decl></param>, <param><decl><type><name>int</name></type></decl></param>, <param><decl><type><name>PyObject</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> struct <name>filedescr</name> *</type><name>find_module</name><parameter_list>(<param><decl><type><name>char</name> *</type></decl></param>, <param><decl><type><name>char</name> *</type></decl></param>, <param><decl><type><name>PyObject</name> *</type></decl></param>,
<param><decl><type><name>char</name> *</type></decl></param>, <param><decl><type><name>size_t</name></type></decl></param>, <param><decl><type><name>FILE</name> **</type></decl></param>, <param><decl><type><name>PyObject</name> **</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> struct <name>_frozen</name> *</type><name>find_frozen</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>name</name></decl></param>)</parameter_list>;</function_decl>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>load_package</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>char</name> *</type><name>pathname</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name></decl>, *<decl><type ref="prev"/><name>d</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>file</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>MAXPATHLEN</name>+1</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> *</type><name>fp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>filedescr</name> *</type><name>fdp</name></decl>;</decl_stmt>
<expr_stmt><expr><name>m</name> = <call><name>PyImport_AddModule</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>m</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>Py_VerboseFlag</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"import %s #directory %s\n"</expr></argument>,
<argument><expr><name>name</name></expr></argument>, <argument><expr><name>pathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>d</name> = <call><name>PyModule_GetDict</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>file</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>file</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<expr_stmt><expr><name>path</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"[O]"</expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>path</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<expr_stmt><expr><name>err</name> = <call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"__file__"</expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>err</name> == 0</expr>)</condition><then>
<expr_stmt><expr><name>err</name> = <call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"__path__"</expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>err</name> != 0</expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<expr_stmt><expr><name><name>buf</name><index>[<expr>0</expr>]</index></name> = '\0'</expr>;</expr_stmt>
<expr_stmt><expr><name>fdp</name> = <call><name>find_module</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>"__init__"</expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>&amp;<name>fp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>fdp</name> == <name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_ImportError</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else
<expr_stmt><expr><name>m</name> = <name>NULL</name></expr>;</expr_stmt></else></if>
<goto>goto <name>cleanup</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>m</name> = <call><name>load_module</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>fdp</name>-&gt;<name>type</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>fp</name> != <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<goto>goto <name>cleanup</name>;</goto>
<label><name>error</name>:</label>
<expr_stmt><expr><name>m</name> = <name>NULL</name></expr>;</expr_stmt>
<label><name>cleanup</name>:</label>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>m</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>is_builtin</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>name</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name><name>PyImport_Inittab</name><index>[<expr><name>i</name></expr>]</index></name>.<name>name</name> != <name>NULL</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>PyImport_Inittab</name><index>[<expr><name>i</name></expr>]</index></name>.<name>name</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>PyImport_Inittab</name><index>[<expr><name>i</name></expr>]</index></name>.<name>initfunc</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then>
<else>else
<return>return <expr>1</expr>;</return></else></if>
}</block></then></if>
}</block></for>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>get_path_importer</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>path_importer_cache</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>path_hooks</name></decl></param>,
<param><decl><type><name>PyObject</name> *</type><name>p</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>importer</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>nhooks</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyList_Check</name><argument_list>(<argument><expr><name>path_hooks</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyDict_Check</name><argument_list>(<argument><expr><name>path_importer_cache</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>nhooks</name> = <call><name>PyList_Size</name><argument_list>(<argument><expr><name>path_hooks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>nhooks</name> &lt; 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>importer</name> = <call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name>path_importer_cache</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>importer</name> != <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>importer</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>path_importer_cache</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>Py_None</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name>nhooks</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>hook</name> <init>= <expr><call><name>PyList_GetItem</name><argument_list>(<argument><expr><name>path_hooks</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>hook</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>importer</name> = <call><name>PyObject_CallFunctionObjArgs</name><argument_list>(<argument><expr><name>hook</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>importer</name> != <name>NULL</name></expr>)</condition><then>
<break>break;</break></then></if>
<if>if <condition>(<expr>!<call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_ImportError</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></for>
<if>if <condition>(<expr><name>importer</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>importer</name> = <call><name>PyObject_CallFunctionObjArgs</name><argument_list>(
<argument><expr>(<name>PyObject</name> *)&amp;<name>PyNullImporter_Type</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>
)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>importer</name> == <name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_ImportError</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></then></if>
}</block></then></if>
}</block></then></if>
<if>if <condition>(<expr><name>importer</name> != <name>NULL</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>err</name> <init>= <expr><call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>path_importer_cache</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>importer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>importer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>err</name> != 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
}</block></then></if>
<return>return <expr><name>importer</name></expr>;</return>
}</block></function>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro>
<macro><name>PyImport_GetImporter</name><argument_list>(<argument>PyObject *path</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>importer</name><init>=<expr><name>NULL</name></expr></init>, *<name>path_importer_cache</name><init>=<expr><name>NULL</name></expr></init>, *<name>path_hooks</name><init>=<expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>(<name>path_importer_cache</name> = <call><name>PySys_GetObject</name><argument_list>(<argument><expr>"path_importer_cache"</expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
<if>if <condition>(<expr>(<name>path_hooks</name> = <call><name>PySys_GetObject</name><argument_list>(<argument><expr>"path_hooks"</expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
<expr_stmt><expr><name>importer</name> = <call><name>get_path_importer</name><argument_list>(<argument><expr><name>path_importer_cache</name></expr></argument>,
<argument><expr><name>path_hooks</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
<expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name>importer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>importer</name></expr>;</return>
}</block>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_COREDLL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function_decl><type><specifier>extern</specifier> <name>FILE</name> *</type><name>PyWin_FindRegisteredModule</name><parameter_list>(<param><decl><type><specifier>const</specifier></type> <name>char</name> *</decl></param>, <param><decl><type>struct</type> <name>filedescr</name> **</decl></param>,
<param><decl><type><name>char</name> *</type></decl></param>, <param><decl><type><name>Py_ssize_t</name></type></decl></param>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>case_ok</name><parameter_list>(<param><decl><type><name>char</name> *</type></decl></param>, <param><decl><type><name>Py_ssize_t</name></type></decl></param>, <param><decl><type><name>Py_ssize_t</name></type></decl></param>, <param><decl><type><name>char</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>find_init_module</name><parameter_list>(<param><decl><type><name>char</name> *</type></decl></param>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><specifier>static</specifier> struct <name>filedescr</name></type> <name>importhookdescr</name> <init>= <expr><block>{<expr>""</expr>, <expr>""</expr>, <expr><name>IMP_HOOK</name></expr>}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> struct <name>filedescr</name> *</type>
<name>find_module</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>fullname</name></decl></param>, <param><decl><type><name>char</name> *</type><name>subname</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>path</name></decl></param>, <param><decl><type><name>char</name> *</type><name>buf</name></decl></param>,
<param><decl><type><name>size_t</name></type> <name>buflen</name></decl></param>, <param><decl><type><name>FILE</name> **</type><name>p_fp</name></decl></param>, <param><decl><type><name>PyObject</name> **</type><name>p_loader</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>npath</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>, <decl><type ref="prev"/><name>namelen</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>filedescr</name> *</type><name>fdp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>filemode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> *</type><name>fp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>path_hooks</name></decl>, *<decl><type ref="prev"/><name>path_importer_cache</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>RISCOS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type>struct <name>stat</name></type> <name>statbuf</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><specifier>static</specifier> struct <name>filedescr</name></type> <name>fd_frozen</name> <init>= <expr><block>{<expr>""</expr>, <expr>""</expr>, <expr><name>PY_FROZEN</name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> struct <name>filedescr</name></type> <name>fd_builtin</name> <init>= <expr><block>{<expr>""</expr>, <expr>""</expr>, <expr><name>C_BUILTIN</name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> struct <name>filedescr</name></type> <name>fd_package</name> <init>= <expr><block>{<expr>""</expr>, <expr>""</expr>, <expr><name>PKG_DIRECTORY</name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>name</name><index>[<expr><name>MAXPATHLEN</name>+1</expr>]</index></name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>size_t</name></type> <name>saved_len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>saved_namelen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>saved_buf</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><name>p_loader</name> != <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr>*<name>p_loader</name> = <name>NULL</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>subname</name></expr></argument>)</argument_list></call> &gt; <name>MAXPATHLEN</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
<argument><expr>"module name is too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>subname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>p_loader</name> != <name>NULL</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>meta_path</name></decl>;</decl_stmt>
<expr_stmt><expr><name>meta_path</name> = <call><name>PySys_GetObject</name><argument_list>(<argument><expr>"meta_path"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>meta_path</name> == <name>NULL</name> || !<call><name>PyList_Check</name><argument_list>(<argument><expr><name>meta_path</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ImportError</name></expr></argument>,
<argument><expr>"sys.meta_path must be a list of "
"import hooks"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>meta_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>npath</name> = <call><name>PyList_Size</name><argument_list>(<argument><expr><name>meta_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>npath</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>loader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>hook</name> <init>= <expr><call><name>PyList_GetItem</name><argument_list>(<argument><expr><name>meta_path</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>loader</name> = <call><name>PyObject_CallMethod</name><argument_list>(<argument><expr><name>hook</name></expr></argument>, <argument><expr>"find_module"</expr></argument>,
<argument><expr>"sO"</expr></argument>, <argument><expr><name>fullname</name></expr></argument>,
<argument><expr><name>path</name> != <name>NULL</name> ?
<name>path</name> : <name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>loader</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>meta_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>loader</name> != <name>Py_None</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>p_loader</name> = <name>loader</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>meta_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>&amp;<name>importhookdescr</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>loader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>meta_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>path</name> != <name>NULL</name> &amp;&amp; <call><name>PyString_Check</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PyString_Size</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call> + 1 + <call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call> &gt;= (<name>size_t</name>)<name>buflen</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ImportError</name></expr></argument>,
<argument><expr>"full frozen module name too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>PyString_AsString</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>"."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>find_frozen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>&amp;<name>fd_frozen</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ImportError</name></expr></argument>,
<argument><expr>"No frozen submodule named %.200s"</expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>path</name> == <name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>is_builtin</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>&amp;<name>fd_builtin</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>(<call><name>find_frozen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>&amp;<name>fd_frozen</name></expr>;</return>
}</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_COREDLL</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>fp</name> = <call><name>PyWin_FindRegisteredModule</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>&amp;<name>fdp</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>fp</name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>p_fp</name> = <name>fp</name></expr>;</expr_stmt>
<return>return <expr><name>fdp</name></expr>;</return>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>path</name> = <call><name>PySys_GetObject</name><argument_list>(<argument><expr>"path"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>path</name> == <name>NULL</name> || !<call><name>PyList_Check</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ImportError</name></expr></argument>,
<argument><expr>"sys.path must be a list of directory names"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>path_hooks</name> = <call><name>PySys_GetObject</name><argument_list>(<argument><expr>"path_hooks"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>path_hooks</name> == <name>NULL</name> || !<call><name>PyList_Check</name><argument_list>(<argument><expr><name>path_hooks</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ImportError</name></expr></argument>,
<argument><expr>"sys.path_hooks must be a list of "
"import hooks"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>path_importer_cache</name> = <call><name>PySys_GetObject</name><argument_list>(<argument><expr>"path_importer_cache"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>path_importer_cache</name> == <name>NULL</name> ||
!<call><name>PyDict_Check</name><argument_list>(<argument><expr><name>path_importer_cache</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ImportError</name></expr></argument>,
<argument><expr>"sys.path_importer_cache must be a dict"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>npath</name> = <call><name>PyList_Size</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>namelen</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>npath</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>copy</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name> <init>= <expr><call><name>PyList_GetItem</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>v</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_USING_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>copy</name> = <call><name>PyUnicode_Encode</name><argument_list>(<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>copy</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>v</name> = <name>copy</name></expr>;</expr_stmt>
}</block></then> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr>!<call><name>PyString_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<continue>continue;</continue></then></if></else></if>
<expr_stmt><expr><name>len</name> = <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>len</name> + 2 + <name>namelen</name> + <name>MAXSUFFIXSIZE</name> &gt;= <name>buflen</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
}</block></then></if>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call> != <name>len</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
}</block></then></if>
<if>if <condition>(<expr><name>p_loader</name> != <name>NULL</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>importer</name></decl>;</decl_stmt>
<expr_stmt><expr><name>importer</name> = <call><name>get_path_importer</name><argument_list>(<argument><expr><name>path_importer_cache</name></expr></argument>,
<argument><expr><name>path_hooks</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>importer</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>importer</name> != <name>Py_None</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>loader</name></decl>;</decl_stmt>
<expr_stmt><expr><name>loader</name> = <call><name>PyObject_CallMethod</name><argument_list>(<argument><expr><name>importer</name></expr></argument>,
<argument><expr>"find_module"</expr></argument>,
<argument><expr>"s"</expr></argument>, <argument><expr><name>fullname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>loader</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>loader</name> != <name>Py_None</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>p_loader</name> = <name>loader</name></expr>;</expr_stmt>
<return>return <expr>&amp;<name>importhookdescr</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>loader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
}</block></then></if>
}</block></then></if>
<if>if <condition>(<expr><name>len</name> &gt; 0 &amp;&amp; <name><name>buf</name><index>[<expr><name>len</name>-1</expr>]</index></name> != <name>SEP</name>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ALTSEP</name></expr></argument>)</argument_list></call></expr></cpp:if>
&amp;&amp; <name><name>buf</name><index>[<expr><name>len</name>-1</expr>]</index></name> != <name>ALTSEP</name></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
)</condition><then>
<expr_stmt><expr><name><name>buf</name><index>[<expr><name>len</name>++</expr>]</index></name> = <name>SEP</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf</name>+<name>len</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> += <name>namelen</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STAT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>&amp;<name>statbuf</name></expr></argument>)</argument_list></call> == 0 &amp;&amp;
<call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>statbuf</name>.<name>st_mode</name></name></expr></argument>)</argument_list></call> &amp;&amp;
<call><name>case_ok</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>namelen</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>find_init_module</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>&amp;<name>fd_package</name></expr>;</return>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>char</name></type> <name><name>warnstr</name><index>[<expr><name>MAXPATHLEN</name>+80</expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>warnstr</name></expr></argument>, <argument><expr>"Not importing directory "
"'%.*s': missing __init__.py"</expr></argument>,
<argument><expr><name>MAXPATHLEN</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyErr_Warn</name><argument_list>(<argument><expr><name>PyExc_ImportWarning</name></expr></argument>,
<argument><expr><name>warnstr</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
}</block></else></if>
}</block></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>RISCOS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>isdir</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call> &amp;&amp;
<call><name>case_ok</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>namelen</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>find_init_module</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>&amp;<name>fd_package</name></expr>;</return>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>char</name></type> <name><name>warnstr</name><index>[<expr><name>MAXPATHLEN</name>+80</expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>warnstr</name></expr></argument>, <argument><expr>"Not importing directory "
"'%.*s': missing __init__.py"</expr></argument>,
<argument><expr><name>MAXPATHLEN</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyErr_Warn</name><argument_list>(<argument><expr><name>PyExc_ImportWarning</name></expr></argument>,
<argument><expr><name>warnstr</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
}</block></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>saved_buf</name> = <call><name>strdup</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>saved_len</name> = <name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><name>saved_namelen</name> = <name>namelen</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<for>for (<init><expr><name>fdp</name> = <name>_PyImport_Filetab</name></expr>;</init> <condition><expr><name><name>fdp</name>-&gt;<name>suffix</name></name> != <name>NULL</name></expr>;</condition> <incr><expr><name>fdp</name>++</expr></incr>) <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_DYNAMIC_LOADING</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>subname</name></expr></argument>)</argument_list></call> &gt; 8</expr>)</condition><then> <block>{
<decl_stmt><decl><type><specifier>const</specifier> struct <name>filedescr</name> *</type><name>scan</name></decl>;</decl_stmt>
<expr_stmt><expr><name>scan</name> = <name>_PyImport_DynLoadFiletab</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name><name>scan</name>-&gt;<name>suffix</name></name> != <name>NULL</name></expr>)</condition> <block>{
<if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name><name>scan</name>-&gt;<name>suffix</name></name></expr></argument>, <argument><expr><name><name>fdp</name>-&gt;<name>suffix</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
<break>break;</break></then>
<else>else
<expr_stmt><expr><name>scan</name>++</expr>;</expr_stmt></else></if>
}</block></while>
<if>if <condition>(<expr><name><name>scan</name>-&gt;<name>suffix</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>namelen</name> = 8</expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> -= <call><name>strlen</name><argument_list>(<argument><expr><name>subname</name></expr></argument>)</argument_list></call> - <name>namelen</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><name>len</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf</name>+<name>len</name></expr></argument>, <argument><expr><name><name>fdp</name>-&gt;<name>suffix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>Py_VerboseFlag</name> &gt; 1</expr>)</condition><then>
<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"#trying %s\n"</expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>filemode</name> = <name><name>fdp</name>-&gt;<name>mode</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>filemode</name><index>[<expr>0</expr>]</index></name> == 'U'</expr>)</condition><then>
<expr_stmt><expr><name>filemode</name> = "r" <name>PY_STDIOTEXTMODE</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>fp</name> = <call><name>fopen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>filemode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>fp</name> != <name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>case_ok</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>namelen</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<break>break;</break></then>
<else>else <block>{
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>fp</name> = <name>NULL</name></expr>;</expr_stmt>
}</block></else></if>
}</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>saved_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> = <name>saved_len</name></expr>;</expr_stmt>
<expr_stmt><expr><name>namelen</name> = <name>saved_namelen</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></for>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>saved_buf</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>saved_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>saved_buf</name> = <name>NULL</name></expr>;</expr_stmt>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>fp</name> != <name>NULL</name></expr>)</condition><then>
<break>break;</break></then></if>
}</block></then></if>
<if>if <condition>(<expr><name>fp</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ImportError</name></expr></argument>,
<argument><expr>"No module named %.200s"</expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr>*<name>p_fp</name> = <name>fp</name></expr>;</expr_stmt>
<return>return <expr><name>fdp</name></expr>;</return>
}</block></for>
<function><type>struct <name>filedescr</name> *</type>
<name>_PyImport_FindModule</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>path</name></decl></param>, <param><decl><type><name>char</name> *</type><name>buf</name></decl></param>,
<param><decl><type><name>size_t</name></type> <name>buflen</name></decl></param>, <param><decl><type><name>FILE</name> **</type><name>p_fp</name></decl></param>, <param><decl><type><name>PyObject</name> **</type><name>p_loader</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>find_module</name><argument_list>(<argument><expr>(<name>char</name> *) <name>name</name></expr></argument>, <argument><expr>(<name>char</name> *) <name>name</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>, <argument><expr><name>p_fp</name></expr></argument>, <argument><expr><name>p_loader</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>_PyImport_IsScript</name><argument_list>(<argument>struct filedescr * fd</argument>)</argument_list></macro> <block>{
<return>return <expr><name><name>fd</name>-&gt;<name>type</name></name> == <name>PY_SOURCE</name> || <name><name>fd</name>-&gt;<name>type</name></name> == <name>PY_COMPILED</name></expr>;</return>
}</block>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;windows.h&gt;</cpp:file></cpp:include>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DJGPP</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dir.h&gt;</cpp:file></cpp:include>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr>(<call><name>defined</name><argument_list>(<argument><expr><name>__MACH__</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call>) &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_DIRENT_H</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dirent.h&gt;</cpp:file></cpp:include>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INCL_DOS</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INCL_DOSERRORS</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INCL_NOPMAPI</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;os2.h&gt;</cpp:file></cpp:include>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>RISCOS</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"oslib/osfscontrol.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>case_ok</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>buf</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>namelen</name></decl></param>, <param><decl><type><name>char</name> *</type><name>name</name></decl></param>)</parameter_list> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>WIN32_FIND_DATA</name></type> <name>data</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>HANDLE</name></type> <name>h</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>Py_GETENV</name><argument_list>(<argument><expr>"PYTHONCASEOK"</expr></argument>)</argument_list></call> != <name>NULL</name></expr>)</condition><then>
<return>return <expr>1</expr>;</return></then></if>
<expr_stmt><expr><name>h</name> = <call><name>FindFirstFile</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>&amp;<name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>h</name> == <name>INVALID_HANDLE_VALUE</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_NameError</name></expr></argument>,
<argument><expr>"Can't find file for module %.100s\n(filename %.300s)"</expr></argument>,
<argument><expr><name>name</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>FindClose</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>data</name>.<name>cFileName</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>namelen</name></expr></argument>)</argument_list></call> == 0</expr>;</return>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DJGPP</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<decl_stmt><decl><type>struct <name>ffblk</name></type> <name>ffblk</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>done</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>Py_GETENV</name><argument_list>(<argument><expr>"PYTHONCASEOK"</expr></argument>)</argument_list></call> != <name>NULL</name></expr>)</condition><then>
<return>return <expr>1</expr>;</return></then></if>
<expr_stmt><expr><name>done</name> = <call><name>findfirst</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>&amp;<name>ffblk</name></expr></argument>, <argument><expr><name>FA_ARCH</name>|<name>FA_RDONLY</name>|<name>FA_HIDDEN</name>|<name>FA_DIREC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>done</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_NameError</name></expr></argument>,
<argument><expr>"Can't find file for module %.100s\n(filename %.300s)"</expr></argument>,
<argument><expr><name>name</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<return>return <expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>ffblk</name>.<name>ff_name</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>namelen</name></expr></argument>)</argument_list></call> == 0</expr>;</return>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr>(<call><name>defined</name><argument_list>(<argument><expr><name>__MACH__</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>__APPLE__</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call>) &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_DIRENT_H</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<decl_stmt><decl><type><name>DIR</name> *</type><name>dirp</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>dirent</name> *</type><name>dp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>dirname</name><index>[<expr><name>MAXPATHLEN</name> + 1</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>dirlen</name> <init>= <expr><name>len</name> - <name>namelen</name> - 1</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>Py_GETENV</name><argument_list>(<argument><expr>"PYTHONCASEOK"</expr></argument>)</argument_list></call> != <name>NULL</name></expr>)</condition><then>
<return>return <expr>1</expr>;</return></then></if>
<if>if <condition>(<expr><name>dirlen</name> &lt;= 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>dirname</name><index>[<expr>0</expr>]</index></name> = '.'</expr>;</expr_stmt>
<expr_stmt><expr><name><name>dirname</name><index>[<expr>1</expr>]</index></name> = '\0'</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>dirlen</name> &lt;= <name>MAXPATHLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dirname</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>dirlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>dirname</name><index>[<expr><name>dirlen</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><name>dirp</name> = <call><name>opendir</name><argument_list>(<argument><expr><name>dirname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>dirp</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>nameWithExt</name> <init>= <expr><name>buf</name> + <name>len</name> - <name>namelen</name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr>(<name>dp</name> = <call><name>readdir</name><argument_list>(<argument><expr><name>dirp</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>thislen</name> <init>=
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_DIRENT_HAVE_D_NAMELEN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><name><name>dp</name>-&gt;<name>d_namlen</name></name></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>dp</name>-&gt;<name>d_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><name>thislen</name> &gt;= <name>namelen</name> &amp;&amp;
<call><name>strcmp</name><argument_list>(<argument><expr><name><name>dp</name>-&gt;<name>d_name</name></name></expr></argument>, <argument><expr><name>nameWithExt</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr>(<name>void</name>)<call><name>closedir</name><argument_list>(<argument><expr><name>dirp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></then></if>
}</block></while>
<expr_stmt><expr>(<name>void</name>)<call><name>closedir</name><argument_list>(<argument><expr><name>dirp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr>0</expr> ;</return>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>RISCOS</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<decl_stmt><decl><type><name>char</name></type> <name><name>canon</name><index>[<expr><name>MAXPATHLEN</name>+1</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf2</name><index>[<expr><name>MAXPATHLEN</name>+2</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>nameWithExt</name> <init>= <expr><name>buf</name>+<name>len</name>-<name>namelen</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>canonlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>os_error</name> *</type><name>e</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>Py_GETENV</name><argument_list>(<argument><expr>"PYTHONCASEOK"</expr></argument>)</argument_list></call> != <name>NULL</name></expr>)</condition><then>
<return>return <expr>1</expr>;</return></then></if>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf2</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>buf2</name></expr></argument>, <argument><expr>"*"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>e</name> = <call><name>xosfscontrol_canonicalise_path</name><argument_list>(<argument><expr><name>buf2</name></expr></argument>,<argument><expr><name>canon</name></expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>,<argument><expr><name>MAXPATHLEN</name>+1</expr></argument>,<argument><expr>&amp;<name>canonlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>canonlen</name> = <name>MAXPATHLEN</name>+1-<name>canonlen</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>e</name> || <name>canonlen</name>&lt;=0 || <name>canonlen</name>&gt;(<name>MAXPATHLEN</name>+1)</expr> )</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>nameWithExt</name></expr></argument>, <argument><expr><name>canon</name>+<name>canonlen</name>-<call><name>strlen</name><argument_list>(<argument><expr><name>nameWithExt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>==0</expr>)</condition><then>
<return>return <expr>1</expr>;</return></then></if>
<return>return <expr>0</expr>;</return>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<decl_stmt><decl><type><name>HDIR</name></type> <name>hdir</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>ULONG</name></type> <name>srchcnt</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILEFINDBUF3</name></type> <name>ffbuf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>APIRET</name></type> <name>rc</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>Py_GETENV</name><argument_list>(<argument><expr>"PYTHONCASEOK"</expr></argument>)</argument_list></call> != <name>NULL</name></expr>)</condition><then>
<return>return <expr>1</expr>;</return></then></if>
<expr_stmt><expr><name>rc</name> = <call><name>DosFindFirst</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,
<argument><expr>&amp;<name>hdir</name></expr></argument>,
<argument><expr><name>FILE_READONLY</name> | <name>FILE_HIDDEN</name> | <name>FILE_SYSTEM</name> | <name>FILE_DIRECTORY</name></expr></argument>,
<argument><expr>&amp;<name>ffbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ffbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr>&amp;<name>srchcnt</name></expr></argument>,
<argument><expr><name>FIL_STANDARD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rc</name> != <name>NO_ERROR</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<return>return <expr><call><name>strncmp</name><argument_list>(<argument><expr><name><name>ffbuf</name>.<name>achName</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>namelen</name></expr></argument>)</argument_list></call> == 0</expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<return>return <expr>1</expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STAT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>find_init_module</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>buf</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>save_len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name> <init>= <expr><name>save_len</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>pname</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>stat</name></type> <name>statbuf</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>save_len</name> + 13 &gt;= <name>MAXPATHLEN</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><name><name>buf</name><index>[<expr><name>i</name>++</expr>]</index></name> = <name>SEP</name></expr>;</expr_stmt>
<expr_stmt><expr><name>pname</name> = <name>buf</name> + <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>pname</name></expr></argument>, <argument><expr>"__init__.py"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>&amp;<name>statbuf</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>case_ok</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,
<argument><expr><name>save_len</name> + 9</expr></argument>,
<argument><expr>8</expr></argument>,
<argument><expr><name>pname</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>buf</name><index>[<expr><name>save_len</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></then></if>
}</block></then></if>
<expr_stmt><expr><name>i</name> += <call><name>strlen</name><argument_list>(<argument><expr><name>pname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf</name>+<name>i</name></expr></argument>, <argument><expr><name>Py_OptimizeFlag</name> ? "o" : "c"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>&amp;<name>statbuf</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>case_ok</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,
<argument><expr><name>save_len</name> + 9</expr></argument>,
<argument><expr>8</expr></argument>,
<argument><expr><name>pname</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>buf</name><index>[<expr><name>save_len</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></then></if>
}</block></then></if>
<expr_stmt><expr><name><name>buf</name><index>[<expr><name>save_len</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>RISCOS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>find_init_module</name><parameter_list>(<param><decl><type><name>buf</name></type></decl></param>)</parameter_list>
<decl_stmt><decl><type><name>char</name> *</type><name>buf</name></decl>;</decl_stmt>
<block>{
<decl_stmt><decl><type><name>int</name></type> <name>save_len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>save_len</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>save_len</name> + 13 &gt;= <name>MAXPATHLEN</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><name><name>buf</name><index>[<expr><name>i</name>++</expr>]</index></name> = <name>SEP</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf</name>+<name>i</name></expr></argument>, <argument><expr>"__init__/py"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>isfile</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>buf</name><index>[<expr><name>save_len</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>Py_OptimizeFlag</name></expr>)</condition><then>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf</name>+<name>i</name></expr></argument>, <argument><expr>"o"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf</name>+<name>i</name></expr></argument>, <argument><expr>"c"</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<if>if <condition>(<expr><call><name>isfile</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>buf</name><index>[<expr><name>save_len</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>buf</name><index>[<expr><name>save_len</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>init_builtin</name><parameter_list>(<param><decl><type><name>char</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>load_module</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>FILE</name> *</type><name>fp</name></decl></param>, <param><decl><type><name>char</name> *</type><name>buf</name></decl></param>, <param><decl><type><name>int</name></type> <name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>loader</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>modules</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{
<case>case <expr><name>PY_SOURCE</name></expr>:
</case><case>case <expr><name>PY_COMPILED</name></expr>:
<if>if <condition>(<expr><name>fp</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"file object required for import (type code %d)"</expr></argument>,
<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
</case>}</block></switch>
<switch>switch <condition>(<expr><name>type</name></expr>)</condition> <block>{
<case>case <expr><name>PY_SOURCE</name></expr>:
<expr_stmt><expr><name>m</name> = <call><name>load_source_module</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>PY_COMPILED</name></expr>:
<expr_stmt><expr><name>m</name> = <call><name>load_compiled_module</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_DYNAMIC_LOADING</name></expr></argument>)</argument_list></call></expr></cpp:if>
</case><case>case <expr><name>C_EXTENSION</name></expr>:
<expr_stmt><expr><name>m</name> = <call><name>_PyImport_LoadDynamicModule</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</case><case>case <expr><name>PKG_DIRECTORY</name></expr>:
<expr_stmt><expr><name>m</name> = <call><name>load_package</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>C_BUILTIN</name></expr>:
</case><case>case <expr><name>PY_FROZEN</name></expr>:
<if>if <condition>(<expr><name>buf</name> != <name>NULL</name> &amp;&amp; <name><name>buf</name><index>[<expr>0</expr>]</index></name> != '\0'</expr>)</condition><then>
<expr_stmt><expr><name>name</name> = <name>buf</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>type</name> == <name>C_BUILTIN</name></expr>)</condition><then>
<expr_stmt><expr><name>err</name> = <call><name>init_builtin</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>err</name> = <call><name>PyImport_ImportFrozenModule</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<if>if <condition>(<expr><name>err</name> &lt; 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>err</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ImportError</name></expr></argument>,
<argument><expr>"Purported %s module %.200s not found"</expr></argument>,
<argument><expr><name>type</name> == <name>C_BUILTIN</name> ?
"builtin" : "frozen"</expr></argument>,
<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>modules</name> = <call><name>PyImport_GetModuleDict</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>m</name> = <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>modules</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>m</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(
<argument><expr><name>PyExc_ImportError</name></expr></argument>,
<argument><expr>"%s module %.200s not properly initialized"</expr></argument>,
<argument><expr><name>type</name> == <name>C_BUILTIN</name> ?
"builtin" : "frozen"</expr></argument>,
<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>IMP_HOOK</name></expr>: <block>{
<if>if <condition>(<expr><name>loader</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ImportError</name></expr></argument>,
<argument><expr>"import hook without loader"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>m</name> = <call><name>PyObject_CallMethod</name><argument_list>(<argument><expr><name>loader</name></expr></argument>, <argument><expr>"load_module"</expr></argument>, <argument><expr>"s"</expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
}</block>
</case><default>default:
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ImportError</name></expr></argument>,
<argument><expr>"Don't know how to import %.200s (type code %d)"</expr></argument>,
<argument><expr><name>name</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>m</name> = <name>NULL</name></expr>;</expr_stmt>
</default>}</block></switch>
<return>return <expr><name>m</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>init_builtin</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>name</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>_inittab</name> *</type><name>p</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>_PyImport_FindExtension</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> != <name>NULL</name></expr>)</condition><then>
<return>return <expr>1</expr>;</return></then></if>
<for>for (<init><expr><name>p</name> = <name>PyImport_Inittab</name></expr>;</init> <condition><expr><name><name>p</name>-&gt;<name>name</name></name> != <name>NULL</name></expr>;</condition> <incr><expr><name>p</name>++</expr></incr>) <block>{
<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>p</name>-&gt;<name>name</name></name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>p</name>-&gt;<name>initfunc</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ImportError</name></expr></argument>,
<argument><expr>"Cannot re-init internal module %.200s"</expr></argument>,
<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>Py_VerboseFlag</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"import %s #builtin\n"</expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call>(*<name><name>p</name>-&gt;<name>initfunc</name></name>)<argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr><call><name>_PyImport_FixupExtension</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<return>return <expr>1</expr>;</return>
}</block></then></if>
}</block></for>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> struct <name>_frozen</name> *</type>
<name>find_frozen</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>name</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>_frozen</name> *</type><name>p</name></decl>;</decl_stmt>
<for>for (<init><expr><name>p</name> = <name>PyImport_FrozenModules</name></expr>;</init> <condition>;</condition> <incr><expr><name>p</name>++</expr></incr>) <block>{
<if>if <condition>(<expr><name><name>p</name>-&gt;<name>name</name></name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>p</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
<break>break;</break></then></if>
}</block></for>
<return>return <expr><name>p</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>get_frozen_object</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>name</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>_frozen</name> *</type><name>p</name> <init>= <expr><call><name>find_frozen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>size</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>p</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ImportError</name></expr></argument>,
<argument><expr>"No such frozen object named %.200s"</expr></argument>,
<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name><name>p</name>-&gt;<name>code</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ImportError</name></expr></argument>,
<argument><expr>"Excluded frozen object named %.200s"</expr></argument>,
<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>size</name> = <name><name>p</name>-&gt;<name>size</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>size</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>size</name> = -<name>size</name></expr>;</expr_stmt></then></if>
<return>return <expr><call><name>PyMarshal_ReadObjectFromString</name><argument_list>(<argument><expr>(<name>char</name> *)<name><name>p</name>-&gt;<name>code</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>int</name></type>
<name>PyImport_ImportFrozenModule</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>name</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>_frozen</name> *</type><name>p</name> <init>= <expr><call><name>find_frozen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>co</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ispackage</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>size</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>p</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<if>if <condition>(<expr><name><name>p</name>-&gt;<name>code</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ImportError</name></expr></argument>,
<argument><expr>"Excluded frozen object named %.200s"</expr></argument>,
<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>size</name> = <name><name>p</name>-&gt;<name>size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>ispackage</name> = (<name>size</name> &lt; 0)</expr>;</expr_stmt>
<if>if <condition>(<expr><name>ispackage</name></expr>)</condition><then>
<expr_stmt><expr><name>size</name> = -<name>size</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>Py_VerboseFlag</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"import %s #frozen%s\n"</expr></argument>,
<argument><expr><name>name</name></expr></argument>, <argument><expr><name>ispackage</name> ? " package" : ""</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>co</name> = <call><name>PyMarshal_ReadObjectFromString</name><argument_list>(<argument><expr>(<name>char</name> *)<name><name>p</name>-&gt;<name>code</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>co</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>PyCode_Check</name><argument_list>(<argument><expr><name>co</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"frozen object %.200s is not a code object"</expr></argument>,
<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>err_return</name>;</goto>
}</block></then></if>
<if>if <condition>(<expr><name>ispackage</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>d</name></decl>, *<decl><type ref="prev"/><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>
<expr_stmt><expr><name>m</name> = <call><name>PyImport_AddModule</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>m</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>err_return</name>;</goto></then></if>
<expr_stmt><expr><name>d</name> = <call><name>PyModule_GetDict</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>s</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>err_return</name>;</goto></then></if>
<expr_stmt><expr><name>err</name> = <call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"__path__"</expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>err</name> != 0</expr>)</condition><then>
<goto>goto <name>err_return</name>;</goto></then></if>
}</block></then></if>
<expr_stmt><expr><name>m</name> = <call><name>PyImport_ExecCodeModuleEx</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>co</name></expr></argument>, <argument><expr>"&lt;frozen&gt;"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>m</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>err_return</name>;</goto></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>co</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
<label><name>err_return</name>:</label>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>co</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type>
<name>PyImport_ImportModule</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>pname</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
<expr_stmt><expr><name>pname</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>pname</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>result</name> = <call><name>PyImport_Import</name><argument_list>(<argument><expr><name>pname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>pname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type>
<name>PyImport_ImportModuleNoBlock</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>modules</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>me</name></decl>;</decl_stmt>
<expr_stmt><expr><name>modules</name> = <call><name>PyImport_GetModuleDict</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>modules</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>result</name> = <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>modules</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WITH_THREAD</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>me</name> = <call><name>PyThread_get_thread_ident</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>import_lock_thread</name> == -1 || <name>import_lock_thread</name> == <name>me</name></expr>)</condition><then> <block>{
<return>return <expr><call><name>PyImport_ImportModule</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ImportError</name></expr></argument>,
<argument><expr>"Failed to import %.200s because the import lock"
"is held by another thread."</expr></argument>,
<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></else></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<return>return <expr><call><name>PyImport_ImportModule</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>
<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>get_parent</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>globals</name></decl></param>, <param><decl><type><name>char</name> *</type><name>buf</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name> *</type><name>p_buflen</name></decl></param>, <param><decl><type><name>int</name></type> <name>level</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>load_next</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>mod</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>altmod</name></decl></param>,
<param><decl><type><name>char</name> **</type><name>p_name</name></decl></param>, <param><decl><type><name>char</name> *</type><name>buf</name></decl></param>, <param><decl><type><name>Py_ssize_t</name> *</type><name>p_buflen</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>mark_miss</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>name</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>ensure_fromlist</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>mod</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>fromlist</name></decl></param>,
<param><decl><type><name>char</name> *</type><name>buf</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>buflen</name></decl></param>, <param><decl><type><name>int</name></type> <name>recursive</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type> <name>import_submodule</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>mod</name></decl></param>, <param><decl><type><name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>char</name> *</type><name>fullname</name></decl></param>)</parameter_list>;</function_decl>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>import_module_level</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>globals</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>locals</name></decl></param>,
<param><decl><type><name>PyObject</name> *</type><name>fromlist</name></decl></param>, <param><decl><type><name>int</name></type> <name>level</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>MAXPATHLEN</name>+1</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>buflen</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>parent</name></decl>, *<decl><type ref="prev"/><name>head</name></decl>, *<decl><type ref="prev"/><name>next</name></decl>, *<decl><type ref="prev"/><name>tail</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>'/'</expr></argument>)</argument_list></call> != <name>NULL</name>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
|| <call><name>strchr</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>'\\'</expr></argument>)</argument_list></call> != <name>NULL</name></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ImportError</name></expr></argument>,
<argument><expr>"Import by filename is not supported."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>parent</name> = <call><name>get_parent</name><argument_list>(<argument><expr><name>globals</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr>&amp;<name>buflen</name></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>parent</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>head</name> = <call><name>load_next</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>Py_None</name></expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr>&amp;<name>buflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>head</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>tail</name> = <name>head</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>name</name></expr>)</condition> <block>{
<expr_stmt><expr><name>next</name> = <call><name>load_next</name><argument_list>(<argument><expr><name>tail</name></expr></argument>, <argument><expr><name>tail</name></expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr>&amp;<name>buflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>next</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>tail</name> = <name>next</name></expr>;</expr_stmt>
}</block></while>
<if>if <condition>(<expr><name>tail</name> == <name>Py_None</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"Empty module name"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>fromlist</name> != <name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>fromlist</name> == <name>Py_None</name> || !<call><name>PyObject_IsTrue</name><argument_list>(<argument><expr><name>fromlist</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>fromlist</name> = <name>NULL</name></expr>;</expr_stmt></then></if>
}</block></then></if>
<if>if <condition>(<expr><name>fromlist</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>head</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>ensure_fromlist</name><argument_list>(<argument><expr><name>tail</name></expr></argument>, <argument><expr><name>fromlist</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><name>tail</name></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type>
<name>PyImport_ImportModuleLevel</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>globals</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>locals</name></decl></param>,
<param><decl><type><name>PyObject</name> *</type><name>fromlist</name></decl></param>, <param><decl><type><name>int</name></type> <name>level</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>lock_import</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> = <call><name>import_module_level</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>globals</name></expr></argument>, <argument><expr><name>locals</name></expr></argument>, <argument><expr><name>fromlist</name></expr></argument>, <argument><expr><name>level</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>unlock_import</name><argument_list>()</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_RuntimeError</name></expr></argument>,
<argument><expr>"not holding the import lock"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>get_parent</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>globals</name></decl></param>, <param><decl><type><name>char</name> *</type><name>buf</name></decl></param>, <param><decl><type><name>Py_ssize_t</name> *</type><name>p_buflen</name></decl></param>, <param><decl><type><name>int</name></type> <name>level</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>namestr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>pathstr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>pkgstr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>pkgname</name></decl>, *<decl><type ref="prev"/><name>modname</name></decl>, *<decl><type ref="prev"/><name>modpath</name></decl>, *<decl><type ref="prev"/><name>modules</name></decl>, *<decl><type ref="prev"/><name>parent</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>orig_level</name> <init>= <expr><name>level</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>globals</name> == <name>NULL</name> || !<call><name>PyDict_Check</name><argument_list>(<argument><expr><name>globals</name></expr></argument>)</argument_list></call> || !<name>level</name></expr>)</condition><then>
<return>return <expr><name>Py_None</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>namestr</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>namestr</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__name__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>namestr</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
}</block></then></if>
<if>if <condition>(<expr><name>pathstr</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>pathstr</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__path__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>pathstr</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
}</block></then></if>
<if>if <condition>(<expr><name>pkgstr</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>pkgstr</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__package__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>pkgstr</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
}</block></then></if>
<expr_stmt><expr>*<name>buf</name> = '\0'</expr>;</expr_stmt>
<expr_stmt><expr>*<name>p_buflen</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>pkgname</name> = <call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name>globals</name></expr></argument>, <argument><expr><name>pkgstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>(<name>pkgname</name> != <name>NULL</name>) &amp;&amp; (<name>pkgname</name> != <name>Py_None</name>)</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyString_Check</name><argument_list>(<argument><expr><name>pkgname</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"__package__ set to non-string"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>len</name> = <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>pkgname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>len</name> == 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>level</name> &gt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"Attempted relative import in non-package"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>len</name> &gt; <name>MAXPATHLEN</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"Package name too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>pkgname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>modname</name> = <call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name>globals</name></expr></argument>, <argument><expr><name>namestr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>modname</name> == <name>NULL</name> || !<call><name>PyString_Check</name><argument_list>(<argument><expr><name>modname</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>Py_None</name></expr>;</return></then></if>
<expr_stmt><expr><name>modpath</name> = <call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name>globals</name></expr></argument>, <argument><expr><name>pathstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>modpath</name> != <name>NULL</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name> <init>= <expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>modname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>error</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>len</name> &gt; <name>MAXPATHLEN</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"Module name too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>modname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>error</name> = <call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>globals</name></expr></argument>, <argument><expr><name>pkgstr</name></expr></argument>, <argument><expr><name>modname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>error</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"Could not set __package__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>start</name> <init>= <expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>modname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>lastdot</name> <init>= <expr><call><name>strrchr</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr>'.'</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>error</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>lastdot</name> == <name>NULL</name> &amp;&amp; <name>level</name> &gt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"Attempted relative import in non-package"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>lastdot</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>error</name> = <call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>globals</name></expr></argument>, <argument><expr><name>pkgstr</name></expr></argument>, <argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>error</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"Could not set __package__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>len</name> = <name>lastdot</name> - <name>start</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>len</name> &gt;= <name>MAXPATHLEN</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"Module name too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><name>len</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
<expr_stmt><expr><name>pkgname</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>pkgname</name> == <name>NULL</name></expr>)</condition><then> <block>{
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>error</name> = <call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>globals</name></expr></argument>, <argument><expr><name>pkgstr</name></expr></argument>, <argument><expr><name>pkgname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>pkgname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>error</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"Could not set __package__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
}</block></else></if>
}</block></else></if>
<while>while <condition>(<expr>--<name>level</name> &gt; 0</expr>)</condition> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>dot</name> <init>= <expr><call><name>strrchr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>'.'</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>dot</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"Attempted relative import beyond "
"toplevel package"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr>*<name>dot</name> = '\0'</expr>;</expr_stmt>
}</block></while>
<expr_stmt><expr>*<name>p_buflen</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>modules</name> = <call><name>PyImport_GetModuleDict</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>parent</name> = <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>modules</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>parent</name> == <name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>orig_level</name> &lt; 1</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>err_msg</name> <init>= <expr><call><name>PyString_FromFormat</name><argument_list>(
<argument><expr>"Parent module '%.200s' not found "
"while handling absolute import"</expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>err_msg</name> == <name>NULL</name></expr>)</condition><then> <block>{
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>!<call><name>PyErr_WarnEx</name><argument_list>(<argument><expr><name>PyExc_RuntimeWarning</name></expr></argument>,
<argument><expr><call><name>PyString_AsString</name><argument_list>(<argument><expr><name>err_msg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>buf</name> = '\0'</expr>;</expr_stmt>
<expr_stmt><expr>*<name>p_buflen</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>parent</name> = <name>Py_None</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>err_msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
<argument><expr>"Parent module '%.200s' not loaded, "
"cannot perform relative import"</expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
}</block></then></if>
<return>return <expr><name>parent</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>load_next</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>mod</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>altmod</name></decl></param>, <param><decl><type><name>char</name> **</type><name>p_name</name></decl></param>, <param><decl><type><name>char</name> *</type><name>buf</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name> *</type><name>p_buflen</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>name</name> <init>= <expr>*<name>p_name</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>dot</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>'.'</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>p_name</name> = <name>NULL</name></expr>;</expr_stmt>
<return>return <expr><name>mod</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>dot</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>p_name</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr>*<name>p_name</name> = <name>dot</name>+1</expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> = <name>dot</name>-<name>name</name></expr>;</expr_stmt>
}</block></else></if>
<if>if <condition>(<expr><name>len</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"Empty module name"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>p</name> = <name>buf</name> + *<name>p_buflen</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>p</name> != <name>buf</name></expr>)</condition><then>
<expr_stmt><expr>*<name>p</name>++ = '.'</expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>p</name>+<name>len</name>-<name>buf</name> &gt;= <name>MAXPATHLEN</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"Module name too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>p</name><index>[<expr><name>len</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
<expr_stmt><expr>*<name>p_buflen</name> = <name>p</name>+<name>len</name>-<name>buf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> = <call><name>import_submodule</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> == <name>Py_None</name> &amp;&amp; <name>altmod</name> != <name>mod</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> = <call><name>import_submodule</name><argument_list>(<argument><expr><name>altmod</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> != <name>NULL</name> &amp;&amp; <name>result</name> != <name>Py_None</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>mark_miss</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr><name>len</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
<expr_stmt><expr>*<name>p_buflen</name> = <name>len</name></expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>result</name> == <name>Py_None</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ImportError</name></expr></argument>,
<argument><expr>"No module named %.200s"</expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>mark_miss</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>name</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>modules</name> <init>= <expr><call><name>PyImport_GetModuleDict</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>modules</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>ensure_fromlist</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>mod</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>fromlist</name></decl></param>, <param><decl><type><name>char</name> *</type><name>buf</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>buflen</name></decl></param>,
<param><decl><type><name>int</name></type> <name>recursive</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyObject_HasAttrString</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr>"__path__"</expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>1</expr>;</return></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>item</name> <init>= <expr><call><name>PySequence_GetItem</name><argument_list>(<argument><expr><name>fromlist</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>hasit</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>item</name> == <name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_IndexError</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></then></if>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>!<call><name>PyString_Check</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"Item in ``from list'' not a string"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call><index>[<expr>0</expr>]</index> == '*'</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>all</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>recursive</name></expr>)</condition><then>
<continue>continue;</continue></then></if>
<expr_stmt><expr><name>all</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr>"__all__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>all</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
<else>else <block>{
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><call><name>ensure_fromlist</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>all</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>all</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>ret</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
}</block></else></if>
<continue>continue;</continue>
}</block></then></if>
<expr_stmt><expr><name>hasit</name> = <call><name>PyObject_HasAttr</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>hasit</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>subname</name> <init>= <expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>submod</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>p</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>buflen</name> + <call><name>strlen</name><argument_list>(<argument><expr><name>subname</name></expr></argument>)</argument_list></call> &gt;= <name>MAXPATHLEN</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"Module name too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>p</name> = <name>buf</name> + <name>buflen</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = '.'</expr>;</expr_stmt>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>subname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>submod</name> = <call><name>import_submodule</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>subname</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>submod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>submod</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
}</block></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>add_submodule</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>mod</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>submod</name></decl></param>, <param><decl><type><name>char</name> *</type><name>fullname</name></decl></param>, <param><decl><type><name>char</name> *</type><name>subname</name></decl></param>,
<param><decl><type><name>PyObject</name> *</type><name>modules</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name>mod</name> == <name>Py_None</name></expr>)</condition><then>
<return>return <expr>1</expr>;</return></then></if>
<if>if <condition>(<expr><name>submod</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>submod</name> = <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>modules</name></expr></argument>, <argument><expr><name>fullname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>submod</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>1</expr>;</return></then></if>
}</block></then></if>
<if>if <condition>(<expr><call><name>PyModule_Check</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>dict</name> <init>= <expr><call><name>PyModule_GetDict</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>dict</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<if>if <condition>(<expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name>subname</name></expr></argument>, <argument><expr><name>submod</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
}</block></then> <else>else <block>{
<if>if <condition>(<expr><call><name>PyObject_SetAttrString</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>subname</name></expr></argument>, <argument><expr><name>submod</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
}</block></else></if>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>import_submodule</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>mod</name></decl></param>, <param><decl><type><name>char</name> *</type><name>subname</name></decl></param>, <param><decl><type><name>char</name> *</type><name>fullname</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>modules</name> <init>= <expr><call><name>PyImport_GetModuleDict</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>(<name>m</name> = <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>modules</name></expr></argument>, <argument><expr><name>fullname</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>path</name></decl>, *<decl><type ref="prev"/><name>loader</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>MAXPATHLEN</name>+1</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>filedescr</name> *</type><name>fdp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> *</type><name>fp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>mod</name> == <name>Py_None</name></expr>)</condition><then>
<expr_stmt><expr><name>path</name> = <name>NULL</name></expr>;</expr_stmt></then>
<else>else <block>{
<expr_stmt><expr><name>path</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr>"__path__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>path</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></then></if>
}</block></else></if>
<expr_stmt><expr><name><name>buf</name><index>[<expr>0</expr>]</index></name> = '\0'</expr>;</expr_stmt>
<expr_stmt><expr><name>fdp</name> = <call><name>find_module</name><argument_list>(<argument><expr><name>fullname</name></expr></argument>, <argument><expr><name>subname</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name>+1</expr></argument>,
<argument><expr>&amp;<name>fp</name></expr></argument>, <argument><expr>&amp;<name>loader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>fdp</name> == <name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_ImportError</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>m</name> = <call><name>load_module</name><argument_list>(<argument><expr><name>fullname</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>fdp</name>-&gt;<name>type</name></name></expr></argument>, <argument><expr><name>loader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>loader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>fp</name></expr>)</condition><then>
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr>!<call><name>add_submodule</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>m</name></expr></argument>, <argument><expr><name>fullname</name></expr></argument>, <argument><expr><name>subname</name></expr></argument>, <argument><expr><name>modules</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>m</name> = <name>NULL</name></expr>;</expr_stmt>
}</block></then></if>
}</block></else></if>
<return>return <expr><name>m</name></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type>
<name>PyImport_ReloadModule</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>m</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyInterpreterState</name> *</type><name>interp</name> <init>= <expr><call><name>PyThreadState_Get</name><argument_list>()</argument_list></call>-&gt;<name>interp</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>modules_reloading</name> <init>= <expr><name><name>interp</name>-&gt;<name>modules_reloading</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>modules</name> <init>= <expr><call><name>PyImport_GetModuleDict</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>path</name> <init>= <expr><name>NULL</name></expr></init>, *<name>loader</name> <init>= <expr><name>NULL</name></expr></init>, *<name>existing_m</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>, *<decl><type ref="prev"/><name>subname</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>MAXPATHLEN</name>+1</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>filedescr</name> *</type><name>fdp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> *</type><name>fp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>newm</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>modules_reloading</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"PyImport_ReloadModule: "
"no modules_reloading dictionary!"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>m</name> == <name>NULL</name> || !<call><name>PyModule_Check</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"reload() argument must be module"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>name</name> = <call><name>PyModule_GetName</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>name</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>m</name> != <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>modules</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ImportError</name></expr></argument>,
<argument><expr>"reload(): module %.200s not in sys.modules"</expr></argument>,
<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>existing_m</name> = <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name>modules_reloading</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>existing_m</name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>existing_m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>existing_m</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>modules_reloading</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>subname</name> = <call><name>strrchr</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>'.'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>subname</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><name>subname</name> = <name>name</name></expr>;</expr_stmt></then>
<else>else <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>parentname</name></decl>, *<decl><type ref="prev"/><name>parent</name></decl>;</decl_stmt>
<expr_stmt><expr><name>parentname</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>(<name>subname</name>-<name>name</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>parentname</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>imp_modules_reloading_clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>parent</name> = <call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name>modules</name></expr></argument>, <argument><expr><name>parentname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>parent</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ImportError</name></expr></argument>,
<argument><expr>"reload(): parent %.200s not in sys.modules"</expr></argument>,
<argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>parentname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>parentname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>imp_modules_reloading_clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>parentname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>subname</name>++</expr>;</expr_stmt>
<expr_stmt><expr><name>path</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr>"__path__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>path</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
}</block></else></if>
<expr_stmt><expr><name><name>buf</name><index>[<expr>0</expr>]</index></name> = '\0'</expr>;</expr_stmt>
<expr_stmt><expr><name>fdp</name> = <call><name>find_module</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>subname</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name>+1</expr></argument>, <argument><expr>&amp;<name>fp</name></expr></argument>, <argument><expr>&amp;<name>loader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>fdp</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>loader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>imp_modules_reloading_clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>newm</name> = <call><name>load_module</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>fdp</name>-&gt;<name>type</name></name></expr></argument>, <argument><expr><name>loader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>loader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>fp</name></expr>)</condition><then>
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>newm</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>modules</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>imp_modules_reloading_clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>newm</name></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type>
<name>PyImport_Import</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>module_name</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>silly_list</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>builtins_str</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>import_str</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>globals</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>import</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>builtins</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>r</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>silly_list</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>import_str</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__import__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>import_str</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>builtins_str</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"__builtins__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>builtins_str</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>silly_list</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"[s]"</expr></argument>, <argument><expr>"__doc__"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>silly_list</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
}</block></then></if>
<expr_stmt><expr><name>globals</name> = <call><name>PyEval_GetGlobals</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>globals</name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>globals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>builtins</name> = <call><name>PyObject_GetItem</name><argument_list>(<argument><expr><name>globals</name></expr></argument>, <argument><expr><name>builtins_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>builtins</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>err</name>;</goto></then></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>builtins</name> = <call><name>PyImport_ImportModuleLevel</name><argument_list>(<argument><expr>"__builtin__"</expr></argument>,
<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>builtins</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>globals</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"{OO}"</expr></argument>, <argument><expr><name>builtins_str</name></expr></argument>, <argument><expr><name>builtins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>globals</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>err</name>;</goto></then></if>
}</block></else></if>
<if>if <condition>(<expr><call><name>PyDict_Check</name><argument_list>(<argument><expr><name>builtins</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>import</name> = <call><name>PyObject_GetItem</name><argument_list>(<argument><expr><name>builtins</name></expr></argument>, <argument><expr><name>import_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>import</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyErr_SetObject</name><argument_list>(<argument><expr><name>PyExc_KeyError</name></expr></argument>, <argument><expr><name>import_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></then> <else>else
<expr_stmt><expr><name>import</name> = <call><name>PyObject_GetAttr</name><argument_list>(<argument><expr><name>builtins</name></expr></argument>, <argument><expr><name>import_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<if>if <condition>(<expr><name>import</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>err</name>;</goto></then></if>
<expr_stmt><expr><name>r</name> = <call><name>PyObject_CallFunction</name><argument_list>(<argument><expr><name>import</name></expr></argument>, <argument><expr>"OOOOi"</expr></argument>, <argument><expr><name>module_name</name></expr></argument>, <argument><expr><name>globals</name></expr></argument>,
<argument><expr><name>globals</name></expr></argument>, <argument><expr><name>silly_list</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>err</name>:</label>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>globals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>builtins</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>import</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>r</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>imp_get_magic</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>4</expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr>0</expr>]</index></name> = <call>(<name>char</name>) <argument_list>(<argument><expr>(<name>pyc_magic</name> &gt;&gt; 0) &amp; 0xff</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr>1</expr>]</index></name> = <call>(<name>char</name>) <argument_list>(<argument><expr>(<name>pyc_magic</name> &gt;&gt; 8) &amp; 0xff</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr>2</expr>]</index></name> = <call>(<name>char</name>) <argument_list>(<argument><expr>(<name>pyc_magic</name> &gt;&gt; 16) &amp; 0xff</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr>3</expr>]</index></name> = <call>(<name>char</name>) <argument_list>(<argument><expr>(<name>pyc_magic</name> &gt;&gt; 24) &amp; 0xff</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>4</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>imp_get_suffixes</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>noargs</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>list</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>filedescr</name> *</type><name>fdp</name></decl>;</decl_stmt>
<expr_stmt><expr><name>list</name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>list</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<for>for (<init><expr><name>fdp</name> = <name>_PyImport_Filetab</name></expr>;</init> <condition><expr><name><name>fdp</name>-&gt;<name>suffix</name></name> != <name>NULL</name></expr>;</condition> <incr><expr><name>fdp</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>item</name> <init>= <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"ssi"</expr></argument>,
<argument><expr><name><name>fdp</name>-&gt;<name>suffix</name></name></expr></argument>, <argument><expr><name><name>fdp</name>-&gt;<name>mode</name></name></expr></argument>, <argument><expr><name><name>fdp</name>-&gt;<name>type</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>item</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><call><name>PyList_Append</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<return>return <expr><name>list</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>call_find_module</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>path</name></decl></param>)</parameter_list> <block>{
<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>fclose</name><parameter_list>(<param><decl><type><name>FILE</name> *</type></decl></param>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>fob</name></decl>, *<decl><type ref="prev"/><name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>filedescr</name> *</type><name>fdp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>pathname</name><index>[<expr><name>MAXPATHLEN</name>+1</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> *</type><name>fp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>pathname</name><index>[<expr>0</expr>]</index></name> = '\0'</expr>;</expr_stmt>
<if>if <condition>(<expr><name>path</name> == <name>Py_None</name></expr>)</condition><then>
<expr_stmt><expr><name>path</name> = <name>NULL</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>fdp</name> = <call><name>find_module</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>MAXPATHLEN</name>+1</expr></argument>, <argument><expr>&amp;<name>fp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>fdp</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>fp</name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>fob</name> = <call><name>PyFile_FromFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>pathname</name></expr></argument>, <argument><expr><name><name>fdp</name>-&gt;<name>mode</name></name></expr></argument>, <argument><expr><name>fclose</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>fob</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>fob</name> = <name>Py_None</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>fob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><name>ret</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"Os(ssi)"</expr></argument>,
<argument><expr><name>fob</name></expr></argument>, <argument><expr><name>pathname</name></expr></argument>, <argument><expr><name><name>fdp</name>-&gt;<name>suffix</name></name></expr></argument>, <argument><expr><name><name>fdp</name>-&gt;<name>mode</name></name></expr></argument>, <argument><expr><name><name>fdp</name>-&gt;<name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>fob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>imp_find_module</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s|O:find_module"</expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>, <argument><expr>&amp;<name>path</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>call_find_module</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>imp_init_builtin</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s:init_builtin"</expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>ret</name> = <call><name>init_builtin</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ret</name> &lt; 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>ret</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>m</name> = <call><name>PyImport_AddModule</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>m</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>imp_init_frozen</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s:init_frozen"</expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>ret</name> = <call><name>PyImport_ImportFrozenModule</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ret</name> &lt; 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>ret</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>m</name> = <call><name>PyImport_AddModule</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XINCREF</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>m</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>imp_get_frozen_object</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s:get_frozen_object"</expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>get_frozen_object</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>imp_is_builtin</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s:is_builtin"</expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><call><name>is_builtin</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>imp_is_frozen</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>_frozen</name> *</type><name>p</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s:is_frozen"</expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>p</name> = <call><name>find_frozen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><call>(<name>long</name>) <argument_list>(<argument><expr><name>p</name> == <name>NULL</name> ? 0 : <name><name>p</name>-&gt;<name>size</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>FILE</name> *</type>
<name>get_file</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>pathname</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>fob</name></decl></param>, <param><decl><type><name>char</name> *</type><name>mode</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>FILE</name> *</type><name>fp</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>fob</name> == <name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>mode</name><index>[<expr>0</expr>]</index></name> == 'U'</expr>)</condition><then>
<expr_stmt><expr><name>mode</name> = "r" <name>PY_STDIOTEXTMODE</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>fp</name> = <call><name>fopen</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>fp</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyErr_SetFromErrno</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>fp</name> = <call><name>PyFile_AsFile</name><argument_list>(<argument><expr><name>fob</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>fp</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"bad/closed file object"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></else></if>
<return>return <expr><name>fp</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>imp_load_compiled</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>pathname</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>fob</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> *</type><name>fp</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"ss|O!:load_compiled"</expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>, <argument><expr>&amp;<name>pathname</name></expr></argument>,
<argument><expr>&amp;<name>PyFile_Type</name></expr></argument>, <argument><expr>&amp;<name>fob</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>fp</name> = <call><name>get_file</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>fob</name></expr></argument>, <argument><expr>"rb"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>fp</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>m</name> = <call><name>load_compiled_module</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>fob</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>m</name></expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_DYNAMIC_LOADING</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>imp_load_dynamic</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>pathname</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>fob</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> *</type><name>fp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"ss|O!:load_dynamic"</expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>, <argument><expr>&amp;<name>pathname</name></expr></argument>,
<argument><expr>&amp;<name>PyFile_Type</name></expr></argument>, <argument><expr>&amp;<name>fob</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>fob</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>fp</name> = <call><name>get_file</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>fob</name></expr></argument>, <argument><expr>"r"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>fp</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
}</block></then></if>
<expr_stmt><expr><name>m</name> = <call><name>_PyImport_LoadDynamicModule</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>m</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>imp_load_source</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>pathname</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>fob</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> *</type><name>fp</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"ss|O!:load_source"</expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>, <argument><expr>&amp;<name>pathname</name></expr></argument>,
<argument><expr>&amp;<name>PyFile_Type</name></expr></argument>, <argument><expr>&amp;<name>fob</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>fp</name> = <call><name>get_file</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>fob</name></expr></argument>, <argument><expr>"r"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>fp</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>m</name> = <call><name>load_source_module</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>fob</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>m</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>imp_load_module</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>fob</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>pathname</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>suffix</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>mode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>type</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> *</type><name>fp</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"sOs(ssi):load_module"</expr></argument>,
<argument><expr>&amp;<name>name</name></expr></argument>, <argument><expr>&amp;<name>fob</name></expr></argument>, <argument><expr>&amp;<name>pathname</name></expr></argument>,
<argument><expr>&amp;<name>suffix</name></expr></argument>, <argument><expr>&amp;<name>mode</name></expr></argument>, <argument><expr>&amp;<name>type</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr>*<name>mode</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>!(*<name>mode</name> == 'r' || *<name>mode</name> == 'U') || <call><name>strchr</name><argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr>'+'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"invalid file open mode %.200s"</expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
}</block></then></if>
<if>if <condition>(<expr><name>fob</name> == <name>Py_None</name></expr>)</condition><then>
<expr_stmt><expr><name>fp</name> = <name>NULL</name></expr>;</expr_stmt></then>
<else>else <block>{
<if>if <condition>(<expr>!<call><name>PyFile_Check</name><argument_list>(<argument><expr><name>fob</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"load_module arg#2 should be a file or None"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>fp</name> = <call><name>get_file</name><argument_list>(<argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>fob</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>fp</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
}</block></else></if>
<return>return <expr><call><name>load_module</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>pathname</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>imp_load_package</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>pathname</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"ss:load_package"</expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>, <argument><expr>&amp;<name>pathname</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>load_package</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>pathname</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>imp_new_module</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s:new_module"</expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>PyModule_New</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>imp_reload</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>PyImport_ReloadModule</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>doc_imp</name></expr></argument>,
<argument><expr>"This module provides the components needed to build your own\n\
__import__ function. Undocumented functions are obsolete."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>doc_reload</name></expr></argument>,
<argument><expr>"reload(module) -&gt; module\n\
\n\
Reload the module. The module must have been successfully imported before."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>doc_find_module</name></expr></argument>,
<argument><expr>"find_module(name, [path]) -&gt; (file, filename, (suffix, mode, type))\n\
Search for a module. If path is omitted or None, search for a\n\
built-in, frozen or special module and continue search in sys.path.\n\
The module name cannot contain '.'; to search for a submodule of a\n\
package, pass the submodule name and the package's __path__."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>doc_load_module</name></expr></argument>,
<argument><expr>"load_module(name, file, filename, (suffix, mode, type)) -&gt; module\n\
Load a module, given information returned by find_module().\n\
The module name must include the full package name, if any."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>doc_get_magic</name></expr></argument>,
<argument><expr>"get_magic() -&gt; string\n\
Return the magic number for .pyc or .pyo files."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>doc_get_suffixes</name></expr></argument>,
<argument><expr>"get_suffixes() -&gt; [(suffix, mode, type), ...]\n\
Return a list of (suffix, mode, type) tuples describing the files\n\
that find_module() looks for."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>doc_new_module</name></expr></argument>,
<argument><expr>"new_module(name) -&gt; module\n\
Create a new module. Do not enter it in sys.modules.\n\
The module name must include the full package name, if any."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>doc_lock_held</name></expr></argument>,
<argument><expr>"lock_held() -&gt; boolean\n\
Return True if the import lock is currently held, else False.\n\
On platforms without threads, return False."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>doc_acquire_lock</name></expr></argument>,
<argument><expr>"acquire_lock() -&gt; None\n\
Acquires the interpreter's import lock for the current thread.\n\
This lock should be used by import hooks to ensure thread-safety\n\
when importing modules.\n\
On platforms without threads, this function does nothing."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>doc_release_lock</name></expr></argument>,
<argument><expr>"release_lock() -&gt; None\n\
Release the interpreter's import lock.\n\
On platforms without threads, this function does nothing."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>imp_methods</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr>"reload"</expr>, <expr><name>imp_reload</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>doc_reload</name></expr>}</block></expr>,
<expr><block>{<expr>"find_module"</expr>, <expr><name>imp_find_module</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>doc_find_module</name></expr>}</block></expr>,
<expr><block>{<expr>"get_magic"</expr>, <expr><name>imp_get_magic</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>doc_get_magic</name></expr>}</block></expr>,
<expr><block>{<expr>"get_suffixes"</expr>, <expr><name>imp_get_suffixes</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>doc_get_suffixes</name></expr>}</block></expr>,
<expr><block>{<expr>"load_module"</expr>, <expr><name>imp_load_module</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>doc_load_module</name></expr>}</block></expr>,
<expr><block>{<expr>"new_module"</expr>, <expr><name>imp_new_module</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>doc_new_module</name></expr>}</block></expr>,
<expr><block>{<expr>"lock_held"</expr>, <expr><name>imp_lock_held</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>doc_lock_held</name></expr>}</block></expr>,
<expr><block>{<expr>"acquire_lock"</expr>, <expr><name>imp_acquire_lock</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>doc_acquire_lock</name></expr>}</block></expr>,
<expr><block>{<expr>"release_lock"</expr>, <expr><name>imp_release_lock</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>doc_release_lock</name></expr>}</block></expr>,
<expr><block>{<expr>"get_frozen_object"</expr>, <expr><name>imp_get_frozen_object</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
<expr><block>{<expr>"init_builtin"</expr>, <expr><name>imp_init_builtin</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
<expr><block>{<expr>"init_frozen"</expr>, <expr><name>imp_init_frozen</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
<expr><block>{<expr>"is_builtin"</expr>, <expr><name>imp_is_builtin</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
<expr><block>{<expr>"is_frozen"</expr>, <expr><name>imp_is_frozen</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
<expr><block>{<expr>"load_compiled"</expr>, <expr><name>imp_load_compiled</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_DYNAMIC_LOADING</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"load_dynamic"</expr>, <expr><name>imp_load_dynamic</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr><block>{<expr>"load_package"</expr>, <expr><name>imp_load_package</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
<expr><block>{<expr>"load_source"</expr>, <expr><name>imp_load_source</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>setint</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>d</name></decl></param>, <param><decl><type><name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>int</name></type> <name>value</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>
<expr_stmt><expr><name>v</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> = <call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>err</name></expr>;</return>
}</block></function>
<typedef>typedef <type><struct>struct <block>{
<expr_stmt><expr><name>PyObject_HEAD</name></expr></expr_stmt>
}</block></struct></type> <name>NullImporter</name>;</typedef>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>NullImporter_init</name><parameter_list>(<param><decl><type><name>NullImporter</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>path</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>pathlen</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>_PyArg_NoKeywords</name><argument_list>(<argument><expr>"NullImporter()"</expr></argument>, <argument><expr><name>kwds</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s:NullImporter"</expr></argument>,
<argument><expr>&amp;<name>path</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><name>pathlen</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>pathlen</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ImportError</name></expr></argument>, <argument><expr>"empty pathname"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then> <else>else <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>RISCOS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type>struct <name>stat</name></type> <name>statbuf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>rv</name></decl>;</decl_stmt>
<expr_stmt><expr><name>rv</name> = <call><name>stat</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>&amp;<name>statbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>rv</name> != 0 &amp;&amp; <name>pathlen</name> &lt;= <name>MAXPATHLEN</name> &amp;&amp;
(<name><name>path</name><index>[<expr><name>pathlen</name>-1</expr>]</index></name> == '/' || <name><name>path</name><index>[<expr><name>pathlen</name>-1</expr>]</index></name> == '\\')</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name></type> <name><name>mangled</name><index>[<expr><name>MAXPATHLEN</name>+1</expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>mangled</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mangled</name><index>[<expr><name>pathlen</name>-1</expr>]</index></name> = '\0'</expr>;</expr_stmt>
<expr_stmt><expr><name>rv</name> = <call><name>stat</name><argument_list>(<argument><expr><name>mangled</name></expr></argument>, <argument><expr>&amp;<name>statbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><name>rv</name> == 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>statbuf</name>.<name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ImportError</name></expr></argument>,
<argument><expr>"existing directory"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
}</block></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if>if <condition>(<expr><call><name>object_exists</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>isdir</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ImportError</name></expr></argument>,
<argument><expr>"existing directory"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></else></if>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>NullImporter_find_module</name><parameter_list>(<param><decl><type><name>NullImporter</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>NullImporter_methods</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{
<expr>"find_module"</expr>, <expr>(<name>PyCFunction</name>)<name>NullImporter_find_module</name></expr>, <expr><name>METH_VARARGS</name></expr>,
<expr>"Always return None"</expr>
}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyTypeObject</name></type> <name>PyNullImporter_Type</name> <init>= <expr><block>{
<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
"imp.NullImporter"</expr>,
<expr><sizeof>sizeof<argument_list>(<argument><expr><name>NullImporter</name></expr></argument>)</argument_list></sizeof></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>Py_TPFLAGS_DEFAULT</name></expr>,
<expr>"Null importer object"</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>NullImporter_methods</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>(<name>initproc</name>)<name>NullImporter_init</name></expr>,
<expr>0</expr>,
<expr><name>PyType_GenericNew</name></expr>
}</block></expr></init></decl>;</decl_stmt>
<function><type><name>PyMODINIT_FUNC</name></type>
<name>initimp</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name></decl>, *<decl><type ref="prev"/><name>d</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyType_Ready</name><argument_list>(<argument><expr>&amp;<name>PyNullImporter_Type</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<goto>goto <name>failure</name>;</goto></then></if>
<expr_stmt><expr><name>m</name> = <call><name>Py_InitModule4</name><argument_list>(<argument><expr>"imp"</expr></argument>, <argument><expr><name>imp_methods</name></expr></argument>, <argument><expr><name>doc_imp</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>PYTHON_API_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>m</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>failure</name>;</goto></then></if>
<expr_stmt><expr><name>d</name> = <call><name>PyModule_GetDict</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>d</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>failure</name>;</goto></then></if>
<if>if <condition>(<expr><call><name>setint</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"SEARCH_ERROR"</expr></argument>, <argument><expr><name>SEARCH_ERROR</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <goto>goto <name>failure</name>;</goto></then></if>
<if>if <condition>(<expr><call><name>setint</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"PY_SOURCE"</expr></argument>, <argument><expr><name>PY_SOURCE</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <goto>goto <name>failure</name>;</goto></then></if>
<if>if <condition>(<expr><call><name>setint</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"PY_COMPILED"</expr></argument>, <argument><expr><name>PY_COMPILED</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <goto>goto <name>failure</name>;</goto></then></if>
<if>if <condition>(<expr><call><name>setint</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"C_EXTENSION"</expr></argument>, <argument><expr><name>C_EXTENSION</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <goto>goto <name>failure</name>;</goto></then></if>
<if>if <condition>(<expr><call><name>setint</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"PY_RESOURCE"</expr></argument>, <argument><expr><name>PY_RESOURCE</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <goto>goto <name>failure</name>;</goto></then></if>
<if>if <condition>(<expr><call><name>setint</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"PKG_DIRECTORY"</expr></argument>, <argument><expr><name>PKG_DIRECTORY</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <goto>goto <name>failure</name>;</goto></then></if>
<if>if <condition>(<expr><call><name>setint</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"C_BUILTIN"</expr></argument>, <argument><expr><name>C_BUILTIN</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <goto>goto <name>failure</name>;</goto></then></if>
<if>if <condition>(<expr><call><name>setint</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"PY_FROZEN"</expr></argument>, <argument><expr><name>PY_FROZEN</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <goto>goto <name>failure</name>;</goto></then></if>
<if>if <condition>(<expr><call><name>setint</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"PY_CODERESOURCE"</expr></argument>, <argument><expr><name>PY_CODERESOURCE</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <goto>goto <name>failure</name>;</goto></then></if>
<if>if <condition>(<expr><call><name>setint</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr>"IMP_HOOK"</expr></argument>, <argument><expr><name>IMP_HOOK</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <goto>goto <name>failure</name>;</goto></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>&amp;<name>PyNullImporter_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyModule_AddObject</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"NullImporter"</expr></argument>, <argument><expr>(<name>PyObject</name> *)&amp;<name>PyNullImporter_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>failure</name>:</label>
<empty_stmt>;</empty_stmt>
}</block></function>
<function><type><name>int</name></type>
<name>PyImport_ExtendInittab</name><parameter_list>(<param><decl><type>struct <name>_inittab</name> *</type><name>newtab</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>static</specifier> struct <name>_inittab</name> *</type><name>our_copy</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>_inittab</name> *</type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
<for>for (<init><expr><name>n</name> = 0</expr>;</init> <condition><expr><name><name>newtab</name><index>[<expr><name>n</name></expr>]</index></name>.<name>name</name> != <name>NULL</name></expr>;</condition> <incr><expr><name>n</name>++</expr></incr>)
<empty_stmt>;</empty_stmt></for>
<if>if <condition>(<expr><name>n</name> == 0</expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name><name>PyImport_Inittab</name><index>[<expr><name>i</name></expr>]</index></name>.<name>name</name> != <name>NULL</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
<empty_stmt>;</empty_stmt></for>
<expr_stmt><expr><name>p</name> = <name>our_copy</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyMem_RESIZE</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument>struct <expr><name>_inittab</name></expr></argument>, <argument><expr><name>i</name>+<name>n</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>p</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr><name>our_copy</name> != <name>PyImport_Inittab</name></expr>)</condition><then>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>PyImport_Inittab</name></expr></argument>, <argument><expr>(<name>i</name>+1) * <sizeof>sizeof<argument_list>(<argument>struct <expr><name>_inittab</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>PyImport_Inittab</name> = <name>our_copy</name> = <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name>+<name>i</name></expr></argument>, <argument><expr><name>newtab</name></expr></argument>, <argument><expr>(<name>n</name>+1) * <sizeof>sizeof<argument_list>(<argument>struct <expr><name>_inittab</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><name>int</name></type>
<name>PyImport_AppendInittab</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>name</name></decl></param>, <param><function_decl><type><name>void</name></type> (*<name>initfunc</name>)<parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list></function_decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>_inittab</name></type> <name><name>newtab</name><index>[<expr>2</expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>newtab</name></expr></argument>, <argument><expr>'\0'</expr></argument>, <argument><expr>sizeof <name>newtab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newtab</name><index>[<expr>0</expr>]</index></name>.<name>name</name> = <name>name</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>newtab</name><index>[<expr>0</expr>]</index></name>.<name>initfunc</name> = <name>initfunc</name></expr>;</expr_stmt>
<return>return <expr><call><name>PyImport_ExtendInittab</name><argument_list>(<argument><expr><name>newtab</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call></expr></cpp:if>
}</block></function></block></extern>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
