<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="Python/codecs.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>_PyCodecRegistry_Init</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>;</function_decl>
<function><type><name>int</name></type> <name>PyCodec_Register</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>search_function</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyInterpreterState</name> *</type><name>interp</name> <init>= <expr><call><name>PyThreadState_GET</name><argument_list>()</argument_list></call>-&gt;<name>interp</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>interp</name>-&gt;<name>codec_search_path</name></name> == <name>NULL</name> &amp;&amp; <call><name>_PyCodecRegistry_Init</name><argument_list>()</argument_list></call></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<if>if <condition>(<expr><name>search_function</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_BadArgument</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>onError</name>;</goto>
}</block></then></if>
<if>if <condition>(<expr>!<call><name>PyCallable_Check</name><argument_list>(<argument><expr><name>search_function</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"argument must be callable"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>onError</name>;</goto>
}</block></then></if>
<return>return <expr><call><name>PyList_Append</name><argument_list>(<argument><expr><name><name>interp</name>-&gt;<name>codec_search_path</name></name></expr></argument>, <argument><expr><name>search_function</name></expr></argument>)</argument_list></call></expr>;</return>
<label><name>onError</name>:</label>
<return>return <expr>-1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier>
<name>PyObject</name> *</type><name>normalizestring</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>string</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>register</name> <name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>len</name> &gt; <name>PY_SSIZE_T_MAX</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>, <argument><expr>"string is too large"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>v</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>p</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>register</name> <name>char</name></type> <name>ch</name> <init>= <expr><name><name>string</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>ch</name> == ' '</expr>)</condition><then>
<expr_stmt><expr><name>ch</name> = '-'</expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>ch</name> = <call><name>tolower</name><argument_list>(<argument><expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<expr_stmt><expr><name><name>p</name><index>[<expr><name>i</name></expr>]</index></name> = <name>ch</name></expr>;</expr_stmt>
}</block></for>
<return>return <expr><name>v</name></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type><name>_PyCodec_Lookup</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>encoding</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyInterpreterState</name> *</type><name>interp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>, *<decl><type ref="prev"/><name>args</name> <init>= <expr><name>NULL</name></expr></init>, *<name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>encoding</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_BadArgument</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>onError</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>interp</name> = <call><name>PyThreadState_GET</name><argument_list>()</argument_list></call>-&gt;<name>interp</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>interp</name>-&gt;<name>codec_search_path</name></name> == <name>NULL</name> &amp;&amp; <call><name>_PyCodecRegistry_Init</name><argument_list>()</argument_list></call></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<expr_stmt><expr><name>v</name> = <call><name>normalizestring</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<expr_stmt><expr><call><name>PyString_InternInPlace</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> = <call><name>PyDict_GetItem</name><argument_list>(<argument><expr><name><name>interp</name>-&gt;<name>codec_search_cache</name></name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>args</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>args</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>args</name></expr></argument>,<argument><expr>0</expr></argument>,<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> = <call><name>PyList_Size</name><argument_list>(<argument><expr><name><name>interp</name>-&gt;<name>codec_search_path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>len</name> &lt; 0</expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<if>if <condition>(<expr><name>len</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_LookupError</name></expr></argument>,
<argument><expr>"no codec search functions registered: "
"can't find encoding"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>onError</name>;</goto>
}</block></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>func</name></decl>;</decl_stmt>
<expr_stmt><expr><name>func</name> = <call><name>PyList_GetItem</name><argument_list>(<argument><expr><name><name>interp</name>-&gt;<name>codec_search_path</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>func</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<expr_stmt><expr><name>result</name> = <call><name>PyEval_CallObject</name><argument_list>(<argument><expr><name>func</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<if>if <condition>(<expr><name>result</name> == <name>Py_None</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
}</block></then></if>
<if>if <condition>(<expr>!<call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> || <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> != 4</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"codec search functions must return 4-tuples"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>onError</name>;</goto>
}</block></then></if>
<break>break;</break>
}</block></for>
<if>if <condition>(<expr><name>i</name> == <name>len</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_LookupError</name></expr></argument>,
<argument><expr>"unknown encoding: %s"</expr></argument>, <argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>onError</name>;</goto>
}</block></then></if>
<expr_stmt><expr><call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name><name>interp</name>-&gt;<name>codec_search_cache</name></name></expr></argument>, <argument><expr><name>v</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
<label><name>onError</name>:</label>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier>
<name>PyObject</name> *</type><name>args_tuple</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>object</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>args</name></decl>;</decl_stmt>
<expr_stmt><expr><name>args</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr>1 + (<name>errors</name> != <name>NULL</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>args</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>args</name></expr></argument>,<argument><expr>0</expr></argument>,<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>errors</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
<expr_stmt><expr><name>v</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>PyTuple_SET_ITEM</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>args</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier>
<name>PyObject</name> *</type><name>codec_getitem</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>encoding</name></decl></param>, <param><decl><type><name>int</name></type> <name>index</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>codecs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
<expr_stmt><expr><name>codecs</name> = <call><name>_PyCodec_Lookup</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>codecs</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>v</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>codecs</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>codecs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>v</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier>
<name>PyObject</name> *</type><name>codec_getincrementalcodec</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>encoding</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>attrname</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>codecs</name></decl>, *<decl><type ref="prev"/><name>ret</name></decl>, *<decl><type ref="prev"/><name>inccodec</name></decl>;</decl_stmt>
<expr_stmt><expr><name>codecs</name> = <call><name>_PyCodec_Lookup</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>codecs</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>inccodec</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>codecs</name></expr></argument>, <argument><expr><name>attrname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>codecs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>inccodec</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>errors</name></expr>)</condition><then>
<expr_stmt><expr><name>ret</name> = <call><name>PyObject_CallFunction</name><argument_list>(<argument><expr><name>inccodec</name></expr></argument>, <argument><expr>"s"</expr></argument>, <argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>ret</name> = <call><name>PyObject_CallFunction</name><argument_list>(<argument><expr><name>inccodec</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>inccodec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier>
<name>PyObject</name> *</type><name>codec_getstreamcodec</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>encoding</name></decl></param>,
<param><decl><type><name>PyObject</name> *</type><name>stream</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>int</name></type> <name>index</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>codecs</name></decl>, *<decl><type ref="prev"/><name>streamcodec</name></decl>, *<decl><type ref="prev"/><name>codeccls</name></decl>;</decl_stmt>
<expr_stmt><expr><name>codecs</name> = <call><name>_PyCodec_Lookup</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>codecs</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>codeccls</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>codecs</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>errors</name> != <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><name>streamcodec</name> = <call><name>PyObject_CallFunction</name><argument_list>(<argument><expr><name>codeccls</name></expr></argument>, <argument><expr>"Os"</expr></argument>, <argument><expr><name>stream</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>streamcodec</name> = <call><name>PyObject_CallFunction</name><argument_list>(<argument><expr><name>codeccls</name></expr></argument>, <argument><expr>"O"</expr></argument>, <argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>codecs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>streamcodec</name></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type><name>PyCodec_Encoder</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>encoding</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>codec_getitem</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type><name>PyCodec_Decoder</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>encoding</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>codec_getitem</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type><name>PyCodec_IncrementalEncoder</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>encoding</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>codec_getincrementalcodec</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>, <argument><expr>"incrementalencoder"</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type><name>PyCodec_IncrementalDecoder</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>encoding</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>codec_getincrementalcodec</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>, <argument><expr>"incrementaldecoder"</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type><name>PyCodec_StreamReader</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>encoding</name></decl></param>,
<param><decl><type><name>PyObject</name> *</type><name>stream</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>codec_getstreamcodec</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>stream</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type><name>PyCodec_StreamWriter</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>encoding</name></decl></param>,
<param><decl><type><name>PyObject</name> *</type><name>stream</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>codec_getstreamcodec</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>stream</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type><name>PyCodec_Encode</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>object</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>encoding</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>encoder</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>args</name> <init>= <expr><name>NULL</name></expr></init>, *<name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
<expr_stmt><expr><name>encoder</name> = <call><name>PyCodec_Encoder</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>encoder</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<expr_stmt><expr><name>args</name> = <call><name>args_tuple</name><argument_list>(<argument><expr><name>object</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>args</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<expr_stmt><expr><name>result</name> = <call><name>PyEval_CallObject</name><argument_list>(<argument><expr><name>encoder</name></expr></argument>,<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<if>if <condition>(<expr>!<call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> ||
<call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> != 2</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"encoder must return a tuple (object,integer)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>onError</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>v</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>result</name></expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>encoder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>v</name></expr>;</return>
<label><name>onError</name>:</label>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>encoder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type><name>PyCodec_Decode</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>object</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>encoding</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>decoder</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>args</name> <init>= <expr><name>NULL</name></expr></init>, *<name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
<expr_stmt><expr><name>decoder</name> = <call><name>PyCodec_Decoder</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>decoder</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<expr_stmt><expr><name>args</name> = <call><name>args_tuple</name><argument_list>(<argument><expr><name>object</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>args</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<expr_stmt><expr><name>result</name> = <call><name>PyEval_CallObject</name><argument_list>(<argument><expr><name>decoder</name></expr></argument>,<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<if>if <condition>(<expr>!<call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> ||
<call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> != 2</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"decoder must return a tuple (object,integer)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>onError</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>v</name> = <call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>result</name></expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>decoder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>v</name></expr>;</return>
<label><name>onError</name>:</label>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>decoder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><name>int</name></type> <name>PyCodec_RegisterError</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>error</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyInterpreterState</name> *</type><name>interp</name> <init>= <expr><call><name>PyThreadState_GET</name><argument_list>()</argument_list></call>-&gt;<name>interp</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>interp</name>-&gt;<name>codec_search_path</name></name> == <name>NULL</name> &amp;&amp; <call><name>_PyCodecRegistry_Init</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>PyCallable_Check</name><argument_list>(<argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"handler must be callable"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<return>return <expr><call><name>PyDict_SetItemString</name><argument_list>(<argument><expr><name><name>interp</name>-&gt;<name>codec_error_registry</name></name></expr></argument>,
<argument><expr>(<name>char</name> *)<name>name</name></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type><name>PyCodec_LookupError</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>handler</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyInterpreterState</name> *</type><name>interp</name> <init>= <expr><call><name>PyThreadState_GET</name><argument_list>()</argument_list></call>-&gt;<name>interp</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>interp</name>-&gt;<name>codec_search_path</name></name> == <name>NULL</name> &amp;&amp; <call><name>_PyCodecRegistry_Init</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>name</name>==<name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><name>name</name> = "strict"</expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>handler</name> = <call><name>PyDict_GetItemString</name><argument_list>(<argument><expr><name><name>interp</name>-&gt;<name>codec_error_registry</name></name></expr></argument>, <argument><expr>(<name>char</name> *)<name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>handler</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_LookupError</name></expr></argument>, <argument><expr>"unknown error handler name '%.400s'"</expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<return>return <expr><name>handler</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>wrong_exception_type</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>exc</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>type</name> <init>= <expr><call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr>"__class__"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>type</name> != <name>NULL</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>name</name> <init>= <expr><call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr>"__name__"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>name</name> != <name>NULL</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>string</name> <init>= <expr><call><name>PyObject_Str</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>string</name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"don't know how to handle %.400s in error callback"</expr></argument>,
<argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
}</block></then></if>
}</block></function>
<function><type><name>PyObject</name> *</type><name>PyCodec_StrictErrors</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>exc</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><call><name>PyExceptionInstance_Check</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><call><name>PyErr_SetObject</name><argument_list>(<argument><expr><call><name>PyExceptionInstance_Class</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"codec must pass exception instance"</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_USING_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>PyObject</name> *</type><name>PyCodec_IgnoreErrors</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>exc</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>end</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyObject_IsInstance</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><name>PyExc_UnicodeEncodeError</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PyUnicodeEncodeError_GetEnd</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr>&amp;<name>end</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
}</block></then> <else>else <if>if <condition>(<expr><call><name>PyObject_IsInstance</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><name>PyExc_UnicodeDecodeError</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PyUnicodeDecodeError_GetEnd</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr>&amp;<name>end</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
}</block></then> <else>else <if>if <condition>(<expr><call><name>PyObject_IsInstance</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><name>PyExc_UnicodeTranslateError</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PyUnicodeTranslateError_GetEnd</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr>&amp;<name>end</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>wrong_exception_type</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></else></if></else></if></else></if>
<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(u#n)"</expr></argument>, <argument><expr>&amp;<name>end</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type><name>PyCodec_ReplaceErrors</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>exc</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>restuple</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>start</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyObject_IsInstance</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><name>PyExc_UnicodeEncodeError</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>p</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyUnicodeEncodeError_GetStart</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr>&amp;<name>start</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>PyUnicodeEncodeError_GetEnd</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr>&amp;<name>end</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>res</name> = <call><name>PyUnicode_FromUnicode</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>end</name>-<name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>res</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<for>for (<init><expr><name>p</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>, <expr><name>i</name> = <name>start</name></expr>;</init>
<condition><expr><name>i</name>&lt;<name>end</name></expr>;</condition> <incr><expr>++<name>p</name></expr>, <expr>++<name>i</name></expr></incr>)
<expr_stmt><expr>*<name>p</name> = '?'</expr>;</expr_stmt></for>
<expr_stmt><expr><name>restuple</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(On)"</expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>restuple</name></expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><call><name>PyObject_IsInstance</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><name>PyExc_UnicodeDecodeError</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>Py_UNICODE</name></type> <name>res</name> <init>= <expr><name>Py_UNICODE_REPLACEMENT_CHARACTER</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyUnicodeDecodeError_GetEnd</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr>&amp;<name>end</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(u#n)"</expr></argument>, <argument><expr>&amp;<name>res</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><call><name>PyObject_IsInstance</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><name>PyExc_UnicodeTranslateError</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>p</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyUnicodeTranslateError_GetStart</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr>&amp;<name>start</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>PyUnicodeTranslateError_GetEnd</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr>&amp;<name>end</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>res</name> = <call><name>PyUnicode_FromUnicode</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>end</name>-<name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>res</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<for>for (<init><expr><name>p</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>, <expr><name>i</name> = <name>start</name></expr>;</init>
<condition><expr><name>i</name>&lt;<name>end</name></expr>;</condition> <incr><expr>++<name>p</name></expr>, <expr>++<name>i</name></expr></incr>)
<expr_stmt><expr>*<name>p</name> = <name>Py_UNICODE_REPLACEMENT_CHARACTER</name></expr>;</expr_stmt></for>
<expr_stmt><expr><name>restuple</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(On)"</expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>restuple</name></expr>;</return>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>wrong_exception_type</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></else></if></else></if></else></if>
}</block></function>
<function><type><name>PyObject</name> *</type><name>PyCodec_XMLCharRefReplaceErrors</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>exc</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><call><name>PyObject_IsInstance</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><name>PyExc_UnicodeEncodeError</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>restuple</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>object</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>start</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>startp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>outp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ressize</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyUnicodeEncodeError_GetStart</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr>&amp;<name>start</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>PyUnicodeEncodeError_GetEnd</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr>&amp;<name>end</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr>!(<name>object</name> = <call><name>PyUnicodeEncodeError_GetObject</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>startp</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>p</name> = <name>startp</name>+<name>start</name></expr>, <expr><name>ressize</name> = 0</expr>;</init> <condition><expr><name>p</name> &lt; <name>startp</name>+<name>end</name></expr>;</condition> <incr><expr>++<name>p</name></expr></incr>) <block>{
<if>if <condition>(<expr>*<name>p</name>&lt;10</expr>)</condition><then>
<expr_stmt><expr><name>ressize</name> += 2+1+1</expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr>*<name>p</name>&lt;100</expr>)</condition><then>
<expr_stmt><expr><name>ressize</name> += 2+2+1</expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr>*<name>p</name>&lt;1000</expr>)</condition><then>
<expr_stmt><expr><name>ressize</name> += 2+3+1</expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr>*<name>p</name>&lt;10000</expr>)</condition><then>
<expr_stmt><expr><name>ressize</name> += 2+4+1</expr>;</expr_stmt></then>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>Py_UNICODE_WIDE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<else>else
<expr_stmt><expr><name>ressize</name> += 2+5+1</expr>;</expr_stmt></else></if></else></if></else></if></else></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<else>else <if>if <condition>(<expr>*<name>p</name>&lt;100000</expr>)</condition><then>
<expr_stmt><expr><name>ressize</name> += 2+5+1</expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr>*<name>p</name>&lt;1000000</expr>)</condition><then>
<expr_stmt><expr><name>ressize</name> += 2+6+1</expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>ressize</name> += 2+7+1</expr>;</expr_stmt></else></if></else></if></else>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></for>
<expr_stmt><expr><name>res</name> = <call><name>PyUnicode_FromUnicode</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>ressize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>res</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<for>for (<init><expr><name>p</name> = <name>startp</name>+<name>start</name></expr>, <expr><name>outp</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</init>
<condition><expr><name>p</name> &lt; <name>startp</name>+<name>end</name></expr>;</condition> <incr><expr>++<name>p</name></expr></incr>) <block>{
<decl_stmt><decl><type><name>Py_UNICODE</name></type> <name>c</name> <init>= <expr>*<name>p</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>digits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>base</name></decl>;</decl_stmt>
<expr_stmt><expr>*<name>outp</name>++ = '&amp;'</expr>;</expr_stmt>
<expr_stmt><expr>*<name>outp</name>++ = '#'</expr>;</expr_stmt>
<if>if <condition>(<expr>*<name>p</name>&lt;10</expr>)</condition><then> <block>{
<expr_stmt><expr><name>digits</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name>base</name> = 1</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr>*<name>p</name>&lt;100</expr>)</condition><then> <block>{
<expr_stmt><expr><name>digits</name> = 2</expr>;</expr_stmt>
<expr_stmt><expr><name>base</name> = 10</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr>*<name>p</name>&lt;1000</expr>)</condition><then> <block>{
<expr_stmt><expr><name>digits</name> = 3</expr>;</expr_stmt>
<expr_stmt><expr><name>base</name> = 100</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr>*<name>p</name>&lt;10000</expr>)</condition><then> <block>{
<expr_stmt><expr><name>digits</name> = 4</expr>;</expr_stmt>
<expr_stmt><expr><name>base</name> = 1000</expr>;</expr_stmt>
}</block></then>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>Py_UNICODE_WIDE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<else>else <block>{
<expr_stmt><expr><name>digits</name> = 5</expr>;</expr_stmt>
<expr_stmt><expr><name>base</name> = 10000</expr>;</expr_stmt>
}</block></else></if></else></if></else></if></else></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<else>else <if>if <condition>(<expr>*<name>p</name>&lt;100000</expr>)</condition><then> <block>{
<expr_stmt><expr><name>digits</name> = 5</expr>;</expr_stmt>
<expr_stmt><expr><name>base</name> = 10000</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr>*<name>p</name>&lt;1000000</expr>)</condition><then> <block>{
<expr_stmt><expr><name>digits</name> = 6</expr>;</expr_stmt>
<expr_stmt><expr><name>base</name> = 100000</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>digits</name> = 7</expr>;</expr_stmt>
<expr_stmt><expr><name>base</name> = 1000000</expr>;</expr_stmt>
}</block></else></if></else></if></else>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<while>while <condition>(<expr><name>digits</name>--&gt;0</expr>)</condition> <block>{
<expr_stmt><expr>*<name>outp</name>++ = '0' + <name>c</name>/<name>base</name></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> %= <name>base</name></expr>;</expr_stmt>
<expr_stmt><expr><name>base</name> /= 10</expr>;</expr_stmt>
}</block></while>
<expr_stmt><expr>*<name>outp</name>++ = ';'</expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><name>restuple</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(On)"</expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>restuple</name></expr>;</return>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>wrong_exception_type</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></else></if>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <name>Py_UNICODE</name></type> <name><name>hexdigits</name><index>[]</index></name> <init>= <expr><block>{
<expr>'0'</expr>, <expr>'1'</expr>, <expr>'2'</expr>, <expr>'3'</expr>, <expr>'4'</expr>, <expr>'5'</expr>, <expr>'6'</expr>, <expr>'7'</expr>,
<expr>'8'</expr>, <expr>'9'</expr>, <expr>'a'</expr>, <expr>'b'</expr>, <expr>'c'</expr>, <expr>'d'</expr>, <expr>'e'</expr>, <expr>'f'</expr>
}</block></expr></init></decl>;</decl_stmt>
<function><type><name>PyObject</name> *</type><name>PyCodec_BackslashReplaceErrors</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>exc</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><call><name>PyObject_IsInstance</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr><name>PyExc_UnicodeEncodeError</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>restuple</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>object</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>start</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>startp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>outp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ressize</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyUnicodeEncodeError_GetStart</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr>&amp;<name>start</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>PyUnicodeEncodeError_GetEnd</name><argument_list>(<argument><expr><name>exc</name></expr></argument>, <argument><expr>&amp;<name>end</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr>!(<name>object</name> = <call><name>PyUnicodeEncodeError_GetObject</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>startp</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>p</name> = <name>startp</name>+<name>start</name></expr>, <expr><name>ressize</name> = 0</expr>;</init> <condition><expr><name>p</name> &lt; <name>startp</name>+<name>end</name></expr>;</condition> <incr><expr>++<name>p</name></expr></incr>) <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_UNICODE_WIDE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr>*<name>p</name> &gt;= 0x00010000</expr>)</condition><then>
<expr_stmt><expr><name>ressize</name> += 1+1+8</expr>;</expr_stmt></then>
<else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr>*<name>p</name> &gt;= 0x100</expr>)</condition><then> <block>{
<expr_stmt><expr><name>ressize</name> += 1+1+4</expr>;</expr_stmt>
}</block></then> <else>else
<expr_stmt><expr><name>ressize</name> += 1+1+2</expr>;</expr_stmt></else></if></else></if>
}</block></for>
<expr_stmt><expr><name>res</name> = <call><name>PyUnicode_FromUnicode</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>ressize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>res</name>==<name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<for>for (<init><expr><name>p</name> = <name>startp</name>+<name>start</name></expr>, <expr><name>outp</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</init>
<condition><expr><name>p</name> &lt; <name>startp</name>+<name>end</name></expr>;</condition> <incr><expr>++<name>p</name></expr></incr>) <block>{
<decl_stmt><decl><type><name>Py_UNICODE</name></type> <name>c</name> <init>= <expr>*<name>p</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr>*<name>outp</name>++ = '\\'</expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_UNICODE_WIDE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>c</name> &gt;= 0x00010000</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>outp</name>++ = 'U'</expr>;</expr_stmt>
<expr_stmt><expr>*<name>outp</name>++ = <name><name>hexdigits</name><index>[<expr>(<name>c</name>&gt;&gt;28)&amp;0xf</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>outp</name>++ = <name><name>hexdigits</name><index>[<expr>(<name>c</name>&gt;&gt;24)&amp;0xf</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>outp</name>++ = <name><name>hexdigits</name><index>[<expr>(<name>c</name>&gt;&gt;20)&amp;0xf</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>outp</name>++ = <name><name>hexdigits</name><index>[<expr>(<name>c</name>&gt;&gt;16)&amp;0xf</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>outp</name>++ = <name><name>hexdigits</name><index>[<expr>(<name>c</name>&gt;&gt;12)&amp;0xf</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>outp</name>++ = <name><name>hexdigits</name><index>[<expr>(<name>c</name>&gt;&gt;8)&amp;0xf</expr>]</index></name></expr>;</expr_stmt>
}</block></then> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><name>c</name> &gt;= 0x100</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>outp</name>++ = 'u'</expr>;</expr_stmt>
<expr_stmt><expr>*<name>outp</name>++ = <name><name>hexdigits</name><index>[<expr>(<name>c</name>&gt;&gt;12)&amp;0xf</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>outp</name>++ = <name><name>hexdigits</name><index>[<expr>(<name>c</name>&gt;&gt;8)&amp;0xf</expr>]</index></name></expr>;</expr_stmt>
}</block></then> <else>else
<expr_stmt><expr>*<name>outp</name>++ = 'x'</expr>;</expr_stmt></else></if></else></if>
<expr_stmt><expr>*<name>outp</name>++ = <name><name>hexdigits</name><index>[<expr>(<name>c</name>&gt;&gt;4)&amp;0xf</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>outp</name>++ = <name><name>hexdigits</name><index>[<expr><name>c</name>&amp;0xf</expr>]</index></name></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><name>restuple</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(On)"</expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>restuple</name></expr>;</return>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>wrong_exception_type</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></else></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type><name>strict_errors</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>exc</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>PyCodec_StrictErrors</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_USING_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type><name>ignore_errors</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>exc</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>PyCodec_IgnoreErrors</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type><name>replace_errors</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>exc</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>PyCodec_ReplaceErrors</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type><name>xmlcharrefreplace_errors</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>exc</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>PyCodec_XMLCharRefReplaceErrors</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type><name>backslashreplace_errors</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>exc</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>PyCodec_BackslashReplaceErrors</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>int</name></type> <name>_PyCodecRegistry_Init</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<struct><specifier>static</specifier> struct <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyMethodDef</name></type> <name>def</name></decl>;</decl_stmt>
}</block> <decl><name><name>methods</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{
<expr>"strict"</expr>,
<expr><block>{
<expr>"strict_errors"</expr>,
<expr><name>strict_errors</name></expr>,
<expr><name>METH_O</name></expr>
}</block></expr>
}</block></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_USING_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{
<expr>"ignore"</expr>,
<expr><block>{
<expr>"ignore_errors"</expr>,
<expr><name>ignore_errors</name></expr>,
<expr><name>METH_O</name></expr>
}</block></expr>
}</block></expr>,
<expr><block>{
<expr>"replace"</expr>,
<expr><block>{
<expr>"replace_errors"</expr>,
<expr><name>replace_errors</name></expr>,
<expr><name>METH_O</name></expr>
}</block></expr>
}</block></expr>,
<expr><block>{
<expr>"xmlcharrefreplace"</expr>,
<expr><block>{
<expr>"xmlcharrefreplace_errors"</expr>,
<expr><name>xmlcharrefreplace_errors</name></expr>,
<expr><name>METH_O</name></expr>
}</block></expr>
}</block></expr>,
<expr><block>{
<expr>"backslashreplace"</expr>,
<expr><block>{
<expr>"backslashreplace_errors"</expr>,
<expr><name>backslashreplace_errors</name></expr>,
<expr><name>METH_O</name></expr>
}</block></expr>
}</block></expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></expr></init></decl>;</struct>
<decl_stmt><decl><type><name>PyInterpreterState</name> *</type><name>interp</name> <init>= <expr><call><name>PyThreadState_GET</name><argument_list>()</argument_list></call>-&gt;<name>interp</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>mod</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name></type> <name>i</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>interp</name>-&gt;<name>codec_search_path</name></name> != <name>NULL</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><name><name>interp</name>-&gt;<name>codec_search_path</name></name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>interp</name>-&gt;<name>codec_search_cache</name></name> = <call><name>PyDict_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>interp</name>-&gt;<name>codec_error_registry</name></name> = <call><name>PyDict_New</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>interp</name>-&gt;<name>codec_error_registry</name></name></expr>)</condition><then> <block>{
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <sizeof>sizeof<argument_list>(<argument><expr><name>methods</name></expr></argument>)</argument_list></sizeof>/<sizeof>sizeof<argument_list>(<argument><expr><name><name>methods</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>func</name> <init>= <expr><call><name>PyCFunction_New</name><argument_list>(<argument><expr>&amp;<name><name>methods</name><index>[<expr><name>i</name></expr>]</index></name>.<name>def</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>func</name></expr>)</condition><then>
<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"can't initialize codec error registry"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>res</name> = <call><name>PyCodec_RegisterError</name><argument_list>(<argument><expr><name><name>methods</name><index>[<expr><name>i</name></expr>]</index></name>.<name>name</name></expr></argument>, <argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>func</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>res</name></expr>)</condition><then>
<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"can't initialize codec error registry"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></for>
}</block></then></if>
<if>if <condition>(<expr><name><name>interp</name>-&gt;<name>codec_search_path</name></name> == <name>NULL</name> ||
<name><name>interp</name>-&gt;<name>codec_search_cache</name></name> == <name>NULL</name> ||
<name><name>interp</name>-&gt;<name>codec_error_registry</name></name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"can't initialize codec registry"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>mod</name> = <call><name>PyImport_ImportModuleLevel</name><argument_list>(<argument><expr>"encodings"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>mod</name> == <name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_ImportError</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
</unit>
