<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="Objects/longobject.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"longintrepr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>KARATSUBA_CUTOFF</name></cpp:macro> <cpp:value>70</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>KARATSUBA_SQUARE_CUTOFF</name></cpp:macro> <cpp:value>(2 * KARATSUBA_CUTOFF)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FIVEARY_CUTOFF</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ABS</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((x) &lt; 0 ? -(x) : (x))</cpp:value></cpp:define>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>MIN</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>MAX</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX</name><parameter_list>(<param><type><name>x</name></type></param>, <param><type><name>y</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((x) &lt; (y) ? (y) : (x))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIN</name><parameter_list>(<param><type><name>x</name></type></param>, <param><type><name>y</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((x) &gt; (y) ? (y) : (x))</cpp:value></cpp:define>
<function_decl><type><specifier>static</specifier> <name>PyLongObject</name> *</type><name>long_normalize</name><parameter_list>(<param><decl><type><name>PyLongObject</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PyLongObject</name> *</type><name>mul1</name><parameter_list>(<param><decl><type><name>PyLongObject</name> *</type></decl></param>, <param><decl><type><name>wdigit</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PyLongObject</name> *</type><name>muladd1</name><parameter_list>(<param><decl><type><name>PyLongObject</name> *</type></decl></param>, <param><decl><type><name>wdigit</name></type></decl></param>, <param><decl><type><name>wdigit</name></type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PyLongObject</name> *</type><name>divrem1</name><parameter_list>(<param><decl><type><name>PyLongObject</name> *</type></decl></param>, <param><decl><type><name>digit</name></type></decl></param>, <param><decl><type><name>digit</name> *</type></decl></param>)</parameter_list>;</function_decl>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIGCHECK</name><parameter_list>(<param><type><name>PyTryBlock</name></type></param>)</parameter_list></cpp:macro> <cpp:value>if (--_Py_Ticker &lt; 0) { _Py_Ticker = _Py_CheckInterval; if (PyErr_CheckSignals()) PyTryBlock }</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>PyLongObject</name> *</type>
<name>long_normalize</name><parameter_list>(<param><decl><type><name>register</name> <name>PyLongObject</name> *</type><name>v</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>j</name> <init>= <expr><call><name>ABS</name><argument_list>(<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name> <init>= <expr><name>j</name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>i</name> &gt; 0 &amp;&amp; <name><name>v</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name>-1</expr>]</index></name> == 0</expr>)</condition>
<expr_stmt><expr>--<name>i</name></expr>;</expr_stmt></while>
<if>if <condition>(<expr><name>i</name> != <name>j</name></expr>)</condition><then>
<expr_stmt><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> = (<call><name>Py_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> &lt; 0) ? -(<name>i</name>) : <name>i</name></expr>;</expr_stmt></then></if>
<return>return <expr><name>v</name></expr>;</return>
}</block></function>
<function><type><name>PyLongObject</name> *</type>
<name>_PyLong_New</name><parameter_list>(<param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name>size</name> &gt; <name>PY_SSIZE_T_MAX</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>PyObject_NEW_VAR</name><argument_list>(<argument><expr><name>PyLongObject</name></expr></argument>, <argument><expr>&amp;<name>PyLong_Type</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type>
<name>_PyLong_Copy</name><parameter_list>(<param><decl><type><name>PyLongObject</name> *</type><name>src</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>src</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> = <name><name>src</name>-&gt;<name>ob_size</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>i</name> = -(<name>i</name>)</expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>result</name> = <call><name>_PyLong_New</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>result</name>-&gt;<name>ob_size</name></name> = <name><name>src</name>-&gt;<name>ob_size</name></name></expr>;</expr_stmt>
<while>while <condition>(<expr>--<name>i</name> &gt;= 0</expr>)</condition>
<expr_stmt><expr><name><name>result</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name> = <name><name>src</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></while>
}</block></then></if>
<return>return <expr>(<name>PyObject</name> *)<name>result</name></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type>
<name>PyLong_FromLong</name><parameter_list>(<param><decl><type><name>long</name></type> <name>ival</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>abs_ival</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>t</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ndigits</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>negative</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>ival</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>abs_ival</name> = <call>(<name>unsigned</name> <name>long</name>)<argument_list>(<argument><expr>-1-<name>ival</name></expr></argument>)</argument_list></call> + 1</expr>;</expr_stmt>
<expr_stmt><expr><name>negative</name> = 1</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>abs_ival</name> = (<name>unsigned</name> <name>long</name>)<name>ival</name></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><name>t</name> = <name>abs_ival</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>t</name></expr>)</condition> <block>{
<expr_stmt><expr>++<name>ndigits</name></expr>;</expr_stmt>
<expr_stmt><expr><name>t</name> &gt;&gt;= <name>PyLong_SHIFT</name></expr>;</expr_stmt>
}</block></while>
<expr_stmt><expr><name>v</name> = <call><name>_PyLong_New</name><argument_list>(<argument><expr><name>ndigits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> != <name>NULL</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>digit</name> *</type><name>p</name> <init>= <expr><name><name>v</name>-&gt;<name>ob_digit</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>v</name>-&gt;<name>ob_size</name></name> = <name>negative</name> ? -<name>ndigits</name> : <name>ndigits</name></expr>;</expr_stmt>
<expr_stmt><expr><name>t</name> = <name>abs_ival</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>t</name></expr>)</condition> <block>{
<expr_stmt><expr>*<name>p</name>++ = <call>(<name>digit</name>)<argument_list>(<argument><expr><name>t</name> &amp; <name>PyLong_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>t</name> &gt;&gt;= <name>PyLong_SHIFT</name></expr>;</expr_stmt>
}</block></while>
}</block></then></if>
<return>return <expr>(<name>PyObject</name> *)<name>v</name></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type>
<name>PyLong_FromUnsignedLong</name><parameter_list>(<param><decl><type><name>unsigned</name> <name>long</name></type> <name>ival</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>t</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ndigits</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>t</name> = (<name>unsigned</name> <name>long</name>)<name>ival</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>t</name></expr>)</condition> <block>{
<expr_stmt><expr>++<name>ndigits</name></expr>;</expr_stmt>
<expr_stmt><expr><name>t</name> &gt;&gt;= <name>PyLong_SHIFT</name></expr>;</expr_stmt>
}</block></while>
<expr_stmt><expr><name>v</name> = <call><name>_PyLong_New</name><argument_list>(<argument><expr><name>ndigits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> != <name>NULL</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>digit</name> *</type><name>p</name> <init>= <expr><name><name>v</name>-&gt;<name>ob_digit</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> = <name>ndigits</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>ival</name></expr>)</condition> <block>{
<expr_stmt><expr>*<name>p</name>++ = <call>(<name>digit</name>)<argument_list>(<argument><expr><name>ival</name> &amp; <name>PyLong_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ival</name> &gt;&gt;= <name>PyLong_SHIFT</name></expr>;</expr_stmt>
}</block></while>
}</block></then></if>
<return>return <expr>(<name>PyObject</name> *)<name>v</name></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type>
<name>PyLong_FromDouble</name><parameter_list>(<param><decl><type><name>double</name></type> <name>dval</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>frac</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>ndig</name></decl>, <decl><type ref="prev"/><name>expo</name></decl>, <decl><type ref="prev"/><name>neg</name></decl>;</decl_stmt>
<expr_stmt><expr><name>neg</name> = 0</expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>Py_IS_INFINITY</name><argument_list>(<argument><expr><name>dval</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
<argument><expr>"cannot convert float infinity to integer"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><call><name>Py_IS_NAN</name><argument_list>(<argument><expr><name>dval</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"cannot convert float NaN to integer"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>dval</name> &lt; 0.0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>neg</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name>dval</name> = -<name>dval</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>frac</name> = <call><name>frexp</name><argument_list>(<argument><expr><name>dval</name></expr></argument>, <argument><expr>&amp;<name>expo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>expo</name> &lt;= 0</expr>)</condition><then>
<return>return <expr><call><name>PyLong_FromLong</name><argument_list>(<argument><expr>0L</expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>ndig</name> = (<name>expo</name>-1) / <name>PyLong_SHIFT</name> + 1</expr>;</expr_stmt>
<expr_stmt><expr><name>v</name> = <call><name>_PyLong_New</name><argument_list>(<argument><expr><name>ndig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>frac</name> = <call><name>ldexp</name><argument_list>(<argument><expr><name>frac</name></expr></argument>, <argument><expr>(<name>expo</name>-1) % <name>PyLong_SHIFT</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = <name>ndig</name></expr>;</init> <condition><expr>--<name>i</name> &gt;= 0</expr>;</condition> <incr/>) <block>{
<decl_stmt><decl><type><name>long</name></type> <name>bits</name> <init>= <expr>(<name>long</name>)<name>frac</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>v</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name> = (<name>digit</name>) <name>bits</name></expr>;</expr_stmt>
<expr_stmt><expr><name>frac</name> = <name>frac</name> - (<name>double</name>)<name>bits</name></expr>;</expr_stmt>
<expr_stmt><expr><name>frac</name> = <call><name>ldexp</name><argument_list>(<argument><expr><name>frac</name></expr></argument>, <argument><expr><name>PyLong_SHIFT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<if>if <condition>(<expr><name>neg</name></expr>)</condition><then>
<expr_stmt><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> = -(<call><name>Py_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt></then></if>
<return>return <expr>(<name>PyObject</name> *)<name>v</name></expr>;</return>
}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PY_ABS_LONG_MIN</name></cpp:macro> <cpp:value>(0-(unsigned long)LONG_MIN)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PY_ABS_SSIZE_T_MIN</name></cpp:macro> <cpp:value>(0-(size_t)PY_SSIZE_T_MIN)</cpp:value></cpp:define>
<function><type><name>long</name></type>
<name>PyLong_AsLong</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>vv</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>register</name> <name>PyLongObject</name> *</type><name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>x</name></decl>, <decl><type ref="prev"/><name>prev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sign</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>vv</name> == <name>NULL</name> || !<call><name>PyLong_Check</name><argument_list>(<argument><expr><name>vv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>vv</name> != <name>NULL</name> &amp;&amp; <call><name>PyInt_Check</name><argument_list>(<argument><expr><name>vv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>vv</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>v</name> = (<name>PyLongObject</name> *)<name>vv</name></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> = <name><name>v</name>-&gt;<name>ob_size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>sign</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name>x</name> = 0</expr>;</expr_stmt>
<if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>sign</name> = -1</expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> = -(<name>i</name>)</expr>;</expr_stmt>
}</block></then></if>
<while>while <condition>(<expr>--<name>i</name> &gt;= 0</expr>)</condition> <block>{
<expr_stmt><expr><name>prev</name> = <name>x</name></expr>;</expr_stmt>
<expr_stmt><expr><name>x</name> = (<name>x</name> &lt;&lt; <name>PyLong_SHIFT</name>) + <name><name>v</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if>if <condition>(<expr>(<name>x</name> &gt;&gt; <name>PyLong_SHIFT</name>) != <name>prev</name></expr>)</condition><then>
<goto>goto <name>overflow</name>;</goto></then></if>
}</block></while>
<if>if <condition>(<expr><name>x</name> &lt;= (<name>unsigned</name> <name>long</name>)<name>LONG_MAX</name></expr>)</condition><then> <block>{
<return>return <expr>(<name>long</name>)<name>x</name> * <name>sign</name></expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><name>sign</name> &lt; 0 &amp;&amp; <name>x</name> == <name>PY_ABS_LONG_MIN</name></expr>)</condition><then> <block>{
<return>return <expr><name>LONG_MIN</name></expr>;</return>
}</block></then></if></else></if>
<label><name>overflow</name>:</label>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
<argument><expr>"long int too large to convert to int"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></function>
<function><type><name>Py_ssize_t</name></type>
<name>PyLong_AsSsize_t</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>vv</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>register</name> <name>PyLongObject</name> *</type><name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>x</name></decl>, <decl><type ref="prev"/><name>prev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sign</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>vv</name> == <name>NULL</name> || !<call><name>PyLong_Check</name><argument_list>(<argument><expr><name>vv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>v</name> = (<name>PyLongObject</name> *)<name>vv</name></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> = <name><name>v</name>-&gt;<name>ob_size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>sign</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name>x</name> = 0</expr>;</expr_stmt>
<if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>sign</name> = -1</expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> = -(<name>i</name>)</expr>;</expr_stmt>
}</block></then></if>
<while>while <condition>(<expr>--<name>i</name> &gt;= 0</expr>)</condition> <block>{
<expr_stmt><expr><name>prev</name> = <name>x</name></expr>;</expr_stmt>
<expr_stmt><expr><name>x</name> = (<name>x</name> &lt;&lt; <name>PyLong_SHIFT</name>) + <name><name>v</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if>if <condition>(<expr>(<name>x</name> &gt;&gt; <name>PyLong_SHIFT</name>) != <name>prev</name></expr>)</condition><then>
<goto>goto <name>overflow</name>;</goto></then></if>
}</block></while>
<if>if <condition>(<expr><name>x</name> &lt;= (<name>size_t</name>)<name>PY_SSIZE_T_MAX</name></expr>)</condition><then> <block>{
<return>return <expr>(<name>Py_ssize_t</name>)<name>x</name> * <name>sign</name></expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><name>sign</name> &lt; 0 &amp;&amp; <name>x</name> == <name>PY_ABS_SSIZE_T_MIN</name></expr>)</condition><then> <block>{
<return>return <expr><name>PY_SSIZE_T_MIN</name></expr>;</return>
}</block></then></if></else></if>
<label><name>overflow</name>:</label>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
<argument><expr>"long int too large to convert to int"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></function>
<function><type><name>unsigned</name> <name>long</name></type>
<name>PyLong_AsUnsignedLong</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>vv</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>register</name> <name>PyLongObject</name> *</type><name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>x</name></decl>, <decl><type ref="prev"/><name>prev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>vv</name> == <name>NULL</name> || !<call><name>PyLong_Check</name><argument_list>(<argument><expr><name>vv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>vv</name> != <name>NULL</name> &amp;&amp; <call><name>PyInt_Check</name><argument_list>(<argument><expr><name>vv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>long</name></type> <name>val</name> <init>= <expr><call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>vv</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>val</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
<argument><expr>"can't convert negative value to unsigned long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>unsigned</name> <name>long</name>) -1</expr>;</return>
}</block></then></if>
<return>return <expr><name>val</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>unsigned</name> <name>long</name>) -1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>v</name> = (<name>PyLongObject</name> *)<name>vv</name></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> = <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>x</name> = 0</expr>;</expr_stmt>
<if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
<argument><expr>"can't convert negative value to unsigned long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>unsigned</name> <name>long</name>) -1</expr>;</return>
}</block></then></if>
<while>while <condition>(<expr>--<name>i</name> &gt;= 0</expr>)</condition> <block>{
<expr_stmt><expr><name>prev</name> = <name>x</name></expr>;</expr_stmt>
<expr_stmt><expr><name>x</name> = (<name>x</name> &lt;&lt; <name>PyLong_SHIFT</name>) + <name><name>v</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if>if <condition>(<expr>(<name>x</name> &gt;&gt; <name>PyLong_SHIFT</name>) != <name>prev</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
<argument><expr>"long int too large to convert"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>unsigned</name> <name>long</name>) -1</expr>;</return>
}</block></then></if>
}</block></while>
<return>return <expr><name>x</name></expr>;</return>
}</block></function>
<function><type><name>unsigned</name> <name>long</name></type>
<name>PyLong_AsUnsignedLongMask</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>vv</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>register</name> <name>PyLongObject</name> *</type><name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>x</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sign</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>vv</name> == <name>NULL</name> || !<call><name>PyLong_Check</name><argument_list>(<argument><expr><name>vv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>vv</name> != <name>NULL</name> &amp;&amp; <call><name>PyInt_Check</name><argument_list>(<argument><expr><name>vv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>PyInt_AsUnsignedLongMask</name><argument_list>(<argument><expr><name>vv</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>unsigned</name> <name>long</name>) -1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>v</name> = (<name>PyLongObject</name> *)<name>vv</name></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> = <name><name>v</name>-&gt;<name>ob_size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>sign</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name>x</name> = 0</expr>;</expr_stmt>
<if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>sign</name> = -1</expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> = -<name>i</name></expr>;</expr_stmt>
}</block></then></if>
<while>while <condition>(<expr>--<name>i</name> &gt;= 0</expr>)</condition> <block>{
<expr_stmt><expr><name>x</name> = (<name>x</name> &lt;&lt; <name>PyLong_SHIFT</name>) + <name><name>v</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
}</block></while>
<return>return <expr><name>x</name> * <name>sign</name></expr>;</return>
}</block></function>
<function><type><name>int</name></type>
<name>_PyLong_Sign</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>vv</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>v</name> <init>= <expr>(<name>PyLongObject</name> *)<name>vv</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>v</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyLong_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> == 0 ? 0 : (<call><name>Py_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> &lt; 0 ? -1 : 1)</expr>;</return>
}</block></function>
<function><type><name>size_t</name></type>
<name>_PyLong_NumBits</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>vv</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>v</name> <init>= <expr>(<name>PyLongObject</name> *)<name>vv</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>result</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>ndigits</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>v</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyLong_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ndigits</name> = <call><name>ABS</name><argument_list>(<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ndigits</name> == 0 || <name><name>v</name>-&gt;<name>ob_digit</name><index>[<expr><name>ndigits</name> - 1</expr>]</index></name> != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ndigits</name> &gt; 0</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>digit</name></type> <name>msd</name> <init>= <expr><name><name>v</name>-&gt;<name>ob_digit</name><index>[<expr><name>ndigits</name> - 1</expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>result</name> = (<name>ndigits</name> - 1) * <name>PyLong_SHIFT</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> / <name>PyLong_SHIFT</name> != <call>(<name>size_t</name>)<argument_list>(<argument><expr><name>ndigits</name> - 1</expr></argument>)</argument_list></call></expr>)</condition><then>
<goto>goto <name>Overflow</name>;</goto></then></if>
<do>do <block>{
<expr_stmt><expr>++<name>result</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> == 0</expr>)</condition><then>
<goto>goto <name>Overflow</name>;</goto></then></if>
<expr_stmt><expr><name>msd</name> &gt;&gt;= 1</expr>;</expr_stmt>
}</block> while <condition>(<expr><name>msd</name></expr>)</condition>;</do>
}</block></then></if>
<return>return <expr><name>result</name></expr>;</return>
<label><name>Overflow</name>:</label>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>, <argument><expr>"long has too many bits "
"to express in a platform size_t"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>size_t</name>)-1</expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type>
<name>_PyLong_FromByteArray</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name>*</type> <name>bytes</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>n</name></decl></param>,
<param><decl><type><name>int</name></type> <name>little_endian</name></decl></param>, <param><decl><type><name>int</name></type> <name>is_signed</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name>*</type> <name>pstartbyte</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>incr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name>*</type> <name>pendbyte</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>numsignificantbytes</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>ndigits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyLongObject</name>*</type> <name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>idigit</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>n</name> == 0</expr>)</condition><then>
<return>return <expr><call><name>PyLong_FromLong</name><argument_list>(<argument><expr>0L</expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><name>little_endian</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>pstartbyte</name> = <name>bytes</name></expr>;</expr_stmt>
<expr_stmt><expr><name>pendbyte</name> = <name>bytes</name> + <name>n</name> - 1</expr>;</expr_stmt>
<expr_stmt><expr><name>incr</name> = 1</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>pstartbyte</name> = <name>bytes</name> + <name>n</name> - 1</expr>;</expr_stmt>
<expr_stmt><expr><name>pendbyte</name> = <name>bytes</name></expr>;</expr_stmt>
<expr_stmt><expr><name>incr</name> = -1</expr>;</expr_stmt>
}</block></else></if>
<if>if <condition>(<expr><name>is_signed</name></expr>)</condition><then>
<expr_stmt><expr><name>is_signed</name> = *<name>pendbyte</name> &gt;= 0x80</expr>;</expr_stmt></then></if>
<block>{
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name>*</type> <name>p</name> <init>= <expr><name>pendbyte</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>pincr</name> <init>= <expr>-<name>incr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name>insignficant</name> <init>= <expr><name>is_signed</name> ? 0xff : 0x00</expr></init></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr>++<name>i</name></expr>, <expr><name>p</name> += <name>pincr</name></expr></incr>) <block>{
<if>if <condition>(<expr>*<name>p</name> != <name>insignficant</name></expr>)</condition><then>
<break>break;</break></then></if>
}</block></for>
<expr_stmt><expr><name>numsignificantbytes</name> = <name>n</name> - <name>i</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>is_signed</name> &amp;&amp; <name>numsignificantbytes</name> &lt; <name>n</name></expr>)</condition><then>
<expr_stmt><expr>++<name>numsignificantbytes</name></expr>;</expr_stmt></then></if>
}</block>
<expr_stmt><expr><name>ndigits</name> = (<name>numsignificantbytes</name> * 8 + <name>PyLong_SHIFT</name> - 1) / <name>PyLong_SHIFT</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ndigits</name> &gt; (<name>size_t</name>)<name>INT_MAX</name></expr>)</condition><then>
<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>v</name> = <call><name>_PyLong_New</name><argument_list>(<argument><expr>(<name>int</name>)<name>ndigits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<block>{
<decl_stmt><decl><type><name>size_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>twodigits</name></type> <name>carry</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>twodigits</name></type> <name>accum</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>accumbits</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name>*</type> <name>p</name> <init>= <expr><name>pstartbyte</name></expr></init></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>numsignificantbytes</name></expr>;</condition> <incr><expr>++<name>i</name></expr>, <expr><name>p</name> += <name>incr</name></expr></incr>) <block>{
<decl_stmt><decl><type><name>twodigits</name></type> <name>thisbyte</name> <init>= <expr>*<name>p</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>is_signed</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>thisbyte</name> = (0xff ^ <name>thisbyte</name>) + <name>carry</name></expr>;</expr_stmt>
<expr_stmt><expr><name>carry</name> = <name>thisbyte</name> &gt;&gt; 8</expr>;</expr_stmt>
<expr_stmt><expr><name>thisbyte</name> &amp;= 0xff</expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>accum</name> |= <name>thisbyte</name> &lt;&lt; <name>accumbits</name></expr>;</expr_stmt>
<expr_stmt><expr><name>accumbits</name> += 8</expr>;</expr_stmt>
<if>if <condition>(<expr><name>accumbits</name> &gt;= <name>PyLong_SHIFT</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>idigit</name> &lt; (<name>int</name>)<name>ndigits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>v</name>-&gt;<name>ob_digit</name><index>[<expr><name>idigit</name></expr>]</index></name> = <call>(<name>digit</name>)<argument_list>(<argument><expr><name>accum</name> &amp; <name>PyLong_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>++<name>idigit</name></expr>;</expr_stmt>
<expr_stmt><expr><name>accum</name> &gt;&gt;= <name>PyLong_SHIFT</name></expr>;</expr_stmt>
<expr_stmt><expr><name>accumbits</name> -= <name>PyLong_SHIFT</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>accumbits</name> &lt; <name>PyLong_SHIFT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></for>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>accumbits</name> &lt; <name>PyLong_SHIFT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>accumbits</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>idigit</name> &lt; (<name>int</name>)<name>ndigits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>v</name>-&gt;<name>ob_digit</name><index>[<expr><name>idigit</name></expr>]</index></name> = (<name>digit</name>)<name>accum</name></expr>;</expr_stmt>
<expr_stmt><expr>++<name>idigit</name></expr>;</expr_stmt>
}</block></then></if>
}</block>
<expr_stmt><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> = <name>is_signed</name> ? -<name>idigit</name> : <name>idigit</name></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *)<call><name>long_normalize</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>int</name></type>
<name>_PyLong_AsByteArray</name><parameter_list>(<param><decl><type><name>PyLongObject</name>*</type> <name>v</name></decl></param>,
<param><decl><type><name>unsigned</name> <name>char</name>*</type> <name>bytes</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>n</name></decl></param>,
<param><decl><type><name>int</name></type> <name>little_endian</name></decl></param>, <param><decl><type><name>int</name></type> <name>is_signed</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>ndigits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>twodigits</name></type> <name>accum</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>accumbits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>do_twos_comp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>twodigits</name></type> <name>carry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name>*</type> <name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>pincr</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>v</name> != <name>NULL</name> &amp;&amp; <call><name>PyLong_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>ndigits</name> = -(<call><name>Py_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>is_signed</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"can't convert negative long to unsigned"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>do_twos_comp</name> = 1</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>ndigits</name> = <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>do_twos_comp</name> = 0</expr>;</expr_stmt>
}</block></else></if>
<if>if <condition>(<expr><name>little_endian</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>p</name> = <name>bytes</name></expr>;</expr_stmt>
<expr_stmt><expr><name>pincr</name> = 1</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>p</name> = <name>bytes</name> + <name>n</name> - 1</expr>;</expr_stmt>
<expr_stmt><expr><name>pincr</name> = -1</expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ndigits</name> == 0 || <name><name>v</name>-&gt;<name>ob_digit</name><index>[<expr><name>ndigits</name> - 1</expr>]</index></name> != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>accum</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>accumbits</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>carry</name> = <name>do_twos_comp</name> ? 1 : 0</expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>ndigits</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<decl_stmt><decl><type><name>twodigits</name></type> <name>thisdigit</name> <init>= <expr><name><name>v</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>do_twos_comp</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>thisdigit</name> = (<name>thisdigit</name> ^ <name>PyLong_MASK</name>) + <name>carry</name></expr>;</expr_stmt>
<expr_stmt><expr><name>carry</name> = <name>thisdigit</name> &gt;&gt; <name>PyLong_SHIFT</name></expr>;</expr_stmt>
<expr_stmt><expr><name>thisdigit</name> &amp;= <name>PyLong_MASK</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>accum</name> |= <name>thisdigit</name> &lt;&lt; <name>accumbits</name></expr>;</expr_stmt>
<expr_stmt><expr><name>accumbits</name> += <name>PyLong_SHIFT</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>i</name> == <name>ndigits</name> - 1</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>stwodigits</name></type> <name>s</name> <init>= <expr><call>(<name>stwodigits</name>)<argument_list>(<argument><expr><name>thisdigit</name> &lt;&lt;
(8*<sizeof>sizeof<argument_list>(<argument><expr><name>stwodigits</name></expr></argument>)</argument_list></sizeof> - <name>PyLong_SHIFT</name>)</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>nsignbits</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr>(<name>s</name> &lt; 0) == <name>do_twos_comp</name> &amp;&amp; <name>nsignbits</name> &lt; <name>PyLong_SHIFT</name></expr>)</condition> <block>{
<expr_stmt><expr>++<name>nsignbits</name></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> &lt;&lt;= 1</expr>;</expr_stmt>
}</block></while>
<expr_stmt><expr><name>accumbits</name> -= <name>nsignbits</name></expr>;</expr_stmt>
}</block></then></if>
<while>while <condition>(<expr><name>accumbits</name> &gt;= 8</expr>)</condition> <block>{
<if>if <condition>(<expr><name>j</name> &gt;= <name>n</name></expr>)</condition><then>
<goto>goto <name>Overflow</name>;</goto></then></if>
<expr_stmt><expr>++<name>j</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name> = <call>(<name>unsigned</name> <name>char</name>)<argument_list>(<argument><expr><name>accum</name> &amp; 0xff</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> += <name>pincr</name></expr>;</expr_stmt>
<expr_stmt><expr><name>accumbits</name> -= 8</expr>;</expr_stmt>
<expr_stmt><expr><name>accum</name> &gt;&gt;= 8</expr>;</expr_stmt>
}</block></while>
}</block></for>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>accumbits</name> &lt; 8</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>carry</name> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>accumbits</name> &gt; 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>j</name> &gt;= <name>n</name></expr>)</condition><then>
<goto>goto <name>Overflow</name>;</goto></then></if>
<expr_stmt><expr>++<name>j</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>do_twos_comp</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>accum</name> |= (~(<name>twodigits</name>)0) &lt;&lt; <name>accumbits</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr>*<name>p</name> = <call>(<name>unsigned</name> <name>char</name>)<argument_list>(<argument><expr><name>accum</name> &amp; 0xff</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> += <name>pincr</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>j</name> == <name>n</name> &amp;&amp; <name>n</name> &gt; 0 &amp;&amp; <name>is_signed</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>msb</name> <init>= <expr>*(<name>p</name> - <name>pincr</name>)</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sign_bit_set</name> <init>= <expr><name>msb</name> &gt;= 0x80</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>accumbits</name> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>sign_bit_set</name> == <name>do_twos_comp</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then>
<else>else
<goto>goto <name>Overflow</name>;</goto></else></if>
}</block></then></if></else></if>
<block>{
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>signbyte</name> <init>= <expr><name>do_twos_comp</name> ? 0xffU : 0U</expr></init></decl>;</decl_stmt>
<for>for ( <init>;</init> <condition><expr><name>j</name> &lt; <name>n</name></expr>;</condition> <incr><expr>++<name>j</name></expr>, <expr><name>p</name> += <name>pincr</name></expr></incr>)
<expr_stmt><expr>*<name>p</name> = <name>signbyte</name></expr>;</expr_stmt></for>
}</block>
<return>return <expr>0</expr>;</return>
<label><name>Overflow</name>:</label>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>, <argument><expr>"long too big to convert"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></function>
<function><type><name>double</name></type>
<name>_PyLong_AsScaledDouble</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>vv</name></decl></param>, <param><decl><type><name>int</name> *</type><name>exponent</name></decl></param>)</parameter_list> <block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NBITS_WANTED</name></cpp:macro> <cpp:value>57</cpp:value></cpp:define>
<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>x</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>double</name></type> <name>multiplier</name> <init>= <expr><call>(<name>double</name>)<argument_list>(<argument><expr>1L &lt;&lt; <name>PyLong_SHIFT</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sign</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nbitsneeded</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>vv</name> == <name>NULL</name> || !<call><name>PyLong_Check</name><argument_list>(<argument><expr><name>vv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>v</name> = (<name>PyLongObject</name> *)<name>vv</name></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> = <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>sign</name> = 1</expr>;</expr_stmt>
<if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>sign</name> = -1</expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> = -(<name>i</name>)</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>i</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>exponent</name> = 0</expr>;</expr_stmt>
<return>return <expr>0.0</expr>;</return>
}</block></then></if></else></if>
<expr_stmt><expr>--<name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><name>x</name> = (<name>double</name>)<name><name>v</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>nbitsneeded</name> = <name>NBITS_WANTED</name> - 1</expr>;</expr_stmt>
<while>while <condition>(<expr><name>i</name> &gt; 0 &amp;&amp; <name>nbitsneeded</name> &gt; 0</expr>)</condition> <block>{
<expr_stmt><expr>--<name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><name>x</name> = <name>x</name> * <name>multiplier</name> + (<name>double</name>)<name><name>v</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>nbitsneeded</name> -= <name>PyLong_SHIFT</name></expr>;</expr_stmt>
}</block></while>
<expr_stmt><expr>*<name>exponent</name> = <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>x</name> &gt; 0.0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>x</name> * <name>sign</name></expr>;</return>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>NBITS_WANTED</name></cpp:undef>
}</block></function>
<function><type><name>double</name></type>
<name>PyLong_AsDouble</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>vv</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>e</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>x</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>vv</name> == <name>NULL</name> || !<call><name>PyLong_Check</name><argument_list>(<argument><expr><name>vv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>x</name> = <call><name>_PyLong_AsScaledDouble</name><argument_list>(<argument><expr><name>vv</name></expr></argument>, <argument><expr>&amp;<name>e</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>x</name> == -1.0 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr>-1.0</expr>;</return></then></if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>e</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>e</name> &gt; <name>INT_MAX</name> / <name>PyLong_SHIFT</name></expr>)</condition><then>
<goto>goto <name>overflow</name>;</goto></then></if>
<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>x</name> = <call><name>ldexp</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>e</name> * <name>PyLong_SHIFT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>Py_OVERFLOWED</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<goto>goto <name>overflow</name>;</goto></then></if>
<return>return <expr><name>x</name></expr>;</return>
<label><name>overflow</name>:</label>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
<argument><expr>"long int too large to convert to float"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1.0</expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type>
<name>PyLong_FromVoidPtr</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>p</name></decl></param>)</parameter_list> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_VOID_P</name> &lt;= <name>SIZEOF_LONG</name></expr></cpp:if>
<if>if <condition>(<expr>(<name>long</name>)<name>p</name> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name>PyLong_FromUnsignedLong</name><argument_list>(<argument><expr>(<name>unsigned</name> <name>long</name>)<name>p</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name>p</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LONG_LONG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:error>#<cpp:directive>error</cpp:directive> "PyLong_FromVoidPtr: sizeof(void*) &gt; sizeof(long), but no long long"</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_LONG_LONG</name> &lt; <name>SIZEOF_VOID_P</name></expr></cpp:if>
<cpp:error>#<cpp:directive>error</cpp:directive> "PyLong_FromVoidPtr: sizeof(PY_LONG_LONG) &lt; sizeof(void*)"</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><name>p</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>
<return>return <expr><call><name>PyLong_FromUnsignedLongLong</name><argument_list>(<argument><expr>(<name>unsigned</name> <name>PY_LONG_LONG</name>)<name>p</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>
<function><type><name>void</name> *</type>
<name>PyLong_AsVoidPtr</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>vv</name></decl></param>)</parameter_list> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_VOID_P</name> &lt;= <name>SIZEOF_LONG</name></expr></cpp:if>
<decl_stmt><decl><type><name>long</name></type> <name>x</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>vv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>x</name> = <call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><name>vv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><call><name>PyLong_Check</name><argument_list>(<argument><expr><name>vv</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>_PyLong_Sign</name><argument_list>(<argument><expr><name>vv</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>x</name> = <call><name>PyLong_AsLong</name><argument_list>(<argument><expr><name>vv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>x</name> = <call><name>PyLong_AsUnsignedLong</name><argument_list>(<argument><expr><name>vv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LONG_LONG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:error>#<cpp:directive>error</cpp:directive> "PyLong_AsVoidPtr: sizeof(void*) &gt; sizeof(long), but no long long"</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_LONG_LONG</name> &lt; <name>SIZEOF_VOID_P</name></expr></cpp:if>
<cpp:error>#<cpp:directive>error</cpp:directive> "PyLong_AsVoidPtr: sizeof(PY_LONG_LONG) &lt; sizeof(void*)"</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>PY_LONG_LONG</name></type> <name>x</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>vv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>x</name> = <call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><name>vv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><call><name>PyLong_Check</name><argument_list>(<argument><expr><name>vv</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>_PyLong_Sign</name><argument_list>(<argument><expr><name>vv</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>x</name> = <call><name>PyLong_AsLongLong</name><argument_list>(<argument><expr><name>vv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>x</name> = <call><name>PyLong_AsUnsignedLongLong</name><argument_list>(<argument><expr><name>vv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><name>x</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr>(<name>void</name> *)<name>x</name></expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LONG_LONG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_LITTLE_ENDIAN</name></cpp:macro> <cpp:value>(int)*(unsigned char*)&amp;one</cpp:value></cpp:define>
<function><type><name>PyObject</name> *</type>
<name>PyLong_FromLongLong</name><parameter_list>(<param><decl><type><name>PY_LONG_LONG</name></type> <name>ival</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>PY_LONG_LONG</name></type> <name>abs_ival</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>PY_LONG_LONG</name></type> <name>t</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ndigits</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>negative</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>ival</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>abs_ival</name> = <call>(<name>unsigned</name> <name>PY_LONG_LONG</name>)<argument_list>(<argument><expr>-1-<name>ival</name></expr></argument>)</argument_list></call> + 1</expr>;</expr_stmt>
<expr_stmt><expr><name>negative</name> = 1</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>abs_ival</name> = (<name>unsigned</name> <name>PY_LONG_LONG</name>)<name>ival</name></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><name>t</name> = <name>abs_ival</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>t</name></expr>)</condition> <block>{
<expr_stmt><expr>++<name>ndigits</name></expr>;</expr_stmt>
<expr_stmt><expr><name>t</name> &gt;&gt;= <name>PyLong_SHIFT</name></expr>;</expr_stmt>
}</block></while>
<expr_stmt><expr><name>v</name> = <call><name>_PyLong_New</name><argument_list>(<argument><expr><name>ndigits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> != <name>NULL</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>digit</name> *</type><name>p</name> <init>= <expr><name><name>v</name>-&gt;<name>ob_digit</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> = <name>negative</name> ? -<name>ndigits</name> : <name>ndigits</name></expr>;</expr_stmt>
<expr_stmt><expr><name>t</name> = <name>abs_ival</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>t</name></expr>)</condition> <block>{
<expr_stmt><expr>*<name>p</name>++ = <call>(<name>digit</name>)<argument_list>(<argument><expr><name>t</name> &amp; <name>PyLong_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>t</name> &gt;&gt;= <name>PyLong_SHIFT</name></expr>;</expr_stmt>
}</block></while>
}</block></then></if>
<return>return <expr>(<name>PyObject</name> *)<name>v</name></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type>
<name>PyLong_FromUnsignedLongLong</name><parameter_list>(<param><decl><type><name>unsigned</name> <name>PY_LONG_LONG</name></type> <name>ival</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>PY_LONG_LONG</name></type> <name>t</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ndigits</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>t</name> = (<name>unsigned</name> <name>PY_LONG_LONG</name>)<name>ival</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>t</name></expr>)</condition> <block>{
<expr_stmt><expr>++<name>ndigits</name></expr>;</expr_stmt>
<expr_stmt><expr><name>t</name> &gt;&gt;= <name>PyLong_SHIFT</name></expr>;</expr_stmt>
}</block></while>
<expr_stmt><expr><name>v</name> = <call><name>_PyLong_New</name><argument_list>(<argument><expr><name>ndigits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> != <name>NULL</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>digit</name> *</type><name>p</name> <init>= <expr><name><name>v</name>-&gt;<name>ob_digit</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> = <name>ndigits</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>ival</name></expr>)</condition> <block>{
<expr_stmt><expr>*<name>p</name>++ = <call>(<name>digit</name>)<argument_list>(<argument><expr><name>ival</name> &amp; <name>PyLong_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ival</name> &gt;&gt;= <name>PyLong_SHIFT</name></expr>;</expr_stmt>
}</block></while>
}</block></then></if>
<return>return <expr>(<name>PyObject</name> *)<name>v</name></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type>
<name>PyLong_FromSsize_t</name><parameter_list>(<param><decl><type><name>Py_ssize_t</name></type> <name>ival</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>bytes</name> <init>= <expr><name>ival</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>one</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>_PyLong_FromByteArray</name><argument_list>(
<argument><expr>(<name>unsigned</name> <name>char</name> *)&amp;<name>bytes</name></expr></argument>,
<argument><expr><name>SIZEOF_SIZE_T</name></expr></argument>, <argument><expr><name>IS_LITTLE_ENDIAN</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type>
<name>PyLong_FromSize_t</name><parameter_list>(<param><decl><type><name>size_t</name></type> <name>ival</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>size_t</name></type> <name>bytes</name> <init>= <expr><name>ival</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>one</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>_PyLong_FromByteArray</name><argument_list>(
<argument><expr>(<name>unsigned</name> <name>char</name> *)&amp;<name>bytes</name></expr></argument>,
<argument><expr><name>SIZEOF_SIZE_T</name></expr></argument>, <argument><expr><name>IS_LITTLE_ENDIAN</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>PY_LONG_LONG</name></type>
<name>PyLong_AsLongLong</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>vv</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PY_LONG_LONG</name></type> <name>bytes</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>one</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>vv</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>!<call><name>PyLong_Check</name><argument_list>(<argument><expr><name>vv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyNumberMethods</name> *</type><name>nb</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>io</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>vv</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>(<name>PY_LONG_LONG</name>)<call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>vv</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr>(<name>nb</name> = <name><name>vv</name>-&gt;<name>ob_type</name>-&gt;<name>tp_as_number</name></name>) == <name>NULL</name> ||
<name><name>nb</name>-&gt;<name>nb_int</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"an integer is required"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>io</name> = <call>(*<name><name>nb</name>-&gt;<name>nb_int</name></name>) <argument_list>(<argument><expr><name>vv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>io</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>io</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>bytes</name> = <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>io</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>io</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>bytes</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><call><name>PyLong_Check</name><argument_list>(<argument><expr><name>io</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>bytes</name> = <call><name>PyLong_AsLongLong</name><argument_list>(<argument><expr><name>io</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>io</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>bytes</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>io</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"integer conversion failed"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>res</name> = <call><name>_PyLong_AsByteArray</name><argument_list>(
<argument><expr>(<name>PyLongObject</name> *)<name>vv</name></expr></argument>, <argument><expr>(<name>unsigned</name> <name>char</name> *)&amp;<name>bytes</name></expr></argument>,
<argument><expr><name>SIZEOF_LONG_LONG</name></expr></argument>, <argument><expr><name>IS_LITTLE_ENDIAN</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then>
<return>return <expr>(<name>PY_LONG_LONG</name>)-1</expr>;</return></then>
<else>else
<return>return <expr><name>bytes</name></expr>;</return></else></if>
}</block></function>
<function><type><name>unsigned</name> <name>PY_LONG_LONG</name></type>
<name>PyLong_AsUnsignedLongLong</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>vv</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>PY_LONG_LONG</name></type> <name>bytes</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>one</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>vv</name> == <name>NULL</name> || !<call><name>PyLong_Check</name><argument_list>(<argument><expr><name>vv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>unsigned</name> <name>PY_LONG_LONG</name>)-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>res</name> = <call><name>_PyLong_AsByteArray</name><argument_list>(
<argument><expr>(<name>PyLongObject</name> *)<name>vv</name></expr></argument>, <argument><expr>(<name>unsigned</name> <name>char</name> *)&amp;<name>bytes</name></expr></argument>,
<argument><expr><name>SIZEOF_LONG_LONG</name></expr></argument>, <argument><expr><name>IS_LITTLE_ENDIAN</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>res</name> &lt; 0</expr>)</condition><then>
<return>return <expr>(<name>unsigned</name> <name>PY_LONG_LONG</name>)<name>res</name></expr>;</return></then>
<else>else
<return>return <expr><name>bytes</name></expr>;</return></else></if>
}</block></function>
<function><type><name>unsigned</name> <name>PY_LONG_LONG</name></type>
<name>PyLong_AsUnsignedLongLongMask</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>vv</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>register</name> <name>PyLongObject</name> *</type><name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>PY_LONG_LONG</name></type> <name>x</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sign</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>vv</name> == <name>NULL</name> || !<call><name>PyLong_Check</name><argument_list>(<argument><expr><name>vv</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>unsigned</name> <name>long</name>) -1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>v</name> = (<name>PyLongObject</name> *)<name>vv</name></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> = <name><name>v</name>-&gt;<name>ob_size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>sign</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name>x</name> = 0</expr>;</expr_stmt>
<if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>sign</name> = -1</expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> = -<name>i</name></expr>;</expr_stmt>
}</block></then></if>
<while>while <condition>(<expr>--<name>i</name> &gt;= 0</expr>)</condition> <block>{
<expr_stmt><expr><name>x</name> = (<name>x</name> &lt;&lt; <name>PyLong_SHIFT</name>) + <name><name>v</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
}</block></while>
<return>return <expr><name>x</name> * <name>sign</name></expr>;</return>
}</block></function>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>IS_LITTLE_ENDIAN</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>convert_binop</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>, <param><decl><type><name>PyLongObject</name> **</type><name>a</name></decl></param>, <param><decl><type><name>PyLongObject</name> **</type><name>b</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><call><name>PyLong_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>a</name> = (<name>PyLongObject</name> *) <name>v</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>a</name> = (<name>PyLongObject</name> *) <call><name>PyLong_FromLong</name><argument_list>(<argument><expr><call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<return>return <expr>0</expr>;</return>
}</block></else></if></else></if>
<if>if <condition>(<expr><call><name>PyLong_Check</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>b</name> = (<name>PyLongObject</name> *) <name>w</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>b</name> = (<name>PyLongObject</name> *) <call><name>PyLong_FromLong</name><argument_list>(<argument><expr><call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr>*<name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></else></if></else></if>
<return>return <expr>1</expr>;</return>
}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONVERT_BINOP</name><parameter_list>(<param><type><name>v</name></type></param>, <param><type><name>w</name></type></param>, <param><type><name>a</name></type></param>, <param><type><name>b</name></type></param>)</parameter_list></cpp:macro> <cpp:value>if (!convert_binop(v, w, a, b)) { Py_INCREF(Py_NotImplemented); return Py_NotImplemented; }</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>digit</name></type>
<name>v_iadd</name><parameter_list>(<param><decl><type><name>digit</name> *</type><name>x</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>m</name></decl></param>, <param><decl><type><name>digit</name> *</type><name>y</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>n</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>digit</name></type> <name>carry</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>m</name> &gt;= <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<expr_stmt><expr><name>carry</name> += <name><name>x</name><index>[<expr><name>i</name></expr>]</index></name> + <name><name>y</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>x</name><index>[<expr><name>i</name></expr>]</index></name> = <name>carry</name> &amp; <name>PyLong_MASK</name></expr>;</expr_stmt>
<expr_stmt><expr><name>carry</name> &gt;&gt;= <name>PyLong_SHIFT</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>(<name>carry</name> &amp; 1) == <name>carry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<for>for (<init>;</init> <condition><expr><name>carry</name> &amp;&amp; <name>i</name> &lt; <name>m</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<expr_stmt><expr><name>carry</name> += <name><name>x</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>x</name><index>[<expr><name>i</name></expr>]</index></name> = <name>carry</name> &amp; <name>PyLong_MASK</name></expr>;</expr_stmt>
<expr_stmt><expr><name>carry</name> &gt;&gt;= <name>PyLong_SHIFT</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>(<name>carry</name> &amp; 1) == <name>carry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<return>return <expr><name>carry</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>digit</name></type>
<name>v_isub</name><parameter_list>(<param><decl><type><name>digit</name> *</type><name>x</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>m</name></decl></param>, <param><decl><type><name>digit</name> *</type><name>y</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>n</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>digit</name></type> <name>borrow</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>m</name> &gt;= <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<expr_stmt><expr><name>borrow</name> = <name><name>x</name><index>[<expr><name>i</name></expr>]</index></name> - <name><name>y</name><index>[<expr><name>i</name></expr>]</index></name> - <name>borrow</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>x</name><index>[<expr><name>i</name></expr>]</index></name> = <name>borrow</name> &amp; <name>PyLong_MASK</name></expr>;</expr_stmt>
<expr_stmt><expr><name>borrow</name> &gt;&gt;= <name>PyLong_SHIFT</name></expr>;</expr_stmt>
<expr_stmt><expr><name>borrow</name> &amp;= 1</expr>;</expr_stmt>
}</block></for>
<for>for (<init>;</init> <condition><expr><name>borrow</name> &amp;&amp; <name>i</name> &lt; <name>m</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<expr_stmt><expr><name>borrow</name> = <name><name>x</name><index>[<expr><name>i</name></expr>]</index></name> - <name>borrow</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>x</name><index>[<expr><name>i</name></expr>]</index></name> = <name>borrow</name> &amp; <name>PyLong_MASK</name></expr>;</expr_stmt>
<expr_stmt><expr><name>borrow</name> &gt;&gt;= <name>PyLong_SHIFT</name></expr>;</expr_stmt>
<expr_stmt><expr><name>borrow</name> &amp;= 1</expr>;</expr_stmt>
}</block></for>
<return>return <expr><name>borrow</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyLongObject</name> *</type>
<name>mul1</name><parameter_list>(<param><decl><type><name>PyLongObject</name> *</type><name>a</name></decl></param>, <param><decl><type><name>wdigit</name></type> <name>n</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>muladd1</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr>(<name>digit</name>)0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyLongObject</name> *</type>
<name>muladd1</name><parameter_list>(<param><decl><type><name>PyLongObject</name> *</type><name>a</name></decl></param>, <param><decl><type><name>wdigit</name></type> <name>n</name></decl></param>, <param><decl><type><name>wdigit</name></type> <name>extra</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size_a</name> <init>= <expr><call><name>ABS</name><argument_list>(<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>z</name> <init>= <expr><call><name>_PyLong_New</name><argument_list>(<argument><expr><name>size_a</name>+1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>twodigits</name></type> <name>carry</name> <init>= <expr><name>extra</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>z</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>size_a</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<expr_stmt><expr><name>carry</name> += (<name>twodigits</name>)<name><name>a</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name> * <name>n</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>z</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name> = <call>(<name>digit</name>) <argument_list>(<argument><expr><name>carry</name> &amp; <name>PyLong_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>carry</name> &gt;&gt;= <name>PyLong_SHIFT</name></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><name><name>z</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name> = (<name>digit</name>) <name>carry</name></expr>;</expr_stmt>
<return>return <expr><call><name>long_normalize</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>digit</name></type>
<name>inplace_divrem1</name><parameter_list>(<param><decl><type><name>digit</name> *</type><name>pout</name></decl></param>, <param><decl><type><name>digit</name> *</type><name>pin</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>, <param><decl><type><name>digit</name></type> <name>n</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>twodigits</name></type> <name>rem</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n</name> &gt; 0 &amp;&amp; <name>n</name> &lt;= <name>PyLong_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>pin</name> += <name>size</name></expr>;</expr_stmt>
<expr_stmt><expr><name>pout</name> += <name>size</name></expr>;</expr_stmt>
<while>while <condition>(<expr>--<name>size</name> &gt;= 0</expr>)</condition> <block>{
<decl_stmt><decl><type><name>digit</name></type> <name>hi</name></decl>;</decl_stmt>
<expr_stmt><expr><name>rem</name> = (<name>rem</name> &lt;&lt; <name>PyLong_SHIFT</name>) + *--<name>pin</name></expr>;</expr_stmt>
<expr_stmt><expr>*--<name>pout</name> = <name>hi</name> = <call>(<name>digit</name>)<argument_list>(<argument><expr><name>rem</name> / <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rem</name> -= <name>hi</name> * <name>n</name></expr>;</expr_stmt>
}</block></while>
<return>return <expr>(<name>digit</name>)<name>rem</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyLongObject</name> *</type>
<name>divrem1</name><parameter_list>(<param><decl><type><name>PyLongObject</name> *</type><name>a</name></decl></param>, <param><decl><type><name>digit</name></type> <name>n</name></decl></param>, <param><decl><type><name>digit</name> *</type><name>prem</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>Py_ssize_t</name></type> <name>size</name> <init>= <expr><call><name>ABS</name><argument_list>(<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>z</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>n</name> &gt; 0 &amp;&amp; <name>n</name> &lt;= <name>PyLong_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>z</name> = <call><name>_PyLong_New</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>z</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr>*<name>prem</name> = <call><name>inplace_divrem1</name><argument_list>(<argument><expr><name><name>z</name>-&gt;<name>ob_digit</name></name></expr></argument>, <argument><expr><name><name>a</name>-&gt;<name>ob_digit</name></name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>long_normalize</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<macro><name>PyAPI_FUNC</name><argument_list>(<argument>PyObject *</argument>)</argument_list></macro>
<macro><name>_PyLong_Format</name><argument_list>(<argument>PyObject *aa</argument>, <argument>int base</argument>, <argument>int addL</argument>, <argument>int newstyle</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>register</name> <name>PyLongObject</name> *</type><name>a</name> <init>= <expr>(<name>PyLongObject</name> *)<name>aa</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyStringObject</name> *</type><name>str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>sz</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size_a</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bits</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>sign</name> <init>= <expr>'\0'</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>a</name> == <name>NULL</name> || !<call><name>PyLong_Check</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>base</name> &gt;= 2 &amp;&amp; <name>base</name> &lt;= 36</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>size_a</name> = <call><name>ABS</name><argument_list>(<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> = <name>base</name></expr>;</expr_stmt>
<expr_stmt><expr><name>bits</name> = 0</expr>;</expr_stmt>
<while>while <condition>(<expr><name>i</name> &gt; 1</expr>)</condition> <block>{
<expr_stmt><expr>++<name>bits</name></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> &gt;&gt;= 1</expr>;</expr_stmt>
}</block></while>
<expr_stmt><expr><name>i</name> = 5 + (<name>addL</name> ? 1 : 0)</expr>;</expr_stmt>
<expr_stmt><expr><name>j</name> = <name>size_a</name>*<name>PyLong_SHIFT</name> + <name>bits</name>-1</expr>;</expr_stmt>
<expr_stmt><expr><name>sz</name> = <name>i</name> + <name>j</name> / <name>bits</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>j</name> / <name>PyLong_SHIFT</name> &lt; <name>size_a</name> || <name>sz</name> &lt; <name>i</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
<argument><expr>"long is too large to format"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>str</name> = (<name>PyStringObject</name> *) <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr>(<name>char</name> *)0</expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>str</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>p</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> + <name>sz</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name> = '\0'</expr>;</expr_stmt>
<if>if <condition>(<expr><name>addL</name></expr>)</condition><then>
<expr_stmt><expr>*--<name>p</name> = 'L'</expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name><name>a</name>-&gt;<name>ob_size</name></name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>sign</name> = '-'</expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name><name>a</name>-&gt;<name>ob_size</name></name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr>*--<name>p</name> = '0'</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr>(<name>base</name> &amp; (<name>base</name> - 1)) == 0</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>twodigits</name></type> <name>accum</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>accumbits</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>basebits</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>i</name> = <name>base</name></expr>;</expr_stmt>
<while>while <condition>(<expr>(<name>i</name> &gt;&gt;= 1) &gt; 1</expr>)</condition>
<expr_stmt><expr>++<name>basebits</name></expr>;</expr_stmt></while>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>size_a</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<expr_stmt><expr><name>accum</name> |= (<name>twodigits</name>)<name><name>a</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name> &lt;&lt; <name>accumbits</name></expr>;</expr_stmt>
<expr_stmt><expr><name>accumbits</name> += <name>PyLong_SHIFT</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>accumbits</name> &gt;= <name>basebits</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<do>do <block>{
<decl_stmt><decl><type><name>char</name></type> <name>cdigit</name> <init>= <expr><call>(<name>char</name>)<argument_list>(<argument><expr><name>accum</name> &amp; (<name>base</name> - 1)</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>cdigit</name> += (<name>cdigit</name> &lt; 10) ? '0' : 'a'-10</expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>p</name> &gt; <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*--<name>p</name> = <name>cdigit</name></expr>;</expr_stmt>
<expr_stmt><expr><name>accumbits</name> -= <name>basebits</name></expr>;</expr_stmt>
<expr_stmt><expr><name>accum</name> &gt;&gt;= <name>basebits</name></expr>;</expr_stmt>
}</block> while <condition>(<expr><name>i</name> &lt; <name>size_a</name>-1 ? <name>accumbits</name> &gt;= <name>basebits</name> :
<name>accum</name> &gt; 0</expr>)</condition>;</do>
}</block></for>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size</name> <init>= <expr><name>size_a</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>digit</name> *</type><name>pin</name> <init>= <expr><name><name>a</name>-&gt;<name>ob_digit</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>scratch</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>digit</name></type> <name>powbase</name> <init>= <expr><name>base</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>power</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>newpow</name> <init>= <macro><name>powbase</name></macro> <expr>* (<name>unsigned</name> <name>long</name>)<name>base</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>newpow</name> &gt;&gt; <name>PyLong_SHIFT</name></expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr><name>powbase</name> = (<name>digit</name>)<name>newpow</name></expr>;</expr_stmt>
<expr_stmt><expr>++<name>power</name></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><name>scratch</name> = <call><name>_PyLong_New</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>scratch</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<do>do <block>{
<decl_stmt><decl><type><name>int</name></type> <name>ntostore</name> <init>= <expr><name>power</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>digit</name></type> <name>rem</name> <init>= <expr><call><name>inplace_divrem1</name><argument_list>(<argument><expr><name><name>scratch</name>-&gt;<name>ob_digit</name></name></expr></argument>,
<argument><expr><name>pin</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>powbase</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>pin</name> = <name><name>scratch</name>-&gt;<name>ob_digit</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>pin</name><index>[<expr><name>size</name> - 1</expr>]</index></name> == 0</expr>)</condition><then>
<expr_stmt><expr>--<name>size</name></expr>;</expr_stmt></then></if>
<macro><name>SIGCHECK</name><argument_list>(<argument>{
Py_DECREF(scratch);
Py_DECREF(str);
return NULL;
}</argument>)</argument_list></macro>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>ntostore</name> &gt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<do>do <block>{
<decl_stmt><decl><type><name>digit</name></type> <name>nextrem</name> <init>= <expr><call>(<name>digit</name>)<argument_list>(<argument><expr><name>rem</name> / <name>base</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>c</name> <init>= <expr><call>(<name>char</name>)<argument_list>(<argument><expr><name>rem</name> - <name>nextrem</name> * <name>base</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>p</name> &gt; <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> += (<name>c</name> &lt; 10) ? '0' : 'a'-10</expr>;</expr_stmt>
<expr_stmt><expr>*--<name>p</name> = <name>c</name></expr>;</expr_stmt>
<expr_stmt><expr><name>rem</name> = <name>nextrem</name></expr>;</expr_stmt>
<expr_stmt><expr>--<name>ntostore</name></expr>;</expr_stmt>
}</block> while <condition>(<expr><name>ntostore</name> &amp;&amp; (<name>size</name> || <name>rem</name>)</expr>)</condition>;</do>
}</block> while <condition>(<expr><name>size</name> != 0</expr>)</condition>;</do>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>scratch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if></else></if>
<if>if <condition>(<expr><name>base</name> == 2</expr>)</condition><then> <block>{
<expr_stmt><expr>*--<name>p</name> = 'b'</expr>;</expr_stmt>
<expr_stmt><expr>*--<name>p</name> = '0'</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>base</name> == 8</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>newstyle</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*--<name>p</name> = 'o'</expr>;</expr_stmt>
<expr_stmt><expr>*--<name>p</name> = '0'</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>size_a</name> != 0</expr>)</condition><then>
<expr_stmt><expr>*--<name>p</name> = '0'</expr>;</expr_stmt></then></if></else></if>
}</block></then> <else>else <if>if <condition>(<expr><name>base</name> == 16</expr>)</condition><then> <block>{
<expr_stmt><expr>*--<name>p</name> = 'x'</expr>;</expr_stmt>
<expr_stmt><expr>*--<name>p</name> = '0'</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>base</name> != 10</expr>)</condition><then> <block>{
<expr_stmt><expr>*--<name>p</name> = '#'</expr>;</expr_stmt>
<expr_stmt><expr>*--<name>p</name> = '0' + <name>base</name>%10</expr>;</expr_stmt>
<if>if <condition>(<expr><name>base</name> &gt; 10</expr>)</condition><then>
<expr_stmt><expr>*--<name>p</name> = '0' + <name>base</name>/10</expr>;</expr_stmt></then></if>
}</block></then></if></else></if></else></if></else></if>
<if>if <condition>(<expr><name>sign</name></expr>)</condition><then>
<expr_stmt><expr>*--<name>p</name> = <name>sign</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>p</name> != <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>q</name> <init>= <expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>p</name> &gt; <name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<do>do <block>{
}</block> while <condition>(<expr>(*<name>q</name>++ = *<name>p</name>++) != '\0'</expr>)</condition>;</do>
<expr_stmt><expr><name>q</name>--</expr>;</expr_stmt>
<expr_stmt><expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>(<name>PyObject</name> **)&amp;<name>str</name></expr></argument>,
<argument><expr><call>(<name>Py_ssize_t</name>) <argument_list>(<argument><expr><name>q</name> - <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr>(<name>PyObject</name> *)<name>str</name></expr>;</return>
}</block>
<decl_stmt><decl><type><name>int</name></type> <name><name>_PyLong_DigitValue</name><index>[<expr>256</expr>]</index></name> <init>= <expr><block>{
<expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>,
<expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>,
<expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>,
<expr>0</expr>, <expr>1</expr>, <expr>2</expr>, <expr>3</expr>, <expr>4</expr>, <expr>5</expr>, <expr>6</expr>, <expr>7</expr>, <expr>8</expr>, <expr>9</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>,
<expr>37</expr>, <expr>10</expr>, <expr>11</expr>, <expr>12</expr>, <expr>13</expr>, <expr>14</expr>, <expr>15</expr>, <expr>16</expr>, <expr>17</expr>, <expr>18</expr>, <expr>19</expr>, <expr>20</expr>, <expr>21</expr>, <expr>22</expr>, <expr>23</expr>, <expr>24</expr>,
<expr>25</expr>, <expr>26</expr>, <expr>27</expr>, <expr>28</expr>, <expr>29</expr>, <expr>30</expr>, <expr>31</expr>, <expr>32</expr>, <expr>33</expr>, <expr>34</expr>, <expr>35</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>,
<expr>37</expr>, <expr>10</expr>, <expr>11</expr>, <expr>12</expr>, <expr>13</expr>, <expr>14</expr>, <expr>15</expr>, <expr>16</expr>, <expr>17</expr>, <expr>18</expr>, <expr>19</expr>, <expr>20</expr>, <expr>21</expr>, <expr>22</expr>, <expr>23</expr>, <expr>24</expr>,
<expr>25</expr>, <expr>26</expr>, <expr>27</expr>, <expr>28</expr>, <expr>29</expr>, <expr>30</expr>, <expr>31</expr>, <expr>32</expr>, <expr>33</expr>, <expr>34</expr>, <expr>35</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>,
<expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>,
<expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>,
<expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>,
<expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>,
<expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>,
<expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>,
<expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>,
<expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>, <expr>37</expr>,
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>PyLongObject</name> *</type>
<name>long_from_binary_base</name><parameter_list>(<param><decl><type><name>char</name> **</type><name>str</name></decl></param>, <param><decl><type><name>int</name></type> <name>base</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>p</name> <init>= <expr>*<name>str</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>start</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bits_per_char</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>z</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>twodigits</name></type> <name>accum</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bits_in_accum</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>digit</name> *</type><name>pdigit</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>base</name> &gt;= 2 &amp;&amp; <name>base</name> &lt;= 32 &amp;&amp; (<name>base</name> &amp; (<name>base</name> - 1)) == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> = <name>base</name></expr>;</expr_stmt>
<for>for (<init><expr><name>bits_per_char</name> = -1</expr>;</init> <condition><expr><name>n</name></expr>;</condition> <incr><expr>++<name>bits_per_char</name></expr></incr>)
<expr_stmt><expr><name>n</name> &gt;&gt;= 1</expr>;</expr_stmt></for>
<expr_stmt><expr><name>n</name> = 0</expr>;</expr_stmt>
<while>while <condition>(<expr><name><name>_PyLong_DigitValue</name><index>[<expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>]</index></name> &lt; <name>base</name></expr>)</condition>
<expr_stmt><expr>++<name>p</name></expr>;</expr_stmt></while>
<expr_stmt><expr>*<name>str</name> = <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> = (<name>p</name> - <name>start</name>) * <name>bits_per_char</name> + <name>PyLong_SHIFT</name> - 1</expr>;</expr_stmt>
<if>if <condition>(<expr><name>n</name> / <name>bits_per_char</name> &lt; <name>p</name> - <name>start</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"long string too large to convert"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>n</name> = <name>n</name> / <name>PyLong_SHIFT</name></expr>;</expr_stmt>
<expr_stmt><expr><name>z</name> = <call><name>_PyLong_New</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>z</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>accum</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>bits_in_accum</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>pdigit</name> = <name><name>z</name>-&gt;<name>ob_digit</name></name></expr>;</expr_stmt>
<while>while <condition>(<expr>--<name>p</name> &gt;= <name>start</name></expr>)</condition> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>k</name> <init>= <expr><name><name>_PyLong_DigitValue</name><index>[<expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>k</name> &gt;= 0 &amp;&amp; <name>k</name> &lt; <name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>accum</name> |= <call>(<name>twodigits</name>)<argument_list>(<argument><expr><name>k</name> &lt;&lt; <name>bits_in_accum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>bits_in_accum</name> += <name>bits_per_char</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>bits_in_accum</name> &gt;= <name>PyLong_SHIFT</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>pdigit</name>++ = <call>(<name>digit</name>)<argument_list>(<argument><expr><name>accum</name> &amp; <name>PyLong_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>pdigit</name> - <name><name>z</name>-&gt;<name>ob_digit</name></name> &lt;= (<name>int</name>)<name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>accum</name> &gt;&gt;= <name>PyLong_SHIFT</name></expr>;</expr_stmt>
<expr_stmt><expr><name>bits_in_accum</name> -= <name>PyLong_SHIFT</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>bits_in_accum</name> &lt; <name>PyLong_SHIFT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></while>
<if>if <condition>(<expr><name>bits_in_accum</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>bits_in_accum</name> &lt;= <name>PyLong_SHIFT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>pdigit</name>++ = (<name>digit</name>)<name>accum</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>pdigit</name> - <name><name>z</name>-&gt;<name>ob_digit</name></name> &lt;= (<name>int</name>)<name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<while>while <condition>(<expr><name>pdigit</name> - <name><name>z</name>-&gt;<name>ob_digit</name></name> &lt; <name>n</name></expr>)</condition>
<expr_stmt><expr>*<name>pdigit</name>++ = 0</expr>;</expr_stmt></while>
<return>return <expr><call><name>long_normalize</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type>
<name>PyLong_FromString</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>str</name></decl></param>, <param><decl><type><name>char</name> **</type><name>pend</name></decl></param>, <param><decl><type><name>int</name></type> <name>base</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>sign</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>start</name></decl>, *<decl><type ref="prev"/><name>orig_str</name> <init>= <expr><name>str</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>z</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>strobj</name></decl>, *<decl><type ref="prev"/><name>strrepr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>slen</name></decl>;</decl_stmt>
<if>if <condition>(<expr>(<name>base</name> != 0 &amp;&amp; <name>base</name> &lt; 2) || <name>base</name> &gt; 36</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"long() arg 2 must be &gt;= 2 and &lt;= 36"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<while>while <condition>(<expr>*<name>str</name> != '\0' &amp;&amp; <call><name>isspace</name><argument_list>(<argument><expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
<expr_stmt><expr><name>str</name>++</expr>;</expr_stmt></while>
<if>if <condition>(<expr>*<name>str</name> == '+'</expr>)</condition><then>
<expr_stmt><expr>++<name>str</name></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr>*<name>str</name> == '-'</expr>)</condition><then> <block>{
<expr_stmt><expr>++<name>str</name></expr>;</expr_stmt>
<expr_stmt><expr><name>sign</name> = -1</expr>;</expr_stmt>
}</block></then></if></else></if>
<while>while <condition>(<expr>*<name>str</name> != '\0' &amp;&amp; <call><name>isspace</name><argument_list>(<argument><expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
<expr_stmt><expr><name>str</name>++</expr>;</expr_stmt></while>
<if>if <condition>(<expr><name>base</name> == 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>str</name><index>[<expr>0</expr>]</index></name> != '0'</expr>)</condition><then>
<expr_stmt><expr><name>base</name> = 10</expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name><name>str</name><index>[<expr>1</expr>]</index></name> == 'x' || <name><name>str</name><index>[<expr>1</expr>]</index></name> == 'X'</expr>)</condition><then>
<expr_stmt><expr><name>base</name> = 16</expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name><name>str</name><index>[<expr>1</expr>]</index></name> == 'o' || <name><name>str</name><index>[<expr>1</expr>]</index></name> == 'O'</expr>)</condition><then>
<expr_stmt><expr><name>base</name> = 8</expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name><name>str</name><index>[<expr>1</expr>]</index></name> == 'b' || <name><name>str</name><index>[<expr>1</expr>]</index></name> == 'B'</expr>)</condition><then>
<expr_stmt><expr><name>base</name> = 2</expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>base</name> = 8</expr>;</expr_stmt></else></if></else></if></else></if></else></if>
}</block></then></if>
<if>if <condition>(<expr><name><name>str</name><index>[<expr>0</expr>]</index></name> == '0' &amp;&amp;
((<name>base</name> == 16 &amp;&amp; (<name><name>str</name><index>[<expr>1</expr>]</index></name> == 'x' || <name><name>str</name><index>[<expr>1</expr>]</index></name> == 'X')) ||
(<name>base</name> == 8 &amp;&amp; (<name><name>str</name><index>[<expr>1</expr>]</index></name> == 'o' || <name><name>str</name><index>[<expr>1</expr>]</index></name> == 'O')) ||
(<name>base</name> == 2 &amp;&amp; (<name><name>str</name><index>[<expr>1</expr>]</index></name> == 'b' || <name><name>str</name><index>[<expr>1</expr>]</index></name> == 'B')))</expr>)</condition><then>
<expr_stmt><expr><name>str</name> += 2</expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>start</name> = <name>str</name></expr>;</expr_stmt>
<if>if <condition>(<expr>(<name>base</name> &amp; (<name>base</name> - 1)) == 0</expr>)</condition><then>
<expr_stmt><expr><name>z</name> = <call><name>long_from_binary_base</name><argument_list>(<argument><expr>&amp;<name>str</name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else <block>{
<decl_stmt><decl><type><name>register</name> <name>twodigits</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size_z</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>convwidth</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>twodigits</name></type> <name>convmultmax</name></decl>, <decl><type ref="prev"/><name>convmult</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>digit</name> *</type><name>pz</name></decl>, *<decl><type ref="prev"/><name>pzstop</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>*</type> <name>scan</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>double</name></type> <name><name>log_base_PyLong_BASE</name><index>[<expr>37</expr>]</index></name> <init>= <expr><block>{<expr>0.0e0</expr>,}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name><name>convwidth_base</name><index>[<expr>37</expr>]</index></name> <init>= <expr><block>{<expr>0</expr>,}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>twodigits</name></type> <name><name>convmultmax_base</name><index>[<expr>37</expr>]</index></name> <init>= <expr><block>{<expr>0</expr>,}</block></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>log_base_PyLong_BASE</name><index>[<expr><name>base</name></expr>]</index></name> == 0.0</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>twodigits</name></type> <name>convmax</name> <init>= <expr><name>base</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>log_base_PyLong_BASE</name><index>[<expr><name>base</name></expr>]</index></name> = <call><name>log</name><argument_list>(<argument><expr>(<name>double</name>)<name>base</name></expr></argument>)</argument_list></call> /
<call><name>log</name><argument_list>(<argument><expr>(<name>double</name>)<name>PyLong_BASE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<decl_stmt><decl><type><name>twodigits</name></type> <name>next</name> <init>= <expr><name>convmax</name> * <name>base</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>next</name> &gt; <name>PyLong_BASE</name></expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr><name>convmax</name> = <name>next</name></expr>;</expr_stmt>
<expr_stmt><expr>++<name>i</name></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><name><name>convmultmax_base</name><index>[<expr><name>base</name></expr>]</index></name> = <name>convmax</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>i</name> &gt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>convwidth_base</name><index>[<expr><name>base</name></expr>]</index></name> = <name>i</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>scan</name> = <name>str</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name><name>_PyLong_DigitValue</name><index>[<expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>scan</name></expr></argument>)</argument_list></call></expr>]</index></name> &lt; <name>base</name></expr>)</condition>
<expr_stmt><expr>++<name>scan</name></expr>;</expr_stmt></while>
<expr_stmt><expr><name>size_z</name> = <call>(<name>Py_ssize_t</name>)<argument_list>(<argument><expr>(<name>scan</name> - <name>str</name>) * <name><name>log_base_PyLong_BASE</name><index>[<expr><name>base</name></expr>]</index></name></expr></argument>)</argument_list></call> + 1</expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>size_z</name> &gt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>z</name> = <call><name>_PyLong_New</name><argument_list>(<argument><expr><name>size_z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>z</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>convwidth</name> = <name><name>convwidth_base</name><index>[<expr><name>base</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>convmultmax</name> = <name><name>convmultmax_base</name><index>[<expr><name>base</name></expr>]</index></name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>str</name> &lt; <name>scan</name></expr>)</condition> <block>{
<expr_stmt><expr><name>c</name> = (<name>digit</name>)<name><name>_PyLong_DigitValue</name><index>[<expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>str</name>++</expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 1</expr>;</init> <condition><expr><name>i</name> &lt; <name>convwidth</name> &amp;&amp; <name>str</name> != <name>scan</name></expr>;</condition> <incr><expr>++<name>i</name></expr>, <expr>++<name>str</name></expr></incr>) <block>{
<expr_stmt><expr><name>c</name> = <call>(<name>twodigits</name>)<argument_list>(<argument><expr><name>c</name> * <name>base</name> +
<name><name>_PyLong_DigitValue</name><index>[<expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>str</name></expr></argument>)</argument_list></call></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>c</name> &lt; <name>PyLong_BASE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><name>convmult</name> = <name>convmultmax</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>i</name> != <name>convwidth</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>convmult</name> = <name>base</name></expr>;</expr_stmt>
<for>for ( <init>;</init> <condition><expr><name>i</name> &gt; 1</expr>;</condition> <incr><expr>--<name>i</name></expr></incr>)
<expr_stmt><expr><name>convmult</name> *= <name>base</name></expr>;</expr_stmt></for>
}</block></then></if>
<expr_stmt><expr><name>pz</name> = <name><name>z</name>-&gt;<name>ob_digit</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>pzstop</name> = <name>pz</name> + <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init>;</init> <condition><expr><name>pz</name> &lt; <name>pzstop</name></expr>;</condition> <incr><expr>++<name>pz</name></expr></incr>) <block>{
<expr_stmt><expr><name>c</name> += (<name>twodigits</name>)*<name>pz</name> * <name>convmult</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>pz</name> = <call>(<name>digit</name>)<argument_list>(<argument><expr><name>c</name> &amp; <name>PyLong_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> &gt;&gt;= <name>PyLong_SHIFT</name></expr>;</expr_stmt>
}</block></for>
<if>if <condition>(<expr><name>c</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>c</name> &lt; <name>PyLong_BASE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> &lt; <name>size_z</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>pz</name> = (<name>digit</name>)<name>c</name></expr>;</expr_stmt>
<expr_stmt><expr>++<call><name>Py_SIZE</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>tmp</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> == <name>size_z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tmp</name> = <call><name>_PyLong_New</name><argument_list>(<argument><expr><name>size_z</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>tmp</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>tmp</name>-&gt;<name>ob_digit</name></name></expr></argument>,
<argument><expr><name><name>z</name>-&gt;<name>ob_digit</name></name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>digit</name></expr></argument>)</argument_list></sizeof> * <name>size_z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>z</name> = <name>tmp</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>z</name>-&gt;<name>ob_digit</name><index>[<expr><name>size_z</name></expr>]</index></name> = (<name>digit</name>)<name>c</name></expr>;</expr_stmt>
<expr_stmt><expr>++<name>size_z</name></expr>;</expr_stmt>
}</block></else></if>
}</block></then></if>
}</block></while>
}</block></else></if>
<if>if <condition>(<expr><name>z</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>str</name> == <name>start</name></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<if>if <condition>(<expr><name>sign</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> = -(<call><name>Py_SIZE</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt></then></if>
<if>if <condition>(<expr>*<name>str</name> == 'L' || *<name>str</name> == 'l'</expr>)</condition><then>
<expr_stmt><expr><name>str</name>++</expr>;</expr_stmt></then></if>
<while>while <condition>(<expr>*<name>str</name> &amp;&amp; <call><name>isspace</name><argument_list>(<argument><expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
<expr_stmt><expr><name>str</name>++</expr>;</expr_stmt></while>
<if>if <condition>(<expr>*<name>str</name> != '\0'</expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<if>if <condition>(<expr><name>pend</name></expr>)</condition><then>
<expr_stmt><expr>*<name>pend</name> = <name>str</name></expr>;</expr_stmt></then></if>
<return>return <expr>(<name>PyObject</name> *) <name>z</name></expr>;</return>
<label><name>onError</name>:</label>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>slen</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>orig_str</name></expr></argument>)</argument_list></call> &lt; 200 ? <call><name>strlen</name><argument_list>(<argument><expr><name>orig_str</name></expr></argument>)</argument_list></call> : 200</expr>;</expr_stmt>
<expr_stmt><expr><name>strobj</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>orig_str</name></expr></argument>, <argument><expr><name>slen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>strobj</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>strrepr</name> = <call><name>PyObject_Repr</name><argument_list>(<argument><expr><name>strobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>strobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>strrepr</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"invalid literal for long() with base %d: %s"</expr></argument>,
<argument><expr><name>base</name></expr></argument>, <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>strrepr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>strrepr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_USING_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>PyObject</name> *</type>
<name>PyLong_FromUnicode</name><parameter_list>(<param><decl><type><name>Py_UNICODE</name> *</type><name>u</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>length</name></decl></param>, <param><decl><type><name>int</name></type> <name>base</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>buffer</name> <init>= <expr>(<name>char</name> *)<call><name>PyMem_MALLOC</name><argument_list>(<argument><expr><name>length</name>+1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>buffer</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>PyUnicode_EncodeDecimal</name><argument_list>(<argument><expr><name>u</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyMem_FREE</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>result</name> = <call><name>PyLong_FromString</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyMem_FREE</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><specifier>static</specifier> <name>PyLongObject</name> *</type><name>x_divrem</name>
<parameter_list>(<param><decl><type><name>PyLongObject</name> *</type></decl></param>, <param><decl><type><name>PyLongObject</name> *</type></decl></param>, <param><decl><type><name>PyLongObject</name> **</type></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>long_long</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>long_divrem</name><parameter_list>(<param><decl><type><name>PyLongObject</name> *</type></decl></param>, <param><decl><type><name>PyLongObject</name> *</type></decl></param>,
<param><decl><type><name>PyLongObject</name> **</type></decl></param>, <param><decl><type><name>PyLongObject</name> **</type></decl></param>)</parameter_list>;</function_decl>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>long_divrem</name><parameter_list>(<param><decl><type><name>PyLongObject</name> *</type><name>a</name></decl></param>, <param><decl><type><name>PyLongObject</name> *</type><name>b</name></decl></param>,
<param><decl><type><name>PyLongObject</name> **</type><name>pdiv</name></decl></param>, <param><decl><type><name>PyLongObject</name> **</type><name>prem</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size_a</name> <init>= <expr><call><name>ABS</name><argument_list>(<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init>, <name>size_b</name> <init>= <expr><call><name>ABS</name><argument_list>(<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>z</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>size_b</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ZeroDivisionError</name></expr></argument>,
<argument><expr>"long division or modulo by zero"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>size_a</name> &lt; <name>size_b</name> ||
(<name>size_a</name> == <name>size_b</name> &amp;&amp;
<name><name>a</name>-&gt;<name>ob_digit</name><index>[<expr><name>size_a</name>-1</expr>]</index></name> &lt; <name><name>b</name>-&gt;<name>ob_digit</name><index>[<expr><name>size_b</name>-1</expr>]</index></name>)</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>pdiv</name> = <call><name>_PyLong_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>*<name>pdiv</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>prem</name> = (<name>PyLongObject</name> *) <name>a</name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>size_b</name> == 1</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>digit</name></type> <name>rem</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>z</name> = <call><name>divrem1</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>ob_digit</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>rem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>z</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr>*<name>prem</name> = (<name>PyLongObject</name> *) <call><name>PyLong_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name>rem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>*<name>prem</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>z</name> = <call><name>x_divrem</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>prem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>z</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
}</block></else></if>
<if>if <condition>(<expr>(<name><name>a</name>-&gt;<name>ob_size</name></name> &lt; 0) != (<name><name>b</name>-&gt;<name>ob_size</name></name> &lt; 0)</expr>)</condition><then>
<expr_stmt><expr><name><name>z</name>-&gt;<name>ob_size</name></name> = -(<name><name>z</name>-&gt;<name>ob_size</name></name>)</expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name><name>a</name>-&gt;<name>ob_size</name></name> &lt; 0 &amp;&amp; <name>(*<name>prem</name>)-&gt;<name>ob_size</name></name> != 0</expr>)</condition><then>
<expr_stmt><expr><name>(*<name>prem</name>)-&gt;<name>ob_size</name></name> = -(<name>(*<name>prem</name>)-&gt;<name>ob_size</name></name>)</expr>;</expr_stmt></then></if>
<expr_stmt><expr>*<name>pdiv</name> = <name>z</name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyLongObject</name> *</type>
<name>x_divrem</name><parameter_list>(<param><decl><type><name>PyLongObject</name> *</type><name>v1</name></decl></param>, <param><decl><type><name>PyLongObject</name> *</type><name>w1</name></decl></param>, <param><decl><type><name>PyLongObject</name> **</type><name>prem</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size_v</name> <init>= <expr><call><name>ABS</name><argument_list>(<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>v1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init>, <name>size_w</name> <init>= <expr><call><name>ABS</name><argument_list>(<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>w1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>digit</name></type> <name>d</name> <init>= <expr><call>(<name>digit</name>) <argument_list>(<argument><expr>(<name>twodigits</name>)<name>PyLong_BASE</name> / (<name><name>w1</name>-&gt;<name>ob_digit</name><index>[<expr><name>size_w</name>-1</expr>]</index></name> + 1)</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>v</name> <init>= <expr><call><name>mul1</name><argument_list>(<argument><expr><name>v1</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>w</name> <init>= <expr><call><name>mul1</name><argument_list>(<argument><expr><name>w1</name></expr></argument>, <argument><expr><name>d</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>a</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name> || <name>w</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>size_v</name> &gt;= <name>size_w</name> &amp;&amp; <name>size_w</name> &gt; 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>Py_REFCNT</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> == 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>size_w</name> == <call><name>ABS</name><argument_list>(<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>size_v</name> = <call><name>ABS</name><argument_list>(<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>k</name> = <name>size_v</name> - <name>size_w</name></expr>;</expr_stmt>
<expr_stmt><expr><name>a</name> = <call><name>_PyLong_New</name><argument_list>(<argument><expr><name>k</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>j</name> = <name>size_v</name></expr>;</init> <condition><expr><name>a</name> != <name>NULL</name> &amp;&amp; <name>k</name> &gt;= 0</expr>;</condition> <incr><expr>--<name>j</name></expr>, <expr>--<name>k</name></expr></incr>) <block>{
<decl_stmt><decl><type><name>digit</name></type> <name>vj</name> <init>= <expr>(<name>j</name> &gt;= <name>size_v</name>) ? 0 : <name><name>v</name>-&gt;<name>ob_digit</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>twodigits</name></type> <name>q</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>stwodigits</name></type> <name>carry</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<macro><name>SIGCHECK</name><argument_list>(<argument>{
Py_DECREF(a);
a = NULL;
break;
}</argument>)</argument_list></macro>
<if>if <condition>(<expr><name>vj</name> == <name><name>w</name>-&gt;<name>ob_digit</name><index>[<expr><name>size_w</name>-1</expr>]</index></name></expr>)</condition><then>
<expr_stmt><expr><name>q</name> = <name>PyLong_MASK</name></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>q</name> = (((<name>twodigits</name>)<name>vj</name> &lt;&lt; <name>PyLong_SHIFT</name>) + <name><name>v</name>-&gt;<name>ob_digit</name><index>[<expr><name>j</name>-1</expr>]</index></name>) /
<name><name>w</name>-&gt;<name>ob_digit</name><index>[<expr><name>size_w</name>-1</expr>]</index></name></expr>;</expr_stmt></else></if>
<while>while <condition>(<expr><name><name>w</name>-&gt;<name>ob_digit</name><index>[<expr><name>size_w</name>-2</expr>]</index></name>*<name>q</name> &gt;
((
((<name>twodigits</name>)<name>vj</name> &lt;&lt; <name>PyLong_SHIFT</name>)
+ <name><name>v</name>-&gt;<name>ob_digit</name><index>[<expr><name>j</name>-1</expr>]</index></name>
- <name>q</name>*<name><name>w</name>-&gt;<name>ob_digit</name><index>[<expr><name>size_w</name>-1</expr>]</index></name>
) &lt;&lt; <name>PyLong_SHIFT</name>)
+ <name><name>v</name>-&gt;<name>ob_digit</name><index>[<expr><name>j</name>-2</expr>]</index></name></expr>)</condition>
<expr_stmt><expr>--<name>q</name></expr>;</expr_stmt></while>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>size_w</name> &amp;&amp; <name>i</name>+<name>k</name> &lt; <name>size_v</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<decl_stmt><decl><type><name>twodigits</name></type> <name>z</name> <init>= <expr><name><name>w</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name> * <name>q</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>digit</name></type> <name>zz</name> <init>= <expr><call>(<name>digit</name>) <argument_list>(<argument><expr><name>z</name> &gt;&gt; <name>PyLong_SHIFT</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>carry</name> += <name><name>v</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name>+<name>k</name></expr>]</index></name> - <name>z</name>
+ ((<name>twodigits</name>)<name>zz</name> &lt;&lt; <name>PyLong_SHIFT</name>)</expr>;</expr_stmt>
<expr_stmt><expr><name><name>v</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name>+<name>k</name></expr>]</index></name> = <call>(<name>digit</name>)<argument_list>(<argument><expr><name>carry</name> &amp; <name>PyLong_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>carry</name> = <call><name>Py_ARITHMETIC_RIGHT_SHIFT</name><argument_list>(<argument><expr><name>PyLong_BASE_TWODIGITS_TYPE</name></expr></argument>,
<argument><expr><name>carry</name></expr></argument>, <argument><expr><name>PyLong_SHIFT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>carry</name> -= <name>zz</name></expr>;</expr_stmt>
}</block></for>
<if>if <condition>(<expr><name>i</name>+<name>k</name> &lt; <name>size_v</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>carry</name> += <name><name>v</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name>+<name>k</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>v</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name>+<name>k</name></expr>]</index></name> = 0</expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>carry</name> == 0</expr>)</condition><then>
<expr_stmt><expr><name><name>a</name>-&gt;<name>ob_digit</name><index>[<expr><name>k</name></expr>]</index></name> = (<name>digit</name>) <name>q</name></expr>;</expr_stmt></then>
<else>else <block>{
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>carry</name> == -1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>a</name>-&gt;<name>ob_digit</name><index>[<expr><name>k</name></expr>]</index></name> = (<name>digit</name>) <name>q</name>-1</expr>;</expr_stmt>
<expr_stmt><expr><name>carry</name> = 0</expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>size_w</name> &amp;&amp; <name>i</name>+<name>k</name> &lt; <name>size_v</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<expr_stmt><expr><name>carry</name> += <name><name>v</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name>+<name>k</name></expr>]</index></name> + <name><name>w</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>v</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name>+<name>k</name></expr>]</index></name> = <call>(<name>digit</name>)<argument_list>(<argument><expr><name>carry</name> &amp; <name>PyLong_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>carry</name> = <call><name>Py_ARITHMETIC_RIGHT_SHIFT</name><argument_list>(
<argument><expr><name>PyLong_BASE_TWODIGITS_TYPE</name></expr></argument>,
<argument><expr><name>carry</name></expr></argument>, <argument><expr><name>PyLong_SHIFT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
}</block></else></if>
}</block></for>
<if>if <condition>(<expr><name>a</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr>*<name>prem</name> = <name>NULL</name></expr>;</expr_stmt></then>
<else>else <block>{
<expr_stmt><expr><name>a</name> = <call><name>long_normalize</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>prem</name> = <call><name>divrem1</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr>&amp;<name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>*<name>prem</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>a</name> = <name>NULL</name></expr>;</expr_stmt>
}</block></then></if>
}</block></else></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>a</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>long_dealloc</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call>-&gt;<call><name>tp_free</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>long_repr</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>_PyLong_Format</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>10</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>long_str</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>_PyLong_Format</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>10</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>long_compare</name><parameter_list>(<param><decl><type><name>PyLongObject</name> *</type><name>a</name></decl></param>, <param><decl><type><name>PyLongObject</name> *</type><name>b</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>sign</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> != <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>ABS</name><argument_list>(<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == 0 &amp;&amp; <call><name>ABS</name><argument_list>(<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
<expr_stmt><expr><name>sign</name> = 0</expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>sign</name> = <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> - <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name> <init>= <expr><call><name>ABS</name><argument_list>(<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr>--<name>i</name> &gt;= 0 &amp;&amp; <name><name>a</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name> == <name><name>b</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
<empty_stmt>;</empty_stmt></while>
<if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>sign</name> = 0</expr>;</expr_stmt></then>
<else>else <block>{
<expr_stmt><expr><name>sign</name> = (<name>int</name>)<name><name>a</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name> - (<name>int</name>)<name><name>b</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>sign</name> = -<name>sign</name></expr>;</expr_stmt></then></if>
}</block></else></if>
}</block></else></if>
<return>return <expr><name>sign</name> &lt; 0 ? -1 : <name>sign</name> &gt; 0 ? 1 : 0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>long</name></type>
<name>long_hash</name><parameter_list>(<param><decl><type><name>PyLongObject</name> *</type><name>v</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>long</name></type> <name>x</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sign</name></decl>;</decl_stmt>
<expr_stmt><expr><name>i</name> = <name><name>v</name>-&gt;<name>ob_size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>sign</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name>x</name> = 0</expr>;</expr_stmt>
<if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>sign</name> = -1</expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> = -(<name>i</name>)</expr>;</expr_stmt>
}</block></then></if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LONG_BIT_PyLong_SHIFT</name></cpp:macro> <cpp:value>(8*sizeof(long) - PyLong_SHIFT)</cpp:value></cpp:define>
<while>while <condition>(<expr>--<name>i</name> &gt;= 0</expr>)</condition> <block>{
<expr_stmt><expr><name>x</name> = ((<name>x</name> &lt;&lt; <name>PyLong_SHIFT</name>) &amp; ~<name>PyLong_MASK</name>) | ((<name>x</name> &gt;&gt; <name>LONG_BIT_PyLong_SHIFT</name>) &amp; <name>PyLong_MASK</name>)</expr>;</expr_stmt>
<expr_stmt><expr><name>x</name> += <name><name>v</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if>if <condition>(<expr>(<name>unsigned</name> <name>long</name>)<name>x</name> &lt; <name><name>v</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then>
<expr_stmt><expr><name>x</name>++</expr>;</expr_stmt></then></if>
}</block></while>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>LONG_BIT_PyLong_SHIFT</name></cpp:undef>
<expr_stmt><expr><name>x</name> = <name>x</name> * <name>sign</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>x</name> == -1</expr>)</condition><then>
<expr_stmt><expr><name>x</name> = -2</expr>;</expr_stmt></then></if>
<return>return <expr><name>x</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyLongObject</name> *</type>
<name>x_add</name><parameter_list>(<param><decl><type><name>PyLongObject</name> *</type><name>a</name></decl></param>, <param><decl><type><name>PyLongObject</name> *</type><name>b</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size_a</name> <init>= <expr><call><name>ABS</name><argument_list>(<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init>, <name>size_b</name> <init>= <expr><call><name>ABS</name><argument_list>(<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>z</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>digit</name></type> <name>carry</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>size_a</name> &lt; <name>size_b</name></expr>)</condition><then> <block>{
<block>{
<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>temp</name> <init>= <expr><name>a</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>a</name> = <name>b</name></expr>;</expr_stmt>
<expr_stmt><expr><name>b</name> = <name>temp</name></expr>;</expr_stmt>
}</block>
<block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size_temp</name> <init>= <expr><name>size_a</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>size_a</name> = <name>size_b</name></expr>;</expr_stmt>
<expr_stmt><expr><name>size_b</name> = <name>size_temp</name></expr>;</expr_stmt>
}</block>
}</block></then></if>
<expr_stmt><expr><name>z</name> = <call><name>_PyLong_New</name><argument_list>(<argument><expr><name>size_a</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>z</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>size_b</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<expr_stmt><expr><name>carry</name> += <name><name>a</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name> + <name><name>b</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>z</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name> = <name>carry</name> &amp; <name>PyLong_MASK</name></expr>;</expr_stmt>
<expr_stmt><expr><name>carry</name> &gt;&gt;= <name>PyLong_SHIFT</name></expr>;</expr_stmt>
}</block></for>
<for>for (<init>;</init> <condition><expr><name>i</name> &lt; <name>size_a</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<expr_stmt><expr><name>carry</name> += <name><name>a</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>z</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name> = <name>carry</name> &amp; <name>PyLong_MASK</name></expr>;</expr_stmt>
<expr_stmt><expr><name>carry</name> &gt;&gt;= <name>PyLong_SHIFT</name></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><name><name>z</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name> = <name>carry</name></expr>;</expr_stmt>
<return>return <expr><call><name>long_normalize</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyLongObject</name> *</type>
<name>x_sub</name><parameter_list>(<param><decl><type><name>PyLongObject</name> *</type><name>a</name></decl></param>, <param><decl><type><name>PyLongObject</name> *</type><name>b</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size_a</name> <init>= <expr><call><name>ABS</name><argument_list>(<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init>, <name>size_b</name> <init>= <expr><call><name>ABS</name><argument_list>(<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>z</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>sign</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>digit</name></type> <name>borrow</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>size_a</name> &lt; <name>size_b</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>sign</name> = -1</expr>;</expr_stmt>
<block>{
<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>temp</name> <init>= <expr><name>a</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>a</name> = <name>b</name></expr>;</expr_stmt>
<expr_stmt><expr><name>b</name> = <name>temp</name></expr>;</expr_stmt>
}</block>
<block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size_temp</name> <init>= <expr><name>size_a</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>size_a</name> = <name>size_b</name></expr>;</expr_stmt>
<expr_stmt><expr><name>size_b</name> = <name>size_temp</name></expr>;</expr_stmt>
}</block>
}</block></then> <else>else <if>if <condition>(<expr><name>size_a</name> == <name>size_b</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>i</name> = <name>size_a</name></expr>;</expr_stmt>
<while>while <condition>(<expr>--<name>i</name> &gt;= 0 &amp;&amp; <name><name>a</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name> == <name><name>b</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
<empty_stmt>;</empty_stmt></while>
<if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name>_PyLong_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><name><name>a</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name> &lt; <name><name>b</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>sign</name> = -1</expr>;</expr_stmt>
<block>{
<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>temp</name> <init>= <expr><name>a</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>a</name> = <name>b</name></expr>;</expr_stmt>
<expr_stmt><expr><name>b</name> = <name>temp</name></expr>;</expr_stmt>
}</block>
}</block></then></if>
<expr_stmt><expr><name>size_a</name> = <name>size_b</name> = <name>i</name>+1</expr>;</expr_stmt>
}</block></then></if></else></if>
<expr_stmt><expr><name>z</name> = <call><name>_PyLong_New</name><argument_list>(<argument><expr><name>size_a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>z</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>size_b</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<expr_stmt><expr><name>borrow</name> = <name><name>a</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name> - <name><name>b</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name> - <name>borrow</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>z</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name> = <name>borrow</name> &amp; <name>PyLong_MASK</name></expr>;</expr_stmt>
<expr_stmt><expr><name>borrow</name> &gt;&gt;= <name>PyLong_SHIFT</name></expr>;</expr_stmt>
<expr_stmt><expr><name>borrow</name> &amp;= 1</expr>;</expr_stmt>
}</block></for>
<for>for (<init>;</init> <condition><expr><name>i</name> &lt; <name>size_a</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<expr_stmt><expr><name>borrow</name> = <name><name>a</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name> - <name>borrow</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>z</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name> = <name>borrow</name> &amp; <name>PyLong_MASK</name></expr>;</expr_stmt>
<expr_stmt><expr><name>borrow</name> &gt;&gt;= <name>PyLong_SHIFT</name></expr>;</expr_stmt>
<expr_stmt><expr><name>borrow</name> &amp;= 1</expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>borrow</name> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>sign</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name><name>z</name>-&gt;<name>ob_size</name></name> = -(<name><name>z</name>-&gt;<name>ob_size</name></name>)</expr>;</expr_stmt></then></if>
<return>return <expr><call><name>long_normalize</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>long_add</name><parameter_list>(<param><decl><type><name>PyLongObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyLongObject</name> *</type><name>w</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>a</name></decl>, *<decl><type ref="prev"/><name>b</name></decl>, *<decl><type ref="prev"/><name>z</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>CONVERT_BINOP</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>v</name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>w</name></expr></argument>, <argument><expr>&amp;<name>a</name></expr></argument>, <argument><expr>&amp;<name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>a</name>-&gt;<name>ob_size</name></name> &lt; 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>b</name>-&gt;<name>ob_size</name></name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>z</name> = <call><name>x_add</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>z</name> != <name>NULL</name> &amp;&amp; <name><name>z</name>-&gt;<name>ob_size</name></name> != 0</expr>)</condition><then>
<expr_stmt><expr><name><name>z</name>-&gt;<name>ob_size</name></name> = -(<name><name>z</name>-&gt;<name>ob_size</name></name>)</expr>;</expr_stmt></then></if>
}</block></then> <else>else
<expr_stmt><expr><name>z</name> = <call><name>x_sub</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
}</block></then> <else>else <block>{
<if>if <condition>(<expr><name><name>b</name>-&gt;<name>ob_size</name></name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>z</name> = <call><name>x_sub</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>z</name> = <call><name>x_add</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
}</block></else></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *)<name>z</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>long_sub</name><parameter_list>(<param><decl><type><name>PyLongObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyLongObject</name> *</type><name>w</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>a</name></decl>, *<decl><type ref="prev"/><name>b</name></decl>, *<decl><type ref="prev"/><name>z</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>CONVERT_BINOP</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>v</name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>w</name></expr></argument>, <argument><expr>&amp;<name>a</name></expr></argument>, <argument><expr>&amp;<name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>a</name>-&gt;<name>ob_size</name></name> &lt; 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>b</name>-&gt;<name>ob_size</name></name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>z</name> = <call><name>x_sub</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>z</name> = <call><name>x_add</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<if>if <condition>(<expr><name>z</name> != <name>NULL</name> &amp;&amp; <name><name>z</name>-&gt;<name>ob_size</name></name> != 0</expr>)</condition><then>
<expr_stmt><expr><name><name>z</name>-&gt;<name>ob_size</name></name> = -(<name><name>z</name>-&gt;<name>ob_size</name></name>)</expr>;</expr_stmt></then></if>
}</block></then> <else>else <block>{
<if>if <condition>(<expr><name><name>b</name>-&gt;<name>ob_size</name></name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>z</name> = <call><name>x_add</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>z</name> = <call><name>x_sub</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
}</block></else></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *)<name>z</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyLongObject</name> *</type>
<name>x_mul</name><parameter_list>(<param><decl><type><name>PyLongObject</name> *</type><name>a</name></decl></param>, <param><decl><type><name>PyLongObject</name> *</type><name>b</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>z</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size_a</name> <init>= <expr><call><name>ABS</name><argument_list>(<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size_b</name> <init>= <expr><call><name>ABS</name><argument_list>(<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><name>z</name> = <call><name>_PyLong_New</name><argument_list>(<argument><expr><name>size_a</name> + <name>size_b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>z</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>z</name>-&gt;<name>ob_digit</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> * <sizeof>sizeof<argument_list>(<argument><expr><name>digit</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>a</name> == <name>b</name></expr>)</condition><then> <block>{
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>size_a</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<decl_stmt><decl><type><name>twodigits</name></type> <name>carry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>twodigits</name></type> <name>f</name> <init>= <expr><name><name>a</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>digit</name> *</type><name>pz</name> <init>= <expr><name><name>z</name>-&gt;<name>ob_digit</name></name> + (<name>i</name> &lt;&lt; 1)</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>digit</name> *</type><name>pa</name> <init>= <expr><name><name>a</name>-&gt;<name>ob_digit</name></name> + <name>i</name> + 1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>digit</name> *</type><name>paend</name> <init>= <expr><name><name>a</name>-&gt;<name>ob_digit</name></name> + <name>size_a</name></expr></init></decl>;</decl_stmt>
<macro><name>SIGCHECK</name><argument_list>(<argument>{
Py_DECREF(z);
return NULL;
}</argument>)</argument_list></macro>
<expr_stmt><expr><name>carry</name> = *<name>pz</name> + <name>f</name> * <name>f</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>pz</name>++ = <call>(<name>digit</name>)<argument_list>(<argument><expr><name>carry</name> &amp; <name>PyLong_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>carry</name> &gt;&gt;= <name>PyLong_SHIFT</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>carry</name> &lt;= <name>PyLong_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>f</name> &lt;&lt;= 1</expr>;</expr_stmt>
<while>while <condition>(<expr><name>pa</name> &lt; <name>paend</name></expr>)</condition> <block>{
<expr_stmt><expr><name>carry</name> += *<name>pz</name> + *<name>pa</name>++ * <name>f</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>pz</name>++ = <call>(<name>digit</name>)<argument_list>(<argument><expr><name>carry</name> &amp; <name>PyLong_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>carry</name> &gt;&gt;= <name>PyLong_SHIFT</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>carry</name> &lt;= (<name>PyLong_MASK</name> &lt;&lt; 1)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></while>
<if>if <condition>(<expr><name>carry</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>carry</name> += *<name>pz</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>pz</name>++ = <call>(<name>digit</name>)<argument_list>(<argument><expr><name>carry</name> &amp; <name>PyLong_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>carry</name> &gt;&gt;= <name>PyLong_SHIFT</name></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>carry</name></expr>)</condition><then>
<expr_stmt><expr>*<name>pz</name> += <call>(<name>digit</name>)<argument_list>(<argument><expr><name>carry</name> &amp; <name>PyLong_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>(<name>carry</name> &gt;&gt; <name>PyLong_SHIFT</name>) == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
}</block></then> <else>else <block>{
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>size_a</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<decl_stmt><decl><type><name>twodigits</name></type> <name>carry</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>twodigits</name></type> <name>f</name> <init>= <expr><name><name>a</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>digit</name> *</type><name>pz</name> <init>= <expr><name><name>z</name>-&gt;<name>ob_digit</name></name> + <name>i</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>digit</name> *</type><name>pb</name> <init>= <expr><name><name>b</name>-&gt;<name>ob_digit</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>digit</name> *</type><name>pbend</name> <init>= <expr><name><name>b</name>-&gt;<name>ob_digit</name></name> + <name>size_b</name></expr></init></decl>;</decl_stmt>
<macro><name>SIGCHECK</name><argument_list>(<argument>{
Py_DECREF(z);
return NULL;
}</argument>)</argument_list></macro>
<while>while <condition>(<expr><name>pb</name> &lt; <name>pbend</name></expr>)</condition> <block>{
<expr_stmt><expr><name>carry</name> += *<name>pz</name> + *<name>pb</name>++ * <name>f</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>pz</name>++ = <call>(<name>digit</name>)<argument_list>(<argument><expr><name>carry</name> &amp; <name>PyLong_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>carry</name> &gt;&gt;= <name>PyLong_SHIFT</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>carry</name> &lt;= <name>PyLong_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></while>
<if>if <condition>(<expr><name>carry</name></expr>)</condition><then>
<expr_stmt><expr>*<name>pz</name> += <call>(<name>digit</name>)<argument_list>(<argument><expr><name>carry</name> &amp; <name>PyLong_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>(<name>carry</name> &gt;&gt; <name>PyLong_SHIFT</name>) == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
}</block></else></if>
<return>return <expr><call><name>long_normalize</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>kmul_split</name><parameter_list>(<param><decl><type><name>PyLongObject</name> *</type><name>n</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>, <param><decl><type><name>PyLongObject</name> **</type><name>high</name></decl></param>, <param><decl><type><name>PyLongObject</name> **</type><name>low</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>hi</name></decl>, *<decl><type ref="prev"/><name>lo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size_lo</name></decl>, <decl><type ref="prev"/><name>size_hi</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Py_ssize_t</name></type> <name>size_n</name> <init>= <expr><call><name>ABS</name><argument_list>(<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>size_lo</name> = <call><name>MIN</name><argument_list>(<argument><expr><name>size_n</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>size_hi</name> = <name>size_n</name> - <name>size_lo</name></expr>;</expr_stmt>
<if>if <condition>(<expr>(<name>hi</name> = <call><name>_PyLong_New</name><argument_list>(<argument><expr><name>size_hi</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr>(<name>lo</name> = <call><name>_PyLong_New</name><argument_list>(<argument><expr><name>size_lo</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>lo</name>-&gt;<name>ob_digit</name></name></expr></argument>, <argument><expr><name><name>n</name>-&gt;<name>ob_digit</name></name></expr></argument>, <argument><expr><name>size_lo</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>digit</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>hi</name>-&gt;<name>ob_digit</name></name></expr></argument>, <argument><expr><name><name>n</name>-&gt;<name>ob_digit</name></name> + <name>size_lo</name></expr></argument>, <argument><expr><name>size_hi</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>digit</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>high</name> = <call><name>long_normalize</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>low</name> = <call><name>long_normalize</name><argument_list>(<argument><expr><name>lo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function_decl><type><specifier>static</specifier> <name>PyLongObject</name> *</type><name>k_lopsided_mul</name><parameter_list>(<param><decl><type><name>PyLongObject</name> *</type><name>a</name></decl></param>, <param><decl><type><name>PyLongObject</name> *</type><name>b</name></decl></param>)</parameter_list>;</function_decl>
<function><type><specifier>static</specifier> <name>PyLongObject</name> *</type>
<name>k_mul</name><parameter_list>(<param><decl><type><name>PyLongObject</name> *</type><name>a</name></decl></param>, <param><decl><type><name>PyLongObject</name> *</type><name>b</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>asize</name> <init>= <expr><call><name>ABS</name><argument_list>(<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>bsize</name> <init>= <expr><call><name>ABS</name><argument_list>(<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>ah</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>al</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>bh</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>bl</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>t1</name></decl>, *<decl><type ref="prev"/><name>t2</name></decl>, *<decl><type ref="prev"/><name>t3</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>shift</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>asize</name> &gt; <name>bsize</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>t1</name> = <name>a</name></expr>;</expr_stmt>
<expr_stmt><expr><name>a</name> = <name>b</name></expr>;</expr_stmt>
<expr_stmt><expr><name>b</name> = <name>t1</name></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> = <name>asize</name></expr>;</expr_stmt>
<expr_stmt><expr><name>asize</name> = <name>bsize</name></expr>;</expr_stmt>
<expr_stmt><expr><name>bsize</name> = <name>i</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>i</name> = <name>a</name> == <name>b</name> ? <name>KARATSUBA_SQUARE_CUTOFF</name> : <name>KARATSUBA_CUTOFF</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>asize</name> &lt;= <name>i</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>asize</name> == 0</expr>)</condition><then>
<return>return <expr><call><name>_PyLong_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then>
<else>else
<return>return <expr><call><name>x_mul</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></then></if>
<if>if <condition>(<expr>2 * <name>asize</name> &lt;= <name>bsize</name></expr>)</condition><then>
<return>return <expr><call><name>k_lopsided_mul</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>shift</name> = <name>bsize</name> &gt;&gt; 1</expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>kmul_split</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>shift</name></expr></argument>, <argument><expr>&amp;<name>ah</name></expr></argument>, <argument><expr>&amp;<name>al</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <goto>goto <name>fail</name>;</goto></then></if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>ah</name></expr></argument>)</argument_list></call> &gt; 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>a</name> == <name>b</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>bh</name> = <name>ah</name></expr>;</expr_stmt>
<expr_stmt><expr><name>bl</name> = <name>al</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>bh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>bl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><call><name>kmul_split</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>shift</name></expr></argument>, <argument><expr>&amp;<name>bh</name></expr></argument>, <argument><expr>&amp;<name>bl</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <goto>goto <name>fail</name>;</goto></then></if></else></if>
<expr_stmt><expr><name>ret</name> = <call><name>_PyLong_New</name><argument_list>(<argument><expr><name>asize</name> + <name>bsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ret</name> == <name>NULL</name></expr>)</condition><then> <goto>goto <name>fail</name>;</goto></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_DEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>ret</name>-&gt;<name>ob_digit</name></name></expr></argument>, <argument><expr>0xDF</expr></argument>, <argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call> * <sizeof>sizeof<argument_list>(<argument><expr><name>digit</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr>(<name>t1</name> = <call><name>k_mul</name><argument_list>(<argument><expr><name>ah</name></expr></argument>, <argument><expr><name>bh</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <goto>goto <name>fail</name>;</goto></then></if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>2*<name>shift</name> + <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call> &lt;= <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>ret</name>-&gt;<name>ob_digit</name></name> + 2*<name>shift</name></expr></argument>, <argument><expr><name><name>t1</name>-&gt;<name>ob_digit</name></name></expr></argument>,
<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call> * <sizeof>sizeof<argument_list>(<argument><expr><name>digit</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> = <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call> - 2*<name>shift</name> - <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>i</name></expr>)</condition><then>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>ret</name>-&gt;<name>ob_digit</name></name> + 2*<name>shift</name> + <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>,
<argument><expr><name>i</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>digit</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr>(<name>t2</name> = <call><name>k_mul</name><argument_list>(<argument><expr><name>al</name></expr></argument>, <argument><expr><name>bl</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>
}</block></then></if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></call> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></call> &lt;= 2*<name>shift</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>ret</name>-&gt;<name>ob_digit</name></name></expr></argument>, <argument><expr><name><name>t2</name>-&gt;<name>ob_digit</name></name></expr></argument>, <argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></call> * <sizeof>sizeof<argument_list>(<argument><expr><name>digit</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> = 2*<name>shift</name> - <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>i</name></expr>)</condition><then>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>ret</name>-&gt;<name>ob_digit</name></name> + <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>i</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>digit</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>i</name> = <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call> - <name>shift</name></expr>;</expr_stmt>
<expr_stmt><expr>(<name>void</name>)<call><name>v_isub</name><argument_list>(<argument><expr><name><name>ret</name>-&gt;<name>ob_digit</name></name> + <name>shift</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>t2</name>-&gt;<name>ob_digit</name></name></expr></argument>, <argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>(<name>void</name>)<call><name>v_isub</name><argument_list>(<argument><expr><name><name>ret</name>-&gt;<name>ob_digit</name></name> + <name>shift</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>t1</name>-&gt;<name>ob_digit</name></name></expr></argument>, <argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>(<name>t1</name> = <call><name>x_add</name><argument_list>(<argument><expr><name>ah</name></expr></argument>, <argument><expr><name>al</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <goto>goto <name>fail</name>;</goto></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>ah</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>al</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ah</name> = <name>al</name> = <name>NULL</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>a</name> == <name>b</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>t2</name> = <name>t1</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr>(<name>t2</name> = <call><name>x_add</name><argument_list>(<argument><expr><name>bh</name></expr></argument>, <argument><expr><name>bl</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>
}</block></then></if></else></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>bh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>bl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>bh</name> = <name>bl</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>t3</name> = <call><name>k_mul</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>t3</name> == <name>NULL</name></expr>)</condition><then> <goto>goto <name>fail</name>;</goto></then></if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>t3</name></expr></argument>)</argument_list></call> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>(<name>void</name>)<call><name>v_iadd</name><argument_list>(<argument><expr><name><name>ret</name>-&gt;<name>ob_digit</name></name> + <name>shift</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>t3</name>-&gt;<name>ob_digit</name></name></expr></argument>, <argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>t3</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>t3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>long_normalize</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</return>
<label><name>fail</name>:</label>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>ah</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>al</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>bh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>bl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyLongObject</name> *</type>
<name>k_lopsided_mul</name><parameter_list>(<param><decl><type><name>PyLongObject</name> *</type><name>a</name></decl></param>, <param><decl><type><name>PyLongObject</name> *</type><name>b</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>Py_ssize_t</name></type> <name>asize</name> <init>= <expr><call><name>ABS</name><argument_list>(<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>bsize</name> <init>= <expr><call><name>ABS</name><argument_list>(<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>nbdone</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>bslice</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>asize</name> &gt; <name>KARATSUBA_CUTOFF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>2 * <name>asize</name> &lt;= <name>bsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> = <call><name>_PyLong_New</name><argument_list>(<argument><expr><name>asize</name> + <name>bsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ret</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>ret</name>-&gt;<name>ob_digit</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call> * <sizeof>sizeof<argument_list>(<argument><expr><name>digit</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>bslice</name> = <call><name>_PyLong_New</name><argument_list>(<argument><expr><name>asize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>bslice</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>fail</name>;</goto></then></if>
<expr_stmt><expr><name>nbdone</name> = 0</expr>;</expr_stmt>
<while>while <condition>(<expr><name>bsize</name> &gt; 0</expr>)</condition> <block>{
<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>product</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Py_ssize_t</name></type> <name>nbtouse</name> <init>= <expr><call><name>MIN</name><argument_list>(<argument><expr><name>bsize</name></expr></argument>, <argument><expr><name>asize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>bslice</name>-&gt;<name>ob_digit</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>ob_digit</name></name> + <name>nbdone</name></expr></argument>,
<argument><expr><name>nbtouse</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>digit</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>bslice</name></expr></argument>)</argument_list></call> = <name>nbtouse</name></expr>;</expr_stmt>
<expr_stmt><expr><name>product</name> = <call><name>k_mul</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>bslice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>product</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>fail</name>;</goto></then></if>
<expr_stmt><expr>(<name>void</name>)<call><name>v_iadd</name><argument_list>(<argument><expr><name><name>ret</name>-&gt;<name>ob_digit</name></name> + <name>nbdone</name></expr></argument>, <argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call> - <name>nbdone</name></expr></argument>,
<argument><expr><name><name>product</name>-&gt;<name>ob_digit</name></name></expr></argument>, <argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>product</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>product</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>bsize</name> -= <name>nbtouse</name></expr>;</expr_stmt>
<expr_stmt><expr><name>nbdone</name> += <name>nbtouse</name></expr>;</expr_stmt>
}</block></while>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>bslice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>long_normalize</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</return>
<label><name>fail</name>:</label>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>bslice</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>long_mul</name><parameter_list>(<param><decl><type><name>PyLongObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyLongObject</name> *</type><name>w</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>a</name></decl>, *<decl><type ref="prev"/><name>b</name></decl>, *<decl><type ref="prev"/><name>z</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>convert_binop</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>v</name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>w</name></expr></argument>, <argument><expr>&amp;<name>a</name></expr></argument>, <argument><expr>&amp;<name>b</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_NotImplemented</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_NotImplemented</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>z</name> = <call><name>k_mul</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>((<name><name>a</name>-&gt;<name>ob_size</name></name> ^ <name><name>b</name>-&gt;<name>ob_size</name></name>) &lt; 0) &amp;&amp; <name>z</name></expr>)</condition><then>
<expr_stmt><expr><name><name>z</name>-&gt;<name>ob_size</name></name> = -(<name><name>z</name>-&gt;<name>ob_size</name></name>)</expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *)<name>z</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>l_divmod</name><parameter_list>(<param><decl><type><name>PyLongObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyLongObject</name> *</type><name>w</name></decl></param>,
<param><decl><type><name>PyLongObject</name> **</type><name>pdiv</name></decl></param>, <param><decl><type><name>PyLongObject</name> **</type><name>pmod</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>div</name></decl>, *<decl><type ref="prev"/><name>mod</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>long_divrem</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr>&amp;<name>div</name></expr></argument>, <argument><expr>&amp;<name>mod</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr>(<call><name>Py_SIZE</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call> &lt; 0 &amp;&amp; <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call> &gt; 0) ||
(<call><name>Py_SIZE</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call> &gt; 0 &amp;&amp; <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call> &lt; 0)</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>temp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>one</name></decl>;</decl_stmt>
<expr_stmt><expr><name>temp</name> = (<name>PyLongObject</name> *) <call><name>long_add</name><argument_list>(<argument><expr><name>mod</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>mod</name> = <name>temp</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>mod</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>div</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>one</name> = (<name>PyLongObject</name> *) <call><name>PyLong_FromLong</name><argument_list>(<argument><expr>1L</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>one</name> == <name>NULL</name> ||
(<name>temp</name> = (<name>PyLongObject</name> *) <call><name>long_sub</name><argument_list>(<argument><expr><name>div</name></expr></argument>, <argument><expr><name>one</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>div</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>one</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>one</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>div</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>div</name> = <name>temp</name></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>pdiv</name> != <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr>*<name>pdiv</name> = <name>div</name></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>div</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<if>if <condition>(<expr><name>pmod</name> != <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr>*<name>pmod</name> = <name>mod</name></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>long_div</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>a</name></decl>, *<decl><type ref="prev"/><name>b</name></decl>, *<decl><type ref="prev"/><name>div</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>CONVERT_BINOP</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr>&amp;<name>a</name></expr></argument>, <argument><expr>&amp;<name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>l_divmod</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr>&amp;<name>div</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>div</name> = <name>NULL</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *)<name>div</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>long_classic_div</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>a</name></decl>, *<decl><type ref="prev"/><name>b</name></decl>, *<decl><type ref="prev"/><name>div</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>CONVERT_BINOP</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr>&amp;<name>a</name></expr></argument>, <argument><expr>&amp;<name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>Py_DivisionWarningFlag</name> &amp;&amp;
<call><name>PyErr_Warn</name><argument_list>(<argument><expr><name>PyExc_DeprecationWarning</name></expr></argument>, <argument><expr>"classic long division"</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>div</name> = <name>NULL</name></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><call><name>l_divmod</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr>&amp;<name>div</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>div</name> = <name>NULL</name></expr>;</expr_stmt></then></if></else></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *)<name>div</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>long_true_divide</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>a</name></decl>, *<decl><type ref="prev"/><name>b</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>ad</name></decl>, <decl><type ref="prev"/><name>bd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>failed</name></decl>, <decl><type ref="prev"/><name>aexp</name> <init>= <expr>-1</expr></init>, <name>bexp</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>CONVERT_BINOP</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr>&amp;<name>a</name></expr></argument>, <argument><expr>&amp;<name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ad</name> = <call><name>_PyLong_AsScaledDouble</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>a</name></expr></argument>, <argument><expr>&amp;<name>aexp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>bd</name> = <call><name>_PyLong_AsScaledDouble</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>b</name></expr></argument>, <argument><expr>&amp;<name>bexp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>failed</name> = (<name>ad</name> == -1.0 || <name>bd</name> == -1.0) &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>failed</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>aexp</name> &gt;= 0 &amp;&amp; <name>bexp</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>bd</name> == 0.0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ZeroDivisionError</name></expr></argument>,
<argument><expr>"long division or modulo by zero"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>ad</name> /= <name>bd</name></expr>;</expr_stmt>
<expr_stmt><expr><name>aexp</name> -= <name>bexp</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>aexp</name> &gt; <name>INT_MAX</name> / <name>PyLong_SHIFT</name></expr>)</condition><then>
<goto>goto <name>overflow</name>;</goto></then>
<else>else <if>if <condition>(<expr><name>aexp</name> &lt; -(<name>INT_MAX</name> / <name>PyLong_SHIFT</name>)</expr>)</condition><then>
<return>return <expr><call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr>0.0</expr></argument>)</argument_list></call></expr>;</return></then></if></else></if>
<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>ad</name> = <call><name>ldexp</name><argument_list>(<argument><expr><name>ad</name></expr></argument>, <argument><expr><name>aexp</name> * <name>PyLong_SHIFT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>Py_OVERFLOWED</name><argument_list>(<argument><expr><name>ad</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<goto>goto <name>overflow</name>;</goto></then></if>
<return>return <expr><call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr><name>ad</name></expr></argument>)</argument_list></call></expr>;</return>
<label><name>overflow</name>:</label>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
<argument><expr>"long/long too large for a float"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>long_mod</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>a</name></decl>, *<decl><type ref="prev"/><name>b</name></decl>, *<decl><type ref="prev"/><name>mod</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>CONVERT_BINOP</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr>&amp;<name>a</name></expr></argument>, <argument><expr>&amp;<name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>l_divmod</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>mod</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>mod</name> = <name>NULL</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *)<name>mod</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>long_divmod</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>a</name></decl>, *<decl><type ref="prev"/><name>b</name></decl>, *<decl><type ref="prev"/><name>div</name></decl>, *<decl><type ref="prev"/><name>mod</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>z</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>CONVERT_BINOP</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr>&amp;<name>a</name></expr></argument>, <argument><expr>&amp;<name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>l_divmod</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr>&amp;<name>div</name></expr></argument>, <argument><expr>&amp;<name>mod</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>z</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>z</name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyTuple_SetItem</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>(<name>PyObject</name> *) <name>div</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyTuple_SetItem</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>(<name>PyObject</name> *) <name>mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>div</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>mod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>z</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>long_pow</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>x</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>a</name></decl>, *<decl><type ref="prev"/><name>b</name></decl>, *<decl><type ref="prev"/><name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>negativeOutput</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>z</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>k</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>temp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyLongObject</name> *</type><name><name>table</name><index>[<expr>32</expr>]</index></name> <init>= <expr><block>{<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,
<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>,<expr>0</expr>
}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>CONVERT_BINOP</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr>&amp;<name>a</name></expr></argument>, <argument><expr>&amp;<name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyLong_Check</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>c</name> = (<name>PyLongObject</name> *)<name>x</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>c</name> = (<name>PyLongObject</name> *)<call><name>PyLong_FromLong</name><argument_list>(<argument><expr><call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>c</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>Error</name>;</goto></then></if>
}</block></then> <else>else <if>if <condition>(<expr><name>x</name> == <name>Py_None</name></expr>)</condition><then>
<expr_stmt><expr><name>c</name> = <name>NULL</name></expr>;</expr_stmt></then>
<else>else <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_NotImplemented</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_NotImplemented</name></expr>;</return>
}</block></else></if></else></if></else></if>
<if>if <condition>(<expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>c</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"pow() 2nd argument "
"cannot be negative when 3rd argument specified"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>Error</name>;</goto>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name><name>PyFloat_Type</name>.<name>tp_as_number</name>-&gt;<name>nb_power</name></name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></else></if>
}</block></then></if>
<if>if <condition>(<expr><name>c</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"pow() 3rd argument cannot be 0"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>Error</name>;</goto>
}</block></then></if>
<if>if <condition>(<expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>negativeOutput</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name>temp</name> = (<name>PyLongObject</name> *)<call><name>_PyLong_Copy</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>temp</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>Error</name>;</goto></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> = <name>temp</name></expr>;</expr_stmt>
<expr_stmt><expr><name>temp</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>c</name>-&gt;<name>ob_size</name></name> = - <name><name>c</name>-&gt;<name>ob_size</name></name></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr>(<call><name>Py_SIZE</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call> == 1) &amp;&amp; (<name><name>c</name>-&gt;<name>ob_digit</name><index>[<expr>0</expr>]</index></name> == 1)</expr>)</condition><then> <block>{
<expr_stmt><expr><name>z</name> = (<name>PyLongObject</name> *)<call><name>PyLong_FromLong</name><argument_list>(<argument><expr>0L</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>Done</name>;</goto>
}</block></then></if>
<if>if <condition>(<expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>l_divmod</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>temp</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<goto>goto <name>Error</name>;</goto></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>a</name> = <name>temp</name></expr>;</expr_stmt>
<expr_stmt><expr><name>temp</name> = <name>NULL</name></expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
<expr_stmt><expr><name>z</name> = (<name>PyLongObject</name> *)<call><name>PyLong_FromLong</name><argument_list>(<argument><expr>1L</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>z</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>Error</name>;</goto></then></if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REDUCE</name><parameter_list>(<param><type><name>X</name></type></param>)</parameter_list></cpp:macro> <cpp:value>if (c != NULL) { if (l_divmod(X, c, NULL, &amp;temp) &lt; 0) goto Error; Py_XDECREF(X); X = temp; temp = NULL; }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MULT</name><parameter_list>(<param><type><name>X</name></type></param>, <param><type><name>Y</name></type></param>, <param><type><name>result</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{ temp = (PyLongObject *)long_mul(X, Y); if (temp == NULL) goto Error; Py_XDECREF(result); result = temp; temp = NULL; REDUCE(result) }</cpp:value></cpp:define>
<if>if <condition>(<expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> &lt;= <name>FIVEARY_CUTOFF</name></expr>)</condition><then> <block>{
<for>for (<init><expr><name>i</name> = <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> - 1</expr>;</init> <condition><expr><name>i</name> &gt;= 0</expr>;</condition> <incr><expr>--<name>i</name></expr></incr>) <block>{
<decl_stmt><decl><type><name>digit</name></type> <name>bi</name> <init>= <expr><name><name>b</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<for>for (<init><expr><name>j</name> = 1 &lt;&lt; (<name>PyLong_SHIFT</name>-1)</expr>;</init> <condition><expr><name>j</name> != 0</expr>;</condition> <incr><expr><name>j</name> &gt;&gt;= 1</expr></incr>) <block>{
<macro><name>MULT</name><argument_list>(<argument>z</argument>, <argument>z</argument>, <argument>z</argument>)</argument_list></macro>
<if>if <condition>(<expr><name>bi</name> &amp; <name>j</name></expr>)</condition><then>
<macro><name>MULT</name><argument_list>(<argument>z</argument>, <argument>a</argument>, <argument>z</argument>)</argument_list></macro></then></if>
}</block></for>
}</block></for>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>table</name><index>[<expr>0</expr>]</index></name> = <name>z</name></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 1</expr>;</init> <condition><expr><name>i</name> &lt; 32</expr>;</condition> <incr><expr>++<name>i</name></expr></incr>)
<macro><name>MULT</name><argument_list>(<argument>table[i-1]</argument>, <argument>a</argument>, <argument>table[i]</argument>)</argument_list></macro>
<for>for (<init><expr><name>i</name> = <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> - 1</expr>;</init> <condition><expr><name>i</name> &gt;= 0</expr>;</condition> <incr><expr>--<name>i</name></expr></incr>) <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>digit</name></type> <name>bi</name> <init>= <expr><name><name>b</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<for>for (<init><expr><name>j</name> = <name>PyLong_SHIFT</name> - 5</expr>;</init> <condition><expr><name>j</name> &gt;= 0</expr>;</condition> <incr><expr><name>j</name> -= 5</expr></incr>) <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>index</name> <init>= <expr>(<name>bi</name> &gt;&gt; <name>j</name>) &amp; 0x1f</expr></init></decl>;</decl_stmt>
<for>for (<init><expr><name>k</name> = 0</expr>;</init> <condition><expr><name>k</name> &lt; 5</expr>;</condition> <incr><expr>++<name>k</name></expr></incr>)
<macro><name>MULT</name><argument_list>(<argument>z</argument>, <argument>z</argument>, <argument>z</argument>)</argument_list></macro>
<if>if <condition>(<expr><name>index</name></expr>)</condition><then>
<macro><name>MULT</name><argument_list>(<argument>z</argument>, <argument>table[index]</argument>, <argument>z</argument>)</argument_list></macro></then></if></for>
}</block></for>
}</block></for></for>
}</block></else></if>
<if>if <condition>(<expr><name>negativeOutput</name> &amp;&amp; (<call><name>Py_SIZE</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> != 0)</expr>)</condition><then> <block>{
<expr_stmt><expr><name>temp</name> = (<name>PyLongObject</name> *)<call><name>long_sub</name><argument_list>(<argument><expr><name>z</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>temp</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>Error</name>;</goto></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>z</name> = <name>temp</name></expr>;</expr_stmt>
<expr_stmt><expr><name>temp</name> = <name>NULL</name></expr>;</expr_stmt>
}</block></then></if>
<goto>goto <name>Done</name>;</goto>
<label><name>Error</name>:</label>
<if>if <condition>(<expr><name>z</name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>z</name> = <name>NULL</name></expr>;</expr_stmt>
}</block></then></if>
<label><name>Done</name>:</label>
<if>if <condition>(<expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> &gt; <name>FIVEARY_CUTOFF</name></expr>)</condition><then> <block>{
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; 32</expr>;</condition> <incr><expr>++<name>i</name></expr></incr>)
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>table</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
}</block></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *)<name>z</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>long_invert</name><parameter_list>(<param><decl><type><name>PyLongObject</name> *</type><name>v</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>x</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>w</name></decl>;</decl_stmt>
<expr_stmt><expr><name>w</name> = (<name>PyLongObject</name> *)<call><name>PyLong_FromLong</name><argument_list>(<argument><expr>1L</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>w</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>x</name> = (<name>PyLongObject</name> *) <call><name>long_add</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>x</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> = -(<call><name>Py_SIZE</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *)<name>x</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>long_neg</name><parameter_list>(<param><decl><type><name>PyLongObject</name> *</type><name>v</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>z</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>v</name>-&gt;<name>ob_size</name></name> == 0 &amp;&amp; <call><name>PyLong_CheckExact</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *) <name>v</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>z</name> = (<name>PyLongObject</name> *)<call><name>_PyLong_Copy</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>z</name> != <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><name><name>z</name>-&gt;<name>ob_size</name></name> = -(<name><name>v</name>-&gt;<name>ob_size</name></name>)</expr>;</expr_stmt></then></if>
<return>return <expr>(<name>PyObject</name> *)<name>z</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>long_abs</name><parameter_list>(<param><decl><type><name>PyLongObject</name> *</type><name>v</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name><name>v</name>-&gt;<name>ob_size</name></name> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name>long_neg</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</return></then>
<else>else
<return>return <expr><call><name>long_long</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>v</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>long_nonzero</name><parameter_list>(<param><decl><type><name>PyLongObject</name> *</type><name>v</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>ABS</name><argument_list>(<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> != 0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>long_rshift</name><parameter_list>(<param><decl><type><name>PyLongObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyLongObject</name> *</type><name>w</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>a</name></decl>, *<decl><type ref="prev"/><name>b</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>z</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>shiftby</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>newsize</name></decl>, <decl><type ref="prev"/><name>wordshift</name></decl>, <decl><type ref="prev"/><name>loshift</name></decl>, <decl><type ref="prev"/><name>hishift</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>digit</name></type> <name>lomask</name></decl>, <decl><type ref="prev"/><name>himask</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>CONVERT_BINOP</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>v</name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>w</name></expr></argument>, <argument><expr>&amp;<name>a</name></expr></argument>, <argument><expr>&amp;<name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>a1</name></decl>, *<decl><type ref="prev"/><name>a2</name></decl>;</decl_stmt>
<expr_stmt><expr><name>a1</name> = (<name>PyLongObject</name> *) <call><name>long_invert</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>a1</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>rshift_error</name>;</goto></then></if>
<expr_stmt><expr><name>a2</name> = (<name>PyLongObject</name> *) <call><name>long_rshift</name><argument_list>(<argument><expr><name>a1</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>a1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>a2</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>rshift_error</name>;</goto></then></if>
<expr_stmt><expr><name>z</name> = (<name>PyLongObject</name> *) <call><name>long_invert</name><argument_list>(<argument><expr><name>a2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>a2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>shiftby</name> = <call><name>PyLong_AsLong</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>shiftby</name> == -1L &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<goto>goto <name>rshift_error</name>;</goto></then></if>
<if>if <condition>(<expr><name>shiftby</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"negative shift count"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>rshift_error</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>wordshift</name> = <name>shiftby</name> / <name>PyLong_SHIFT</name></expr>;</expr_stmt>
<expr_stmt><expr><name>newsize</name> = <call><name>ABS</name><argument_list>(<argument><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> - <name>wordshift</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>newsize</name> &lt;= 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>z</name> = <call><name>_PyLong_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *)<name>z</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>loshift</name> = <name>shiftby</name> % <name>PyLong_SHIFT</name></expr>;</expr_stmt>
<expr_stmt><expr><name>hishift</name> = <name>PyLong_SHIFT</name> - <name>loshift</name></expr>;</expr_stmt>
<expr_stmt><expr><name>lomask</name> = ((<name>digit</name>)1 &lt;&lt; <name>hishift</name>) - 1</expr>;</expr_stmt>
<expr_stmt><expr><name>himask</name> = <name>PyLong_MASK</name> ^ <name>lomask</name></expr>;</expr_stmt>
<expr_stmt><expr><name>z</name> = <call><name>_PyLong_New</name><argument_list>(<argument><expr><name>newsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>z</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>rshift_error</name>;</goto></then></if>
<if>if <condition>(<expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call> = -(<call><name>Py_SIZE</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>, <expr><name>j</name> = <name>wordshift</name></expr>;</init> <condition><expr><name>i</name> &lt; <name>newsize</name></expr>;</condition> <incr><expr><name>i</name>++</expr>, <expr><name>j</name>++</expr></incr>) <block>{
<expr_stmt><expr><name><name>z</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name> = (<name><name>a</name>-&gt;<name>ob_digit</name><index>[<expr><name>j</name></expr>]</index></name> &gt;&gt; <name>loshift</name>) &amp; <name>lomask</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>i</name>+1 &lt; <name>newsize</name></expr>)</condition><then>
<expr_stmt><expr><name><name>z</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name> |=
(<name><name>a</name>-&gt;<name>ob_digit</name><index>[<expr><name>j</name>+1</expr>]</index></name> &lt;&lt; <name>hishift</name>) &amp; <name>himask</name></expr>;</expr_stmt></then></if>
}</block></for>
<expr_stmt><expr><name>z</name> = <call><name>long_normalize</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<label><name>rshift_error</name>:</label>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *) <name>z</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>long_lshift</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>a</name></decl>, *<decl><type ref="prev"/><name>b</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>z</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>shiftby</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>oldsize</name></decl>, <decl><type ref="prev"/><name>newsize</name></decl>, <decl><type ref="prev"/><name>wordshift</name></decl>, <decl><type ref="prev"/><name>remshift</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>twodigits</name></type> <name>accum</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>CONVERT_BINOP</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr>&amp;<name>a</name></expr></argument>, <argument><expr>&amp;<name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>shiftby</name> = <call><name>PyLong_AsLong</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>shiftby</name> == -1L &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<goto>goto <name>lshift_error</name>;</goto></then></if>
<if>if <condition>(<expr><name>shiftby</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"negative shift count"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>lshift_error</name>;</goto>
}</block></then></if>
<if>if <condition>(<expr>(<name>long</name>)(<name>int</name>)<name>shiftby</name> != <name>shiftby</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"outrageous left shift count"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>lshift_error</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>wordshift</name> = (<name>int</name>)<name>shiftby</name> / <name>PyLong_SHIFT</name></expr>;</expr_stmt>
<expr_stmt><expr><name>remshift</name> = (<name>int</name>)<name>shiftby</name> - <name>wordshift</name> * <name>PyLong_SHIFT</name></expr>;</expr_stmt>
<expr_stmt><expr><name>oldsize</name> = <call><name>ABS</name><argument_list>(<argument><expr><name><name>a</name>-&gt;<name>ob_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>newsize</name> = <name>oldsize</name> + <name>wordshift</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>remshift</name></expr>)</condition><then>
<expr_stmt><expr>++<name>newsize</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>z</name> = <call><name>_PyLong_New</name><argument_list>(<argument><expr><name>newsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>z</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>lshift_error</name>;</goto></then></if>
<if>if <condition>(<expr><name><name>a</name>-&gt;<name>ob_size</name></name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name><name>z</name>-&gt;<name>ob_size</name></name> = -(<name><name>z</name>-&gt;<name>ob_size</name></name>)</expr>;</expr_stmt></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>wordshift</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
<expr_stmt><expr><name><name>z</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name> = 0</expr>;</expr_stmt></for>
<expr_stmt><expr><name>accum</name> = 0</expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = <name>wordshift</name></expr>, <expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name>oldsize</name></expr>;</condition> <incr><expr><name>i</name>++</expr>, <expr><name>j</name>++</expr></incr>) <block>{
<expr_stmt><expr><name>accum</name> |= (<name>twodigits</name>)<name><name>a</name>-&gt;<name>ob_digit</name><index>[<expr><name>j</name></expr>]</index></name> &lt;&lt; <name>remshift</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>z</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name> = <call>(<name>digit</name>)<argument_list>(<argument><expr><name>accum</name> &amp; <name>PyLong_MASK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>accum</name> &gt;&gt;= <name>PyLong_SHIFT</name></expr>;</expr_stmt>
}</block></for>
<if>if <condition>(<expr><name>remshift</name></expr>)</condition><then>
<expr_stmt><expr><name><name>z</name>-&gt;<name>ob_digit</name><index>[<expr><name>newsize</name>-1</expr>]</index></name> = (<name>digit</name>)<name>accum</name></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>!<name>accum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<expr_stmt><expr><name>z</name> = <call><name>long_normalize</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>lshift_error</name>:</label>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *) <name>z</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>long_bitwise</name><parameter_list>(<param><decl><type><name>PyLongObject</name> *</type><name>a</name></decl></param>,
<param><decl><type><name>int</name></type> <name>op</name></decl></param>,
<param><decl><type><name>PyLongObject</name> *</type><name>b</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>digit</name></type> <name>maska</name></decl>, <decl><type ref="prev"/><name>maskb</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>negz</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size_a</name></decl>, <decl><type ref="prev"/><name>size_b</name></decl>, <decl><type ref="prev"/><name>size_z</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>z</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>digit</name></type> <name>diga</name></decl>, <decl><type ref="prev"/><name>digb</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>a</name> = (<name>PyLongObject</name> *) <call><name>long_invert</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>a</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>maska</name> = <name>PyLong_MASK</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>maska</name> = 0</expr>;</expr_stmt>
}</block></else></if>
<if>if <condition>(<expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>b</name> = (<name>PyLongObject</name> *) <call><name>long_invert</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>b</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>maskb</name> = <name>PyLong_MASK</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>maskb</name> = 0</expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><name>negz</name> = 0</expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{
<case>case <expr>'^'</expr>:
<if>if <condition>(<expr><name>maska</name> != <name>maskb</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>maska</name> ^= <name>PyLong_MASK</name></expr>;</expr_stmt>
<expr_stmt><expr><name>negz</name> = -1</expr>;</expr_stmt>
}</block></then></if>
<break>break;</break>
</case><case>case <expr>'&amp;'</expr>:
<if>if <condition>(<expr><name>maska</name> &amp;&amp; <name>maskb</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>op</name> = '|'</expr>;</expr_stmt>
<expr_stmt><expr><name>maska</name> ^= <name>PyLong_MASK</name></expr>;</expr_stmt>
<expr_stmt><expr><name>maskb</name> ^= <name>PyLong_MASK</name></expr>;</expr_stmt>
<expr_stmt><expr><name>negz</name> = -1</expr>;</expr_stmt>
}</block></then></if>
<break>break;</break>
</case><case>case <expr>'|'</expr>:
<if>if <condition>(<expr><name>maska</name> || <name>maskb</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>op</name> = '&amp;'</expr>;</expr_stmt>
<expr_stmt><expr><name>maska</name> ^= <name>PyLong_MASK</name></expr>;</expr_stmt>
<expr_stmt><expr><name>maskb</name> ^= <name>PyLong_MASK</name></expr>;</expr_stmt>
<expr_stmt><expr><name>negz</name> = -1</expr>;</expr_stmt>
}</block></then></if>
<break>break;</break>
</case>}</block></switch>
<expr_stmt><expr><name>size_a</name> = <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>size_b</name> = <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>size_z</name> = <name>op</name> == '&amp;'
? (<name>maska</name>
? <name>size_b</name>
: (<name>maskb</name> ? <name>size_a</name> : <call><name>MIN</name><argument_list>(<argument><expr><name>size_a</name></expr></argument>, <argument><expr><name>size_b</name></expr></argument>)</argument_list></call>))
: <call><name>MAX</name><argument_list>(<argument><expr><name>size_a</name></expr></argument>, <argument><expr><name>size_b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>z</name> = <call><name>_PyLong_New</name><argument_list>(<argument><expr><name>size_z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>z</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>size_z</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<expr_stmt><expr><name>diga</name> = (<name>i</name> &lt; <name>size_a</name> ? <name><name>a</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name> : 0) ^ <name>maska</name></expr>;</expr_stmt>
<expr_stmt><expr><name>digb</name> = (<name>i</name> &lt; <name>size_b</name> ? <name><name>b</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name> : 0) ^ <name>maskb</name></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{
<case>case <expr>'&amp;'</expr>:
<expr_stmt><expr><name><name>z</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name> = <name>diga</name> &amp; <name>digb</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'|'</expr>:
<expr_stmt><expr><name><name>z</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name> = <name>diga</name> | <name>digb</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'^'</expr>:
<expr_stmt><expr><name><name>z</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name> = <name>diga</name> ^ <name>digb</name></expr>;</expr_stmt>
<break>break;</break>
</case>}</block></switch>
}</block></for>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>z</name> = <call><name>long_normalize</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>negz</name> == 0</expr>)</condition><then>
<return>return <expr>(<name>PyObject</name> *) <name>z</name></expr>;</return></then></if>
<expr_stmt><expr><name>v</name> = <call><name>long_invert</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>v</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>long_and</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>a</name></decl>, *<decl><type ref="prev"/><name>b</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>c</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>CONVERT_BINOP</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr>&amp;<name>a</name></expr></argument>, <argument><expr>&amp;<name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> = <call><name>long_bitwise</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr>'&amp;'</expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>c</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>long_xor</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>a</name></decl>, *<decl><type ref="prev"/><name>b</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>c</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>CONVERT_BINOP</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr>&amp;<name>a</name></expr></argument>, <argument><expr>&amp;<name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> = <call><name>long_bitwise</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr>'^'</expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>c</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>long_or</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>a</name></decl>, *<decl><type ref="prev"/><name>b</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>c</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>CONVERT_BINOP</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr>&amp;<name>a</name></expr></argument>, <argument><expr>&amp;<name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> = <call><name>long_bitwise</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr>'|'</expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>c</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>long_coerce</name><parameter_list>(<param><decl><type><name>PyObject</name> **</type><name>pv</name></decl></param>, <param><decl><type><name>PyObject</name> **</type><name>pw</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr>*<name>pw</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>pw</name> = <call><name>PyLong_FromLong</name><argument_list>(<argument><expr><call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr>*<name>pw</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>*<name>pw</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>*<name>pv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><call><name>PyLong_Check</name><argument_list>(<argument><expr>*<name>pw</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>*<name>pv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr>*<name>pw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if></else></if>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>long_long</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><call><name>PyLong_CheckExact</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>v</name> = <call><name>_PyLong_Copy</name><argument_list>(<argument><expr>(<name>PyLongObject</name> *)<name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<return>return <expr><name>v</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>long_int</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>long</name></type> <name>x</name></decl>;</decl_stmt>
<expr_stmt><expr><name>x</name> = <call><name>PyLong_AsLong</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyLong_CheckExact</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>v</name></expr>;</return>
}</block></then> <else>else
<return>return <expr><call><name>_PyLong_Copy</name><argument_list>(<argument><expr>(<name>PyLongObject</name> *)<name>v</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></then> <else>else
<return>return <expr><name>NULL</name></expr>;</return></else></if>
}</block></then></if>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>long_float</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>double</name></type> <name>result</name></decl>;</decl_stmt>
<expr_stmt><expr><name>result</name> = <call><name>PyLong_AsDouble</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> == -1.0 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>PyFloat_FromDouble</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>long_oct</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>_PyLong_Format</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>8</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>long_hex</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>_PyLong_Format</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr>16</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>long_subtype_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list>;</function_decl>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>long_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>x</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>base</name> <init>= <expr>-909</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>kwlist</name><index>[]</index></name> <init>= <expr><block>{<expr>"x"</expr>, <expr>"base"</expr>, <expr>0</expr>}</block></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>type</name> != &amp;<name>PyLong_Type</name></expr>)</condition><then>
<return>return <expr><call><name>long_subtype_new</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>, <argument><expr>"|Oi:long"</expr></argument>, <argument><expr><name>kwlist</name></expr></argument>,
<argument><expr>&amp;<name>x</name></expr></argument>, <argument><expr>&amp;<name>base</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>x</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><call><name>PyLong_FromLong</name><argument_list>(<argument><expr>0L</expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><name>base</name> == -909</expr>)</condition><then>
<return>return <expr><call><name>PyNumber_Long</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return></then>
<else>else <if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>string</name> <init>= <expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call> != <call><name>PyString_Size</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>srepr</name></decl>;</decl_stmt>
<expr_stmt><expr><name>srepr</name> = <call><name>PyObject_Repr</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>srepr</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"invalid literal for long() with base %d: %s"</expr></argument>,
<argument><expr><name>base</name></expr></argument>, <argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>srepr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>srepr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>PyLong_FromString</name><argument_list>(<argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_USING_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<else>else <if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>PyLong_FromUnicode</name><argument_list>(<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</return></then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<else>else <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"long() can't convert non-string with explicit base"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></else></if></else></if></else></if>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>long_subtype_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyLongObject</name> *</type><name>tmp</name></decl>, *<decl><type ref="prev"/><name>newobj</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyType_IsSubtype</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr>&amp;<name>PyLong_Type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tmp</name> = (<name>PyLongObject</name> *)<call><name>long_new</name><argument_list>(<argument><expr>&amp;<name>PyLong_Type</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>tmp</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyLong_CheckExact</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> = <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>n</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>n</name> = -<name>n</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>newobj</name> = (<name>PyLongObject</name> *)<call><name><name>type</name>-&gt;<name>tp_alloc</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>newobj</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyLong_Check</name><argument_list>(<argument><expr><name>newobj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_SIZE</name><argument_list>(<argument><expr><name>newobj</name></expr></argument>)</argument_list></call> = <call><name>Py_SIZE</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>n</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
<expr_stmt><expr><name><name>newobj</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name> = <name><name>tmp</name>-&gt;<name>ob_digit</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></for>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *)<name>newobj</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>long_getnewargs</name><parameter_list>(<param><decl><type><name>PyLongObject</name> *</type><name>v</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(N)"</expr></argument>, <argument><expr><call><name>_PyLong_Copy</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>long_getN</name><parameter_list>(<param><decl><type><name>PyLongObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>void</name> *</type><name>context</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>PyLong_FromLong</name><argument_list>(<argument><expr>(<name>Py_intptr_t</name>)<name>context</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>long__format__</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>format_spec</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O:__format__"</expr></argument>, <argument><expr>&amp;<name>format_spec</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>PyBytes_Check</name><argument_list>(<argument><expr><name>format_spec</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>_PyLong_FormatAdvanced</name><argument_list>(<argument><expr><name>self</name></expr></argument>,
<argument><expr><call><name>PyBytes_AS_STRING</name><argument_list>(<argument><expr><name>format_spec</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>PyBytes_GET_SIZE</name><argument_list>(<argument><expr><name>format_spec</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>format_spec</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>str_spec</name> <init>= <expr><call><name>PyObject_Str</name><argument_list>(<argument><expr><name>format_spec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>str_spec</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>result</name> = <call><name>_PyLong_FormatAdvanced</name><argument_list>(<argument><expr><name>self</name></expr></argument>,
<argument><expr><call><name>PyBytes_AS_STRING</name><argument_list>(<argument><expr><name>str_spec</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>PyBytes_GET_SIZE</name><argument_list>(<argument><expr><name>str_spec</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str_spec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"__format__ requires str or unicode"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>long_sizeof</name><parameter_list>(<param><decl><type><name>PyLongObject</name> *</type><name>v</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>res</name></decl>;</decl_stmt>
<expr_stmt><expr><name>res</name> = <name><name>v</name>-&gt;<name>ob_type</name>-&gt;<name>tp_basicsize</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>v</name>-&gt;<name>ob_size</name></name> != 0</expr>)</condition><then>
<expr_stmt><expr><name>res</name> += <call><name>abs</name><argument_list>(<argument><expr><name><name>v</name>-&gt;<name>ob_size</name></name></expr></argument>)</argument_list></call> * <sizeof>sizeof<argument_list>(<argument><expr><name>digit</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt></then></if>
<return>return <expr><call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
static PyObject *
long_is_finite(PyObject *v) {
Py_RETURN_TRUE;
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>long_methods</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{
<expr>"conjugate"</expr>, <expr>(<name>PyCFunction</name>)<name>long_long</name></expr>, <expr><name>METH_NOARGS</name></expr>,
<expr>"Returns self, the complex conjugate of any long."</expr>
}</block></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
{
"is_finite", (PyCFunction)long_is_finite, METH_NOARGS,
"Returns always True."
},
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr><block>{
<expr>"__trunc__"</expr>, <expr>(<name>PyCFunction</name>)<name>long_long</name></expr>, <expr><name>METH_NOARGS</name></expr>,
<expr>"Truncating an Integral returns itself."</expr>
}</block></expr>,
<expr><block>{<expr>"__getnewargs__"</expr>, <expr>(<name>PyCFunction</name>)<name>long_getnewargs</name></expr>, <expr><name>METH_NOARGS</name></expr>}</block></expr>,
<expr><block>{<expr>"__format__"</expr>, <expr>(<name>PyCFunction</name>)<name>long__format__</name></expr>, <expr><name>METH_VARARGS</name></expr>}</block></expr>,
<expr><block>{
<expr>"__sizeof__"</expr>, <expr>(<name>PyCFunction</name>)<name>long_sizeof</name></expr>, <expr><name>METH_NOARGS</name></expr>,
<expr>"Returns size in memory, in bytes"</expr>
}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyGetSetDef</name></type> <name><name>long_getset</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{
<expr>"real"</expr>,
<expr>(<name>getter</name>)<name>long_long</name></expr>, <expr>(<name>setter</name>)<name>NULL</name></expr>,
<expr>"the real part of a complex number"</expr>,
<expr><name>NULL</name></expr>
}</block></expr>,
<expr><block>{
<expr>"imag"</expr>,
<expr>(<name>getter</name>)<name>long_getN</name></expr>, <expr>(<name>setter</name>)<name>NULL</name></expr>,
<expr>"the imaginary part of a complex number"</expr>,
<expr>(<name>void</name>*)0</expr>
}</block></expr>,
<expr><block>{
<expr>"numerator"</expr>,
<expr>(<name>getter</name>)<name>long_long</name></expr>, <expr>(<name>setter</name>)<name>NULL</name></expr>,
<expr>"the numerator of a rational number in lowest terms"</expr>,
<expr><name>NULL</name></expr>
}</block></expr>,
<expr><block>{
<expr>"denominator"</expr>,
<expr>(<name>getter</name>)<name>long_getN</name></expr>, <expr>(<name>setter</name>)<name>NULL</name></expr>,
<expr>"the denominator of a rational number in lowest terms"</expr>,
<expr>(<name>void</name>*)1</expr>
}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>long_doc</name></expr></argument>,
<argument><expr>"long(x[, base]) -&gt; integer\n\
\n\
Convert a string or number to a long integer, if possible. A floating\n\
point argument will be truncated towards zero (this does not include a\n\
string representation of a floating point number!) When converting a\n\
string, use the optional base. It is an error to supply a base when\n\
converting a non-string."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyNumberMethods</name></type> <name>long_as_number</name> <init>= <expr><block>{
<expr>(<name>binaryfunc</name>) <name>long_add</name></expr>,
<expr>(<name>binaryfunc</name>) <name>long_sub</name></expr>,
<expr>(<name>binaryfunc</name>) <name>long_mul</name></expr>,
<expr><name>long_classic_div</name></expr>,
<expr><name>long_mod</name></expr>,
<expr><name>long_divmod</name></expr>,
<expr><name>long_pow</name></expr>,
<expr>(<name>unaryfunc</name>) <name>long_neg</name></expr>,
<expr>(<name>unaryfunc</name>) <name>long_long</name></expr>,
<expr>(<name>unaryfunc</name>) <name>long_abs</name></expr>,
<expr>(<name>inquiry</name>) <name>long_nonzero</name></expr>,
<expr>(<name>unaryfunc</name>) <name>long_invert</name></expr>,
<expr><name>long_lshift</name></expr>,
<expr>(<name>binaryfunc</name>) <name>long_rshift</name></expr>,
<expr><name>long_and</name></expr>,
<expr><name>long_xor</name></expr>,
<expr><name>long_or</name></expr>,
<expr><name>long_coerce</name></expr>,
<expr><name>long_int</name></expr>,
<expr><name>long_long</name></expr>,
<expr><name>long_float</name></expr>,
<expr><name>long_oct</name></expr>,
<expr><name>long_hex</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>long_div</name></expr>,
<expr><name>long_true_divide</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>long_long</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyTypeObject</name></type> <name>PyLong_Type</name> <init>= <expr><block>{
<expr><call><name>PyObject_HEAD_INIT</name><argument_list>(<argument><expr>&amp;<name>PyType_Type</name></expr></argument>)</argument_list></call>
0</expr>,
<expr>"long"</expr>,
<expr><sizeof>sizeof<argument_list>(<argument><expr><name>PyLongObject</name></expr></argument>)</argument_list></sizeof> - <sizeof>sizeof<argument_list>(<argument><expr><name>digit</name></expr></argument>)</argument_list></sizeof></expr>,
<expr><sizeof>sizeof<argument_list>(<argument><expr><name>digit</name></expr></argument>)</argument_list></sizeof></expr>,
<expr><name>long_dealloc</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>(<name>cmpfunc</name>)<name>long_compare</name></expr>,
<expr><name>long_repr</name></expr>,
<expr>&amp;<name>long_as_number</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>(<name>hashfunc</name>)<name>long_hash</name></expr>,
<expr>0</expr>,
<expr><name>long_str</name></expr>,
<expr><name>PyObject_GenericGetAttr</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_CHECKTYPES</name> |
<name>Py_TPFLAGS_BASETYPE</name> | <name>Py_TPFLAGS_LONG_SUBCLASS</name></expr>,
<expr><name>long_doc</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>long_methods</name></expr>,
<expr>0</expr>,
<expr><name>long_getset</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>long_new</name></expr>,
<expr><name>PyObject_Del</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
</unit>
