<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="Objects/fileobject.c"><cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PY_SSIZE_T_CLEAN</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"structmember.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SYS_TYPES_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/types.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>fileno</name></cpp:macro> <cpp:value>_fileno</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HAVE_FTRUNCATE</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WIN32_LEAN_AND_MEAN</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;windows.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>_MSC_VER</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WIN32_LEAN_AND_MEAN</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;windows.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>PYOS_OS2</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>PYCC_GCC</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;io.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BUF</name><parameter_list>(<param><type><name>v</name></type></param>)</parameter_list></cpp:macro> <cpp:value>PyString_AS_STRING((PyStringObject *)v)</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>DONT_HAVE_ERRNO_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETC_UNLOCKED</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GETC</name><parameter_list>(<param><type><name>f</name></type></param>)</parameter_list></cpp:macro> <cpp:value>getc_unlocked(f)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLOCKFILE</name><parameter_list>(<param><type><name>f</name></type></param>)</parameter_list></cpp:macro> <cpp:value>flockfile(f)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FUNLOCKFILE</name><parameter_list>(<param><type><name>f</name></type></param>)</parameter_list></cpp:macro> <cpp:value>funlockfile(f)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GETC</name><parameter_list>(<param><type><name>f</name></type></param>)</parameter_list></cpp:macro> <cpp:value>getc(f)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLOCKFILE</name><parameter_list>(<param><type><name>f</name></type></param>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FUNLOCKFILE</name><parameter_list>(<param><type><name>f</name></type></param>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NEWLINE_UNKNOWN</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NEWLINE_CR</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NEWLINE_LF</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NEWLINE_CRLF</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FILE_BEGIN_ALLOW_THREADS</name><parameter_list>(<param><type><name>fobj</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{ fobj-&gt;unlocked_count++; Py_BEGIN_ALLOW_THREADS</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FILE_END_ALLOW_THREADS</name><parameter_list>(<param><type><name>fobj</name></type></param>)</parameter_list></cpp:macro> <cpp:value>Py_END_ALLOW_THREADS fobj-&gt;unlocked_count--; assert(fobj-&gt;unlocked_count &gt;= 0); }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FILE_ABORT_ALLOW_THREADS</name><parameter_list>(<param><type><name>fobj</name></type></param>)</parameter_list></cpp:macro> <cpp:value>Py_BLOCK_THREADS fobj-&gt;unlocked_count--; assert(fobj-&gt;unlocked_count &gt;= 0);</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call></expr></cpp:if>
<extern>extern "C" <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>FILE</name> *</type>
<name>PyFile_AsFile</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name>f</name> == <name>NULL</name> || !<call><name>PyFile_Check</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then>
<else>else
<return>return <expr>((<name>PyFileObject</name> *)<name>f</name>)-&gt;<name>f_fp</name></expr>;</return></else></if>
}</block></function>
<function><type><name>void</name></type> <name>PyFile_IncUseCount</name><parameter_list>(<param><decl><type><name>PyFileObject</name> *</type><name>fobj</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name><name>fobj</name>-&gt;<name>unlocked_count</name></name>++</expr>;</expr_stmt>
}</block></function>
<function><type><name>void</name></type> <name>PyFile_DecUseCount</name><parameter_list>(<param><decl><type><name>PyFileObject</name> *</type><name>fobj</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name><name>fobj</name>-&gt;<name>unlocked_count</name></name>--</expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>fobj</name>-&gt;<name>unlocked_count</name></name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><name>PyObject</name> *</type>
<name>PyFile_Name</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name>f</name> == <name>NULL</name> || !<call><name>PyFile_Check</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then>
<else>else
<return>return <expr>((<name>PyFileObject</name> *)<name>f</name>)-&gt;<name>f_name</name></expr>;</return></else></if>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>file_PyObject_Print</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>op</name></decl></param>, <param><decl><type><name>PyFileObject</name> *</type><name>f</name></decl></param>, <param><decl><type><name>int</name></type> <name>flags</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PyFile_IncUseCount</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> = <call><name>PyObject_Print</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>f_fp</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyFile_DecUseCount</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyFileObject</name>*</type>
<name>dircheck</name><parameter_list>(<param><decl><type><name>PyFileObject</name>*</type> <name>f</name></decl></param>)</parameter_list> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FSTAT</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>S_IFDIR</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>EISDIR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type>struct <name>stat</name></type> <name>buf</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>f</name>-&gt;<name>f_fp</name></name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>f</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>fstat</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>f_fp</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>buf</name></expr></argument>)</argument_list></call> == 0 &amp;&amp;
<call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>buf</name>.<name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>msg</name> <init>= <expr><call><name>strerror</name><argument_list>(<argument><expr><name>EISDIR</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>exc</name> <init>= <expr><call><name>PyObject_CallFunction</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>, <argument><expr>"(is)"</expr></argument>,
<argument><expr><name>EISDIR</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PyErr_SetObject</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>, <argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><name>f</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>fill_file_fields</name><parameter_list>(<param><decl><type><name>PyFileObject</name> *</type><name>f</name></decl></param>, <param><decl><type><name>FILE</name> *</type><name>fp</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>name</name></decl></param>, <param><decl><type><name>char</name> *</type><name>mode</name></decl></param>,
<param><function_decl><type><name>int</name></type> (*<name>close</name>)<parameter_list>(<param><decl><type><name>FILE</name> *</type></decl></param>)</parameter_list></function_decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>name</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>f</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyFile_Check</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>f_fp</name></name> == <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>f_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>f_mode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>f_encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>f_errors</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>f</name>-&gt;<name>f_name</name></name> = <name>name</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>f</name>-&gt;<name>f_mode</name></name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>f</name>-&gt;<name>f_close</name></name> = <name>close</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>f</name>-&gt;<name>f_softspace</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>f</name>-&gt;<name>f_binary</name></name> = <call><name>strchr</name><argument_list>(<argument><expr><name>mode</name></expr></argument>,<argument><expr>'b'</expr></argument>)</argument_list></call> != <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>f</name>-&gt;<name>f_buf</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>f</name>-&gt;<name>f_univ_newline</name></name> = (<call><name>strchr</name><argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr>'U'</expr></argument>)</argument_list></call> != <name>NULL</name>)</expr>;</expr_stmt>
<expr_stmt><expr><name><name>f</name>-&gt;<name>f_newlinetypes</name></name> = <name>NEWLINE_UNKNOWN</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>f</name>-&gt;<name>f_skipnextlf</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>f</name>-&gt;<name>f_encoding</name></name> = <name>Py_None</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>f</name>-&gt;<name>f_errors</name></name> = <name>Py_None</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>f</name>-&gt;<name>f_mode</name></name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>f</name>-&gt;<name>f_fp</name></name> = <name>fp</name></expr>;</expr_stmt>
<expr_stmt><expr><name>f</name> = <call><name>dircheck</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *) <name>f</name></expr>;</return>
}</block></function>
<function><type><name>int</name></type>
<name>_PyFile_SanitizeMode</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>mode</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>upos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>len</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"empty mode string"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>upos</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr>'U'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>upos</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>upos</name></expr></argument>, <argument><expr><name>upos</name>+1</expr></argument>, <argument><expr><name>len</name>-(<name>upos</name>-<name>mode</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>mode</name><index>[<expr>0</expr>]</index></name> == 'w' || <name><name>mode</name><index>[<expr>0</expr>]</index></name> == 'a'</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"universal newline "
"mode can only be used with modes "
"starting with 'r'"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name><name>mode</name><index>[<expr>0</expr>]</index></name> != 'r'</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>mode</name>+1</expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>mode</name></expr></argument>)</argument_list></call>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mode</name><index>[<expr>0</expr>]</index></name> = 'r'</expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr>!<call><name>strchr</name><argument_list>(<argument><expr><name>mode</name></expr></argument>, <argument><expr>'b'</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>mode</name>+2</expr></argument>, <argument><expr><name>mode</name>+1</expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mode</name><index>[<expr>1</expr>]</index></name> = 'b'</expr>;</expr_stmt>
}</block></then></if>
}</block></then> <else>else <if>if <condition>(<expr><name><name>mode</name><index>[<expr>0</expr>]</index></name> != 'r' &amp;&amp; <name><name>mode</name><index>[<expr>0</expr>]</index></name> != 'w' &amp;&amp; <name><name>mode</name><index>[<expr>0</expr>]</index></name> != 'a'</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"mode string must begin with "
"one of 'r', 'w', 'a' or 'U', not '%.200s'"</expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if></else></if>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>open_the_file</name><parameter_list>(<param><decl><type><name>PyFileObject</name> *</type><name>f</name></decl></param>, <param><decl><type><name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>char</name> *</type><name>mode</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>newmode</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>f</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyFile_Check</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>f_name</name></name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>name</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>mode</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>f_fp</name></name> == <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>newmode</name> = <call><name>PyMem_MALLOC</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>mode</name></expr></argument>)</argument_list></call> + 3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>newmode</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>newmode</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>_PyFile_SanitizeMode</name><argument_list>(<argument><expr><name>newmode</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>f</name> = <name>NULL</name></expr>;</expr_stmt>
<goto>goto <name>cleanup</name>;</goto>
}</block></then></if>
<if>if <condition>(<expr><call><name>PyEval_GetRestricted</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>,
<argument><expr>"file() constructor not accessible in restricted mode"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>f</name> = <name>NULL</name></expr>;</expr_stmt>
<goto>goto <name>cleanup</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>f_name</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>wmode</name></decl>;</decl_stmt>
<expr_stmt><expr><name>wmode</name> = <call><name>PyUnicode_DecodeASCII</name><argument_list>(<argument><expr><name>newmode</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>newmode</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>f</name>-&gt;<name>f_name</name></name> &amp;&amp; <name>wmode</name></expr>)</condition><then> <block>{
<macro><name>FILE_BEGIN_ALLOW_THREADS</name><argument_list>(<argument>f</argument>)</argument_list></macro>
<expr_stmt><expr><name><name>f</name>-&gt;<name>f_fp</name></name> = <call><name>_wfopen</name><argument_list>(<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>f_name</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>wmode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>FILE_END_ALLOW_THREADS</name><argument_list>(<argument>f</argument>)</argument_list></macro>
}</block></then></if>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>wmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><name>NULL</name> == <name><name>f</name>-&gt;<name>f_fp</name></name> &amp;&amp; <name>NULL</name> != <name>name</name></expr>)</condition><then> <block>{
<macro><name>FILE_BEGIN_ALLOW_THREADS</name><argument_list>(<argument>f</argument>)</argument_list></macro>
<expr_stmt><expr><name><name>f</name>-&gt;<name>f_fp</name></name> = <call><name>fopen</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>newmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>FILE_END_ALLOW_THREADS</name><argument_list>(<argument>f</argument>)</argument_list></macro>
}</block></then></if>
<if>if <condition>(<expr><name><name>f</name>-&gt;<name>f_fp</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>defined</name> <name>_MSC_VER</name> &amp;&amp; (<name>_MSC_VER</name> &lt; 1400 || !<call><name>defined</name><argument_list>(<argument><expr><name>__STDC_SECURE_LIB__</name></expr></argument>)</argument_list></call>)</expr></cpp:if>
<if>if <condition>(<expr><name>errno</name> == 0</expr>)</condition><then>
<expr_stmt><expr><name>errno</name> = <name>EINVAL</name></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name>errno</name> == <name>EINVAL</name></expr>)</condition><then>
<expr_stmt><expr><name>errno</name> = <name>ENOENT</name></expr>;</expr_stmt></then></if></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><name>errno</name> == <name>EINVAL</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>message</name><index>[<expr>100</expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>message</name></expr></argument>, <argument><expr>100</expr></argument>,
<argument><expr>"invalid mode ('%.50s') or filename"</expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>v</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(isO)"</expr></argument>, <argument><expr><name>errno</name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>f_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetObject</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></then> <else>else
<expr_stmt><expr><call><name>PyErr_SetFromErrnoWithFilenameObject</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>f_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<expr_stmt><expr><name>f</name> = <name>NULL</name></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>f</name> != <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><name>f</name> = <call><name>dircheck</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<label><name>cleanup</name>:</label>
<expr_stmt><expr><call><name>PyMem_FREE</name><argument_list>(<argument><expr><name>newmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *)<name>f</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>close_the_file</name><parameter_list>(<param><decl><type><name>PyFileObject</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>sts</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<function_decl><type><name>int</name></type> (*<name>local_close</name>)<parameter_list>(<param><decl><type><name>FILE</name> *</type></decl></param>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>FILE</name> *</type><name>local_fp</name> <init>= <expr><name><name>f</name>-&gt;<name>f_fp</name></name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>local_fp</name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>local_close</name> = <name><name>f</name>-&gt;<name>f_close</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>local_close</name> != <name>NULL</name> &amp;&amp; <name><name>f</name>-&gt;<name>unlocked_count</name></name> &gt; 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>f</name>-&gt;<name>ob_refcnt</name></name> &gt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>,
<argument><expr>"close() called during concurrent "
"operation on the same file object."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
<argument><expr>"PyFileObject locking error in "
"destructor (refcnt &lt;= 0 at close)."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>f</name>-&gt;<name>f_fp</name></name> = <name>NULL</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>local_close</name> != <name>NULL</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>Py_BEGIN_ALLOW_THREADS</name></type>
<name>errno</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>sts</name> = <call>(*<name>local_close</name>)<argument_list>(<argument><expr><name>local_fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>Py_END_ALLOW_THREADS</name></macro>
<if>if <condition>(<expr><name>sts</name> == <name>EOF</name></expr>)</condition><then>
<return>return <expr><call><name>PyErr_SetFromErrno</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><name>sts</name> != 0</expr>)</condition><then>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name>sts</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
}</block></then></if>
}</block></then></if>
<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
}</block></function>
<function><type><name>PyObject</name> *</type>
<name>PyFile_FromFile</name><parameter_list>(<param><decl><type><name>FILE</name> *</type><name>fp</name></decl></param>, <param><decl><type><name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>char</name> *</type><name>mode</name></decl></param>, <param><function_decl><type><name>int</name></type> (*<name>close</name>)<parameter_list>(<param><decl><type><name>FILE</name> *</type></decl></param>)</parameter_list></function_decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyFileObject</name> *</type><name>f</name> <init>= <expr>(<name>PyFileObject</name> *)<call><name><name>PyFile_Type</name>.<name>tp_new</name></name><argument_list>(<argument><expr>&amp;<name>PyFile_Type</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>f</name> != <name>NULL</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>o_name</name> <init>= <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>o_name</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>fill_file_fields</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>o_name</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>close</name></expr></argument>)</argument_list></call> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>f</name> = <name>NULL</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>o_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr>(<name>PyObject</name> *) <name>f</name></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type>
<name>PyFile_FromString</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><name>char</name> *</type><name>mode</name></decl></param>)</parameter_list> <block>{
<function_decl><type><specifier>extern</specifier> <name>int</name></type> <name>fclose</name><parameter_list>(<param><decl><type><name>FILE</name> *</type></decl></param>)</parameter_list>;</function_decl>
<decl_stmt><decl><type><name>PyFileObject</name> *</type><name>f</name></decl>;</decl_stmt>
<expr_stmt><expr><name>f</name> = (<name>PyFileObject</name> *)<call><name>PyFile_FromFile</name><argument_list>(<argument><expr>(<name>FILE</name> *)<name>NULL</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><name>fclose</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>f</name> != <name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>open_the_file</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>f</name> = <name>NULL</name></expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
<return>return <expr>(<name>PyObject</name> *)<name>f</name></expr>;</return>
}</block></function>
<function><type><name>void</name></type>
<name>PyFile_SetBufSize</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>f</name></decl></param>, <param><decl><type><name>int</name></type> <name>bufsize</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyFileObject</name> *</type><name>file</name> <init>= <expr>(<name>PyFileObject</name> *)<name>f</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>bufsize</name> &gt;= 0</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>type</name></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name>bufsize</name></expr>)</condition> <block>{
<case>case <expr>0</expr>:
<expr_stmt><expr><name>type</name> = <name>_IONBF</name></expr>;</expr_stmt>
<break>break;</break>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SETVBUF</name></expr></argument>)</argument_list></call></expr></cpp:if>
</case><case>case <expr>1</expr>:
<expr_stmt><expr><name>type</name> = <name>_IOLBF</name></expr>;</expr_stmt>
<expr_stmt><expr><name>bufsize</name> = <name>BUFSIZ</name></expr>;</expr_stmt>
<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</case><default>default:
<expr_stmt><expr><name>type</name> = <name>_IOFBF</name></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SETVBUF</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>bufsize</name> = <name>BUFSIZ</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<break>break;</break>
</default>}</block></switch>
<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name><name>file</name>-&gt;<name>f_fp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>type</name> == <name>_IONBF</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name><name>file</name>-&gt;<name>f_setbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>file</name>-&gt;<name>f_setbuf</name></name> = <name>NULL</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name><name>file</name>-&gt;<name>f_setbuf</name></name> = (<name>char</name> *)<call><name>PyMem_Realloc</name><argument_list>(<argument><expr><name><name>file</name>-&gt;<name>f_setbuf</name></name></expr></argument>,
<argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_SETVBUF</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>setvbuf</name><argument_list>(<argument><expr><name><name>file</name>-&gt;<name>f_fp</name></name></expr></argument>, <argument><expr><name><name>file</name>-&gt;<name>f_setbuf</name></name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>setbuf</name><argument_list>(<argument><expr><name><name>file</name>-&gt;<name>f_fp</name></name></expr></argument>, <argument><expr><name><name>file</name>-&gt;<name>f_setbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></then></if>
}</block></function>
<function><type><name>int</name></type>
<name>PyFile_SetEncoding</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>f</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>enc</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>PyFile_SetEncodingAndErrors</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>enc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>int</name></type>
<name>PyFile_SetEncodingAndErrors</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>f</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>enc</name></decl></param>, <param><decl><type><name>char</name>*</type> <name>errors</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyFileObject</name> *</type><name>file</name> <init>= <expr>(<name>PyFileObject</name>*)<name>f</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>str</name></decl>, *<decl><type ref="prev"/><name>oerrors</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyFile_Check</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>str</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>str</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<if>if <condition>(<expr><name>errors</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>oerrors</name> = <call><name>PyString_FromString</name><argument_list>(<argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>oerrors</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>oerrors</name> = <name>Py_None</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name><name>file</name>-&gt;<name>f_encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>file</name>-&gt;<name>f_encoding</name></name> = <name>str</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name><name>file</name>-&gt;<name>f_errors</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>file</name>-&gt;<name>f_errors</name></name> = <name>oerrors</name></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>err_closed</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"I/O operation on closed file"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>err_iterbuffered</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"Mixing iteration and read methods would lose data"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>drop_readahead</name><parameter_list>(<param><decl><type><name>PyFileObject</name> *</type></decl></param>)</parameter_list>;</function_decl>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>file_dealloc</name><parameter_list>(<param><decl><type><name>PyFileObject</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>ret</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>f</name>-&gt;<name>weakreflist</name></name> != <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyObject_ClearWeakRefs</name><argument_list>(<argument><expr>(<name>PyObject</name> *) <name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>ret</name> = <call><name>close_the_file</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>ret</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PySys_WriteStderr</name><argument_list>(<argument><expr>"close failed in file object destructor:\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_Print</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>f_setbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>f_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>f_mode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>f_encoding</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>f_errors</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>drop_readahead</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call>-&gt;<call><name>tp_free</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>file_repr</name><parameter_list>(<param><decl><type><name>PyFileObject</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>f_name</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_USING_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>name</name> <init>= <expr><call><name>PyUnicode_AsUnicodeEscapeString</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>f_name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name_str</name> <init>= <expr><name>name</name> ? <call><name>PyString_AsString</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call> : "?"</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>ret</name> = <call><name>PyString_FromFormat</name><argument_list>(<argument><expr>"&lt;%s file u'%s', mode '%s' at %p&gt;"</expr></argument>,
<argument><expr><name><name>f</name>-&gt;<name>f_fp</name></name> == <name>NULL</name> ? "closed" : "open"</expr></argument>,
<argument><expr><name>name_str</name></expr></argument>,
<argument><expr><call><name>PyString_AsString</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>f_mode</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></then> <else>else <block>{
<return>return <expr><call><name>PyString_FromFormat</name><argument_list>(<argument><expr>"&lt;%s file '%s', mode '%s' at %p&gt;"</expr></argument>,
<argument><expr><name><name>f</name>-&gt;<name>f_fp</name></name> == <name>NULL</name> ? "closed" : "open"</expr></argument>,
<argument><expr><call><name>PyString_AsString</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>f_name</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>PyString_AsString</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>f_mode</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></else></if>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>file_close</name><parameter_list>(<param><decl><type><name>PyFileObject</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>sts</name> <init>= <expr><call><name>close_the_file</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>f_setbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>f</name>-&gt;<name>f_setbuf</name></name> = <name>NULL</name></expr>;</expr_stmt>
<return>return <expr><name>sts</name></expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LARGEFILE_SUPPORT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<typedef>typedef <type><name>off_t</name></type> <name>Py_off_t</name>;</typedef>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>SIZEOF_OFF_T</name> &gt;= 8</expr></cpp:elif>
<typedef>typedef <type><name>off_t</name></type> <name>Py_off_t</name>;</typedef>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>SIZEOF_FPOS_T</name> &gt;= 8</expr></cpp:elif>
<typedef>typedef <type><name>fpos_t</name></type> <name>Py_off_t</name>;</typedef>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:error>#<cpp:directive>error</cpp:directive> "Large file support, but neither off_t nor fpos_t is large enough."</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>_portable_fseek</name><parameter_list>(<param><decl><type><name>FILE</name> *</type><name>fp</name></decl></param>, <param><decl><type><name>Py_off_t</name></type> <name>offset</name></decl></param>, <param><decl><type><name>int</name></type> <name>whence</name></decl></param>)</parameter_list> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LARGEFILE_SUPPORT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<return>return <expr><call><name>fseek</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>whence</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FSEEKO</name></expr></argument>)</argument_list></call> &amp;&amp; <name>SIZEOF_OFF_T</name> &gt;= 8</expr></cpp:elif>
<return>return <expr><call><name>fseeko</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>whence</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FSEEK64</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<return>return <expr><call><name>fseek64</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>whence</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__BEOS__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<return>return <expr><call><name>_fseek</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>whence</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>SIZEOF_FPOS_T</name> &gt;= 8</expr></cpp:elif>
<decl_stmt><decl><type><name>fpos_t</name></type> <name>pos</name></decl>;</decl_stmt>
<switch>switch <condition>(<expr><name>whence</name></expr>)</condition> <block>{
<case>case <expr><name>SEEK_END</name></expr>:
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>_lseeki64</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call> == -1</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if>if <condition>(<expr><call><name>fseek</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>SEEK_END</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</case><case>case <expr><name>SEEK_CUR</name></expr>:
<if>if <condition>(<expr><call><name>fgetpos</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>&amp;<name>pos</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><name>offset</name> += <name>pos</name></expr>;</expr_stmt>
<break>break;</break>
</case>}</block></switch>
<return>return <expr><call><name>fsetpos</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>&amp;<name>offset</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:error>#<cpp:directive>error</cpp:directive> "Large file support, but no way to fseek."</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>
<function><type><specifier>static</specifier> <name>Py_off_t</name></type>
<name>_portable_ftell</name><parameter_list>(<param><decl><type><name>FILE</name>*</type> <name>fp</name></decl></param>)</parameter_list> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LARGEFILE_SUPPORT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<return>return <expr><call><name>ftell</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FTELLO</name></expr></argument>)</argument_list></call> &amp;&amp; <name>SIZEOF_OFF_T</name> &gt;= 8</expr></cpp:elif>
<return>return <expr><call><name>ftello</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FTELL64</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<return>return <expr><call><name>ftell64</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><name>SIZEOF_FPOS_T</name> &gt;= 8</expr></cpp:elif>
<decl_stmt><decl><type><name>fpos_t</name></type> <name>pos</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>fgetpos</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr>&amp;<name>pos</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<return>return <expr><name>pos</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:error>#<cpp:directive>error</cpp:directive> "Large file support, but no way to ftell."</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>file_seek</name><parameter_list>(<param><decl><type><name>PyFileObject</name> *</type><name>f</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>whence</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_off_t</name></type> <name>offset</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>offobj</name></decl>, *<decl><type ref="prev"/><name>off_index</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>f</name>-&gt;<name>f_fp</name></name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><call><name>err_closed</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>drop_readahead</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>whence</name> = 0</expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O|i:seek"</expr></argument>, <argument><expr>&amp;<name>offobj</name></expr></argument>, <argument><expr>&amp;<name>whence</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>off_index</name> = <call><name>PyNumber_Index</name><argument_list>(<argument><expr><name>offobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>off_index</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<call><name>PyFloat_Check</name><argument_list>(<argument><expr><name>offobj</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyErr_WarnEx</name><argument_list>(<argument><expr><name>PyExc_DeprecationWarning</name></expr></argument>,
<argument><expr>"integer argument expected, got float"</expr></argument>,
<argument><expr>1</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>off_index</name> = <name>offobj</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>offobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LARGEFILE_SUPPORT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>offset</name> = <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>off_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>offset</name> = <call><name>PyLong_Check</name><argument_list>(<argument><expr><name>off_index</name></expr></argument>)</argument_list></call> ?
<call><name>PyLong_AsLongLong</name><argument_list>(<argument><expr><name>off_index</name></expr></argument>)</argument_list></call> : <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>off_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>off_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<macro><name>FILE_BEGIN_ALLOW_THREADS</name><argument_list>(<argument>f</argument>)</argument_list></macro>
<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> = <call><name>_portable_fseek</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>f_fp</name></name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>whence</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>FILE_END_ALLOW_THREADS</name><argument_list>(<argument>f</argument>)</argument_list></macro>
<if>if <condition>(<expr><name>ret</name> != 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetFromErrno</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>clearerr</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>f_fp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>f</name>-&gt;<name>f_skipnextlf</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FTRUNCATE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>file_truncate</name><parameter_list>(<param><decl><type><name>PyFileObject</name> *</type><name>f</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_off_t</name></type> <name>newsize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>newsizeobj</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_off_t</name></type> <name>initialpos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>f</name>-&gt;<name>f_fp</name></name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><call><name>err_closed</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>PyArg_UnpackTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"truncate"</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>&amp;<name>newsizeobj</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<macro><name>FILE_BEGIN_ALLOW_THREADS</name><argument_list>(<argument>f</argument>)</argument_list></macro>
<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>initialpos</name> = <call><name>_portable_ftell</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>f_fp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>FILE_END_ALLOW_THREADS</name><argument_list>(<argument>f</argument>)</argument_list></macro>
<if>if <condition>(<expr><name>initialpos</name> == -1</expr>)</condition><then>
<goto>goto <name>onioerror</name>;</goto></then></if>
<if>if <condition>(<expr><name>newsizeobj</name> != <name>NULL</name></expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LARGEFILE_SUPPORT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>newsize</name> = <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>newsizeobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>newsize</name> = <call><name>PyLong_Check</name><argument_list>(<argument><expr><name>newsizeobj</name></expr></argument>)</argument_list></call> ?
<call><name>PyLong_AsLongLong</name><argument_list>(<argument><expr><name>newsizeobj</name></expr></argument>)</argument_list></call> :
<call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>newsizeobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
}</block></then> <else>else
<expr_stmt><expr><name>newsize</name> = <name>initialpos</name></expr>;</expr_stmt></else></if>
<macro><name>FILE_BEGIN_ALLOW_THREADS</name><argument_list>(<argument>f</argument>)</argument_list></macro>
<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> = <call><name>fflush</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>f_fp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>FILE_END_ALLOW_THREADS</name><argument_list>(<argument>f</argument>)</argument_list></macro>
<if>if <condition>(<expr><name>ret</name> != 0</expr>)</condition><then>
<goto>goto <name>onioerror</name>;</goto></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<block>{
<decl_stmt><decl><type><name>HANDLE</name></type> <name>hFile</name></decl>;</decl_stmt>
<macro><name>FILE_BEGIN_ALLOW_THREADS</name><argument_list>(<argument>f</argument>)</argument_list></macro>
<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> = <call><name>_portable_fseek</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>f_fp</name></name></expr></argument>, <argument><expr><name>newsize</name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call> != 0</expr>;</expr_stmt>
<macro><name>FILE_END_ALLOW_THREADS</name><argument_list>(<argument>f</argument>)</argument_list></macro>
<if>if <condition>(<expr><name>ret</name></expr>)</condition><then>
<goto>goto <name>onioerror</name>;</goto></then></if>
<macro><name>FILE_BEGIN_ALLOW_THREADS</name><argument_list>(<argument>f</argument>)</argument_list></macro>
<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>hFile</name> = (<name>HANDLE</name>)<call><name>_get_osfhandle</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>f_fp</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> = <name>hFile</name> == (<name>HANDLE</name>)-1</expr>;</expr_stmt>
<if>if <condition>(<expr><name>ret</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>ret</name> = <call><name>SetEndOfFile</name><argument_list>(<argument><expr><name>hFile</name></expr></argument>)</argument_list></call> == 0</expr>;</expr_stmt>
<if>if <condition>(<expr><name>ret</name></expr>)</condition><then>
<expr_stmt><expr><name>errno</name> = <name>EACCES</name></expr>;</expr_stmt></then></if>
}</block></then></if>
<macro><name>FILE_END_ALLOW_THREADS</name><argument_list>(<argument>f</argument>)</argument_list></macro>
<if>if <condition>(<expr><name>ret</name></expr>)</condition><then>
<goto>goto <name>onioerror</name>;</goto></then></if>
}</block>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<macro><name>FILE_BEGIN_ALLOW_THREADS</name><argument_list>(<argument>f</argument>)</argument_list></macro>
<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> = <call><name>ftruncate</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>f_fp</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>newsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>FILE_END_ALLOW_THREADS</name><argument_list>(<argument>f</argument>)</argument_list></macro>
<if>if <condition>(<expr><name>ret</name> != 0</expr>)</condition><then>
<goto>goto <name>onioerror</name>;</goto></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<macro><name>FILE_BEGIN_ALLOW_THREADS</name><argument_list>(<argument>f</argument>)</argument_list></macro>
<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> = <call><name>_portable_fseek</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>f_fp</name></name></expr></argument>, <argument><expr><name>initialpos</name></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call> != 0</expr>;</expr_stmt>
<macro><name>FILE_END_ALLOW_THREADS</name><argument_list>(<argument>f</argument>)</argument_list></macro>
<if>if <condition>(<expr><name>ret</name></expr>)</condition><then>
<goto>goto <name>onioerror</name>;</goto></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
<label><name>onioerror</name>:</label>
<expr_stmt><expr><call><name>PyErr_SetFromErrno</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>clearerr</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>f_fp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>file_tell</name><parameter_list>(<param><decl><type><name>PyFileObject</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_off_t</name></type> <name>pos</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>f</name>-&gt;<name>f_fp</name></name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><call><name>err_closed</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<macro><name>FILE_BEGIN_ALLOW_THREADS</name><argument_list>(<argument>f</argument>)</argument_list></macro>
<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>pos</name> = <call><name>_portable_ftell</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>f_fp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>FILE_END_ALLOW_THREADS</name><argument_list>(<argument>f</argument>)</argument_list></macro>
<if>if <condition>(<expr><name>pos</name> == -1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetFromErrno</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>clearerr</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>f_fp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name><name>f</name>-&gt;<name>f_skipnextlf</name></name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
<expr_stmt><expr><name>c</name> = <call><name>GETC</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>f_fp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>c</name> == '\n'</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>f</name>-&gt;<name>f_newlinetypes</name></name> |= <name>NEWLINE_CRLF</name></expr>;</expr_stmt>
<expr_stmt><expr><name>pos</name>++</expr>;</expr_stmt>
<expr_stmt><expr><name><name>f</name>-&gt;<name>f_skipnextlf</name></name> = 0</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>c</name> != <name>EOF</name></expr>)</condition><then> <expr_stmt><expr><call><name>ungetc</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>f_fp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if>
}</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>HAVE_LARGEFILE_SUPPORT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<return>return <expr><call><name>PyLong_FromLongLong</name><argument_list>(<argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>file_fileno</name><parameter_list>(<param><decl><type><name>PyFileObject</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name><name>f</name>-&gt;<name>f_fp</name></name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><call><name>err_closed</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>) <call><name>fileno</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>f_fp</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>file_flush</name><parameter_list>(<param><decl><type><name>PyFileObject</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>res</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>f</name>-&gt;<name>f_fp</name></name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><call><name>err_closed</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<macro><name>FILE_BEGIN_ALLOW_THREADS</name><argument_list>(<argument>f</argument>)</argument_list></macro>
<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>res</name> = <call><name>fflush</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>f_fp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>FILE_END_ALLOW_THREADS</name><argument_list>(<argument>f</argument>)</argument_list></macro>
<if>if <condition>(<expr><name>res</name> != 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetFromErrno</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>clearerr</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>f_fp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>file_isatty</name><parameter_list>(<param><decl><type><name>PyFileObject</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>long</name></type> <name>res</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>f</name>-&gt;<name>f_fp</name></name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><call><name>err_closed</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<macro><name>FILE_BEGIN_ALLOW_THREADS</name><argument_list>(<argument>f</argument>)</argument_list></macro>
<expr_stmt><expr><name>res</name> = <call><name>isatty</name><argument_list>(<argument><expr>(<name>int</name>)<call><name>fileno</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>f_fp</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>FILE_END_ALLOW_THREADS</name><argument_list>(<argument>f</argument>)</argument_list></macro>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>BUFSIZ</name> &lt; 8192</expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SMALLCHUNK</name></cpp:macro> <cpp:value>8192</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SMALLCHUNK</name></cpp:macro> <cpp:value>BUFSIZ</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_INT</name> &lt; 4</expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BIGCHUNK</name></cpp:macro> <cpp:value>(512 * 32)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BIGCHUNK</name></cpp:macro> <cpp:value>(512 * 1024)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>new_buffersize</name><parameter_list>(<param><decl><type><name>PyFileObject</name> *</type><name>f</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>currentsize</name></decl></param>)</parameter_list> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FSTAT</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>off_t</name></type> <name>pos</name></decl>, <decl><type ref="prev"/><name>end</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>stat</name></type> <name>st</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>fstat</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>f_fp</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>st</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>end</name> = <name><name>st</name>.<name>st_size</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>pos</name> = <call><name>lseek</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>f_fp</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>0L</expr></argument>, <argument><expr><name>SEEK_CUR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>pos</name> &gt;= 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>pos</name> = <call><name>ftell</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>f_fp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>pos</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><call><name>clearerr</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>f_fp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>end</name> &gt; <name>pos</name> &amp;&amp; <name>pos</name> &gt;= 0</expr>)</condition><then>
<return>return <expr><name>currentsize</name> + <name>end</name> - <name>pos</name> + 1</expr>;</return></then></if>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><name>currentsize</name> &gt; <name>SMALLCHUNK</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>currentsize</name> &lt;= <name>BIGCHUNK</name></expr>)</condition><then>
<return>return <expr><name>currentsize</name> + <name>currentsize</name></expr>;</return></then>
<else>else
<return>return <expr><name>currentsize</name> + <name>BIGCHUNK</name></expr>;</return></else></if>
}</block></then></if>
<return>return <expr><name>currentsize</name> + <name>SMALLCHUNK</name></expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EWOULDBLOCK</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>EAGAIN</name></expr></argument>)</argument_list></call> &amp;&amp; <name>EWOULDBLOCK</name> != <name>EAGAIN</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BLOCKED_ERRNO</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((x) == EWOULDBLOCK || (x) == EAGAIN)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EWOULDBLOCK</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BLOCKED_ERRNO</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((x) == EWOULDBLOCK)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>EAGAIN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BLOCKED_ERRNO</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((x) == EAGAIN)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BLOCKED_ERRNO</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>file_read</name><parameter_list>(<param><decl><type><name>PyFileObject</name> *</type><name>f</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>long</name></type> <name>bytesrequested</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>bytesread</name></decl>, <decl><type ref="prev"/><name>buffersize</name></decl>, <decl><type ref="prev"/><name>chunksize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>f</name>-&gt;<name>f_fp</name></name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><call><name>err_closed</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><name><name>f</name>-&gt;<name>f_buf</name></name> != <name>NULL</name> &amp;&amp;
(<name><name>f</name>-&gt;<name>f_bufend</name></name> - <name><name>f</name>-&gt;<name>f_bufptr</name></name>) &gt; 0 &amp;&amp;
<name><name>f</name>-&gt;<name>f_buf</name><index>[<expr>0</expr>]</index></name> != '\0'</expr>)</condition><then>
<return>return <expr><call><name>err_iterbuffered</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|l:read"</expr></argument>, <argument><expr>&amp;<name>bytesrequested</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>bytesrequested</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>buffersize</name> = <call><name>new_buffersize</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr>(<name>size_t</name>)0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>buffersize</name> = <name>bytesrequested</name></expr>;</expr_stmt></else></if>
<if>if <condition>(<expr><name>buffersize</name> &gt; <name>PY_SSIZE_T_MAX</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
<argument><expr>"requested number of bytes is more than a Python string can hold"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>v</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr>(<name>char</name> *)<name>NULL</name></expr></argument>, <argument><expr><name>buffersize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>bytesread</name> = 0</expr>;</expr_stmt>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<macro><name>FILE_BEGIN_ALLOW_THREADS</name><argument_list>(<argument>f</argument>)</argument_list></macro>
<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>chunksize</name> = <call><name>Py_UniversalNewlineFread</name><argument_list>(<argument><expr><call><name>BUF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> + <name>bytesread</name></expr></argument>,
<argument><expr><name>buffersize</name> - <name>bytesread</name></expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>f_fp</name></name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>FILE_END_ALLOW_THREADS</name><argument_list>(<argument>f</argument>)</argument_list></macro>
<if>if <condition>(<expr><name>chunksize</name> == 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<call><name>ferror</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>f_fp</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr><call><name>clearerr</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>f_fp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>bytesread</name> &gt; 0 &amp;&amp; <call><name>BLOCKED_ERRNO</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr><call><name>PyErr_SetFromErrno</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>bytesread</name> += <name>chunksize</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>bytesread</name> &lt; <name>buffersize</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>clearerr</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>f_fp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
<if>if <condition>(<expr><name>bytesrequested</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>buffersize</name> = <call><name>new_buffersize</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>buffersize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr><name>buffersize</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
}</block></then> <else>else <block>{
<break>break;</break>
}</block></else></if>
}</block></for>
<if>if <condition>(<expr><name>bytesread</name> != <name>buffersize</name></expr>)</condition><then>
<expr_stmt><expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr><name>bytesread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>v</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>file_readinto</name><parameter_list>(<param><decl><type><name>PyFileObject</name> *</type><name>f</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>ptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>ntodo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>ndone</name></decl>, <decl><type ref="prev"/><name>nnow</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_buffer</name></type> <name>pbuf</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>f</name>-&gt;<name>f_fp</name></name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><call><name>err_closed</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><name><name>f</name>-&gt;<name>f_buf</name></name> != <name>NULL</name> &amp;&amp;
(<name><name>f</name>-&gt;<name>f_bufend</name></name> - <name><name>f</name>-&gt;<name>f_bufptr</name></name>) &gt; 0 &amp;&amp;
<name><name>f</name>-&gt;<name>f_buf</name><index>[<expr>0</expr>]</index></name> != '\0'</expr>)</condition><then>
<return>return <expr><call><name>err_iterbuffered</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"w*"</expr></argument>, <argument><expr>&amp;<name>pbuf</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>ptr</name> = <name><name>pbuf</name>.<name>buf</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>ntodo</name> = <name><name>pbuf</name>.<name>len</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>ndone</name> = 0</expr>;</expr_stmt>
<while>while <condition>(<expr><name>ntodo</name> &gt; 0</expr>)</condition> <block>{
<macro><name>FILE_BEGIN_ALLOW_THREADS</name><argument_list>(<argument>f</argument>)</argument_list></macro>
<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>nnow</name> = <call><name>Py_UniversalNewlineFread</name><argument_list>(<argument><expr><name>ptr</name>+<name>ndone</name></expr></argument>, <argument><expr><name>ntodo</name></expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>f_fp</name></name></expr></argument>,
<argument><expr>(<name>PyObject</name> *)<name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>FILE_END_ALLOW_THREADS</name><argument_list>(<argument>f</argument>)</argument_list></macro>
<if>if <condition>(<expr><name>nnow</name> == 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<call><name>ferror</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>f_fp</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr><call><name>PyErr_SetFromErrno</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>clearerr</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>f_fp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>ndone</name> += <name>nnow</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ntodo</name> -= <name>nnow</name></expr>;</expr_stmt>
}</block></while>
<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><name>ndone</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>USE_FGETS_IN_GETLINE</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>defined</name><argument_list>(<argument><expr><name>HAVE_GETC_UNLOCKED</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_FGETS_IN_GETLINE</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>DONT_USE_FGETS_IN_GETLINE</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>USE_FGETS_IN_GETLINE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>USE_FGETS_IN_GETLINE</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_FGETS_IN_GETLINE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>getline_via_fgets</name><parameter_list>(<param><decl><type><name>PyFileObject</name> *</type><name>f</name></decl></param>, <param><decl><type><name>FILE</name> *</type><name>fp</name></decl></param>)</parameter_list> <block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INITBUFSIZE</name></cpp:macro> <cpp:value>100</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXBUFSIZE</name></cpp:macro> <cpp:value>300</cpp:value></cpp:define>
<decl_stmt><decl><type><name>char</name>*</type> <name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>MAXBUFSIZE</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name>*</type> <name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>*</type> <name>pvfree</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>*</type> <name>pvend</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>nfree</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>total_v_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>increment</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>prev_v_size</name></decl>;</decl_stmt>
<expr_stmt><expr><name>total_v_size</name> = <name>INITBUFSIZE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>pvfree</name> = <name>buf</name></expr>;</expr_stmt>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<macro><name>FILE_BEGIN_ALLOW_THREADS</name><argument_list>(<argument>f</argument>)</argument_list></macro>
<expr_stmt><expr><name>pvend</name> = <name>buf</name> + <name>total_v_size</name></expr>;</expr_stmt>
<expr_stmt><expr><name>nfree</name> = <name>pvend</name> - <name>pvfree</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pvfree</name></expr></argument>, <argument><expr>'\n'</expr></argument>, <argument><expr><name>nfree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>nfree</name> &lt; <name>INT_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> = <call><name>fgets</name><argument_list>(<argument><expr><name>pvfree</name></expr></argument>, <argument><expr>(<name>int</name>)<name>nfree</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>FILE_END_ALLOW_THREADS</name><argument_list>(<argument>f</argument>)</argument_list></macro>
<if>if <condition>(<expr><name>p</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>clearerr</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyErr_CheckSignals</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>v</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>pvfree</name> - <name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>v</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>p</name> = <call><name>memchr</name><argument_list>(<argument><expr><name>pvfree</name></expr></argument>, <argument><expr>'\n'</expr></argument>, <argument><expr><name>nfree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>p</name> != <name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>p</name>+1 &lt; <name>pvend</name> &amp;&amp; *(<name>p</name>+1) == '\0'</expr>)</condition><then> <block>{
<expr_stmt><expr>++<name>p</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>p</name> &gt; <name>pvfree</name> &amp;&amp; *(<name>p</name>-1) == '\0'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>--<name>p</name></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><name>v</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>p</name> - <name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>v</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>*(<name>pvend</name>-1) == '\0'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>pvfree</name> == <name>buf</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>pvfree</name> = <name>pvend</name> - 1</expr>;</expr_stmt>
<expr_stmt><expr><name>total_v_size</name> = <name>MAXBUFSIZE</name></expr>;</expr_stmt>
}</block></then> <else>else
<break>break;</break></else></if>
}</block></for>
<expr_stmt><expr><name>total_v_size</name> = <name>MAXBUFSIZE</name> &lt;&lt; 1</expr>;</expr_stmt>
<expr_stmt><expr><name>v</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr>(<name>char</name>*)<name>NULL</name></expr></argument>, <argument><expr>(<name>int</name>)<name>total_v_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>v</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>BUF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>MAXBUFSIZE</name>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>pvfree</name> = <call><name>BUF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> + <name>MAXBUFSIZE</name> - 1</expr>;</expr_stmt>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<macro><name>FILE_BEGIN_ALLOW_THREADS</name><argument_list>(<argument>f</argument>)</argument_list></macro>
<expr_stmt><expr><name>pvend</name> = <call><name>BUF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> + <name>total_v_size</name></expr>;</expr_stmt>
<expr_stmt><expr><name>nfree</name> = <name>pvend</name> - <name>pvfree</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>pvfree</name></expr></argument>, <argument><expr>'\n'</expr></argument>, <argument><expr><name>nfree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>nfree</name> &lt; <name>INT_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> = <call><name>fgets</name><argument_list>(<argument><expr><name>pvfree</name></expr></argument>, <argument><expr>(<name>int</name>)<name>nfree</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>FILE_END_ALLOW_THREADS</name><argument_list>(<argument>f</argument>)</argument_list></macro>
<if>if <condition>(<expr><name>p</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>clearerr</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyErr_CheckSignals</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>p</name> = <name>pvfree</name></expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
<expr_stmt><expr><name>p</name> = <call><name>memchr</name><argument_list>(<argument><expr><name>pvfree</name></expr></argument>, <argument><expr>'\n'</expr></argument>, <argument><expr><name>nfree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>p</name> != <name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>p</name>+1 &lt; <name>pvend</name> &amp;&amp; *(<name>p</name>+1) == '\0'</expr>)</condition><then> <block>{
<expr_stmt><expr>++<name>p</name></expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>p</name> &gt; <name>pvfree</name> &amp;&amp; *(<name>p</name>-1) == '\0'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>--<name>p</name></expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>*(<name>pvend</name>-1) == '\0'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>increment</name> = <name>total_v_size</name> &gt;&gt; 2</expr>;</expr_stmt>
<expr_stmt><expr><name>prev_v_size</name> = <name>total_v_size</name></expr>;</expr_stmt>
<expr_stmt><expr><name>total_v_size</name> += <name>increment</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>total_v_size</name> &lt;= <name>prev_v_size</name> ||
<name>total_v_size</name> &gt; <name>PY_SSIZE_T_MAX</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
<argument><expr>"line is longer than a Python string can hold"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr>(<name>int</name>)<name>total_v_size</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>pvfree</name> = <call><name>BUF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> + (<name>prev_v_size</name> - 1)</expr>;</expr_stmt>
}</block></for>
<if>if <condition>(<expr><call><name>BUF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> + <name>total_v_size</name> != <name>p</name></expr>)</condition><then>
<expr_stmt><expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr><name>p</name> - <call><name>BUF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>v</name></expr>;</return>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>INITBUFSIZE</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>MAXBUFSIZE</name></cpp:undef>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>get_line</name><parameter_list>(<param><decl><type><name>PyFileObject</name> *</type><name>f</name></decl></param>, <param><decl><type><name>int</name></type> <name>n</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>FILE</name> *</type><name>fp</name> <init>= <expr><name><name>f</name>-&gt;<name>f_fp</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>buf</name></decl>, *<decl><type ref="prev"/><name>end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>total_v_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>used_v_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>increment</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>newlinetypes</name> <init>= <expr><name><name>f</name>-&gt;<name>f_newlinetypes</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>skipnextlf</name> <init>= <expr><name><name>f</name>-&gt;<name>f_skipnextlf</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>univ_newline</name> <init>= <expr><name><name>f</name>-&gt;<name>f_univ_newline</name></name></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>USE_FGETS_IN_GETLINE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>n</name> &lt;= 0 &amp;&amp; !<name>univ_newline</name></expr> )</condition><then>
<return>return <expr><call><name>getline_via_fgets</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>total_v_size</name> = <name>n</name> &gt; 0 ? <name>n</name> : 100</expr>;</expr_stmt>
<expr_stmt><expr><name>v</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr>(<name>char</name> *)<name>NULL</name></expr></argument>, <argument><expr><name>total_v_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>buf</name> = <call><name>BUF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>end</name> = <name>buf</name> + <name>total_v_size</name></expr>;</expr_stmt>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<macro><name>FILE_BEGIN_ALLOW_THREADS</name><argument_list>(<argument>f</argument>)</argument_list></macro>
<expr_stmt><expr><call><name>FLOCKFILE</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>univ_newline</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>c</name> = 'x'</expr>;</expr_stmt>
<while>while <condition>( <expr><name>buf</name> != <name>end</name> &amp;&amp; (<name>c</name> = <call><name>GETC</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call>) != <name>EOF</name></expr> )</condition> <block>{
<if>if <condition>(<expr><name>skipnextlf</name></expr> )</condition><then> <block>{
<expr_stmt><expr><name>skipnextlf</name> = 0</expr>;</expr_stmt>
<if>if <condition>(<expr><name>c</name> == '\n'</expr>)</condition><then> <block>{
<expr_stmt><expr><name>newlinetypes</name> |= <name>NEWLINE_CRLF</name></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> = <call><name>GETC</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>c</name> == <name>EOF</name></expr>)</condition><then> <break>break;</break></then></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>newlinetypes</name> |= <name>NEWLINE_CR</name></expr>;</expr_stmt>
}</block></else></if>
}</block></then></if>
<if>if <condition>(<expr><name>c</name> == '\r'</expr>)</condition><then> <block>{
<expr_stmt><expr><name>skipnextlf</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> = '\n'</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>( <expr><name>c</name> == '\n'</expr>)</condition><then>
<expr_stmt><expr><name>newlinetypes</name> |= <name>NEWLINE_LF</name></expr>;</expr_stmt></then></if></else></if>
<expr_stmt><expr>*<name>buf</name>++ = <name>c</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>c</name> == '\n'</expr>)</condition><then> <break>break;</break></then></if>
}</block></while>
<if>if <condition>( <expr><name>c</name> == <name>EOF</name> &amp;&amp; <name>skipnextlf</name></expr> )</condition><then>
<expr_stmt><expr><name>newlinetypes</name> |= <name>NEWLINE_CR</name></expr>;</expr_stmt></then></if>
}</block></then> <else>else
<while>while <condition>(<expr>(<name>c</name> = <call><name>GETC</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call>) != <name>EOF</name> &amp;&amp;
(*<name>buf</name>++ = <name>c</name>) != '\n' &amp;&amp;
<name>buf</name> != <name>end</name></expr>)</condition>
<empty_stmt>;</empty_stmt></while></else></if>
<expr_stmt><expr><call><name>FUNLOCKFILE</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>FILE_END_ALLOW_THREADS</name><argument_list>(<argument>f</argument>)</argument_list></macro>
<expr_stmt><expr><name><name>f</name>-&gt;<name>f_newlinetypes</name></name> = <name>newlinetypes</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>f</name>-&gt;<name>f_skipnextlf</name></name> = <name>skipnextlf</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>c</name> == '\n'</expr>)</condition><then>
<break>break;</break></then></if>
<if>if <condition>(<expr><name>c</name> == <name>EOF</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>ferror</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetFromErrno</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>clearerr</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>clearerr</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyErr_CheckSignals</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<break>break;</break>
}</block></then></if>
<if>if <condition>(<expr><name>n</name> &gt; 0</expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr><name>used_v_size</name> = <name>total_v_size</name></expr>;</expr_stmt>
<expr_stmt><expr><name>increment</name> = <name>total_v_size</name> &gt;&gt; 2</expr>;</expr_stmt>
<expr_stmt><expr><name>total_v_size</name> += <name>increment</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>total_v_size</name> &gt; <name>PY_SSIZE_T_MAX</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
<argument><expr>"line is longer than a Python string can hold"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr><name>total_v_size</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>buf</name> = <call><name>BUF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> + <name>used_v_size</name></expr>;</expr_stmt>
<expr_stmt><expr><name>end</name> = <call><name>BUF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> + <name>total_v_size</name></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><name>used_v_size</name> = <name>buf</name> - <call><name>BUF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>used_v_size</name> != <name>total_v_size</name></expr>)</condition><then>
<expr_stmt><expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr><name>used_v_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>v</name></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type>
<name>PyFile_GetLine</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>f</name></decl></param>, <param><decl><type><name>int</name></type> <name>n</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>f</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><call><name>PyFile_Check</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyFileObject</name> *</type><name>fo</name> <init>= <expr>(<name>PyFileObject</name> *)<name>f</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>fo</name>-&gt;<name>f_fp</name></name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><call><name>err_closed</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><name><name>fo</name>-&gt;<name>f_buf</name></name> != <name>NULL</name> &amp;&amp;
(<name><name>fo</name>-&gt;<name>f_bufend</name></name> - <name><name>fo</name>-&gt;<name>f_bufptr</name></name>) &gt; 0 &amp;&amp;
<name><name>fo</name>-&gt;<name>f_buf</name><index>[<expr>0</expr>]</index></name> != '\0'</expr>)</condition><then>
<return>return <expr><call><name>err_iterbuffered</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>result</name> = <call><name>get_line</name><argument_list>(<argument><expr><name>fo</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>reader</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>args</name></decl>;</decl_stmt>
<expr_stmt><expr><name>reader</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr>"readline"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>reader</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>n</name> &lt;= 0</expr>)</condition><then>
<expr_stmt><expr><name>args</name> = <call><name>PyTuple_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>args</name> = <call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(i)"</expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<if>if <condition>(<expr><name>args</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>reader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>result</name> = <call><name>PyEval_CallObject</name><argument_list>(<argument><expr><name>reader</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>reader</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> != <name>NULL</name> &amp;&amp; !<call><name>PyString_Check</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> &amp;&amp;
!<call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"object.readline() returned non-string"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></else></if>
<if>if <condition>(<expr><name>n</name> &lt; 0 &amp;&amp; <name>result</name> != <name>NULL</name> &amp;&amp; <call><name>PyString_Check</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>s</name> <init>= <expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name> <init>= <expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>len</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_EOFError</name></expr></argument>,
<argument><expr>"EOF when reading a line"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name><name>s</name><index>[<expr><name>len</name>-1</expr>]</index></name> == '\n'</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>result</name>-&gt;<name>ob_refcnt</name></name> == 1</expr>)</condition><then>
<expr_stmt><expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>result</name></expr></argument>, <argument><expr><name>len</name>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
<expr_stmt><expr><name>v</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> = <name>v</name></expr>;</expr_stmt>
}</block></else></if>
}</block></then></if></else></if>
}</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_USING_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>n</name> &lt; 0 &amp;&amp; <name>result</name> != <name>NULL</name> &amp;&amp; <call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>s</name> <init>= <expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name> <init>= <expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>len</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_EOFError</name></expr></argument>,
<argument><expr>"EOF when reading a line"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name><name>s</name><index>[<expr><name>len</name>-1</expr>]</index></name> == '\n'</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>result</name>-&gt;<name>ob_refcnt</name></name> == 1</expr>)</condition><then>
<expr_stmt><expr><call><name>PyUnicode_Resize</name><argument_list>(<argument><expr>&amp;<name>result</name></expr></argument>, <argument><expr><name>len</name>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
<expr_stmt><expr><name>v</name> = <call><name>PyUnicode_FromUnicode</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> = <name>v</name></expr>;</expr_stmt>
}</block></else></if>
}</block></then></if></else></if>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>file_readline</name><parameter_list>(<param><decl><type><name>PyFileObject</name> *</type><name>f</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>f</name>-&gt;<name>f_fp</name></name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><call><name>err_closed</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><name><name>f</name>-&gt;<name>f_buf</name></name> != <name>NULL</name> &amp;&amp;
(<name><name>f</name>-&gt;<name>f_bufend</name></name> - <name><name>f</name>-&gt;<name>f_bufptr</name></name>) &gt; 0 &amp;&amp;
<name><name>f</name>-&gt;<name>f_buf</name><index>[<expr>0</expr>]</index></name> != '\0'</expr>)</condition><then>
<return>return <expr><call><name>err_iterbuffered</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|i:readline"</expr></argument>, <argument><expr>&amp;<name>n</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>n</name> == 0</expr>)</condition><then>
<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr>""</expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><name>n</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>n</name> = 0</expr>;</expr_stmt></then></if>
<return>return <expr><call><name>get_line</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>file_readlines</name><parameter_list>(<param><decl><type><name>PyFileObject</name> *</type><name>f</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>long</name></type> <name>sizehint</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>list</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>line</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>small_buffer</name><index>[<expr><name>SMALLCHUNK</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>buffer</name> <init>= <expr><name>small_buffer</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>buffersize</name> <init>= <expr><name>SMALLCHUNK</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>big_buffer</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>nfilled</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>nread</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>totalread</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>p</name></decl>, *<decl><type ref="prev"/><name>q</name></decl>, *<decl><type ref="prev"/><name>end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>shortread</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>f</name>-&gt;<name>f_fp</name></name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><call><name>err_closed</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><name><name>f</name>-&gt;<name>f_buf</name></name> != <name>NULL</name> &amp;&amp;
(<name><name>f</name>-&gt;<name>f_bufend</name></name> - <name><name>f</name>-&gt;<name>f_bufptr</name></name>) &gt; 0 &amp;&amp;
<name><name>f</name>-&gt;<name>f_buf</name><index>[<expr>0</expr>]</index></name> != '\0'</expr>)</condition><then>
<return>return <expr><call><name>err_iterbuffered</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|l:readlines"</expr></argument>, <argument><expr>&amp;<name>sizehint</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr>(<name>list</name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<if>if <condition>(<expr><name>shortread</name></expr>)</condition><then>
<expr_stmt><expr><name>nread</name> = 0</expr>;</expr_stmt></then>
<else>else <block>{
<macro><name>FILE_BEGIN_ALLOW_THREADS</name><argument_list>(<argument>f</argument>)</argument_list></macro>
<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>nread</name> = <call><name>Py_UniversalNewlineFread</name><argument_list>(<argument><expr><name>buffer</name>+<name>nfilled</name></expr></argument>,
<argument><expr><name>buffersize</name>-<name>nfilled</name></expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>f_fp</name></name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>FILE_END_ALLOW_THREADS</name><argument_list>(<argument>f</argument>)</argument_list></macro>
<expr_stmt><expr><name>shortread</name> = (<name>nread</name> &lt; <name>buffersize</name>-<name>nfilled</name>)</expr>;</expr_stmt>
}</block></else></if>
<if>if <condition>(<expr><name>nread</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>sizehint</name> = 0</expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>ferror</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>f_fp</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr><call><name>PyErr_SetFromErrno</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>clearerr</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>f_fp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>error</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>totalread</name> += <name>nread</name></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> = (<name>char</name> *)<call><name>memchr</name><argument_list>(<argument><expr><name>buffer</name>+<name>nfilled</name></expr></argument>, <argument><expr>'\n'</expr></argument>, <argument><expr><name>nread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>p</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>nfilled</name> += <name>nread</name></expr>;</expr_stmt>
<expr_stmt><expr><name>buffersize</name> *= 2</expr>;</expr_stmt>
<if>if <condition>(<expr><name>buffersize</name> &gt; <name>PY_SSIZE_T_MAX</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
<argument><expr>"line is longer than a Python string can hold"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>error</name>;</goto>
}</block></then></if>
<if>if <condition>(<expr><name>big_buffer</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>big_buffer</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(
<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>buffersize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>big_buffer</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<expr_stmt><expr><name>buffer</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>big_buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>small_buffer</name></expr></argument>, <argument><expr><name>nfilled</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<if>if <condition>( <expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>big_buffer</name></expr></argument>, <argument><expr><name>buffersize</name></expr></argument>)</argument_list></call> &lt; 0</expr> )</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<expr_stmt><expr><name>buffer</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>big_buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<continue>continue;</continue>
}</block></then></if>
<expr_stmt><expr><name>end</name> = <name>buffer</name>+<name>nfilled</name>+<name>nread</name></expr>;</expr_stmt>
<expr_stmt><expr><name>q</name> = <name>buffer</name></expr>;</expr_stmt>
<do>do <block>{
<expr_stmt><expr><name>p</name>++</expr>;</expr_stmt>
<expr_stmt><expr><name>line</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr><name>p</name>-<name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>line</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<expr_stmt><expr><name>err</name> = <call><name>PyList_Append</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>err</name> != 0</expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<expr_stmt><expr><name>q</name> = <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> = (<name>char</name> *)<call><name>memchr</name><argument_list>(<argument><expr><name>q</name></expr></argument>, <argument><expr>'\n'</expr></argument>, <argument><expr><name>end</name>-<name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block> while <condition>(<expr><name>p</name> != <name>NULL</name></expr>)</condition>;</do>
<expr_stmt><expr><name>nfilled</name> = <name>end</name>-<name>q</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>q</name></expr></argument>, <argument><expr><name>nfilled</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>sizehint</name> &gt; 0</expr>)</condition><then>
<if>if <condition>(<expr><name>totalread</name> &gt;= (<name>size_t</name>)<name>sizehint</name></expr>)</condition><then>
<break>break;</break></then></if></then></if>
}</block></for>
<if>if <condition>(<expr><name>nfilled</name> != 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>line</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>nfilled</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>line</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<if>if <condition>(<expr><name>sizehint</name> &gt; 0</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>rest</name> <init>= <expr><call><name>get_line</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>rest</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>error</name>;</goto>
}</block></then></if>
<expr_stmt><expr><call><name>PyString_Concat</name><argument_list>(<argument><expr>&amp;<name>line</name></expr></argument>, <argument><expr><name>rest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>rest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>line</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
}</block></then></if>
<expr_stmt><expr><name>err</name> = <call><name>PyList_Append</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>err</name> != 0</expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
}</block></then></if>
<label><name>cleanup</name>:</label>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>big_buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>list</name></expr>;</return>
<label><name>error</name>:</label>
<expr_stmt><expr><call><name>Py_CLEAR</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>cleanup</name>;</goto>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>file_write</name><parameter_list>(<param><decl><type><name>PyFileObject</name> *</type><name>f</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_buffer</name></type> <name>pbuf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>n2</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>f</name>-&gt;<name>f_fp</name></name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><call><name>err_closed</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><name><name>f</name>-&gt;<name>f_binary</name></name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"s*"</expr></argument>, <argument><expr>&amp;<name>pbuf</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>s</name> = <name><name>pbuf</name>.<name>buf</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> = <name><name>pbuf</name>.<name>len</name></name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"t#"</expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>, <argument><expr>&amp;<name>n</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if></else></if>
<expr_stmt><expr><name><name>f</name>-&gt;<name>f_softspace</name></name> = 0</expr>;</expr_stmt>
<macro><name>FILE_BEGIN_ALLOW_THREADS</name><argument_list>(<argument>f</argument>)</argument_list></macro>
<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>n2</name> = <call><name>fwrite</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>f_fp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>FILE_END_ALLOW_THREADS</name><argument_list>(<argument>f</argument>)</argument_list></macro>
<if>if <condition>(<expr><name><name>f</name>-&gt;<name>f_binary</name></name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyBuffer_Release</name><argument_list>(<argument><expr>&amp;<name>pbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>n2</name> != <name>n</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetFromErrno</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>clearerr</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>f_fp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>file_writelines</name><parameter_list>(<param><decl><type><name>PyFileObject</name> *</type><name>f</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>seq</name></decl></param>)</parameter_list> <block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHUNKSIZE</name></cpp:macro> <cpp:value>1000</cpp:value></cpp:define>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>list</name></decl>, *<decl><type ref="prev"/><name>line</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>it</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>index</name></decl>, <decl><type ref="prev"/><name>islist</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>nwritten</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>seq</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>f</name>-&gt;<name>f_fp</name></name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><call><name>err_closed</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>result</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>list</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>islist</name> = <call><name>PyList_Check</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>islist</name></expr>)</condition><then>
<expr_stmt><expr><name>it</name> = <name>NULL</name></expr>;</expr_stmt></then>
<else>else <block>{
<expr_stmt><expr><name>it</name> = <call><name>PyObject_GetIter</name><argument_list>(<argument><expr><name>seq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>it</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"writelines() requires an iterable argument"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>list</name> = <call><name>PyList_New</name><argument_list>(<argument><expr><name>CHUNKSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>list</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
}</block></else></if>
<for>for (<init><expr><name>index</name> = 0</expr>;</init> <condition>;</condition> <incr><expr><name>index</name> += <name>CHUNKSIZE</name></expr></incr>) <block>{
<if>if <condition>(<expr><name>islist</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>list</name> = <call><name>PyList_GetSlice</name><argument_list>(<argument><expr><name>seq</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>index</name>+<name>CHUNKSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>list</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<expr_stmt><expr><name>j</name> = <call><name>PyList_GET_SIZE</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name>CHUNKSIZE</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
<expr_stmt><expr><name>line</name> = <call><name>PyIter_Next</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>line</name> == <name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<break>break;</break>
}</block></then></if>
<expr_stmt><expr><call><name>PyList_SetItem</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
}</block></else></if>
<if>if <condition>(<expr><name>j</name> == 0</expr>)</condition><then>
<break>break;</break></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>j</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name> <init>= <expr><call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyString_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>buffer</name></decl>;</decl_stmt>
<if>if <condition>(<expr>((<name><name>f</name>-&gt;<name>f_binary</name></name> &amp;&amp;
<call><name>PyObject_AsReadBuffer</name><argument_list>(<argument><expr><name>v</name></expr></argument>,
<argument><expr>(const <name>void</name>**)&amp;<name>buffer</name></expr></argument>,
<argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call>) ||
<call><name>PyObject_AsCharBuffer</name><argument_list>(<argument><expr><name>v</name></expr></argument>,
<argument><expr>&amp;<name>buffer</name></expr></argument>,
<argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"writelines() argument must be a sequence of strings"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>error</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>line</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>,
<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>line</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>error</name>;</goto></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyList_SET_ITEM</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></for>
<expr_stmt><expr><name><name>f</name>-&gt;<name>f_softspace</name></name> = 0</expr>;</expr_stmt>
<macro><name>FILE_BEGIN_ALLOW_THREADS</name><argument_list>(<argument>f</argument>)</argument_list></macro>
<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>j</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><name>line</name> = <call><name>PyList_GET_ITEM</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> = <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>nwritten</name> = <call><name>fwrite</name><argument_list>(<argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr>1</expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>f_fp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>nwritten</name> != <name>len</name></expr>)</condition><then> <block>{
<macro><name>FILE_ABORT_ALLOW_THREADS</name><argument_list>(<argument>f</argument>)</argument_list></macro>
<expr_stmt><expr><call><name>PyErr_SetFromErrno</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>clearerr</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>f_fp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>error</name>;</goto>
}</block></then></if>
}</block></for>
<macro><name>FILE_END_ALLOW_THREADS</name><argument_list>(<argument>f</argument>)</argument_list></macro>
<if>if <condition>(<expr><name>j</name> &lt; <name>CHUNKSIZE</name></expr>)</condition><then>
<break>break;</break></then></if>
}</block></for>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> = <name>Py_None</name></expr>;</expr_stmt>
<label><name>error</name>:</label>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>it</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>CHUNKSIZE</name></cpp:undef>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>file_self</name><parameter_list>(<param><decl><type><name>PyFileObject</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name><name>f</name>-&gt;<name>f_fp</name></name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><call><name>err_closed</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *)<name>f</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>file_xreadlines</name><parameter_list>(<param><decl><type><name>PyFileObject</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><call><name>PyErr_WarnPy3k</name><argument_list>(<argument><expr>"f.xreadlines() not supported in 3.x, "
"try 'for line in f' instead"</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>file_self</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>file_exit</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>f</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>ret</name> <init>= <expr><call><name>PyObject_CallMethod</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr>"close"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>ret</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>Py_RETURN_NONE</name></expr>;</expr_stmt>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>readline_doc</name></expr></argument>,
<argument><expr>"readline([size]) -&gt; next line from the file, as a string.\n"
"\n"
"Retain newline. A non-negative size argument limits the maximum\n"
"number of bytes to return (an incomplete line may be returned then).\n"
"Return an empty string at EOF."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>read_doc</name></expr></argument>,
<argument><expr>"read([size]) -&gt; read at most size bytes, returned as a string.\n"
"\n"
"If the size argument is negative or omitted, read until EOF is reached.\n"
"Notice that when in non-blocking mode, less data than what was requested\n"
"may be returned, even if no size parameter was given."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>write_doc</name></expr></argument>,
<argument><expr>"write(str) -&gt; None. Write string str to file.\n"
"\n"
"Note that due to buffering, flush() or close() may be needed before\n"
"the file on disk reflects the data written."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>fileno_doc</name></expr></argument>,
<argument><expr>"fileno() -&gt; integer \"file descriptor\".\n"
"\n"
"This is needed for lower-level file interfaces, such os.read()."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>seek_doc</name></expr></argument>,
<argument><expr>"seek(offset[, whence]) -&gt; None. Move to new file position.\n"
"\n"
"Argument offset is a byte count. Optional argument whence defaults to\n"
"0 (offset from start of file, offset should be &gt;= 0); other values are 1\n"
"(move relative to current position, positive or negative), and 2 (move\n"
"relative to end of file, usually negative, although many platforms allow\n"
"seeking beyond the end of a file). If the file is opened in text mode,\n"
"only offsets returned by tell() are legal. Use of other offsets causes\n"
"undefined behavior."
"\n"
"Note that not all file objects are seekable."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FTRUNCATE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>truncate_doc</name></expr></argument>,
<argument><expr>"truncate([size]) -&gt; None. Truncate the file to at most size bytes.\n"
"\n"
"Size defaults to the current file position, as returned by tell()."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>tell_doc</name></expr></argument>,
<argument><expr>"tell() -&gt; current file position, an integer (may be a long integer)."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>readinto_doc</name></expr></argument>,
<argument><expr>"readinto() -&gt; Undocumented. Don't use this; it may go away."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>readlines_doc</name></expr></argument>,
<argument><expr>"readlines([size]) -&gt; list of strings, each a line from the file.\n"
"\n"
"Call readline() repeatedly and return a list of the lines so read.\n"
"The optional size argument, if given, is an approximate bound on the\n"
"total number of bytes in the lines returned."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>xreadlines_doc</name></expr></argument>,
<argument><expr>"xreadlines() -&gt; returns self.\n"
"\n"
"For backward compatibility. File objects now include the performance\n"
"optimizations previously implemented in the xreadlines module."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>writelines_doc</name></expr></argument>,
<argument><expr>"writelines(sequence_of_strings) -&gt; None. Write the strings to the file.\n"
"\n"
"Note that newlines are not added. The sequence can be any iterable object\n"
"producing strings. This is equivalent to calling write() for each string."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>flush_doc</name></expr></argument>,
<argument><expr>"flush() -&gt; None. Flush the internal I/O buffer."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>close_doc</name></expr></argument>,
<argument><expr>"close() -&gt; None or (perhaps) an integer. Close the file.\n"
"\n"
"Sets data attribute .closed to True. A closed file cannot be used for\n"
"further I/O operations. close() may be called more than once without\n"
"error. Some kinds of file objects (for example, opened by popen())\n"
"may return an exit status upon closing."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>isatty_doc</name></expr></argument>,
<argument><expr>"isatty() -&gt; true or false. True if the file is connected to a tty device."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>enter_doc</name></expr></argument>,
<argument><expr>"__enter__() -&gt; self."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>exit_doc</name></expr></argument>,
<argument><expr>"__exit__(*excinfo) -&gt; None. Closes the file."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>file_methods</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr>"readline"</expr>, <expr>(<name>PyCFunction</name>)<name>file_readline</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>readline_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"read"</expr>, <expr>(<name>PyCFunction</name>)<name>file_read</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>read_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"write"</expr>, <expr>(<name>PyCFunction</name>)<name>file_write</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>write_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"fileno"</expr>, <expr>(<name>PyCFunction</name>)<name>file_fileno</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>fileno_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"seek"</expr>, <expr>(<name>PyCFunction</name>)<name>file_seek</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>seek_doc</name></expr>}</block></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_FTRUNCATE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{<expr>"truncate"</expr>, <expr>(<name>PyCFunction</name>)<name>file_truncate</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>truncate_doc</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr><block>{<expr>"tell"</expr>, <expr>(<name>PyCFunction</name>)<name>file_tell</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>tell_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"readinto"</expr>, <expr>(<name>PyCFunction</name>)<name>file_readinto</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>readinto_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"readlines"</expr>, <expr>(<name>PyCFunction</name>)<name>file_readlines</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>readlines_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"xreadlines"</expr>,<expr>(<name>PyCFunction</name>)<name>file_xreadlines</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>xreadlines_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"writelines"</expr>,<expr>(<name>PyCFunction</name>)<name>file_writelines</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>writelines_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"flush"</expr>, <expr>(<name>PyCFunction</name>)<name>file_flush</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>flush_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"close"</expr>, <expr>(<name>PyCFunction</name>)<name>file_close</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>close_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"isatty"</expr>, <expr>(<name>PyCFunction</name>)<name>file_isatty</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>isatty_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"__enter__"</expr>, <expr>(<name>PyCFunction</name>)<name>file_self</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>enter_doc</name></expr>}</block></expr>,
<expr><block>{<expr>"__exit__"</expr>, <expr>(<name>PyCFunction</name>)<name>file_exit</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>exit_doc</name></expr>}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OFF</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro> <cpp:value>offsetof(PyFileObject, x)</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyMemberDef</name></type> <name><name>file_memberlist</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{
<expr>"mode"</expr>, <expr><name>T_OBJECT</name></expr>, <expr><call><name>OFF</name><argument_list>(<argument><expr><name>f_mode</name></expr></argument>)</argument_list></call></expr>, <expr><name>RO</name></expr>,
<expr>"file mode ('r', 'U', 'w', 'a', possibly with 'b' or '+' added)"</expr>
}</block></expr>,
<expr><block>{
<expr>"name"</expr>, <expr><name>T_OBJECT</name></expr>, <expr><call><name>OFF</name><argument_list>(<argument><expr><name>f_name</name></expr></argument>)</argument_list></call></expr>, <expr><name>RO</name></expr>,
<expr>"file name"</expr>
}</block></expr>,
<expr><block>{
<expr>"encoding"</expr>, <expr><name>T_OBJECT</name></expr>, <expr><call><name>OFF</name><argument_list>(<argument><expr><name>f_encoding</name></expr></argument>)</argument_list></call></expr>, <expr><name>RO</name></expr>,
<expr>"file encoding"</expr>
}</block></expr>,
<expr><block>{
<expr>"errors"</expr>, <expr><name>T_OBJECT</name></expr>, <expr><call><name>OFF</name><argument_list>(<argument><expr><name>f_errors</name></expr></argument>)</argument_list></call></expr>, <expr><name>RO</name></expr>,
<expr>"Unicode error handler"</expr>
}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>get_closed</name><parameter_list>(<param><decl><type><name>PyFileObject</name> *</type><name>f</name></decl></param>, <param><decl><type><name>void</name> *</type><name>closure</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><call>(<name>long</name>)<argument_list>(<argument><expr><name><name>f</name>-&gt;<name>f_fp</name></name> == 0</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>get_newlines</name><parameter_list>(<param><decl><type><name>PyFileObject</name> *</type><name>f</name></decl></param>, <param><decl><type><name>void</name> *</type><name>closure</name></decl></param>)</parameter_list> <block>{
<switch>switch <condition>(<expr><name><name>f</name>-&gt;<name>f_newlinetypes</name></name></expr>)</condition> <block>{
<case>case <expr><name>NEWLINE_UNKNOWN</name></expr>:
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_None</name></expr>;</return>
</case><case>case <expr><name>NEWLINE_CR</name></expr>:
<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr>"\r"</expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>NEWLINE_LF</name></expr>:
<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>NEWLINE_CR</name>|<name>NEWLINE_LF</name></expr>:
<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(ss)"</expr></argument>, <argument><expr>"\r"</expr></argument>, <argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>NEWLINE_CRLF</name></expr>:
<return>return <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr>"\r\n"</expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>NEWLINE_CR</name>|<name>NEWLINE_CRLF</name></expr>:
<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(ss)"</expr></argument>, <argument><expr>"\r"</expr></argument>, <argument><expr>"\r\n"</expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>NEWLINE_LF</name>|<name>NEWLINE_CRLF</name></expr>:
<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(ss)"</expr></argument>, <argument><expr>"\n"</expr></argument>, <argument><expr>"\r\n"</expr></argument>)</argument_list></call></expr>;</return>
</case><case>case <expr><name>NEWLINE_CR</name>|<name>NEWLINE_LF</name>|<name>NEWLINE_CRLF</name></expr>:
<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(sss)"</expr></argument>, <argument><expr>"\r"</expr></argument>, <argument><expr>"\n"</expr></argument>, <argument><expr>"\r\n"</expr></argument>)</argument_list></call></expr>;</return>
</case><default>default:
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
<argument><expr>"Unknown newlines value 0x%x\n"</expr></argument>,
<argument><expr><name><name>f</name>-&gt;<name>f_newlinetypes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
</default>}</block></switch>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>get_softspace</name><parameter_list>(<param><decl><type><name>PyFileObject</name> *</type><name>f</name></decl></param>, <param><decl><type><name>void</name> *</type><name>closure</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><call><name>PyErr_WarnPy3k</name><argument_list>(<argument><expr>"file.softspace not supported in 3.x"</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>f_softspace</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>set_softspace</name><parameter_list>(<param><decl><type><name>PyFileObject</name> *</type><name>f</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>value</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>new</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyErr_WarnPy3k</name><argument_list>(<argument><expr>"file.softspace not supported in 3.x"</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr><name>value</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"can't delete softspace attribute"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>new</name> = <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>new</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><name><name>f</name>-&gt;<name>f_softspace</name></name> = <name>new</name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyGetSetDef</name></type> <name><name>file_getsetlist</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr>"closed"</expr>, <expr>(<name>getter</name>)<name>get_closed</name></expr>, <expr><name>NULL</name></expr>, <expr>"True if the file is closed"</expr>}</block></expr>,
<expr><block>{
<expr>"newlines"</expr>, <expr>(<name>getter</name>)<name>get_newlines</name></expr>, <expr><name>NULL</name></expr>,
<expr>"end-of-line convention used in this file"</expr>
}</block></expr>,
<expr><block>{
<expr>"softspace"</expr>, <expr>(<name>getter</name>)<name>get_softspace</name></expr>, <expr>(<name>setter</name>)<name>set_softspace</name></expr>,
<expr>"flag indicating that a space needs to be printed; used by print"</expr>
}</block></expr>,
<expr><block>{<expr>0</expr>}</block></expr>,
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>drop_readahead</name><parameter_list>(<param><decl><type><name>PyFileObject</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name><name>f</name>-&gt;<name>f_buf</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>f_buf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>f</name>-&gt;<name>f_buf</name></name> = <name>NULL</name></expr>;</expr_stmt>
}</block></then></if>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>readahead</name><parameter_list>(<param><decl><type><name>PyFileObject</name> *</type><name>f</name></decl></param>, <param><decl><type><name>int</name></type> <name>bufsize</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>chunksize</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>f</name>-&gt;<name>f_buf</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
<if>if<condition>( <expr>(<name><name>f</name>-&gt;<name>f_bufend</name></name> - <name><name>f</name>-&gt;<name>f_bufptr</name></name>) &gt;= 1</expr>)</condition><then>
<return>return <expr>0</expr>;</return></then>
<else>else
<expr_stmt><expr><call><name>drop_readahead</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
}</block></then></if>
<if>if <condition>(<expr>(<name><name>f</name>-&gt;<name>f_buf</name></name> = (<name>char</name> *)<call><name>PyMem_Malloc</name><argument_list>(<argument><expr><name>bufsize</name></expr></argument>)</argument_list></call>) == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<macro><name>FILE_BEGIN_ALLOW_THREADS</name><argument_list>(<argument>f</argument>)</argument_list></macro>
<expr_stmt><expr><name>errno</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>chunksize</name> = <call><name>Py_UniversalNewlineFread</name><argument_list>(
<argument><expr><name><name>f</name>-&gt;<name>f_buf</name></name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>f_fp</name></name></expr></argument>, <argument><expr>(<name>PyObject</name> *)<name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>FILE_END_ALLOW_THREADS</name><argument_list>(<argument>f</argument>)</argument_list></macro>
<if>if <condition>(<expr><name>chunksize</name> == 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>ferror</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>f_fp</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetFromErrno</name><argument_list>(<argument><expr><name>PyExc_IOError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>clearerr</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>f_fp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>drop_readahead</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
}</block></then></if>
<expr_stmt><expr><name><name>f</name>-&gt;<name>f_bufptr</name></name> = <name><name>f</name>-&gt;<name>f_buf</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>f</name>-&gt;<name>f_bufend</name></name> = <name><name>f</name>-&gt;<name>f_buf</name></name> + <name>chunksize</name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyStringObject</name> *</type>
<name>readahead_get_line_skip</name><parameter_list>(<param><decl><type><name>PyFileObject</name> *</type><name>f</name></decl></param>, <param><decl><type><name>int</name></type> <name>skip</name></decl></param>, <param><decl><type><name>int</name></type> <name>bufsize</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyStringObject</name>*</type> <name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>bufptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>f</name>-&gt;<name>f_buf</name></name> == <name>NULL</name></expr>)</condition><then>
<if>if <condition>(<expr><call><name>readahead</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if></then></if>
<expr_stmt><expr><name>len</name> = <name><name>f</name>-&gt;<name>f_bufend</name></name> - <name><name>f</name>-&gt;<name>f_bufptr</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>len</name> == 0</expr>)</condition><then>
<return>return <expr>(<name>PyStringObject</name> *)
<call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>skip</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>bufptr</name> = (<name>char</name> *)<call><name>memchr</name><argument_list>(<argument><expr><name><name>f</name>-&gt;<name>f_bufptr</name></name></expr></argument>, <argument><expr>'\n'</expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>bufptr</name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>bufptr</name>++</expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> = <name>bufptr</name> - <name><name>f</name>-&gt;<name>f_bufptr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> = (<name>PyStringObject</name> *)
<call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>skip</name>+<name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>s</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call>+<name>skip</name></expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>f_bufptr</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>f</name>-&gt;<name>f_bufptr</name></name> = <name>bufptr</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>bufptr</name> == <name><name>f</name>-&gt;<name>f_bufend</name></name></expr>)</condition><then>
<expr_stmt><expr><call><name>drop_readahead</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>bufptr</name> = <name><name>f</name>-&gt;<name>f_bufptr</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>buf</name> = <name><name>f</name>-&gt;<name>f_buf</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>f</name>-&gt;<name>f_buf</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>skip</name>+<name>len</name> &lt; <name>INT_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> = <call><name>readahead_get_line_skip</name><argument_list>(
<argument><expr><name>f</name></expr></argument>, <argument><expr><call>(<name>int</name>)<argument_list>(<argument><expr><name>skip</name>+<name>len</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>bufsize</name> + (<name>bufsize</name>&gt;&gt;2)</expr></argument> )</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>s</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call>+<name>skip</name></expr></argument>, <argument><expr><name>bufptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<return>return <expr><name>s</name></expr>;</return>
}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READAHEAD_BUFSIZE</name></cpp:macro> <cpp:value>8192</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>file_iternext</name><parameter_list>(<param><decl><type><name>PyFileObject</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyStringObject</name>*</type> <name>l</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>f</name>-&gt;<name>f_fp</name></name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><call><name>err_closed</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>l</name> = <call><name>readahead_get_line_skip</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>READAHEAD_BUFSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>l</name> == <name>NULL</name> || <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr>(<name>PyObject</name> *)<name>l</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>file_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>self</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyObject</name> *</type><name>not_yet_string</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>type</name> != <name>NULL</name> &amp;&amp; <name><name>type</name>-&gt;<name>tp_alloc</name></name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>not_yet_string</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>not_yet_string</name> = <call><name>PyString_InternFromString</name><argument_list>(<argument><expr>"&lt;uninitialized file&gt;"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>not_yet_string</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
}</block></then></if>
<expr_stmt><expr><name>self</name> = <call><name><name>type</name>-&gt;<name>tp_alloc</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>self</name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>not_yet_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>((<name>PyFileObject</name> *)<name>self</name>)-&gt;<name>f_name</name> = <name>not_yet_string</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>not_yet_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>((<name>PyFileObject</name> *)<name>self</name>)-&gt;<name>f_mode</name> = <name>not_yet_string</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>((<name>PyFileObject</name> *)<name>self</name>)-&gt;<name>f_encoding</name> = <name>Py_None</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_None</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>((<name>PyFileObject</name> *)<name>self</name>)-&gt;<name>f_errors</name> = <name>Py_None</name></expr>;</expr_stmt>
<expr_stmt><expr>((<name>PyFileObject</name> *)<name>self</name>)-&gt;<name>weakreflist</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr>((<name>PyFileObject</name> *)<name>self</name>)-&gt;<name>unlocked_count</name> = 0</expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>self</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>file_init</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyFileObject</name> *</type><name>foself</name> <init>= <expr>(<name>PyFileObject</name> *)<name>self</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>kwlist</name><index>[]</index></name> <init>= <expr><block>{<expr>"name"</expr>, <expr>"mode"</expr>, <expr>"buffering"</expr>, <expr>0</expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>mode</name> <init>= <expr>"r"</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bufsize</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>wideargument</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyFile_Check</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>foself</name>-&gt;<name>f_fp</name></name> != <name>NULL</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>closeresult</name> <init>= <expr><call><name>file_close</name><argument_list>(<argument><expr><name>foself</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>closeresult</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>closeresult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_WIN_WIDE_FILENAMES</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><call><name>GetVersion</name><argument_list>()</argument_list></call> &lt; 0x80000000</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>po</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>, <argument><expr>"U|si:file"</expr></argument>,
<argument><expr><name>kwlist</name></expr></argument>, <argument><expr>&amp;<name>po</name></expr></argument>, <argument><expr>&amp;<name>mode</name></expr></argument>, <argument><expr>&amp;<name>bufsize</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>wideargument</name> = 1</expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>fill_file_fields</name><argument_list>(<argument><expr><name>foself</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>po</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>,
<argument><expr><name>fclose</name></expr></argument>)</argument_list></call> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>Error</name>;</goto></then></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr>!<name>wideargument</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>o_name</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>, <argument><expr>"et|si:file"</expr></argument>, <argument><expr><name>kwlist</name></expr></argument>,
<argument><expr><name>Py_FileSystemDefaultEncoding</name></expr></argument>,
<argument><expr>&amp;<name>name</name></expr></argument>,
<argument><expr>&amp;<name>mode</name></expr></argument>, <argument><expr>&amp;<name>bufsize</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>, <argument><expr>"O|si:file"</expr></argument>,
<argument><expr><name>kwlist</name></expr></argument>, <argument><expr>&amp;<name>o_name</name></expr></argument>, <argument><expr>&amp;<name>mode</name></expr></argument>,
<argument><expr>&amp;<name>bufsize</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<goto>goto <name>Error</name>;</goto></then></if>
<if>if <condition>(<expr><call><name>fill_file_fields</name><argument_list>(<argument><expr><name>foself</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>o_name</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>,
<argument><expr><name>fclose</name></expr></argument>)</argument_list></call> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>Error</name>;</goto></then></if>
}</block></then></if>
<if>if <condition>(<expr><call><name>open_the_file</name><argument_list>(<argument><expr><name>foself</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>Error</name>;</goto></then></if>
<expr_stmt><expr><name><name>foself</name>-&gt;<name>f_setbuf</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyFile_SetBufSize</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>Done</name>;</goto>
<label><name>Error</name>:</label>
<expr_stmt><expr><name>ret</name> = -1</expr>;</expr_stmt>
<label><name>Done</name>:</label>
<expr_stmt><expr><call><name>PyMem_Free</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_VAR</name><argument_list>(<argument><expr><name>file_doc</name></expr></argument>)</argument_list></call> =
<macro><name>PyDoc_STR</name><argument_list>(
<argument>"file(name[, mode[, buffering]]) -&gt; file object\n"
"\n"
"Open a file. The mode can be 'r', 'w' or 'a' for reading (default),\n"
"writing or appending. The file will be created if it doesn't exist\n"
"when opened for writing or appending; it will be truncated when\n"
"opened for writing. Add a 'b' to the mode for binary files.\n"
"Add a '+' to the mode to allow simultaneous reading and writing.\n"
"If the buffering argument is given, 0 means unbuffered, 1 means line\n"
"buffered, and larger numbers specify the buffer size. The preferred way\n"
"to open a file is with the builtin open() function.\n"</argument>
)</argument_list></macro>
<call><name>PyDoc_STR</name><argument_list>(
<argument><expr>"Add a 'U' to mode to open the file for input with universal newline\n"
"support. Any line ending in the input file will be seen as a '\\n'\n"
"in Python. Also, a file so opened gains the attribute 'newlines';\n"
"the value for this attribute is one of None (no newline read yet),\n"
"'\\r', '\\n', '\\r\\n' or a tuple containing all the newline types seen.\n"
"\n"
"'U' cannot be combined with 'w' or '+' mode.\n"</expr></argument>
)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>PyTypeObject</name></type> <name>PyFile_Type</name> <init>= <expr><block>{
<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr>&amp;<name>PyType_Type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
"file"</expr>,
<expr><sizeof>sizeof<argument_list>(<argument><expr><name>PyFileObject</name></expr></argument>)</argument_list></sizeof></expr>,
<expr>0</expr>,
<expr>(<name>destructor</name>)<name>file_dealloc</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>(<name>reprfunc</name>)<name>file_repr</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>PyObject_GenericGetAttr</name></expr>,
<expr><name>PyObject_GenericSetAttr</name></expr>,
<expr>0</expr>,
<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_BASETYPE</name> | <name>Py_TPFLAGS_HAVE_WEAKREFS</name></expr>,
<expr><name>file_doc</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PyFileObject</name></expr></argument>, <argument><expr><name>weakreflist</name></expr></argument>)</argument_list></call></expr>,
<expr>(<name>getiterfunc</name>)<name>file_self</name></expr>,
<expr>(<name>iternextfunc</name>)<name>file_iternext</name></expr>,
<expr><name>file_methods</name></expr>,
<expr><name>file_memberlist</name></expr>,
<expr><name>file_getsetlist</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>file_init</name></expr>,
<expr><name>PyType_GenericAlloc</name></expr>,
<expr><name>file_new</name></expr>,
<expr><name>PyObject_Del</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
<function><type><name>int</name></type>
<name>PyFile_SoftSpace</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>f</name></decl></param>, <param><decl><type><name>int</name></type> <name>newflag</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>long</name></type> <name>oldflag</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>f</name> == <name>NULL</name></expr>)</condition><then> <block>{
}</block></then> <else>else <if>if <condition>(<expr><call><name>PyFile_Check</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>oldflag</name> = ((<name>PyFileObject</name> *)<name>f</name>)-&gt;<name>f_softspace</name></expr>;</expr_stmt>
<expr_stmt><expr>((<name>PyFileObject</name> *)<name>f</name>)-&gt;<name>f_softspace</name> = <name>newflag</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
<expr_stmt><expr><name>v</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr>"softspace"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
<else>else <block>{
<if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>oldflag</name> = <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>oldflag</name> &lt; <name>INT_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><name>v</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name>newflag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then>
<else>else <block>{
<if>if <condition>(<expr><call><name>PyObject_SetAttrString</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr>"softspace"</expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
}</block></else></if></else></if>
<return>return <expr>(<name>int</name>)<name>oldflag</name></expr>;</return>
}</block></function>
<function><type><name>int</name></type>
<name>PyFile_WriteObject</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>f</name></decl></param>, <param><decl><type><name>int</name></type> <name>flags</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>writer</name></decl>, *<decl><type ref="prev"/><name>value</name></decl>, *<decl><type ref="prev"/><name>args</name></decl>, *<decl><type ref="prev"/><name>result</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>f</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"writeobject with NULL file"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><call><name>PyFile_Check</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyFileObject</name> *</type><name>fobj</name> <init>= <expr>(<name>PyFileObject</name> *) <name>f</name></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_USING_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>enc</name> <init>= <expr><name><name>fobj</name>-&gt;<name>f_encoding</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><name><name>fobj</name>-&gt;<name>f_fp</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>err_closed</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_USING_UNICODE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr>(<name>flags</name> &amp; <name>Py_PRINT_RAW</name>) &amp;&amp;
<call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> &amp;&amp; <name>enc</name> != <name>Py_None</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>cenc</name> <init>= <expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>enc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>errors</name> <init>= <expr><name><name>fobj</name>-&gt;<name>f_errors</name></name> == <name>Py_None</name> ?
"strict" : <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name><name>fobj</name>-&gt;<name>f_errors</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>value</name> = <call><name>PyUnicode_AsEncodedString</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>cenc</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>value</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>value</name> = <name>v</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><name>result</name> = <call><name>file_PyObject_Print</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>fobj</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<return>return <expr><call><name>file_PyObject_Print</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>fobj</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></then></if></else></if>
<expr_stmt><expr><name>writer</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr>"write"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>writer</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr><name>flags</name> &amp; <name>Py_PRINT_RAW</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>value</name> = <name>v</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else
<expr_stmt><expr><name>value</name> = <call><name>PyObject_Str</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
}</block></then> <else>else
<expr_stmt><expr><name>value</name> = <call><name>PyObject_Repr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<if>if <condition>(<expr><name>value</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>writer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>args</name> = <call><name>PyTuple_Pack</name><argument_list>(<argument><expr>1</expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>args</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>writer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>result</name> = <call><name>PyEval_CallObject</name><argument_list>(<argument><expr><name>writer</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>writer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><name>int</name></type>
<name>PyFile_WriteString</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>f</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name>f</name> == <name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
<argument><expr>"null file for PyFile_WriteString"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr>-1</expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><call><name>PyFile_Check</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyFileObject</name> *</type><name>fobj</name> <init>= <expr>(<name>PyFileObject</name> *) <name>f</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>FILE</name> *</type><name>fp</name> <init>= <expr><call><name>PyFile_AsFile</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>fp</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>err_closed</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<macro><name>FILE_BEGIN_ALLOW_THREADS</name><argument_list>(<argument>fobj</argument>)</argument_list></macro>
<expr_stmt><expr><call><name>fputs</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<macro><name>FILE_END_ALLOW_THREADS</name><argument_list>(<argument>fobj</argument>)</argument_list></macro>
<return>return <expr>0</expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr>!<call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name> <init>= <expr><call><name>PyString_FromString</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>err</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><name>err</name> = <call><name>PyFile_WriteObject</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>Py_PRINT_RAW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>err</name></expr>;</return>
}</block></then> <else>else
<return>return <expr>-1</expr>;</return></else></if></else></if></else></if>
}</block></function>
<function><type><name>int</name></type> <name>PyObject_AsFileDescriptor</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>o</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>meth</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>fd</name> = <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><call><name>PyLong_Check</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>fd</name> = <call><name>PyLong_AsLong</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr>(<name>meth</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>o</name></expr></argument>, <argument><expr>"fileno"</expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>fno</name> <init>= <expr><call><name>PyEval_CallObject</name><argument_list>(<argument><expr><name>meth</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>meth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>fno</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>fno</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>fd</name> = <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>fno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>fno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><call><name>PyLong_Check</name><argument_list>(<argument><expr><name>fno</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>fd</name> = <call><name>PyLong_AsLong</name><argument_list>(<argument><expr><name>fno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>fno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"fileno() returned a non-integer"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>fno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></else></if></else></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"argument must be an int, or have a fileno() method."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></else></if></else></if></else></if>
<if>if <condition>(<expr><name>fd</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"file descriptor cannot be a negative integer (%i)"</expr></argument>,
<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<return>return <expr><name>fd</name></expr>;</return>
}</block></function>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>fgets</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>fread</name></cpp:undef>
<function><type><name>char</name> *</type>
<name>Py_UniversalNewlineFgets</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>buf</name></decl></param>, <param><decl><type><name>int</name></type> <name>n</name></decl></param>, <param><decl><type><name>FILE</name> *</type><name>stream</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>fobj</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>p</name> <init>= <expr><name>buf</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>newlinetypes</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>skipnextlf</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>univ_newline</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>fobj</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<call><name>PyFile_Check</name><argument_list>(<argument><expr><name>fobj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>errno</name> = <name>ENXIO</name></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>univ_newline</name> = ((<name>PyFileObject</name> *)<name>fobj</name>)-&gt;<name>f_univ_newline</name></expr>;</expr_stmt>
<if>if <condition>( <expr>!<name>univ_newline</name></expr> )</condition><then>
<return>return <expr><call><name>fgets</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>newlinetypes</name> = ((<name>PyFileObject</name> *)<name>fobj</name>)-&gt;<name>f_newlinetypes</name></expr>;</expr_stmt>
<expr_stmt><expr><name>skipnextlf</name> = ((<name>PyFileObject</name> *)<name>fobj</name>)-&gt;<name>f_skipnextlf</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>FLOCKFILE</name><argument_list>(<argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> = 'x'</expr>;</expr_stmt>
<while>while <condition>(<expr>--<name>n</name> &gt; 0 &amp;&amp; (<name>c</name> = <call><name>GETC</name><argument_list>(<argument><expr><name>stream</name></expr></argument>)</argument_list></call>) != <name>EOF</name></expr> )</condition> <block>{
<if>if <condition>(<expr><name>skipnextlf</name></expr> )</condition><then> <block>{
<expr_stmt><expr><name>skipnextlf</name> = 0</expr>;</expr_stmt>
<if>if <condition>(<expr><name>c</name> == '\n'</expr>)</condition><then> <block>{
<expr_stmt><expr><name>newlinetypes</name> |= <name>NEWLINE_CRLF</name></expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> = <call><name>GETC</name><argument_list>(<argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>c</name> == <name>EOF</name></expr>)</condition><then> <break>break;</break></then></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>newlinetypes</name> |= <name>NEWLINE_CR</name></expr>;</expr_stmt>
}</block></else></if>
}</block></then></if>
<if>if <condition>(<expr><name>c</name> == '\r'</expr>)</condition><then> <block>{
<expr_stmt><expr><name>skipnextlf</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> = '\n'</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>( <expr><name>c</name> == '\n'</expr>)</condition><then> <block>{
<expr_stmt><expr><name>newlinetypes</name> |= <name>NEWLINE_LF</name></expr>;</expr_stmt>
}</block></then></if></else></if>
<expr_stmt><expr>*<name>p</name>++ = <name>c</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>c</name> == '\n'</expr>)</condition><then> <break>break;</break></then></if>
}</block></while>
<if>if <condition>( <expr><name>c</name> == <name>EOF</name> &amp;&amp; <name>skipnextlf</name></expr> )</condition><then>
<expr_stmt><expr><name>newlinetypes</name> |= <name>NEWLINE_CR</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>FUNLOCKFILE</name><argument_list>(<argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name> = '\0'</expr>;</expr_stmt>
<if>if <condition>(<expr><name>fobj</name></expr>)</condition><then> <block>{
<expr_stmt><expr>((<name>PyFileObject</name> *)<name>fobj</name>)-&gt;<name>f_newlinetypes</name> = <name>newlinetypes</name></expr>;</expr_stmt>
<expr_stmt><expr>((<name>PyFileObject</name> *)<name>fobj</name>)-&gt;<name>f_skipnextlf</name> = <name>skipnextlf</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>( <expr><name>skipnextlf</name></expr> )</condition><then> <block>{
<expr_stmt><expr><name>c</name> = <call><name>GETC</name><argument_list>(<argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>( <expr><name>c</name> != '\n'</expr> )</condition><then>
<expr_stmt><expr><call><name>ungetc</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></then></if></else></if>
<if>if <condition>(<expr><name>p</name> == <name>buf</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><name>buf</name></expr>;</return>
}</block></function>
<function><type><name>size_t</name></type>
<name>Py_UniversalNewlineFread</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>buf</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>n</name></decl></param>,
<param><decl><type><name>FILE</name> *</type><name>stream</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>fobj</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>dst</name> <init>= <expr><name>buf</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyFileObject</name> *</type><name>f</name> <init>= <expr>(<name>PyFileObject</name> *)<name>fobj</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>newlinetypes</name></decl>, <decl><type ref="prev"/><name>skipnextlf</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>buf</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>stream</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>fobj</name> || !<call><name>PyFile_Check</name><argument_list>(<argument><expr><name>fobj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>errno</name> = <name>ENXIO</name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>!<name><name>f</name>-&gt;<name>f_univ_newline</name></name></expr>)</condition><then>
<return>return <expr><call><name>fread</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>newlinetypes</name> = <name><name>f</name>-&gt;<name>f_newlinetypes</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>skipnextlf</name> = <name><name>f</name>-&gt;<name>f_skipnextlf</name></name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>n</name></expr>)</condition> <block>{
<decl_stmt><decl><type><name>size_t</name></type> <name>nread</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>shortread</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>src</name> <init>= <expr><name>dst</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>nread</name> = <call><name>fread</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>n</name></expr></argument>, <argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>nread</name> &lt;= <name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>nread</name> == 0</expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr><name>n</name> -= <name>nread</name></expr>;</expr_stmt>
<expr_stmt><expr><name>shortread</name> = <name>n</name> != 0</expr>;</expr_stmt>
<while>while <condition>(<expr><name>nread</name>--</expr>)</condition> <block>{
<decl_stmt><decl><type><name>char</name></type> <name>c</name> <init>= <expr>*<name>src</name>++</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>c</name> == '\r'</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>dst</name>++ = '\n'</expr>;</expr_stmt>
<expr_stmt><expr><name>skipnextlf</name> = 1</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>skipnextlf</name> &amp;&amp; <name>c</name> == '\n'</expr>)</condition><then> <block>{
<expr_stmt><expr><name>skipnextlf</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>newlinetypes</name> |= <name>NEWLINE_CRLF</name></expr>;</expr_stmt>
<expr_stmt><expr>++<name>n</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<if>if <condition>(<expr><name>c</name> == '\n'</expr>)</condition><then>
<expr_stmt><expr><name>newlinetypes</name> |= <name>NEWLINE_LF</name></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name>skipnextlf</name></expr>)</condition><then>
<expr_stmt><expr><name>newlinetypes</name> |= <name>NEWLINE_CR</name></expr>;</expr_stmt></then></if></else></if>
<expr_stmt><expr>*<name>dst</name>++ = <name>c</name></expr>;</expr_stmt>
<expr_stmt><expr><name>skipnextlf</name> = 0</expr>;</expr_stmt>
}</block></else></if></else></if>
}</block></while>
<if>if <condition>(<expr><name>shortread</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>skipnextlf</name> &amp;&amp; <call><name>feof</name><argument_list>(<argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>newlinetypes</name> |= <name>NEWLINE_CR</name></expr>;</expr_stmt></then></if>
<break>break;</break>
}</block></then></if>
}</block></while>
<expr_stmt><expr><name><name>f</name>-&gt;<name>f_newlinetypes</name></name> = <name>newlinetypes</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>f</name>-&gt;<name>f_skipnextlf</name></name> = <name>skipnextlf</name></expr>;</expr_stmt>
<return>return <expr><name>dst</name> - <name>buf</name></expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call></expr></cpp:if>
}</block></extern>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
