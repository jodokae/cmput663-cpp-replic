<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="Objects/bytes_methods.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"bytes_methods.h"</cpp:file></cpp:include>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>int</name></type> <name><name>_Py_ctype_table</name><index>[<expr>256</expr>]</index></name> <init>= <expr><block>{
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>FLAG_SPACE</name></expr>,
<expr><name>FLAG_SPACE</name></expr>,
<expr><name>FLAG_SPACE</name></expr>,
<expr><name>FLAG_SPACE</name></expr>,
<expr><name>FLAG_SPACE</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>FLAG_SPACE</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>FLAG_DIGIT</name>|<name>FLAG_XDIGIT</name></expr>,
<expr><name>FLAG_DIGIT</name>|<name>FLAG_XDIGIT</name></expr>,
<expr><name>FLAG_DIGIT</name>|<name>FLAG_XDIGIT</name></expr>,
<expr><name>FLAG_DIGIT</name>|<name>FLAG_XDIGIT</name></expr>,
<expr><name>FLAG_DIGIT</name>|<name>FLAG_XDIGIT</name></expr>,
<expr><name>FLAG_DIGIT</name>|<name>FLAG_XDIGIT</name></expr>,
<expr><name>FLAG_DIGIT</name>|<name>FLAG_XDIGIT</name></expr>,
<expr><name>FLAG_DIGIT</name>|<name>FLAG_XDIGIT</name></expr>,
<expr><name>FLAG_DIGIT</name>|<name>FLAG_XDIGIT</name></expr>,
<expr><name>FLAG_DIGIT</name>|<name>FLAG_XDIGIT</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>FLAG_UPPER</name>|<name>FLAG_XDIGIT</name></expr>,
<expr><name>FLAG_UPPER</name>|<name>FLAG_XDIGIT</name></expr>,
<expr><name>FLAG_UPPER</name>|<name>FLAG_XDIGIT</name></expr>,
<expr><name>FLAG_UPPER</name>|<name>FLAG_XDIGIT</name></expr>,
<expr><name>FLAG_UPPER</name>|<name>FLAG_XDIGIT</name></expr>,
<expr><name>FLAG_UPPER</name>|<name>FLAG_XDIGIT</name></expr>,
<expr><name>FLAG_UPPER</name></expr>,
<expr><name>FLAG_UPPER</name></expr>,
<expr><name>FLAG_UPPER</name></expr>,
<expr><name>FLAG_UPPER</name></expr>,
<expr><name>FLAG_UPPER</name></expr>,
<expr><name>FLAG_UPPER</name></expr>,
<expr><name>FLAG_UPPER</name></expr>,
<expr><name>FLAG_UPPER</name></expr>,
<expr><name>FLAG_UPPER</name></expr>,
<expr><name>FLAG_UPPER</name></expr>,
<expr><name>FLAG_UPPER</name></expr>,
<expr><name>FLAG_UPPER</name></expr>,
<expr><name>FLAG_UPPER</name></expr>,
<expr><name>FLAG_UPPER</name></expr>,
<expr><name>FLAG_UPPER</name></expr>,
<expr><name>FLAG_UPPER</name></expr>,
<expr><name>FLAG_UPPER</name></expr>,
<expr><name>FLAG_UPPER</name></expr>,
<expr><name>FLAG_UPPER</name></expr>,
<expr><name>FLAG_UPPER</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>FLAG_LOWER</name>|<name>FLAG_XDIGIT</name></expr>,
<expr><name>FLAG_LOWER</name>|<name>FLAG_XDIGIT</name></expr>,
<expr><name>FLAG_LOWER</name>|<name>FLAG_XDIGIT</name></expr>,
<expr><name>FLAG_LOWER</name>|<name>FLAG_XDIGIT</name></expr>,
<expr><name>FLAG_LOWER</name>|<name>FLAG_XDIGIT</name></expr>,
<expr><name>FLAG_LOWER</name>|<name>FLAG_XDIGIT</name></expr>,
<expr><name>FLAG_LOWER</name></expr>,
<expr><name>FLAG_LOWER</name></expr>,
<expr><name>FLAG_LOWER</name></expr>,
<expr><name>FLAG_LOWER</name></expr>,
<expr><name>FLAG_LOWER</name></expr>,
<expr><name>FLAG_LOWER</name></expr>,
<expr><name>FLAG_LOWER</name></expr>,
<expr><name>FLAG_LOWER</name></expr>,
<expr><name>FLAG_LOWER</name></expr>,
<expr><name>FLAG_LOWER</name></expr>,
<expr><name>FLAG_LOWER</name></expr>,
<expr><name>FLAG_LOWER</name></expr>,
<expr><name>FLAG_LOWER</name></expr>,
<expr><name>FLAG_LOWER</name></expr>,
<expr><name>FLAG_LOWER</name></expr>,
<expr><name>FLAG_LOWER</name></expr>,
<expr><name>FLAG_LOWER</name></expr>,
<expr><name>FLAG_LOWER</name></expr>,
<expr><name>FLAG_LOWER</name></expr>,
<expr><name>FLAG_LOWER</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name><name>_Py_ctype_tolower</name><index>[<expr>256</expr>]</index></name> <init>= <expr><block>{
<expr>0x00</expr>, <expr>0x01</expr>, <expr>0x02</expr>, <expr>0x03</expr>, <expr>0x04</expr>, <expr>0x05</expr>, <expr>0x06</expr>, <expr>0x07</expr>,
<expr>0x08</expr>, <expr>0x09</expr>, <expr>0x0a</expr>, <expr>0x0b</expr>, <expr>0x0c</expr>, <expr>0x0d</expr>, <expr>0x0e</expr>, <expr>0x0f</expr>,
<expr>0x10</expr>, <expr>0x11</expr>, <expr>0x12</expr>, <expr>0x13</expr>, <expr>0x14</expr>, <expr>0x15</expr>, <expr>0x16</expr>, <expr>0x17</expr>,
<expr>0x18</expr>, <expr>0x19</expr>, <expr>0x1a</expr>, <expr>0x1b</expr>, <expr>0x1c</expr>, <expr>0x1d</expr>, <expr>0x1e</expr>, <expr>0x1f</expr>,
<expr>0x20</expr>, <expr>0x21</expr>, <expr>0x22</expr>, <expr>0x23</expr>, <expr>0x24</expr>, <expr>0x25</expr>, <expr>0x26</expr>, <expr>0x27</expr>,
<expr>0x28</expr>, <expr>0x29</expr>, <expr>0x2a</expr>, <expr>0x2b</expr>, <expr>0x2c</expr>, <expr>0x2d</expr>, <expr>0x2e</expr>, <expr>0x2f</expr>,
<expr>0x30</expr>, <expr>0x31</expr>, <expr>0x32</expr>, <expr>0x33</expr>, <expr>0x34</expr>, <expr>0x35</expr>, <expr>0x36</expr>, <expr>0x37</expr>,
<expr>0x38</expr>, <expr>0x39</expr>, <expr>0x3a</expr>, <expr>0x3b</expr>, <expr>0x3c</expr>, <expr>0x3d</expr>, <expr>0x3e</expr>, <expr>0x3f</expr>,
<expr>0x40</expr>, <expr>0x61</expr>, <expr>0x62</expr>, <expr>0x63</expr>, <expr>0x64</expr>, <expr>0x65</expr>, <expr>0x66</expr>, <expr>0x67</expr>,
<expr>0x68</expr>, <expr>0x69</expr>, <expr>0x6a</expr>, <expr>0x6b</expr>, <expr>0x6c</expr>, <expr>0x6d</expr>, <expr>0x6e</expr>, <expr>0x6f</expr>,
<expr>0x70</expr>, <expr>0x71</expr>, <expr>0x72</expr>, <expr>0x73</expr>, <expr>0x74</expr>, <expr>0x75</expr>, <expr>0x76</expr>, <expr>0x77</expr>,
<expr>0x78</expr>, <expr>0x79</expr>, <expr>0x7a</expr>, <expr>0x5b</expr>, <expr>0x5c</expr>, <expr>0x5d</expr>, <expr>0x5e</expr>, <expr>0x5f</expr>,
<expr>0x60</expr>, <expr>0x61</expr>, <expr>0x62</expr>, <expr>0x63</expr>, <expr>0x64</expr>, <expr>0x65</expr>, <expr>0x66</expr>, <expr>0x67</expr>,
<expr>0x68</expr>, <expr>0x69</expr>, <expr>0x6a</expr>, <expr>0x6b</expr>, <expr>0x6c</expr>, <expr>0x6d</expr>, <expr>0x6e</expr>, <expr>0x6f</expr>,
<expr>0x70</expr>, <expr>0x71</expr>, <expr>0x72</expr>, <expr>0x73</expr>, <expr>0x74</expr>, <expr>0x75</expr>, <expr>0x76</expr>, <expr>0x77</expr>,
<expr>0x78</expr>, <expr>0x79</expr>, <expr>0x7a</expr>, <expr>0x7b</expr>, <expr>0x7c</expr>, <expr>0x7d</expr>, <expr>0x7e</expr>, <expr>0x7f</expr>,
<expr>0x80</expr>, <expr>0x81</expr>, <expr>0x82</expr>, <expr>0x83</expr>, <expr>0x84</expr>, <expr>0x85</expr>, <expr>0x86</expr>, <expr>0x87</expr>,
<expr>0x88</expr>, <expr>0x89</expr>, <expr>0x8a</expr>, <expr>0x8b</expr>, <expr>0x8c</expr>, <expr>0x8d</expr>, <expr>0x8e</expr>, <expr>0x8f</expr>,
<expr>0x90</expr>, <expr>0x91</expr>, <expr>0x92</expr>, <expr>0x93</expr>, <expr>0x94</expr>, <expr>0x95</expr>, <expr>0x96</expr>, <expr>0x97</expr>,
<expr>0x98</expr>, <expr>0x99</expr>, <expr>0x9a</expr>, <expr>0x9b</expr>, <expr>0x9c</expr>, <expr>0x9d</expr>, <expr>0x9e</expr>, <expr>0x9f</expr>,
<expr>0xa0</expr>, <expr>0xa1</expr>, <expr>0xa2</expr>, <expr>0xa3</expr>, <expr>0xa4</expr>, <expr>0xa5</expr>, <expr>0xa6</expr>, <expr>0xa7</expr>,
<expr>0xa8</expr>, <expr>0xa9</expr>, <expr>0xaa</expr>, <expr>0xab</expr>, <expr>0xac</expr>, <expr>0xad</expr>, <expr>0xae</expr>, <expr>0xaf</expr>,
<expr>0xb0</expr>, <expr>0xb1</expr>, <expr>0xb2</expr>, <expr>0xb3</expr>, <expr>0xb4</expr>, <expr>0xb5</expr>, <expr>0xb6</expr>, <expr>0xb7</expr>,
<expr>0xb8</expr>, <expr>0xb9</expr>, <expr>0xba</expr>, <expr>0xbb</expr>, <expr>0xbc</expr>, <expr>0xbd</expr>, <expr>0xbe</expr>, <expr>0xbf</expr>,
<expr>0xc0</expr>, <expr>0xc1</expr>, <expr>0xc2</expr>, <expr>0xc3</expr>, <expr>0xc4</expr>, <expr>0xc5</expr>, <expr>0xc6</expr>, <expr>0xc7</expr>,
<expr>0xc8</expr>, <expr>0xc9</expr>, <expr>0xca</expr>, <expr>0xcb</expr>, <expr>0xcc</expr>, <expr>0xcd</expr>, <expr>0xce</expr>, <expr>0xcf</expr>,
<expr>0xd0</expr>, <expr>0xd1</expr>, <expr>0xd2</expr>, <expr>0xd3</expr>, <expr>0xd4</expr>, <expr>0xd5</expr>, <expr>0xd6</expr>, <expr>0xd7</expr>,
<expr>0xd8</expr>, <expr>0xd9</expr>, <expr>0xda</expr>, <expr>0xdb</expr>, <expr>0xdc</expr>, <expr>0xdd</expr>, <expr>0xde</expr>, <expr>0xdf</expr>,
<expr>0xe0</expr>, <expr>0xe1</expr>, <expr>0xe2</expr>, <expr>0xe3</expr>, <expr>0xe4</expr>, <expr>0xe5</expr>, <expr>0xe6</expr>, <expr>0xe7</expr>,
<expr>0xe8</expr>, <expr>0xe9</expr>, <expr>0xea</expr>, <expr>0xeb</expr>, <expr>0xec</expr>, <expr>0xed</expr>, <expr>0xee</expr>, <expr>0xef</expr>,
<expr>0xf0</expr>, <expr>0xf1</expr>, <expr>0xf2</expr>, <expr>0xf3</expr>, <expr>0xf4</expr>, <expr>0xf5</expr>, <expr>0xf6</expr>, <expr>0xf7</expr>,
<expr>0xf8</expr>, <expr>0xf9</expr>, <expr>0xfa</expr>, <expr>0xfb</expr>, <expr>0xfc</expr>, <expr>0xfd</expr>, <expr>0xfe</expr>, <expr>0xff</expr>,
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name><name>_Py_ctype_toupper</name><index>[<expr>256</expr>]</index></name> <init>= <expr><block>{
<expr>0x00</expr>, <expr>0x01</expr>, <expr>0x02</expr>, <expr>0x03</expr>, <expr>0x04</expr>, <expr>0x05</expr>, <expr>0x06</expr>, <expr>0x07</expr>,
<expr>0x08</expr>, <expr>0x09</expr>, <expr>0x0a</expr>, <expr>0x0b</expr>, <expr>0x0c</expr>, <expr>0x0d</expr>, <expr>0x0e</expr>, <expr>0x0f</expr>,
<expr>0x10</expr>, <expr>0x11</expr>, <expr>0x12</expr>, <expr>0x13</expr>, <expr>0x14</expr>, <expr>0x15</expr>, <expr>0x16</expr>, <expr>0x17</expr>,
<expr>0x18</expr>, <expr>0x19</expr>, <expr>0x1a</expr>, <expr>0x1b</expr>, <expr>0x1c</expr>, <expr>0x1d</expr>, <expr>0x1e</expr>, <expr>0x1f</expr>,
<expr>0x20</expr>, <expr>0x21</expr>, <expr>0x22</expr>, <expr>0x23</expr>, <expr>0x24</expr>, <expr>0x25</expr>, <expr>0x26</expr>, <expr>0x27</expr>,
<expr>0x28</expr>, <expr>0x29</expr>, <expr>0x2a</expr>, <expr>0x2b</expr>, <expr>0x2c</expr>, <expr>0x2d</expr>, <expr>0x2e</expr>, <expr>0x2f</expr>,
<expr>0x30</expr>, <expr>0x31</expr>, <expr>0x32</expr>, <expr>0x33</expr>, <expr>0x34</expr>, <expr>0x35</expr>, <expr>0x36</expr>, <expr>0x37</expr>,
<expr>0x38</expr>, <expr>0x39</expr>, <expr>0x3a</expr>, <expr>0x3b</expr>, <expr>0x3c</expr>, <expr>0x3d</expr>, <expr>0x3e</expr>, <expr>0x3f</expr>,
<expr>0x40</expr>, <expr>0x41</expr>, <expr>0x42</expr>, <expr>0x43</expr>, <expr>0x44</expr>, <expr>0x45</expr>, <expr>0x46</expr>, <expr>0x47</expr>,
<expr>0x48</expr>, <expr>0x49</expr>, <expr>0x4a</expr>, <expr>0x4b</expr>, <expr>0x4c</expr>, <expr>0x4d</expr>, <expr>0x4e</expr>, <expr>0x4f</expr>,
<expr>0x50</expr>, <expr>0x51</expr>, <expr>0x52</expr>, <expr>0x53</expr>, <expr>0x54</expr>, <expr>0x55</expr>, <expr>0x56</expr>, <expr>0x57</expr>,
<expr>0x58</expr>, <expr>0x59</expr>, <expr>0x5a</expr>, <expr>0x5b</expr>, <expr>0x5c</expr>, <expr>0x5d</expr>, <expr>0x5e</expr>, <expr>0x5f</expr>,
<expr>0x60</expr>, <expr>0x41</expr>, <expr>0x42</expr>, <expr>0x43</expr>, <expr>0x44</expr>, <expr>0x45</expr>, <expr>0x46</expr>, <expr>0x47</expr>,
<expr>0x48</expr>, <expr>0x49</expr>, <expr>0x4a</expr>, <expr>0x4b</expr>, <expr>0x4c</expr>, <expr>0x4d</expr>, <expr>0x4e</expr>, <expr>0x4f</expr>,
<expr>0x50</expr>, <expr>0x51</expr>, <expr>0x52</expr>, <expr>0x53</expr>, <expr>0x54</expr>, <expr>0x55</expr>, <expr>0x56</expr>, <expr>0x57</expr>,
<expr>0x58</expr>, <expr>0x59</expr>, <expr>0x5a</expr>, <expr>0x7b</expr>, <expr>0x7c</expr>, <expr>0x7d</expr>, <expr>0x7e</expr>, <expr>0x7f</expr>,
<expr>0x80</expr>, <expr>0x81</expr>, <expr>0x82</expr>, <expr>0x83</expr>, <expr>0x84</expr>, <expr>0x85</expr>, <expr>0x86</expr>, <expr>0x87</expr>,
<expr>0x88</expr>, <expr>0x89</expr>, <expr>0x8a</expr>, <expr>0x8b</expr>, <expr>0x8c</expr>, <expr>0x8d</expr>, <expr>0x8e</expr>, <expr>0x8f</expr>,
<expr>0x90</expr>, <expr>0x91</expr>, <expr>0x92</expr>, <expr>0x93</expr>, <expr>0x94</expr>, <expr>0x95</expr>, <expr>0x96</expr>, <expr>0x97</expr>,
<expr>0x98</expr>, <expr>0x99</expr>, <expr>0x9a</expr>, <expr>0x9b</expr>, <expr>0x9c</expr>, <expr>0x9d</expr>, <expr>0x9e</expr>, <expr>0x9f</expr>,
<expr>0xa0</expr>, <expr>0xa1</expr>, <expr>0xa2</expr>, <expr>0xa3</expr>, <expr>0xa4</expr>, <expr>0xa5</expr>, <expr>0xa6</expr>, <expr>0xa7</expr>,
<expr>0xa8</expr>, <expr>0xa9</expr>, <expr>0xaa</expr>, <expr>0xab</expr>, <expr>0xac</expr>, <expr>0xad</expr>, <expr>0xae</expr>, <expr>0xaf</expr>,
<expr>0xb0</expr>, <expr>0xb1</expr>, <expr>0xb2</expr>, <expr>0xb3</expr>, <expr>0xb4</expr>, <expr>0xb5</expr>, <expr>0xb6</expr>, <expr>0xb7</expr>,
<expr>0xb8</expr>, <expr>0xb9</expr>, <expr>0xba</expr>, <expr>0xbb</expr>, <expr>0xbc</expr>, <expr>0xbd</expr>, <expr>0xbe</expr>, <expr>0xbf</expr>,
<expr>0xc0</expr>, <expr>0xc1</expr>, <expr>0xc2</expr>, <expr>0xc3</expr>, <expr>0xc4</expr>, <expr>0xc5</expr>, <expr>0xc6</expr>, <expr>0xc7</expr>,
<expr>0xc8</expr>, <expr>0xc9</expr>, <expr>0xca</expr>, <expr>0xcb</expr>, <expr>0xcc</expr>, <expr>0xcd</expr>, <expr>0xce</expr>, <expr>0xcf</expr>,
<expr>0xd0</expr>, <expr>0xd1</expr>, <expr>0xd2</expr>, <expr>0xd3</expr>, <expr>0xd4</expr>, <expr>0xd5</expr>, <expr>0xd6</expr>, <expr>0xd7</expr>,
<expr>0xd8</expr>, <expr>0xd9</expr>, <expr>0xda</expr>, <expr>0xdb</expr>, <expr>0xdc</expr>, <expr>0xdd</expr>, <expr>0xde</expr>, <expr>0xdf</expr>,
<expr>0xe0</expr>, <expr>0xe1</expr>, <expr>0xe2</expr>, <expr>0xe3</expr>, <expr>0xe4</expr>, <expr>0xe5</expr>, <expr>0xe6</expr>, <expr>0xe7</expr>,
<expr>0xe8</expr>, <expr>0xe9</expr>, <expr>0xea</expr>, <expr>0xeb</expr>, <expr>0xec</expr>, <expr>0xed</expr>, <expr>0xee</expr>, <expr>0xef</expr>,
<expr>0xf0</expr>, <expr>0xf1</expr>, <expr>0xf2</expr>, <expr>0xf3</expr>, <expr>0xf4</expr>, <expr>0xf5</expr>, <expr>0xf6</expr>, <expr>0xf7</expr>,
<expr>0xf8</expr>, <expr>0xf9</expr>, <expr>0xfa</expr>, <expr>0xfb</expr>, <expr>0xfc</expr>, <expr>0xfd</expr>, <expr>0xfe</expr>, <expr>0xff</expr>,
}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PyDoc_STRVAR_shared</name><argument_list>(<argument><expr><name>_Py_isspace__doc__</name></expr></argument>,
<argument><expr>"B.isspace() -&gt; bool\n\
\n\
Return True if all characters in B are whitespace\n\
and there is at least one character in B, False otherwise."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><name>PyObject</name>*</type>
<name>_Py_bytes_isspace</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>cptr</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>p</name>
<init>= <expr>(<name>unsigned</name> <name>char</name> *) <name>cptr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>e</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>len</name> == 1 &amp;&amp; <call><name>ISSPACE</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>Py_RETURN_TRUE</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>len</name> == 0</expr>)</condition><then>
<expr_stmt><expr><name>Py_RETURN_FALSE</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>e</name> = <name>p</name> + <name>len</name></expr>;</expr_stmt>
<for>for (<init>;</init> <condition><expr><name>p</name> &lt; <name>e</name></expr>;</condition> <incr><expr><name>p</name>++</expr></incr>) <block>{
<if>if <condition>(<expr>!<call><name>ISSPACE</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>Py_RETURN_FALSE</name></expr>;</expr_stmt></then></if>
}</block></for>
<expr_stmt><expr><name>Py_RETURN_TRUE</name></expr>;</expr_stmt>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR_shared</name><argument_list>(<argument><expr><name>_Py_isalpha__doc__</name></expr></argument>,
<argument><expr>"B.isalpha() -&gt; bool\n\
\n\
Return True if all characters in B are alphabetic\n\
and there is at least one character in B, False otherwise."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><name>PyObject</name>*</type>
<name>_Py_bytes_isalpha</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>cptr</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>p</name>
<init>= <expr>(<name>unsigned</name> <name>char</name> *) <name>cptr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>e</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>len</name> == 1 &amp;&amp; <call><name>ISALPHA</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>Py_RETURN_TRUE</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>len</name> == 0</expr>)</condition><then>
<expr_stmt><expr><name>Py_RETURN_FALSE</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>e</name> = <name>p</name> + <name>len</name></expr>;</expr_stmt>
<for>for (<init>;</init> <condition><expr><name>p</name> &lt; <name>e</name></expr>;</condition> <incr><expr><name>p</name>++</expr></incr>) <block>{
<if>if <condition>(<expr>!<call><name>ISALPHA</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>Py_RETURN_FALSE</name></expr>;</expr_stmt></then></if>
}</block></for>
<expr_stmt><expr><name>Py_RETURN_TRUE</name></expr>;</expr_stmt>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR_shared</name><argument_list>(<argument><expr><name>_Py_isalnum__doc__</name></expr></argument>,
<argument><expr>"B.isalnum() -&gt; bool\n\
\n\
Return True if all characters in B are alphanumeric\n\
and there is at least one character in B, False otherwise."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><name>PyObject</name>*</type>
<name>_Py_bytes_isalnum</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>cptr</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>p</name>
<init>= <expr>(<name>unsigned</name> <name>char</name> *) <name>cptr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>e</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>len</name> == 1 &amp;&amp; <call><name>ISALNUM</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>Py_RETURN_TRUE</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>len</name> == 0</expr>)</condition><then>
<expr_stmt><expr><name>Py_RETURN_FALSE</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>e</name> = <name>p</name> + <name>len</name></expr>;</expr_stmt>
<for>for (<init>;</init> <condition><expr><name>p</name> &lt; <name>e</name></expr>;</condition> <incr><expr><name>p</name>++</expr></incr>) <block>{
<if>if <condition>(<expr>!<call><name>ISALNUM</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>Py_RETURN_FALSE</name></expr>;</expr_stmt></then></if>
}</block></for>
<expr_stmt><expr><name>Py_RETURN_TRUE</name></expr>;</expr_stmt>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR_shared</name><argument_list>(<argument><expr><name>_Py_isdigit__doc__</name></expr></argument>,
<argument><expr>"B.isdigit() -&gt; bool\n\
\n\
Return True if all characters in B are digits\n\
and there is at least one character in B, False otherwise."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><name>PyObject</name>*</type>
<name>_Py_bytes_isdigit</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>cptr</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>p</name>
<init>= <expr>(<name>unsigned</name> <name>char</name> *) <name>cptr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>e</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>len</name> == 1 &amp;&amp; <call><name>ISDIGIT</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>Py_RETURN_TRUE</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>len</name> == 0</expr>)</condition><then>
<expr_stmt><expr><name>Py_RETURN_FALSE</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>e</name> = <name>p</name> + <name>len</name></expr>;</expr_stmt>
<for>for (<init>;</init> <condition><expr><name>p</name> &lt; <name>e</name></expr>;</condition> <incr><expr><name>p</name>++</expr></incr>) <block>{
<if>if <condition>(<expr>!<call><name>ISDIGIT</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>Py_RETURN_FALSE</name></expr>;</expr_stmt></then></if>
}</block></for>
<expr_stmt><expr><name>Py_RETURN_TRUE</name></expr>;</expr_stmt>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR_shared</name><argument_list>(<argument><expr><name>_Py_islower__doc__</name></expr></argument>,
<argument><expr>"B.islower() -&gt; bool\n\
\n\
Return True if all cased characters in B are lowercase and there is\n\
at least one cased character in B, False otherwise."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><name>PyObject</name>*</type>
<name>_Py_bytes_islower</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>cptr</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>p</name>
<init>= <expr>(<name>unsigned</name> <name>char</name> *) <name>cptr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>e</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>cased</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>len</name> == 1</expr>)</condition><then>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><call><name>ISLOWER</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><name>len</name> == 0</expr>)</condition><then>
<expr_stmt><expr><name>Py_RETURN_FALSE</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>e</name> = <name>p</name> + <name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><name>cased</name> = 0</expr>;</expr_stmt>
<for>for (<init>;</init> <condition><expr><name>p</name> &lt; <name>e</name></expr>;</condition> <incr><expr><name>p</name>++</expr></incr>) <block>{
<if>if <condition>(<expr><call><name>ISUPPER</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>Py_RETURN_FALSE</name></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr>!<name>cased</name> &amp;&amp; <call><name>ISLOWER</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>cased</name> = 1</expr>;</expr_stmt></then></if></else></if>
}</block></for>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><name>cased</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR_shared</name><argument_list>(<argument><expr><name>_Py_isupper__doc__</name></expr></argument>,
<argument><expr>"B.isupper() -&gt; bool\n\
\n\
Return True if all cased characters in B are uppercase and there is\n\
at least one cased character in B, False otherwise."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><name>PyObject</name>*</type>
<name>_Py_bytes_isupper</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>cptr</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>p</name>
<init>= <expr>(<name>unsigned</name> <name>char</name> *) <name>cptr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>e</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>cased</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>len</name> == 1</expr>)</condition><then>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><call><name>ISUPPER</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><name>len</name> == 0</expr>)</condition><then>
<expr_stmt><expr><name>Py_RETURN_FALSE</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>e</name> = <name>p</name> + <name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><name>cased</name> = 0</expr>;</expr_stmt>
<for>for (<init>;</init> <condition><expr><name>p</name> &lt; <name>e</name></expr>;</condition> <incr><expr><name>p</name>++</expr></incr>) <block>{
<if>if <condition>(<expr><call><name>ISLOWER</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>Py_RETURN_FALSE</name></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr>!<name>cased</name> &amp;&amp; <call><name>ISUPPER</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>cased</name> = 1</expr>;</expr_stmt></then></if></else></if>
}</block></for>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><name>cased</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR_shared</name><argument_list>(<argument><expr><name>_Py_istitle__doc__</name></expr></argument>,
<argument><expr>"B.istitle() -&gt; bool\n\
\n\
Return True if B is a titlecased string and there is at least one\n\
character in B, i.e. uppercase characters may only follow uncased\n\
characters and lowercase characters only cased ones. Return False\n\
otherwise."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><name>PyObject</name>*</type>
<name>_Py_bytes_istitle</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>cptr</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>p</name>
<init>= <expr>(<name>unsigned</name> <name>char</name> *) <name>cptr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>e</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>cased</name></decl>, <decl><type ref="prev"/><name>previous_is_cased</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>len</name> == 1</expr>)</condition><then>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><call><name>ISUPPER</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><name>len</name> == 0</expr>)</condition><then>
<expr_stmt><expr><name>Py_RETURN_FALSE</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>e</name> = <name>p</name> + <name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><name>cased</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>previous_is_cased</name> = 0</expr>;</expr_stmt>
<for>for (<init>;</init> <condition><expr><name>p</name> &lt; <name>e</name></expr>;</condition> <incr><expr><name>p</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name>ch</name> <init>= <expr>*<name>p</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>ISUPPER</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>previous_is_cased</name></expr>)</condition><then>
<expr_stmt><expr><name>Py_RETURN_FALSE</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>previous_is_cased</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name>cased</name> = 1</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><call><name>ISLOWER</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<name>previous_is_cased</name></expr>)</condition><then>
<expr_stmt><expr><name>Py_RETURN_FALSE</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>previous_is_cased</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name>cased</name> = 1</expr>;</expr_stmt>
}</block></then> <else>else
<expr_stmt><expr><name>previous_is_cased</name> = 0</expr>;</expr_stmt></else></if></else></if>
}</block></for>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><name>cased</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR_shared</name><argument_list>(<argument><expr><name>_Py_lower__doc__</name></expr></argument>,
<argument><expr>"B.lower() -&gt; copy of B\n\
\n\
Return a copy of B with all ASCII characters converted to lowercase."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><name>void</name></type>
<name>_Py_bytes_lower</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>result</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>cptr</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>Py_MEMCPY</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>cptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr><name><name>result</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>ISUPPER</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name><name>result</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name>TOLOWER</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></for>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR_shared</name><argument_list>(<argument><expr><name>_Py_upper__doc__</name></expr></argument>,
<argument><expr>"B.upper() -&gt; copy of B\n\
\n\
Return a copy of B with all ASCII characters converted to uppercase."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><name>void</name></type>
<name>_Py_bytes_upper</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>result</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>cptr</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>Py_MEMCPY</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>cptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr><name><name>result</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>ISLOWER</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name><name>result</name><index>[<expr><name>i</name></expr>]</index></name> = <call><name>TOUPPER</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></for>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR_shared</name><argument_list>(<argument><expr><name>_Py_title__doc__</name></expr></argument>,
<argument><expr>"B.title() -&gt; copy of B\n\
\n\
Return a titlecased version of B, i.e. ASCII words start with uppercase\n\
characters, all remaining cased characters have lowercase."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><name>void</name></type>
<name>_Py_bytes_title</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>result</name></decl></param>, <param><decl><type><name>char</name> *</type><name>s</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>previous_is_cased</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>s</name>++</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>ISLOWER</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<name>previous_is_cased</name></expr>)</condition><then>
<expr_stmt><expr><name>c</name> = <call><name>TOUPPER</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>previous_is_cased</name> = 1</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><call><name>ISUPPER</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>previous_is_cased</name></expr>)</condition><then>
<expr_stmt><expr><name>c</name> = <call><name>TOLOWER</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>previous_is_cased</name> = 1</expr>;</expr_stmt>
}</block></then> <else>else
<expr_stmt><expr><name>previous_is_cased</name> = 0</expr>;</expr_stmt></else></if></else></if>
<expr_stmt><expr>*<name>result</name>++ = <name>c</name></expr>;</expr_stmt>
}</block></for>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR_shared</name><argument_list>(<argument><expr><name>_Py_capitalize__doc__</name></expr></argument>,
<argument><expr>"B.capitalize() -&gt; copy of B\n\
\n\
Return a copy of B with only its first character capitalized (ASCII)."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><name>void</name></type>
<name>_Py_bytes_capitalize</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>result</name></decl></param>, <param><decl><type><name>char</name> *</type><name>s</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<if>if <condition>(<expr>0 &lt; <name>len</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>s</name>++</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>ISLOWER</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr>*<name>result</name> = <call><name>TOUPPER</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr>*<name>result</name> = <name>c</name></expr>;</expr_stmt></else></if>
<expr_stmt><expr><name>result</name>++</expr>;</expr_stmt>
}</block></then></if>
<for>for (<init><expr><name>i</name> = 1</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>s</name>++</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>ISUPPER</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr>*<name>result</name> = <call><name>TOLOWER</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr>*<name>result</name> = <name>c</name></expr>;</expr_stmt></else></if>
<expr_stmt><expr><name>result</name>++</expr>;</expr_stmt>
}</block></for>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR_shared</name><argument_list>(<argument><expr><name>_Py_swapcase__doc__</name></expr></argument>,
<argument><expr>"B.swapcase() -&gt; copy of B\n\
\n\
Return a copy of B with uppercase ASCII characters converted\n\
to lowercase ASCII and vice versa."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><name>void</name></type>
<name>_Py_bytes_swapcase</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>result</name></decl></param>, <param><decl><type><name>char</name> *</type><name>s</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>int</name></type> <name>c</name> <init>= <expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>s</name>++</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>ISLOWER</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>result</name> = <call><name>TOUPPER</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><call><name>ISUPPER</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>result</name> = <call><name>TOLOWER</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else
<expr_stmt><expr>*<name>result</name> = <name>c</name></expr>;</expr_stmt></else></if></else></if>
<expr_stmt><expr><name>result</name>++</expr>;</expr_stmt>
}</block></for>
}</block></function>
</unit>
