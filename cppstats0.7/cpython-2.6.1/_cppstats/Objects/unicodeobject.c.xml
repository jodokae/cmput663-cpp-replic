<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="Objects/unicodeobject.c"><cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PY_SSIZE_T_CLEAN</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"Python.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"unicodeobject.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ucnhash.h"</cpp:file></cpp:include>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;windows.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PyUnicode_MAXFREELIST</name></cpp:macro> <cpp:value>1024</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>KEEPALIVE_SIZE_LIMIT</name></cpp:macro> <cpp:value>9</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WORDS_BIGENDIAN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BYTEORDER_IS_BIG_ENDIAN</name></cpp:macro></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BYTEORDER_IS_LITTLE_ENDIAN</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call></expr></cpp:if>
<extern>extern "C" <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyUnicodeObject</name> *</type><name>free_list</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>numfree</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyUnicodeObject</name> *</type><name>unicode_empty</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyUnicodeObject</name> *</type><name><name>unicode_latin1</name><index>[<expr>256</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>unicode_default_encoding</name><index>[<expr>100</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name></type> <name><name>_Py_ascii_whitespace</name><index>[]</index></name> <init>= <expr><block>{
<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
<expr>0</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>0</expr>, <expr>0</expr>,
<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
<expr>1</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>char</name></type> <name><name>ascii_linebreak</name><index>[]</index></name> <init>= <expr><block>{
<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
<expr>0</expr>, <expr>0</expr>, <expr>1</expr>, <expr>0</expr>, <expr>0</expr>, <expr>1</expr>, <expr>0</expr>, <expr>0</expr>,
<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>0</expr>,
<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>
}</block></expr></init></decl>;</decl_stmt>
<function><type><name>Py_UNICODE</name></type>
<name>PyUnicode_GetMax</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_UNICODE_WIDE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<return>return <expr>0x10FFFF</expr>;</return>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<return>return <expr>0xFFFF</expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BLOOM_MASK</name></cpp:macro> <cpp:value>unsigned long</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <name>BLOOM_MASK</name></type> <name>bloom_linebreak</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BLOOM</name><parameter_list>(<param><type><name>mask</name></type></param>, <param><type><name>ch</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((mask &amp; (1 &lt;&lt; ((ch) &amp; 0x1F))))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BLOOM_LINEBREAK</name><parameter_list>(<param><type><name>ch</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((ch) &lt; 128U ? ascii_linebreak[(ch)] : (BLOOM(bloom_linebreak, (ch)) &amp;&amp; Py_UNICODE_ISLINEBREAK(ch)))</cpp:value></cpp:define>
<macro><name>Py_LOCAL_INLINE</name><argument_list>(<argument>BLOOM_MASK</argument>)</argument_list></macro> <macro><name>make_bloom_mask</name><argument_list>(<argument>Py_UNICODE* ptr</argument>, <argument>Py_ssize_t len</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>long</name></type> <name>mask</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><name>mask</name> = 0</expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
<expr_stmt><expr><name>mask</name> |= (1 &lt;&lt; (<name><name>ptr</name><index>[<expr><name>i</name></expr>]</index></name> &amp; 0x1F))</expr>;</expr_stmt></for>
<return>return <expr><name>mask</name></expr>;</return>
}</block>
<macro><name>Py_LOCAL_INLINE</name><argument_list>(<argument>int</argument>)</argument_list></macro> <macro><name>unicode_member</name><argument_list>(<argument>Py_UNICODE chr</argument>, <argument>Py_UNICODE* set</argument>, <argument>Py_ssize_t setlen</argument>)</argument_list></macro> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>setlen</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
<if>if <condition>(<expr><name><name>set</name><index>[<expr><name>i</name></expr>]</index></name> == <name>chr</name></expr>)</condition><then>
<return>return <expr>1</expr>;</return></then></if></for>
<return>return <expr>0</expr>;</return>
}</block>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BLOOM_MEMBER</name><parameter_list>(<param><type><name>mask</name></type></param>, <param><type><name>chr</name></type></param>, <param><type><name>set</name></type></param>, <param><type><name>setlen</name></type></param>)</parameter_list></cpp:macro><cpp:value>BLOOM(mask, chr) &amp;&amp; unicode_member(chr, set, setlen)</cpp:value></cpp:define>
<function><type><specifier>static</specifier>
<name>int</name></type> <name>unicode_resize</name><parameter_list>(<param><decl><type><name>register</name> <name>PyUnicodeObject</name> *</type><name>unicode</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>length</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>void</name> *</type><name>oldstr</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>unicode</name>-&gt;<name>length</name></name> == <name>length</name></expr>)</condition><then>
<goto>goto <name>reset</name>;</goto></then></if>
<if>if <condition>(<expr><name>unicode</name> == <name>unicode_empty</name> ||
(<name><name>unicode</name>-&gt;<name>length</name></name> == 1 &amp;&amp;
<name><name>unicode</name>-&gt;<name>str</name><index>[<expr>0</expr>]</index></name> &lt; 256U &amp;&amp;
<name><name>unicode_latin1</name><index>[<expr><name><name>unicode</name>-&gt;<name>str</name><index>[<expr>0</expr>]</index></name></expr>]</index></name> == <name>unicode</name>)</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
<argument><expr>"can't resize shared unicode objects"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>oldstr</name> = <name><name>unicode</name>-&gt;<name>str</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>unicode</name>-&gt;<name>str</name></name> = <call><name>PyObject_REALLOC</name><argument_list>(<argument><expr><name><name>unicode</name>-&gt;<name>str</name></name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Py_UNICODE</name></expr></argument>)</argument_list></sizeof> * (<name>length</name> + 1)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name><name>unicode</name>-&gt;<name>str</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>unicode</name>-&gt;<name>str</name></name> = (<name>Py_UNICODE</name> *)<name>oldstr</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>unicode</name>-&gt;<name>str</name><index>[<expr><name>length</name></expr>]</index></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>unicode</name>-&gt;<name>length</name></name> = <name>length</name></expr>;</expr_stmt>
<label><name>reset</name>:</label>
<if>if <condition>(<expr><name><name>unicode</name>-&gt;<name>defenc</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name><name>unicode</name>-&gt;<name>defenc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>unicode</name>-&gt;<name>defenc</name></name> = <name>NULL</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name><name>unicode</name>-&gt;<name>hash</name></name> = -1</expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier>
<name>PyUnicodeObject</name> *</type><name>_PyUnicode_New</name><parameter_list>(<param><decl><type><name>Py_ssize_t</name></type> <name>length</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>register</name> <name>PyUnicodeObject</name> *</type><name>unicode</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>length</name> == 0 &amp;&amp; <name>unicode_empty</name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>unicode_empty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>unicode_empty</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>length</name> &gt; ((<name>PY_SSIZE_T_MAX</name> / <sizeof>sizeof<argument_list>(<argument><expr><name>Py_UNICODE</name></expr></argument>)</argument_list></sizeof>) - 1)</expr>)</condition><then> <block>{
<return>return <expr>(<name>PyUnicodeObject</name> *)<call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>free_list</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>unicode</name> = <name>free_list</name></expr>;</expr_stmt>
<expr_stmt><expr><name>free_list</name> = *(<name>PyUnicodeObject</name> **)<name>unicode</name></expr>;</expr_stmt>
<expr_stmt><expr><name>numfree</name>--</expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>unicode</name>-&gt;<name>str</name></name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>(<name><name>unicode</name>-&gt;<name>length</name></name> &lt; <name>length</name>) &amp;&amp;
<call><name>unicode_resize</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyObject_DEL</name><argument_list>(<argument><expr><name><name>unicode</name>-&gt;<name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>unicode</name>-&gt;<name>str</name></name> = <name>NULL</name></expr>;</expr_stmt>
}</block></then></if>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>size_t</name></type> <name>new_size</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>Py_UNICODE</name></expr></argument>)</argument_list></sizeof> * ((<name>size_t</name>)<name>length</name> + 1)</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>unicode</name>-&gt;<name>str</name></name> = (<name>Py_UNICODE</name>*) <call><name>PyObject_MALLOC</name><argument_list>(<argument><expr><name>new_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><call><name>PyObject_INIT</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>, <argument><expr>&amp;<name>PyUnicode_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>size_t</name></type> <name>new_size</name></decl>;</decl_stmt>
<expr_stmt><expr><name>unicode</name> = <call><name>PyObject_New</name><argument_list>(<argument><expr><name>PyUnicodeObject</name></expr></argument>, <argument><expr>&amp;<name>PyUnicode_Type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>unicode</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>new_size</name> = <sizeof>sizeof<argument_list>(<argument><expr><name>Py_UNICODE</name></expr></argument>)</argument_list></sizeof> * ((<name>size_t</name>)<name>length</name> + 1)</expr>;</expr_stmt>
<expr_stmt><expr><name><name>unicode</name>-&gt;<name>str</name></name> = (<name>Py_UNICODE</name>*) <call><name>PyObject_MALLOC</name><argument_list>(<argument><expr><name>new_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<if>if <condition>(<expr>!<name><name>unicode</name>-&gt;<name>str</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>onError</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name><name>unicode</name>-&gt;<name>str</name><index>[<expr>0</expr>]</index></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>unicode</name>-&gt;<name>str</name><index>[<expr><name>length</name></expr>]</index></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>unicode</name>-&gt;<name>length</name></name> = <name>length</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>unicode</name>-&gt;<name>hash</name></name> = -1</expr>;</expr_stmt>
<expr_stmt><expr><name><name>unicode</name>-&gt;<name>defenc</name></name> = <name>NULL</name></expr>;</expr_stmt>
<return>return <expr><name>unicode</name></expr>;</return>
<label><name>onError</name>:</label>
<expr_stmt><expr><name>_Py_DEC_REFTOTAL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>_Py_ForgetReference</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>unicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyObject_Del</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier>
<name>void</name></type> <name>unicode_dealloc</name><parameter_list>(<param><decl><type><name>register</name> <name>PyUnicodeObject</name> *</type><name>unicode</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><call><name>PyUnicode_CheckExact</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call> &amp;&amp;
<name>numfree</name> &lt; <name>PyUnicode_MAXFREELIST</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>unicode</name>-&gt;<name>length</name></name> &gt;= <name>KEEPALIVE_SIZE_LIMIT</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyObject_DEL</name><argument_list>(<argument><expr><name><name>unicode</name>-&gt;<name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>unicode</name>-&gt;<name>str</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>unicode</name>-&gt;<name>length</name></name> = 0</expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name><name>unicode</name>-&gt;<name>defenc</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name><name>unicode</name>-&gt;<name>defenc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>unicode</name>-&gt;<name>defenc</name></name> = <name>NULL</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr>*(<name>PyUnicodeObject</name> **)<name>unicode</name> = <name>free_list</name></expr>;</expr_stmt>
<expr_stmt><expr><name>free_list</name> = <name>unicode</name></expr>;</expr_stmt>
<expr_stmt><expr><name>numfree</name>++</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>PyObject_DEL</name><argument_list>(<argument><expr><name><name>unicode</name>-&gt;<name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>unicode</name>-&gt;<name>defenc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call>-&gt;<call><name>tp_free</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>unicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
}</block></function>
<function><type><name>int</name></type> <name>PyUnicode_Resize</name><parameter_list>(<param><decl><type><name>PyObject</name> **</type><name>unicode</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>length</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>register</name> <name>PyUnicodeObject</name> *</type><name>v</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>unicode</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>v</name> = (<name>PyUnicodeObject</name> *)*<name>unicode</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name> || !<call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> || <call><name>Py_REFCNT</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> != 1 || <name>length</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name><name>v</name>-&gt;<name>length</name></name> != <name>length</name> &amp;&amp;
(<name>v</name> == <name>unicode_empty</name> || <name><name>v</name>-&gt;<name>length</name></name> == 1)</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>w</name> <init>= <expr><call><name>_PyUnicode_New</name><argument_list>(<argument><expr><name>length</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>w</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><call><name>Py_UNICODE_COPY</name><argument_list>(<argument><expr><name><name>w</name>-&gt;<name>str</name></name></expr></argument>, <argument><expr><name><name>v</name>-&gt;<name>str</name></name></expr></argument>,
<argument><expr><name>length</name> &lt; <name><name>v</name>-&gt;<name>length</name></name> ? <name>length</name> : <name><name>v</name>-&gt;<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr>*<name>unicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>unicode</name> = (<name>PyObject</name> *)<name>w</name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<return>return <expr><call><name>unicode_resize</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_PyUnicode_Resize</name><parameter_list>(<param><type><name>unicodevar</name></type></param>, <param><type><name>length</name></type></param>)</parameter_list></cpp:macro> <cpp:value>PyUnicode_Resize(((PyObject **)(unicodevar)), length)</cpp:value></cpp:define>
<function><type><name>PyObject</name> *</type><name>PyUnicode_FromUnicode</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>u</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>unicode</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>u</name> != <name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>size</name> == 0 &amp;&amp; <name>unicode_empty</name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>unicode_empty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *)<name>unicode_empty</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>size</name> == 1 &amp;&amp; *<name>u</name> &lt; 256</expr>)</condition><then> <block>{
<expr_stmt><expr><name>unicode</name> = <name><name>unicode_latin1</name><index>[<expr>*<name>u</name></expr>]</index></name></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>unicode</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>unicode</name> = <call><name>_PyUnicode_New</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>unicode</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>unicode</name>-&gt;<name>str</name><index>[<expr>0</expr>]</index></name> = *<name>u</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>unicode_latin1</name><index>[<expr>*<name>u</name></expr>]</index></name> = <name>unicode</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *)<name>unicode</name></expr>;</return>
}</block></then></if>
}</block></then></if>
<expr_stmt><expr><name>unicode</name> = <call><name>_PyUnicode_New</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>unicode</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>u</name> != <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>Py_UNICODE_COPY</name><argument_list>(<argument><expr><name><name>unicode</name>-&gt;<name>str</name></name></expr></argument>, <argument><expr><name>u</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr>(<name>PyObject</name> *)<name>unicode</name></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type><name>PyUnicode_FromStringAndSize</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>u</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>unicode</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>size</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
<argument><expr>"Negative size passed to PyUnicode_FromStringAndSize"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>u</name> != <name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>size</name> == 0 &amp;&amp; <name>unicode_empty</name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>unicode_empty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *)<name>unicode_empty</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>size</name> == 1 &amp;&amp; <call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>u</name></expr></argument>)</argument_list></call> &lt; 128</expr>)</condition><then> <block>{
<expr_stmt><expr><name>unicode</name> = <name><name>unicode_latin1</name><index>[<expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>u</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>unicode</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>unicode</name> = <call><name>_PyUnicode_New</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>unicode</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name><name>unicode</name>-&gt;<name>str</name><index>[<expr>0</expr>]</index></name> = <call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>unicode_latin1</name><index>[<expr><call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>u</name></expr></argument>)</argument_list></call></expr>]</index></name> = <name>unicode</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *)<name>unicode</name></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>PyUnicode_DecodeUTF8</name><argument_list>(<argument><expr><name>u</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>unicode</name> = <call><name>_PyUnicode_New</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>unicode</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr>(<name>PyObject</name> *)<name>unicode</name></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type><name>PyUnicode_FromString</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>u</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>size_t</name></type> <name>size</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>size</name> &gt; <name>PY_SSIZE_T_MAX</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>, <argument><expr>"input too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>PyUnicode_FromStringAndSize</name><argument_list>(<argument><expr><name>u</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_WCHAR_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><name>PyObject</name> *</type><name>PyUnicode_FromWideChar</name><parameter_list>(<param><decl><type><name>register</name> <specifier>const</specifier> <name>wchar_t</name> *</type><name>w</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>unicode</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>w</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>unicode</name> = <call><name>_PyUnicode_New</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>unicode</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_USABLE_WCHAR_T</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>unicode</name>-&gt;<name>str</name></name></expr></argument>, <argument><expr><name>w</name></expr></argument>, <argument><expr><name>size</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>wchar_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<block>{
<decl_stmt><decl><type><name>register</name> <name>Py_UNICODE</name> *</type><name>u</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><name>u</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = <name>size</name></expr>;</init> <condition><expr><name>i</name> &gt; 0</expr>;</condition> <incr><expr><name>i</name>--</expr></incr>)
<expr_stmt><expr>*<name>u</name>++ = *<name>w</name>++</expr>;</expr_stmt></for>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr>(<name>PyObject</name> *)<name>unicode</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>makefmt</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>fmt</name></decl></param>, <param><decl><type><name>int</name></type> <name>longflag</name></decl></param>, <param><decl><type><name>int</name></type> <name>size_tflag</name></decl></param>, <param><decl><type><name>int</name></type> <name>zeropad</name></decl></param>, <param><decl><type><name>int</name></type> <name>width</name></decl></param>, <param><decl><type><name>int</name></type> <name>precision</name></decl></param>, <param><decl><type><name>char</name></type> <name>c</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr>*<name>fmt</name>++ = '%'</expr>;</expr_stmt>
<if>if <condition>(<expr><name>width</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>zeropad</name></expr>)</condition><then>
<expr_stmt><expr>*<name>fmt</name>++ = '0'</expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>fmt</name> += <call><name>sprintf</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>, <argument><expr>"%d"</expr></argument>, <argument><expr><name>width</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>precision</name></expr>)</condition><then>
<expr_stmt><expr><name>fmt</name> += <call><name>sprintf</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>, <argument><expr>".%d"</expr></argument>, <argument><expr><name>precision</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>longflag</name></expr>)</condition><then>
<expr_stmt><expr>*<name>fmt</name>++ = 'l'</expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name>size_tflag</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>f</name> <init>= <expr><name>PY_FORMAT_SIZE_T</name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr>*<name>f</name></expr>)</condition>
<expr_stmt><expr>*<name>fmt</name>++ = *<name>f</name>++</expr>;</expr_stmt></while>
}</block></then></if></else></if>
<expr_stmt><expr>*<name>fmt</name>++ = <name>c</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>fmt</name> = '\0'</expr>;</expr_stmt>
}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>appendstring</name><parameter_list>(<param><type><name>string</name></type></param>)</parameter_list></cpp:macro> <cpp:value>{for (copy = string;*copy;) *s++ = *copy++;}</cpp:value></cpp:define>
<function><type><name>PyObject</name> *</type>
<name>PyUnicode_FromFormatV</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>format</name></decl></param>, <param><decl><type><name>va_list</name></type> <name>vargs</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>va_list</name></type> <name>count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>callcount</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> **</type><name>callresults</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> **</type><name>callresult</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>width</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>precision</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>zeropad</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>f</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>string</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr>21</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>abuffer</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>realbuffer</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>abuffersize</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>fmt</name><index>[<expr>60</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copy</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>VA_LIST_IS_ARRAY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>Py_MEMCPY</name><argument_list>(<argument><expr><name>count</name></expr></argument>, <argument><expr><name>vargs</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>va_list</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__va_copy</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>__va_copy</name><argument_list>(<argument><expr><name>count</name></expr></argument>, <argument><expr><name>vargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>count</name> = <name>vargs</name></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<for>for (<init><expr><name>f</name> = <name>format</name></expr>;</init> <condition><expr>*<name>f</name></expr>;</condition> <incr><expr><name>f</name>++</expr></incr>) <block>{
<if>if <condition>(<expr>*<name>f</name> == '%' &amp;&amp; (*(<name>f</name>+1)=='S' || *(<name>f</name>+1)=='R')</expr>)</condition><then>
<expr_stmt><expr>++<name>callcount</name></expr>;</expr_stmt></then></if>
}</block></for>
<if>if <condition>(<expr><name>callcount</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>callresults</name> = <call><name>PyObject_Malloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PyObject</name> *</expr></argument>)</argument_list></sizeof>*<name>callcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>callresults</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>callresult</name> = <name>callresults</name></expr>;</expr_stmt>
}</block></then></if>
<for>for (<init><expr><name>f</name> = <name>format</name></expr>;</init> <condition><expr>*<name>f</name></expr>;</condition> <incr><expr><name>f</name>++</expr></incr>) <block>{
<if>if <condition>(<expr>*<name>f</name> == '%'</expr>)</condition><then> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>p</name> <init>= <expr><name>f</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>width</name> = 0</expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr>(<name>unsigned</name>)*<name>f</name></expr></argument>)</argument_list></call></expr>)</condition>
<expr_stmt><expr><name>width</name> = (<name>width</name>*10) + *<name>f</name>++ - '0'</expr>;</expr_stmt></while>
<while>while <condition>(<expr>*++<name>f</name> &amp;&amp; *<name>f</name> != '%' &amp;&amp; !<call><name>isalpha</name><argument_list>(<argument><expr>(<name>unsigned</name>)*<name>f</name></expr></argument>)</argument_list></call></expr>)</condition>
<empty_stmt>;</empty_stmt></while>
<if>if <condition>(<expr>(*<name>f</name> == 'l' || *<name>f</name> == 'z') &amp;&amp;
(<name><name>f</name><index>[<expr>1</expr>]</index></name> == 'd' || <name><name>f</name><index>[<expr>1</expr>]</index></name> == 'u')</expr>)</condition><then>
<expr_stmt><expr>++<name>f</name></expr>;</expr_stmt></then></if>
<switch>switch <condition>(<expr>*<name>f</name></expr>)</condition> <block>{
<case>case <expr>'c'</expr>:
<expr_stmt><expr>(<name>void</name>)<call><name>va_arg</name><argument_list>(<argument><expr><name>count</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</case><case>case <expr>'%'</expr>:
<expr_stmt><expr><name>n</name>++</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'d'</expr>:
</case><case>case <expr>'u'</expr>:
</case><case>case <expr>'i'</expr>:
</case><case>case <expr>'x'</expr>:
<expr_stmt><expr>(<name>void</name>) <call><name>va_arg</name><argument_list>(<argument><expr><name>count</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>width</name> &lt; 20</expr>)</condition><then>
<expr_stmt><expr><name>width</name> = 20</expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>n</name> += <name>width</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>abuffersize</name> &lt; <name>width</name></expr>)</condition><then>
<expr_stmt><expr><name>abuffersize</name> = <name>width</name></expr>;</expr_stmt></then></if>
<break>break;</break>
</case><case>case <expr>'s'</expr>: <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>char</name>*</type><name>s</name></decl>;</decl_stmt>
<expr_stmt><expr><name>s</name> = <macro><name>va_arg</name><argument_list>(<argument>count</argument>, <argument>unsigned char*</argument>)</argument_list></macro></expr>;</expr_stmt>
<while>while <condition>(<expr>*<name>s</name></expr>)</condition> <block>{
<if>if <condition>(<expr>*<name>s</name> &lt; 128</expr>)</condition><then> <block>{
<expr_stmt><expr><name>n</name>++</expr>;</expr_stmt>
<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr>*<name>s</name> &lt; 0xc0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>n</name>++</expr>;</expr_stmt>
<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr>*<name>s</name> &lt; 0xc0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>n</name>++</expr>;</expr_stmt>
<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt>
<if>if<condition>(<expr>!*<name>s</name></expr>)</condition><then><break>break;</break></then></if>
<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr>*<name>s</name> &lt; 0xe0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>n</name>++</expr>;</expr_stmt>
<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt>
<if>if<condition>(<expr>!*<name>s</name></expr>)</condition><then><break>break;</break></then></if>
<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt>
<if>if<condition>(<expr>!*<name>s</name></expr>)</condition><then><break>break;</break></then></if>
<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_UNICODE_WIDE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><name>n</name>++</expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>n</name>+=2</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt>
<if>if<condition>(<expr>!*<name>s</name></expr>)</condition><then><break>break;</break></then></if>
<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt>
<if>if<condition>(<expr>!*<name>s</name></expr>)</condition><then><break>break;</break></then></if>
<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt>
<if>if<condition>(<expr>!*<name>s</name></expr>)</condition><then><break>break;</break></then></if>
<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt>
}</block></else></if></else></if></else></if></else></if>
}</block></while>
<break>break;</break>
}</block>
</case><case>case <expr>'U'</expr>: <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>obj</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>count</name></expr></argument>, <argument><expr><name>PyObject</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>obj</name> &amp;&amp; <call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> += <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
}</block>
</case><case>case <expr>'V'</expr>: <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>obj</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>count</name></expr></argument>, <argument><expr><name>PyObject</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>str</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>count</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>obj</name> || <name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>!<name>obj</name> || <call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>obj</name></expr>)</condition><then>
<expr_stmt><expr><name>n</name> += <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>n</name> += <call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<break>break;</break>
}</block>
</case><case>case <expr>'S'</expr>: <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>obj</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>count</name></expr></argument>, <argument><expr><name>PyObject</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>str</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>str</name> = <call><name>PyObject_Str</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>str</name></expr>)</condition><then>
<goto>goto <name>fail</name>;</goto></then></if>
<expr_stmt><expr><name>n</name> += <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>callresult</name>++ = <name>str</name></expr>;</expr_stmt>
<break>break;</break>
}</block>
</case><case>case <expr>'R'</expr>: <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>obj</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>count</name></expr></argument>, <argument><expr><name>PyObject</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>repr</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>repr</name> = <call><name>PyObject_Repr</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>repr</name></expr>)</condition><then>
<goto>goto <name>fail</name>;</goto></then></if>
<expr_stmt><expr><name>n</name> += <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>repr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>callresult</name>++ = <name>repr</name></expr>;</expr_stmt>
<break>break;</break>
}</block>
</case><case>case <expr>'p'</expr>:
<expr_stmt><expr>(<name>void</name>) <call><name>va_arg</name><argument_list>(<argument><expr><name>count</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name> += 19</expr>;</expr_stmt>
<break>break;</break>
</case><default>default:
<expr_stmt><expr><name>n</name> += <call><name>strlen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>expand</name>;</goto>
</default>}</block></switch>
}</block></then> <else>else
<expr_stmt><expr><name>n</name>++</expr>;</expr_stmt></else></if>
}</block></for>
<label><name>expand</name>:</label>
<if>if <condition>(<expr><name>abuffersize</name> &gt; 20</expr>)</condition><then> <block>{
<expr_stmt><expr><name>abuffer</name> = <call><name>PyObject_Malloc</name><argument_list>(<argument><expr><name>abuffersize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>abuffer</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>fail</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>realbuffer</name> = <name>abuffer</name></expr>;</expr_stmt>
}</block></then> <else>else
<expr_stmt><expr><name>realbuffer</name> = <name>buffer</name></expr>;</expr_stmt></else></if>
<expr_stmt><expr><name>string</name> = <call><name>PyUnicode_FromUnicode</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>string</name></expr>)</condition><then>
<goto>goto <name>fail</name>;</goto></then></if>
<expr_stmt><expr><name>s</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>callresult</name> = <name>callresults</name></expr>;</expr_stmt>
<for>for (<init><expr><name>f</name> = <name>format</name></expr>;</init> <condition><expr>*<name>f</name></expr>;</condition> <incr><expr><name>f</name>++</expr></incr>) <block>{
<if>if <condition>(<expr>*<name>f</name> == '%'</expr>)</condition><then> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>p</name> <init>= <expr><name>f</name>++</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>longflag</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>size_tflag</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>zeropad</name> = (*<name>f</name> == '0')</expr>;</expr_stmt>
<expr_stmt><expr><name>width</name> = 0</expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr>(<name>unsigned</name>)*<name>f</name></expr></argument>)</argument_list></call></expr>)</condition>
<expr_stmt><expr><name>width</name> = (<name>width</name>*10) + *<name>f</name>++ - '0'</expr>;</expr_stmt></while>
<expr_stmt><expr><name>precision</name> = 0</expr>;</expr_stmt>
<if>if <condition>(<expr>*<name>f</name> == '.'</expr>)</condition><then> <block>{
<expr_stmt><expr><name>f</name>++</expr>;</expr_stmt>
<while>while <condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr>(<name>unsigned</name>)*<name>f</name></expr></argument>)</argument_list></call></expr>)</condition>
<expr_stmt><expr><name>precision</name> = (<name>precision</name>*10) + *<name>f</name>++ - '0'</expr>;</expr_stmt></while>
}</block></then></if>
<if>if <condition>(<expr>*<name>f</name> == 'l' &amp;&amp; (<name><name>f</name><index>[<expr>1</expr>]</index></name> == 'd' || <name><name>f</name><index>[<expr>1</expr>]</index></name> == 'u')</expr>)</condition><then> <block>{
<expr_stmt><expr><name>longflag</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr>++<name>f</name></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr>*<name>f</name> == 'z' &amp;&amp; (<name><name>f</name><index>[<expr>1</expr>]</index></name> == 'd' || <name><name>f</name><index>[<expr>1</expr>]</index></name> == 'u')</expr>)</condition><then> <block>{
<expr_stmt><expr><name>size_tflag</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr>++<name>f</name></expr>;</expr_stmt>
}</block></then></if>
<switch>switch <condition>(<expr>*<name>f</name></expr>)</condition> <block>{
<case>case <expr>'c'</expr>:
<expr_stmt><expr>*<name>s</name>++ = <call><name>va_arg</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'d'</expr>:
<expr_stmt><expr><call><name>makefmt</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>longflag</name></expr></argument>, <argument><expr><name>size_tflag</name></expr></argument>, <argument><expr><name>zeropad</name></expr></argument>, <argument><expr><name>width</name></expr></argument>, <argument><expr><name>precision</name></expr></argument>, <argument><expr>'d'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>longflag</name></expr>)</condition><then>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>realbuffer</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><call><name>va_arg</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>, <argument><expr><name>long</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name>size_tflag</name></expr>)</condition><then>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>realbuffer</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><call><name>va_arg</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>, <argument><expr><name>Py_ssize_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>realbuffer</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><call><name>va_arg</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if>
<expr_stmt><expr><call><name>appendstring</name><argument_list>(<argument><expr><name>realbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'u'</expr>:
<expr_stmt><expr><call><name>makefmt</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>longflag</name></expr></argument>, <argument><expr><name>size_tflag</name></expr></argument>, <argument><expr><name>zeropad</name></expr></argument>, <argument><expr><name>width</name></expr></argument>, <argument><expr><name>precision</name></expr></argument>, <argument><expr>'u'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>longflag</name></expr>)</condition><then>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>realbuffer</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><macro><name>va_arg</name><argument_list>(<argument>vargs</argument>, <argument>unsigned long</argument>)</argument_list></macro></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name>size_tflag</name></expr>)</condition><then>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>realbuffer</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><call><name>va_arg</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>, <argument><expr><name>size_t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>realbuffer</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><macro><name>va_arg</name><argument_list>(<argument>vargs</argument>, <argument>unsigned int</argument>)</argument_list></macro></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if>
<expr_stmt><expr><call><name>appendstring</name><argument_list>(<argument><expr><name>realbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'i'</expr>:
<expr_stmt><expr><call><name>makefmt</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>zeropad</name></expr></argument>, <argument><expr><name>width</name></expr></argument>, <argument><expr><name>precision</name></expr></argument>, <argument><expr>'i'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>realbuffer</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><call><name>va_arg</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>appendstring</name><argument_list>(<argument><expr><name>realbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'x'</expr>:
<expr_stmt><expr><call><name>makefmt</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>zeropad</name></expr></argument>, <argument><expr><name>width</name></expr></argument>, <argument><expr><name>precision</name></expr></argument>, <argument><expr>'x'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>realbuffer</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><call><name>va_arg</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>appendstring</name><argument_list>(<argument><expr><name>realbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'s'</expr>: <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>u</name></decl>;</decl_stmt>
<expr_stmt><expr><name>p</name> = <call><name>va_arg</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>, <argument><expr><name>char</name>*</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>u</name> = <call><name>PyUnicode_DecodeUTF8</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr>"replace"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>u</name></expr>)</condition><then>
<goto>goto <name>fail</name>;</goto></then></if>
<expr_stmt><expr><call><name>Py_UNICODE_COPY</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> += <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
}</block>
</case><case>case <expr>'U'</expr>: <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>obj</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>, <argument><expr><name>PyObject</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size</name> <init>= <expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>Py_UNICODE_COPY</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> += <name>size</name></expr>;</expr_stmt>
<break>break;</break>
}</block>
</case><case>case <expr>'V'</expr>: <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>obj</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>, <argument><expr><name>PyObject</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>str</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>obj</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>size</name> <init>= <expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>Py_UNICODE_COPY</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> += <name>size</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>appendstring</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<break>break;</break>
}</block>
</case><case>case <expr>'S'</expr>:
</case><case>case <expr>'R'</expr>: <block>{
<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>ucopy</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>usize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>upos</name></decl>;</decl_stmt>
<expr_stmt><expr>(<name>void</name>) <call><name>va_arg</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>, <argument><expr><name>PyObject</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ucopy</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr>*<name>callresult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>usize</name> = <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr>*<name>callresult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>upos</name> = 0</expr>;</init> <condition><expr><name>upos</name>&lt;<name>usize</name></expr>;</condition><incr/>)
<expr_stmt><expr>*<name>s</name>++ = <name><name>ucopy</name><index>[<expr><name>upos</name>++</expr>]</index></name></expr>;</expr_stmt></for>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr>*<name>callresult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>++<name>callresult</name></expr>;</expr_stmt>
<break>break;</break>
}</block>
</case><case>case <expr>'p'</expr>:
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr>"%p"</expr></argument>, <argument><expr><call><name>va_arg</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>, <argument><expr><name>void</name>*</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>buffer</name><index>[<expr>1</expr>]</index></name> == 'X'</expr>)</condition><then>
<expr_stmt><expr><name><name>buffer</name><index>[<expr>1</expr>]</index></name> = 'x'</expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name><name>buffer</name><index>[<expr>1</expr>]</index></name> != 'x'</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>buffer</name>+2</expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buffer</name><index>[<expr>0</expr>]</index></name> = '0'</expr>;</expr_stmt>
<expr_stmt><expr><name><name>buffer</name><index>[<expr>1</expr>]</index></name> = 'x'</expr>;</expr_stmt>
}</block></then></if></else></if>
<expr_stmt><expr><call><name>appendstring</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'%'</expr>:
<expr_stmt><expr>*<name>s</name>++ = '%'</expr>;</expr_stmt>
<break>break;</break>
</case><default>default:
<expr_stmt><expr><call><name>appendstring</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>end</name>;</goto>
</default>}</block></switch>
}</block></then> <else>else
<expr_stmt><expr>*<name>s</name>++ = *<name>f</name></expr>;</expr_stmt></else></if>
}</block></for>
<label><name>end</name>:</label>
<if>if <condition>(<expr><name>callresults</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyObject_Free</name><argument_list>(<argument><expr><name>callresults</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>abuffer</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyObject_Free</name><argument_list>(<argument><expr><name>abuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>_PyUnicode_Resize</name><argument_list>(<argument><expr>&amp;<name>string</name></expr></argument>, <argument><expr><name>s</name> - <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>string</name></expr>;</return>
<label><name>fail</name>:</label>
<if>if <condition>(<expr><name>callresults</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> **</type><name>callresult2</name> <init>= <expr><name>callresults</name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>callresult2</name> &lt; <name>callresult</name></expr>)</condition> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr>*<name>callresult2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>++<name>callresult2</name></expr>;</expr_stmt>
}</block></while>
<expr_stmt><expr><call><name>PyObject_Free</name><argument_list>(<argument><expr><name>callresults</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>abuffer</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyObject_Free</name><argument_list>(<argument><expr><name>abuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>appendstring</name></cpp:undef>
<function><type><name>PyObject</name> *</type>
<name>PyUnicode_FromFormat</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>format</name></decl></param>, <param><decl><type>...</type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name>*</type> <name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>va_list</name></type> <name>vargs</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_STDARG_PROTOTYPES</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>ret</name> = <call><name>PyUnicode_FromFormatV</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><name>vargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
}</block></function>
<function><type><name>Py_ssize_t</name></type> <name>PyUnicode_AsWideChar</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>unicode</name></decl></param>,
<param><decl><type><name>wchar_t</name> *</type><name>w</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name>unicode</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>size</name> &gt; <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>size</name> = <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call> + 1</expr>;</expr_stmt></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>HAVE_USABLE_WCHAR_T</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>w</name></expr></argument>, <argument><expr><name><name>unicode</name>-&gt;<name>str</name></name></expr></argument>, <argument><expr><name>size</name> * <sizeof>sizeof<argument_list>(<argument><expr><name>wchar_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<block>{
<decl_stmt><decl><type><name>register</name> <name>Py_UNICODE</name> *</type><name>u</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><name>u</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = <name>size</name></expr>;</init> <condition><expr><name>i</name> &gt; 0</expr>;</condition> <incr><expr><name>i</name>--</expr></incr>)
<expr_stmt><expr>*<name>w</name>++ = *<name>u</name>++</expr>;</expr_stmt></for>
}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><name>size</name> &gt; <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>;</return></then>
<else>else
<return>return <expr><name>size</name></expr>;</return></else></if>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>PyObject</name> *</type><name>PyUnicode_FromOrdinal</name><parameter_list>(<param><decl><type><name>int</name></type> <name>ordinal</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_UNICODE</name></type> <name><name>s</name><index>[<expr>1</expr>]</index></name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_UNICODE_WIDE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>ordinal</name> &lt; 0 || <name>ordinal</name> &gt; 0x10ffff</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"unichr() arg not in range(0x110000) "
"(wide Python build)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if>if <condition>(<expr><name>ordinal</name> &lt; 0 || <name>ordinal</name> &gt; 0xffff</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"unichr() arg not in range(0x10000) "
"(narrow Python build)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name><name>s</name><index>[<expr>0</expr>]</index></name> = (<name>Py_UNICODE</name>)<name>ordinal</name></expr>;</expr_stmt>
<return>return <expr><call><name>PyUnicode_FromUnicode</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type><name>PyUnicode_FromObject</name><parameter_list>(<param><decl><type><name>register</name> <name>PyObject</name> *</type><name>obj</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><call><name>PyUnicode_CheckExact</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>obj</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<return>return <expr><call><name>PyUnicode_FromUnicode</name><argument_list>(<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>PyUnicode_FromEncodedObject</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>"strict"</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type><name>PyUnicode_FromEncodedObject</name><parameter_list>(<param><decl><type><name>register</name> <name>PyObject</name> *</type><name>obj</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>encoding</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>obj</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
if (PyUnicode_Check(obj)) {
if (encoding) {
PyErr_SetString(PyExc_TypeError,
"decoding Unicode is not supported");
return NULL;
}
return PyObject_Unicode(obj);
}
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"decoding Unicode is not supported"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>s</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> = <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><call><name>PyByteArray_Check</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"decoding bytearray is not supported"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><call><name>PyObject_AsCharBuffer</name><argument_list>(<argument><expr><name>obj</name></expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"coercing to Unicode: need string or buffer, "
"%.80s found"</expr></argument>,
<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<goto>goto <name>onError</name>;</goto>
}</block></then></if></else></if></else></if>
<if>if <condition>(<expr><name>len</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>unicode_empty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>v</name> = (<name>PyObject</name> *)<name>unicode_empty</name></expr>;</expr_stmt>
}</block></then> <else>else
<expr_stmt><expr><name>v</name> = <call><name>PyUnicode_Decode</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<return>return <expr><name>v</name></expr>;</return>
<label><name>onError</name>:</label>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type><name>PyUnicode_Decode</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>encoding</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>buffer</name> <init>= <expr><name>NULL</name></expr></init>, *<name>unicode</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>encoding</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><name>encoding</name> = <call><name>PyUnicode_GetDefaultEncoding</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr>"utf-8"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
<return>return <expr><call><name>PyUnicode_DecodeUTF8</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr>;</return></then>
<else>else <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr>"latin-1"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
<return>return <expr><call><name>PyUnicode_DecodeLatin1</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr>;</return></then>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_USABLE_WCHAR_T</name></expr></argument>)</argument_list></call></expr></cpp:if>
<else>else <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr>"mbcs"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
<return>return <expr><call><name>PyUnicode_DecodeMBCS</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr>;</return></then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<else>else <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr>"ascii"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
<return>return <expr><call><name>PyUnicode_DecodeASCII</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr>;</return></then></if></else></if></else></if></else></if>
<expr_stmt><expr><name>buffer</name> = <call><name>PyBuffer_FromMemory</name><argument_list>(<argument><expr>(<name>void</name> *)<name>s</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>buffer</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<expr_stmt><expr><name>unicode</name> = <call><name>PyCodec_Decode</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>unicode</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<if>if <condition>(<expr>!<call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"decoder did not return an unicode object (type=%.400s)"</expr></argument>,
<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>onError</name>;</goto>
}</block></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>unicode</name></expr>;</return>
<label><name>onError</name>:</label>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type><name>PyUnicode_AsDecodedObject</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>unicode</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>encoding</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_BadArgument</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>onError</name>;</goto>
}</block></then></if>
<if>if <condition>(<expr><name>encoding</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><name>encoding</name> = <call><name>PyUnicode_GetDefaultEncoding</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>v</name> = <call><name>PyCodec_Decode</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<return>return <expr><name>v</name></expr>;</return>
<label><name>onError</name>:</label>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type><name>PyUnicode_Encode</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>s</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>encoding</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>, *<decl><type ref="prev"/><name>unicode</name></decl>;</decl_stmt>
<expr_stmt><expr><name>unicode</name> = <call><name>PyUnicode_FromUnicode</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>unicode</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>v</name> = <call><name>PyUnicode_AsEncodedString</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>v</name></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type><name>PyUnicode_AsEncodedObject</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>unicode</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>encoding</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_BadArgument</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>onError</name>;</goto>
}</block></then></if>
<if>if <condition>(<expr><name>encoding</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><name>encoding</name> = <call><name>PyUnicode_GetDefaultEncoding</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>v</name> = <call><name>PyCodec_Encode</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<return>return <expr><name>v</name></expr>;</return>
<label><name>onError</name>:</label>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type><name>PyUnicode_AsEncodedString</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>unicode</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>encoding</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_BadArgument</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>onError</name>;</goto>
}</block></then></if>
<if>if <condition>(<expr><name>encoding</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><name>encoding</name> = <call><name>PyUnicode_GetDefaultEncoding</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>errors</name> == <name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr>"utf-8"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
<return>return <expr><call><name>PyUnicode_AsUTF8String</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>;</return></then>
<else>else <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr>"latin-1"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
<return>return <expr><call><name>PyUnicode_AsLatin1String</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>;</return></then>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_USABLE_WCHAR_T</name></expr></argument>)</argument_list></call></expr></cpp:if>
<else>else <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr>"mbcs"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
<return>return <expr><call><name>PyUnicode_AsMBCSString</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>;</return></then>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<else>else <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>, <argument><expr>"ascii"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
<return>return <expr><call><name>PyUnicode_AsASCIIString</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>;</return></then></if></else></if></else></if></else></if>
}</block></then></if>
<expr_stmt><expr><name>v</name> = <call><name>PyCodec_Encode</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<if>if <condition>(<expr>!<call><name>PyString_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"encoder did not return a string object (type=%.400s)"</expr></argument>,
<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>onError</name>;</goto>
}</block></then></if>
<return>return <expr><name>v</name></expr>;</return>
<label><name>onError</name>:</label>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type><name>_PyUnicode_AsDefaultEncodedString</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>unicode</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name> <init>= <expr>((<name>PyUnicodeObject</name> *)<name>unicode</name>)-&gt;<name>defenc</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>v</name></expr>)</condition><then>
<return>return <expr><name>v</name></expr>;</return></then></if>
<expr_stmt><expr><name>v</name> = <call><name>PyUnicode_AsEncodedString</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> &amp;&amp; <name>errors</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr>((<name>PyUnicodeObject</name> *)<name>unicode</name>)-&gt;<name>defenc</name> = <name>v</name></expr>;</expr_stmt></then></if>
<return>return <expr><name>v</name></expr>;</return>
}</block></function>
<function><type><name>Py_UNICODE</name> *</type><name>PyUnicode_AsUnicode</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>unicode</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr>!<call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_BadArgument</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>onError</name>;</goto>
}</block></then></if>
<return>return <expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>;</return>
<label><name>onError</name>:</label>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><name>Py_ssize_t</name></type> <name>PyUnicode_GetSize</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>unicode</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr>!<call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_BadArgument</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>onError</name>;</goto>
}</block></then></if>
<return>return <expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>;</return>
<label><name>onError</name>:</label>
<return>return <expr>-1</expr>;</return>
}</block></function>
<function><type><specifier>const</specifier> <name>char</name> *</type><name>PyUnicode_GetDefaultEncoding</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<return>return <expr><name>unicode_default_encoding</name></expr>;</return>
}</block></function>
<function><type><name>int</name></type> <name>PyUnicode_SetDefaultEncoding</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>encoding</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
<expr_stmt><expr><name>v</name> = <call><name>_PyCodec_Lookup</name><argument_list>(<argument><expr><name>encoding</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>unicode_default_encoding</name></expr></argument>,
<argument><expr><name>encoding</name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>unicode_default_encoding</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
<label><name>onError</name>:</label>
<return>return <expr>-1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier>
<name>int</name></type> <name>unicode_decode_call_errorhandler</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>, <param><decl><type><name>PyObject</name> **</type><name>errorHandler</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>encoding</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>reason</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>input</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>insize</name></decl></param>, <param><decl><type><name>Py_ssize_t</name> *</type><name>startinpos</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name> *</type><name>endinpos</name></decl></param>, <param><decl><type><name>PyObject</name> **</type><name>exceptionObject</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>inptr</name></decl></param>,
<param><decl><type><name>PyObject</name> **</type><name>output</name></decl></param>, <param><decl><type><name>Py_ssize_t</name> *</type><name>outpos</name></decl></param>, <param><decl><type><name>Py_UNICODE</name> **</type><name>outptr</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name>argparse</name> <init>= <expr>"O!n;decoding error handler must return (unicode, int) tuple"</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>restuple</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>repunicode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>outsize</name> <init>= <expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr>*<name>output</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>requiredsize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>newpos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>repptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>repsize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>*<name>errorHandler</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>errorHandler</name> = <call><name>PyCodec_LookupError</name><argument_list>(<argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>*<name>errorHandler</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
}</block></then></if>
<if>if <condition>(<expr>*<name>exceptionObject</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>exceptionObject</name> = <call><name>PyUnicodeDecodeError_Create</name><argument_list>(
<argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>insize</name></expr></argument>, <argument><expr>*<name>startinpos</name></expr></argument>, <argument><expr>*<name>endinpos</name></expr></argument>, <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>*<name>exceptionObject</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
}</block></then> <else>else <block>{
<if>if <condition>(<expr><call><name>PyUnicodeDecodeError_SetStart</name><argument_list>(<argument><expr>*<name>exceptionObject</name></expr></argument>, <argument><expr>*<name>startinpos</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<if>if <condition>(<expr><call><name>PyUnicodeDecodeError_SetEnd</name><argument_list>(<argument><expr>*<name>exceptionObject</name></expr></argument>, <argument><expr>*<name>endinpos</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<if>if <condition>(<expr><call><name>PyUnicodeDecodeError_SetReason</name><argument_list>(<argument><expr>*<name>exceptionObject</name></expr></argument>, <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
}</block></else></if>
<expr_stmt><expr><name>restuple</name> = <call><name>PyObject_CallFunctionObjArgs</name><argument_list>(<argument><expr>*<name>errorHandler</name></expr></argument>, <argument><expr>*<name>exceptionObject</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>restuple</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<if>if <condition>(<expr>!<call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>restuple</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>&amp;<name><name>argparse</name><index>[<expr>4</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>onError</name>;</goto>
}</block></then></if>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>restuple</name></expr></argument>, <argument><expr><name>argparse</name></expr></argument>, <argument><expr>&amp;<name>PyUnicode_Type</name></expr></argument>, <argument><expr>&amp;<name>repunicode</name></expr></argument>, <argument><expr>&amp;<name>newpos</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<if>if <condition>(<expr><name>newpos</name>&lt;0</expr>)</condition><then>
<expr_stmt><expr><name>newpos</name> = <name>insize</name>+<name>newpos</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>newpos</name>&lt;0 || <name>newpos</name>&gt;<name>insize</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_IndexError</name></expr></argument>, <argument><expr>"position %zd from error handler out of bounds"</expr></argument>, <argument><expr><name>newpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>onError</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>repptr</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>repunicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>repsize</name> = <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>repunicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>requiredsize</name> = *<name>outpos</name> + <name>repsize</name> + <name>insize</name>-<name>newpos</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>requiredsize</name> &gt; <name>outsize</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>requiredsize</name>&lt;2*<name>outsize</name></expr>)</condition><then>
<expr_stmt><expr><name>requiredsize</name> = 2*<name>outsize</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><call><name>PyUnicode_Resize</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name>requiredsize</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<expr_stmt><expr>*<name>outptr</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr>*<name>output</name></expr></argument>)</argument_list></call> + *<name>outpos</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr>*<name>endinpos</name> = <name>newpos</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>inptr</name> = <name>input</name> + <name>newpos</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_UNICODE_COPY</name><argument_list>(<argument><expr>*<name>outptr</name></expr></argument>, <argument><expr><name>repptr</name></expr></argument>, <argument><expr><name>repsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>outptr</name> += <name>repsize</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>outpos</name> += <name>repsize</name></expr>;</expr_stmt>
<expr_stmt><expr><name>res</name> = 0</expr>;</expr_stmt>
<label><name>onError</name>:</label>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>restuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier>
<name>char</name></type> <name><name>utf7_special</name><index>[<expr>128</expr>]</index></name> <init>= <expr><block>{
<expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>2</expr>, <expr>2</expr>, <expr>1</expr>, <expr>1</expr>, <expr>2</expr>, <expr>1</expr>, <expr>1</expr>,
<expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
<expr>2</expr>, <expr>3</expr>, <expr>3</expr>, <expr>3</expr>, <expr>3</expr>, <expr>3</expr>, <expr>3</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>3</expr>, <expr>1</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>1</expr>,
<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>3</expr>, <expr>3</expr>, <expr>3</expr>, <expr>3</expr>, <expr>0</expr>,
<expr>3</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>3</expr>, <expr>1</expr>, <expr>3</expr>, <expr>3</expr>, <expr>3</expr>,
<expr>3</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>3</expr>, <expr>3</expr>, <expr>3</expr>, <expr>1</expr>, <expr>1</expr>,
}</block></expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPECIAL</name><parameter_list>(<param><type><name>c</name></type></param>, <param><type><name>encodeO</name></type></param>, <param><type><name>encodeWS</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((c) &gt; 127 || (c) &lt;= 0 || utf7_special[(c)] == 1 || (encodeWS &amp;&amp; (utf7_special[(c)] == 2)) || (encodeO &amp;&amp; (utf7_special[(c)] == 3)))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>B64</name><parameter_list>(<param><type><name>n</name></type></param>)</parameter_list></cpp:macro> <cpp:value>("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"[(n) &amp; 0x3f])</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>B64CHAR</name><parameter_list>(<param><type><name>c</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(isalnum(c) || (c) == '+' || (c) == '/')</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>UB64</name><parameter_list>(<param><type><name>c</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((c) == '+' ? 62 : (c) == '/' ? 63 : (c) &gt;= 'a' ? (c) - 71 : (c) &gt;= 'A' ? (c) - 65 : (c) + 4 )</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENCODE</name><parameter_list>(<param><type><name>out</name></type></param>, <param><type><name>ch</name></type></param>, <param><type><name>bits</name></type></param>)</parameter_list></cpp:macro> <cpp:value>while (bits &gt;= 6) { *out++ = B64(ch &gt;&gt; (bits-6)); bits -= 6; }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DECODE</name><parameter_list>(<param><type><name>out</name></type></param>, <param><type><name>ch</name></type></param>, <param><type><name>bits</name></type></param>, <param><type><name>surrogate</name></type></param>)</parameter_list></cpp:macro> <cpp:value>while (bits &gt;= 16) { Py_UNICODE outCh = (Py_UNICODE) ((ch &gt;&gt; (bits-16)) &amp; 0xffff); bits -= 16; if (surrogate) { surrogate = 0; } else if (0xDC00 &lt;= outCh &amp;&amp; outCh &lt;= 0xDFFF) { surrogate = 1; errmsg = "code pairs are not supported"; goto utf7Error; } else { *out++ = outCh; } }</cpp:value></cpp:define>
<function><type><name>PyObject</name> *</type><name>PyUnicode_DecodeUTF7</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>PyUnicode_DecodeUTF7Stateful</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type><name>PyUnicode_DecodeUTF7Stateful</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name> *</type><name>consumed</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>starts</name> <init>= <expr><name>s</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>startinpos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>endinpos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>outpos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>e</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>unicode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errmsg</name> <init>= <expr>""</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>inShift</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>bitsleft</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>charsleft</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>surrogate</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>errorHandler</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>exc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>unicode</name> = <call><name>_PyUnicode_New</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>unicode</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>size</name> == 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>consumed</name></expr>)</condition><then>
<expr_stmt><expr>*<name>consumed</name> = 0</expr>;</expr_stmt></then></if>
<return>return <expr>(<name>PyObject</name> *)<name>unicode</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>p</name> = <name><name>unicode</name>-&gt;<name>str</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>e</name> = <name>s</name> + <name>size</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>s</name> &lt; <name>e</name></expr>)</condition> <block>{
<decl_stmt><decl><type><name>Py_UNICODE</name></type> <name>ch</name></decl>;</decl_stmt>
<label><name>restart</name>:</label>
<expr_stmt><expr><name>ch</name> = (<name>unsigned</name> <name>char</name>) *<name>s</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>inShift</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>(<name>ch</name> == '-') || !<call><name>B64CHAR</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>inShift</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt>
<expr_stmt><expr><call><name>DECODE</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>charsleft</name></expr></argument>, <argument><expr><name>bitsleft</name></expr></argument>, <argument><expr><name>surrogate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>bitsleft</name> &gt;= 6</expr>)</condition><then> <block>{
<expr_stmt><expr><name>errmsg</name> = "partial character in shift sequence"</expr>;</expr_stmt>
<goto>goto <name>utf7Error</name>;</goto>
}</block></then></if>
<if>if <condition>(<expr><name>bitsleft</name> &amp;&amp; <name>charsleft</name> &lt;&lt; (<sizeof>sizeof<argument_list>(<argument><expr><name>charsleft</name></expr></argument>)</argument_list></sizeof> * 8 - <name>bitsleft</name>)</expr>)</condition><then> <block>{
<expr_stmt><expr><name>errmsg</name> = "non-zero padding bits in shift sequence"</expr>;</expr_stmt>
<goto>goto <name>utf7Error</name>;</goto>
}</block></then></if>
<if>if <condition>(<expr><name>ch</name> == '-'</expr>)</condition><then> <block>{
<if>if <condition>(<expr>(<name>s</name> &lt; <name>e</name>) &amp;&amp; (*(<name>s</name>) == '-')</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>p</name>++ = '-'</expr>;</expr_stmt>
<expr_stmt><expr><name>inShift</name> = 1</expr>;</expr_stmt>
}</block></then></if>
}</block></then> <else>else <if>if <condition>(<expr><call><name>SPECIAL</name><argument_list>(<argument><expr><name>ch</name></expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>errmsg</name> = "unexpected special character"</expr>;</expr_stmt>
<goto>goto <name>utf7Error</name>;</goto>
}</block></then> <else>else <block>{
<expr_stmt><expr>*<name>p</name>++ = <name>ch</name></expr>;</expr_stmt>
}</block></else></if></else></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>charsleft</name> = (<name>charsleft</name> &lt;&lt; 6) | <call><name>UB64</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>bitsleft</name> += 6</expr>;</expr_stmt>
<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt>
<expr_stmt><expr><call><name>DECODE</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>charsleft</name></expr></argument>, <argument><expr><name>bitsleft</name></expr></argument>, <argument><expr><name>surrogate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
}</block></then> <else>else <if>if <condition>( <expr><name>ch</name> == '+'</expr> )</condition><then> <block>{
<expr_stmt><expr><name>startinpos</name> = <name>s</name>-<name>starts</name></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt>
<if>if <condition>(<expr><name>s</name> &lt; <name>e</name> &amp;&amp; *<name>s</name> == '-'</expr>)</condition><then> <block>{
<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = '+'</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>inShift</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name>bitsleft</name> = 0</expr>;</expr_stmt>
}</block></else></if>
}</block></then> <else>else <if>if <condition>(<expr><call><name>SPECIAL</name><argument_list>(<argument><expr><name>ch</name></expr></argument>,<argument><expr>0</expr></argument>,<argument><expr>0</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>startinpos</name> = <name>s</name>-<name>starts</name></expr>;</expr_stmt>
<expr_stmt><expr><name>errmsg</name> = "unexpected special character"</expr>;</expr_stmt>
<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt>
<goto>goto <name>utf7Error</name>;</goto>
}</block></then> <else>else <block>{
<expr_stmt><expr>*<name>p</name>++ = <name>ch</name></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt>
}</block></else></if></else></if></else></if>
<continue>continue;</continue>
<label><name>utf7Error</name>:</label>
<expr_stmt><expr><name>outpos</name> = <name>p</name>-<call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>endinpos</name> = <name>s</name>-<name>starts</name></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>unicode_decode_call_errorhandler</name><argument_list>(
<argument><expr><name>errors</name></expr></argument>, <argument><expr>&amp;<name>errorHandler</name></expr></argument>,
<argument><expr>"utf7"</expr></argument>, <argument><expr><name>errmsg</name></expr></argument>,
<argument><expr><name>starts</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr>&amp;<name>startinpos</name></expr></argument>, <argument><expr>&amp;<name>endinpos</name></expr></argument>, <argument><expr>&amp;<name>exc</name></expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>,
<argument><expr>(<name>PyObject</name> **)&amp;<name>unicode</name></expr></argument>, <argument><expr>&amp;<name>outpos</name></expr></argument>, <argument><expr>&amp;<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
}</block></while>
<if>if <condition>(<expr><name>inShift</name> &amp;&amp; !<name>consumed</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>outpos</name> = <name>p</name>-<call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>endinpos</name> = <name>size</name></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>unicode_decode_call_errorhandler</name><argument_list>(
<argument><expr><name>errors</name></expr></argument>, <argument><expr>&amp;<name>errorHandler</name></expr></argument>,
<argument><expr>"utf7"</expr></argument>, <argument><expr>"unterminated shift sequence"</expr></argument>,
<argument><expr><name>starts</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr>&amp;<name>startinpos</name></expr></argument>, <argument><expr>&amp;<name>endinpos</name></expr></argument>, <argument><expr>&amp;<name>exc</name></expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>,
<argument><expr>(<name>PyObject</name> **)&amp;<name>unicode</name></expr></argument>, <argument><expr>&amp;<name>outpos</name></expr></argument>, <argument><expr>&amp;<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<if>if <condition>(<expr><name>s</name> &lt; <name>e</name></expr>)</condition><then>
<goto>goto <name>restart</name>;</goto></then></if>
}</block></then></if>
<if>if <condition>(<expr><name>consumed</name></expr>)</condition><then> <block>{
<if>if<condition>(<expr><name>inShift</name></expr>)</condition><then>
<expr_stmt><expr>*<name>consumed</name> = <name>startinpos</name></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr>*<name>consumed</name> = <name>s</name>-<name>starts</name></expr>;</expr_stmt></else></if>
}</block></then></if>
<if>if <condition>(<expr><call><name>_PyUnicode_Resize</name><argument_list>(<argument><expr>&amp;<name>unicode</name></expr></argument>, <argument><expr><name>p</name> - <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>errorHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *)<name>unicode</name></expr>;</return>
<label><name>onError</name>:</label>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>errorHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type><name>PyUnicode_EncodeUTF7</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>s</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>,
<param><decl><type><name>int</name></type> <name>encodeSetO</name></decl></param>,
<param><decl><type><name>int</name></type> <name>encodeWhiteSpace</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>cbAllocated</name> <init>= <expr>5 * <name>size</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>inShift</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>bitsleft</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>charsleft</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type> <name>out</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type> <name>start</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>cbAllocated</name> / 5 != <name>size</name></expr>)</condition><then>
<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><name>size</name> == 0</expr>)</condition><then>
<return>return <expr><call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>v</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>cbAllocated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>start</name> = <name>out</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init>;</init> <condition><expr><name>i</name> &lt; <name>size</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<decl_stmt><decl><type><name>Py_UNICODE</name></type> <name>ch</name> <init>= <expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>inShift</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>ch</name> == '+'</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>out</name>++ = '+'</expr>;</expr_stmt>
<expr_stmt><expr>*<name>out</name>++ = '-'</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><call><name>SPECIAL</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr><name>encodeSetO</name></expr></argument>, <argument><expr><name>encodeWhiteSpace</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>charsleft</name> = <name>ch</name></expr>;</expr_stmt>
<expr_stmt><expr><name>bitsleft</name> = 16</expr>;</expr_stmt>
<expr_stmt><expr>*<name>out</name>++ = '+'</expr>;</expr_stmt>
<expr_stmt><expr><call><name>ENCODE</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>charsleft</name></expr></argument>, <argument><expr><name>bitsleft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>inShift</name> = <name>bitsleft</name> &gt; 0</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr>*<name>out</name>++ = (<name>char</name>) <name>ch</name></expr>;</expr_stmt>
}</block></else></if></else></if>
}</block></then> <else>else <block>{
<if>if <condition>(<expr>!<call><name>SPECIAL</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr><name>encodeSetO</name></expr></argument>, <argument><expr><name>encodeWhiteSpace</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>out</name>++ = <call><name>B64</name><argument_list>(<argument><expr><name>charsleft</name> &lt;&lt; (6-<name>bitsleft</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>charsleft</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>bitsleft</name> = 0</expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>B64CHAR</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> || <name>ch</name> == '-'</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>out</name>++ = '-'</expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>inShift</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr>*<name>out</name>++ = (<name>char</name>) <name>ch</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>bitsleft</name> += 16</expr>;</expr_stmt>
<expr_stmt><expr><name>charsleft</name> = (<name>charsleft</name> &lt;&lt; 16) | <name>ch</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>ENCODE</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>charsleft</name></expr></argument>, <argument><expr><name>bitsleft</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>bitsleft</name> == 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>i</name> + 1 &lt; <name>size</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>Py_UNICODE</name></type> <name>ch2</name> <init>= <expr><name><name>s</name><index>[<expr><name>i</name>+1</expr>]</index></name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>SPECIAL</name><argument_list>(<argument><expr><name>ch2</name></expr></argument>, <argument><expr><name>encodeSetO</name></expr></argument>, <argument><expr><name>encodeWhiteSpace</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
}</block></then> <else>else <if>if <condition>(<expr><call><name>B64CHAR</name><argument_list>(<argument><expr><name>ch2</name></expr></argument>)</argument_list></call> || <name>ch2</name> == '-'</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>out</name>++ = '-'</expr>;</expr_stmt>
<expr_stmt><expr><name>inShift</name> = 0</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>inShift</name> = 0</expr>;</expr_stmt>
}</block></else></if></else></if>
}</block></then> <else>else <block>{
<expr_stmt><expr>*<name>out</name>++ = '-'</expr>;</expr_stmt>
<expr_stmt><expr><name>inShift</name> = 0</expr>;</expr_stmt>
}</block></else></if>
}</block></then></if>
}</block></else></if>
}</block></else></if>
}</block></for>
<if>if <condition>(<expr><name>bitsleft</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>out</name>++= <call><name>B64</name><argument_list>(<argument><expr><name>charsleft</name> &lt;&lt; (6-<name>bitsleft</name>)</expr></argument> )</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>out</name>++ = '-'</expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr><name>out</name> - <name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>v</name></expr>;</return>
}</block></function>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SPECIAL</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>B64</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>B64CHAR</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>UB64</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>ENCODE</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>DECODE</name></cpp:undef>
<decl_stmt><decl><type><specifier>static</specifier>
<name>char</name></type> <name><name>utf8_code_length</name><index>[<expr>256</expr>]</index></name> <init>= <expr><block>{
<expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
<expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
<expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
<expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
<expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
<expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
<expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
<expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
<expr>2</expr>, <expr>2</expr>, <expr>2</expr>, <expr>2</expr>, <expr>2</expr>, <expr>2</expr>, <expr>2</expr>, <expr>2</expr>, <expr>2</expr>, <expr>2</expr>, <expr>2</expr>, <expr>2</expr>, <expr>2</expr>, <expr>2</expr>, <expr>2</expr>, <expr>2</expr>,
<expr>2</expr>, <expr>2</expr>, <expr>2</expr>, <expr>2</expr>, <expr>2</expr>, <expr>2</expr>, <expr>2</expr>, <expr>2</expr>, <expr>2</expr>, <expr>2</expr>, <expr>2</expr>, <expr>2</expr>, <expr>2</expr>, <expr>2</expr>, <expr>2</expr>, <expr>2</expr>,
<expr>3</expr>, <expr>3</expr>, <expr>3</expr>, <expr>3</expr>, <expr>3</expr>, <expr>3</expr>, <expr>3</expr>, <expr>3</expr>, <expr>3</expr>, <expr>3</expr>, <expr>3</expr>, <expr>3</expr>, <expr>3</expr>, <expr>3</expr>, <expr>3</expr>, <expr>3</expr>,
<expr>4</expr>, <expr>4</expr>, <expr>4</expr>, <expr>4</expr>, <expr>4</expr>, <expr>4</expr>, <expr>4</expr>, <expr>4</expr>, <expr>5</expr>, <expr>5</expr>, <expr>5</expr>, <expr>5</expr>, <expr>6</expr>, <expr>6</expr>, <expr>0</expr>, <expr>0</expr>
}</block></expr></init></decl>;</decl_stmt>
<function><type><name>PyObject</name> *</type><name>PyUnicode_DecodeUTF8</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>PyUnicode_DecodeUTF8Stateful</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type><name>PyUnicode_DecodeUTF8Stateful</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name> *</type><name>consumed</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>starts</name> <init>= <expr><name>s</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>startinpos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>endinpos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>outpos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>e</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>unicode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errmsg</name> <init>= <expr>""</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>errorHandler</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>exc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>unicode</name> = <call><name>_PyUnicode_New</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>unicode</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>size</name> == 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>consumed</name></expr>)</condition><then>
<expr_stmt><expr>*<name>consumed</name> = 0</expr>;</expr_stmt></then></if>
<return>return <expr>(<name>PyObject</name> *)<name>unicode</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>p</name> = <name><name>unicode</name>-&gt;<name>str</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>e</name> = <name>s</name> + <name>size</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>s</name> &lt; <name>e</name></expr>)</condition> <block>{
<decl_stmt><decl><type><name>Py_UCS4</name></type> <name>ch</name> <init>= <expr>(<name>unsigned</name> <name>char</name>)*<name>s</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>ch</name> &lt; 0x80</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>p</name>++ = (<name>Py_UNICODE</name>)<name>ch</name></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt>
<continue>continue;</continue>
}</block></then></if>
<expr_stmt><expr><name>n</name> = <name><name>utf8_code_length</name><index>[<expr><name>ch</name></expr>]</index></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>s</name> + <name>n</name> &gt; <name>e</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>consumed</name></expr>)</condition><then>
<break>break;</break></then>
<else>else <block>{
<expr_stmt><expr><name>errmsg</name> = "unexpected end of data"</expr>;</expr_stmt>
<expr_stmt><expr><name>startinpos</name> = <name>s</name>-<name>starts</name></expr>;</expr_stmt>
<expr_stmt><expr><name>endinpos</name> = <name>size</name></expr>;</expr_stmt>
<goto>goto <name>utf8Error</name>;</goto>
}</block></else></if>
}</block></then></if>
<switch>switch <condition>(<expr><name>n</name></expr>)</condition> <block>{
<case>case <expr>0</expr>:
<expr_stmt><expr><name>errmsg</name> = "unexpected code byte"</expr>;</expr_stmt>
<expr_stmt><expr><name>startinpos</name> = <name>s</name>-<name>starts</name></expr>;</expr_stmt>
<expr_stmt><expr><name>endinpos</name> = <name>startinpos</name>+1</expr>;</expr_stmt>
<goto>goto <name>utf8Error</name>;</goto>
</case><case>case <expr>1</expr>:
<expr_stmt><expr><name>errmsg</name> = "internal error"</expr>;</expr_stmt>
<expr_stmt><expr><name>startinpos</name> = <name>s</name>-<name>starts</name></expr>;</expr_stmt>
<expr_stmt><expr><name>endinpos</name> = <name>startinpos</name>+1</expr>;</expr_stmt>
<goto>goto <name>utf8Error</name>;</goto>
</case><case>case <expr>2</expr>:
<if>if <condition>(<expr>(<name><name>s</name><index>[<expr>1</expr>]</index></name> &amp; 0xc0) != 0x80</expr>)</condition><then> <block>{
<expr_stmt><expr><name>errmsg</name> = "invalid data"</expr>;</expr_stmt>
<expr_stmt><expr><name>startinpos</name> = <name>s</name>-<name>starts</name></expr>;</expr_stmt>
<expr_stmt><expr><name>endinpos</name> = <name>startinpos</name>+2</expr>;</expr_stmt>
<goto>goto <name>utf8Error</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>ch</name> = ((<name><name>s</name><index>[<expr>0</expr>]</index></name> &amp; 0x1f) &lt;&lt; 6) + (<name><name>s</name><index>[<expr>1</expr>]</index></name> &amp; 0x3f)</expr>;</expr_stmt>
<if>if <condition>(<expr><name>ch</name> &lt; 0x80</expr>)</condition><then> <block>{
<expr_stmt><expr><name>startinpos</name> = <name>s</name>-<name>starts</name></expr>;</expr_stmt>
<expr_stmt><expr><name>endinpos</name> = <name>startinpos</name>+2</expr>;</expr_stmt>
<expr_stmt><expr><name>errmsg</name> = "illegal encoding"</expr>;</expr_stmt>
<goto>goto <name>utf8Error</name>;</goto>
}</block></then> <else>else
<expr_stmt><expr>*<name>p</name>++ = (<name>Py_UNICODE</name>)<name>ch</name></expr>;</expr_stmt></else></if>
<break>break;</break>
</case><case>case <expr>3</expr>:
<if>if <condition>(<expr>(<name><name>s</name><index>[<expr>1</expr>]</index></name> &amp; 0xc0) != 0x80 ||
(<name><name>s</name><index>[<expr>2</expr>]</index></name> &amp; 0xc0) != 0x80</expr>)</condition><then> <block>{
<expr_stmt><expr><name>errmsg</name> = "invalid data"</expr>;</expr_stmt>
<expr_stmt><expr><name>startinpos</name> = <name>s</name>-<name>starts</name></expr>;</expr_stmt>
<expr_stmt><expr><name>endinpos</name> = <name>startinpos</name>+3</expr>;</expr_stmt>
<goto>goto <name>utf8Error</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>ch</name> = ((<name><name>s</name><index>[<expr>0</expr>]</index></name> &amp; 0x0f) &lt;&lt; 12) + ((<name><name>s</name><index>[<expr>1</expr>]</index></name> &amp; 0x3f) &lt;&lt; 6) + (<name><name>s</name><index>[<expr>2</expr>]</index></name> &amp; 0x3f)</expr>;</expr_stmt>
<if>if <condition>(<expr><name>ch</name> &lt; 0x0800</expr>)</condition><then> <block>{
<expr_stmt><expr><name>errmsg</name> = "illegal encoding"</expr>;</expr_stmt>
<expr_stmt><expr><name>startinpos</name> = <name>s</name>-<name>starts</name></expr>;</expr_stmt>
<expr_stmt><expr><name>endinpos</name> = <name>startinpos</name>+3</expr>;</expr_stmt>
<goto>goto <name>utf8Error</name>;</goto>
}</block></then> <else>else
<expr_stmt><expr>*<name>p</name>++ = (<name>Py_UNICODE</name>)<name>ch</name></expr>;</expr_stmt></else></if>
<break>break;</break>
</case><case>case <expr>4</expr>:
<if>if <condition>(<expr>(<name><name>s</name><index>[<expr>1</expr>]</index></name> &amp; 0xc0) != 0x80 ||
(<name><name>s</name><index>[<expr>2</expr>]</index></name> &amp; 0xc0) != 0x80 ||
(<name><name>s</name><index>[<expr>3</expr>]</index></name> &amp; 0xc0) != 0x80</expr>)</condition><then> <block>{
<expr_stmt><expr><name>errmsg</name> = "invalid data"</expr>;</expr_stmt>
<expr_stmt><expr><name>startinpos</name> = <name>s</name>-<name>starts</name></expr>;</expr_stmt>
<expr_stmt><expr><name>endinpos</name> = <name>startinpos</name>+4</expr>;</expr_stmt>
<goto>goto <name>utf8Error</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>ch</name> = ((<name><name>s</name><index>[<expr>0</expr>]</index></name> &amp; 0x7) &lt;&lt; 18) + ((<name><name>s</name><index>[<expr>1</expr>]</index></name> &amp; 0x3f) &lt;&lt; 12) +
((<name><name>s</name><index>[<expr>2</expr>]</index></name> &amp; 0x3f) &lt;&lt; 6) + (<name><name>s</name><index>[<expr>3</expr>]</index></name> &amp; 0x3f)</expr>;</expr_stmt>
<if>if <condition>(<expr>(<name>ch</name> &lt; 0x10000)
|| (<name>ch</name> &gt; 0x10ffff)</expr>)</condition><then>
<block>{
<expr_stmt><expr><name>errmsg</name> = "illegal encoding"</expr>;</expr_stmt>
<expr_stmt><expr><name>startinpos</name> = <name>s</name>-<name>starts</name></expr>;</expr_stmt>
<expr_stmt><expr><name>endinpos</name> = <name>startinpos</name>+4</expr>;</expr_stmt>
<goto>goto <name>utf8Error</name>;</goto>
}</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_UNICODE_WIDE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr>*<name>p</name>++ = (<name>Py_UNICODE</name>)<name>ch</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>ch</name> -= 0x10000</expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = <call>(<name>Py_UNICODE</name>)<argument_list>(<argument><expr>0xD800 + (<name>ch</name> &gt;&gt; 10)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = <call>(<name>Py_UNICODE</name>)<argument_list>(<argument><expr>0xDC00 + (<name>ch</name> &amp; 0x03FF)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<break>break;</break>
</case><default>default:
<expr_stmt><expr><name>errmsg</name> = "unsupported Unicode code range"</expr>;</expr_stmt>
<expr_stmt><expr><name>startinpos</name> = <name>s</name>-<name>starts</name></expr>;</expr_stmt>
<expr_stmt><expr><name>endinpos</name> = <name>startinpos</name>+<name>n</name></expr>;</expr_stmt>
<goto>goto <name>utf8Error</name>;</goto>
</default>}</block></switch>
<expr_stmt><expr><name>s</name> += <name>n</name></expr>;</expr_stmt>
<continue>continue;</continue>
<label><name>utf8Error</name>:</label>
<expr_stmt><expr><name>outpos</name> = <name>p</name>-<call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>unicode_decode_call_errorhandler</name><argument_list>(
<argument><expr><name>errors</name></expr></argument>, <argument><expr>&amp;<name>errorHandler</name></expr></argument>,
<argument><expr>"utf8"</expr></argument>, <argument><expr><name>errmsg</name></expr></argument>,
<argument><expr><name>starts</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr>&amp;<name>startinpos</name></expr></argument>, <argument><expr>&amp;<name>endinpos</name></expr></argument>, <argument><expr>&amp;<name>exc</name></expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>,
<argument><expr>(<name>PyObject</name> **)&amp;<name>unicode</name></expr></argument>, <argument><expr>&amp;<name>outpos</name></expr></argument>, <argument><expr>&amp;<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
}</block></while>
<if>if <condition>(<expr><name>consumed</name></expr>)</condition><then>
<expr_stmt><expr>*<name>consumed</name> = <name>s</name>-<name>starts</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><call><name>_PyUnicode_Resize</name><argument_list>(<argument><expr>&amp;<name>unicode</name></expr></argument>, <argument><expr><name>p</name> - <name><name>unicode</name>-&gt;<name>str</name></name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>errorHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *)<name>unicode</name></expr>;</return>
<label><name>onError</name>:</label>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>errorHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type>
<name>PyUnicode_EncodeUTF8</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>s</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>)</parameter_list> <block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_SHORT_UNICHARS</name></cpp:macro> <cpp:value>300</cpp:value></cpp:define>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>nallocated</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>nneeded</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>stackbuf</name><index>[<expr><name>MAX_SHORT_UNICHARS</name> * 4</expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>s</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>size</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>size</name> &lt;= <name>MAX_SHORT_UNICHARS</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>nallocated</name> = <call><name>Py_SAFE_DOWNCAST</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>stackbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>size_t</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>v</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> = <name>stackbuf</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>nallocated</name> = <name>size</name> * 4</expr>;</expr_stmt>
<if>if <condition>(<expr><name>nallocated</name> / 4 != <name>size</name></expr>)</condition><then>
<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>v</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>nallocated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>p</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>size</name></expr>;</condition><incr/>) <block>{
<decl_stmt><decl><type><name>Py_UCS4</name></type> <name>ch</name> <init>= <expr><name><name>s</name><index>[<expr><name>i</name>++</expr>]</index></name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>ch</name> &lt; 0x80</expr>)</condition><then>
<expr_stmt><expr>*<name>p</name>++ = (<name>char</name>) <name>ch</name></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name>ch</name> &lt; 0x0800</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>p</name>++ = <call>(<name>char</name>)<argument_list>(<argument><expr>0xc0 | (<name>ch</name> &gt;&gt; 6)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = <call>(<name>char</name>)<argument_list>(<argument><expr>0x80 | (<name>ch</name> &amp; 0x3f)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<if>if <condition>(<expr><name>ch</name> &lt; 0x10000</expr>)</condition><then> <block>{
<if>if <condition>(<expr>0xD800 &lt;= <name>ch</name> &amp;&amp; <name>ch</name> &lt;= 0xDBFF &amp;&amp; <name>i</name> != <name>size</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>Py_UCS4</name></type> <name>ch2</name> <init>= <expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>0xDC00 &lt;= <name>ch2</name> &amp;&amp; <name>ch2</name> &lt;= 0xDFFF</expr>)</condition><then> <block>{
<expr_stmt><expr><name>ch</name> = ((<name>ch</name> - 0xD800) &lt;&lt; 10 | (<name>ch2</name> - 0xDC00)) + 0x10000</expr>;</expr_stmt>
<expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
<goto>goto <name>encodeUCS4</name>;</goto>
}</block></then></if>
}</block></then></if>
<expr_stmt><expr>*<name>p</name>++ = <call>(<name>char</name>)<argument_list>(<argument><expr>0xe0 | (<name>ch</name> &gt;&gt; 12)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = <call>(<name>char</name>)<argument_list>(<argument><expr>0x80 | ((<name>ch</name> &gt;&gt; 6) &amp; 0x3f)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = <call>(<name>char</name>)<argument_list>(<argument><expr>0x80 | (<name>ch</name> &amp; 0x3f)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
}</block></then></if>
<label><name>encodeUCS4</name>:</label>
<expr_stmt><expr>*<name>p</name>++ = <call>(<name>char</name>)<argument_list>(<argument><expr>0xf0 | (<name>ch</name> &gt;&gt; 18)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = <call>(<name>char</name>)<argument_list>(<argument><expr>0x80 | ((<name>ch</name> &gt;&gt; 12) &amp; 0x3f)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = <call>(<name>char</name>)<argument_list>(<argument><expr>0x80 | ((<name>ch</name> &gt;&gt; 6) &amp; 0x3f)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = <call>(<name>char</name>)<argument_list>(<argument><expr>0x80 | (<name>ch</name> &amp; 0x3f)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if></else></if>
}</block></for>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>nneeded</name> = <name>p</name> - <name>stackbuf</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>nneeded</name> &lt;= <name>nallocated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>v</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>stackbuf</name></expr></argument>, <argument><expr><name>nneeded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>nneeded</name> = <name>p</name> - <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>nneeded</name> &lt;= <name>nallocated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr><name>nneeded</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<return>return <expr><name>v</name></expr>;</return>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>MAX_SHORT_UNICHARS</name></cpp:undef>
}</block></function>
<function><type><name>PyObject</name> *</type><name>PyUnicode_AsUTF8String</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>unicode</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr>!<call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_BadArgument</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>PyUnicode_EncodeUTF8</name><argument_list>(<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type>
<name>PyUnicode_DecodeUTF32</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>,
<param><decl><type><name>int</name> *</type><name>byteorder</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>PyUnicode_DecodeUTF32Stateful</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>, <argument><expr><name>byteorder</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type>
<name>PyUnicode_DecodeUTF32Stateful</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>,
<param><decl><type><name>int</name> *</type><name>byteorder</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name> *</type><name>consumed</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>starts</name> <init>= <expr><name>s</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>startinpos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>endinpos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>outpos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>unicode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>p</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>Py_UNICODE_WIDE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>pairs</name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>pairs</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>q</name></decl>, *<decl><type ref="prev"/><name>e</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bo</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errmsg</name> <init>= <expr>""</expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>BYTEORDER_IS_LITTLE_ENDIAN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name><name>iorder</name><index>[]</index></name> <init>= <expr><block>{<expr>0</expr>, <expr>1</expr>, <expr>2</expr>, <expr>3</expr>}</block></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>int</name></type> <name><name>iorder</name><index>[]</index></name> <init>= <expr><block>{<expr>3</expr>, <expr>2</expr>, <expr>1</expr>, <expr>0</expr>}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>errorHandler</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>exc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>Py_UNICODE_WIDE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<for>for (<init><expr><name>i</name> = <name>pairs</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>size</name>/4</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
<if>if <condition>(<expr>((<name>Py_UCS4</name> *)<name>s</name>)<index>[<expr><name>i</name></expr>]</index> &gt;= 0x10000</expr>)</condition><then>
<expr_stmt><expr><name>pairs</name>++</expr>;</expr_stmt></then></if></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>unicode</name> = <call><name>_PyUnicode_New</name><argument_list>(<argument><expr>(<name>size</name>+3)/4+<name>pairs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>unicode</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>size</name> == 0</expr>)</condition><then>
<return>return <expr>(<name>PyObject</name> *)<name>unicode</name></expr>;</return></then></if>
<expr_stmt><expr><name>p</name> = <name><name>unicode</name>-&gt;<name>str</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>q</name> = (<name>unsigned</name> <name>char</name> *)<name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><name>e</name> = <name>q</name> + <name>size</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>byteorder</name></expr>)</condition><then>
<expr_stmt><expr><name>bo</name> = *<name>byteorder</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>bo</name> == 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>size</name> &gt;= 4</expr>)</condition><then> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>Py_UCS4</name></type> <name>bom</name> <init>= <expr>(<name><name>q</name><index>[<expr><name><name>iorder</name><index>[<expr>3</expr>]</index></name></expr>]</index></name> &lt;&lt; 24) | (<name><name>q</name><index>[<expr><name><name>iorder</name><index>[<expr>2</expr>]</index></name></expr>]</index></name> &lt;&lt; 16) |
(<name><name>q</name><index>[<expr><name><name>iorder</name><index>[<expr>1</expr>]</index></name></expr>]</index></name> &lt;&lt; 8) | <name><name>q</name><index>[<expr><name><name>iorder</name><index>[<expr>0</expr>]</index></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>BYTEORDER_IS_LITTLE_ENDIAN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>bom</name> == 0x0000FEFF</expr>)</condition><then> <block>{
<expr_stmt><expr><name>q</name> += 4</expr>;</expr_stmt>
<expr_stmt><expr><name>bo</name> = -1</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>bom</name> == 0xFFFE0000</expr>)</condition><then> <block>{
<expr_stmt><expr><name>q</name> += 4</expr>;</expr_stmt>
<expr_stmt><expr><name>bo</name> = 1</expr>;</expr_stmt>
}</block></then></if></else></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if>if <condition>(<expr><name>bom</name> == 0x0000FEFF</expr>)</condition><then> <block>{
<expr_stmt><expr><name>q</name> += 4</expr>;</expr_stmt>
<expr_stmt><expr><name>bo</name> = 1</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>bom</name> == 0xFFFE0000</expr>)</condition><then> <block>{
<expr_stmt><expr><name>q</name> += 4</expr>;</expr_stmt>
<expr_stmt><expr><name>bo</name> = -1</expr>;</expr_stmt>
}</block></then></if></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></then></if>
}</block></then></if>
<if>if <condition>(<expr><name>bo</name> == -1</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>iorder</name><index>[<expr>0</expr>]</index></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>iorder</name><index>[<expr>1</expr>]</index></name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name><name>iorder</name><index>[<expr>2</expr>]</index></name> = 2</expr>;</expr_stmt>
<expr_stmt><expr><name><name>iorder</name><index>[<expr>3</expr>]</index></name> = 3</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>bo</name> == 1</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>iorder</name><index>[<expr>0</expr>]</index></name> = 3</expr>;</expr_stmt>
<expr_stmt><expr><name><name>iorder</name><index>[<expr>1</expr>]</index></name> = 2</expr>;</expr_stmt>
<expr_stmt><expr><name><name>iorder</name><index>[<expr>2</expr>]</index></name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name><name>iorder</name><index>[<expr>3</expr>]</index></name> = 0</expr>;</expr_stmt>
}</block></then></if></else></if>
<while>while <condition>(<expr><name>q</name> &lt; <name>e</name></expr>)</condition> <block>{
<decl_stmt><decl><type><name>Py_UCS4</name></type> <name>ch</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>e</name>-<name>q</name>&lt;4</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>consumed</name></expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr><name>errmsg</name> = "truncated data"</expr>;</expr_stmt>
<expr_stmt><expr><name>startinpos</name> = ((const <name>char</name> *)<name>q</name>)-<name>starts</name></expr>;</expr_stmt>
<expr_stmt><expr><name>endinpos</name> = ((const <name>char</name> *)<name>e</name>)-<name>starts</name></expr>;</expr_stmt>
<goto>goto <name>utf32Error</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>ch</name> = (<name><name>q</name><index>[<expr><name><name>iorder</name><index>[<expr>3</expr>]</index></name></expr>]</index></name> &lt;&lt; 24) | (<name><name>q</name><index>[<expr><name><name>iorder</name><index>[<expr>2</expr>]</index></name></expr>]</index></name> &lt;&lt; 16) |
(<name><name>q</name><index>[<expr><name><name>iorder</name><index>[<expr>1</expr>]</index></name></expr>]</index></name> &lt;&lt; 8) | <name><name>q</name><index>[<expr><name><name>iorder</name><index>[<expr>0</expr>]</index></name></expr>]</index></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ch</name> &gt;= 0x110000</expr>)</condition><then> <block>{
<expr_stmt><expr><name>errmsg</name> = "codepoint not in range(0x110000)"</expr>;</expr_stmt>
<expr_stmt><expr><name>startinpos</name> = ((const <name>char</name> *)<name>q</name>)-<name>starts</name></expr>;</expr_stmt>
<expr_stmt><expr><name>endinpos</name> = <name>startinpos</name>+4</expr>;</expr_stmt>
<goto>goto <name>utf32Error</name>;</goto>
}</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>Py_UNICODE_WIDE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>ch</name> &gt;= 0x10000</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>p</name>++ = 0xD800 | ((<name>ch</name>-0x10000) &gt;&gt; 10)</expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = 0xDC00 | ((<name>ch</name>-0x10000) &amp; 0x3FF)</expr>;</expr_stmt>
}</block></then> <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr>*<name>p</name>++ = <name>ch</name></expr>;</expr_stmt></else></if>
<expr_stmt><expr><name>q</name> += 4</expr>;</expr_stmt>
<continue>continue;</continue>
<label><name>utf32Error</name>:</label>
<expr_stmt><expr><name>outpos</name> = <name>p</name>-<call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>unicode_decode_call_errorhandler</name><argument_list>(
<argument><expr><name>errors</name></expr></argument>, <argument><expr>&amp;<name>errorHandler</name></expr></argument>,
<argument><expr>"utf32"</expr></argument>, <argument><expr><name>errmsg</name></expr></argument>,
<argument><expr><name>starts</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr>&amp;<name>startinpos</name></expr></argument>, <argument><expr>&amp;<name>endinpos</name></expr></argument>, <argument><expr>&amp;<name>exc</name></expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>,
<argument><expr>(<name>PyObject</name> **)&amp;<name>unicode</name></expr></argument>, <argument><expr>&amp;<name>outpos</name></expr></argument>, <argument><expr>&amp;<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
}</block></while>
<if>if <condition>(<expr><name>byteorder</name></expr>)</condition><then>
<expr_stmt><expr>*<name>byteorder</name> = <name>bo</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>consumed</name></expr>)</condition><then>
<expr_stmt><expr>*<name>consumed</name> = (const <name>char</name> *)<name>q</name>-<name>starts</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><call><name>_PyUnicode_Resize</name><argument_list>(<argument><expr>&amp;<name>unicode</name></expr></argument>, <argument><expr><name>p</name> - <name><name>unicode</name>-&gt;<name>str</name></name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>errorHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *)<name>unicode</name></expr>;</return>
<label><name>onError</name>:</label>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>errorHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type>
<name>PyUnicode_EncodeUTF32</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>s</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>,
<param><decl><type><name>int</name></type> <name>byteorder</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>nsize</name></decl>, <decl><type ref="prev"/><name>bytesize</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>Py_UNICODE_WIDE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>pairs</name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>pairs</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>BYTEORDER_IS_LITTLE_ENDIAN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name><name>iorder</name><index>[]</index></name> <init>= <expr><block>{<expr>0</expr>, <expr>1</expr>, <expr>2</expr>, <expr>3</expr>}</block></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>int</name></type> <name><name>iorder</name><index>[]</index></name> <init>= <expr><block>{<expr>3</expr>, <expr>2</expr>, <expr>1</expr>, <expr>0</expr>}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STORECHAR</name><parameter_list>(<param><type><name>CH</name></type></param>)</parameter_list></cpp:macro> <cpp:value>do { p[iorder[3]] = ((CH) &gt;&gt; 24) &amp; 0xff; p[iorder[2]] = ((CH) &gt;&gt; 16) &amp; 0xff; p[iorder[1]] = ((CH) &gt;&gt; 8) &amp; 0xff; p[iorder[0]] = (CH) &amp; 0xff; p += 4; } while(0)</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>Py_UNICODE_WIDE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<for>for (<init><expr><name>i</name> = <name>pairs</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>size</name>-1</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
<if>if <condition>(<expr>0xD800 &lt;= <name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> &amp;&amp; <name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> &lt;= 0xDBFF &amp;&amp;
0xDC00 &lt;= <name><name>s</name><index>[<expr><name>i</name>+1</expr>]</index></name> &amp;&amp; <name><name>s</name><index>[<expr><name>i</name>+1</expr>]</index></name> &lt;= 0xDFFF</expr>)</condition><then>
<expr_stmt><expr><name>pairs</name>++</expr>;</expr_stmt></then></if></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>nsize</name> = (<name>size</name> - <name>pairs</name> + (<name>byteorder</name> == 0))</expr>;</expr_stmt>
<expr_stmt><expr><name>bytesize</name> = <name>nsize</name> * 4</expr>;</expr_stmt>
<if>if <condition>(<expr><name>bytesize</name> / 4 != <name>nsize</name></expr>)</condition><then>
<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>v</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>bytesize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>p</name> = (<name>unsigned</name> <name>char</name> *)<call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>byteorder</name> == 0</expr>)</condition><then>
<expr_stmt><expr><call><name>STORECHAR</name><argument_list>(<argument><expr>0xFEFF</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>size</name> == 0</expr>)</condition><then>
<return>return <expr><name>v</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>byteorder</name> == -1</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>iorder</name><index>[<expr>0</expr>]</index></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>iorder</name><index>[<expr>1</expr>]</index></name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name><name>iorder</name><index>[<expr>2</expr>]</index></name> = 2</expr>;</expr_stmt>
<expr_stmt><expr><name><name>iorder</name><index>[<expr>3</expr>]</index></name> = 3</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>byteorder</name> == 1</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>iorder</name><index>[<expr>0</expr>]</index></name> = 3</expr>;</expr_stmt>
<expr_stmt><expr><name><name>iorder</name><index>[<expr>1</expr>]</index></name> = 2</expr>;</expr_stmt>
<expr_stmt><expr><name><name>iorder</name><index>[<expr>2</expr>]</index></name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name><name>iorder</name><index>[<expr>3</expr>]</index></name> = 0</expr>;</expr_stmt>
}</block></then></if></else></if>
<while>while <condition>(<expr><name>size</name>-- &gt; 0</expr>)</condition> <block>{
<decl_stmt><decl><type><name>Py_UCS4</name></type> <name>ch</name> <init>= <expr>*<name>s</name>++</expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>Py_UNICODE_WIDE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr>0xD800 &lt;= <name>ch</name> &amp;&amp; <name>ch</name> &lt;= 0xDBFF &amp;&amp; <name>size</name> &gt; 0</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>Py_UCS4</name></type> <name>ch2</name> <init>= <expr>*<name>s</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>0xDC00 &lt;= <name>ch2</name> &amp;&amp; <name>ch2</name> &lt;= 0xDFFF</expr>)</condition><then> <block>{
<expr_stmt><expr><name>ch</name> = (((<name>ch</name> &amp; 0x3FF)&lt;&lt;10) | (<name>ch2</name> &amp; 0x3FF)) + 0x10000</expr>;</expr_stmt>
<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt>
<expr_stmt><expr><name>size</name>--</expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>STORECHAR</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></while>
<return>return <expr><name>v</name></expr>;</return>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>STORECHAR</name></cpp:undef>
}</block></function>
<function><type><name>PyObject</name> *</type><name>PyUnicode_AsUTF32String</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>unicode</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr>!<call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_BadArgument</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>PyUnicode_EncodeUTF32</name><argument_list>(<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>,
<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type>
<name>PyUnicode_DecodeUTF16</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>,
<param><decl><type><name>int</name> *</type><name>byteorder</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>PyUnicode_DecodeUTF16Stateful</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>, <argument><expr><name>byteorder</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type>
<name>PyUnicode_DecodeUTF16Stateful</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>,
<param><decl><type><name>int</name> *</type><name>byteorder</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name> *</type><name>consumed</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>starts</name> <init>= <expr><name>s</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>startinpos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>endinpos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>outpos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>unicode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>q</name></decl>, *<decl><type ref="prev"/><name>e</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>bo</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errmsg</name> <init>= <expr>""</expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>BYTEORDER_IS_LITTLE_ENDIAN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>ihi</name> <init>= <expr>1</expr></init>, <name>ilo</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>int</name></type> <name>ihi</name> <init>= <expr>0</expr></init>, <name>ilo</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>errorHandler</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>exc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>unicode</name> = <call><name>_PyUnicode_New</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>unicode</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>size</name> == 0</expr>)</condition><then>
<return>return <expr>(<name>PyObject</name> *)<name>unicode</name></expr>;</return></then></if>
<expr_stmt><expr><name>p</name> = <name><name>unicode</name>-&gt;<name>str</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>q</name> = (<name>unsigned</name> <name>char</name> *)<name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><name>e</name> = <name>q</name> + <name>size</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>byteorder</name></expr>)</condition><then>
<expr_stmt><expr><name>bo</name> = *<name>byteorder</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>bo</name> == 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>size</name> &gt;= 2</expr>)</condition><then> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>Py_UNICODE</name></type> <name>bom</name> <init>= <expr>(<name><name>q</name><index>[<expr><name>ihi</name></expr>]</index></name> &lt;&lt; 8) | <name><name>q</name><index>[<expr><name>ilo</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>BYTEORDER_IS_LITTLE_ENDIAN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>bom</name> == 0xFEFF</expr>)</condition><then> <block>{
<expr_stmt><expr><name>q</name> += 2</expr>;</expr_stmt>
<expr_stmt><expr><name>bo</name> = -1</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>bom</name> == 0xFFFE</expr>)</condition><then> <block>{
<expr_stmt><expr><name>q</name> += 2</expr>;</expr_stmt>
<expr_stmt><expr><name>bo</name> = 1</expr>;</expr_stmt>
}</block></then></if></else></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if>if <condition>(<expr><name>bom</name> == 0xFEFF</expr>)</condition><then> <block>{
<expr_stmt><expr><name>q</name> += 2</expr>;</expr_stmt>
<expr_stmt><expr><name>bo</name> = 1</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>bom</name> == 0xFFFE</expr>)</condition><then> <block>{
<expr_stmt><expr><name>q</name> += 2</expr>;</expr_stmt>
<expr_stmt><expr><name>bo</name> = -1</expr>;</expr_stmt>
}</block></then></if></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></then></if>
}</block></then></if>
<if>if <condition>(<expr><name>bo</name> == -1</expr>)</condition><then> <block>{
<expr_stmt><expr><name>ihi</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name>ilo</name> = 0</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>bo</name> == 1</expr>)</condition><then> <block>{
<expr_stmt><expr><name>ihi</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>ilo</name> = 1</expr>;</expr_stmt>
}</block></then></if></else></if>
<while>while <condition>(<expr><name>q</name> &lt; <name>e</name></expr>)</condition> <block>{
<decl_stmt><decl><type><name>Py_UNICODE</name></type> <name>ch</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>e</name>-<name>q</name>&lt;2</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>consumed</name></expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr><name>errmsg</name> = "truncated data"</expr>;</expr_stmt>
<expr_stmt><expr><name>startinpos</name> = ((const <name>char</name> *)<name>q</name>)-<name>starts</name></expr>;</expr_stmt>
<expr_stmt><expr><name>endinpos</name> = ((const <name>char</name> *)<name>e</name>)-<name>starts</name></expr>;</expr_stmt>
<goto>goto <name>utf16Error</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>ch</name> = (<name><name>q</name><index>[<expr><name>ihi</name></expr>]</index></name> &lt;&lt; 8) | <name><name>q</name><index>[<expr><name>ilo</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>q</name> += 2</expr>;</expr_stmt>
<if>if <condition>(<expr><name>ch</name> &lt; 0xD800 || <name>ch</name> &gt; 0xDFFF</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>p</name>++ = <name>ch</name></expr>;</expr_stmt>
<continue>continue;</continue>
}</block></then></if>
<if>if <condition>(<expr><name>q</name> &gt;= <name>e</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>errmsg</name> = "unexpected end of data"</expr>;</expr_stmt>
<expr_stmt><expr><name>startinpos</name> = (((const <name>char</name> *)<name>q</name>)-2)-<name>starts</name></expr>;</expr_stmt>
<expr_stmt><expr><name>endinpos</name> = ((const <name>char</name> *)<name>e</name>)-<name>starts</name></expr>;</expr_stmt>
<goto>goto <name>utf16Error</name>;</goto>
}</block></then></if>
<if>if <condition>(<expr>0xD800 &lt;= <name>ch</name> &amp;&amp; <name>ch</name> &lt;= 0xDBFF</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>Py_UNICODE</name></type> <name>ch2</name> <init>= <expr>(<name><name>q</name><index>[<expr><name>ihi</name></expr>]</index></name> &lt;&lt; 8) | <name><name>q</name><index>[<expr><name>ilo</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>q</name> += 2</expr>;</expr_stmt>
<if>if <condition>(<expr>0xDC00 &lt;= <name>ch2</name> &amp;&amp; <name>ch2</name> &lt;= 0xDFFF</expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>Py_UNICODE_WIDE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr>*<name>p</name>++ = <name>ch</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = <name>ch2</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr>*<name>p</name>++ = (((<name>ch</name> &amp; 0x3FF)&lt;&lt;10) | (<name>ch2</name> &amp; 0x3FF)) + 0x10000</expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<continue>continue;</continue>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>errmsg</name> = "illegal UTF-16 surrogate"</expr>;</expr_stmt>
<expr_stmt><expr><name>startinpos</name> = (((const <name>char</name> *)<name>q</name>)-4)-<name>starts</name></expr>;</expr_stmt>
<expr_stmt><expr><name>endinpos</name> = <name>startinpos</name>+2</expr>;</expr_stmt>
<goto>goto <name>utf16Error</name>;</goto>
}</block></else></if>
}</block></then></if>
<expr_stmt><expr><name>errmsg</name> = "illegal encoding"</expr>;</expr_stmt>
<expr_stmt><expr><name>startinpos</name> = (((const <name>char</name> *)<name>q</name>)-2)-<name>starts</name></expr>;</expr_stmt>
<expr_stmt><expr><name>endinpos</name> = <name>startinpos</name>+2</expr>;</expr_stmt>
<label><name>utf16Error</name>:</label>
<expr_stmt><expr><name>outpos</name> = <name>p</name>-<call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>unicode_decode_call_errorhandler</name><argument_list>(
<argument><expr><name>errors</name></expr></argument>, <argument><expr>&amp;<name>errorHandler</name></expr></argument>,
<argument><expr>"utf16"</expr></argument>, <argument><expr><name>errmsg</name></expr></argument>,
<argument><expr><name>starts</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr>&amp;<name>startinpos</name></expr></argument>, <argument><expr>&amp;<name>endinpos</name></expr></argument>, <argument><expr>&amp;<name>exc</name></expr></argument>, <argument><expr>(const <name>char</name> **)&amp;<name>q</name></expr></argument>,
<argument><expr>(<name>PyObject</name> **)&amp;<name>unicode</name></expr></argument>, <argument><expr>&amp;<name>outpos</name></expr></argument>, <argument><expr>&amp;<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
}</block></while>
<if>if <condition>(<expr><name>byteorder</name></expr>)</condition><then>
<expr_stmt><expr>*<name>byteorder</name> = <name>bo</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>consumed</name></expr>)</condition><then>
<expr_stmt><expr>*<name>consumed</name> = (const <name>char</name> *)<name>q</name>-<name>starts</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><call><name>_PyUnicode_Resize</name><argument_list>(<argument><expr>&amp;<name>unicode</name></expr></argument>, <argument><expr><name>p</name> - <name><name>unicode</name>-&gt;<name>str</name></name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>errorHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *)<name>unicode</name></expr>;</return>
<label><name>onError</name>:</label>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>errorHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type>
<name>PyUnicode_EncodeUTF16</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>s</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>,
<param><decl><type><name>int</name></type> <name>byteorder</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>nsize</name></decl>, <decl><type ref="prev"/><name>bytesize</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_UNICODE_WIDE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>pairs</name></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>pairs</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>BYTEORDER_IS_LITTLE_ENDIAN</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>int</name></type> <name>ihi</name> <init>= <expr>1</expr></init>, <name>ilo</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>int</name></type> <name>ihi</name> <init>= <expr>0</expr></init>, <name>ilo</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STORECHAR</name><parameter_list>(<param><type><name>CH</name></type></param>)</parameter_list></cpp:macro> <cpp:value>do { p[ihi] = ((CH) &gt;&gt; 8) &amp; 0xff; p[ilo] = (CH) &amp; 0xff; p += 2; } while(0)</cpp:value></cpp:define>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_UNICODE_WIDE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<for>for (<init><expr><name>i</name> = <name>pairs</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>size</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
<if>if <condition>(<expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name> &gt;= 0x10000</expr>)</condition><then>
<expr_stmt><expr><name>pairs</name>++</expr>;</expr_stmt></then></if></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><name>size</name> &gt; <name>PY_SSIZE_T_MAX</name> ||
<name>size</name> &gt; <name>PY_SSIZE_T_MAX</name> - <name>pairs</name> - (<name>byteorder</name> == 0)</expr>)</condition><then>
<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>nsize</name> = <name>size</name> + <name>pairs</name> + (<name>byteorder</name> == 0)</expr>;</expr_stmt>
<expr_stmt><expr><name>bytesize</name> = <name>nsize</name> * 2</expr>;</expr_stmt>
<if>if <condition>(<expr><name>bytesize</name> / 2 != <name>nsize</name></expr>)</condition><then>
<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>v</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>bytesize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>p</name> = (<name>unsigned</name> <name>char</name> *)<call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>byteorder</name> == 0</expr>)</condition><then>
<expr_stmt><expr><call><name>STORECHAR</name><argument_list>(<argument><expr>0xFEFF</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>size</name> == 0</expr>)</condition><then>
<return>return <expr><name>v</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>byteorder</name> == -1</expr>)</condition><then> <block>{
<expr_stmt><expr><name>ihi</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name>ilo</name> = 0</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>byteorder</name> == 1</expr>)</condition><then> <block>{
<expr_stmt><expr><name>ihi</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>ilo</name> = 1</expr>;</expr_stmt>
}</block></then></if></else></if>
<while>while <condition>(<expr><name>size</name>-- &gt; 0</expr>)</condition> <block>{
<decl_stmt><decl><type><name>Py_UNICODE</name></type> <name>ch</name> <init>= <expr>*<name>s</name>++</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UNICODE</name></type> <name>ch2</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_UNICODE_WIDE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>ch</name> &gt;= 0x10000</expr>)</condition><then> <block>{
<expr_stmt><expr><name>ch2</name> = 0xDC00 | ((<name>ch</name>-0x10000) &amp; 0x3FF)</expr>;</expr_stmt>
<expr_stmt><expr><name>ch</name> = 0xD800 | ((<name>ch</name>-0x10000) &gt;&gt; 10)</expr>;</expr_stmt>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>STORECHAR</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ch2</name></expr>)</condition><then>
<expr_stmt><expr><call><name>STORECHAR</name><argument_list>(<argument><expr><name>ch2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></while>
<return>return <expr><name>v</name></expr>;</return>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>STORECHAR</name></cpp:undef>
}</block></function>
<function><type><name>PyObject</name> *</type><name>PyUnicode_AsUTF16String</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>unicode</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr>!<call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_BadArgument</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>PyUnicode_EncodeUTF16</name><argument_list>(<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>,
<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <name>_PyUnicode_Name_CAPI</name> *</type><name>ucnhash_CAPI</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<function><type><name>PyObject</name> *</type><name>PyUnicode_DecodeUnicodeEscape</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>starts</name> <init>= <expr><name>s</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>startinpos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>endinpos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>outpos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>*</type> <name>message</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UCS4</name></type> <name>chr</name> <init>= <expr>0xffffffff</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>errorHandler</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>exc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>v</name> = <call><name>_PyUnicode_New</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<if>if <condition>(<expr><name>size</name> == 0</expr>)</condition><then>
<return>return <expr>(<name>PyObject</name> *)<name>v</name></expr>;</return></then></if>
<expr_stmt><expr><name>p</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>end</name> = <name>s</name> + <name>size</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>s</name> &lt; <name>end</name></expr>)</condition> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UNICODE</name></type> <name>x</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>digits</name></decl>;</decl_stmt>
<if>if <condition>(<expr>*<name>s</name> != '\\'</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>p</name>++ = (<name>unsigned</name> <name>char</name>) *<name>s</name>++</expr>;</expr_stmt>
<continue>continue;</continue>
}</block></then></if>
<expr_stmt><expr><name>startinpos</name> = <name>s</name>-<name>starts</name></expr>;</expr_stmt>
<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> = *<name>s</name>++</expr>;</expr_stmt>
<if>if <condition>(<expr><name>s</name> &gt; <name>end</name></expr>)</condition><then>
<expr_stmt><expr><name>c</name> = '\0'</expr>;</expr_stmt></then></if>
<switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{
<case>case <expr>'\n'</expr>:
<break>break;</break>
</case><case>case <expr>'\\'</expr>:
<expr_stmt><expr>*<name>p</name>++ = '\\'</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'\''</expr>:
<expr_stmt><expr>*<name>p</name>++ = '\''</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'\"'</expr>:
<expr_stmt><expr>*<name>p</name>++ = '\"'</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'b'</expr>:
<expr_stmt><expr>*<name>p</name>++ = '\b'</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'f'</expr>:
<expr_stmt><expr>*<name>p</name>++ = '\014'</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'t'</expr>:
<expr_stmt><expr>*<name>p</name>++ = '\t'</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'n'</expr>:
<expr_stmt><expr>*<name>p</name>++ = '\n'</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'r'</expr>:
<expr_stmt><expr>*<name>p</name>++ = '\r'</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'v'</expr>:
<expr_stmt><expr>*<name>p</name>++ = '\013'</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'a'</expr>:
<expr_stmt><expr>*<name>p</name>++ = '\007'</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'0'</expr>:
</case><case>case <expr>'1'</expr>:
</case><case>case <expr>'2'</expr>:
</case><case>case <expr>'3'</expr>:
</case><case>case <expr>'4'</expr>:
</case><case>case <expr>'5'</expr>:
</case><case>case <expr>'6'</expr>:
</case><case>case <expr>'7'</expr>:
<expr_stmt><expr><name>x</name> = <name><name>s</name><index>[<expr>-1</expr>]</index></name> - '0'</expr>;</expr_stmt>
<if>if <condition>(<expr><name>s</name> &lt; <name>end</name> &amp;&amp; '0' &lt;= *<name>s</name> &amp;&amp; *<name>s</name> &lt;= '7'</expr>)</condition><then> <block>{
<expr_stmt><expr><name>x</name> = (<name>x</name>&lt;&lt;3) + *<name>s</name>++ - '0'</expr>;</expr_stmt>
<if>if <condition>(<expr><name>s</name> &lt; <name>end</name> &amp;&amp; '0' &lt;= *<name>s</name> &amp;&amp; *<name>s</name> &lt;= '7'</expr>)</condition><then>
<expr_stmt><expr><name>x</name> = (<name>x</name>&lt;&lt;3) + *<name>s</name>++ - '0'</expr>;</expr_stmt></then></if>
}</block></then></if>
<expr_stmt><expr>*<name>p</name>++ = <name>x</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'x'</expr>:
<expr_stmt><expr><name>digits</name> = 2</expr>;</expr_stmt>
<expr_stmt><expr><name>message</name> = "truncated \\xXX escape"</expr>;</expr_stmt>
<goto>goto <name>hexescape</name>;</goto>
</case><case>case <expr>'u'</expr>:
<expr_stmt><expr><name>digits</name> = 4</expr>;</expr_stmt>
<expr_stmt><expr><name>message</name> = "truncated \\uXXXX escape"</expr>;</expr_stmt>
<goto>goto <name>hexescape</name>;</goto>
</case><case>case <expr>'U'</expr>:
<expr_stmt><expr><name>digits</name> = 8</expr>;</expr_stmt>
<expr_stmt><expr><name>message</name> = "truncated \\UXXXXXXXX escape"</expr>;</expr_stmt>
<label><name>hexescape</name>:</label>
<expr_stmt><expr><name>chr</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>outpos</name> = <name>p</name>-<call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>s</name>+<name>digits</name>&gt;<name>end</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>endinpos</name> = <name>size</name></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>unicode_decode_call_errorhandler</name><argument_list>(
<argument><expr><name>errors</name></expr></argument>, <argument><expr>&amp;<name>errorHandler</name></expr></argument>,
<argument><expr>"unicodeescape"</expr></argument>, <argument><expr>"end of string in escape sequence"</expr></argument>,
<argument><expr><name>starts</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr>&amp;<name>startinpos</name></expr></argument>, <argument><expr>&amp;<name>endinpos</name></expr></argument>, <argument><expr>&amp;<name>exc</name></expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>,
<argument><expr>(<name>PyObject</name> **)&amp;<name>v</name></expr></argument>, <argument><expr>&amp;<name>outpos</name></expr></argument>, <argument><expr>&amp;<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<goto>goto <name>nextByte</name>;</goto>
}</block></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>digits</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<expr_stmt><expr><name>c</name> = (<name>unsigned</name> <name>char</name>) <name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>isxdigit</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>endinpos</name> = (<name>s</name>+<name>i</name>+1)-<name>starts</name></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>unicode_decode_call_errorhandler</name><argument_list>(
<argument><expr><name>errors</name></expr></argument>, <argument><expr>&amp;<name>errorHandler</name></expr></argument>,
<argument><expr>"unicodeescape"</expr></argument>, <argument><expr><name>message</name></expr></argument>,
<argument><expr><name>starts</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr>&amp;<name>startinpos</name></expr></argument>, <argument><expr>&amp;<name>endinpos</name></expr></argument>, <argument><expr>&amp;<name>exc</name></expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>,
<argument><expr>(<name>PyObject</name> **)&amp;<name>v</name></expr></argument>, <argument><expr>&amp;<name>outpos</name></expr></argument>, <argument><expr>&amp;<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<goto>goto <name>nextByte</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>chr</name> = (<name>chr</name>&lt;&lt;4) &amp; ~0xF</expr>;</expr_stmt>
<if>if <condition>(<expr><name>c</name> &gt;= '0' &amp;&amp; <name>c</name> &lt;= '9'</expr>)</condition><then>
<expr_stmt><expr><name>chr</name> += <name>c</name> - '0'</expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name>c</name> &gt;= 'a' &amp;&amp; <name>c</name> &lt;= 'f'</expr>)</condition><then>
<expr_stmt><expr><name>chr</name> += 10 + <name>c</name> - 'a'</expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>chr</name> += 10 + <name>c</name> - 'A'</expr>;</expr_stmt></else></if></else></if>
}</block></for>
<expr_stmt><expr><name>s</name> += <name>i</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>chr</name> == 0xffffffff &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<break>break;</break></then></if>
<label><name>store</name>:</label>
<if>if <condition>(<expr><name>chr</name> &lt;= 0xffff</expr>)</condition><then>
<expr_stmt><expr>*<name>p</name>++ = (<name>Py_UNICODE</name>) <name>chr</name></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name>chr</name> &lt;= 0x10ffff</expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_UNICODE_WIDE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr>*<name>p</name>++ = <name>chr</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>chr</name> -= 0x10000L</expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = 0xD800 + <call>(<name>Py_UNICODE</name>) <argument_list>(<argument><expr><name>chr</name> &gt;&gt; 10</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = 0xDC00 + <call>(<name>Py_UNICODE</name>) <argument_list>(<argument><expr><name>chr</name> &amp; 0x03FF</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>endinpos</name> = <name>s</name>-<name>starts</name></expr>;</expr_stmt>
<expr_stmt><expr><name>outpos</name> = <name>p</name>-<call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>unicode_decode_call_errorhandler</name><argument_list>(
<argument><expr><name>errors</name></expr></argument>, <argument><expr>&amp;<name>errorHandler</name></expr></argument>,
<argument><expr>"unicodeescape"</expr></argument>, <argument><expr>"illegal Unicode character"</expr></argument>,
<argument><expr><name>starts</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr>&amp;<name>startinpos</name></expr></argument>, <argument><expr>&amp;<name>endinpos</name></expr></argument>, <argument><expr>&amp;<name>exc</name></expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>,
<argument><expr>(<name>PyObject</name> **)&amp;<name>v</name></expr></argument>, <argument><expr>&amp;<name>outpos</name></expr></argument>, <argument><expr>&amp;<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
}</block></else></if></else></if>
<break>break;</break>
</case><case>case <expr>'N'</expr>:
<expr_stmt><expr><name>message</name> = "malformed \\N character escape"</expr>;</expr_stmt>
<if>if <condition>(<expr><name>ucnhash_CAPI</name> == <name>NULL</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>m</name></decl>, *<decl><type ref="prev"/><name>api</name></decl>;</decl_stmt>
<expr_stmt><expr><name>m</name> = <call><name>PyImport_ImportModuleNoBlock</name><argument_list>(<argument><expr>"unicodedata"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>m</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>ucnhashError</name>;</goto></then></if>
<expr_stmt><expr><name>api</name> = <call><name>PyObject_GetAttrString</name><argument_list>(<argument><expr><name>m</name></expr></argument>, <argument><expr>"ucnhash_CAPI"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>api</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>ucnhashError</name>;</goto></then></if>
<expr_stmt><expr><name>ucnhash_CAPI</name> = (<name>_PyUnicode_Name_CAPI</name> *)<call><name>PyCObject_AsVoidPtr</name><argument_list>(<argument><expr><name>api</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>api</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ucnhash_CAPI</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>ucnhashError</name>;</goto></then></if>
}</block></then></if>
<if>if <condition>(<expr>*<name>s</name> == '{'</expr>)</condition><then> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>start</name> <init>= <expr><name>s</name>+1</expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr>*<name>s</name> != '}' &amp;&amp; <name>s</name> &lt; <name>end</name></expr>)</condition>
<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt></while>
<if>if <condition>(<expr><name>s</name> &gt; <name>start</name> &amp;&amp; <name>s</name> &lt; <name>end</name> &amp;&amp; *<name>s</name> == '}'</expr>)</condition><then> <block>{
<expr_stmt><expr><name>message</name> = "unknown Unicode character name"</expr>;</expr_stmt>
<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt>
<if>if <condition>(<expr><call><name><name>ucnhash_CAPI</name>-&gt;<name>getcode</name></name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><call>(<name>int</name>)<argument_list>(<argument><expr><name>s</name>-<name>start</name>-1</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>chr</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<goto>goto <name>store</name>;</goto></then></if>
}</block></then></if>
}</block></then></if>
<expr_stmt><expr><name>endinpos</name> = <name>s</name>-<name>starts</name></expr>;</expr_stmt>
<expr_stmt><expr><name>outpos</name> = <name>p</name>-<call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>unicode_decode_call_errorhandler</name><argument_list>(
<argument><expr><name>errors</name></expr></argument>, <argument><expr>&amp;<name>errorHandler</name></expr></argument>,
<argument><expr>"unicodeescape"</expr></argument>, <argument><expr><name>message</name></expr></argument>,
<argument><expr><name>starts</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr>&amp;<name>startinpos</name></expr></argument>, <argument><expr>&amp;<name>endinpos</name></expr></argument>, <argument><expr>&amp;<name>exc</name></expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>,
<argument><expr>(<name>PyObject</name> **)&amp;<name>v</name></expr></argument>, <argument><expr>&amp;<name>outpos</name></expr></argument>, <argument><expr>&amp;<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<break>break;</break>
</case><default>default:
<if>if <condition>(<expr><name>s</name> &gt; <name>end</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>message</name> = "\\ at end of string"</expr>;</expr_stmt>
<expr_stmt><expr><name>s</name>--</expr>;</expr_stmt>
<expr_stmt><expr><name>endinpos</name> = <name>s</name>-<name>starts</name></expr>;</expr_stmt>
<expr_stmt><expr><name>outpos</name> = <name>p</name>-<call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>unicode_decode_call_errorhandler</name><argument_list>(
<argument><expr><name>errors</name></expr></argument>, <argument><expr>&amp;<name>errorHandler</name></expr></argument>,
<argument><expr>"unicodeescape"</expr></argument>, <argument><expr><name>message</name></expr></argument>,
<argument><expr><name>starts</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr>&amp;<name>startinpos</name></expr></argument>, <argument><expr>&amp;<name>endinpos</name></expr></argument>, <argument><expr>&amp;<name>exc</name></expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>,
<argument><expr>(<name>PyObject</name> **)&amp;<name>v</name></expr></argument>, <argument><expr>&amp;<name>outpos</name></expr></argument>, <argument><expr>&amp;<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
}</block></then> <else>else <block>{
<expr_stmt><expr>*<name>p</name>++ = '\\'</expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = (<name>unsigned</name> <name>char</name>)<name><name>s</name><index>[<expr>-1</expr>]</index></name></expr>;</expr_stmt>
}</block></else></if>
<break>break;</break>
</default>}</block></switch>
<label><name>nextByte</name>:</label>
<empty_stmt>;</empty_stmt>
}</block></while>
<if>if <condition>(<expr><call><name>_PyUnicode_Resize</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr><name>p</name> - <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>errorHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *)<name>v</name></expr>;</return>
<label><name>ucnhashError</name>:</label>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(
<argument><expr><name>PyExc_UnicodeError</name></expr></argument>,
<argument><expr>"\\N escapes not supported (can't load unicodedata module)"</expr></argument>
)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>errorHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
<label><name>onError</name>:</label>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>errorHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<macro><name>Py_LOCAL_INLINE</name><argument_list>(<argument>const Py_UNICODE *</argument>)</argument_list></macro> <macro><name>findchar</name><argument_list>(<argument>const Py_UNICODE *s</argument>,
<argument>Py_ssize_t size</argument>,
<argument>Py_UNICODE ch</argument>)</argument_list></macro> <block>{
<while>while <condition>(<expr><name>size</name>-- &gt; 0</expr>)</condition> <block>{
<if>if <condition>(<expr>*<name>s</name> == <name>ch</name></expr>)</condition><then>
<return>return <expr><name>s</name></expr>;</return></then></if>
<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt>
}</block></while>
<return>return <expr><name>NULL</name></expr>;</return>
}</block>
<function><type><specifier>static</specifier>
<name>PyObject</name> *</type><name>unicodeescape_string</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>s</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>,
<param><decl><type><name>int</name></type> <name>quotes</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>repr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>hexdigit</name> <init>= <expr>"0123456789abcdef"</expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_UNICODE_WIDE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>const</specifier> <name>Py_ssize_t</name></type> <name>expandsize</name> <init>= <expr>10</expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><specifier>const</specifier> <name>Py_ssize_t</name></type> <name>expandsize</name> <init>= <expr>6</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><name>size</name> &gt; (<name>PY_SSIZE_T_MAX</name> - 2 - 1) / <name>expandsize</name></expr>)</condition><then>
<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>repr</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
<argument><expr>2
+ <name>expandsize</name>*<name>size</name>
+ 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>repr</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>p</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>repr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>quotes</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>p</name>++ = 'u'</expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = (<call><name>findchar</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr>'\''</expr></argument>)</argument_list></call> &amp;&amp;
!<call><name>findchar</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr>'"'</expr></argument>)</argument_list></call>) ? '"' : '\''</expr>;</expr_stmt>
}</block></then></if>
<while>while <condition>(<expr><name>size</name>-- &gt; 0</expr>)</condition> <block>{
<decl_stmt><decl><type><name>Py_UNICODE</name></type> <name>ch</name> <init>= <expr>*<name>s</name>++</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>(<name>quotes</name> &amp;&amp;
<name>ch</name> == (<name>Py_UNICODE</name>) <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>repr</name></expr></argument>)</argument_list></call><index>[<expr>1</expr>]</index>) || <name>ch</name> == '\\'</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>p</name>++ = '\\'</expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = (<name>char</name>) <name>ch</name></expr>;</expr_stmt>
<continue>continue;</continue>
}</block></then>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_UNICODE_WIDE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<else>else <if>if <condition>(<expr><name>ch</name> &gt;= 0x10000</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>p</name>++ = '\\'</expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = 'U'</expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr>(<name>ch</name> &gt;&gt; 28) &amp; 0x0000000F</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr>(<name>ch</name> &gt;&gt; 24) &amp; 0x0000000F</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr>(<name>ch</name> &gt;&gt; 20) &amp; 0x0000000F</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr>(<name>ch</name> &gt;&gt; 16) &amp; 0x0000000F</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr>(<name>ch</name> &gt;&gt; 12) &amp; 0x0000000F</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr>(<name>ch</name> &gt;&gt; 8) &amp; 0x0000000F</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr>(<name>ch</name> &gt;&gt; 4) &amp; 0x0000000F</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr><name>ch</name> &amp; 0x0000000F</expr>]</index></name></expr>;</expr_stmt>
<continue>continue;</continue>
}</block></then>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<else>else <if>if <condition>(<expr><name>ch</name> &gt;= 0xD800 &amp;&amp; <name>ch</name> &lt; 0xDC00</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>Py_UNICODE</name></type> <name>ch2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UCS4</name></type> <name>ucs</name></decl>;</decl_stmt>
<expr_stmt><expr><name>ch2</name> = *<name>s</name>++</expr>;</expr_stmt>
<expr_stmt><expr><name>size</name>--</expr>;</expr_stmt>
<if>if <condition>(<expr><name>ch2</name> &gt;= 0xDC00 &amp;&amp; <name>ch2</name> &lt;= 0xDFFF</expr>)</condition><then> <block>{
<expr_stmt><expr><name>ucs</name> = (((<name>ch</name> &amp; 0x03FF) &lt;&lt; 10) | (<name>ch2</name> &amp; 0x03FF)) + 0x00010000</expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = '\\'</expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = 'U'</expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr>(<name>ucs</name> &gt;&gt; 28) &amp; 0x0000000F</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr>(<name>ucs</name> &gt;&gt; 24) &amp; 0x0000000F</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr>(<name>ucs</name> &gt;&gt; 20) &amp; 0x0000000F</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr>(<name>ucs</name> &gt;&gt; 16) &amp; 0x0000000F</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr>(<name>ucs</name> &gt;&gt; 12) &amp; 0x0000000F</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr>(<name>ucs</name> &gt;&gt; 8) &amp; 0x0000000F</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr>(<name>ucs</name> &gt;&gt; 4) &amp; 0x0000000F</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr><name>ucs</name> &amp; 0x0000000F</expr>]</index></name></expr>;</expr_stmt>
<continue>continue;</continue>
}</block></then></if>
<expr_stmt><expr><name>s</name>--</expr>;</expr_stmt>
<expr_stmt><expr><name>size</name>++</expr>;</expr_stmt>
}</block></then></if></else></if></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><name>ch</name> &gt;= 256</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>p</name>++ = '\\'</expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = 'u'</expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr>(<name>ch</name> &gt;&gt; 12) &amp; 0x000F</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr>(<name>ch</name> &gt;&gt; 8) &amp; 0x000F</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr>(<name>ch</name> &gt;&gt; 4) &amp; 0x000F</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr><name>ch</name> &amp; 0x000F</expr>]</index></name></expr>;</expr_stmt>
}</block></then>
<else>else <if>if <condition>(<expr><name>ch</name> == '\t'</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>p</name>++ = '\\'</expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = 't'</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>ch</name> == '\n'</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>p</name>++ = '\\'</expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = 'n'</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>ch</name> == '\r'</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>p</name>++ = '\\'</expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = 'r'</expr>;</expr_stmt>
}</block></then>
<else>else <if>if <condition>(<expr><name>ch</name> &lt; ' ' || <name>ch</name> &gt;= 0x7F</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>p</name>++ = '\\'</expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = 'x'</expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr>(<name>ch</name> &gt;&gt; 4) &amp; 0x000F</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr><name>ch</name> &amp; 0x000F</expr>]</index></name></expr>;</expr_stmt>
}</block></then>
<else>else
<expr_stmt><expr>*<name>p</name>++ = (<name>char</name>) <name>ch</name></expr>;</expr_stmt></else></if></else></if></else></if></else></if></else></if>
}</block></while>
<if>if <condition>(<expr><name>quotes</name></expr>)</condition><then>
<expr_stmt><expr>*<name>p</name>++ = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>repr</name></expr></argument>)</argument_list></call><index>[<expr>1</expr>]</index></expr>;</expr_stmt></then></if>
<expr_stmt><expr>*<name>p</name> = '\0'</expr>;</expr_stmt>
<expr_stmt><expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>repr</name></expr></argument>, <argument><expr><name>p</name> - <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>repr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>repr</name></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type><name>PyUnicode_EncodeUnicodeEscape</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>s</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>unicodeescape_string</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type><name>PyUnicode_AsUnicodeEscapeString</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>unicode</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr>!<call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_BadArgument</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>PyUnicode_EncodeUnicodeEscape</name><argument_list>(<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type><name>PyUnicode_DecodeRawUnicodeEscape</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>starts</name> <init>= <expr><name>s</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>startinpos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>endinpos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>outpos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>bs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>errorHandler</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>exc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>v</name> = <call><name>_PyUnicode_New</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<if>if <condition>(<expr><name>size</name> == 0</expr>)</condition><then>
<return>return <expr>(<name>PyObject</name> *)<name>v</name></expr>;</return></then></if>
<expr_stmt><expr><name>p</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>end</name> = <name>s</name> + <name>size</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>s</name> &lt; <name>end</name></expr>)</condition> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>c</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UCS4</name></type> <name>x</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>count</name></decl>;</decl_stmt>
<if>if <condition>(<expr>*<name>s</name> != '\\'</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>p</name>++ = (<name>unsigned</name> <name>char</name>)*<name>s</name>++</expr>;</expr_stmt>
<continue>continue;</continue>
}</block></then></if>
<expr_stmt><expr><name>startinpos</name> = <name>s</name>-<name>starts</name></expr>;</expr_stmt>
<expr_stmt><expr><name>bs</name> = <name>s</name></expr>;</expr_stmt>
<for>for (<init>;</init> <condition><expr><name>s</name> &lt; <name>end</name></expr>;</condition><incr/>) <block>{
<if>if <condition>(<expr>*<name>s</name> != '\\'</expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr>*<name>p</name>++ = (<name>unsigned</name> <name>char</name>)*<name>s</name>++</expr>;</expr_stmt>
}</block></for>
<if>if <condition>(<expr>((<name>s</name> - <name>bs</name>) &amp; 1) == 0 ||
<name>s</name> &gt;= <name>end</name> ||
(*<name>s</name> != 'u' &amp;&amp; *<name>s</name> != 'U')</expr>)</condition><then> <block>{
<continue>continue;</continue>
}</block></then></if>
<expr_stmt><expr><name>p</name>--</expr>;</expr_stmt>
<expr_stmt><expr><name>count</name> = *<name>s</name>=='u' ? 4 : 8</expr>;</expr_stmt>
<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt>
<expr_stmt><expr><name>outpos</name> = <name>p</name>-<call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>x</name> = 0</expr>, <expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>count</name></expr>;</condition> <incr><expr>++<name>i</name></expr>, <expr>++<name>s</name></expr></incr>) <block>{
<expr_stmt><expr><name>c</name> = (<name>unsigned</name> <name>char</name>)*<name>s</name></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>isxdigit</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>endinpos</name> = <name>s</name>-<name>starts</name></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>unicode_decode_call_errorhandler</name><argument_list>(
<argument><expr><name>errors</name></expr></argument>, <argument><expr>&amp;<name>errorHandler</name></expr></argument>,
<argument><expr>"rawunicodeescape"</expr></argument>, <argument><expr>"truncated \\uXXXX"</expr></argument>,
<argument><expr><name>starts</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr>&amp;<name>startinpos</name></expr></argument>, <argument><expr>&amp;<name>endinpos</name></expr></argument>, <argument><expr>&amp;<name>exc</name></expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>,
<argument><expr>(<name>PyObject</name> **)&amp;<name>v</name></expr></argument>, <argument><expr>&amp;<name>outpos</name></expr></argument>, <argument><expr>&amp;<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<goto>goto <name>nextByte</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>x</name> = (<name>x</name>&lt;&lt;4) &amp; ~0xF</expr>;</expr_stmt>
<if>if <condition>(<expr><name>c</name> &gt;= '0' &amp;&amp; <name>c</name> &lt;= '9'</expr>)</condition><then>
<expr_stmt><expr><name>x</name> += <name>c</name> - '0'</expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name>c</name> &gt;= 'a' &amp;&amp; <name>c</name> &lt;= 'f'</expr>)</condition><then>
<expr_stmt><expr><name>x</name> += 10 + <name>c</name> - 'a'</expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>x</name> += 10 + <name>c</name> - 'A'</expr>;</expr_stmt></else></if></else></if>
}</block></for>
<if>if <condition>(<expr><name>x</name> &lt;= 0xffff</expr>)</condition><then>
<expr_stmt><expr>*<name>p</name>++ = (<name>Py_UNICODE</name>) <name>x</name></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name>x</name> &lt;= 0x10ffff</expr>)</condition><then> <block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_UNICODE_WIDE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr_stmt><expr>*<name>p</name>++ = (<name>Py_UNICODE</name>) <name>x</name></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>x</name> -= 0x10000L</expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = 0xD800 + <call>(<name>Py_UNICODE</name>) <argument_list>(<argument><expr><name>x</name> &gt;&gt; 10</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = 0xDC00 + <call>(<name>Py_UNICODE</name>) <argument_list>(<argument><expr><name>x</name> &amp; 0x03FF</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>endinpos</name> = <name>s</name>-<name>starts</name></expr>;</expr_stmt>
<expr_stmt><expr><name>outpos</name> = <name>p</name>-<call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>unicode_decode_call_errorhandler</name><argument_list>(
<argument><expr><name>errors</name></expr></argument>, <argument><expr>&amp;<name>errorHandler</name></expr></argument>,
<argument><expr>"rawunicodeescape"</expr></argument>, <argument><expr>"\\Uxxxxxxxx out of range"</expr></argument>,
<argument><expr><name>starts</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr>&amp;<name>startinpos</name></expr></argument>, <argument><expr>&amp;<name>endinpos</name></expr></argument>, <argument><expr>&amp;<name>exc</name></expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>,
<argument><expr>(<name>PyObject</name> **)&amp;<name>v</name></expr></argument>, <argument><expr>&amp;<name>outpos</name></expr></argument>, <argument><expr>&amp;<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
}</block></else></if></else></if>
<label><name>nextByte</name>:</label>
<empty_stmt>;</empty_stmt>
}</block></while>
<if>if <condition>(<expr><call><name>_PyUnicode_Resize</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr><name>p</name> - <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>errorHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *)<name>v</name></expr>;</return>
<label><name>onError</name>:</label>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>errorHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type><name>PyUnicode_EncodeRawUnicodeEscape</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>s</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>repr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>q</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>hexdigit</name> <init>= <expr>"0123456789abcdef"</expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_UNICODE_WIDE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><specifier>const</specifier> <name>Py_ssize_t</name></type> <name>expandsize</name> <init>= <expr>10</expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><specifier>const</specifier> <name>Py_ssize_t</name></type> <name>expandsize</name> <init>= <expr>6</expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><name>size</name> &gt; <name>PY_SSIZE_T_MAX</name> / <name>expandsize</name></expr>)</condition><then>
<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>repr</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>expandsize</name> * <name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>repr</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>size</name> == 0</expr>)</condition><then>
<return>return <expr><name>repr</name></expr>;</return></then></if>
<expr_stmt><expr><name>p</name> = <name>q</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>repr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>size</name>-- &gt; 0</expr>)</condition> <block>{
<decl_stmt><decl><type><name>Py_UNICODE</name></type> <name>ch</name> <init>= <expr>*<name>s</name>++</expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_UNICODE_WIDE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>ch</name> &gt;= 0x10000</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>p</name>++ = '\\'</expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = 'U'</expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr>(<name>ch</name> &gt;&gt; 28) &amp; 0xf</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr>(<name>ch</name> &gt;&gt; 24) &amp; 0xf</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr>(<name>ch</name> &gt;&gt; 20) &amp; 0xf</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr>(<name>ch</name> &gt;&gt; 16) &amp; 0xf</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr>(<name>ch</name> &gt;&gt; 12) &amp; 0xf</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr>(<name>ch</name> &gt;&gt; 8) &amp; 0xf</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr>(<name>ch</name> &gt;&gt; 4) &amp; 0xf</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr><name>ch</name> &amp; 15</expr>]</index></name></expr>;</expr_stmt>
}</block></then> <else>else
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if>if <condition>(<expr><name>ch</name> &gt;= 0xD800 &amp;&amp; <name>ch</name> &lt; 0xDC00</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>Py_UNICODE</name></type> <name>ch2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UCS4</name></type> <name>ucs</name></decl>;</decl_stmt>
<expr_stmt><expr><name>ch2</name> = *<name>s</name>++</expr>;</expr_stmt>
<expr_stmt><expr><name>size</name>--</expr>;</expr_stmt>
<if>if <condition>(<expr><name>ch2</name> &gt;= 0xDC00 &amp;&amp; <name>ch2</name> &lt;= 0xDFFF</expr>)</condition><then> <block>{
<expr_stmt><expr><name>ucs</name> = (((<name>ch</name> &amp; 0x03FF) &lt;&lt; 10) | (<name>ch2</name> &amp; 0x03FF)) + 0x00010000</expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = '\\'</expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = 'U'</expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr>(<name>ucs</name> &gt;&gt; 28) &amp; 0xf</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr>(<name>ucs</name> &gt;&gt; 24) &amp; 0xf</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr>(<name>ucs</name> &gt;&gt; 20) &amp; 0xf</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr>(<name>ucs</name> &gt;&gt; 16) &amp; 0xf</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr>(<name>ucs</name> &gt;&gt; 12) &amp; 0xf</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr>(<name>ucs</name> &gt;&gt; 8) &amp; 0xf</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr>(<name>ucs</name> &gt;&gt; 4) &amp; 0xf</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr><name>ucs</name> &amp; 0xf</expr>]</index></name></expr>;</expr_stmt>
<continue>continue;</continue>
}</block></then></if>
<expr_stmt><expr><name>s</name>--</expr>;</expr_stmt>
<expr_stmt><expr><name>size</name>++</expr>;</expr_stmt>
}</block></then></if></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><name>ch</name> &gt;= 256</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>p</name>++ = '\\'</expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = 'u'</expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr>(<name>ch</name> &gt;&gt; 12) &amp; 0xf</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr>(<name>ch</name> &gt;&gt; 8) &amp; 0xf</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr>(<name>ch</name> &gt;&gt; 4) &amp; 0xf</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name>++ = <name><name>hexdigit</name><index>[<expr><name>ch</name> &amp; 15</expr>]</index></name></expr>;</expr_stmt>
}</block></then>
<else>else
<expr_stmt><expr>*<name>p</name>++ = (<name>char</name>) <name>ch</name></expr>;</expr_stmt></else></if>
}</block></while>
<expr_stmt><expr>*<name>p</name> = '\0'</expr>;</expr_stmt>
<expr_stmt><expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>repr</name></expr></argument>, <argument><expr><name>p</name> - <name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>repr</name></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type><name>PyUnicode_AsRawUnicodeEscapeString</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>unicode</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr>!<call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_BadArgument</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>PyUnicode_EncodeRawUnicodeEscape</name><argument_list>(<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type><name>_PyUnicode_DecodeUnicodeInternal</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>starts</name> <init>= <expr><name>s</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>startinpos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>endinpos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>outpos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>reason</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>errorHandler</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>exc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_UNICODE_WIDE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<decl_stmt><decl><type><name>Py_UNICODE</name></type> <name>unimax</name> <init>= <expr><call><name>PyUnicode_GetMax</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>v</name> = <call><name>_PyUnicode_New</name><argument_list>(<argument><expr>(<name>size</name>+<name>Py_UNICODE_SIZE</name>-1)/ <name>Py_UNICODE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<if>if <condition>(<expr><call><name>PyUnicode_GetSize</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>v</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
<return>return <expr>(<name>PyObject</name> *)<name>v</name></expr>;</return></then></if>
<expr_stmt><expr><name>p</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>end</name> = <name>s</name> + <name>size</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>s</name> &lt; <name>end</name></expr>)</condition> <block>{
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Py_UNICODE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_UNICODE_WIDE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr>*<name>p</name> &gt; <name>unimax</name> || *<name>p</name> &lt; 0 ||
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<name>end</name>-<name>s</name> &lt; <name>Py_UNICODE_SIZE</name></expr>
)</condition><then> <block>{
<expr_stmt><expr><name>startinpos</name> = <name>s</name> - <name>starts</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>end</name>-<name>s</name> &lt; <name>Py_UNICODE_SIZE</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>endinpos</name> = <name>end</name>-<name>starts</name></expr>;</expr_stmt>
<expr_stmt><expr><name>reason</name> = "truncated input"</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>endinpos</name> = <name>s</name> - <name>starts</name> + <name>Py_UNICODE_SIZE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>reason</name> = "illegal code point (&gt; 0x10FFFF)"</expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><name>outpos</name> = <name>p</name> - <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>unicode_decode_call_errorhandler</name><argument_list>(
<argument><expr><name>errors</name></expr></argument>, <argument><expr>&amp;<name>errorHandler</name></expr></argument>,
<argument><expr>"unicode_internal"</expr></argument>, <argument><expr><name>reason</name></expr></argument>,
<argument><expr><name>starts</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr>&amp;<name>startinpos</name></expr></argument>, <argument><expr>&amp;<name>endinpos</name></expr></argument>, <argument><expr>&amp;<name>exc</name></expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>,
<argument><expr>(<name>PyObject</name> **)&amp;<name>v</name></expr></argument>, <argument><expr>&amp;<name>outpos</name></expr></argument>, <argument><expr>&amp;<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<goto>goto <name>onError</name>;</goto>
}</block></then></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>p</name>++</expr>;</expr_stmt>
<expr_stmt><expr><name>s</name> += <name>Py_UNICODE_SIZE</name></expr>;</expr_stmt>
}</block></else></if>
}</block></while>
<if>if <condition>(<expr><call><name>_PyUnicode_Resize</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr><name>p</name> - <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>errorHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *)<name>v</name></expr>;</return>
<label><name>onError</name>:</label>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>errorHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type><name>PyUnicode_DecodeLatin1</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>p</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>size</name> == 1</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>Py_UNICODE</name></type> <name>r</name> <init>= <expr>*(<name>unsigned</name> <name>char</name>*)<name>s</name></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>PyUnicode_FromUnicode</name><argument_list>(<argument><expr>&amp;<name>r</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>v</name> = <call><name>_PyUnicode_New</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<if>if <condition>(<expr><name>size</name> == 0</expr>)</condition><then>
<return>return <expr>(<name>PyObject</name> *)<name>v</name></expr>;</return></then></if>
<expr_stmt><expr><name>p</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>size</name>-- &gt; 0</expr>)</condition>
<expr_stmt><expr>*<name>p</name>++ = (<name>unsigned</name> <name>char</name>)*<name>s</name>++</expr>;</expr_stmt></while>
<return>return <expr>(<name>PyObject</name> *)<name>v</name></expr>;</return>
<label><name>onError</name>:</label>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>make_encode_exception</name><parameter_list>(<param><decl><type><name>PyObject</name> **</type><name>exceptionObject</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>encoding</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>unicode</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>startpos</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>endpos</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>reason</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr>*<name>exceptionObject</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>exceptionObject</name> = <call><name>PyUnicodeEncodeError_Create</name><argument_list>(
<argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>unicode</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>startpos</name></expr></argument>, <argument><expr><name>endpos</name></expr></argument>, <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<if>if <condition>(<expr><call><name>PyUnicodeEncodeError_SetStart</name><argument_list>(<argument><expr>*<name>exceptionObject</name></expr></argument>, <argument><expr><name>startpos</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<if>if <condition>(<expr><call><name>PyUnicodeEncodeError_SetEnd</name><argument_list>(<argument><expr>*<name>exceptionObject</name></expr></argument>, <argument><expr><name>endpos</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<if>if <condition>(<expr><call><name>PyUnicodeEncodeError_SetReason</name><argument_list>(<argument><expr>*<name>exceptionObject</name></expr></argument>, <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<return>return;</return>
<label><name>onError</name>:</label>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr>*<name>exceptionObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>exceptionObject</name> = <name>NULL</name></expr>;</expr_stmt>
}</block></else></if>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>raise_encode_exception</name><parameter_list>(<param><decl><type><name>PyObject</name> **</type><name>exceptionObject</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>encoding</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>unicode</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>startpos</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>endpos</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>reason</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>make_encode_exception</name><argument_list>(<argument><expr><name>exceptionObject</name></expr></argument>,
<argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>unicode</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>startpos</name></expr></argument>, <argument><expr><name>endpos</name></expr></argument>, <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>*<name>exceptionObject</name> != <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyCodec_StrictErrors</name><argument_list>(<argument><expr>*<name>exceptionObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type><name>unicode_encode_call_errorhandler</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>,
<param><decl><type><name>PyObject</name> **</type><name>errorHandler</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>encoding</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>reason</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>unicode</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>, <param><decl><type><name>PyObject</name> **</type><name>exceptionObject</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>startpos</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>endpos</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name> *</type><name>newpos</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name>argparse</name> <init>= <expr>"O!n;encoding error handler must return (unicode, int) tuple"</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>restuple</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>resunicode</name></decl>;</decl_stmt>
<if>if <condition>(<expr>*<name>errorHandler</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>errorHandler</name> = <call><name>PyCodec_LookupError</name><argument_list>(<argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>*<name>errorHandler</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
}</block></then></if>
<expr_stmt><expr><call><name>make_encode_exception</name><argument_list>(<argument><expr><name>exceptionObject</name></expr></argument>,
<argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>unicode</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>startpos</name></expr></argument>, <argument><expr><name>endpos</name></expr></argument>, <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>*<name>exceptionObject</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>restuple</name> = <call><name>PyObject_CallFunctionObjArgs</name><argument_list>(
<argument><expr>*<name>errorHandler</name></expr></argument>, <argument><expr>*<name>exceptionObject</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>restuple</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>restuple</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>&amp;<name><name>argparse</name><index>[<expr>4</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>restuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>restuple</name></expr></argument>, <argument><expr><name>argparse</name></expr></argument>, <argument><expr>&amp;<name>PyUnicode_Type</name></expr></argument>,
<argument><expr>&amp;<name>resunicode</name></expr></argument>, <argument><expr><name>newpos</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>restuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>*<name>newpos</name>&lt;0</expr>)</condition><then>
<expr_stmt><expr>*<name>newpos</name> = <name>size</name>+*<name>newpos</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr>*<name>newpos</name>&lt;0 || *<name>newpos</name>&gt;<name>size</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_IndexError</name></expr></argument>, <argument><expr>"position %zd from error handler out of bounds"</expr></argument>, <argument><expr>*<name>newpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>restuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>resunicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>restuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>resunicode</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type><name>unicode_encode_ucs1</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>p</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>,
<param><decl><type><name>int</name></type> <name>limit</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>startp</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>endp</name> <init>= <expr><name>p</name> + <name>size</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>respos</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>ressize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>encoding</name> <init>= <expr>(<name>limit</name> == 256) ? "latin-1" : "ascii"</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>reason</name> <init>= <expr>(<name>limit</name> == 256) ? "ordinal not in range(256)" : "ordinal not in range(128)"</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>errorHandler</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>exc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>known_errorHandler</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>res</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>res</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<if>if <condition>(<expr><name>size</name> == 0</expr>)</condition><then>
<return>return <expr><name>res</name></expr>;</return></then></if>
<expr_stmt><expr><name>str</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ressize</name> = <name>size</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>p</name>&lt;<name>endp</name></expr>)</condition> <block>{
<decl_stmt><decl><type><name>Py_UNICODE</name></type> <name>c</name> <init>= <expr>*<name>p</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>c</name>&lt;<name>limit</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>str</name>++ = (<name>char</name>)<name>c</name></expr>;</expr_stmt>
<expr_stmt><expr>++<name>p</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>unicodepos</name> <init>= <expr><name>p</name>-<name>startp</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>requiredsize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>repunicode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>repsize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>newpos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>respos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>uni2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>collstart</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>collend</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr>(<name>collend</name> &lt; <name>endp</name>) &amp;&amp; ((*<name>collend</name>)&gt;=<name>limit</name>)</expr>)</condition>
<expr_stmt><expr>++<name>collend</name></expr>;</expr_stmt></while>
<if>if <condition>(<expr><name>known_errorHandler</name>==-1</expr>)</condition><then> <block>{
<if>if <condition>(<expr>(<name>errors</name>==<name>NULL</name>) || (!<call><name>strcmp</name><argument_list>(<argument><expr><name>errors</name></expr></argument>, <argument><expr>"strict"</expr></argument>)</argument_list></call>)</expr>)</condition><then>
<expr_stmt><expr><name>known_errorHandler</name> = 1</expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>errors</name></expr></argument>, <argument><expr>"replace"</expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>known_errorHandler</name> = 2</expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>errors</name></expr></argument>, <argument><expr>"ignore"</expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>known_errorHandler</name> = 3</expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>errors</name></expr></argument>, <argument><expr>"xmlcharrefreplace"</expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>known_errorHandler</name> = 4</expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>known_errorHandler</name> = 0</expr>;</expr_stmt></else></if></else></if></else></if></else></if>
}</block></then></if>
<switch>switch <condition>(<expr><name>known_errorHandler</name></expr>)</condition> <block>{
<case>case <expr>1</expr>:
<expr_stmt><expr><call><name>raise_encode_exception</name><argument_list>(<argument><expr>&amp;<name>exc</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>startp</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>collstart</name>-<name>startp</name></expr></argument>, <argument><expr><name>collend</name>-<name>startp</name></expr></argument>, <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>onError</name>;</goto>
</case><case>case <expr>2</expr>:
<while>while <condition>(<expr><name>collstart</name>++&lt;<name>collend</name></expr>)</condition>
<expr_stmt><expr>*<name>str</name>++ = '?'</expr>;</expr_stmt></while>
</case><case>case <expr>3</expr>:
<expr_stmt><expr><name>p</name> = <name>collend</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>4</expr>:
<expr_stmt><expr><name>respos</name> = <name>str</name>-<call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>p</name> = <name>collstart</name></expr>, <expr><name>repsize</name> = 0</expr>;</init> <condition><expr><name>p</name> &lt; <name>collend</name></expr>;</condition> <incr><expr>++<name>p</name></expr></incr>) <block>{
<if>if <condition>(<expr>*<name>p</name>&lt;10</expr>)</condition><then>
<expr_stmt><expr><name>repsize</name> += 2+1+1</expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr>*<name>p</name>&lt;100</expr>)</condition><then>
<expr_stmt><expr><name>repsize</name> += 2+2+1</expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr>*<name>p</name>&lt;1000</expr>)</condition><then>
<expr_stmt><expr><name>repsize</name> += 2+3+1</expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr>*<name>p</name>&lt;10000</expr>)</condition><then>
<expr_stmt><expr><name>repsize</name> += 2+4+1</expr>;</expr_stmt></then>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>Py_UNICODE_WIDE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<else>else
<expr_stmt><expr><name>repsize</name> += 2+5+1</expr>;</expr_stmt></else></if></else></if></else></if></else></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<else>else <if>if <condition>(<expr>*<name>p</name>&lt;100000</expr>)</condition><then>
<expr_stmt><expr><name>repsize</name> += 2+5+1</expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr>*<name>p</name>&lt;1000000</expr>)</condition><then>
<expr_stmt><expr><name>repsize</name> += 2+6+1</expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>repsize</name> += 2+7+1</expr>;</expr_stmt></else></if></else></if></else>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></for>
<expr_stmt><expr><name>requiredsize</name> = <name>respos</name>+<name>repsize</name>+(<name>endp</name>-<name>collend</name>)</expr>;</expr_stmt>
<if>if <condition>(<expr><name>requiredsize</name> &gt; <name>ressize</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>requiredsize</name>&lt;2*<name>ressize</name></expr>)</condition><then>
<expr_stmt><expr><name>requiredsize</name> = 2*<name>ressize</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>res</name></expr></argument>, <argument><expr><name>requiredsize</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<expr_stmt><expr><name>str</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> + <name>respos</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ressize</name> = <name>requiredsize</name></expr>;</expr_stmt>
}</block></then></if>
<for>for (<init><expr><name>p</name> = <name>collstart</name></expr>;</init> <condition><expr><name>p</name> &lt; <name>collend</name></expr>;</condition> <incr><expr>++<name>p</name></expr></incr>) <block>{
<expr_stmt><expr><name>str</name> += <call><name>sprintf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr>"&amp;#%d;"</expr></argument>, <argument><expr>(<name>int</name>)*<name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><name>p</name> = <name>collend</name></expr>;</expr_stmt>
<break>break;</break>
</case><default>default:
<expr_stmt><expr><name>repunicode</name> = <call><name>unicode_encode_call_errorhandler</name><argument_list>(<argument><expr><name>errors</name></expr></argument>, <argument><expr>&amp;<name>errorHandler</name></expr></argument>,
<argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>reason</name></expr></argument>, <argument><expr><name>startp</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr>&amp;<name>exc</name></expr></argument>,
<argument><expr><name>collstart</name>-<name>startp</name></expr></argument>, <argument><expr><name>collend</name>-<name>startp</name></expr></argument>, <argument><expr>&amp;<name>newpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>repunicode</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<expr_stmt><expr><name>respos</name> = <name>str</name>-<call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>repsize</name> = <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>repunicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>requiredsize</name> = <name>respos</name>+<name>repsize</name>+(<name>endp</name>-<name>collend</name>)</expr>;</expr_stmt>
<if>if <condition>(<expr><name>requiredsize</name> &gt; <name>ressize</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>requiredsize</name>&lt;2*<name>ressize</name></expr>)</condition><then>
<expr_stmt><expr><name>requiredsize</name> = 2*<name>ressize</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>res</name></expr></argument>, <argument><expr><name>requiredsize</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>repunicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>onError</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>str</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> + <name>respos</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ressize</name> = <name>requiredsize</name></expr>;</expr_stmt>
}</block></then></if>
<for>for (<init><expr><name>uni2</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>repunicode</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>repsize</name>--&gt;0</expr>;</condition> <incr><expr>++<name>uni2</name></expr>, <expr>++<name>str</name></expr></incr>) <block>{
<expr_stmt><expr><name>c</name> = *<name>uni2</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>c</name> &gt;= <name>limit</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>raise_encode_exception</name><argument_list>(<argument><expr>&amp;<name>exc</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>startp</name></expr></argument>, <argument><expr><name>size</name></expr></argument>,
<argument><expr><name>unicodepos</name></expr></argument>, <argument><expr><name>unicodepos</name>+1</expr></argument>, <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>repunicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>onError</name>;</goto>
}</block></then></if>
<expr_stmt><expr>*<name>str</name> = (<name>char</name>)<name>c</name></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><name>p</name> = <name>startp</name> + <name>newpos</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>repunicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</default>}</block></switch>
}</block></else></if>
}</block></while>
<expr_stmt><expr><name>respos</name> = <name>str</name>-<call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>respos</name>&lt;<name>ressize</name></expr>)</condition><then>
<expr_stmt><expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>res</name></expr></argument>, <argument><expr><name>respos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>errorHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
<label><name>onError</name>:</label>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>errorHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type><name>PyUnicode_EncodeLatin1</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>p</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>unicode_encode_ucs1</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>, <argument><expr>256</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type><name>PyUnicode_AsLatin1String</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>unicode</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr>!<call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_BadArgument</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>PyUnicode_EncodeLatin1</name><argument_list>(<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type><name>PyUnicode_DecodeASCII</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>starts</name> <init>= <expr><name>s</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>startinpos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>endinpos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>outpos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>e</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>errorHandler</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>exc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>size</name> == 1 &amp;&amp; *(<name>unsigned</name> <name>char</name>*)<name>s</name> &lt; 128</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>Py_UNICODE</name></type> <name>r</name> <init>= <expr>*(<name>unsigned</name> <name>char</name>*)<name>s</name></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>PyUnicode_FromUnicode</name><argument_list>(<argument><expr>&amp;<name>r</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>v</name> = <call><name>_PyUnicode_New</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<if>if <condition>(<expr><name>size</name> == 0</expr>)</condition><then>
<return>return <expr>(<name>PyObject</name> *)<name>v</name></expr>;</return></then></if>
<expr_stmt><expr><name>p</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>e</name> = <name>s</name> + <name>size</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>s</name> &lt; <name>e</name></expr>)</condition> <block>{
<decl_stmt><decl><type><name>register</name> <name>unsigned</name> <name>char</name></type> <name>c</name> <init>= <expr>(<name>unsigned</name> <name>char</name>)*<name>s</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>c</name> &lt; 128</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>p</name>++ = <name>c</name></expr>;</expr_stmt>
<expr_stmt><expr>++<name>s</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>startinpos</name> = <name>s</name>-<name>starts</name></expr>;</expr_stmt>
<expr_stmt><expr><name>endinpos</name> = <name>startinpos</name> + 1</expr>;</expr_stmt>
<expr_stmt><expr><name>outpos</name> = <name>p</name> - (<name>Py_UNICODE</name> *)<call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>unicode_decode_call_errorhandler</name><argument_list>(
<argument><expr><name>errors</name></expr></argument>, <argument><expr>&amp;<name>errorHandler</name></expr></argument>,
<argument><expr>"ascii"</expr></argument>, <argument><expr>"ordinal not in range(128)"</expr></argument>,
<argument><expr><name>starts</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr>&amp;<name>startinpos</name></expr></argument>, <argument><expr>&amp;<name>endinpos</name></expr></argument>, <argument><expr>&amp;<name>exc</name></expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>,
<argument><expr>(<name>PyObject</name> **)&amp;<name>v</name></expr></argument>, <argument><expr>&amp;<name>outpos</name></expr></argument>, <argument><expr>&amp;<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
}</block></else></if>
}</block></while>
<if>if <condition>(<expr><name>p</name> - <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> &lt; <call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<if>if <condition>(<expr><call><name>_PyUnicode_Resize</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr><name>p</name> - <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if></then></if>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>errorHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *)<name>v</name></expr>;</return>
<label><name>onError</name>:</label>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>errorHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type><name>PyUnicode_EncodeASCII</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>p</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>unicode_encode_ucs1</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>, <argument><expr>128</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type><name>PyUnicode_AsASCIIString</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>unicode</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr>!<call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_BadArgument</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>PyUnicode_EncodeASCII</name><argument_list>(<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>MS_WINDOWS</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>defined</name><argument_list>(<argument><expr><name>HAVE_USABLE_WCHAR_T</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>SIZEOF_INT</name> &lt; <name>SIZEOF_SSIZE_T</name></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NEED_RETRY</name></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>int</name></type> <name>is_dbcs_lead_byte</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl></param>, <param><decl><type><name>int</name></type> <name>offset</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>curr</name> <init>= <expr><name>s</name> + <name>offset</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>IsDBCSLeadByte</name><argument_list>(<argument><expr>*<name>curr</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>prev</name> <init>= <expr><call><name>CharPrev</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>curr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr>(<name>prev</name> == <name>curr</name>) || !<call><name>IsDBCSLeadByte</name><argument_list>(<argument><expr>*<name>prev</name></expr></argument>)</argument_list></call> || (<name>curr</name> - <name>prev</name> == 2)</expr>;</return>
}</block></then></if>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>decode_mbcs</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> **</type><name>v</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl></param>,
<param><decl><type><name>int</name></type> <name>size</name></decl></param>,
<param><decl><type><name>int</name></type> <name>final</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>usize</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>size</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>final</name> &amp;&amp; <name>size</name> &gt;= 1 &amp;&amp; <call><name>is_dbcs_lead_byte</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>size</name> - 1</expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr>--<name>size</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>size</name> &gt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>usize</name> = <call><name>MultiByteToWideChar</name><argument_list>(<argument><expr><name>CP_ACP</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>usize</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetFromWindowsErrWithFilename</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
}</block></then></if>
<if>if <condition>(<expr>*<name>v</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>v</name> = <call><name>_PyUnicode_New</name><argument_list>(<argument><expr><name>usize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>*<name>v</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>n</name> = <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr>*<name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>_PyUnicode_Resize</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>n</name> + <name>usize</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
}</block></else></if>
<if>if <condition>(<expr><name>size</name> &gt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>p</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr>*<name>v</name></expr></argument>)</argument_list></call> + <name>n</name></expr>;</expr_stmt>
<if>if <condition>(<expr>0 == <call><name>MultiByteToWideChar</name><argument_list>(<argument><expr><name>CP_ACP</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>usize</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetFromWindowsErrWithFilename</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
}</block></then></if>
<return>return <expr><name>size</name></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type><name>PyUnicode_DecodeMBCSStateful</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name> *</type><name>consumed</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>v</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>done</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>consumed</name></expr>)</condition><then>
<expr_stmt><expr>*<name>consumed</name> = 0</expr>;</expr_stmt></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NEED_RETRY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<label><name>retry</name>:</label>
<if>if <condition>(<expr><name>size</name> &gt; <name>INT_MAX</name></expr>)</condition><then>
<expr_stmt><expr><name>done</name> = <call><name>decode_mbcs</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>INT_MAX</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>done</name> = <call><name>decode_mbcs</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr>(<name>int</name>)<name>size</name></expr></argument>, <argument><expr>!<name>consumed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<if>if <condition>(<expr><name>done</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>consumed</name></expr>)</condition><then>
<expr_stmt><expr>*<name>consumed</name> += <name>done</name></expr>;</expr_stmt></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NEED_RETRY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>size</name> &gt; <name>INT_MAX</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>s</name> += <name>done</name></expr>;</expr_stmt>
<expr_stmt><expr><name>size</name> -= <name>done</name></expr>;</expr_stmt>
<goto>goto <name>retry</name>;</goto>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr>(<name>PyObject</name> *)<name>v</name></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type><name>PyUnicode_DecodeMBCS</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>PyUnicode_DecodeMBCSStateful</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type> <name>encode_mbcs</name><parameter_list>(<param><decl><type><name>PyObject</name> **</type><name>repr</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>p</name></decl></param>,
<param><decl><type><name>int</name></type> <name>size</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>mbcssize</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>size</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>size</name> &gt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>mbcssize</name> = <call><name>WideCharToMultiByte</name><argument_list>(<argument><expr><name>CP_ACP</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>mbcssize</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetFromWindowsErrWithFilename</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
}</block></then></if>
<if>if <condition>(<expr>*<name>repr</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>repr</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>mbcssize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>*<name>repr</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>n</name> = <call><name>PyString_Size</name><argument_list>(<argument><expr>*<name>repr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr><name>repr</name></expr></argument>, <argument><expr><name>n</name> + <name>mbcssize</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
}</block></else></if>
<if>if <condition>(<expr><name>size</name> &gt; 0</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>s</name> <init>= <expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr>*<name>repr</name></expr></argument>)</argument_list></call> + <name>n</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>0 == <call><name>WideCharToMultiByte</name><argument_list>(<argument><expr><name>CP_ACP</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>mbcssize</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetFromWindowsErrWithFilename</name><argument_list>(<argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
}</block></then></if>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type><name>PyUnicode_EncodeMBCS</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>p</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>repr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NEED_RETRY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<label><name>retry</name>:</label>
<if>if <condition>(<expr><name>size</name> &gt; <name>INT_MAX</name></expr>)</condition><then>
<expr_stmt><expr><name>ret</name> = <call><name>encode_mbcs</name><argument_list>(<argument><expr>&amp;<name>repr</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>INT_MAX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name>ret</name> = <call><name>encode_mbcs</name><argument_list>(<argument><expr>&amp;<name>repr</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr>(<name>int</name>)<name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<if>if <condition>(<expr><name>ret</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>repr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>NEED_RETRY</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>size</name> &gt; <name>INT_MAX</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>p</name> += <name>INT_MAX</name></expr>;</expr_stmt>
<expr_stmt><expr><name>size</name> -= <name>INT_MAX</name></expr>;</expr_stmt>
<goto>goto <name>retry</name>;</goto>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><name>repr</name></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type><name>PyUnicode_AsMBCSString</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>unicode</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr>!<call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_BadArgument</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>PyUnicode_EncodeMBCS</name><argument_list>(<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>NEED_RETRY</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>PyObject</name> *</type><name>PyUnicode_DecodeCharmap</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>,
<param><decl><type><name>PyObject</name> *</type><name>mapping</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>starts</name> <init>= <expr><name>s</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>startinpos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>endinpos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>outpos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>e</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>v</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>extrachars</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>errorHandler</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>exc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>mapstring</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>maplen</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>mapping</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><call><name>PyUnicode_DecodeLatin1</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>v</name> = <call><name>_PyUnicode_New</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<if>if <condition>(<expr><name>size</name> == 0</expr>)</condition><then>
<return>return <expr>(<name>PyObject</name> *)<name>v</name></expr>;</return></then></if>
<expr_stmt><expr><name>p</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>e</name> = <name>s</name> + <name>size</name></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyUnicode_CheckExact</name><argument_list>(<argument><expr><name>mapping</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>mapstring</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>mapping</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>maplen</name> = <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>mapping</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>s</name> &lt; <name>e</name></expr>)</condition> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>ch</name> <init>= <expr>*<name>s</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UNICODE</name></type> <name>x</name> <init>= <expr>0xfffe</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>ch</name> &lt; <name>maplen</name></expr>)</condition><then>
<expr_stmt><expr><name>x</name> = <name><name>mapstring</name><index>[<expr><name>ch</name></expr>]</index></name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>x</name> == 0xfffe</expr>)</condition><then> <block>{
<expr_stmt><expr><name>outpos</name> = <name>p</name>-<call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>startinpos</name> = <name>s</name>-<name>starts</name></expr>;</expr_stmt>
<expr_stmt><expr><name>endinpos</name> = <name>startinpos</name>+1</expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>unicode_decode_call_errorhandler</name><argument_list>(
<argument><expr><name>errors</name></expr></argument>, <argument><expr>&amp;<name>errorHandler</name></expr></argument>,
<argument><expr>"charmap"</expr></argument>, <argument><expr>"character maps to &lt;undefined&gt;"</expr></argument>,
<argument><expr><name>starts</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr>&amp;<name>startinpos</name></expr></argument>, <argument><expr>&amp;<name>endinpos</name></expr></argument>, <argument><expr>&amp;<name>exc</name></expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>,
<argument><expr>(<name>PyObject</name> **)&amp;<name>v</name></expr></argument>, <argument><expr>&amp;<name>outpos</name></expr></argument>, <argument><expr>&amp;<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<goto>goto <name>onError</name>;</goto>
}</block></then></if>
<continue>continue;</continue>
}</block></then></if>
<expr_stmt><expr>*<name>p</name>++ = <name>x</name></expr>;</expr_stmt>
<expr_stmt><expr>++<name>s</name></expr>;</expr_stmt>
}</block></while>
}</block></then> <else>else <block>{
<while>while <condition>(<expr><name>s</name> &lt; <name>e</name></expr>)</condition> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>ch</name> <init>= <expr>*<name>s</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>w</name></decl>, *<decl><type ref="prev"/><name>x</name></decl>;</decl_stmt>
<expr_stmt><expr><name>w</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>w</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<expr_stmt><expr><name>x</name> = <call><name>PyObject_GetItem</name><argument_list>(<argument><expr><name>mapping</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>x</name> == <name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_LookupError</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>x</name> = <name>Py_None</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else
<goto>goto <name>onError</name>;</goto></else></if>
}</block></then></if>
<if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>long</name></type> <name>value</name> <init>= <expr><call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>value</name> &lt; 0 || <name>value</name> &gt; 65535</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"character mapping must be in range(65536)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>onError</name>;</goto>
}</block></then></if>
<expr_stmt><expr>*<name>p</name>++ = (<name>Py_UNICODE</name>)<name>value</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>x</name> == <name>Py_None</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>outpos</name> = <name>p</name>-<call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>startinpos</name> = <name>s</name>-<name>starts</name></expr>;</expr_stmt>
<expr_stmt><expr><name>endinpos</name> = <name>startinpos</name>+1</expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>unicode_decode_call_errorhandler</name><argument_list>(
<argument><expr><name>errors</name></expr></argument>, <argument><expr>&amp;<name>errorHandler</name></expr></argument>,
<argument><expr>"charmap"</expr></argument>, <argument><expr>"character maps to &lt;undefined&gt;"</expr></argument>,
<argument><expr><name>starts</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr>&amp;<name>startinpos</name></expr></argument>, <argument><expr>&amp;<name>endinpos</name></expr></argument>, <argument><expr>&amp;<name>exc</name></expr></argument>, <argument><expr>&amp;<name>s</name></expr></argument>,
<argument><expr>(<name>PyObject</name> **)&amp;<name>v</name></expr></argument>, <argument><expr>&amp;<name>outpos</name></expr></argument>, <argument><expr>&amp;<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>onError</name>;</goto>
}</block></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<continue>continue;</continue>
}</block></then> <else>else <if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>targetsize</name> <init>= <expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>targetsize</name> == 1</expr>)</condition><then>
<expr_stmt><expr>*<name>p</name>++ = *<call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name>targetsize</name> &gt; 1</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>targetsize</name> &gt; <name>extrachars</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>oldpos</name> <init>= <expr><name>p</name> - <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>needed</name> <init>= <expr>(<name>targetsize</name> - <name>extrachars</name>) + \
(<name>targetsize</name> &lt;&lt; 2)</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>extrachars</name> += <name>needed</name></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>_PyUnicode_Resize</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>,
<argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> + <name>needed</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>onError</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>p</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> + <name>oldpos</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>Py_UNICODE_COPY</name><argument_list>(<argument><expr><name>p</name></expr></argument>,
<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>targetsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> += <name>targetsize</name></expr>;</expr_stmt>
<expr_stmt><expr><name>extrachars</name> -= <name>targetsize</name></expr>;</expr_stmt>
}</block></then></if></else></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"character mapping must return integer, None or unicode"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>onError</name>;</goto>
}</block></else></if></else></if></else></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>++<name>s</name></expr>;</expr_stmt>
}</block></while>
}</block></else></if>
<if>if <condition>(<expr><name>p</name> - <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> &lt; <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<if>if <condition>(<expr><call><name>_PyUnicode_Resize</name><argument_list>(<argument><expr>&amp;<name>v</name></expr></argument>, <argument><expr><name>p</name> - <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if></then></if>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>errorHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *)<name>v</name></expr>;</return>
<label><name>onError</name>:</label>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>errorHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<struct>struct <name>encoding_map</name> <block>{
<decl_stmt><decl><type><name>PyObject_HEAD</name>
<name>unsigned</name> <name>char</name></type> <name><name>level1</name><index>[<expr>32</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>count2</name></decl>, <decl><type ref="prev"/><name>count3</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>level23</name><index>[<expr>1</expr>]</index></name></decl>;</decl_stmt>
}</block>;</struct>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>encoding_map_size</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>, <param><decl><type><name>PyObject</name>*</type> <name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>encoding_map</name> *</type><name>map</name> <init>= <expr>(struct <name>encoding_map</name>*)<name>obj</name></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>map</name></expr></argument>)</argument_list></sizeof> - 1 + 16*<name><name>map</name>-&gt;<name>count2</name></name> +
128*<name><name>map</name>-&gt;<name>count3</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>encoding_map_methods</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{
<expr>"size"</expr>, <expr><name>encoding_map_size</name></expr>, <expr><name>METH_NOARGS</name></expr>,
<macro><name>PyDoc_STR</name><argument_list>(<argument>"Return the size (in bytes) of this object"</argument>)</argument_list></macro>
}</block></expr>,
<expr><block>{ <expr>0</expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>encoding_map_dealloc</name><parameter_list>(<param><decl><type><name>PyObject</name>*</type> <name>o</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>PyObject_FREE</name><argument_list>(<argument><expr><name>o</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyTypeObject</name></type> <name>EncodingMapType</name> <init>= <expr><block>{
<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
"EncodingMap"</expr>,
<expr><sizeof>sizeof<argument_list>(<argument>struct <expr><name>encoding_map</name></expr></argument>)</argument_list></sizeof></expr>,
<expr>0</expr>,
<expr><name>encoding_map_dealloc</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>Py_TPFLAGS_DEFAULT</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>encoding_map_methods</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
}</block></expr></init></decl>;</decl_stmt>
<function><type><name>PyObject</name>*</type>
<name>PyUnicode_BuildEncodingMap</name><parameter_list>(<param><decl><type><name>PyObject</name>*</type> <name>string</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>decode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>encoding_map</name> *</type><name>mresult</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>need_dict</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>level1</name><index>[<expr>32</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>level2</name><index>[<expr>512</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>mlevel1</name></decl>, *<decl><type ref="prev"/><name>mlevel2</name></decl>, *<decl><type ref="prev"/><name>mlevel3</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>count2</name> <init>= <expr>0</expr></init>, <name>count3</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call> || <call><name>PyUnicode_GetSize</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call> != 256</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_BadArgument</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>decode</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>level1</name></expr></argument>, <argument><expr>0xFF</expr></argument>, <argument><expr>sizeof <name>level1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>level2</name></expr></argument>, <argument><expr>0xFF</expr></argument>, <argument><expr>sizeof <name>level2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>decode</name><index>[<expr>0</expr>]</index></name> != 0</expr>)</condition><then>
<expr_stmt><expr><name>need_dict</name> = 1</expr>;</expr_stmt></then></if>
<for>for (<init><expr><name>i</name> = 1</expr>;</init> <condition><expr><name>i</name> &lt; 256</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>int</name></type> <name>l1</name></decl>, <decl><type ref="prev"/><name>l2</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>decode</name><index>[<expr><name>i</name></expr>]</index></name> == 0
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_UNICODE_WIDE</name></expr></argument>)</argument_list></call></expr></cpp:if>
|| <name><name>decode</name><index>[<expr><name>i</name></expr>]</index></name> &gt; 0xFFFF</expr>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
)</condition><then> <block>{
<expr_stmt><expr><name>need_dict</name> = 1</expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
<if>if <condition>(<expr><name><name>decode</name><index>[<expr><name>i</name></expr>]</index></name> == 0xFFFE</expr>)</condition><then>
<continue>continue;</continue></then></if>
<expr_stmt><expr><name>l1</name> = <name><name>decode</name><index>[<expr><name>i</name></expr>]</index></name> &gt;&gt; 11</expr>;</expr_stmt>
<expr_stmt><expr><name>l2</name> = <name><name>decode</name><index>[<expr><name>i</name></expr>]</index></name> &gt;&gt; 7</expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>level1</name><index>[<expr><name>l1</name></expr>]</index></name> == 0xFF</expr>)</condition><then>
<expr_stmt><expr><name><name>level1</name><index>[<expr><name>l1</name></expr>]</index></name> = <name>count2</name>++</expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name><name>level2</name><index>[<expr><name>l2</name></expr>]</index></name> == 0xFF</expr>)</condition><then>
<expr_stmt><expr><name><name>level2</name><index>[<expr><name>l2</name></expr>]</index></name> = <name>count3</name>++</expr>;</expr_stmt></then></if>
}</block></for>
<if>if <condition>(<expr><name>count2</name> &gt;= 0xFF || <name>count3</name> &gt;= 0xFF</expr>)</condition><then>
<expr_stmt><expr><name>need_dict</name> = 1</expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>need_dict</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><call><name>PyDict_New</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>key</name></decl>, *<decl><type ref="prev"/><name>value</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<name>result</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; 256</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><name>key</name> = <name>value</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>key</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name><name>decode</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>value</name> = <call><name>PyInt_FromLong</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>key</name> || !<name>value</name></expr>)</condition><then>
<goto>goto <name>failed1</name>;</goto></then></if>
<if>if <condition>(<expr><call><name>PyDict_SetItem</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then>
<goto>goto <name>failed1</name>;</goto></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<return>return <expr><name>result</name></expr>;</return>
<label><name>failed1</name>:</label>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>result</name> = <call><name>PyObject_MALLOC</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument>struct <expr><name>encoding_map</name></expr></argument>)</argument_list></sizeof> +
16*<name>count2</name> + 128*<name>count3</name> - 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>result</name></expr>)</condition><then>
<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>PyObject_Init</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr>&amp;<name>EncodingMapType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>mresult</name> = (struct <name>encoding_map</name>*)<name>result</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mresult</name>-&gt;<name>count2</name></name> = <name>count2</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mresult</name>-&gt;<name>count3</name></name> = <name>count3</name></expr>;</expr_stmt>
<expr_stmt><expr><name>mlevel1</name> = <name><name>mresult</name>-&gt;<name>level1</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>mlevel2</name> = <name><name>mresult</name>-&gt;<name>level23</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>mlevel3</name> = <name><name>mresult</name>-&gt;<name>level23</name></name> + 16*<name>count2</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>mlevel1</name></expr></argument>, <argument><expr><name>level1</name></expr></argument>, <argument><expr>32</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>mlevel2</name></expr></argument>, <argument><expr>0xFF</expr></argument>, <argument><expr>16*<name>count2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>mlevel3</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>128*<name>count3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>count3</name> = 0</expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 1</expr>;</init> <condition><expr><name>i</name> &lt; 256</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>int</name></type> <name>o1</name></decl>, <decl><type ref="prev"/><name>o2</name></decl>, <decl><type ref="prev"/><name>o3</name></decl>, <decl><type ref="prev"/><name>i2</name></decl>, <decl><type ref="prev"/><name>i3</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>decode</name><index>[<expr><name>i</name></expr>]</index></name> == 0xFFFE</expr>)</condition><then>
<continue>continue;</continue></then></if>
<expr_stmt><expr><name>o1</name> = <name><name>decode</name><index>[<expr><name>i</name></expr>]</index></name>&gt;&gt;11</expr>;</expr_stmt>
<expr_stmt><expr><name>o2</name> = (<name><name>decode</name><index>[<expr><name>i</name></expr>]</index></name>&gt;&gt;7) &amp; 0xF</expr>;</expr_stmt>
<expr_stmt><expr><name>i2</name> = 16*<name><name>mlevel1</name><index>[<expr><name>o1</name></expr>]</index></name> + <name>o2</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>mlevel2</name><index>[<expr><name>i2</name></expr>]</index></name> == 0xFF</expr>)</condition><then>
<expr_stmt><expr><name><name>mlevel2</name><index>[<expr><name>i2</name></expr>]</index></name> = <name>count3</name>++</expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>o3</name> = <name><name>decode</name><index>[<expr><name>i</name></expr>]</index></name> &amp; 0x7F</expr>;</expr_stmt>
<expr_stmt><expr><name>i3</name> = 128*<name><name>mlevel2</name><index>[<expr><name>i2</name></expr>]</index></name> + <name>o3</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>mlevel3</name><index>[<expr><name>i3</name></expr>]</index></name> = <name>i</name></expr>;</expr_stmt>
}</block></for>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>encoding_map_lookup</name><parameter_list>(<param><decl><type><name>Py_UNICODE</name></type> <name>c</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>mapping</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>encoding_map</name> *</type><name>map</name> <init>= <expr>(struct <name>encoding_map</name>*)<name>mapping</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>l1</name> <init>= <expr><name>c</name>&gt;&gt;11</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>l2</name> <init>= <expr>(<name>c</name>&gt;&gt;7) &amp; 0xF</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>l3</name> <init>= <expr><name>c</name> &amp; 0x7F</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_UNICODE_WIDE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>c</name> &gt; 0xFFFF</expr>)</condition><then> <block>{
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><name>c</name> == 0</expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><name>i</name> = <name><name>map</name>-&gt;<name>level1</name><index>[<expr><name>l1</name></expr>]</index></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>i</name> == 0xFF</expr>)</condition><then> <block>{
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>i</name> = <name><name>map</name>-&gt;<name>level23</name><index>[<expr>16*<name>i</name>+<name>l2</name></expr>]</index></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>i</name> == 0xFF</expr>)</condition><then> <block>{
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>i</name> = <name><name>map</name>-&gt;<name>level23</name><index>[<expr>16*<name><name>map</name>-&gt;<name>count2</name></name> + 128*<name>i</name> + <name>l3</name></expr>]</index></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>i</name> == 0</expr>)</condition><then> <block>{
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<return>return <expr><name>i</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type><name>charmapencode_lookup</name><parameter_list>(<param><decl><type><name>Py_UNICODE</name></type> <name>c</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>mapping</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>w</name> <init>= <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>x</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>w</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>x</name> = <call><name>PyObject_GetItem</name><argument_list>(<argument><expr><name>mapping</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>x</name> == <name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_LookupError</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>x</name> = <name>Py_None</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>x</name></expr>;</return>
}</block></then> <else>else
<return>return <expr><name>NULL</name></expr>;</return></else></if>
}</block></then> <else>else <if>if <condition>(<expr><name>x</name> == <name>Py_None</name></expr>)</condition><then>
<return>return <expr><name>x</name></expr>;</return></then>
<else>else <if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>long</name></type> <name>value</name> <init>= <expr><call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>value</name> &lt; 0 || <name>value</name> &gt; 255</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"character mapping must be in range(256)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><name>x</name></expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>x</name></expr>;</return></then>
<else>else <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"character mapping must return integer, None or str"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></else></if></else></if></else></if></else></if>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>charmapencode_resize</name><parameter_list>(<param><decl><type><name>PyObject</name> **</type><name>outobj</name></decl></param>, <param><decl><type><name>Py_ssize_t</name> *</type><name>outpos</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>requiredsize</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>outsize</name> <init>= <expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr>*<name>outobj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>requiredsize</name> &lt; 2*<name>outsize</name></expr>)</condition><then>
<expr_stmt><expr><name>requiredsize</name> = 2*<name>outsize</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr><name>outobj</name></expr></argument>, <argument><expr><name>requiredsize</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<return>return <expr>0</expr>;</return>
}</block></then></if>
<return>return <expr>1</expr>;</return>
}</block></function>
<typedef>typedef <type><enum>enum <name>charmapencode_result</name> <block>{
<decl><name>enc_SUCCESS</name></decl>, <decl><name>enc_FAILED</name></decl>, <decl><name>enc_EXCEPTION</name></decl>
}</block></enum></type> <name>charmapencode_result</name>;</typedef>
<function><type><specifier>static</specifier>
<name>charmapencode_result</name></type> <name>charmapencode_output</name><parameter_list>(<param><decl><type><name>Py_UNICODE</name></type> <name>c</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>mapping</name></decl></param>,
<param><decl><type><name>PyObject</name> **</type><name>outobj</name></decl></param>, <param><decl><type><name>Py_ssize_t</name> *</type><name>outpos</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>rep</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>outstart</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>outsize</name> <init>= <expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr>*<name>outobj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>mapping</name></expr></argument>)</argument_list></call> == &amp;<name>EncodingMapType</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>encoding_map_lookup</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>mapping</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>requiredsize</name> <init>= <expr>*<name>outpos</name>+1</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>res</name> == -1</expr>)</condition><then>
<return>return <expr><name>enc_FAILED</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>outsize</name>&lt;<name>requiredsize</name></expr>)</condition><then>
<if>if <condition>(<expr>!<call><name>charmapencode_resize</name><argument_list>(<argument><expr><name>outobj</name></expr></argument>, <argument><expr><name>outpos</name></expr></argument>, <argument><expr><name>requiredsize</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>enc_EXCEPTION</name></expr>;</return></then></if></then></if>
<expr_stmt><expr><name>outstart</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr>*<name>outobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>outstart</name><index>[<expr>(*<name>outpos</name>)++</expr>]</index></name> = (<name>char</name>)<name>res</name></expr>;</expr_stmt>
<return>return <expr><name>enc_SUCCESS</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>rep</name> = <call><name>charmapencode_lookup</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>mapping</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rep</name>==<name>NULL</name></expr>)</condition><then>
<return>return <expr><name>enc_EXCEPTION</name></expr>;</return></then>
<else>else <if>if <condition>(<expr><name>rep</name>==<name>Py_None</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>rep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>enc_FAILED</name></expr>;</return>
}</block></then> <else>else <block>{
<if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>rep</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>requiredsize</name> <init>= <expr>*<name>outpos</name>+1</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>outsize</name>&lt;<name>requiredsize</name></expr>)</condition><then>
<if>if <condition>(<expr>!<call><name>charmapencode_resize</name><argument_list>(<argument><expr><name>outobj</name></expr></argument>, <argument><expr><name>outpos</name></expr></argument>, <argument><expr><name>requiredsize</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>rep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>enc_EXCEPTION</name></expr>;</return>
}</block></then></if></then></if>
<expr_stmt><expr><name>outstart</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr>*<name>outobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>outstart</name><index>[<expr>(*<name>outpos</name>)++</expr>]</index></name> = (<name>char</name>)<call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><name>rep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>repchars</name> <init>= <expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>rep</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>repsize</name> <init>= <expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>rep</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>requiredsize</name> <init>= <expr>*<name>outpos</name>+<name>repsize</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>outsize</name>&lt;<name>requiredsize</name></expr>)</condition><then>
<if>if <condition>(<expr>!<call><name>charmapencode_resize</name><argument_list>(<argument><expr><name>outobj</name></expr></argument>, <argument><expr><name>outpos</name></expr></argument>, <argument><expr><name>requiredsize</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>rep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>enc_EXCEPTION</name></expr>;</return>
}</block></then></if></then></if>
<expr_stmt><expr><name>outstart</name> = <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr>*<name>outobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>outstart</name> + *<name>outpos</name></expr></argument>, <argument><expr><name>repchars</name></expr></argument>, <argument><expr><name>repsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>outpos</name> += <name>repsize</name></expr>;</expr_stmt>
}</block></else></if>
}</block></else></if></else></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>rep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>enc_SUCCESS</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier>
<name>int</name></type> <name>charmap_encoding_error</name><parameter_list>(
<param><decl><type><specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>p</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>, <param><decl><type><name>Py_ssize_t</name> *</type><name>inpos</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>mapping</name></decl></param>,
<param><decl><type><name>PyObject</name> **</type><name>exceptionObject</name></decl></param>,
<param><decl><type><name>int</name> *</type><name>known_errorHandler</name></decl></param>, <param><decl><type><name>PyObject</name> **</type><name>errorHandler</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>,
<param><decl><type><name>PyObject</name> **</type><name>res</name></decl></param>, <param><decl><type><name>Py_ssize_t</name> *</type><name>respos</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>repunicode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>repsize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>newpos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>uni2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>collstartpos</name> <init>= <expr>*<name>inpos</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>collendpos</name> <init>= <expr>*<name>inpos</name>+1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>collpos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>encoding</name> <init>= <expr>"charmap"</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>reason</name> <init>= <expr>"character maps to &lt;undefined&gt;"</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>charmapencode_result</name></type> <name>x</name></decl>;</decl_stmt>
<while>while <condition>(<expr><name>collendpos</name> &lt; <name>size</name></expr>)</condition> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>rep</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>mapping</name></expr></argument>)</argument_list></call> == &amp;<name>EncodingMapType</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>res</name> <init>= <expr><call><name>encoding_map_lookup</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><name>collendpos</name></expr>]</index></name></expr></argument>, <argument><expr><name>mapping</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>res</name> != -1</expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr>++<name>collendpos</name></expr>;</expr_stmt>
<continue>continue;</continue>
}</block></then></if>
<expr_stmt><expr><name>rep</name> = <call><name>charmapencode_lookup</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><name>collendpos</name></expr>]</index></name></expr></argument>, <argument><expr><name>mapping</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rep</name>==<name>NULL</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then>
<else>else <if>if <condition>(<expr><name>rep</name>!=<name>Py_None</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>rep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
}</block></then></if></else></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>rep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>++<name>collendpos</name></expr>;</expr_stmt>
}</block></while>
<if>if <condition>(<expr>*<name>known_errorHandler</name>==-1</expr>)</condition><then> <block>{
<if>if <condition>(<expr>(<name>errors</name>==<name>NULL</name>) || (!<call><name>strcmp</name><argument_list>(<argument><expr><name>errors</name></expr></argument>, <argument><expr>"strict"</expr></argument>)</argument_list></call>)</expr>)</condition><then>
<expr_stmt><expr>*<name>known_errorHandler</name> = 1</expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>errors</name></expr></argument>, <argument><expr>"replace"</expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr>*<name>known_errorHandler</name> = 2</expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>errors</name></expr></argument>, <argument><expr>"ignore"</expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr>*<name>known_errorHandler</name> = 3</expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>errors</name></expr></argument>, <argument><expr>"xmlcharrefreplace"</expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr>*<name>known_errorHandler</name> = 4</expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr>*<name>known_errorHandler</name> = 0</expr>;</expr_stmt></else></if></else></if></else></if></else></if>
}</block></then></if>
<switch>switch <condition>(<expr>*<name>known_errorHandler</name></expr>)</condition> <block>{
<case>case <expr>1</expr>:
<expr_stmt><expr><call><name>raise_encode_exception</name><argument_list>(<argument><expr><name>exceptionObject</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>collstartpos</name></expr></argument>, <argument><expr><name>collendpos</name></expr></argument>, <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
</case><case>case <expr>2</expr>:
<for>for (<init><expr><name>collpos</name> = <name>collstartpos</name></expr>;</init> <condition><expr><name>collpos</name>&lt;<name>collendpos</name></expr>;</condition> <incr><expr>++<name>collpos</name></expr></incr>) <block>{
<expr_stmt><expr><name>x</name> = <call><name>charmapencode_output</name><argument_list>(<argument><expr>'?'</expr></argument>, <argument><expr><name>mapping</name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><name>respos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>x</name>==<name>enc_EXCEPTION</name></expr>)</condition><then> <block>{
<return>return <expr>-1</expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><name>x</name>==<name>enc_FAILED</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>raise_encode_exception</name><argument_list>(<argument><expr><name>exceptionObject</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>collstartpos</name></expr></argument>, <argument><expr><name>collendpos</name></expr></argument>, <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if></else></if>
}</block></for>
</case><case>case <expr>3</expr>:
<expr_stmt><expr>*<name>inpos</name> = <name>collendpos</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>4</expr>:
<for>for (<init><expr><name>collpos</name> = <name>collstartpos</name></expr>;</init> <condition><expr><name>collpos</name> &lt; <name>collendpos</name></expr>;</condition> <incr><expr>++<name>collpos</name></expr></incr>) <block>{
<decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr>2+29+1+1</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>cp</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr>"&amp;#%d;"</expr></argument>, <argument><expr>(<name>int</name>)<name><name>p</name><index>[<expr><name>collpos</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>cp</name> = <name>buffer</name></expr>;</init> <condition><expr>*<name>cp</name></expr>;</condition> <incr><expr>++<name>cp</name></expr></incr>) <block>{
<expr_stmt><expr><name>x</name> = <call><name>charmapencode_output</name><argument_list>(<argument><expr>*<name>cp</name></expr></argument>, <argument><expr><name>mapping</name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><name>respos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>x</name>==<name>enc_EXCEPTION</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then>
<else>else <if>if <condition>(<expr><name>x</name>==<name>enc_FAILED</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>raise_encode_exception</name><argument_list>(<argument><expr><name>exceptionObject</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>collstartpos</name></expr></argument>, <argument><expr><name>collendpos</name></expr></argument>, <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if></else></if>
}</block></for>
}</block></for>
<expr_stmt><expr>*<name>inpos</name> = <name>collendpos</name></expr>;</expr_stmt>
<break>break;</break>
</case><default>default:
<expr_stmt><expr><name>repunicode</name> = <call><name>unicode_encode_call_errorhandler</name><argument_list>(<argument><expr><name>errors</name></expr></argument>, <argument><expr><name>errorHandler</name></expr></argument>,
<argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>reason</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>exceptionObject</name></expr></argument>,
<argument><expr><name>collstartpos</name></expr></argument>, <argument><expr><name>collendpos</name></expr></argument>, <argument><expr>&amp;<name>newpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>repunicode</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><name>repsize</name> = <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>repunicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>uni2</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>repunicode</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>repsize</name>--&gt;0</expr>;</condition> <incr><expr>++<name>uni2</name></expr></incr>) <block>{
<expr_stmt><expr><name>x</name> = <call><name>charmapencode_output</name><argument_list>(<argument><expr>*<name>uni2</name></expr></argument>, <argument><expr><name>mapping</name></expr></argument>, <argument><expr><name>res</name></expr></argument>, <argument><expr><name>respos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>x</name>==<name>enc_EXCEPTION</name></expr>)</condition><then> <block>{
<return>return <expr>-1</expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><name>x</name>==<name>enc_FAILED</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>repunicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>raise_encode_exception</name><argument_list>(<argument><expr><name>exceptionObject</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>collstartpos</name></expr></argument>, <argument><expr><name>collendpos</name></expr></argument>, <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if></else></if>
}</block></for>
<expr_stmt><expr>*<name>inpos</name> = <name>newpos</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>repunicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</default>}</block></switch>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type><name>PyUnicode_EncodeCharmap</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>p</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>,
<param><decl><type><name>PyObject</name> *</type><name>mapping</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>inpos</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>respos</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>errorHandler</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>exc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>known_errorHandler</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>mapping</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><call><name>PyUnicode_EncodeLatin1</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>res</name> = <call><name>PyString_FromStringAndSize</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>res</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<if>if <condition>(<expr><name>size</name> == 0</expr>)</condition><then>
<return>return <expr><name>res</name></expr>;</return></then></if>
<while>while <condition>(<expr><name>inpos</name>&lt;<name>size</name></expr>)</condition> <block>{
<decl_stmt><decl><type><name>charmapencode_result</name></type> <name>x</name> <init>= <expr><call><name>charmapencode_output</name><argument_list>(<argument><expr><name><name>p</name><index>[<expr><name>inpos</name></expr>]</index></name></expr></argument>, <argument><expr><name>mapping</name></expr></argument>, <argument><expr>&amp;<name>res</name></expr></argument>, <argument><expr>&amp;<name>respos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>x</name>==<name>enc_EXCEPTION</name></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<if>if <condition>(<expr><name>x</name>==<name>enc_FAILED</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>charmap_encoding_error</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr>&amp;<name>inpos</name></expr></argument>, <argument><expr><name>mapping</name></expr></argument>,
<argument><expr>&amp;<name>exc</name></expr></argument>,
<argument><expr>&amp;<name>known_errorHandler</name></expr></argument>, <argument><expr>&amp;<name>errorHandler</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>,
<argument><expr>&amp;<name>res</name></expr></argument>, <argument><expr>&amp;<name>respos</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<goto>goto <name>onError</name>;</goto>
}</block></then></if>
}</block></then> <else>else
<expr_stmt><expr>++<name>inpos</name></expr>;</expr_stmt></else></if>
}</block></while>
<if>if <condition>(<expr><name>respos</name>&lt;<call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>_PyString_Resize</name><argument_list>(<argument><expr>&amp;<name>res</name></expr></argument>, <argument><expr><name>respos</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
}</block></then></if>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>errorHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
<label><name>onError</name>:</label>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>errorHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type><name>PyUnicode_AsCharmapString</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>unicode</name></decl></param>,
<param><decl><type><name>PyObject</name> *</type><name>mapping</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr>!<call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call> || <name>mapping</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_BadArgument</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>PyUnicode_EncodeCharmap</name><argument_list>(<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>mapping</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>make_translate_exception</name><parameter_list>(<param><decl><type><name>PyObject</name> **</type><name>exceptionObject</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>unicode</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>startpos</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>endpos</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>reason</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr>*<name>exceptionObject</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>exceptionObject</name> = <call><name>PyUnicodeTranslateError_Create</name><argument_list>(
<argument><expr><name>unicode</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>startpos</name></expr></argument>, <argument><expr><name>endpos</name></expr></argument>, <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<if>if <condition>(<expr><call><name>PyUnicodeTranslateError_SetStart</name><argument_list>(<argument><expr>*<name>exceptionObject</name></expr></argument>, <argument><expr><name>startpos</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<if>if <condition>(<expr><call><name>PyUnicodeTranslateError_SetEnd</name><argument_list>(<argument><expr>*<name>exceptionObject</name></expr></argument>, <argument><expr><name>endpos</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<if>if <condition>(<expr><call><name>PyUnicodeTranslateError_SetReason</name><argument_list>(<argument><expr>*<name>exceptionObject</name></expr></argument>, <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<return>return;</return>
<label><name>onError</name>:</label>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr>*<name>exceptionObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>exceptionObject</name> = <name>NULL</name></expr>;</expr_stmt>
}</block></else></if>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type> <name>raise_translate_exception</name><parameter_list>(<param><decl><type><name>PyObject</name> **</type><name>exceptionObject</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>unicode</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>startpos</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>endpos</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>reason</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>make_translate_exception</name><argument_list>(<argument><expr><name>exceptionObject</name></expr></argument>,
<argument><expr><name>unicode</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>startpos</name></expr></argument>, <argument><expr><name>endpos</name></expr></argument>, <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>*<name>exceptionObject</name> != <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyCodec_StrictErrors</name><argument_list>(<argument><expr>*<name>exceptionObject</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type><name>unicode_translate_call_errorhandler</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>,
<param><decl><type><name>PyObject</name> **</type><name>errorHandler</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>reason</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>unicode</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>, <param><decl><type><name>PyObject</name> **</type><name>exceptionObject</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>startpos</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>endpos</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name> *</type><name>newpos</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name>argparse</name> <init>= <expr>"O!n;translating error handler must return (unicode, int) tuple"</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i_newpos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>restuple</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>resunicode</name></decl>;</decl_stmt>
<if>if <condition>(<expr>*<name>errorHandler</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>errorHandler</name> = <call><name>PyCodec_LookupError</name><argument_list>(<argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>*<name>errorHandler</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
}</block></then></if>
<expr_stmt><expr><call><name>make_translate_exception</name><argument_list>(<argument><expr><name>exceptionObject</name></expr></argument>,
<argument><expr><name>unicode</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>startpos</name></expr></argument>, <argument><expr><name>endpos</name></expr></argument>, <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>*<name>exceptionObject</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>restuple</name> = <call><name>PyObject_CallFunctionObjArgs</name><argument_list>(
<argument><expr>*<name>errorHandler</name></expr></argument>, <argument><expr>*<name>exceptionObject</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>restuple</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>restuple</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>&amp;<name><name>argparse</name><index>[<expr>4</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>restuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>restuple</name></expr></argument>, <argument><expr><name>argparse</name></expr></argument>, <argument><expr>&amp;<name>PyUnicode_Type</name></expr></argument>,
<argument><expr>&amp;<name>resunicode</name></expr></argument>, <argument><expr>&amp;<name>i_newpos</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>restuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>i_newpos</name>&lt;0</expr>)</condition><then>
<expr_stmt><expr>*<name>newpos</name> = <name>size</name>+<name>i_newpos</name></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr>*<name>newpos</name> = <name>i_newpos</name></expr>;</expr_stmt></else></if>
<if>if <condition>(<expr>*<name>newpos</name>&lt;0 || *<name>newpos</name>&gt;<name>size</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_IndexError</name></expr></argument>, <argument><expr>"position %zd from error handler out of bounds"</expr></argument>, <argument><expr>*<name>newpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>restuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>resunicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>restuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>resunicode</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier>
<name>int</name></type> <name>charmaptranslate_lookup</name><parameter_list>(<param><decl><type><name>Py_UNICODE</name></type> <name>c</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>mapping</name></decl></param>, <param><decl><type><name>PyObject</name> **</type><name>result</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>w</name> <init>= <expr><call><name>PyInt_FromLong</name><argument_list>(<argument><expr>(<name>long</name>)<name>c</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>x</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>w</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><name>x</name> = <call><name>PyObject_GetItem</name><argument_list>(<argument><expr><name>mapping</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>x</name> == <name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_LookupError</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>result</name> = <name>NULL</name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then> <else>else
<return>return <expr>-1</expr>;</return></else></if>
}</block></then> <else>else <if>if <condition>(<expr><name>x</name> == <name>Py_None</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>result</name> = <name>x</name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>long</name></type> <name>value</name> <init>= <expr><call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>max</name> <init>= <expr><call><name>PyUnicode_GetMax</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>value</name> &lt; 0 || <name>value</name> &gt; <name>max</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"character mapping must be in range(0x%lx)"</expr></argument>, <argument><expr><name>max</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr>*<name>result</name> = <name>x</name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>result</name> = <name>x</name></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"character mapping must return integer, None or unicode"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></else></if></else></if></else></if></else></if>
}</block></function>
<function><type><specifier>static</specifier>
<name>int</name></type> <name>charmaptranslate_makespace</name><parameter_list>(<param><decl><type><name>PyObject</name> **</type><name>outobj</name></decl></param>, <param><decl><type><name>Py_UNICODE</name> **</type><name>outp</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>requiredsize</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>oldsize</name> <init>= <expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr>*<name>outobj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>requiredsize</name> &gt; <name>oldsize</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>outpos</name> <init>= <expr>*<name>outp</name>-<call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr>*<name>outobj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>requiredsize</name> &lt; 2 * <name>oldsize</name></expr>)</condition><then>
<expr_stmt><expr><name>requiredsize</name> = 2 * <name>oldsize</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><call><name>_PyUnicode_Resize</name><argument_list>(<argument><expr><name>outobj</name></expr></argument>, <argument><expr><name>requiredsize</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr>*<name>outp</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr>*<name>outobj</name></expr></argument>)</argument_list></call> + <name>outpos</name></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier>
<name>int</name></type> <name>charmaptranslate_output</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>startinp</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>curinp</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>insize</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>mapping</name></decl></param>, <param><decl><type><name>PyObject</name> **</type><name>outobj</name></decl></param>, <param><decl><type><name>Py_UNICODE</name> **</type><name>outp</name></decl></param>,
<param><decl><type><name>PyObject</name> **</type><name>res</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><call><name>charmaptranslate_lookup</name><argument_list>(<argument><expr>*<name>curinp</name></expr></argument>, <argument><expr><name>mapping</name></expr></argument>, <argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr>*<name>res</name>==<name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*(*<name>outp</name>)++ = *<name>curinp</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr>*<name>res</name>==<name>Py_None</name></expr>)</condition><then>
<empty_stmt>;</empty_stmt></then>
<else>else <if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr>*<name>res</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr>*(*<name>outp</name>)++ = (<name>Py_UNICODE</name>)<call><name>PyInt_AS_LONG</name><argument_list>(<argument><expr>*<name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr>*<name>res</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>repsize</name> <init>= <expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr>*<name>res</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>repsize</name>==1</expr>)</condition><then> <block>{
<expr_stmt><expr>*(*<name>outp</name>)++ = *<call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr>*<name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>repsize</name>!=0</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>requiredsize</name> <init>= <expr>(*<name>outp</name>-<call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr>*<name>outobj</name></expr></argument>)</argument_list></call>) +
(<name>insize</name> - (<name>curinp</name>-<name>startinp</name>)) +
<name>repsize</name> - 1</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>charmaptranslate_makespace</name><argument_list>(<argument><expr><name>outobj</name></expr></argument>, <argument><expr><name>outp</name></expr></argument>, <argument><expr><name>requiredsize</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr>*<name>outp</name></expr></argument>, <argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr>*<name>res</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Py_UNICODE</name></expr></argument>)</argument_list></sizeof>*<name>repsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>outp</name> += <name>repsize</name></expr>;</expr_stmt>
}</block></then></if></else></if>
}</block></then> <else>else
<return>return <expr>-1</expr>;</return></else></if></else></if></else></if></else></if>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type><name>PyUnicode_TranslateCharmap</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>p</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>size</name></decl></param>,
<param><decl><type><name>PyObject</name> *</type><name>mapping</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>startp</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>endp</name> <init>= <expr><name>p</name> + <name>size</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>respos</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>reason</name> <init>= <expr>"character maps to &lt;undefined&gt;"</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>errorHandler</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>exc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>known_errorHandler</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>mapping</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_BadArgument</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>res</name> = <call><name>PyUnicode_FromUnicode</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>res</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<if>if <condition>(<expr><name>size</name> == 0</expr>)</condition><then>
<return>return <expr><name>res</name></expr>;</return></then></if>
<expr_stmt><expr><name>str</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>p</name>&lt;<name>endp</name></expr>)</condition> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>x</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>charmaptranslate_output</name><argument_list>(<argument><expr><name>startp</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>mapping</name></expr></argument>, <argument><expr>&amp;<name>res</name></expr></argument>, <argument><expr>&amp;<name>str</name></expr></argument>, <argument><expr>&amp;<name>x</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>onError</name>;</goto>
}</block></then></if>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>x</name>!=<name>Py_None</name></expr>)</condition><then>
<expr_stmt><expr>++<name>p</name></expr>;</expr_stmt></then>
<else>else <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>repunicode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>repsize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>newpos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>uni2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>collstart</name> <init>= <expr><name>p</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>collend</name> <init>= <expr><name>p</name>+1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>coll</name></decl>;</decl_stmt>
<while>while <condition>(<expr><name>collend</name> &lt; <name>endp</name></expr>)</condition> <block>{
<if>if <condition>(<expr><call><name>charmaptranslate_lookup</name><argument_list>(<argument><expr>*<name>collend</name></expr></argument>, <argument><expr><name>mapping</name></expr></argument>, <argument><expr>&amp;<name>x</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>x</name>!=<name>Py_None</name></expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr>++<name>collend</name></expr>;</expr_stmt>
}</block></while>
<if>if <condition>(<expr><name>known_errorHandler</name>==-1</expr>)</condition><then> <block>{
<if>if <condition>(<expr>(<name>errors</name>==<name>NULL</name>) || (!<call><name>strcmp</name><argument_list>(<argument><expr><name>errors</name></expr></argument>, <argument><expr>"strict"</expr></argument>)</argument_list></call>)</expr>)</condition><then>
<expr_stmt><expr><name>known_errorHandler</name> = 1</expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>errors</name></expr></argument>, <argument><expr>"replace"</expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>known_errorHandler</name> = 2</expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>errors</name></expr></argument>, <argument><expr>"ignore"</expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>known_errorHandler</name> = 3</expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>errors</name></expr></argument>, <argument><expr>"xmlcharrefreplace"</expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>known_errorHandler</name> = 4</expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>known_errorHandler</name> = 0</expr>;</expr_stmt></else></if></else></if></else></if></else></if>
}</block></then></if>
<switch>switch <condition>(<expr><name>known_errorHandler</name></expr>)</condition> <block>{
<case>case <expr>1</expr>:
<expr_stmt><expr><call><name>raise_translate_exception</name><argument_list>(<argument><expr>&amp;<name>exc</name></expr></argument>, <argument><expr><name>startp</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>collstart</name>-<name>startp</name></expr></argument>, <argument><expr><name>collend</name>-<name>startp</name></expr></argument>, <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>onError</name>;</goto>
</case><case>case <expr>2</expr>:
<for>for (<init><expr><name>coll</name> = <name>collstart</name></expr>;</init> <condition><expr><name>coll</name>&lt;<name>collend</name></expr>;</condition> <incr><expr>++<name>coll</name></expr></incr>)
<expr_stmt><expr>*<name>str</name>++ = '?'</expr>;</expr_stmt></for>
</case><case>case <expr>3</expr>:
<expr_stmt><expr><name>p</name> = <name>collend</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>4</expr>:
<for>for (<init><expr><name>p</name> = <name>collstart</name></expr>;</init> <condition><expr><name>p</name> &lt; <name>collend</name></expr>;</condition> <incr><expr>++<name>p</name></expr></incr>) <block>{
<decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr>2+29+1+1</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>cp</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr>"&amp;#%d;"</expr></argument>, <argument><expr>(<name>int</name>)*<name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>charmaptranslate_makespace</name><argument_list>(<argument><expr>&amp;<name>res</name></expr></argument>, <argument><expr>&amp;<name>str</name></expr></argument>,
<argument><expr>(<name>str</name>-<call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call>)+<call><name>strlen</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call>+(<name>endp</name>-<name>collend</name>)</expr></argument>)</argument_list></call></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<for>for (<init><expr><name>cp</name> = <name>buffer</name></expr>;</init> <condition><expr>*<name>cp</name></expr>;</condition> <incr><expr>++<name>cp</name></expr></incr>)
<expr_stmt><expr>*<name>str</name>++ = *<name>cp</name></expr>;</expr_stmt></for>
}</block></for>
<expr_stmt><expr><name>p</name> = <name>collend</name></expr>;</expr_stmt>
<break>break;</break>
</case><default>default:
<expr_stmt><expr><name>repunicode</name> = <call><name>unicode_translate_call_errorhandler</name><argument_list>(<argument><expr><name>errors</name></expr></argument>, <argument><expr>&amp;<name>errorHandler</name></expr></argument>,
<argument><expr><name>reason</name></expr></argument>, <argument><expr><name>startp</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr>&amp;<name>exc</name></expr></argument>,
<argument><expr><name>collstart</name>-<name>startp</name></expr></argument>, <argument><expr><name>collend</name>-<name>startp</name></expr></argument>, <argument><expr>&amp;<name>newpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>repunicode</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<expr_stmt><expr><name>repsize</name> = <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>repunicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>charmaptranslate_makespace</name><argument_list>(<argument><expr>&amp;<name>res</name></expr></argument>, <argument><expr>&amp;<name>str</name></expr></argument>,
<argument><expr>(<name>str</name>-<call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call>)+<name>repsize</name>+(<name>endp</name>-<name>collend</name>)</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>repunicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>onError</name>;</goto>
}</block></then></if>
<for>for (<init><expr><name>uni2</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>repunicode</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>repsize</name>--&gt;0</expr>;</condition> <incr><expr>++<name>uni2</name></expr></incr>)
<expr_stmt><expr>*<name>str</name>++ = *<name>uni2</name></expr>;</expr_stmt></for>
<expr_stmt><expr><name>p</name> = <name>startp</name> + <name>newpos</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>repunicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</default>}</block></switch>
}</block></else></if>
}</block></while>
<expr_stmt><expr><name>respos</name> = <name>str</name>-<call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>respos</name>&lt;<call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>_PyUnicode_Resize</name><argument_list>(<argument><expr>&amp;<name>res</name></expr></argument>, <argument><expr><name>respos</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
}</block></then></if>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>errorHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
<label><name>onError</name>:</label>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>errorHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type><name>PyUnicode_Translate</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>str</name></decl></param>,
<param><decl><type><name>PyObject</name> *</type><name>mapping</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
<expr_stmt><expr><name>str</name> = <call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>str</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<expr_stmt><expr><name>result</name> = <call><name>PyUnicode_TranslateCharmap</name><argument_list>(<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>mapping</name></expr></argument>,
<argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
<label><name>onError</name>:</label>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><name>int</name></type> <name>PyUnicode_EncodeDecimal</name><parameter_list>(<param><decl><type><name>Py_UNICODE</name> *</type><name>s</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>length</name></decl></param>,
<param><decl><type><name>char</name> *</type><name>output</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errors</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>p</name></decl>, *<decl><type ref="prev"/><name>end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>errorHandler</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>exc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>encoding</name> <init>= <expr>"decimal"</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>reason</name> <init>= <expr>"invalid decimal Unicode string"</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>known_errorHandler</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>output</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_BadArgument</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>p</name> = <name>s</name></expr>;</expr_stmt>
<expr_stmt><expr><name>end</name> = <name>s</name> + <name>length</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>p</name> &lt; <name>end</name></expr>)</condition> <block>{
<decl_stmt><decl><type><name>register</name> <name>Py_UNICODE</name></type> <name>ch</name> <init>= <expr>*<name>p</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>decimal</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>repunicode</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>repsize</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>newpos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>uni2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>collstart</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>collend</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>Py_UNICODE_ISSPACE</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>output</name>++ = ' '</expr>;</expr_stmt>
<expr_stmt><expr>++<name>p</name></expr>;</expr_stmt>
<continue>continue;</continue>
}</block></then></if>
<expr_stmt><expr><name>decimal</name> = <call><name>Py_UNICODE_TODECIMAL</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>decimal</name> &gt;= 0</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>output</name>++ = '0' + <name>decimal</name></expr>;</expr_stmt>
<expr_stmt><expr>++<name>p</name></expr>;</expr_stmt>
<continue>continue;</continue>
}</block></then></if>
<if>if <condition>(<expr>0 &lt; <name>ch</name> &amp;&amp; <name>ch</name> &lt; 256</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>output</name>++ = (<name>char</name>)<name>ch</name></expr>;</expr_stmt>
<expr_stmt><expr>++<name>p</name></expr>;</expr_stmt>
<continue>continue;</continue>
}</block></then></if>
<expr_stmt><expr><name>collstart</name> = <name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name>collend</name> = <name>p</name>+1</expr>;</expr_stmt>
<while>while <condition>(<expr><name>collend</name> &lt; <name>end</name></expr>)</condition> <block>{
<if>if <condition>(<expr>(0 &lt; *<name>collend</name> &amp;&amp; *<name>collend</name> &lt; 256) ||
!<call><name>Py_UNICODE_ISSPACE</name><argument_list>(<argument><expr>*<name>collend</name></expr></argument>)</argument_list></call> ||
<call><name>Py_UNICODE_TODECIMAL</name><argument_list>(<argument><expr>*<name>collend</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<break>break;</break></then></if>
}</block></while>
<if>if <condition>(<expr><name>known_errorHandler</name>==-1</expr>)</condition><then> <block>{
<if>if <condition>(<expr>(<name>errors</name>==<name>NULL</name>) || (!<call><name>strcmp</name><argument_list>(<argument><expr><name>errors</name></expr></argument>, <argument><expr>"strict"</expr></argument>)</argument_list></call>)</expr>)</condition><then>
<expr_stmt><expr><name>known_errorHandler</name> = 1</expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>errors</name></expr></argument>, <argument><expr>"replace"</expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>known_errorHandler</name> = 2</expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>errors</name></expr></argument>, <argument><expr>"ignore"</expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>known_errorHandler</name> = 3</expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>errors</name></expr></argument>, <argument><expr>"xmlcharrefreplace"</expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>known_errorHandler</name> = 4</expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>known_errorHandler</name> = 0</expr>;</expr_stmt></else></if></else></if></else></if></else></if>
}</block></then></if>
<switch>switch <condition>(<expr><name>known_errorHandler</name></expr>)</condition> <block>{
<case>case <expr>1</expr>:
<expr_stmt><expr><call><name>raise_encode_exception</name><argument_list>(<argument><expr>&amp;<name>exc</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name>collstart</name>-<name>s</name></expr></argument>, <argument><expr><name>collend</name>-<name>s</name></expr></argument>, <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>onError</name>;</goto>
</case><case>case <expr>2</expr>:
<for>for (<init><expr><name>p</name> = <name>collstart</name></expr>;</init> <condition><expr><name>p</name> &lt; <name>collend</name></expr>;</condition> <incr><expr>++<name>p</name></expr></incr>)
<expr_stmt><expr>*<name>output</name>++ = '?'</expr>;</expr_stmt></for>
</case><case>case <expr>3</expr>:
<expr_stmt><expr><name>p</name> = <name>collend</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>4</expr>:
<for>for (<init><expr><name>p</name> = <name>collstart</name></expr>;</init> <condition><expr><name>p</name> &lt; <name>collend</name></expr>;</condition> <incr><expr>++<name>p</name></expr></incr>)
<expr_stmt><expr><name>output</name> += <call><name>sprintf</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr>"&amp;#%d;"</expr></argument>, <argument><expr>(<name>int</name>)*<name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
<expr_stmt><expr><name>p</name> = <name>collend</name></expr>;</expr_stmt>
<break>break;</break>
</case><default>default:
<expr_stmt><expr><name>repunicode</name> = <call><name>unicode_encode_call_errorhandler</name><argument_list>(<argument><expr><name>errors</name></expr></argument>, <argument><expr>&amp;<name>errorHandler</name></expr></argument>,
<argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>reason</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr>&amp;<name>exc</name></expr></argument>,
<argument><expr><name>collstart</name>-<name>s</name></expr></argument>, <argument><expr><name>collend</name>-<name>s</name></expr></argument>, <argument><expr>&amp;<name>newpos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>repunicode</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<expr_stmt><expr><name>repsize</name> = <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>repunicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>uni2</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>repunicode</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>repsize</name>--&gt;0</expr>;</condition> <incr><expr>++<name>uni2</name></expr></incr>) <block>{
<decl_stmt><decl><type><name>Py_UNICODE</name></type> <name>ch</name> <init>= <expr>*<name>uni2</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>Py_UNICODE_ISSPACE</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr>*<name>output</name>++ = ' '</expr>;</expr_stmt></then>
<else>else <block>{
<expr_stmt><expr><name>decimal</name> = <call><name>Py_UNICODE_TODECIMAL</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>decimal</name> &gt;= 0</expr>)</condition><then>
<expr_stmt><expr>*<name>output</name>++ = '0' + <name>decimal</name></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr>0 &lt; <name>ch</name> &amp;&amp; <name>ch</name> &lt; 256</expr>)</condition><then>
<expr_stmt><expr>*<name>output</name>++ = (<name>char</name>)<name>ch</name></expr>;</expr_stmt></then>
<else>else <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>repunicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>raise_encode_exception</name><argument_list>(<argument><expr>&amp;<name>exc</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>,
<argument><expr><name>s</name></expr></argument>, <argument><expr><name>length</name></expr></argument>, <argument><expr><name>collstart</name>-<name>s</name></expr></argument>, <argument><expr><name>collend</name>-<name>s</name></expr></argument>, <argument><expr><name>reason</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>onError</name>;</goto>
}</block></else></if></else></if>
}</block></else></if>
}</block></for>
<expr_stmt><expr><name>p</name> = <name>s</name> + <name>newpos</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>repunicode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</default>}</block></switch>
}</block></while>
<expr_stmt><expr>*<name>output</name>++ = '\0'</expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>errorHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
<label><name>onError</name>:</label>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>exc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>errorHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></function>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"stringlib/unicodedefs.h"</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FROM_UNICODE</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"stringlib/fastsearch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"stringlib/count.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"stringlib/find.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"stringlib/partition.h"</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FIX_START_END</name><parameter_list>(<param><type><name>obj</name></type></param>)</parameter_list></cpp:macro> <cpp:value>if (start &lt; 0) start += (obj)-&gt;length; if (start &lt; 0) start = 0; if (end &gt; (obj)-&gt;length) end = (obj)-&gt;length; if (end &lt; 0) end += (obj)-&gt;length; if (end &lt; 0) end = 0;</cpp:value></cpp:define>
<function><type><name>Py_ssize_t</name></type> <name>PyUnicode_Count</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>str</name></decl></param>,
<param><decl><type><name>PyObject</name> *</type><name>substr</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>start</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>end</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyUnicodeObject</name>*</type> <name>str_obj</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyUnicodeObject</name>*</type> <name>sub_obj</name></decl>;</decl_stmt>
<expr_stmt><expr><name>str_obj</name> = (<name>PyUnicodeObject</name>*) <call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>str_obj</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><name>sub_obj</name> = (<name>PyUnicodeObject</name>*) <call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>substr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>sub_obj</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>FIX_START_END</name><argument_list>(<argument><expr><name>str_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> = <call><name>stringlib_count</name><argument_list>(
<argument><expr><name><name>str_obj</name>-&gt;<name>str</name></name> + <name>start</name></expr></argument>, <argument><expr><name>end</name> - <name>start</name></expr></argument>, <argument><expr><name><name>sub_obj</name>-&gt;<name>str</name></name></expr></argument>, <argument><expr><name><name>sub_obj</name>-&gt;<name>length</name></name></expr></argument>
)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>sub_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<function><type><name>Py_ssize_t</name></type> <name>PyUnicode_Find</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>str</name></decl></param>,
<param><decl><type><name>PyObject</name> *</type><name>sub</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>start</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>end</name></decl></param>,
<param><decl><type><name>int</name></type> <name>direction</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>result</name></decl>;</decl_stmt>
<expr_stmt><expr><name>str</name> = <call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>str</name></expr>)</condition><then>
<return>return <expr>-2</expr>;</return></then></if>
<expr_stmt><expr><name>sub</name> = <call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>sub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>sub</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-2</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>direction</name> &gt; 0</expr>)</condition><then>
<expr_stmt><expr><name>result</name> = <call><name>stringlib_find_slice</name><argument_list>(
<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>sub</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>sub</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>
)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>result</name> = <call><name>stringlib_rfind_slice</name><argument_list>(
<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>sub</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>sub</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>
)</argument_list></call></expr>;</expr_stmt></else></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>sub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier>
<name>int</name></type> <name>tailmatch</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>,
<param><decl><type><name>PyUnicodeObject</name> *</type><name>substring</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>start</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>end</name></decl></param>,
<param><decl><type><name>int</name></type> <name>direction</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name><name>substring</name>-&gt;<name>length</name></name> == 0</expr>)</condition><then>
<return>return <expr>1</expr>;</return></then></if>
<expr_stmt><expr><call><name>FIX_START_END</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>end</name> -= <name><name>substring</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>end</name> &lt; <name>start</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<if>if <condition>(<expr><name>direction</name> &gt; 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>Py_UNICODE_MATCH</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>substring</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>1</expr>;</return></then></if>
}</block></then> <else>else <block>{
<if>if <condition>(<expr><call><name>Py_UNICODE_MATCH</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>substring</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>1</expr>;</return></then></if>
}</block></else></if>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><name>Py_ssize_t</name></type> <name>PyUnicode_Tailmatch</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>str</name></decl></param>,
<param><decl><type><name>PyObject</name> *</type><name>substr</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>start</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>end</name></decl></param>,
<param><decl><type><name>int</name></type> <name>direction</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>result</name></decl>;</decl_stmt>
<expr_stmt><expr><name>str</name> = <call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>str</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr><name>substr</name> = <call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>substr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>substr</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>result</name> = <call><name>tailmatch</name><argument_list>(<argument><expr>(<name>PyUnicodeObject</name> *)<name>str</name></expr></argument>,
<argument><expr>(<name>PyUnicodeObject</name> *)<name>substr</name></expr></argument>,
<argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>direction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>substr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier>
<name>PyObject</name> *</type><name>fixup</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>,
<param><function_decl><type><name>int</name></type> (*<name>fixfct</name>)<parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>s</name></decl></param>)</parameter_list></function_decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>u</name></decl>;</decl_stmt>
<expr_stmt><expr><name>u</name> = (<name>PyUnicodeObject</name>*) <call><name>PyUnicode_FromUnicode</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>u</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>Py_UNICODE_COPY</name><argument_list>(<argument><expr><name><name>u</name>-&gt;<name>str</name></name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>str</name></name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<call><name>fixfct</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>PyUnicode_CheckExact</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name>*) <name>self</name></expr>;</return>
}</block></then></if>
<return>return <expr>(<name>PyObject</name>*) <name>u</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier>
<name>int</name></type> <name>fixupper</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name> <init>= <expr><name><name>self</name>-&gt;<name>length</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>s</name> <init>= <expr><name><name>self</name>-&gt;<name>str</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>status</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>len</name>-- &gt; 0</expr>)</condition> <block>{
<decl_stmt><decl><type><name>register</name> <name>Py_UNICODE</name></type> <name>ch</name></decl>;</decl_stmt>
<expr_stmt><expr><name>ch</name> = <call><name>Py_UNICODE_TOUPPER</name><argument_list>(<argument><expr>*<name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ch</name> != *<name>s</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>status</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr>*<name>s</name> = <name>ch</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt>
}</block></while>
<return>return <expr><name>status</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier>
<name>int</name></type> <name>fixlower</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name> <init>= <expr><name><name>self</name>-&gt;<name>length</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>s</name> <init>= <expr><name><name>self</name>-&gt;<name>str</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>status</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>len</name>-- &gt; 0</expr>)</condition> <block>{
<decl_stmt><decl><type><name>register</name> <name>Py_UNICODE</name></type> <name>ch</name></decl>;</decl_stmt>
<expr_stmt><expr><name>ch</name> = <call><name>Py_UNICODE_TOLOWER</name><argument_list>(<argument><expr>*<name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ch</name> != *<name>s</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>status</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr>*<name>s</name> = <name>ch</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt>
}</block></while>
<return>return <expr><name>status</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier>
<name>int</name></type> <name>fixswapcase</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name> <init>= <expr><name><name>self</name>-&gt;<name>length</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>s</name> <init>= <expr><name><name>self</name>-&gt;<name>str</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>status</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>len</name>-- &gt; 0</expr>)</condition> <block>{
<if>if <condition>(<expr><call><name>Py_UNICODE_ISUPPER</name><argument_list>(<argument><expr>*<name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>s</name> = <call><name>Py_UNICODE_TOLOWER</name><argument_list>(<argument><expr>*<name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>status</name> = 1</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><call><name>Py_UNICODE_ISLOWER</name><argument_list>(<argument><expr>*<name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>s</name> = <call><name>Py_UNICODE_TOUPPER</name><argument_list>(<argument><expr>*<name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>status</name> = 1</expr>;</expr_stmt>
}</block></then></if></else></if>
<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt>
}</block></while>
<return>return <expr><name>status</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier>
<name>int</name></type> <name>fixcapitalize</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name> <init>= <expr><name><name>self</name>-&gt;<name>length</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>s</name> <init>= <expr><name><name>self</name>-&gt;<name>str</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>status</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>len</name> == 0</expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<if>if <condition>(<expr><call><name>Py_UNICODE_ISLOWER</name><argument_list>(<argument><expr>*<name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>s</name> = <call><name>Py_UNICODE_TOUPPER</name><argument_list>(<argument><expr>*<name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>status</name> = 1</expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt>
<while>while <condition>(<expr>--<name>len</name> &gt; 0</expr>)</condition> <block>{
<if>if <condition>(<expr><call><name>Py_UNICODE_ISUPPER</name><argument_list>(<argument><expr>*<name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>s</name> = <call><name>Py_UNICODE_TOLOWER</name><argument_list>(<argument><expr>*<name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>status</name> = 1</expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>s</name>++</expr>;</expr_stmt>
}</block></while>
<return>return <expr><name>status</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier>
<name>int</name></type> <name>fixtitle</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>register</name> <name>Py_UNICODE</name> *</type><name>p</name> <init>= <expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <name>Py_UNICODE</name> *</type><name>e</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>previous_is_cased</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> == 1</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>Py_UNICODE</name></type> <name>ch</name> <init>= <expr><call><name>Py_UNICODE_TOTITLE</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>*<name>p</name> != <name>ch</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>p</name> = <name>ch</name></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></then> <else>else
<return>return <expr>0</expr>;</return></else></if>
}</block></then></if>
<expr_stmt><expr><name>e</name> = <name>p</name> + <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>previous_is_cased</name> = 0</expr>;</expr_stmt>
<for>for (<init>;</init> <condition><expr><name>p</name> &lt; <name>e</name></expr>;</condition> <incr><expr><name>p</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>Py_UNICODE</name></type> <name>ch</name> <init>= <expr>*<name>p</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>previous_is_cased</name></expr>)</condition><then>
<expr_stmt><expr>*<name>p</name> = <call><name>Py_UNICODE_TOLOWER</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr>*<name>p</name> = <call><name>Py_UNICODE_TOTITLE</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<if>if <condition>(<expr><call><name>Py_UNICODE_ISLOWER</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> ||
<call><name>Py_UNICODE_ISUPPER</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> ||
<call><name>Py_UNICODE_ISTITLE</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>previous_is_cased</name> = 1</expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>previous_is_cased</name> = 0</expr>;</expr_stmt></else></if>
}</block></for>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type>
<name>PyUnicode_Join</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>separator</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>seq</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>internal_separator</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Py_UNICODE</name></type> <name>blank</name> <init>= <expr>' '</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>sep</name> <init>= <expr>&amp;<name>blank</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>seplen</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>res</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>res_alloc</name> <init>= <expr>100</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>res_used</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>res_p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>fseq</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>seqlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>item</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><name>fseq</name> = <call><name>PySequence_Fast</name><argument_list>(<argument><expr><name>seq</name></expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>fseq</name> == <name>NULL</name></expr>)</condition><then> <block>{
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>seqlen</name> = <call><name>PySequence_Fast_GET_SIZE</name><argument_list>(<argument><expr><name>fseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>seqlen</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>res</name> = <call><name>_PyUnicode_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>Done</name>;</goto>
}</block></then></if>
<if>if <condition>(<expr><name>seqlen</name> == 1</expr>)</condition><then> <block>{
<expr_stmt><expr><name>item</name> = <call><name>PySequence_Fast_GET_ITEM</name><argument_list>(<argument><expr><name>fseq</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyUnicode_CheckExact</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>res</name> = (<name>PyUnicodeObject</name> *)<name>item</name></expr>;</expr_stmt>
<goto>goto <name>Done</name>;</goto>
}</block></then></if>
}</block></then></if>
<if>if <condition>(<expr><name>seqlen</name> &gt; 1</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>separator</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>sep</name> = &amp;<name>blank</name></expr>;</expr_stmt>
<expr_stmt><expr><name>seplen</name> = 1</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>internal_separator</name> = <call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>separator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>internal_separator</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<expr_stmt><expr><name>sep</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>internal_separator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>seplen</name> = <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>internal_separator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>seqlen</name> = <call><name>PySequence_Fast_GET_SIZE</name><argument_list>(<argument><expr><name>fseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
}</block></then></if>
<expr_stmt><expr><name>res</name> = <call><name>_PyUnicode_New</name><argument_list>(<argument><expr><name>res_alloc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>res</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<expr_stmt><expr><name>res_p</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>res_used</name> = 0</expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>seqlen</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>itemlen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>new_res_used</name></decl>;</decl_stmt>
<expr_stmt><expr><name>item</name> = <call><name>PySequence_Fast_GET_ITEM</name><argument_list>(<argument><expr><name>fseq</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>! <call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call> &amp;&amp; ! <call><name>PyString_Check</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"sequence item %zd: expected string or Unicode,"
" %.80s found"</expr></argument>,
<argument><expr><name>i</name></expr></argument>, <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>onError</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>item</name> = <call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>item</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<expr_stmt><expr><name>seqlen</name> = <call><name>PySequence_Fast_GET_SIZE</name><argument_list>(<argument><expr><name>fseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>itemlen</name> = <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>new_res_used</name> = <name>res_used</name> + <name>itemlen</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>new_res_used</name> &lt; 0</expr>)</condition><then>
<goto>goto <name>Overflow</name>;</goto></then></if>
<if>if <condition>(<expr><name>i</name> &lt; <name>seqlen</name> - 1</expr>)</condition><then> <block>{
<expr_stmt><expr><name>new_res_used</name> += <name>seplen</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>new_res_used</name> &lt; 0</expr>)</condition><then>
<goto>goto <name>Overflow</name>;</goto></then></if>
}</block></then></if>
<if>if <condition>(<expr><name>new_res_used</name> &gt; <name>res_alloc</name></expr>)</condition><then> <block>{
<do>do <block>{
<expr_stmt><expr><name>res_alloc</name> += <name>res_alloc</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>res_alloc</name> &lt;= 0</expr>)</condition><then>
<goto>goto <name>Overflow</name>;</goto></then></if>
}</block> while <condition>(<expr><name>new_res_used</name> &gt; <name>res_alloc</name></expr>)</condition>;</do>
<if>if <condition>(<expr><call><name>_PyUnicode_Resize</name><argument_list>(<argument><expr>&amp;<name>res</name></expr></argument>, <argument><expr><name>res_alloc</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>onError</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>res_p</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call> + <name>res_used</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>Py_UNICODE_COPY</name><argument_list>(<argument><expr><name>res_p</name></expr></argument>, <argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>itemlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>res_p</name> += <name>itemlen</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>i</name> &lt; <name>seqlen</name> - 1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_UNICODE_COPY</name><argument_list>(<argument><expr><name>res_p</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>, <argument><expr><name>seplen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>res_p</name> += <name>seplen</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>res_used</name> = <name>new_res_used</name></expr>;</expr_stmt>
}</block></for>
<if>if <condition>(<expr><call><name>_PyUnicode_Resize</name><argument_list>(<argument><expr>&amp;<name>res</name></expr></argument>, <argument><expr><name>res_used</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<label><name>Done</name>:</label>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>internal_separator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>fseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *)<name>res</name></expr>;</return>
<label><name>Overflow</name>:</label>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
<argument><expr>"join() result is too long for a Python string"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>onError</name>:</label>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>internal_separator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>fseq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier>
<name>PyUnicodeObject</name> *</type><name>pad</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>left</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>right</name></decl></param>,
<param><decl><type><name>Py_UNICODE</name></type> <name>fill</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>u</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>left</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>left</name> = 0</expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>right</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>right</name> = 0</expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>left</name> == 0 &amp;&amp; <name>right</name> == 0 &amp;&amp; <call><name>PyUnicode_CheckExact</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>self</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>left</name> &gt; <name>PY_SSIZE_T_MAX</name> - <name><name>self</name>-&gt;<name>length</name></name> ||
<name>right</name> &gt; <name>PY_SSIZE_T_MAX</name> - (<name>left</name> + <name><name>self</name>-&gt;<name>length</name></name>)</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>, <argument><expr>"padded string is too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>u</name> = <call><name>_PyUnicode_New</name><argument_list>(<argument><expr><name>left</name> + <name><name>self</name>-&gt;<name>length</name></name> + <name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>u</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>left</name></expr>)</condition><then>
<expr_stmt><expr><call><name>Py_UNICODE_FILL</name><argument_list>(<argument><expr><name><name>u</name>-&gt;<name>str</name></name></expr></argument>, <argument><expr><name>fill</name></expr></argument>, <argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>Py_UNICODE_COPY</name><argument_list>(<argument><expr><name><name>u</name>-&gt;<name>str</name></name> + <name>left</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>str</name></name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>right</name></expr>)</condition><then>
<expr_stmt><expr><call><name>Py_UNICODE_FILL</name><argument_list>(<argument><expr><name><name>u</name>-&gt;<name>str</name></name> + <name>left</name> + <name><name>self</name>-&gt;<name>length</name></name></expr></argument>, <argument><expr><name>fill</name></expr></argument>, <argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></then></if>
<return>return <expr><name>u</name></expr>;</return>
}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SPLIT_APPEND</name><parameter_list>(<param><type><name>data</name></type></param>, <param><type><name>left</name></type></param>, <param><type><name>right</name></type></param>)</parameter_list></cpp:macro> <cpp:value>str = PyUnicode_FromUnicode((data) + (left), (right) - (left)); if (!str) goto onError; if (PyList_Append(list, str)) { Py_DECREF(str); goto onError; } else Py_DECREF(str);</cpp:value></cpp:define>
<function><type><specifier>static</specifier>
<name>PyObject</name> *</type><name>split_whitespace</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>,
<param><decl><type><name>PyObject</name> *</type><name>list</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>maxcount</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name> <init>= <expr><name><name>self</name>-&gt;<name>length</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>buf</name> <init>= <expr><name><name>self</name>-&gt;<name>str</name></name></expr></init></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = <name>j</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr/>) <block>{
<while>while <condition>(<expr><name>i</name> &lt; <name>len</name> &amp;&amp; <call><name>Py_UNICODE_ISSPACE</name><argument_list>(<argument><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
<expr_stmt><expr><name>i</name>++</expr>;</expr_stmt></while>
<expr_stmt><expr><name>j</name> = <name>i</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>i</name> &lt; <name>len</name> &amp;&amp; !<call><name>Py_UNICODE_ISSPACE</name><argument_list>(<argument><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
<expr_stmt><expr><name>i</name>++</expr>;</expr_stmt></while>
<if>if <condition>(<expr><name>j</name> &lt; <name>i</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>maxcount</name>-- &lt;= 0</expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr><call><name>SPLIT_APPEND</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>i</name> &lt; <name>len</name> &amp;&amp; <call><name>Py_UNICODE_ISSPACE</name><argument_list>(<argument><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
<expr_stmt><expr><name>i</name>++</expr>;</expr_stmt></while>
<expr_stmt><expr><name>j</name> = <name>i</name></expr>;</expr_stmt>
}</block></then></if>
}</block></for>
<if>if <condition>(<expr><name>j</name> &lt; <name>len</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>SPLIT_APPEND</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>list</name></expr>;</return>
<label><name>onError</name>:</label>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type><name>PyUnicode_Splitlines</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>string</name></decl></param>,
<param><decl><type><name>int</name></type> <name>keepends</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>list</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>data</name></decl>;</decl_stmt>
<expr_stmt><expr><name>string</name> = <call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>string</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>data</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> = <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>list</name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>list</name></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<for>for (<init><expr><name>i</name> = <name>j</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr/>) <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>eol</name></decl>;</decl_stmt>
<while>while <condition>(<expr><name>i</name> &lt; <name>len</name> &amp;&amp; !<call><name>BLOOM_LINEBREAK</name><argument_list>(<argument><expr><name><name>data</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
<expr_stmt><expr><name>i</name>++</expr>;</expr_stmt></while>
<expr_stmt><expr><name>eol</name> = <name>i</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>i</name> &lt; <name>len</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>data</name><index>[<expr><name>i</name></expr>]</index></name> == '\r' &amp;&amp; <name>i</name> + 1 &lt; <name>len</name> &amp;&amp;
<name><name>data</name><index>[<expr><name>i</name>+1</expr>]</index></name> == '\n'</expr>)</condition><then>
<expr_stmt><expr><name>i</name> += 2</expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>i</name>++</expr>;</expr_stmt></else></if>
<if>if <condition>(<expr><name>keepends</name></expr>)</condition><then>
<expr_stmt><expr><name>eol</name> = <name>i</name></expr>;</expr_stmt></then></if>
}</block></then></if>
<expr_stmt><expr><call><name>SPLIT_APPEND</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>eol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name> = <name>i</name></expr>;</expr_stmt>
}</block></for>
<if>if <condition>(<expr><name>j</name> &lt; <name>len</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>SPLIT_APPEND</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>list</name></expr>;</return>
<label><name>onError</name>:</label>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier>
<name>PyObject</name> *</type><name>split_char</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>,
<param><decl><type><name>PyObject</name> *</type><name>list</name></decl></param>,
<param><decl><type><name>Py_UNICODE</name></type> <name>ch</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>maxcount</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name> <init>= <expr><name><name>self</name>-&gt;<name>length</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>buf</name> <init>= <expr><name><name>self</name>-&gt;<name>str</name></name></expr></init></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = <name>j</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr/>) <block>{
<if>if <condition>(<expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name> == <name>ch</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>maxcount</name>-- &lt;= 0</expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr><call><name>SPLIT_APPEND</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> = <name>j</name> = <name>i</name> + 1</expr>;</expr_stmt>
}</block></then> <else>else
<expr_stmt><expr><name>i</name>++</expr>;</expr_stmt></else></if>
}</block></for>
<if>if <condition>(<expr><name>j</name> &lt;= <name>len</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>SPLIT_APPEND</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>list</name></expr>;</return>
<label><name>onError</name>:</label>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier>
<name>PyObject</name> *</type><name>split_substring</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>,
<param><decl><type><name>PyObject</name> *</type><name>list</name></decl></param>,
<param><decl><type><name>PyUnicodeObject</name> *</type><name>substring</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>maxcount</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name> <init>= <expr><name><name>self</name>-&gt;<name>length</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>sublen</name> <init>= <expr><name><name>substring</name>-&gt;<name>length</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>str</name></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = <name>j</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt;= <name>len</name> - <name>sublen</name></expr>;</condition> <incr/>) <block>{
<if>if <condition>(<expr><call><name>Py_UNICODE_MATCH</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>substring</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>maxcount</name>-- &lt;= 0</expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr><call><name>SPLIT_APPEND</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>str</name></name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> = <name>j</name> = <name>i</name> + <name>sublen</name></expr>;</expr_stmt>
}</block></then> <else>else
<expr_stmt><expr><name>i</name>++</expr>;</expr_stmt></else></if>
}</block></for>
<if>if <condition>(<expr><name>j</name> &lt;= <name>len</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>SPLIT_APPEND</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>str</name></name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>list</name></expr>;</return>
<label><name>onError</name>:</label>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier>
<name>PyObject</name> *</type><name>rsplit_whitespace</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>,
<param><decl><type><name>PyObject</name> *</type><name>list</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>maxcount</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name> <init>= <expr><name><name>self</name>-&gt;<name>length</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>buf</name> <init>= <expr><name><name>self</name>-&gt;<name>str</name></name></expr></init></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = <name>j</name> = <name>len</name> - 1</expr>;</init> <condition><expr><name>i</name> &gt;= 0</expr>;</condition> <incr/>) <block>{
<while>while <condition>(<expr><name>i</name> &gt;= 0 &amp;&amp; <call><name>Py_UNICODE_ISSPACE</name><argument_list>(<argument><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
<expr_stmt><expr><name>i</name>--</expr>;</expr_stmt></while>
<expr_stmt><expr><name>j</name> = <name>i</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>i</name> &gt;= 0 &amp;&amp; !<call><name>Py_UNICODE_ISSPACE</name><argument_list>(<argument><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
<expr_stmt><expr><name>i</name>--</expr>;</expr_stmt></while>
<if>if <condition>(<expr><name>j</name> &gt; <name>i</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>maxcount</name>-- &lt;= 0</expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr><call><name>SPLIT_APPEND</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>i</name> + 1</expr></argument>, <argument><expr><name>j</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>i</name> &gt;= 0 &amp;&amp; <call><name>Py_UNICODE_ISSPACE</name><argument_list>(<argument><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
<expr_stmt><expr><name>i</name>--</expr>;</expr_stmt></while>
<expr_stmt><expr><name>j</name> = <name>i</name></expr>;</expr_stmt>
}</block></then></if>
}</block></for>
<if>if <condition>(<expr><name>j</name> &gt;= 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>SPLIT_APPEND</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>j</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><call><name>PyList_Reverse</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<return>return <expr><name>list</name></expr>;</return>
<label><name>onError</name>:</label>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier>
<name>PyObject</name> *</type><name>rsplit_char</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>,
<param><decl><type><name>PyObject</name> *</type><name>list</name></decl></param>,
<param><decl><type><name>Py_UNICODE</name></type> <name>ch</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>maxcount</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name> <init>= <expr><name><name>self</name>-&gt;<name>length</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>buf</name> <init>= <expr><name><name>self</name>-&gt;<name>str</name></name></expr></init></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = <name>j</name> = <name>len</name> - 1</expr>;</init> <condition><expr><name>i</name> &gt;= 0</expr>;</condition> <incr/>) <block>{
<if>if <condition>(<expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name> == <name>ch</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>maxcount</name>-- &lt;= 0</expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr><call><name>SPLIT_APPEND</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>i</name> + 1</expr></argument>, <argument><expr><name>j</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name> = <name>i</name> = <name>i</name> - 1</expr>;</expr_stmt>
}</block></then> <else>else
<expr_stmt><expr><name>i</name>--</expr>;</expr_stmt></else></if>
}</block></for>
<if>if <condition>(<expr><name>j</name> &gt;= -1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>SPLIT_APPEND</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>j</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><call><name>PyList_Reverse</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<return>return <expr><name>list</name></expr>;</return>
<label><name>onError</name>:</label>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier>
<name>PyObject</name> *</type><name>rsplit_substring</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>,
<param><decl><type><name>PyObject</name> *</type><name>list</name></decl></param>,
<param><decl><type><name>PyUnicodeObject</name> *</type><name>substring</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>maxcount</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name> <init>= <expr><name><name>self</name>-&gt;<name>length</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>sublen</name> <init>= <expr><name><name>substring</name>-&gt;<name>length</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>str</name></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = <name>len</name> - <name>sublen</name></expr>, <expr><name>j</name> = <name>len</name></expr>;</init> <condition><expr><name>i</name> &gt;= 0</expr>;</condition> <incr/>) <block>{
<if>if <condition>(<expr><call><name>Py_UNICODE_MATCH</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>substring</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>maxcount</name>-- &lt;= 0</expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr><call><name>SPLIT_APPEND</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>str</name></name></expr></argument>, <argument><expr><name>i</name> + <name>sublen</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name> = <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> -= <name>sublen</name></expr>;</expr_stmt>
}</block></then> <else>else
<expr_stmt><expr><name>i</name>--</expr>;</expr_stmt></else></if>
}</block></for>
<if>if <condition>(<expr><name>j</name> &gt;= 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>SPLIT_APPEND</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>str</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><call><name>PyList_Reverse</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<return>return <expr><name>list</name></expr>;</return>
<label><name>onError</name>:</label>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SPLIT_APPEND</name></cpp:undef>
<function><type><specifier>static</specifier>
<name>PyObject</name> *</type><name>split</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>,
<param><decl><type><name>PyUnicodeObject</name> *</type><name>substring</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>maxcount</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>list</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>maxcount</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>maxcount</name> = <name>PY_SSIZE_T_MAX</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>list</name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>list</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>substring</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><call><name>split_whitespace</name><argument_list>(<argument><expr><name>self</name></expr></argument>,<argument><expr><name>list</name></expr></argument>,<argument><expr><name>maxcount</name></expr></argument>)</argument_list></call></expr>;</return></then>
<else>else <if>if <condition>(<expr><name><name>substring</name>-&gt;<name>length</name></name> == 1</expr>)</condition><then>
<return>return <expr><call><name>split_char</name><argument_list>(<argument><expr><name>self</name></expr></argument>,<argument><expr><name>list</name></expr></argument>,<argument><expr><name><name>substring</name>-&gt;<name>str</name><index>[<expr>0</expr>]</index></name></expr></argument>,<argument><expr><name>maxcount</name></expr></argument>)</argument_list></call></expr>;</return></then>
<else>else <if>if <condition>(<expr><name><name>substring</name>-&gt;<name>length</name></name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"empty separator"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then> <else>else
<return>return <expr><call><name>split_substring</name><argument_list>(<argument><expr><name>self</name></expr></argument>,<argument><expr><name>list</name></expr></argument>,<argument><expr><name>substring</name></expr></argument>,<argument><expr><name>maxcount</name></expr></argument>)</argument_list></call></expr>;</return></else></if></else></if></else></if>
}</block></function>
<function><type><specifier>static</specifier>
<name>PyObject</name> *</type><name>rsplit</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>,
<param><decl><type><name>PyUnicodeObject</name> *</type><name>substring</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>maxcount</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>list</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>maxcount</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>maxcount</name> = <name>PY_SSIZE_T_MAX</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>list</name> = <call><name>PyList_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>list</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>substring</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><call><name>rsplit_whitespace</name><argument_list>(<argument><expr><name>self</name></expr></argument>,<argument><expr><name>list</name></expr></argument>,<argument><expr><name>maxcount</name></expr></argument>)</argument_list></call></expr>;</return></then>
<else>else <if>if <condition>(<expr><name><name>substring</name>-&gt;<name>length</name></name> == 1</expr>)</condition><then>
<return>return <expr><call><name>rsplit_char</name><argument_list>(<argument><expr><name>self</name></expr></argument>,<argument><expr><name>list</name></expr></argument>,<argument><expr><name><name>substring</name>-&gt;<name>str</name><index>[<expr>0</expr>]</index></name></expr></argument>,<argument><expr><name>maxcount</name></expr></argument>)</argument_list></call></expr>;</return></then>
<else>else <if>if <condition>(<expr><name><name>substring</name>-&gt;<name>length</name></name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"empty separator"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then> <else>else
<return>return <expr><call><name>rsplit_substring</name><argument_list>(<argument><expr><name>self</name></expr></argument>,<argument><expr><name>list</name></expr></argument>,<argument><expr><name>substring</name></expr></argument>,<argument><expr><name>maxcount</name></expr></argument>)</argument_list></call></expr>;</return></else></if></else></if></else></if>
}</block></function>
<function><type><specifier>static</specifier>
<name>PyObject</name> *</type><name>replace</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>,
<param><decl><type><name>PyUnicodeObject</name> *</type><name>str1</name></decl></param>,
<param><decl><type><name>PyUnicodeObject</name> *</type><name>str2</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>maxcount</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>u</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>maxcount</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>maxcount</name> = <name>PY_SSIZE_T_MAX</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name><name>str1</name>-&gt;<name>length</name></name> == <name><name>str2</name>-&gt;<name>length</name></name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>str1</name>-&gt;<name>length</name></name> == 1</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>Py_UNICODE</name></type> <name>u1</name></decl>, <decl><type ref="prev"/><name>u2</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>findchar</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>str</name></name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>length</name></name></expr></argument>, <argument><expr><name><name>str1</name>-&gt;<name>str</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
<goto>goto <name>nothing</name>;</goto></then></if>
<expr_stmt><expr><name>u</name> = (<name>PyUnicodeObject</name>*) <call><name>PyUnicode_FromUnicode</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>u</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>Py_UNICODE_COPY</name><argument_list>(<argument><expr><name><name>u</name>-&gt;<name>str</name></name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>str</name></name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>u1</name> = <name><name>str1</name>-&gt;<name>str</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name>u2</name> = <name><name>str2</name>-&gt;<name>str</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>u</name>-&gt;<name>length</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
<if>if <condition>(<expr><name><name>u</name>-&gt;<name>str</name><index>[<expr><name>i</name></expr>]</index></name> == <name>u1</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>--<name>maxcount</name> &lt; 0</expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr><name><name>u</name>-&gt;<name>str</name><index>[<expr><name>i</name></expr>]</index></name> = <name>u2</name></expr>;</expr_stmt>
}</block></then></if></for>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>i</name> = <call><name>fastsearch</name><argument_list>(
<argument><expr><name><name>self</name>-&gt;<name>str</name></name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>length</name></name></expr></argument>, <argument><expr><name><name>str1</name>-&gt;<name>str</name></name></expr></argument>, <argument><expr><name><name>str1</name>-&gt;<name>length</name></name></expr></argument>, <argument><expr><name>FAST_SEARCH</name></expr></argument>
)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then>
<goto>goto <name>nothing</name>;</goto></then></if>
<expr_stmt><expr><name>u</name> = (<name>PyUnicodeObject</name>*) <call><name>PyUnicode_FromUnicode</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>u</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>Py_UNICODE_COPY</name><argument_list>(<argument><expr><name><name>u</name>-&gt;<name>str</name></name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>str</name></name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>i</name> &lt;= <name><name>self</name>-&gt;<name>length</name></name> - <name><name>str1</name>-&gt;<name>length</name></name></expr>)</condition>
<if>if <condition>(<expr><call><name>Py_UNICODE_MATCH</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>str1</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr>--<name>maxcount</name> &lt; 0</expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr><call><name>Py_UNICODE_COPY</name><argument_list>(<argument><expr><name><name>u</name>-&gt;<name>str</name></name>+<name>i</name></expr></argument>, <argument><expr><name><name>str2</name>-&gt;<name>str</name></name></expr></argument>, <argument><expr><name><name>str2</name>-&gt;<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> += <name><name>str1</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
}</block></then> <else>else
<expr_stmt><expr><name>i</name>++</expr>;</expr_stmt></else></if></while>
}</block></else></if>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n</name></decl>, <decl><type ref="prev"/><name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>e</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>product</name></decl>, <decl><type ref="prev"/><name>new_size</name></decl>, <decl><type ref="prev"/><name>delta</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>p</name></decl>;</decl_stmt>
<expr_stmt><expr><name>n</name> = <call><name>stringlib_count</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>str</name></name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>length</name></name></expr></argument>, <argument><expr><name><name>str1</name>-&gt;<name>str</name></name></expr></argument>, <argument><expr><name><name>str1</name>-&gt;<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>n</name> &gt; <name>maxcount</name></expr>)</condition><then>
<expr_stmt><expr><name>n</name> = <name>maxcount</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>n</name> == 0</expr>)</condition><then>
<goto>goto <name>nothing</name>;</goto></then></if>
<expr_stmt><expr><name>delta</name> = (<name><name>str2</name>-&gt;<name>length</name></name> - <name><name>str1</name>-&gt;<name>length</name></name>)</expr>;</expr_stmt>
<if>if <condition>(<expr><name>delta</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>new_size</name> = <name><name>self</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>product</name> = <call><name>n</name> * <argument_list>(<argument><expr><name><name>str2</name>-&gt;<name>length</name></name> - <name><name>str1</name>-&gt;<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>(<name>product</name> / (<name><name>str2</name>-&gt;<name>length</name></name> - <name><name>str1</name>-&gt;<name>length</name></name>)) != <name>n</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
<argument><expr>"replace string is too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>new_size</name> = <name><name>self</name>-&gt;<name>length</name></name> + <name>product</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>new_size</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
<argument><expr>"replace string is too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
}</block></else></if>
<expr_stmt><expr><name>u</name> = <call><name>_PyUnicode_New</name><argument_list>(<argument><expr><name>new_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>u</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>i</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> = <name><name>u</name>-&gt;<name>str</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>e</name> = <name><name>self</name>-&gt;<name>length</name></name> - <name><name>str1</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>str1</name>-&gt;<name>length</name></name> &gt; 0</expr>)</condition><then> <block>{
<while>while <condition>(<expr><name>n</name>-- &gt; 0</expr>)</condition> <block>{
<expr_stmt><expr><name>j</name> = <name>i</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>j</name> &lt;= <name>e</name></expr>)</condition> <block>{
<if>if <condition>(<expr><call><name>Py_UNICODE_MATCH</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>str1</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr><name>j</name>++</expr>;</expr_stmt>
}</block></while>
<if>if <condition>(<expr><name>j</name> &gt; <name>i</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>j</name> &gt; <name>e</name></expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr><call><name>Py_UNICODE_COPY</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>str</name></name>+<name>i</name></expr></argument>, <argument><expr><name>j</name>-<name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> += <name>j</name> - <name>i</name></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name><name>str2</name>-&gt;<name>length</name></name> &gt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_UNICODE_COPY</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>str2</name>-&gt;<name>str</name></name></expr></argument>, <argument><expr><name><name>str2</name>-&gt;<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> += <name><name>str2</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>i</name> = <name>j</name> + <name><name>str1</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
}</block></while>
<if>if <condition>(<expr><name>i</name> &lt; <name><name>self</name>-&gt;<name>length</name></name></expr>)</condition><then>
<expr_stmt><expr><call><name>Py_UNICODE_COPY</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>str</name></name>+<name>i</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>length</name></name>-<name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></then> <else>else <block>{
<while>while <condition>(<expr><name>n</name> &gt; 0</expr>)</condition> <block>{
<expr_stmt><expr><call><name>Py_UNICODE_COPY</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>str2</name>-&gt;<name>str</name></name></expr></argument>, <argument><expr><name><name>str2</name>-&gt;<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> += <name><name>str2</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr>--<name>n</name> &lt;= 0</expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr>*<name>p</name>++ = <name><name>self</name>-&gt;<name>str</name><index>[<expr><name>i</name>++</expr>]</index></name></expr>;</expr_stmt>
}</block></while>
<expr_stmt><expr><call><name>Py_UNICODE_COPY</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>str</name></name>+<name>i</name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>length</name></name>-<name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
}</block></else></if>
<return>return <expr>(<name>PyObject</name> *) <name>u</name></expr>;</return>
<label><name>nothing</name>:</label>
<if>if <condition>(<expr><call><name>PyUnicode_CheckExact</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *) <name>self</name></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>PyUnicode_FromUnicode</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>str</name></name></expr></argument>, <argument><expr><name><name>self</name>-&gt;<name>length</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>title__doc__</name></expr></argument>,
<argument><expr>"S.title() -&gt; unicode\n\
\n\
Return a titlecased version of S, i.e. words start with title case\n\
characters, all remaining cased characters have lower case."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>unicode_title</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>fixup</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>fixtitle</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>capitalize__doc__</name></expr></argument>,
<argument><expr>"S.capitalize() -&gt; unicode\n\
\n\
Return a capitalized version of S, i.e. make the first character\n\
have upper case."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>unicode_capitalize</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>fixup</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>fixcapitalize</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
PyDoc_STRVAR(capwords__doc__,
"S.capwords() -&gt; unicode\n\
\n\
Apply .capitalize() to all words in S and return the result with\n\
normalized whitespace (all whitespace strings are replaced by ' ').");
static PyObject*
unicode_capwords(PyUnicodeObject *self) {
PyObject *list;
PyObject *item;
Py_ssize_t i;
list = split(self, NULL, -1);
if (!list)
return NULL;
for (i = 0; i &lt; PyList_GET_SIZE(list); i++) {
item = fixup((PyUnicodeObject *)PyList_GET_ITEM(list, i),
fixcapitalize);
if (item == NULL)
goto onError;
Py_DECREF(PyList_GET_ITEM(list, i));
PyList_SET_ITEM(list, i, item);
}
item = PyUnicode_Join(NULL, list);
onError:
Py_DECREF(list);
return (PyObject *)item;
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>convert_uc</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>, <param><decl><type><name>void</name> *</type><name>addr</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>fillcharloc</name> <init>= <expr>(<name>Py_UNICODE</name> *)<name>addr</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>uniobj</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>unistr</name></decl>;</decl_stmt>
<expr_stmt><expr><name>uniobj</name> = <call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>uniobj</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"The fill character cannot be converted to Unicode"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>uniobj</name></expr></argument>)</argument_list></call> != 1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"The fill character must be exactly one character long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>uniobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>unistr</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>uniobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>fillcharloc</name> = <name><name>unistr</name><index>[<expr>0</expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>uniobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>center__doc__</name></expr></argument>,
<argument><expr>"S.center(width[, fillchar]) -&gt; unicode\n\
\n\
Return S centered in a Unicode string of length width. Padding is\n\
done using the specified fill character (default is a space)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>unicode_center</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>marg</name></decl>, <decl><type ref="prev"/><name>left</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>width</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UNICODE</name></type> <name>fillchar</name> <init>= <expr>' '</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"n|O&amp;:center"</expr></argument>, <argument><expr>&amp;<name>width</name></expr></argument>, <argument><expr><name>convert_uc</name></expr></argument>, <argument><expr>&amp;<name>fillchar</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>length</name></name> &gt;= <name>width</name> &amp;&amp; <call><name>PyUnicode_CheckExact</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name>*) <name>self</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>marg</name> = <name>width</name> - <name><name>self</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>left</name> = <name>marg</name> / 2 + (<name>marg</name> &amp; <name>width</name> &amp; 1)</expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name>*) <call><name>pad</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>left</name></expr></argument>, <argument><expr><name>marg</name> - <name>left</name></expr></argument>, <argument><expr><name>fillchar</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
static short utf16Fixup[32] = {
0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0, 0, 0, 0, 0,
0, 0, 0, 0x2000, -0x800, -0x800, -0x800, -0x800
};
static int
unicode_compare(PyUnicodeObject *str1, PyUnicodeObject *str2) {
Py_ssize_t len1, len2;
Py_UNICODE *s1 = str1-&gt;str;
Py_UNICODE *s2 = str2-&gt;str;
len1 = str1-&gt;length;
len2 = str2-&gt;length;
while (len1 &gt; 0 &amp;&amp; len2 &gt; 0) {
Py_UNICODE c1, c2;
c1 = *s1++;
c2 = *s2++;
if (c1 &gt; (1&lt;&lt;11) * 26)
c1 += utf16Fixup[c1&gt;&gt;11];
if (c2 &gt; (1&lt;&lt;11) * 26)
c2 += utf16Fixup[c2&gt;&gt;11];
if (c1 != c2)
return (c1 &lt; c2) ? -1 : 1;
len1--;
len2--;
}
return (len1 &lt; len2) ? -1 : (len1 != len2);
}
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>unicode_compare</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>str1</name></decl></param>, <param><decl><type><name>PyUnicodeObject</name> *</type><name>str2</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>len1</name></decl>, <decl><type ref="prev"/><name>len2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>s1</name> <init>= <expr><name><name>str1</name>-&gt;<name>str</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>s2</name> <init>= <expr><name><name>str2</name>-&gt;<name>str</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>len1</name> = <name><name>str1</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>len2</name> = <name><name>str2</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>len1</name> &gt; 0 &amp;&amp; <name>len2</name> &gt; 0</expr>)</condition> <block>{
<decl_stmt><decl><type><name>Py_UNICODE</name></type> <name>c1</name></decl>, <decl><type ref="prev"/><name>c2</name></decl>;</decl_stmt>
<expr_stmt><expr><name>c1</name> = *<name>s1</name>++</expr>;</expr_stmt>
<expr_stmt><expr><name>c2</name> = *<name>s2</name>++</expr>;</expr_stmt>
<if>if <condition>(<expr><name>c1</name> != <name>c2</name></expr>)</condition><then>
<return>return <expr>(<name>c1</name> &lt; <name>c2</name>) ? -1 : 1</expr>;</return></then></if>
<expr_stmt><expr><name>len1</name>--</expr>;</expr_stmt>
<expr_stmt><expr><name>len2</name>--</expr>;</expr_stmt>
}</block></while>
<return>return <expr>(<name>len1</name> &lt; <name>len2</name>) ? -1 : (<name>len1</name> != <name>len2</name>)</expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>int</name></type> <name>PyUnicode_Compare</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>left</name></decl></param>,
<param><decl><type><name>PyObject</name> *</type><name>right</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>u</name> <init>= <expr><name>NULL</name></expr></init>, *<name>v</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>
<expr_stmt><expr><name>u</name> = (<name>PyUnicodeObject</name> *)<call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>u</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<expr_stmt><expr><name>v</name> = (<name>PyUnicodeObject</name> *)<call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<if>if <condition>(<expr><name>v</name> == <name>u</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>0</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>result</name> = <call><name>unicode_compare</name><argument_list>(<argument><expr><name>u</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
<label><name>onError</name>:</label>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type><name>PyUnicode_RichCompare</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>left</name></decl></param>,
<param><decl><type><name>PyObject</name> *</type><name>right</name></decl></param>,
<param><decl><type><name>int</name></type> <name>op</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>
<expr_stmt><expr><name>result</name> = <call><name>PyUnicode_Compare</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<switch>switch <condition>(<expr><name>op</name></expr>)</condition> <block>{
<case>case <expr><name>Py_EQ</name></expr>:
<expr_stmt><expr><name>result</name> = (<name>result</name> == 0)</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>Py_NE</name></expr>:
<expr_stmt><expr><name>result</name> = (<name>result</name> != 0)</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>Py_LE</name></expr>:
<expr_stmt><expr><name>result</name> = (<name>result</name> &lt;= 0)</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>Py_GE</name></expr>:
<expr_stmt><expr><name>result</name> = (<name>result</name> &gt;= 0)</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>Py_LT</name></expr>:
<expr_stmt><expr><name>result</name> = (<name>result</name> == -1)</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>Py_GT</name></expr>:
<expr_stmt><expr><name>result</name> = (<name>result</name> == 1)</expr>;</expr_stmt>
<break>break;</break>
</case>}</block></switch>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
<label><name>onError</name>:</label>
<if>if <condition>(<expr><call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_NotImplemented</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_NotImplemented</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>op</name> != <name>Py_EQ</name> &amp;&amp; <name>op</name> != <name>Py_NE</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>PyErr_ExceptionMatches</name><argument_list>(<argument><expr><name>PyExc_UnicodeDecodeError</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>PyErr_Clear</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyErr_Warn</name><argument_list>(<argument><expr><name>PyExc_UnicodeWarning</name></expr></argument>,
<argument><expr>(<name>op</name> == <name>Py_EQ</name>) ?
"Unicode equal comparison "
"failed to convert both arguments to Unicode - "
"interpreting them as being unequal" :
"Unicode unequal comparison "
"failed to convert both arguments to Unicode - "
"interpreting them as being unequal"</expr></argument>
)</argument_list></call> &lt; 0</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>result</name> = (<name>op</name> == <name>Py_NE</name>)</expr>;</expr_stmt>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>int</name></type> <name>PyUnicode_Contains</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>container</name></decl></param>,
<param><decl><type><name>PyObject</name> *</type><name>element</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>str</name></decl>, *<decl><type ref="prev"/><name>sub</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>
<expr_stmt><expr><name>sub</name> = <call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>element</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>sub</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"'in &lt;string&gt;' requires string as left operand"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>str</name> = <call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>container</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>str</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>sub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>result</name> = <call><name>stringlib_contains_obj</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>sub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>sub</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type><name>PyUnicode_Concat</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>left</name></decl></param>,
<param><decl><type><name>PyObject</name> *</type><name>right</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>u</name> <init>= <expr><name>NULL</name></expr></init>, *<name>v</name> <init>= <expr><name>NULL</name></expr></init>, *<name>w</name></decl>;</decl_stmt>
<expr_stmt><expr><name>u</name> = (<name>PyUnicodeObject</name> *)<call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>u</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<expr_stmt><expr><name>v</name> = (<name>PyUnicodeObject</name> *)<call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<if>if <condition>(<expr><name>v</name> == <name>unicode_empty</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *)<name>u</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>u</name> == <name>unicode_empty</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *)<name>v</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>w</name> = <call><name>_PyUnicode_New</name><argument_list>(<argument><expr><name><name>u</name>-&gt;<name>length</name></name> + <name><name>v</name>-&gt;<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>w</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<expr_stmt><expr><call><name>Py_UNICODE_COPY</name><argument_list>(<argument><expr><name><name>w</name>-&gt;<name>str</name></name></expr></argument>, <argument><expr><name><name>u</name>-&gt;<name>str</name></name></expr></argument>, <argument><expr><name><name>u</name>-&gt;<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_UNICODE_COPY</name><argument_list>(<argument><expr><name><name>w</name>-&gt;<name>str</name></name> + <name><name>u</name>-&gt;<name>length</name></name></expr></argument>, <argument><expr><name><name>v</name>-&gt;<name>str</name></name></expr></argument>, <argument><expr><name><name>v</name>-&gt;<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *)<name>w</name></expr>;</return>
<label><name>onError</name>:</label>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>count__doc__</name></expr></argument>,
<argument><expr>"S.count(sub[, start[, end]]) -&gt; int\n\
\n\
Return the number of non-overlapping occurrences of substring sub in\n\
Unicode string S[start:end]. Optional arguments start and end are\n\
interpreted as in slice notation."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>unicode_count</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>substring</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>start</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>end</name> <init>= <expr><name>PY_SSIZE_T_MAX</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O|O&amp;O&amp;:count"</expr></argument>, <argument><expr>&amp;<name>substring</name></expr></argument>,
<argument><expr><name>_PyEval_SliceIndex</name></expr></argument>, <argument><expr>&amp;<name>start</name></expr></argument>, <argument><expr><name>_PyEval_SliceIndex</name></expr></argument>, <argument><expr>&amp;<name>end</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>substring</name> = (<name>PyUnicodeObject</name> *)<call><name>PyUnicode_FromObject</name><argument_list>(
<argument><expr>(<name>PyObject</name> *)<name>substring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>substring</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>FIX_START_END</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> = <call><name>PyInt_FromSsize_t</name><argument_list>(
<argument><expr><call><name>stringlib_count</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>str</name></name> + <name>start</name></expr></argument>, <argument><expr><name>end</name> - <name>start</name></expr></argument>,
<argument><expr><name><name>substring</name>-&gt;<name>str</name></name></expr></argument>, <argument><expr><name><name>substring</name>-&gt;<name>length</name></name></expr></argument>)</argument_list></call></expr></argument>
)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>substring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>encode__doc__</name></expr></argument>,
<argument><expr>"S.encode([encoding[,errors]]) -&gt; string or unicode\n\
\n\
Encodes S using the codec registered for encoding. encoding defaults\n\
to the default encoding. errors may be given to set a different error\n\
handling scheme. Default is 'strict' meaning that encoding errors raise\n\
a UnicodeEncodeError. Other possible values are 'ignore', 'replace' and\n\
'xmlcharrefreplace' as well as any other name registered with\n\
codecs.register_error that can handle UnicodeEncodeErrors."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>unicode_encode</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>encoding</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>errors</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|ss:encode"</expr></argument>, <argument><expr>&amp;<name>encoding</name></expr></argument>, <argument><expr>&amp;<name>errors</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>v</name> = <call><name>PyUnicode_AsEncodedObject</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<if>if <condition>(<expr>!<call><name>PyString_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"encoder did not return a string/unicode object "
"(type=%.400s)"</expr></argument>,
<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><name>v</name></expr>;</return>
<label><name>onError</name>:</label>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>decode__doc__</name></expr></argument>,
<argument><expr>"S.decode([encoding[,errors]]) -&gt; string or unicode\n\
\n\
Decodes S using the codec registered for encoding. encoding defaults\n\
to the default encoding. errors may be given to set a different error\n\
handling scheme. Default is 'strict' meaning that encoding errors raise\n\
a UnicodeDecodeError. Other possible values are 'ignore' and 'replace'\n\
as well as any other name registerd with codecs.register_error that is\n\
able to handle UnicodeDecodeErrors."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>unicode_decode</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>encoding</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>errors</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|ss:decode"</expr></argument>, <argument><expr>&amp;<name>encoding</name></expr></argument>, <argument><expr>&amp;<name>errors</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>v</name> = <call><name>PyUnicode_AsDecodedObject</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<if>if <condition>(<expr>!<call><name>PyString_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> &amp;&amp; !<call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"decoder did not return a string/unicode object "
"(type=%.400s)"</expr></argument>,
<argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><name>v</name></expr>;</return>
<label><name>onError</name>:</label>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>expandtabs__doc__</name></expr></argument>,
<argument><expr>"S.expandtabs([tabsize]) -&gt; unicode\n\
\n\
Return a copy of S where all tab characters are expanded using spaces.\n\
If tabsize is not given, a tab size of 8 characters is assumed."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>unicode_expandtabs</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>e</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>q</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>qe</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>, <decl><type ref="prev"/><name>incr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>u</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tabsize</name> <init>= <expr>8</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|i:expandtabs"</expr></argument>, <argument><expr>&amp;<name>tabsize</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>i</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>j</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>e</name> = <name><name>self</name>-&gt;<name>str</name></name> + <name><name>self</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
<for>for (<init><expr><name>p</name> = <name><name>self</name>-&gt;<name>str</name></name></expr>;</init> <condition><expr><name>p</name> &lt; <name>e</name></expr>;</condition> <incr><expr><name>p</name>++</expr></incr>)
<if>if <condition>(<expr>*<name>p</name> == '\t'</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>tabsize</name> &gt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>incr</name> = <name>tabsize</name> - (<name>j</name> % <name>tabsize</name>)</expr>;</expr_stmt>
<if>if <condition>(<expr><name>j</name> &gt; <name>PY_SSIZE_T_MAX</name> - <name>incr</name></expr>)</condition><then>
<goto>goto <name>overflow1</name>;</goto></then></if>
<expr_stmt><expr><name>j</name> += <name>incr</name></expr>;</expr_stmt>
}</block></then></if>
}</block></then> <else>else <block>{
<if>if <condition>(<expr><name>j</name> &gt; <name>PY_SSIZE_T_MAX</name> - 1</expr>)</condition><then>
<goto>goto <name>overflow1</name>;</goto></then></if>
<expr_stmt><expr><name>j</name>++</expr>;</expr_stmt>
<if>if <condition>(<expr>*<name>p</name> == '\n' || *<name>p</name> == '\r'</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>i</name> &gt; <name>PY_SSIZE_T_MAX</name> - <name>j</name></expr>)</condition><then>
<goto>goto <name>overflow1</name>;</goto></then></if>
<expr_stmt><expr><name>i</name> += <name>j</name></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name> = 0</expr>;</expr_stmt>
}</block></then></if>
}</block></else></if></for>
<if>if <condition>(<expr><name>i</name> &gt; <name>PY_SSIZE_T_MAX</name> - <name>j</name></expr>)</condition><then>
<goto>goto <name>overflow1</name>;</goto></then></if>
<expr_stmt><expr><name>u</name> = <call><name>_PyUnicode_New</name><argument_list>(<argument><expr><name>i</name> + <name>j</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>u</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>j</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>q</name> = <name><name>u</name>-&gt;<name>str</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>qe</name> = <name><name>u</name>-&gt;<name>str</name></name> + <name><name>u</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
<for>for (<init><expr><name>p</name> = <name><name>self</name>-&gt;<name>str</name></name></expr>;</init> <condition><expr><name>p</name> &lt; <name>e</name></expr>;</condition> <incr><expr><name>p</name>++</expr></incr>)
<if>if <condition>(<expr>*<name>p</name> == '\t'</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>tabsize</name> &gt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>i</name> = <name>tabsize</name> - (<name>j</name> % <name>tabsize</name>)</expr>;</expr_stmt>
<expr_stmt><expr><name>j</name> += <name>i</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>i</name>--</expr>)</condition> <block>{
<if>if <condition>(<expr><name>q</name> &gt;= <name>qe</name></expr>)</condition><then>
<goto>goto <name>overflow2</name>;</goto></then></if>
<expr_stmt><expr>*<name>q</name>++ = ' '</expr>;</expr_stmt>
}</block></while>
}</block></then></if>
}</block></then> <else>else <block>{
<if>if <condition>(<expr><name>q</name> &gt;= <name>qe</name></expr>)</condition><then>
<goto>goto <name>overflow2</name>;</goto></then></if>
<expr_stmt><expr>*<name>q</name>++ = *<name>p</name></expr>;</expr_stmt>
<expr_stmt><expr><name>j</name>++</expr>;</expr_stmt>
<if>if <condition>(<expr>*<name>p</name> == '\n' || *<name>p</name> == '\r'</expr>)</condition><then>
<expr_stmt><expr><name>j</name> = 0</expr>;</expr_stmt></then></if>
}</block></else></if></for>
<return>return <expr>(<name>PyObject</name>*) <name>u</name></expr>;</return>
<label><name>overflow2</name>:</label>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>u</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>overflow1</name>:</label>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>, <argument><expr>"new string is too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>find__doc__</name></expr></argument>,
<argument><expr>"S.find(sub [,start [,end]]) -&gt; int\n\
\n\
Return the lowest index in S where substring sub is found,\n\
such that sub is contained within s[start:end]. Optional\n\
arguments start and end are interpreted as in slice notation.\n\
\n\
Return -1 on failure."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>unicode_find</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>substring</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>start</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>result</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>_ParseTupleFinds</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>&amp;<name>substring</name></expr></argument>, <argument><expr>&amp;<name>start</name></expr></argument>, <argument><expr>&amp;<name>end</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>result</name> = <call><name>stringlib_find_slice</name><argument_list>(
<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>substring</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>substring</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>
)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>substring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>unicode_getitem</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>index</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name>index</name> &lt; 0 || <name>index</name> &gt;= <name><name>self</name>-&gt;<name>length</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_IndexError</name></expr></argument>, <argument><expr>"string index out of range"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr>(<name>PyObject</name>*) <call><name>PyUnicode_FromUnicode</name><argument_list>(<argument><expr>&amp;<name><name>self</name>-&gt;<name>str</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>long</name></type>
<name>unicode_hash</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <name>Py_UNICODE</name> *</type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <name>long</name></type> <name>x</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>hash</name></name> != -1</expr>)</condition><then>
<return>return <expr><name><name>self</name>-&gt;<name>hash</name></name></expr>;</return></then></if>
<expr_stmt><expr><name>len</name> = <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>x</name> = *<name>p</name> &lt;&lt; 7</expr>;</expr_stmt>
<while>while <condition>(<expr>--<name>len</name> &gt;= 0</expr>)</condition>
<expr_stmt><expr><name>x</name> = (1000003*<name>x</name>) ^ *<name>p</name>++</expr>;</expr_stmt></while>
<expr_stmt><expr><name>x</name> ^= <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>x</name> == -1</expr>)</condition><then>
<expr_stmt><expr><name>x</name> = -2</expr>;</expr_stmt></then></if>
<expr_stmt><expr><name><name>self</name>-&gt;<name>hash</name></name> = <name>x</name></expr>;</expr_stmt>
<return>return <expr><name>x</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>index__doc__</name></expr></argument>,
<argument><expr>"S.index(sub [,start [,end]]) -&gt; int\n\
\n\
Like S.find() but raise ValueError when the substring is not found."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>unicode_index</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>substring</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>start</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>end</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>_ParseTupleFinds</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>&amp;<name>substring</name></expr></argument>, <argument><expr>&amp;<name>start</name></expr></argument>, <argument><expr>&amp;<name>end</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>result</name> = <call><name>stringlib_find_slice</name><argument_list>(
<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>substring</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>substring</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>
)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>substring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"substring not found"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>islower__doc__</name></expr></argument>,
<argument><expr>"S.islower() -&gt; bool\n\
\n\
Return True if all cased characters in S are lowercase and there is\n\
at least one cased character in S, False otherwise."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>unicode_islower</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>p</name> <init>= <expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>e</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>cased</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> == 1</expr>)</condition><then>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><call><name>Py_UNICODE_ISLOWER</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>e</name> = <name>p</name> + <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>cased</name> = 0</expr>;</expr_stmt>
<for>for (<init>;</init> <condition><expr><name>p</name> &lt; <name>e</name></expr>;</condition> <incr><expr><name>p</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>Py_UNICODE</name></type> <name>ch</name> <init>= <expr>*<name>p</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>Py_UNICODE_ISUPPER</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> || <call><name>Py_UNICODE_ISTITLE</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then>
<else>else <if>if <condition>(<expr>!<name>cased</name> &amp;&amp; <call><name>Py_UNICODE_ISLOWER</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>cased</name> = 1</expr>;</expr_stmt></then></if></else></if>
}</block></for>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><name>cased</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>isupper__doc__</name></expr></argument>,
<argument><expr>"S.isupper() -&gt; bool\n\
\n\
Return True if all cased characters in S are uppercase and there is\n\
at least one cased character in S, False otherwise."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>unicode_isupper</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>p</name> <init>= <expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>e</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>cased</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> == 1</expr>)</condition><then>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><call><name>Py_UNICODE_ISUPPER</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call> != 0</expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>e</name> = <name>p</name> + <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>cased</name> = 0</expr>;</expr_stmt>
<for>for (<init>;</init> <condition><expr><name>p</name> &lt; <name>e</name></expr>;</condition> <incr><expr><name>p</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>Py_UNICODE</name></type> <name>ch</name> <init>= <expr>*<name>p</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>Py_UNICODE_ISLOWER</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> || <call><name>Py_UNICODE_ISTITLE</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then>
<else>else <if>if <condition>(<expr>!<name>cased</name> &amp;&amp; <call><name>Py_UNICODE_ISUPPER</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>cased</name> = 1</expr>;</expr_stmt></then></if></else></if>
}</block></for>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><name>cased</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>istitle__doc__</name></expr></argument>,
<argument><expr>"S.istitle() -&gt; bool\n\
\n\
Return True if S is a titlecased string and there is at least one\n\
character in S, i.e. upper- and titlecase characters may only\n\
follow uncased characters and lowercase characters only cased ones.\n\
Return False otherwise."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>unicode_istitle</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>p</name> <init>= <expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>e</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>cased</name></decl>, <decl><type ref="prev"/><name>previous_is_cased</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> == 1</expr>)</condition><then>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>(<call><name>Py_UNICODE_ISTITLE</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call> != 0) ||
(<call><name>Py_UNICODE_ISUPPER</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call> != 0)</expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>e</name> = <name>p</name> + <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>cased</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>previous_is_cased</name> = 0</expr>;</expr_stmt>
<for>for (<init>;</init> <condition><expr><name>p</name> &lt; <name>e</name></expr>;</condition> <incr><expr><name>p</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>Py_UNICODE</name></type> <name>ch</name> <init>= <expr>*<name>p</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>Py_UNICODE_ISUPPER</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call> || <call><name>Py_UNICODE_ISTITLE</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>previous_is_cased</name></expr>)</condition><then>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>previous_is_cased</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name>cased</name> = 1</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><call><name>Py_UNICODE_ISLOWER</name><argument_list>(<argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr>!<name>previous_is_cased</name></expr>)</condition><then>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>previous_is_cased</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name>cased</name> = 1</expr>;</expr_stmt>
}</block></then> <else>else
<expr_stmt><expr><name>previous_is_cased</name> = 0</expr>;</expr_stmt></else></if></else></if>
}</block></for>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><name>cased</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>isspace__doc__</name></expr></argument>,
<argument><expr>"S.isspace() -&gt; bool\n\
\n\
Return True if all characters in S are whitespace\n\
and there is at least one character in S, False otherwise."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>unicode_isspace</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>p</name> <init>= <expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>e</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> == 1 &amp;&amp;
<call><name>Py_UNICODE_ISSPACE</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>e</name> = <name>p</name> + <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init>;</init> <condition><expr><name>p</name> &lt; <name>e</name></expr>;</condition> <incr><expr><name>p</name>++</expr></incr>) <block>{
<if>if <condition>(<expr>!<call><name>Py_UNICODE_ISSPACE</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>
}</block></for>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>isalpha__doc__</name></expr></argument>,
<argument><expr>"S.isalpha() -&gt; bool\n\
\n\
Return True if all characters in S are alphabetic\n\
and there is at least one character in S, False otherwise."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>unicode_isalpha</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>p</name> <init>= <expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>e</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> == 1 &amp;&amp;
<call><name>Py_UNICODE_ISALPHA</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>e</name> = <name>p</name> + <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init>;</init> <condition><expr><name>p</name> &lt; <name>e</name></expr>;</condition> <incr><expr><name>p</name>++</expr></incr>) <block>{
<if>if <condition>(<expr>!<call><name>Py_UNICODE_ISALPHA</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>
}</block></for>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>isalnum__doc__</name></expr></argument>,
<argument><expr>"S.isalnum() -&gt; bool\n\
\n\
Return True if all characters in S are alphanumeric\n\
and there is at least one character in S, False otherwise."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>unicode_isalnum</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>p</name> <init>= <expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>e</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> == 1 &amp;&amp;
<call><name>Py_UNICODE_ISALNUM</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>e</name> = <name>p</name> + <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init>;</init> <condition><expr><name>p</name> &lt; <name>e</name></expr>;</condition> <incr><expr><name>p</name>++</expr></incr>) <block>{
<if>if <condition>(<expr>!<call><name>Py_UNICODE_ISALNUM</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>
}</block></for>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>isdecimal__doc__</name></expr></argument>,
<argument><expr>"S.isdecimal() -&gt; bool\n\
\n\
Return True if there are only decimal characters in S,\n\
False otherwise."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>unicode_isdecimal</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>p</name> <init>= <expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>e</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> == 1 &amp;&amp;
<call><name>Py_UNICODE_ISDECIMAL</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>e</name> = <name>p</name> + <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init>;</init> <condition><expr><name>p</name> &lt; <name>e</name></expr>;</condition> <incr><expr><name>p</name>++</expr></incr>) <block>{
<if>if <condition>(<expr>!<call><name>Py_UNICODE_ISDECIMAL</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>
}</block></for>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>isdigit__doc__</name></expr></argument>,
<argument><expr>"S.isdigit() -&gt; bool\n\
\n\
Return True if all characters in S are digits\n\
and there is at least one character in S, False otherwise."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>unicode_isdigit</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>p</name> <init>= <expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>e</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> == 1 &amp;&amp;
<call><name>Py_UNICODE_ISDIGIT</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>e</name> = <name>p</name> + <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init>;</init> <condition><expr><name>p</name> &lt; <name>e</name></expr>;</condition> <incr><expr><name>p</name>++</expr></incr>) <block>{
<if>if <condition>(<expr>!<call><name>Py_UNICODE_ISDIGIT</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>
}</block></for>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>isnumeric__doc__</name></expr></argument>,
<argument><expr>"S.isnumeric() -&gt; bool\n\
\n\
Return True if there are only numeric characters in S,\n\
False otherwise."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>unicode_isnumeric</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>p</name> <init>= <expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>register</name> <specifier>const</specifier> <name>Py_UNICODE</name> *</type><name>e</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> == 1 &amp;&amp;
<call><name>Py_UNICODE_ISNUMERIC</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>e</name> = <name>p</name> + <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init>;</init> <condition><expr><name>p</name> &lt; <name>e</name></expr>;</condition> <incr><expr><name>p</name>++</expr></incr>) <block>{
<if>if <condition>(<expr>!<call><name>Py_UNICODE_ISNUMERIC</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>
}</block></for>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>join__doc__</name></expr></argument>,
<argument><expr>"S.join(sequence) -&gt; unicode\n\
\n\
Return a string which is the concatenation of the strings in the\n\
sequence. The separator between elements is S."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>unicode_join</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>data</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>PyUnicode_Join</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>Py_ssize_t</name></type>
<name>unicode_length</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<return>return <expr><name><name>self</name>-&gt;<name>length</name></name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>ljust__doc__</name></expr></argument>,
<argument><expr>"S.ljust(width[, fillchar]) -&gt; int\n\
\n\
Return S left-justified in a Unicode string of length width. Padding is\n\
done using the specified fill character (default is a space)."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>unicode_ljust</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>width</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UNICODE</name></type> <name>fillchar</name> <init>= <expr>' '</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"n|O&amp;:ljust"</expr></argument>, <argument><expr>&amp;<name>width</name></expr></argument>, <argument><expr><name>convert_uc</name></expr></argument>, <argument><expr>&amp;<name>fillchar</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>length</name></name> &gt;= <name>width</name> &amp;&amp; <call><name>PyUnicode_CheckExact</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name>*) <name>self</name></expr>;</return>
}</block></then></if>
<return>return <expr>(<name>PyObject</name>*) <call><name>pad</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>width</name> - <name><name>self</name>-&gt;<name>length</name></name></expr></argument>, <argument><expr><name>fillchar</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>lower__doc__</name></expr></argument>,
<argument><expr>"S.lower() -&gt; unicode\n\
\n\
Return a copy of the string S converted to lowercase."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>unicode_lower</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>fixup</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>fixlower</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LEFTSTRIP</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RIGHTSTRIP</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BOTHSTRIP</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name><name>stripformat</name><index>[]</index></name> <init>= <expr><block>{<expr>"|O:lstrip"</expr>, <expr>"|O:rstrip"</expr>, <expr>"|O:strip"</expr>}</block></expr></init></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STRIPNAME</name><parameter_list>(<param><type><name>i</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(stripformat[i]+3)</cpp:value></cpp:define>
<function><type><name>PyObject</name> *</type>
<name>_PyUnicode_XStrip</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>int</name></type> <name>striptype</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>sepobj</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>s</name> <init>= <expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name> <init>= <expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>sep</name> <init>= <expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>sepobj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>seplen</name> <init>= <expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>sepobj</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>BLOOM_MASK</name></type> <name>sepmask</name> <init>= <expr><call><name>make_bloom_mask</name><argument_list>(<argument><expr><name>sep</name></expr></argument>, <argument><expr><name>seplen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>i</name> = 0</expr>;</expr_stmt>
<if>if <condition>(<expr><name>striptype</name> != <name>RIGHTSTRIP</name></expr>)</condition><then> <block>{
<while>while <condition>(<expr><name>i</name> &lt; <name>len</name> &amp;&amp; <call><name>BLOOM_MEMBER</name><argument_list>(<argument><expr><name>sepmask</name></expr></argument>, <argument><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>sep</name></expr></argument>, <argument><expr><name>seplen</name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
}</block></while>
}</block></then></if>
<expr_stmt><expr><name>j</name> = <name>len</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>striptype</name> != <name>LEFTSTRIP</name></expr>)</condition><then> <block>{
<do>do <block>{
<expr_stmt><expr><name>j</name>--</expr>;</expr_stmt>
}</block> while <condition>(<expr><name>j</name> &gt;= <name>i</name> &amp;&amp; <call><name>BLOOM_MEMBER</name><argument_list>(<argument><expr><name>sepmask</name></expr></argument>, <argument><expr><name><name>s</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>sep</name></expr></argument>, <argument><expr><name>seplen</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>
<expr_stmt><expr><name>j</name>++</expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>i</name> == 0 &amp;&amp; <name>j</name> == <name>len</name> &amp;&amp; <call><name>PyUnicode_CheckExact</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name>*)<name>self</name></expr>;</return>
}</block></then> <else>else
<return>return <expr><call><name>PyUnicode_FromUnicode</name><argument_list>(<argument><expr><name>s</name>+<name>i</name></expr></argument>, <argument><expr><name>j</name>-<name>i</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>do_strip</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>int</name></type> <name>striptype</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>s</name> <init>= <expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name> <init>= <expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></init>, <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<expr_stmt><expr><name>i</name> = 0</expr>;</expr_stmt>
<if>if <condition>(<expr><name>striptype</name> != <name>RIGHTSTRIP</name></expr>)</condition><then> <block>{
<while>while <condition>(<expr><name>i</name> &lt; <name>len</name> &amp;&amp; <call><name>Py_UNICODE_ISSPACE</name><argument_list>(<argument><expr><name><name>s</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition> <block>{
<expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
}</block></while>
}</block></then></if>
<expr_stmt><expr><name>j</name> = <name>len</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>striptype</name> != <name>LEFTSTRIP</name></expr>)</condition><then> <block>{
<do>do <block>{
<expr_stmt><expr><name>j</name>--</expr>;</expr_stmt>
}</block> while <condition>(<expr><name>j</name> &gt;= <name>i</name> &amp;&amp; <call><name>Py_UNICODE_ISSPACE</name><argument_list>(<argument><expr><name><name>s</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>;</do>
<expr_stmt><expr><name>j</name>++</expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>i</name> == 0 &amp;&amp; <name>j</name> == <name>len</name> &amp;&amp; <call><name>PyUnicode_CheckExact</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name>*)<name>self</name></expr>;</return>
}</block></then> <else>else
<return>return <expr><call><name>PyUnicode_FromUnicode</name><argument_list>(<argument><expr><name>s</name>+<name>i</name></expr></argument>, <argument><expr><name>j</name>-<name>i</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>do_argstrip</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>int</name></type> <name>striptype</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>sep</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>(<name>char</name> *)<name><name>stripformat</name><index>[<expr><name>striptype</name></expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>sep</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>sep</name> != <name>NULL</name> &amp;&amp; <name>sep</name> != <name>Py_None</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>_PyUnicode_XStrip</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>striptype</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</return></then>
<else>else <if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>res</name></decl>;</decl_stmt>
<expr_stmt><expr><name>sep</name> = <call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>sep</name>==<name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>res</name> = <call><name>_PyUnicode_XStrip</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>striptype</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>res</name></expr>;</return>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"%s arg must be None, unicode or str"</expr></argument>,
<argument><expr><call><name>STRIPNAME</name><argument_list>(<argument><expr><name>striptype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></else></if></else></if>
}</block></then></if>
<return>return <expr><call><name>do_strip</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>striptype</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>strip__doc__</name></expr></argument>,
<argument><expr>"S.strip([chars]) -&gt; unicode\n\
\n\
Return a copy of the string S with leading and trailing\n\
whitespace removed.\n\
If chars is given and not None, remove characters in chars instead.\n\
If chars is a str, it will be converted to unicode before stripping"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>unicode_strip</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
<return>return <expr><call><name>do_strip</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>BOTHSTRIP</name></expr></argument>)</argument_list></call></expr>;</return></then>
<else>else
<return>return <expr><call><name>do_argstrip</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>BOTHSTRIP</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>lstrip__doc__</name></expr></argument>,
<argument><expr>"S.lstrip([chars]) -&gt; unicode\n\
\n\
Return a copy of the string S with leading whitespace removed.\n\
If chars is given and not None, remove characters in chars instead.\n\
If chars is a str, it will be converted to unicode before stripping"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>unicode_lstrip</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
<return>return <expr><call><name>do_strip</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>LEFTSTRIP</name></expr></argument>)</argument_list></call></expr>;</return></then>
<else>else
<return>return <expr><call><name>do_argstrip</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>LEFTSTRIP</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>rstrip__doc__</name></expr></argument>,
<argument><expr>"S.rstrip([chars]) -&gt; unicode\n\
\n\
Return a copy of the string S with trailing whitespace removed.\n\
If chars is given and not None, remove characters in chars instead.\n\
If chars is a str, it will be converted to unicode before stripping"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>unicode_rstrip</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
<return>return <expr><call><name>do_strip</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>RIGHTSTRIP</name></expr></argument>)</argument_list></call></expr>;</return></then>
<else>else
<return>return <expr><call><name>do_argstrip</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>RIGHTSTRIP</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>unicode_repeat</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>str</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>u</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>nchars</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>size_t</name></type> <name>nbytes</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>len</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>len</name> = 0</expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>len</name> == 1 &amp;&amp; <call><name>PyUnicode_CheckExact</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name>*) <name>str</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>nchars</name> = <name>len</name> * <name><name>str</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>len</name> &amp;&amp; <name>nchars</name> / <name>len</name> != <name><name>str</name>-&gt;<name>length</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
<argument><expr>"repeated string is too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>nbytes</name> = (<name>nchars</name> + 1) * <sizeof>sizeof<argument_list>(<argument><expr><name>Py_UNICODE</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
<if>if <condition>(<expr><name>nbytes</name> / <sizeof>sizeof<argument_list>(<argument><expr><name>Py_UNICODE</name></expr></argument>)</argument_list></sizeof> != <call>(<name>size_t</name>)<argument_list>(<argument><expr><name>nchars</name> + 1</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
<argument><expr>"repeated string is too long"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>u</name> = <call><name>_PyUnicode_New</name><argument_list>(<argument><expr><name>nchars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>u</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>p</name> = <name><name>u</name>-&gt;<name>str</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>str</name>-&gt;<name>length</name></name> == 1 &amp;&amp; <name>len</name> &gt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_UNICODE_FILL</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>str</name>-&gt;<name>str</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>done</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>done</name> &lt; <name>nchars</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_UNICODE_COPY</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>str</name>-&gt;<name>str</name></name></expr></argument>, <argument><expr><name><name>str</name>-&gt;<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>done</name> = <name><name>str</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
}</block></then></if>
<while>while <condition>(<expr><name>done</name> &lt; <name>nchars</name></expr>)</condition> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n</name> <init>= <expr>(<name>done</name> &lt;= <name>nchars</name>-<name>done</name>) ? <name>done</name> : <name>nchars</name>-<name>done</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>Py_UNICODE_COPY</name><argument_list>(<argument><expr><name>p</name>+<name>done</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>done</name> += <name>n</name></expr>;</expr_stmt>
}</block></while>
}</block></else></if>
<return>return <expr>(<name>PyObject</name>*) <name>u</name></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type><name>PyUnicode_Replace</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>obj</name></decl></param>,
<param><decl><type><name>PyObject</name> *</type><name>subobj</name></decl></param>,
<param><decl><type><name>PyObject</name> *</type><name>replobj</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>maxcount</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>self</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>str1</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>str2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
<expr_stmt><expr><name>self</name> = <call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>self</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>str1</name> = <call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>subobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>str1</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>str2</name> = <call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>replobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>str2</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>result</name> = <call><name>replace</name><argument_list>(<argument><expr>(<name>PyUnicodeObject</name> *)<name>self</name></expr></argument>,
<argument><expr>(<name>PyUnicodeObject</name> *)<name>str1</name></expr></argument>,
<argument><expr>(<name>PyUnicodeObject</name> *)<name>str2</name></expr></argument>,
<argument><expr><name>maxcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>replace__doc__</name></expr></argument>,
<argument><expr>"S.replace (old, new[, count]) -&gt; unicode\n\
\n\
Return a copy of S with all occurrences of substring\n\
old replaced by new. If the optional argument count is\n\
given, only the first count occurrences are replaced."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>unicode_replace</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>str1</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>str2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>maxcount</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"OO|n:replace"</expr></argument>, <argument><expr>&amp;<name>str1</name></expr></argument>, <argument><expr>&amp;<name>str2</name></expr></argument>, <argument><expr>&amp;<name>maxcount</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>str1</name> = (<name>PyUnicodeObject</name> *)<call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>str1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>str1</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>str2</name> = (<name>PyUnicodeObject</name> *)<call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>str2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>str2</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>result</name> = <call><name>replace</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>str1</name></expr></argument>, <argument><expr><name>str2</name></expr></argument>, <argument><expr><name>maxcount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier>
<name>PyObject</name> *</type><name>unicode_repr</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>unicode</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>unicodeescape_string</name><argument_list>(<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>unicode</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr>1</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>rfind__doc__</name></expr></argument>,
<argument><expr>"S.rfind(sub [,start [,end]]) -&gt; int\n\
\n\
Return the highest index in S where substring sub is found,\n\
such that sub is contained within s[start:end]. Optional\n\
arguments start and end are interpreted as in slice notation.\n\
\n\
Return -1 on failure."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>unicode_rfind</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>substring</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>start</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>result</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>_ParseTupleFinds</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>&amp;<name>substring</name></expr></argument>, <argument><expr>&amp;<name>start</name></expr></argument>, <argument><expr>&amp;<name>end</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>result</name> = <call><name>stringlib_rfind_slice</name><argument_list>(
<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>substring</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>substring</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>
)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>substring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>rindex__doc__</name></expr></argument>,
<argument><expr>"S.rindex(sub [,start [,end]]) -&gt; int\n\
\n\
Like S.rfind() but raise ValueError when the substring is not found."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>unicode_rindex</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>substring</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>start</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>result</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>_ParseTupleFinds</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>&amp;<name>substring</name></expr></argument>, <argument><expr>&amp;<name>start</name></expr></argument>, <argument><expr>&amp;<name>end</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>result</name> = <call><name>stringlib_rfind_slice</name><argument_list>(
<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>substring</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>substring</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>
)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>substring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>, <argument><expr>"substring not found"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>rjust__doc__</name></expr></argument>,
<argument><expr>"S.rjust(width[, fillchar]) -&gt; unicode\n\
\n\
Return S right-justified in a Unicode string of length width. Padding is\n\
done using the specified fill character (default is a space)."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>unicode_rjust</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>width</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UNICODE</name></type> <name>fillchar</name> <init>= <expr>' '</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"n|O&amp;:rjust"</expr></argument>, <argument><expr>&amp;<name>width</name></expr></argument>, <argument><expr><name>convert_uc</name></expr></argument>, <argument><expr>&amp;<name>fillchar</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>length</name></name> &gt;= <name>width</name> &amp;&amp; <call><name>PyUnicode_CheckExact</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name>*) <name>self</name></expr>;</return>
}</block></then></if>
<return>return <expr>(<name>PyObject</name>*) <call><name>pad</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>width</name> - <name><name>self</name>-&gt;<name>length</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>fillchar</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>unicode_slice</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>start</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>end</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name>start</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>start</name> = 0</expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>end</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>end</name> = 0</expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>end</name> &gt; <name><name>self</name>-&gt;<name>length</name></name></expr>)</condition><then>
<expr_stmt><expr><name>end</name> = <name><name>self</name>-&gt;<name>length</name></name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>start</name> == 0 &amp;&amp; <name>end</name> == <name><name>self</name>-&gt;<name>length</name></name> &amp;&amp; <call><name>PyUnicode_CheckExact</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name>*) <name>self</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>start</name> &gt; <name>end</name></expr>)</condition><then>
<expr_stmt><expr><name>start</name> = <name>end</name></expr>;</expr_stmt></then></if>
<return>return <expr>(<name>PyObject</name>*) <call><name>PyUnicode_FromUnicode</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>str</name></name> + <name>start</name></expr></argument>,
<argument><expr><name>end</name> - <name>start</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type><name>PyUnicode_Split</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>s</name></decl></param>,
<param><decl><type><name>PyObject</name> *</type><name>sep</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>maxsplit</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
<expr_stmt><expr><name>s</name> = <call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>s</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>sep</name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>sep</name> = <call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>sep</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
}</block></then></if>
<expr_stmt><expr><name>result</name> = <call><name>split</name><argument_list>(<argument><expr>(<name>PyUnicodeObject</name> *)<name>s</name></expr></argument>, <argument><expr>(<name>PyUnicodeObject</name> *)<name>sep</name></expr></argument>, <argument><expr><name>maxsplit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>split__doc__</name></expr></argument>,
<argument><expr>"S.split([sep [,maxsplit]]) -&gt; list of strings\n\
\n\
Return a list of the words in S, using sep as the\n\
delimiter string. If maxsplit is given, at most maxsplit\n\
splits are done. If sep is not specified or is None, any\n\
whitespace string is a separator and empty strings are\n\
removed from the result."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>unicode_split</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>substring</name> <init>= <expr><name>Py_None</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>maxcount</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|On:split"</expr></argument>, <argument><expr>&amp;<name>substring</name></expr></argument>, <argument><expr>&amp;<name>maxcount</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>substring</name> == <name>Py_None</name></expr>)</condition><then>
<return>return <expr><call><name>split</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>maxcount</name></expr></argument>)</argument_list></call></expr>;</return></then>
<else>else <if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>substring</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>split</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>(<name>PyUnicodeObject</name> *)<name>substring</name></expr></argument>, <argument><expr><name>maxcount</name></expr></argument>)</argument_list></call></expr>;</return></then>
<else>else
<return>return <expr><call><name>PyUnicode_Split</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>, <argument><expr><name>substring</name></expr></argument>, <argument><expr><name>maxcount</name></expr></argument>)</argument_list></call></expr>;</return></else></if></else></if>
}</block></function>
<function><type><name>PyObject</name> *</type>
<name>PyUnicode_Partition</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>str_in</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>sep_in</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name>*</type> <name>str_obj</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name>*</type> <name>sep_obj</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name>*</type> <name>out</name></decl>;</decl_stmt>
<expr_stmt><expr><name>str_obj</name> = <call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>str_in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>str_obj</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>sep_obj</name> = <call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>sep_in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>sep_obj</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>out</name> = <call><name>stringlib_partition</name><argument_list>(
<argument><expr><name>str_obj</name></expr></argument>, <argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>str_obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>str_obj</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>sep_obj</name></expr></argument>, <argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>sep_obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>sep_obj</name></expr></argument>)</argument_list></call></expr></argument>
)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>sep_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>out</name></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type>
<name>PyUnicode_RPartition</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>str_in</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>sep_in</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name>*</type> <name>str_obj</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name>*</type> <name>sep_obj</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name>*</type> <name>out</name></decl>;</decl_stmt>
<expr_stmt><expr><name>str_obj</name> = <call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>str_in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>str_obj</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>sep_obj</name> = <call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>sep_in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>sep_obj</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>out</name> = <call><name>stringlib_rpartition</name><argument_list>(
<argument><expr><name>str_obj</name></expr></argument>, <argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>str_obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>str_obj</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>sep_obj</name></expr></argument>, <argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>sep_obj</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>sep_obj</name></expr></argument>)</argument_list></call></expr></argument>
)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>sep_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str_obj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>out</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>partition__doc__</name></expr></argument>,
<argument><expr>"S.partition(sep) -&gt; (head, sep, tail)\n\
\n\
Search for the separator sep in S, and return the part before it,\n\
the separator itself, and the part after it. If the separator is not\n\
found, return S and two empty strings."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>unicode_partition</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>separator</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>PyUnicode_Partition</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>, <argument><expr><name>separator</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>rpartition__doc__</name></expr></argument>,
<argument><expr>"S.rpartition(sep) -&gt; (tail, sep, head)\n\
\n\
Search for the separator sep in S, starting at the end of S, and return\n\
the part before it, the separator itself, and the part after it. If the\n\
separator is not found, return two empty strings and S."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>unicode_rpartition</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>separator</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>PyUnicode_RPartition</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>, <argument><expr><name>separator</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>PyObject</name> *</type><name>PyUnicode_RSplit</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>s</name></decl></param>,
<param><decl><type><name>PyObject</name> *</type><name>sep</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>maxsplit</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name></decl>;</decl_stmt>
<expr_stmt><expr><name>s</name> = <call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>s</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>sep</name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>sep</name> = <call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>sep</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
}</block></then></if>
<expr_stmt><expr><name>result</name> = <call><name>rsplit</name><argument_list>(<argument><expr>(<name>PyUnicodeObject</name> *)<name>s</name></expr></argument>, <argument><expr>(<name>PyUnicodeObject</name> *)<name>sep</name></expr></argument>, <argument><expr><name>maxsplit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>rsplit__doc__</name></expr></argument>,
<argument><expr>"S.rsplit([sep [,maxsplit]]) -&gt; list of strings\n\
\n\
Return a list of the words in S, using sep as the\n\
delimiter string, starting at the end of the string and\n\
working to the front. If maxsplit is given, at most maxsplit\n\
splits are done. If sep is not specified, any whitespace string\n\
is a separator."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>unicode_rsplit</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>substring</name> <init>= <expr><name>Py_None</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>maxcount</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|On:rsplit"</expr></argument>, <argument><expr>&amp;<name>substring</name></expr></argument>, <argument><expr>&amp;<name>maxcount</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>substring</name> == <name>Py_None</name></expr>)</condition><then>
<return>return <expr><call><name>rsplit</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>maxcount</name></expr></argument>)</argument_list></call></expr>;</return></then>
<else>else <if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>substring</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>rsplit</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr>(<name>PyUnicodeObject</name> *)<name>substring</name></expr></argument>, <argument><expr><name>maxcount</name></expr></argument>)</argument_list></call></expr>;</return></then>
<else>else
<return>return <expr><call><name>PyUnicode_RSplit</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>, <argument><expr><name>substring</name></expr></argument>, <argument><expr><name>maxcount</name></expr></argument>)</argument_list></call></expr>;</return></else></if></else></if>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>splitlines__doc__</name></expr></argument>,
<argument><expr>"S.splitlines([keepends]]) -&gt; list of strings\n\
\n\
Return a list of the lines in S, breaking at line boundaries.\n\
Line breaks are not included in the resulting list unless keepends\n\
is given and true."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>unicode_splitlines</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>keepends</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"|i:splitlines"</expr></argument>, <argument><expr>&amp;<name>keepends</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<return>return <expr><call><name>PyUnicode_Splitlines</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>, <argument><expr><name>keepends</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier>
<name>PyObject</name> *</type><name>unicode_str</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>PyUnicode_AsEncodedString</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>swapcase__doc__</name></expr></argument>,
<argument><expr>"S.swapcase() -&gt; unicode\n\
\n\
Return a copy of S with uppercase characters converted to lowercase\n\
and vice versa."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>unicode_swapcase</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>fixup</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>fixswapcase</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>translate__doc__</name></expr></argument>,
<argument><expr>"S.translate(table) -&gt; unicode\n\
\n\
Return a copy of the string S, where all characters have been mapped\n\
through the given translation table, which must be a mapping of\n\
Unicode ordinals to Unicode ordinals, Unicode strings or None.\n\
Unmapped characters are left untouched. Characters mapped to None\n\
are deleted."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>unicode_translate</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>table</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>PyUnicode_TranslateCharmap</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>str</name></name></expr></argument>,
<argument><expr><name><name>self</name>-&gt;<name>length</name></name></expr></argument>,
<argument><expr><name>table</name></expr></argument>,
<argument><expr>"ignore"</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>upper__doc__</name></expr></argument>,
<argument><expr>"S.upper() -&gt; unicode\n\
\n\
Return a copy of S converted to uppercase."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>unicode_upper</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>fixup</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>fixupper</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>zfill__doc__</name></expr></argument>,
<argument><expr>"S.zfill(width) -&gt; unicode\n\
\n\
Pad a numeric string S with zeros on the left, to fill a field\n\
of the specified width. The string S is never truncated."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>unicode_zfill</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>fill</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>u</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>width</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"n:zfill"</expr></argument>, <argument><expr>&amp;<name>width</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name><name>self</name>-&gt;<name>length</name></name> &gt;= <name>width</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PyUnicode_CheckExact</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name>*) <name>self</name></expr>;</return>
}</block></then> <else>else
<return>return <expr><call><name>PyUnicode_FromUnicode</name><argument_list>(
<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>
)</argument_list></call></expr>;</return></else></if>
}</block></then></if>
<expr_stmt><expr><name>fill</name> = <name>width</name> - <name><name>self</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>u</name> = <call><name>pad</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>fill</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>'0'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>u</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name><name>u</name>-&gt;<name>str</name><index>[<expr><name>fill</name></expr>]</index></name> == '+' || <name><name>u</name>-&gt;<name>str</name><index>[<expr><name>fill</name></expr>]</index></name> == '-'</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>u</name>-&gt;<name>str</name><index>[<expr>0</expr>]</index></name> = <name><name>u</name>-&gt;<name>str</name><index>[<expr><name>fill</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>u</name>-&gt;<name>str</name><index>[<expr><name>fill</name></expr>]</index></name> = '0'</expr>;</expr_stmt>
}</block></then></if>
<return>return <expr>(<name>PyObject</name>*) <name>u</name></expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
static PyObject*
free_listsize(PyUnicodeObject *self) {
return PyInt_FromLong(numfree);
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>startswith__doc__</name></expr></argument>,
<argument><expr>"S.startswith(prefix[, start[, end]]) -&gt; bool\n\
\n\
Return True if S starts with the specified prefix, False otherwise.\n\
With optional start, test S beginning at that position.\n\
With optional end, stop comparing S at that position.\n\
prefix can also be a tuple of strings to try."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>unicode_startswith</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>,
<param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>subobj</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>substring</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>start</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>end</name> <init>= <expr><name>PY_SSIZE_T_MAX</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O|O&amp;O&amp;:startswith"</expr></argument>, <argument><expr>&amp;<name>subobj</name></expr></argument>,
<argument><expr><name>_PyEval_SliceIndex</name></expr></argument>, <argument><expr>&amp;<name>start</name></expr></argument>, <argument><expr><name>_PyEval_SliceIndex</name></expr></argument>, <argument><expr>&amp;<name>end</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>subobj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>subobj</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><name>substring</name> = (<name>PyUnicodeObject</name> *)<call><name>PyUnicode_FromObject</name><argument_list>(
<argument><expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>subobj</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>substring</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>result</name> = <call><name>tailmatch</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>substring</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>substring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>Py_RETURN_TRUE</name></expr>;</expr_stmt>
}</block></then></if>
}</block></for>
<expr_stmt><expr><name>Py_RETURN_FALSE</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>substring</name> = (<name>PyUnicodeObject</name> *)<call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>subobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>substring</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>result</name> = <call><name>tailmatch</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>substring</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr>-1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>substring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>endswith__doc__</name></expr></argument>,
<argument><expr>"S.endswith(suffix[, start[, end]]) -&gt; bool\n\
\n\
Return True if S ends with the specified suffix, False otherwise.\n\
With optional start, test S beginning at that position.\n\
With optional end, stop comparing S at that position.\n\
suffix can also be a tuple of strings to try."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>unicode_endswith</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>,
<param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>subobj</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>substring</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>start</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>end</name> <init>= <expr><name>PY_SSIZE_T_MAX</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O|O&amp;O&amp;:endswith"</expr></argument>, <argument><expr>&amp;<name>subobj</name></expr></argument>,
<argument><expr><name>_PyEval_SliceIndex</name></expr></argument>, <argument><expr>&amp;<name>start</name></expr></argument>, <argument><expr><name>_PyEval_SliceIndex</name></expr></argument>, <argument><expr>&amp;<name>end</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>subobj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <call><name>PyTuple_GET_SIZE</name><argument_list>(<argument><expr><name>subobj</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><name>substring</name> = (<name>PyUnicodeObject</name> *)<call><name>PyUnicode_FromObject</name><argument_list>(
<argument><expr><call><name>PyTuple_GET_ITEM</name><argument_list>(<argument><expr><name>subobj</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>substring</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>result</name> = <call><name>tailmatch</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>substring</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>substring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>Py_RETURN_TRUE</name></expr>;</expr_stmt>
}</block></then></if>
}</block></for>
<expr_stmt><expr><name>Py_RETURN_FALSE</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>substring</name> = (<name>PyUnicodeObject</name> *)<call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>subobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>substring</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>result</name> = <call><name>tailmatch</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>substring</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>substring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>PyBool_FromLong</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"stringlib/string_format.h"</cpp:file></cpp:include>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>format__doc__</name></expr></argument>,
<argument><expr>"S.format(*args, **kwargs) -&gt; unicode\n\
\n\
"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>unicode__format__</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>format_spec</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>tmp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTuple</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>"O:__format__"</expr></argument>, <argument><expr>&amp;<name>format_spec</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<goto>goto <name>done</name>;</goto></then></if>
<if>if <condition>(<expr>!(<call><name>PyBytes_Check</name><argument_list>(<argument><expr><name>format_spec</name></expr></argument>)</argument_list></call> || <call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>format_spec</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"__format__ arg must be str "
"or unicode, not %s"</expr></argument>, <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>format_spec</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>done</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>tmp</name> = <call><name>PyObject_Unicode</name><argument_list>(<argument><expr><name>format_spec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>tmp</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>done</name>;</goto></then></if>
<expr_stmt><expr><name>format_spec</name> = <name>tmp</name></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> = <call><name>_PyUnicode_FormatAdvanced</name><argument_list>(<argument><expr><name>self</name></expr></argument>,
<argument><expr><call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>format_spec</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>format_spec</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>done</name>:</label>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>p_format__doc__</name></expr></argument>,
<argument><expr>"S.__format__(format_spec) -&gt; unicode\n\
\n\
"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>unicode__sizeof__</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>v</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>PyInt_FromSsize_t</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PyUnicodeObject</name></expr></argument>)</argument_list></sizeof> +
<sizeof>sizeof<argument_list>(<argument><expr><name>Py_UNICODE</name></expr></argument>)</argument_list></sizeof> * (<name><name>v</name>-&gt;<name>length</name></name> + 1)</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>sizeof__doc__</name></expr></argument>,
<argument><expr>"S.__sizeof__() -&gt; size of S in memory, in bytes\n\
\n\
"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>unicode_getnewargs</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>v</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>Py_BuildValue</name><argument_list>(<argument><expr>"(u#)"</expr></argument>, <argument><expr><name><name>v</name>-&gt;<name>str</name></name></expr></argument>, <argument><expr><name><name>v</name>-&gt;<name>length</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyMethodDef</name></type> <name><name>unicode_methods</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{<expr>"encode"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_encode</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>encode__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"replace"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_replace</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>replace__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"split"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_split</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>split__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"rsplit"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_rsplit</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>rsplit__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"join"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_join</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>join__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"capitalize"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_capitalize</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>capitalize__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"title"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_title</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>title__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"center"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_center</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>center__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"count"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_count</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>count__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"expandtabs"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_expandtabs</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>expandtabs__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"find"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_find</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>find__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"partition"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_partition</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>partition__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"index"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_index</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>index__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"ljust"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_ljust</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>ljust__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"lower"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_lower</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>lower__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"lstrip"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_lstrip</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>lstrip__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"decode"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_decode</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>decode__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"rfind"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_rfind</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>rfind__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"rindex"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_rindex</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>rindex__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"rjust"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_rjust</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>rjust__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"rstrip"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_rstrip</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>rstrip__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"rpartition"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_rpartition</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>rpartition__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"splitlines"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_splitlines</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>splitlines__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"strip"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_strip</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>strip__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"swapcase"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_swapcase</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>swapcase__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"translate"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_translate</name></expr>, <expr><name>METH_O</name></expr>, <expr><name>translate__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"upper"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_upper</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>upper__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"startswith"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_startswith</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>startswith__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"endswith"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_endswith</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>endswith__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"islower"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_islower</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>islower__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"isupper"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_isupper</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>isupper__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"istitle"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_istitle</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>istitle__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"isspace"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_isspace</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>isspace__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"isdecimal"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_isdecimal</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>isdecimal__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"isdigit"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_isdigit</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>isdigit__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"isnumeric"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_isnumeric</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>isnumeric__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"isalpha"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_isalpha</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>isalpha__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"isalnum"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_isalnum</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>isalnum__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"zfill"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode_zfill</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>zfill__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"format"</expr>, <expr>(<name>PyCFunction</name>) <name>do_string_format</name></expr>, <expr><name>METH_VARARGS</name> | <name>METH_KEYWORDS</name></expr>, <expr><name>format__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"__format__"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode__format__</name></expr>, <expr><name>METH_VARARGS</name></expr>, <expr><name>p_format__doc__</name></expr>}</block></expr>,
<expr><block>{<expr>"_formatter_field_name_split"</expr>, <expr>(<name>PyCFunction</name>) <name>formatter_field_name_split</name></expr>, <expr><name>METH_NOARGS</name></expr>}</block></expr>,
<expr><block>{<expr>"_formatter_parser"</expr>, <expr>(<name>PyCFunction</name>) <name>formatter_parser</name></expr>, <expr><name>METH_NOARGS</name></expr>}</block></expr>,
<expr><block>{<expr>"__sizeof__"</expr>, <expr>(<name>PyCFunction</name>) <name>unicode__sizeof__</name></expr>, <expr><name>METH_NOARGS</name></expr>, <expr><name>sizeof__doc__</name></expr>}</block></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
{"capwords", (PyCFunction) unicode_capwords, METH_NOARGS, capwords__doc__},
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
{"freelistsize", (PyCFunction) free_listsize, METH_NOARGS},
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr><block>{<expr>"__getnewargs__"</expr>, <expr>(<name>PyCFunction</name>)<name>unicode_getnewargs</name></expr>, <expr><name>METH_NOARGS</name></expr>}</block></expr>,
<expr><block>{<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>unicode_mod</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>w</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr>!<call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>Py_NotImplemented</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>Py_NotImplemented</name></expr>;</return>
}</block></then></if>
<return>return <expr><call><name>PyUnicode_Format</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>w</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyNumberMethods</name></type> <name>unicode_as_number</name> <init>= <expr><block>{
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>unicode_mod</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PySequenceMethods</name></type> <name>unicode_as_sequence</name> <init>= <expr><block>{
<expr>(<name>lenfunc</name>) <name>unicode_length</name></expr>,
<expr><name>PyUnicode_Concat</name></expr>,
<expr>(<name>ssizeargfunc</name>) <name>unicode_repeat</name></expr>,
<expr>(<name>ssizeargfunc</name>) <name>unicode_getitem</name></expr>,
<expr>(<name>ssizessizeargfunc</name>) <name>unicode_slice</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>PyUnicode_Contains</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>unicode_subscript</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name>*</type> <name>self</name></decl></param>, <param><decl><type><name>PyObject</name>*</type> <name>item</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><call><name>PyIndex_Check</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>i</name> <init>= <expr><call><name>PyNumber_AsSsize_t</name><argument_list>(<argument><expr><name>item</name></expr></argument>, <argument><expr><name>PyExc_IndexError</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>i</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>i</name> += <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><call><name>unicode_getitem</name><argument_list>(<argument><expr><name>self</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><call><name>PySlice_Check</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>start</name></decl>, <decl><type ref="prev"/><name>stop</name></decl>, <decl><type ref="prev"/><name>step</name></decl>, <decl><type ref="prev"/><name>slicelength</name></decl>, <decl><type ref="prev"/><name>cur</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UNICODE</name>*</type> <name>source_buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UNICODE</name>*</type> <name>result_buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name>*</type> <name>result</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PySlice_GetIndicesEx</name><argument_list>(<argument><expr>(<name>PySliceObject</name>*)<name>item</name></expr></argument>, <argument><expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr>&amp;<name>start</name></expr></argument>, <argument><expr>&amp;<name>stop</name></expr></argument>, <argument><expr>&amp;<name>step</name></expr></argument>, <argument><expr>&amp;<name>slicelength</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>slicelength</name> &lt;= 0</expr>)</condition><then> <block>{
<return>return <expr><call><name>PyUnicode_FromUnicode</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><name>start</name> == 0 &amp;&amp; <name>step</name> == 1 &amp;&amp; <name>slicelength</name> == <name><name>self</name>-&gt;<name>length</name></name> &amp;&amp;
<call><name>PyUnicode_CheckExact</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *)<name>self</name></expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr><name>step</name> == 1</expr>)</condition><then> <block>{
<return>return <expr><call><name>PyUnicode_FromUnicode</name><argument_list>(<argument><expr><name><name>self</name>-&gt;<name>str</name></name> + <name>start</name></expr></argument>, <argument><expr><name>slicelength</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>source_buf</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr>(<name>PyObject</name>*)<name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result_buf</name> = (<name>Py_UNICODE</name> *)<call><name>PyObject_MALLOC</name><argument_list>(<argument><expr><name>slicelength</name>*
<sizeof>sizeof<argument_list>(<argument><expr><name>Py_UNICODE</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result_buf</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<for>for (<init><expr><name>cur</name> = <name>start</name></expr>, <expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>slicelength</name></expr>;</condition> <incr><expr><name>cur</name> += <name>step</name></expr>, <expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><name><name>result_buf</name><index>[<expr><name>i</name></expr>]</index></name> = <name><name>source_buf</name><index>[<expr><name>cur</name></expr>]</index></name></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><name>result</name> = <call><name>PyUnicode_FromUnicode</name><argument_list>(<argument><expr><name>result_buf</name></expr></argument>, <argument><expr><name>slicelength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyObject_FREE</name><argument_list>(<argument><expr><name>result_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>result</name></expr>;</return>
}</block></else></if></else></if></else></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>, <argument><expr>"string indices must be integers"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></else></if></else></if>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyMappingMethods</name></type> <name>unicode_as_mapping</name> <init>= <expr><block>{
<expr>(<name>lenfunc</name>)<name>unicode_length</name></expr>,
<expr>(<name>binaryfunc</name>)<name>unicode_subscript</name></expr>,
<expr>(<name>objobjargproc</name>)0</expr>,
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>Py_ssize_t</name></type>
<name>unicode_buffer_getreadbuf</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>index</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>void</name> **</type><name>ptr</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name>index</name> != 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
<argument><expr>"accessing non-existent unicode segment"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr>*<name>ptr</name> = (<name>void</name> *) <name><name>self</name>-&gt;<name>str</name></name></expr>;</expr_stmt>
<return>return <expr><call><name>PyUnicode_GET_DATA_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>Py_ssize_t</name></type>
<name>unicode_buffer_getwritebuf</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>index</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>void</name> **</type><name>ptr</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"cannot use unicode as modifiable buffer"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>unicode_buffer_getsegcount</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name> *</type><name>lenp</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name>lenp</name></expr>)</condition><then>
<expr_stmt><expr>*<name>lenp</name> = <call><name>PyUnicode_GET_DATA_SIZE</name><argument_list>(<argument><expr><name>self</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr>1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>Py_ssize_t</name></type>
<name>unicode_buffer_getcharbuf</name><parameter_list>(<param><decl><type><name>PyUnicodeObject</name> *</type><name>self</name></decl></param>,
<param><decl><type><name>Py_ssize_t</name></type> <name>index</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>void</name> **</type><name>ptr</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>str</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>index</name> != 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_SystemError</name></expr></argument>,
<argument><expr>"accessing non-existent unicode segment"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>str</name> = <call><name>_PyUnicode_AsDefaultEncodedString</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>self</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>str</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<expr_stmt><expr>*<name>ptr</name> = (<name>void</name> *) <call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>getnextarg</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>Py_ssize_t</name></type> <name>arglen</name></decl></param>, <param><decl><type><name>Py_ssize_t</name> *</type><name>p_argidx</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>argidx</name> <init>= <expr>*<name>p_argidx</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>argidx</name> &lt; <name>arglen</name></expr>)</condition><then> <block>{
<expr_stmt><expr>(*<name>p_argidx</name>)++</expr>;</expr_stmt>
<if>if <condition>(<expr><name>arglen</name> &lt; 0</expr>)</condition><then>
<return>return <expr><name>args</name></expr>;</return></then>
<else>else
<return>return <expr><call><name>PyTuple_GetItem</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>argidx</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></then></if>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"not enough arguments for format string"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>F_LJUST</name></cpp:macro> <cpp:value>(1&lt;&lt;0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>F_SIGN</name></cpp:macro> <cpp:value>(1&lt;&lt;1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>F_BLANK</name></cpp:macro> <cpp:value>(1&lt;&lt;2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>F_ALT</name></cpp:macro> <cpp:value>(1&lt;&lt;3)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>F_ZERO</name></cpp:macro> <cpp:value>(1&lt;&lt;4)</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>Py_ssize_t</name></type>
<name>strtounicode</name><parameter_list>(<param><decl><type><name>Py_UNICODE</name> *</type><name>buffer</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>charbuffer</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>register</name> <name>Py_ssize_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>charbuffer</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = <name>len</name> - 1</expr>;</init> <condition><expr><name>i</name> &gt;= 0</expr>;</condition> <incr><expr><name>i</name>--</expr></incr>)
<expr_stmt><expr><name><name>buffer</name><index>[<expr><name>i</name></expr>]</index></name> = (<name>Py_UNICODE</name>) <name><name>charbuffer</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></for>
<return>return <expr><name>len</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>doubletounicode</name><parameter_list>(<param><decl><type><name>Py_UNICODE</name> *</type><name>buffer</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>len</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>format</name></decl></param>, <param><decl><type><name>double</name></type> <name>x</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>result</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PyOS_ascii_formatd</name><argument_list>(<argument><expr>(<name>char</name> *)<name>buffer</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> = <call><name>strtounicode</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr>(<name>char</name> *)<name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>Py_SAFE_DOWNCAST</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>Py_ssize_t</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>longtounicode</name><parameter_list>(<param><decl><type><name>Py_UNICODE</name> *</type><name>buffer</name></decl></param>, <param><decl><type><name>size_t</name></type> <name>len</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>format</name></decl></param>, <param><decl><type><name>long</name></type> <name>x</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>result</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr>(<name>char</name> *)<name>buffer</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>format</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> = <call><name>strtounicode</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr>(<name>char</name> *)<name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>Py_SAFE_DOWNCAST</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>Py_ssize_t</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>formatfloat</name><parameter_list>(<param><decl><type><name>Py_UNICODE</name> *</type><name>buf</name></decl></param>,
<param><decl><type><name>size_t</name></type> <name>buflen</name></decl></param>,
<param><decl><type><name>int</name></type> <name>flags</name></decl></param>,
<param><decl><type><name>int</name></type> <name>prec</name></decl></param>,
<param><decl><type><name>int</name></type> <name>type</name></decl></param>,
<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name></type> <name><name>fmt</name><index>[<expr>20</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type> <name>x</name></decl>;</decl_stmt>
<expr_stmt><expr><name>x</name> = <call><name>PyFloat_AsDouble</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>x</name> == -1.0 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr><name>prec</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>prec</name> = 6</expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>type</name> == 'f' &amp;&amp; (<call><name>fabs</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> / 1e25) &gt;= 1e25</expr>)</condition><then>
<expr_stmt><expr><name>type</name> = 'g'</expr>;</expr_stmt></then></if>
<if>if <condition>(<expr>((<name>type</name> == 'g' || <name>type</name> == 'G') &amp;&amp;
<name>buflen</name> &lt;= (<name>size_t</name>)10 + (<name>size_t</name>)<name>prec</name>) ||
(<name>type</name> == 'f' &amp;&amp; <name>buflen</name> &lt;= (<name>size_t</name>)53 + (<name>size_t</name>)<name>prec</name>)</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
<argument><expr>"formatted float is too long (precision too large?)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fmt</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>"%%%s.%d%c"</expr></argument>,
<argument><expr>(<name>flags</name>&amp;<name>F_ALT</name>) ? "#" : ""</expr></argument>,
<argument><expr><name>prec</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>doubletounicode</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name>*</type>
<name>formatlong</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>val</name></decl></param>, <param><decl><type><name>int</name></type> <name>flags</name></decl></param>, <param><decl><type><name>int</name></type> <name>prec</name></decl></param>, <param><decl><type><name>int</name></type> <name>type</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>result</name></decl>;</decl_stmt>
<expr_stmt><expr><name>str</name> = <call><name>_PyString_FormatLong</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>prec</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr>&amp;<name>buf</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>str</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>result</name> = <call><name>_PyUnicode_New</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>result</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
<expr_stmt><expr><name><name>result</name>-&gt;<name>str</name><index>[<expr><name>i</name></expr>]</index></name> = <name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></for>
<expr_stmt><expr><name><name>result</name>-&gt;<name>str</name><index>[<expr><name>len</name></expr>]</index></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name>*)<name>result</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>formatint</name><parameter_list>(<param><decl><type><name>Py_UNICODE</name> *</type><name>buf</name></decl></param>,
<param><decl><type><name>size_t</name></type> <name>buflen</name></decl></param>,
<param><decl><type><name>int</name></type> <name>flags</name></decl></param>,
<param><decl><type><name>int</name></type> <name>prec</name></decl></param>,
<param><decl><type><name>int</name></type> <name>type</name></decl></param>,
<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name></type> <name><name>fmt</name><index>[<expr>64</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>sign</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>long</name></type> <name>x</name></decl>;</decl_stmt>
<expr_stmt><expr><name>x</name> = <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>x</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr><name>x</name> &lt; 0 &amp;&amp; <name>type</name> == 'u'</expr>)</condition><then> <block>{
<expr_stmt><expr><name>type</name> = 'd'</expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>x</name> &lt; 0 &amp;&amp; (<name>type</name> == 'x' || <name>type</name> == 'X' || <name>type</name> == 'o')</expr>)</condition><then>
<expr_stmt><expr><name>sign</name> = "-"</expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>sign</name> = ""</expr>;</expr_stmt></else></if>
<if>if <condition>(<expr><name>prec</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>prec</name> = 1</expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>buflen</name> &lt;= 14 || <name>buflen</name> &lt;= (<name>size_t</name>)3 + (<name>size_t</name>)<name>prec</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
<argument><expr>"formatted integer is too long (precision too large?)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>(<name>flags</name> &amp; <name>F_ALT</name>) &amp;&amp;
(<name>type</name> == 'x' || <name>type</name> == 'X')</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fmt</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>"%s0%c%%.%dl%c"</expr></argument>,
<argument><expr><name>sign</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>prec</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>PyOS_snprintf</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>fmt</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr>"%s%%%s.%dl%c"</expr></argument>,
<argument><expr><name>sign</name></expr></argument>, <argument><expr>(<name>flags</name>&amp;<name>F_ALT</name>) ? "#" : ""</expr></argument>,
<argument><expr><name>prec</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<if>if <condition>(<expr><name><name>sign</name><index>[<expr>0</expr>]</index></name></expr>)</condition><then>
<return>return <expr><call><name>longtounicode</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr>-<name>x</name></expr></argument>)</argument_list></call></expr>;</return></then>
<else>else
<return>return <expr><call><name>longtounicode</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>formatchar</name><parameter_list>(<param><decl><type><name>Py_UNICODE</name> *</type><name>buf</name></decl></param>,
<param><decl><type><name>size_t</name></type> <name>buflen</name></decl></param>,
<param><decl><type><name>PyObject</name> *</type><name>v</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> != 1</expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<expr_stmt><expr><name><name>buf</name><index>[<expr>0</expr>]</index></name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call><index>[<expr>0</expr>]</index></expr>;</expr_stmt>
}</block></then>
<else>else <if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> != 1</expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<expr_stmt><expr><name><name>buf</name><index>[<expr>0</expr>]</index></name> = (<name>Py_UNICODE</name>)<call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call><index>[<expr>0</expr>]</index></expr>;</expr_stmt>
}</block></then>
<else>else <block>{
<decl_stmt><decl><type><name>long</name></type> <name>x</name></decl>;</decl_stmt>
<expr_stmt><expr><name>x</name> = <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>x</name> == -1 &amp;&amp; <call><name>PyErr_Occurred</name><argument_list>()</argument_list></call></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>Py_UNICODE_WIDE</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>x</name> &lt; 0 || <name>x</name> &gt; 0x10ffff</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
<argument><expr>"%c arg not in range(0x110000) "
"(wide Python build)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<if>if <condition>(<expr><name>x</name> &lt; 0 || <name>x</name> &gt; 0xffff</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_OverflowError</name></expr></argument>,
<argument><expr>"%c arg not in range(0x10000) "
"(narrow Python build)"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<expr_stmt><expr><name><name>buf</name><index>[<expr>0</expr>]</index></name> = (<name>Py_UNICODE</name>) <name>x</name></expr>;</expr_stmt>
}</block></else></if></else></if>
<expr_stmt><expr><name><name>buf</name><index>[<expr>1</expr>]</index></name> = '\0'</expr>;</expr_stmt>
<return>return <expr>1</expr>;</return>
<label><name>onError</name>:</label>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"%c requires int or char"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>-1</expr>;</return>
}</block></function>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FORMATBUFLEN</name></cpp:macro> <cpp:value>(size_t)120</cpp:value></cpp:define>
<function><type><name>PyObject</name> *</type><name>PyUnicode_Format</name><parameter_list>(<param><decl><type><name>PyObject</name> *</type><name>format</name></decl></param>,
<param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>fmt</name></decl>, *<decl><type ref="prev"/><name>res</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>fmtcnt</name></decl>, <decl><type ref="prev"/><name>rescnt</name></decl>, <decl><type ref="prev"/><name>reslen</name></decl>, <decl><type ref="prev"/><name>arglen</name></decl>, <decl><type ref="prev"/><name>argidx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>args_owned</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>dict</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>uformat</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>format</name> == <name>NULL</name> || <name>args</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_BadInternalCall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>uformat</name> = <call><name>PyUnicode_FromObject</name><argument_list>(<argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>uformat</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>fmt</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>uformat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>fmtcnt</name> = <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>uformat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>reslen</name> = <name>rescnt</name> = <name>fmtcnt</name> + 100</expr>;</expr_stmt>
<expr_stmt><expr><name>result</name> = <call><name>_PyUnicode_New</name><argument_list>(<argument><expr><name>reslen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<expr_stmt><expr><name>res</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>arglen</name> = <call><name>PyTuple_Size</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>argidx</name> = 0</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>arglen</name> = -1</expr>;</expr_stmt>
<expr_stmt><expr><name>argidx</name> = -2</expr>;</expr_stmt>
}</block></else></if>
<if>if <condition>(<expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call>-&gt;<name>tp_as_mapping</name> &amp;&amp; !<call><name>PyTuple_Check</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> &amp;&amp;
!<call><name>PyObject_TypeCheck</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr>&amp;<name>PyBaseString_Type</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>dict</name> = <name>args</name></expr>;</expr_stmt></then></if>
<while>while <condition>(<expr>--<name>fmtcnt</name> &gt;= 0</expr>)</condition> <block>{
<if>if <condition>(<expr>*<name>fmt</name> != '%'</expr>)</condition><then> <block>{
<if>if <condition>(<expr>--<name>rescnt</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>rescnt</name> = <name>fmtcnt</name> + 100</expr>;</expr_stmt>
<expr_stmt><expr><name>reslen</name> += <name>rescnt</name></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>_PyUnicode_Resize</name><argument_list>(<argument><expr>&amp;<name>result</name></expr></argument>, <argument><expr><name>reslen</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<expr_stmt><expr><name>res</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> + <name>reslen</name> - <name>rescnt</name></expr>;</expr_stmt>
<expr_stmt><expr>--<name>rescnt</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr>*<name>res</name>++ = *<name>fmt</name>++</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>width</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>prec</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UNICODE</name></type> <name>c</name> <init>= <expr>'\0'</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UNICODE</name></type> <name>fill</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>isnumok</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>v</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>temp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>pbuf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UNICODE</name></type> <name>sign</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UNICODE</name></type> <name><name>formatbuf</name><index>[<expr><name>FORMATBUFLEN</name></expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><name>fmt</name>++</expr>;</expr_stmt>
<if>if <condition>(<expr>*<name>fmt</name> == '('</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>Py_UNICODE</name> *</type><name>keystart</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>keylen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyObject</name> *</type><name>key</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>pcount</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>dict</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"format requires a mapping"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>onError</name>;</goto>
}</block></then></if>
<expr_stmt><expr>++<name>fmt</name></expr>;</expr_stmt>
<expr_stmt><expr>--<name>fmtcnt</name></expr>;</expr_stmt>
<expr_stmt><expr><name>keystart</name> = <name>fmt</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>pcount</name> &gt; 0 &amp;&amp; --<name>fmtcnt</name> &gt;= 0</expr>)</condition> <block>{
<if>if <condition>(<expr>*<name>fmt</name> == ')'</expr>)</condition><then>
<expr_stmt><expr>--<name>pcount</name></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr>*<name>fmt</name> == '('</expr>)</condition><then>
<expr_stmt><expr>++<name>pcount</name></expr>;</expr_stmt></then></if></else></if>
<expr_stmt><expr><name>fmt</name>++</expr>;</expr_stmt>
}</block></while>
<expr_stmt><expr><name>keylen</name> = <name>fmt</name> - <name>keystart</name> - 1</expr>;</expr_stmt>
<if>if <condition>(<expr><name>fmtcnt</name> &lt; 0 || <name>pcount</name> &gt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"incomplete format key"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>onError</name>;</goto>
}</block></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
key = PyUnicode_EncodeUTF8(keystart,
keylen,
NULL);
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr_stmt><expr><name>key</name> = <call><name>PyUnicode_FromUnicode</name><argument_list>(<argument><expr><name>keystart</name></expr></argument>, <argument><expr><name>keylen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<if>if <condition>(<expr><name>key</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<if>if <condition>(<expr><name>args_owned</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>args_owned</name> = 0</expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>args</name> = <call><name>PyObject_GetItem</name><argument_list>(<argument><expr><name>dict</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>args</name> == <name>NULL</name></expr>)</condition><then> <block>{
<goto>goto <name>onError</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>args_owned</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name>arglen</name> = -1</expr>;</expr_stmt>
<expr_stmt><expr><name>argidx</name> = -2</expr>;</expr_stmt>
}</block></then></if>
<while>while <condition>(<expr>--<name>fmtcnt</name> &gt;= 0</expr>)</condition> <block>{
<switch>switch <condition>(<expr><name>c</name> = *<name>fmt</name>++</expr>)</condition> <block>{
<case>case <expr>'-'</expr>:
<expr_stmt><expr><name>flags</name> |= <name>F_LJUST</name></expr>;</expr_stmt>
<continue>continue;</continue>
</case><case>case <expr>'+'</expr>:
<expr_stmt><expr><name>flags</name> |= <name>F_SIGN</name></expr>;</expr_stmt>
<continue>continue;</continue>
</case><case>case <expr>' '</expr>:
<expr_stmt><expr><name>flags</name> |= <name>F_BLANK</name></expr>;</expr_stmt>
<continue>continue;</continue>
</case><case>case <expr>'#'</expr>:
<expr_stmt><expr><name>flags</name> |= <name>F_ALT</name></expr>;</expr_stmt>
<continue>continue;</continue>
</case><case>case <expr>'0'</expr>:
<expr_stmt><expr><name>flags</name> |= <name>F_ZERO</name></expr>;</expr_stmt>
<continue>continue;</continue>
</case>}</block></switch>
<break>break;</break>
}</block></while>
<if>if <condition>(<expr><name>c</name> == '*'</expr>)</condition><then> <block>{
<expr_stmt><expr><name>v</name> = <call><name>getnextarg</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>arglen</name></expr></argument>, <argument><expr>&amp;<name>argidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<if>if <condition>(<expr>!<call><name>PyInt_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"* wants int"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>onError</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>width</name> = <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>width</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>flags</name> |= <name>F_LJUST</name></expr>;</expr_stmt>
<expr_stmt><expr><name>width</name> = -<name>width</name></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr>--<name>fmtcnt</name> &gt;= 0</expr>)</condition><then>
<expr_stmt><expr><name>c</name> = *<name>fmt</name>++</expr>;</expr_stmt></then></if>
}</block></then> <else>else <if>if <condition>(<expr><name>c</name> &gt;= '0' &amp;&amp; <name>c</name> &lt;= '9'</expr>)</condition><then> <block>{
<expr_stmt><expr><name>width</name> = <name>c</name> - '0'</expr>;</expr_stmt>
<while>while <condition>(<expr>--<name>fmtcnt</name> &gt;= 0</expr>)</condition> <block>{
<expr_stmt><expr><name>c</name> = *<name>fmt</name>++</expr>;</expr_stmt>
<if>if <condition>(<expr><name>c</name> &lt; '0' || <name>c</name> &gt; '9'</expr>)</condition><then>
<break>break;</break></then></if>
<if>if <condition>(<expr>(<name>width</name>*10) / 10 != <name>width</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"width too big"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>onError</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>width</name> = <name>width</name>*10 + (<name>c</name> - '0')</expr>;</expr_stmt>
}</block></while>
}</block></then></if></else></if>
<if>if <condition>(<expr><name>c</name> == '.'</expr>)</condition><then> <block>{
<expr_stmt><expr><name>prec</name> = 0</expr>;</expr_stmt>
<if>if <condition>(<expr>--<name>fmtcnt</name> &gt;= 0</expr>)</condition><then>
<expr_stmt><expr><name>c</name> = *<name>fmt</name>++</expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>c</name> == '*'</expr>)</condition><then> <block>{
<expr_stmt><expr><name>v</name> = <call><name>getnextarg</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>arglen</name></expr></argument>, <argument><expr>&amp;<name>argidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<if>if <condition>(<expr>!<call><name>PyInt_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"* wants int"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>onError</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>prec</name> = <call><name>PyInt_AsLong</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>prec</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>prec</name> = 0</expr>;</expr_stmt></then></if>
<if>if <condition>(<expr>--<name>fmtcnt</name> &gt;= 0</expr>)</condition><then>
<expr_stmt><expr><name>c</name> = *<name>fmt</name>++</expr>;</expr_stmt></then></if>
}</block></then> <else>else <if>if <condition>(<expr><name>c</name> &gt;= '0' &amp;&amp; <name>c</name> &lt;= '9'</expr>)</condition><then> <block>{
<expr_stmt><expr><name>prec</name> = <name>c</name> - '0'</expr>;</expr_stmt>
<while>while <condition>(<expr>--<name>fmtcnt</name> &gt;= 0</expr>)</condition> <block>{
<expr_stmt><expr><name>c</name> = <call><name>Py_CHARMASK</name><argument_list>(<argument><expr>*<name>fmt</name>++</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>c</name> &lt; '0' || <name>c</name> &gt; '9'</expr>)</condition><then>
<break>break;</break></then></if>
<if>if <condition>(<expr>(<name>prec</name>*10) / 10 != <name>prec</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"prec too big"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>onError</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>prec</name> = <name>prec</name>*10 + (<name>c</name> - '0')</expr>;</expr_stmt>
}</block></while>
}</block></then></if></else></if>
}</block></then></if>
<if>if <condition>(<expr><name>fmtcnt</name> &gt;= 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>c</name> == 'h' || <name>c</name> == 'l' || <name>c</name> == 'L'</expr>)</condition><then> <block>{
<if>if <condition>(<expr>--<name>fmtcnt</name> &gt;= 0</expr>)</condition><then>
<expr_stmt><expr><name>c</name> = *<name>fmt</name>++</expr>;</expr_stmt></then></if>
}</block></then></if>
}</block></then></if>
<if>if <condition>(<expr><name>fmtcnt</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"incomplete format"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>onError</name>;</goto>
}</block></then></if>
<if>if <condition>(<expr><name>c</name> != '%'</expr>)</condition><then> <block>{
<expr_stmt><expr><name>v</name> = <call><name>getnextarg</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>arglen</name></expr></argument>, <argument><expr>&amp;<name>argidx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>v</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
}</block></then></if>
<expr_stmt><expr><name>sign</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>fill</name> = ' '</expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>c</name></expr>)</condition> <block>{
<case>case <expr>'%'</expr>:
<expr_stmt><expr><name>pbuf</name> = <name>formatbuf</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pbuf</name><index>[<expr>0</expr>]</index></name> = '%'</expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> = 1</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'s'</expr>:
</case><case>case <expr>'r'</expr>:
<if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> &amp;&amp; <name>c</name> == 's'</expr>)</condition><then> <block>{
<expr_stmt><expr><name>temp</name> = <name>v</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>unicode</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>c</name> == 's'</expr>)</condition><then>
<expr_stmt><expr><name>temp</name> = <call><name>PyObject_Unicode</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>temp</name> = <call><name>PyObject_Repr</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<if>if <condition>(<expr><name>temp</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<if>if <condition>(<expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<empty_stmt>;</empty_stmt></then>
<else>else <if>if <condition>(<expr><call><name>PyString_Check</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>unicode</name> = <call><name>PyUnicode_Decode</name><argument_list>(<argument><expr><call><name>PyString_AS_STRING</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>PyString_GET_SIZE</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>,
<argument><expr>"strict"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>temp</name> = <name>unicode</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>temp</name> == <name>NULL</name></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"%s argument has non-string str()"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>onError</name>;</goto>
}</block></else></if></else></if>
}</block></else></if>
<expr_stmt><expr><name>pbuf</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> = <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>prec</name> &gt;= 0 &amp;&amp; <name>len</name> &gt; <name>prec</name></expr>)</condition><then>
<expr_stmt><expr><name>len</name> = <name>prec</name></expr>;</expr_stmt></then></if>
<break>break;</break>
</case><case>case <expr>'i'</expr>:
</case><case>case <expr>'d'</expr>:
</case><case>case <expr>'u'</expr>:
</case><case>case <expr>'o'</expr>:
</case><case>case <expr>'x'</expr>:
</case><case>case <expr>'X'</expr>:
<if>if <condition>(<expr><name>c</name> == 'i'</expr>)</condition><then>
<expr_stmt><expr><name>c</name> = 'd'</expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>isnumok</name> = 0</expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>PyNumber_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>iobj</name><init>=<expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call> || (<call><name>PyLong_Check</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
<expr_stmt><expr><name>iobj</name> = <name>v</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_INCREF</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>iobj</name> = <call><name>PyNumber_Int</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>iobj</name>==<name>NULL</name></expr>)</condition><then> <expr_stmt><expr><name>iobj</name> = <call><name>PyNumber_Long</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></else></if>
<if>if <condition>(<expr><name>iobj</name>!=<name>NULL</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>PyInt_Check</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>isnumok</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name>pbuf</name> = <name>formatbuf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> = <call><name>formatint</name><argument_list>(<argument><expr><name>pbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>formatbuf</name></expr></argument>)</argument_list></sizeof>/<sizeof>sizeof<argument_list>(<argument><expr><name>Py_UNICODE</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><name>flags</name></expr></argument>, <argument><expr><name>prec</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>iobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>len</name> &lt; 0</expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<expr_stmt><expr><name>sign</name> = 1</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><call><name>PyLong_Check</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>isnumok</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><name>temp</name> = <call><name>formatlong</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>prec</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>temp</name></expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<expr_stmt><expr><name>pbuf</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> = <call><name>PyUnicode_GET_SIZE</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>sign</name> = 1</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>iobj</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if></else></if>
}</block></then></if>
}</block></then></if>
<if>if <condition>(<expr>!<name>isnumok</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"%%%c format: a number is required, "
"not %.200s"</expr></argument>, <argument><expr>(<name>char</name>)<name>c</name></expr></argument>, <argument><expr><call><name>Py_TYPE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call>-&gt;<name>tp_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>onError</name>;</goto>
}</block></then></if>
<if>if <condition>(<expr><name>flags</name> &amp; <name>F_ZERO</name></expr>)</condition><then>
<expr_stmt><expr><name>fill</name> = '0'</expr>;</expr_stmt></then></if>
<break>break;</break>
</case><case>case <expr>'e'</expr>:
</case><case>case <expr>'E'</expr>:
</case><case>case <expr>'f'</expr>:
</case><case>case <expr>'F'</expr>:
</case><case>case <expr>'g'</expr>:
</case><case>case <expr>'G'</expr>:
<if>if <condition>(<expr><name>c</name> == 'F'</expr>)</condition><then>
<expr_stmt><expr><name>c</name> = 'f'</expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>pbuf</name> = <name>formatbuf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> = <call><name>formatfloat</name><argument_list>(<argument><expr><name>pbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>formatbuf</name></expr></argument>)</argument_list></sizeof>/<sizeof>sizeof<argument_list>(<argument><expr><name>Py_UNICODE</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><name>flags</name></expr></argument>, <argument><expr><name>prec</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>len</name> &lt; 0</expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<expr_stmt><expr><name>sign</name> = 1</expr>;</expr_stmt>
<if>if <condition>(<expr><name>flags</name> &amp; <name>F_ZERO</name></expr>)</condition><then>
<expr_stmt><expr><name>fill</name> = '0'</expr>;</expr_stmt></then></if>
<break>break;</break>
</case><case>case <expr>'c'</expr>:
<expr_stmt><expr><name>pbuf</name> = <name>formatbuf</name></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> = <call><name>formatchar</name><argument_list>(<argument><expr><name>pbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>formatbuf</name></expr></argument>)</argument_list></sizeof>/<sizeof>sizeof<argument_list>(<argument><expr><name>Py_UNICODE</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>len</name> &lt; 0</expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<break>break;</break>
</case><default>default:
<expr_stmt><expr><call><name>PyErr_Format</name><argument_list>(<argument><expr><name>PyExc_ValueError</name></expr></argument>,
<argument><expr>"unsupported format character '%c' (0x%x) "
"at index %zd"</expr></argument>,
<argument><expr>(31&lt;=<name>c</name> &amp;&amp; <name>c</name>&lt;=126) ? (<name>char</name>)<name>c</name> : '?'</expr></argument>,
<argument><expr>(<name>int</name>)<name>c</name></expr></argument>,
<argument><expr><call>(<name>Py_ssize_t</name>)<argument_list>(<argument><expr><name>fmt</name> - 1 -
<call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>uformat</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>onError</name>;</goto>
</default>}</block></switch>
<if>if <condition>(<expr><name>sign</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>*<name>pbuf</name> == '-' || *<name>pbuf</name> == '+'</expr>)</condition><then> <block>{
<expr_stmt><expr><name>sign</name> = *<name>pbuf</name>++</expr>;</expr_stmt>
<expr_stmt><expr><name>len</name>--</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>flags</name> &amp; <name>F_SIGN</name></expr>)</condition><then>
<expr_stmt><expr><name>sign</name> = '+'</expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name>flags</name> &amp; <name>F_BLANK</name></expr>)</condition><then>
<expr_stmt><expr><name>sign</name> = ' '</expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>sign</name> = 0</expr>;</expr_stmt></else></if></else></if></else></if>
}</block></then></if>
<if>if <condition>(<expr><name>width</name> &lt; <name>len</name></expr>)</condition><then>
<expr_stmt><expr><name>width</name> = <name>len</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>rescnt</name> - (<name>sign</name> != 0) &lt; <name>width</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>reslen</name> -= <name>rescnt</name></expr>;</expr_stmt>
<expr_stmt><expr><name>rescnt</name> = <name>width</name> + <name>fmtcnt</name> + 100</expr>;</expr_stmt>
<expr_stmt><expr><name>reslen</name> += <name>rescnt</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>reslen</name> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>onError</name>;</goto>
}</block></then></if>
<if>if <condition>(<expr><call><name>_PyUnicode_Resize</name><argument_list>(<argument><expr>&amp;<name>result</name></expr></argument>, <argument><expr><name>reslen</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>onError</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>res</name> = <call><name>PyUnicode_AS_UNICODE</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call>
+ <name>reslen</name> - <name>rescnt</name></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>sign</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>fill</name> != ' '</expr>)</condition><then>
<expr_stmt><expr>*<name>res</name>++ = <name>sign</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>rescnt</name>--</expr>;</expr_stmt>
<if>if <condition>(<expr><name>width</name> &gt; <name>len</name></expr>)</condition><then>
<expr_stmt><expr><name>width</name>--</expr>;</expr_stmt></then></if>
}</block></then></if>
<if>if <condition>(<expr>(<name>flags</name> &amp; <name>F_ALT</name>) &amp;&amp; (<name>c</name> == 'x' || <name>c</name> == 'X')</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>pbuf</name><index>[<expr>0</expr>]</index></name> == '0'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>pbuf</name><index>[<expr>1</expr>]</index></name> == <name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>fill</name> != ' '</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>res</name>++ = *<name>pbuf</name>++</expr>;</expr_stmt>
<expr_stmt><expr>*<name>res</name>++ = *<name>pbuf</name>++</expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>rescnt</name> -= 2</expr>;</expr_stmt>
<expr_stmt><expr><name>width</name> -= 2</expr>;</expr_stmt>
<if>if <condition>(<expr><name>width</name> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><name>width</name> = 0</expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>len</name> -= 2</expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>width</name> &gt; <name>len</name> &amp;&amp; !(<name>flags</name> &amp; <name>F_LJUST</name>)</expr>)</condition><then> <block>{
<do>do <block>{
<expr_stmt><expr>--<name>rescnt</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>res</name>++ = <name>fill</name></expr>;</expr_stmt>
}</block> while <condition>(<expr>--<name>width</name> &gt; <name>len</name></expr>)</condition>;</do>
}</block></then></if>
<if>if <condition>(<expr><name>fill</name> == ' '</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>sign</name></expr>)</condition><then>
<expr_stmt><expr>*<name>res</name>++ = <name>sign</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr>(<name>flags</name> &amp; <name>F_ALT</name>) &amp;&amp; (<name>c</name> == 'x' || <name>c</name> == 'X')</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>pbuf</name><index>[<expr>0</expr>]</index></name> == '0'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>pbuf</name><index>[<expr>1</expr>]</index></name> == <name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>res</name>++ = *<name>pbuf</name>++</expr>;</expr_stmt>
<expr_stmt><expr>*<name>res</name>++ = *<name>pbuf</name>++</expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
<expr_stmt><expr><call><name>Py_UNICODE_COPY</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>pbuf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>res</name> += <name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><name>rescnt</name> -= <name>len</name></expr>;</expr_stmt>
<while>while <condition>(<expr>--<name>width</name> &gt;= <name>len</name></expr>)</condition> <block>{
<expr_stmt><expr>--<name>rescnt</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>res</name>++ = ' '</expr>;</expr_stmt>
}</block></while>
<if>if <condition>(<expr><name>dict</name> &amp;&amp; (<name>argidx</name> &lt; <name>arglen</name>) &amp;&amp; <name>c</name> != '%'</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"not all arguments converted during string formatting"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>onError</name>;</goto>
}</block></then></if>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
}</block></while>
<if>if <condition>(<expr><name>argidx</name> &lt; <name>arglen</name> &amp;&amp; !<name>dict</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>PyErr_SetString</name><argument_list>(<argument><expr><name>PyExc_TypeError</name></expr></argument>,
<argument><expr>"not all arguments converted during string formatting"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>onError</name>;</goto>
}</block></then></if>
<if>if <condition>(<expr><call><name>_PyUnicode_Resize</name><argument_list>(<argument><expr>&amp;<name>result</name></expr></argument>, <argument><expr><name>reslen</name> - <name>rescnt</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<goto>goto <name>onError</name>;</goto></then></if>
<if>if <condition>(<expr><name>args_owned</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>uformat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *)<name>result</name></expr>;</return>
<label><name>onError</name>:</label>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>uformat</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>args_owned</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <name>PyBufferProcs</name></type> <name>unicode_as_buffer</name> <init>= <expr><block>{
<expr>(<name>readbufferproc</name>) <name>unicode_buffer_getreadbuf</name></expr>,
<expr>(<name>writebufferproc</name>) <name>unicode_buffer_getwritebuf</name></expr>,
<expr>(<name>segcountproc</name>) <name>unicode_buffer_getsegcount</name></expr>,
<expr>(<name>charbufferproc</name>) <name>unicode_buffer_getcharbuf</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
<function_decl><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>unicode_subtype_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list>;</function_decl>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>unicode_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyObject</name> *</type><name>x</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> *</type><name><name>kwlist</name><index>[]</index></name> <init>= <expr><block>{<expr>"string"</expr>, <expr>"encoding"</expr>, <expr>"errors"</expr>, <expr>0</expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>encoding</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>errors</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>type</name> != &amp;<name>PyUnicode_Type</name></expr>)</condition><then>
<return>return <expr><call><name>unicode_subtype_new</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr>!<call><name>PyArg_ParseTupleAndKeywords</name><argument_list>(<argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>, <argument><expr>"|Oss:unicode"</expr></argument>,
<argument><expr><name>kwlist</name></expr></argument>, <argument><expr>&amp;<name>x</name></expr></argument>, <argument><expr>&amp;<name>encoding</name></expr></argument>, <argument><expr>&amp;<name>errors</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>x</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>(<name>PyObject</name> *)<call><name>_PyUnicode_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><name>encoding</name> == <name>NULL</name> &amp;&amp; <name>errors</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><call><name>PyObject_Unicode</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr>;</return></then>
<else>else
<return>return <expr><call><name>PyUnicode_FromEncodedObject</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>errors</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>
<function><type><specifier>static</specifier> <name>PyObject</name> *</type>
<name>unicode_subtype_new</name><parameter_list>(<param><decl><type><name>PyTypeObject</name> *</type><name>type</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>args</name></decl></param>, <param><decl><type><name>PyObject</name> *</type><name>kwds</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>tmp</name></decl>, *<decl><type ref="prev"/><name>pnew</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_ssize_t</name></type> <name>n</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyType_IsSubtype</name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr>&amp;<name>PyUnicode_Type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tmp</name> = (<name>PyUnicodeObject</name> *)<call><name>unicode_new</name><argument_list>(<argument><expr>&amp;<name>PyUnicode_Type</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>kwds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>tmp</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>PyUnicode_Check</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>pnew</name> = (<name>PyUnicodeObject</name> *) <call><name><name>type</name>-&gt;<name>tp_alloc</name></name><argument_list>(<argument><expr><name>type</name></expr></argument>, <argument><expr><name>n</name> = <name><name>tmp</name>-&gt;<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>pnew</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>pnew</name>-&gt;<name>str</name></name> = (<name>Py_UNICODE</name>*) <call><name>PyObject_MALLOC</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Py_UNICODE</name></expr></argument>)</argument_list></sizeof> * (<name>n</name>+1)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>pnew</name>-&gt;<name>str</name></name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>_Py_ForgetReference</name><argument_list>(<argument><expr>(<name>PyObject</name> *)<name>pnew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyObject_Del</name><argument_list>(<argument><expr><name>pnew</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>PyErr_NoMemory</name><argument_list>()</argument_list></call></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>Py_UNICODE_COPY</name><argument_list>(<argument><expr><name><name>pnew</name>-&gt;<name>str</name></name></expr></argument>, <argument><expr><name><name>tmp</name>-&gt;<name>str</name></name></expr></argument>, <argument><expr><name>n</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pnew</name>-&gt;<name>length</name></name> = <name>n</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pnew</name>-&gt;<name>hash</name></name> = <name><name>tmp</name>-&gt;<name>hash</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr>(<name>PyObject</name> *)<name>pnew</name></expr>;</return>
}</block></function>
<expr_stmt><expr><call><name>PyDoc_STRVAR</name><argument_list>(<argument><expr><name>unicode_doc</name></expr></argument>,
<argument><expr>"unicode(string [, encoding[, errors]]) -&gt; object\n\
\n\
Create a new Unicode object from the given encoded string.\n\
encoding defaults to the current default string encoding.\n\
errors can be 'strict', 'replace' or 'ignore' and defaults to 'strict'."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<decl_stmt><decl><type><name>PyTypeObject</name></type> <name>PyUnicode_Type</name> <init>= <expr><block>{
<expr><call><name>PyVarObject_HEAD_INIT</name><argument_list>(<argument><expr>&amp;<name>PyType_Type</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call>
"unicode"</expr>,
<expr><sizeof>sizeof<argument_list>(<argument><expr><name>PyUnicodeObject</name></expr></argument>)</argument_list></sizeof></expr>,
<expr>0</expr>,
<expr>(<name>destructor</name>)<name>unicode_dealloc</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>unicode_repr</name></expr>,
<expr>&amp;<name>unicode_as_number</name></expr>,
<expr>&amp;<name>unicode_as_sequence</name></expr>,
<expr>&amp;<name>unicode_as_mapping</name></expr>,
<expr>(<name>hashfunc</name>) <name>unicode_hash</name></expr>,
<expr>0</expr>,
<expr>(<name>reprfunc</name>) <name>unicode_str</name></expr>,
<expr><name>PyObject_GenericGetAttr</name></expr>,
<expr>0</expr>,
<expr>&amp;<name>unicode_as_buffer</name></expr>,
<expr><name>Py_TPFLAGS_DEFAULT</name> | <name>Py_TPFLAGS_CHECKTYPES</name> |
<name>Py_TPFLAGS_BASETYPE</name> | <name>Py_TPFLAGS_UNICODE_SUBCLASS</name></expr>,
<expr><name>unicode_doc</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>PyUnicode_RichCompare</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>unicode_methods</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>&amp;<name>PyBaseString_Type</name></expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr>0</expr>,
<expr><name>unicode_new</name></expr>,
<expr><name>PyObject_Del</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
<function><type><name>void</name></type> <name>_PyUnicode_Init</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>Py_UNICODE</name></type> <name><name>linebreak</name><index>[]</index></name> <init>= <expr><block>{
<expr>0x000A</expr>,
<expr>0x000D</expr>,
<expr>0x001C</expr>,
<expr>0x001D</expr>,
<expr>0x001E</expr>,
<expr>0x0085</expr>,
<expr>0x2028</expr>,
<expr>0x2029</expr>,
}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>free_list</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>numfree</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>unicode_empty</name> = <call><name>_PyUnicode_New</name><argument_list>(<argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>unicode_empty</name></expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>unicode_default_encoding</name></expr></argument>, <argument><expr>"ascii"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; 256</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
<expr_stmt><expr><name><name>unicode_latin1</name><index>[<expr><name>i</name></expr>]</index></name> = <name>NULL</name></expr>;</expr_stmt></for>
<if>if <condition>(<expr><call><name>PyType_Ready</name><argument_list>(<argument><expr>&amp;<name>PyUnicode_Type</name></expr></argument>)</argument_list></call> &lt; 0</expr>)</condition><then>
<expr_stmt><expr><call><name>Py_FatalError</name><argument_list>(<argument><expr>"Can't initialize 'unicode'"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>bloom_linebreak</name> = <call><name>make_bloom_mask</name><argument_list>(
<argument><expr><name>linebreak</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>linebreak</name></expr></argument>)</argument_list></sizeof> / <sizeof>sizeof<argument_list>(<argument><expr><name><name>linebreak</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></sizeof></expr></argument>
)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyType_Ready</name><argument_list>(<argument><expr>&amp;<name>EncodingMapType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><name>int</name></type>
<name>PyUnicode_ClearFreeList</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>freelist_size</name> <init>= <expr><name>numfree</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>u</name></decl>;</decl_stmt>
<for>for (<init><expr><name>u</name> = <name>free_list</name></expr>;</init> <condition><expr><name>u</name> != <name>NULL</name></expr>;</condition><incr/>) <block>{
<decl_stmt><decl><type><name>PyUnicodeObject</name> *</type><name>v</name> <init>= <expr><name>u</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>u</name> = *(<name>PyUnicodeObject</name> **)<name>u</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>v</name>-&gt;<name>str</name></name></expr>)</condition><then>
<expr_stmt><expr><call><name>PyObject_DEL</name><argument_list>(<argument><expr><name><name>v</name>-&gt;<name>str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name><name>v</name>-&gt;<name>defenc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PyObject_Del</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>numfree</name>--</expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><name>free_list</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>numfree</name> == 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>freelist_size</name></expr>;</return>
}</block></function>
<function><type><name>void</name></type>
<name>_PyUnicode_Fini</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>Py_XDECREF</name><argument_list>(<argument><expr><name>unicode_empty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>unicode_empty</name> = <name>NULL</name></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; 256</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<if>if <condition>(<expr><name><name>unicode_latin1</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>Py_DECREF</name><argument_list>(<argument><expr><name><name>unicode_latin1</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>unicode_latin1</name><index>[<expr><name>i</name></expr>]</index></name> = <name>NULL</name></expr>;</expr_stmt>
}</block></then></if>
}</block></for>
<expr_stmt><expr>(<name>void</name>)<call><name>PyUnicode_ClearFreeList</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__cplusplus</name></expr></argument>)</argument_list></call></expr></cpp:if>
}</block></extern>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
