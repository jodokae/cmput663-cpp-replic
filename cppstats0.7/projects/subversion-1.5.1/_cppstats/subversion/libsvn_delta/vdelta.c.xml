<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/subversion-1.5.1/_cppstats/subversion/libsvn_delta/vdelta.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_general.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_delta.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"delta.h"</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VD_KEY_SIZE</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>
<typedef>typedef <type><struct>struct <name>hash_slot_t</name> <block>{
<decl_stmt><decl><type>struct <name>hash_slot_t</name> *</type><name>next</name></decl>;</decl_stmt>
}</block></struct></type> <name>hash_slot_t</name>;</typedef>
<typedef>typedef <type><struct>struct <name>hash_table_t</name> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>num_buckets</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>hash_slot_t</name> **</type><name>buckets</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>hash_slot_t</name> *</type><name>slots</name></decl>;</decl_stmt>
}</block></struct></type> <name>hash_table_t</name>;</typedef>
<function><type><specifier>static</specifier> <name>hash_table_t</name> *</type>
<name>create_hash_table</name><parameter_list>(<param><decl><type><name>apr_size_t</name></type> <name>num_slots</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>j</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>hash_table_t</name>*</type> <name>table</name> <init>= <expr><call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>table</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>table</name>-&gt;<name>num_buckets</name></name> = (<name>num_slots</name> / 3) | 1</expr>;</expr_stmt>
<expr_stmt><expr><name><name>table</name>-&gt;<name>buckets</name></name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>(<name><name>table</name>-&gt;<name>num_buckets</name></name>
* <sizeof>sizeof<argument_list>(<argument><expr>*<name><name>table</name>-&gt;<name>buckets</name></name></expr></argument>)</argument_list></sizeof>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>table</name>-&gt;<name>num_buckets</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>)
<expr_stmt><expr><name><name>table</name>-&gt;<name>buckets</name><index>[<expr><name>i</name></expr>]</index></name> = <name>NULL</name></expr>;</expr_stmt></for>
<expr_stmt><expr><name><name>table</name>-&gt;<name>slots</name></name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>num_slots</name> * <sizeof>sizeof<argument_list>(<argument><expr>*<name><name>table</name>-&gt;<name>slots</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name>num_slots</name></expr>;</condition> <incr><expr>++<name>j</name></expr></incr>)
<expr_stmt><expr><name><name>table</name>-&gt;<name>slots</name><index>[<expr><name>j</name></expr>]</index></name>.<name>next</name> = <name>NULL</name></expr>;</expr_stmt></for>
<return>return <expr><name>table</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>APR_INLINE</name> <name>apr_uint32_t</name></type>
<name>get_bucket</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>hash_table_t</name> *</type><name>table</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>key</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_uint32_t</name></type> <name>hash</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>VD_KEY_SIZE</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>)
<expr_stmt><expr><name>hash</name> = <name>hash</name> * 127 + *<name>key</name>++</expr>;</expr_stmt></for>
<return>return <expr><name>hash</name> % <name><name>table</name>-&gt;<name>num_buckets</name></name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>APR_INLINE</name> <name>void</name></type>
<name>store_mapping</name><parameter_list>(<param><decl><type><name>hash_table_t</name> *</type><name>table</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>key</name></decl></param>, <param><decl><type><name>apr_size_t</name></type> <name>idx</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_uint32_t</name></type> <name>bucket</name> <init>= <expr><call><name>get_bucket</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>table</name>-&gt;<name>slots</name><index>[<expr><name>idx</name></expr>]</index></name>.<name>next</name> == <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>table</name>-&gt;<name>slots</name><index>[<expr><name>idx</name></expr>]</index></name>.<name>next</name> = <name><name>table</name>-&gt;<name>buckets</name><index>[<expr><name>bucket</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>table</name>-&gt;<name>buckets</name><index>[<expr><name>bucket</name></expr>]</index></name> = &amp;<name><name>table</name>-&gt;<name>slots</name><index>[<expr><name>idx</name></expr>]</index></name></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>APR_INLINE</name> <name>int</name></type>
<name>find_match_len</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>match</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>from</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>end</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>here</name> <init>= <expr><name>from</name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>here</name> &lt; <name>end</name> &amp;&amp; *<name>match</name> == *<name>here</name></expr>)</condition> <block>{
<expr_stmt><expr>++<name>match</name></expr>;</expr_stmt>
<expr_stmt><expr>++<name>here</name></expr>;</expr_stmt>
}</block></while>
<return>return <expr><name>here</name> - <name>from</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>vdelta</name><parameter_list>(<param><decl><type><name>svn_txdelta__ops_baton_t</name> *</type><name>build_baton</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>start</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>end</name></decl></param>,
<param><decl><type><name>svn_boolean_t</name></type> <name>outputflag</name></decl></param>,
<param><decl><type><name>hash_table_t</name> *</type><name>table</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>here</name> <init>= <expr><name>start</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>insert_from</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>current_match</name></decl>, *<decl><type ref="prev"/><name>key</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>current_match_len</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>hash_slot_t</name> *</type><name>slot</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>progress</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>end</name> - <name>here</name> &lt; <name>VD_KEY_SIZE</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>from</name> <init>= <expr>((<name>insert_from</name> != <name>NULL</name>) ? <name>insert_from</name> : <name>here</name>)</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>outputflag</name> &amp;&amp; <name>from</name> &lt; <name>end</name></expr>)</condition><then>
<expr_stmt><expr><call><name>svn_txdelta__insert_op</name><argument_list>(<argument><expr><name>build_baton</name></expr></argument>, <argument><expr><name>svn_txdelta_new</name></expr></argument>, <argument><expr>0</expr></argument>,
<argument><expr><name>end</name> - <name>from</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return;</return>
}</block></then></if>
<expr_stmt><expr><name>current_match</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>current_match_len</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name>key</name> = <name>here</name></expr>;</expr_stmt>
<do>do <block>{
<expr_stmt><expr><name>progress</name> = <name>FALSE</name></expr>;</expr_stmt>
<for>for (<init><expr><name>slot</name> = <name><name>table</name>-&gt;<name>buckets</name><index>[<expr><call><name>get_bucket</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</init>
<condition><expr><name>slot</name> != <name>NULL</name></expr>;</condition>
<incr><expr><name>slot</name> = <name><name>slot</name>-&gt;<name>next</name></name></expr></incr>) <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>match</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>match_len</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>slot</name> - <name><name>table</name>-&gt;<name>slots</name></name> &lt; <name>key</name> - <name>here</name></expr>)</condition><then>
<continue>continue;</continue></then></if>
<expr_stmt><expr><name>match</name> = <name>data</name> + (<name>slot</name> - <name><name>table</name>-&gt;<name>slots</name></name>) - (<name>key</name> - <name>here</name>)</expr>;</expr_stmt>
<expr_stmt><expr><name>match_len</name> = <call><name>find_match_len</name><argument_list>(<argument><expr><name>match</name></expr></argument>, <argument><expr><name>here</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>match</name> &lt; <name>start</name> &amp;&amp; <name>match</name> + <name>match_len</name> &gt; <name>start</name></expr>)</condition><then>
<expr_stmt><expr><name>match_len</name> = <name>start</name> - <name>match</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>match_len</name> &gt;= <name>VD_KEY_SIZE</name> &amp;&amp; <name>match_len</name> &gt; <name>current_match_len</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>current_match</name> = <name>match</name></expr>;</expr_stmt>
<expr_stmt><expr><name>current_match_len</name> = <name>match_len</name></expr>;</expr_stmt>
<expr_stmt><expr><name>progress</name> = <name>TRUE</name></expr>;</expr_stmt>
}</block></then></if>
}</block></for>
<if>if <condition>(<expr><name>progress</name></expr>)</condition><then>
<expr_stmt><expr><name>key</name> = <name>here</name> + <name>current_match_len</name> - (<name>VD_KEY_SIZE</name> - 1)</expr>;</expr_stmt></then></if>
}</block> while <condition>(<expr><name>progress</name> &amp;&amp; <name>end</name> - <name>key</name> &gt;= <name>VD_KEY_SIZE</name></expr>)</condition>;</do>
<if>if <condition>(<expr><name>current_match_len</name> &lt; <name>VD_KEY_SIZE</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>store_mapping</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>here</name></expr></argument>, <argument><expr><name>here</name> - <name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>insert_from</name> == <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><name>insert_from</name> = <name>here</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>here</name>++</expr>;</expr_stmt>
<continue>continue;</continue>
}</block></then> <else>else <if>if <condition>(<expr><name>outputflag</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>insert_from</name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>svn_txdelta__insert_op</name><argument_list>(<argument><expr><name>build_baton</name></expr></argument>, <argument><expr><name>svn_txdelta_new</name></expr></argument>,
<argument><expr>0</expr></argument>, <argument><expr><name>here</name> - <name>insert_from</name></expr></argument>,
<argument><expr><name>insert_from</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>insert_from</name> = <name>NULL</name></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>current_match</name> &lt; <name>start</name></expr>)</condition><then>
<expr_stmt><expr><call><name>svn_txdelta__insert_op</name><argument_list>(<argument><expr><name>build_baton</name></expr></argument>, <argument><expr><name>svn_txdelta_source</name></expr></argument>,
<argument><expr><name>current_match</name> - <name>data</name></expr></argument>,
<argument><expr><name>current_match_len</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><call><name>svn_txdelta__insert_op</name><argument_list>(<argument><expr><name>build_baton</name></expr></argument>, <argument><expr><name>svn_txdelta_target</name></expr></argument>,
<argument><expr><name>current_match</name> - <name>start</name></expr></argument>,
<argument><expr><name>current_match_len</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
}</block></then></if></else></if>
<expr_stmt><expr><name>here</name> += <name>current_match_len</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>end</name> - <name>here</name> &gt;= <name>VD_KEY_SIZE</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name> <specifier>const</specifier> *</type><name>last</name> <init>= <expr><name>here</name> - (<name>VD_KEY_SIZE</name> - 1)</expr></init></decl>;</decl_stmt>
<for>for (<init>;</init> <condition><expr><name>last</name> &lt; <name>here</name></expr>;</condition> <incr><expr>++<name>last</name></expr></incr>)
<expr_stmt><expr><call><name>store_mapping</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>last</name></expr></argument>, <argument><expr><name>last</name> - <name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
}</block></then></if>
}</block></for>
}</block></function>
<function><type><name>void</name></type>
<name>svn_txdelta__vdelta</name><parameter_list>(<param><decl><type><name>svn_txdelta__ops_baton_t</name> *</type><name>build_baton</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name></decl></param>,
<param><decl><type><name>apr_size_t</name></type> <name>source_len</name></decl></param>,
<param><decl><type><name>apr_size_t</name></type> <name>target_len</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>hash_table_t</name> *</type><name>table</name> <init>= <expr><call><name>create_hash_table</name><argument_list>(<argument><expr><name>source_len</name> + <name>target_len</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>vdelta</name><argument_list>(<argument><expr><name>build_baton</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>data</name> + <name>source_len</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>table</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>vdelta</name><argument_list>(<argument><expr><name>build_baton</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>data</name> + <name>source_len</name></expr></argument>, <argument><expr><name>data</name> + <name>source_len</name> + <name>target_len</name></expr></argument>,
<argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>table</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
{
int i;
int empty = 0;
int collisions = 0;
for (i = 0; i &lt; table-&gt;num_buckets; ++i) {
hash_slot_t *slot = table-&gt;buckets[i];
if (!slot)
++empty;
else {
slot = slot-&gt;next;
while (slot != NULL) {
++collisions;
slot = slot-&gt;next;
}
}
}
fprintf(stderr, "Hash stats: load %d, collisions %d\n",
100 - 100 * empty / table-&gt;num_buckets, collisions);
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>
</unit>
