<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="subversion/libsvn_delta/xdelta.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_general.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_hash.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_delta.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"delta.h"</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADLER32_MASK</name></cpp:macro> <cpp:value>0x0000ffff</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADLER32_CHAR_MASK</name></cpp:macro> <cpp:value>0x000000ff</cpp:value></cpp:define>
<struct>struct <name>adler32</name> <block>{
<decl_stmt><decl><type><name>apr_uint32_t</name></type> <name>s1</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_uint32_t</name></type> <name>s2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_uint32_t</name></type> <name>len</name></decl>;</decl_stmt>
}</block>;</struct>
<function><type><specifier>static</specifier> <name>APR_INLINE</name> <name>void</name></type>
<name>adler32_in</name><parameter_list>(<param><decl><type>struct <name>adler32</name> *</type><name>ad</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name></type> <name>c</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name><name>ad</name>-&gt;<name>s1</name></name> += (<call>(<name>apr_uint32_t</name>) <argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call>) &amp; <name>ADLER32_CHAR_MASK</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ad</name>-&gt;<name>s1</name></name> &amp;= <name>ADLER32_MASK</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ad</name>-&gt;<name>s2</name></name> += <name><name>ad</name>-&gt;<name>s1</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ad</name>-&gt;<name>s2</name></name> &amp;= <name>ADLER32_MASK</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ad</name>-&gt;<name>len</name></name>++</expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>APR_INLINE</name> <name>void</name></type>
<name>adler32_out</name><parameter_list>(<param><decl><type>struct <name>adler32</name> *</type><name>ad</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name></type> <name>c</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name><name>ad</name>-&gt;<name>s1</name></name> -= (<call>(<name>apr_uint32_t</name>) <argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call>) &amp; <name>ADLER32_CHAR_MASK</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ad</name>-&gt;<name>s1</name></name> &amp;= <name>ADLER32_MASK</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>ad</name>-&gt;<name>s2</name></name> -= (<name><name>ad</name>-&gt;<name>len</name></name> * (((<name>apr_uint32_t</name>) <name>c</name>) &amp; <name>ADLER32_CHAR_MASK</name>)) + 1</expr>;</expr_stmt>
<expr_stmt><expr><name><name>ad</name>-&gt;<name>s2</name></name> &amp;= <name>ADLER32_MASK</name></expr>;</expr_stmt>
<expr_stmt><expr>--<name><name>ad</name>-&gt;<name>len</name></name></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>APR_INLINE</name> <name>apr_uint32_t</name></type>
<name>adler32_sum</name><parameter_list>(<param><decl><type><specifier>const</specifier> struct <name>adler32</name> *</type><name>ad</name></decl></param>)</parameter_list> <block>{
<return>return <expr>(<name><name>ad</name>-&gt;<name>s2</name></name> &lt;&lt; 16) | (<name><name>ad</name>-&gt;<name>s1</name></name>)</expr>;</return>
}</block></function>
<expr_stmt><expr>static <name>APR_INLINE</name> struct <name>adler32</name> *
<macro><name>init_adler32</name><argument_list>(<argument>struct adler32 *ad</argument>, <argument>const char *data</argument>, <argument>apr_uint32_t datalen</argument>)</argument_list></macro> <block>{
<expr><name><name>ad</name>-&gt;<name>s1</name></name> = 1</expr>;
<expr><name><name>ad</name>-&gt;<name>s2</name></name> = 0</expr>;
<expr><name><name>ad</name>-&gt;<name>len</name></name> = 0</expr>;
<while>while <condition>(<expr><name>datalen</name>--</expr>)</condition>
<expr_stmt><expr><call><name>adler32_in</name><argument_list>(<argument><expr><name>ad</name></expr></argument>, <argument><expr>*(<name>data</name>++)</expr></argument>)</argument_list></call></expr>;</expr_stmt></while></block></expr></expr_stmt>
<return>return <expr><name>ad</name></expr>;</return>
}
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MATCH_BLOCKSIZE</name></cpp:macro> <cpp:value>64</cpp:value></cpp:define>
struct <macro><name>block</name></macro> <block>{
<decl_stmt><decl><type><name>apr_uint32_t</name></type> <name>adlersum</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>pos</name></decl>;</decl_stmt>
}</block><empty_stmt>;</empty_stmt>
<struct>struct <name>blocks</name> <block>{
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>max</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>block</name> *</type><name>slots</name></decl>;</decl_stmt>
}</block>;</struct>
<function><type><specifier>static</specifier> <name>apr_size_t</name></type> <name>hash_func</name><parameter_list>(<param><decl><type><name>apr_uint32_t</name></type> <name>sum</name></decl></param>)</parameter_list> <block>{
<return>return <expr><name>sum</name> ^ (<name>sum</name> &gt;&gt; 12)</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_block</name><parameter_list>(<param><decl><type>struct <name>blocks</name> *</type><name>blocks</name></decl></param>, <param><decl><type><name>apr_uint32_t</name></type> <name>adlersum</name></decl></param>, <param><decl><type><name>apr_size_t</name></type> <name>pos</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>h</name> <init>= <expr><call><name>hash_func</name><argument_list>(<argument><expr><name>adlersum</name></expr></argument>)</argument_list></call> &amp; <name><name>blocks</name>-&gt;<name>max</name></name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name><name>blocks</name>-&gt;<name>slots</name><index>[<expr><name>h</name></expr>]</index></name>.<name>pos</name> != (<name>apr_size_t</name>)-1</expr>)</condition> <block>{
<if>if <condition>(<expr><name><name>blocks</name>-&gt;<name>slots</name><index>[<expr><name>h</name></expr>]</index></name>.<name>adlersum</name> == <name>adlersum</name></expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><name>h</name> = (<name>h</name> + 1) &amp; <name><name>blocks</name>-&gt;<name>max</name></name></expr>;</expr_stmt>
}</block></while>
<expr_stmt><expr><name><name>blocks</name>-&gt;<name>slots</name><index>[<expr><name>h</name></expr>]</index></name>.<name>adlersum</name> = <name>adlersum</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>blocks</name>-&gt;<name>slots</name><index>[<expr><name>h</name></expr>]</index></name>.<name>pos</name> = <name>pos</name></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>apr_size_t</name></type>
<name>find_block</name><parameter_list>(<param><decl><type><specifier>const</specifier> struct <name>blocks</name> *</type><name>blocks</name></decl></param>, <param><decl><type><name>apr_uint32_t</name></type> <name>adlersum</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>h</name> <init>= <expr><call><name>hash_func</name><argument_list>(<argument><expr><name>adlersum</name></expr></argument>)</argument_list></call> &amp; <name><name>blocks</name>-&gt;<name>max</name></name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name><name>blocks</name>-&gt;<name>slots</name><index>[<expr><name>h</name></expr>]</index></name>.<name>adlersum</name> != <name>adlersum</name>
&amp;&amp; <name><name>blocks</name>-&gt;<name>slots</name><index>[<expr><name>h</name></expr>]</index></name>.<name>pos</name> != (<name>apr_size_t</name>)-1</expr>)</condition>
<expr_stmt><expr><name>h</name> = (<name>h</name> + 1) &amp; <name><name>blocks</name>-&gt;<name>max</name></name></expr>;</expr_stmt></while>
<return>return <expr><name><name>blocks</name>-&gt;<name>slots</name><index>[<expr><name>h</name></expr>]</index></name>.<name>pos</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>init_blocks_table</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name></decl></param>,
<param><decl><type><name>apr_size_t</name></type> <name>datalen</name></decl></param>,
<param><decl><type>struct <name>blocks</name> *</type><name>blocks</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>adler32</name></type> <name>adler</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>nblocks</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>nslots</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>nblocks</name> = <name>datalen</name> / <name>MATCH_BLOCKSIZE</name> + 1</expr>;</expr_stmt>
<while>while <condition>(<expr><name>nslots</name> &lt;= <name>nblocks</name></expr>)</condition>
<expr_stmt><expr><name>nslots</name> *= 2</expr>;</expr_stmt></while>
<expr_stmt><expr><name>nslots</name> *= 2</expr>;</expr_stmt>
<expr_stmt><expr><name><name>blocks</name>-&gt;<name>max</name></name> = <name>nslots</name> - 1</expr>;</expr_stmt>
<expr_stmt><expr><name><name>blocks</name>-&gt;<name>slots</name></name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>nslots</name> * <sizeof>sizeof<argument_list>(<argument><expr>*(<name><name>blocks</name>-&gt;<name>slots</name></name>)</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>nslots</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<expr_stmt><expr><name><name>blocks</name>-&gt;<name>slots</name><index>[<expr><name>i</name></expr>]</index></name>.<name>adlersum</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>blocks</name>-&gt;<name>slots</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pos</name> = (<name>apr_size_t</name>)-1</expr>;</expr_stmt>
}</block></for>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>datalen</name></expr>;</condition> <incr><expr><name>i</name> += <name>MATCH_BLOCKSIZE</name></expr></incr>) <block>{
<decl_stmt><decl><type><name>apr_uint32_t</name></type> <name>step</name> <init>=
<expr>((<name>i</name> + <name>MATCH_BLOCKSIZE</name>) &gt;= <name>datalen</name>) ? (<name>datalen</name> - <name>i</name>) : <name>MATCH_BLOCKSIZE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_uint32_t</name></type> <name>adlersum</name> <init>=
<expr><call><name>adler32_sum</name><argument_list>(<argument><expr><call><name>init_adler32</name><argument_list>(<argument><expr>&amp;<name>adler</name></expr></argument>, <argument><expr><name>data</name> + <name>i</name></expr></argument>, <argument><expr><name>step</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>add_block</name><argument_list>(<argument><expr><name>blocks</name></expr></argument>, <argument><expr><name>adlersum</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_boolean_t</name></type>
<name>find_match</name><parameter_list>(<param><decl><type><specifier>const</specifier> struct <name>blocks</name> *</type><name>blocks</name></decl></param>,
<param><decl><type><specifier>const</specifier> struct <name>adler32</name> *</type><name>rolling</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>a</name></decl></param>,
<param><decl><type><name>apr_size_t</name></type> <name>asize</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>b</name></decl></param>,
<param><decl><type><name>apr_size_t</name></type> <name>bsize</name></decl></param>,
<param><decl><type><name>apr_size_t</name></type> <name>bpos</name></decl></param>,
<param><decl><type><name>apr_size_t</name> *</type><name>aposp</name></decl></param>,
<param><decl><type><name>apr_size_t</name> *</type><name>alenp</name></decl></param>,
<param><decl><type><name>apr_size_t</name> *</type><name>badvancep</name></decl></param>,
<param><decl><type><name>apr_size_t</name> *</type><name>pending_insert_lenp</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_uint32_t</name></type> <name>sum</name> <init>= <expr><call><name>adler32_sum</name><argument_list>(<argument><expr><name>rolling</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>alen</name></decl>, <decl><type ref="prev"/><name>badvance</name></decl>, <decl><type ref="prev"/><name>apos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>tpos</name></decl>, <decl><type ref="prev"/><name>tlen</name></decl>;</decl_stmt>
<expr_stmt><expr><name>tpos</name> = <call><name>find_block</name><argument_list>(<argument><expr><name>blocks</name></expr></argument>, <argument><expr><name>sum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>tpos</name> == (<name>apr_size_t</name>)-1</expr>)</condition><then>
<return>return <expr><name>FALSE</name></expr>;</return></then></if>
<expr_stmt><expr><name>tlen</name> = ((<name>tpos</name> + <name>MATCH_BLOCKSIZE</name>) &gt;= <name>asize</name>)
? (<name>asize</name> - <name>tpos</name>) : <name>MATCH_BLOCKSIZE</name></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>a</name> + <name>tpos</name></expr></argument>, <argument><expr><name>b</name> + <name>bpos</name></expr></argument>, <argument><expr><name>tlen</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
<return>return <expr><name>FALSE</name></expr>;</return></then></if>
<expr_stmt><expr><name>apos</name> = <name>tpos</name></expr>;</expr_stmt>
<expr_stmt><expr><name>alen</name> = <name>tlen</name></expr>;</expr_stmt>
<expr_stmt><expr><name>badvance</name> = <name>tlen</name></expr>;</expr_stmt>
<while>while <condition>(<expr>(<name>apos</name> + <name>alen</name> &lt; <name>asize</name>)
&amp;&amp; (<name>bpos</name> + <name>badvance</name> &lt; <name>bsize</name>)
&amp;&amp; (<name><name>a</name><index>[<expr><name>apos</name> + <name>alen</name></expr>]</index></name> == <name><name>b</name><index>[<expr><name>bpos</name> + <name>badvance</name></expr>]</index></name>)</expr>)</condition> <block>{
<expr_stmt><expr>++<name>alen</name></expr>;</expr_stmt>
<expr_stmt><expr>++<name>badvance</name></expr>;</expr_stmt>
}</block></while>
<while>while <condition>(<expr><name>apos</name> &gt; 0
&amp;&amp; <name>bpos</name> &gt; 0
&amp;&amp; <name><name>a</name><index>[<expr><name>apos</name> - 1</expr>]</index></name> == <name><name>b</name><index>[<expr><name>bpos</name> - 1</expr>]</index></name>
&amp;&amp; *<name>pending_insert_lenp</name> &gt; 0</expr>)</condition> <block>{
<expr_stmt><expr>--(*<name>pending_insert_lenp</name>)</expr>;</expr_stmt>
<expr_stmt><expr>--<name>apos</name></expr>;</expr_stmt>
<expr_stmt><expr>--<name>bpos</name></expr>;</expr_stmt>
<expr_stmt><expr>++<name>alen</name></expr>;</expr_stmt>
}</block></while>
<expr_stmt><expr>*<name>aposp</name> = <name>apos</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>alenp</name> = <name>alen</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>badvancep</name> = <name>badvance</name></expr>;</expr_stmt>
<return>return <expr><name>TRUE</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>compute_delta</name><parameter_list>(<param><decl><type><name>svn_txdelta__ops_baton_t</name> *</type><name>build_baton</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>a</name></decl></param>,
<param><decl><type><name>apr_uint32_t</name></type> <name>asize</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>b</name></decl></param>,
<param><decl><type><name>apr_uint32_t</name></type> <name>bsize</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>blocks</name></type> <name>blocks</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>adler32</name></type> <name>rolling</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>sz</name></decl>, <decl><type ref="prev"/><name>lo</name></decl>, <decl><type ref="prev"/><name>hi</name></decl>, <decl><type ref="prev"/><name>pending_insert_start</name> <init>= <expr>0</expr></init>, <name>pending_insert_len</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>bsize</name> &lt; <name>MATCH_BLOCKSIZE</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>svn_txdelta__insert_op</name><argument_list>(<argument><expr><name>build_baton</name></expr></argument>, <argument><expr><name>svn_txdelta_new</name></expr></argument>,
<argument><expr>0</expr></argument>, <argument><expr><name>bsize</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return;</return>
}</block></then></if>
<expr_stmt><expr><call><name>init_blocks_table</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>asize</name></expr></argument>, <argument><expr>&amp;<name>blocks</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>init_adler32</name><argument_list>(<argument><expr>&amp;<name>rolling</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>MATCH_BLOCKSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>sz</name> = <name>bsize</name></expr>, <expr><name>lo</name> = 0</expr>, <expr><name>hi</name> = <name>MATCH_BLOCKSIZE</name></expr>;</init> <condition><expr><name>lo</name> &lt; <name>sz</name></expr>;</condition><incr/>) <block>{
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>apos</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>alen</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>badvance</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>next</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>match</name></decl>;</decl_stmt>
<expr_stmt><expr><name>match</name> = <call><name>find_match</name><argument_list>(<argument><expr>&amp;<name>blocks</name></expr></argument>, <argument><expr>&amp;<name>rolling</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>asize</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>bsize</name></expr></argument>, <argument><expr><name>lo</name></expr></argument>, <argument><expr>&amp;<name>apos</name></expr></argument>,
<argument><expr>&amp;<name>alen</name></expr></argument>, <argument><expr>&amp;<name>badvance</name></expr></argument>, <argument><expr>&amp;<name>pending_insert_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>! <name>match</name></expr>)</condition><then>
<expr_stmt><expr>++<name>pending_insert_len</name></expr>;</expr_stmt></then>
<else>else <block>{
<if>if <condition>(<expr><name>pending_insert_len</name> &gt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>svn_txdelta__insert_op</name><argument_list>(<argument><expr><name>build_baton</name></expr></argument>, <argument><expr><name>svn_txdelta_new</name></expr></argument>,
<argument><expr>0</expr></argument>, <argument><expr><name>pending_insert_len</name></expr></argument>,
<argument><expr><name>b</name> + <name>pending_insert_start</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>pending_insert_len</name> = 0</expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>pending_insert_start</name> = <name>lo</name> + <name>badvance</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>svn_txdelta__insert_op</name><argument_list>(<argument><expr><name>build_baton</name></expr></argument>, <argument><expr><name>svn_txdelta_source</name></expr></argument>,
<argument><expr><name>apos</name></expr></argument>, <argument><expr><name>alen</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><name>next</name> = <name>lo</name></expr>;</expr_stmt>
<for>for (<init>;</init> <condition><expr><name>next</name> &lt; <name>lo</name> + <name>badvance</name></expr>;</condition> <incr><expr>++<name>next</name></expr></incr>) <block>{
<expr_stmt><expr><call><name>adler32_out</name><argument_list>(<argument><expr>&amp;<name>rolling</name></expr></argument>, <argument><expr><name><name>b</name><index>[<expr><name>next</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>next</name> + <name>MATCH_BLOCKSIZE</name> &lt; <name>bsize</name></expr>)</condition><then>
<expr_stmt><expr><call><name>adler32_in</name><argument_list>(<argument><expr>&amp;<name>rolling</name></expr></argument>, <argument><expr><name><name>b</name><index>[<expr><name>next</name> + <name>MATCH_BLOCKSIZE</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></for>
<expr_stmt><expr><name>lo</name> = <name>next</name></expr>;</expr_stmt>
<expr_stmt><expr><name>hi</name> = <name>lo</name> + <name>MATCH_BLOCKSIZE</name></expr>;</expr_stmt>
}</block></for>
<if>if <condition>(<expr><name>pending_insert_len</name> &gt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>svn_txdelta__insert_op</name><argument_list>(<argument><expr><name>build_baton</name></expr></argument>, <argument><expr><name>svn_txdelta_new</name></expr></argument>,
<argument><expr>0</expr></argument>, <argument><expr><name>pending_insert_len</name></expr></argument>,
<argument><expr><name>b</name> + <name>pending_insert_start</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></function>
<function><type><name>void</name></type>
<name>svn_txdelta__xdelta</name><parameter_list>(<param><decl><type><name>svn_txdelta__ops_baton_t</name> *</type><name>build_baton</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name></decl></param>,
<param><decl><type><name>apr_size_t</name></type> <name>source_len</name></decl></param>,
<param><decl><type><name>apr_size_t</name></type> <name>target_len</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>source_len</name> != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>compute_delta</name><argument_list>(<argument><expr><name>build_baton</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>source_len</name></expr></argument>,
<argument><expr><name>data</name> + <name>source_len</name></expr></argument>, <argument><expr><name>target_len</name></expr></argument>,
<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
</unit>
