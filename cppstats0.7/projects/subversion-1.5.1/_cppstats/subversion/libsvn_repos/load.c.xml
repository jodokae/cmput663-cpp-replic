<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/subversion-1.5.1/_cppstats/subversion/libsvn_repos/load.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_private_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_pools.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_error.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_fs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_repos.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_string.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_path.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_props.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"repos.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_private_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_mergeinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_md5.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_lib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"private/svn_mergeinfo_private.h"</cpp:file></cpp:include>
<struct>struct <name>parse_baton</name> <block>{
<decl_stmt><decl><type><name>svn_repos_t</name> *</type><name>repos</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>use_history</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>use_pre_commit_hook</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>use_post_commit_hook</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>outstream</name></decl>;</decl_stmt>
<enum>enum <name>svn_repos_load_uuid</name> <name>uuid_action</name>;</enum>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>parent_dir</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>rev_map</name></decl>;</decl_stmt>
}</block>;</struct>
<struct>struct <name>revision_baton</name> <block>{
<decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_fs_txn_t</name> *</type><name>txn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>txn_root</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>datestamp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_int32_t</name></type> <name>rev_offset</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>parse_baton</name> *</type><name>pb</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>
}</block>;</struct>
<struct>struct <name>node_baton</name> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>
<enum>enum <name>svn_node_action</name> <name>action</name>;</enum>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>base_checksum</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>result_checksum</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copy_source_checksum</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>copyfrom_rev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copyfrom_path</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>revision_baton</name> *</type><name>rb</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>
}</block>;</struct>
<function><type><specifier>static</specifier> <name>svn_repos_parse_fns2_t</name> *</type>
<name>fns2_from_fns</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>svn_repos_parser_fns_t</name> *</type><name>fns</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>svn_repos_parse_fns2_t</name> *</type><name>fns2</name></decl>;</decl_stmt>
<expr_stmt><expr><name>fns2</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>fns2</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fns2</name>-&gt;<name>new_revision_record</name></name> = <name><name>fns</name>-&gt;<name>new_revision_record</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fns2</name>-&gt;<name>uuid_record</name></name> = <name><name>fns</name>-&gt;<name>uuid_record</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fns2</name>-&gt;<name>new_node_record</name></name> = <name><name>fns</name>-&gt;<name>new_node_record</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fns2</name>-&gt;<name>set_revision_property</name></name> = <name><name>fns</name>-&gt;<name>set_revision_property</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fns2</name>-&gt;<name>set_node_property</name></name> = <name><name>fns</name>-&gt;<name>set_node_property</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fns2</name>-&gt;<name>remove_node_props</name></name> = <name><name>fns</name>-&gt;<name>remove_node_props</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fns2</name>-&gt;<name>set_fulltext</name></name> = <name><name>fns</name>-&gt;<name>set_fulltext</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fns2</name>-&gt;<name>close_node</name></name> = <name><name>fns</name>-&gt;<name>close_node</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fns2</name>-&gt;<name>close_revision</name></name> = <name><name>fns</name>-&gt;<name>close_revision</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fns2</name>-&gt;<name>delete_node_property</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fns2</name>-&gt;<name>apply_textdelta</name></name> = <name>NULL</name></expr>;</expr_stmt>
<return>return <expr><name>fns2</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>stream_ran_dry</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_INCOMPLETE_DATA</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr>"Premature end of content data in dumpstream"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>stream_malformed</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_STREAM_MALFORMED_DATA</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr>"Dumpstream data appears to be malformed"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>read_header_block</name><parameter_list>(<param><decl><type><name>svn_stream_t</name> *</type><name>stream</name></decl></param>,
<param><decl><type><name>svn_stringbuf_t</name> *</type><name>first_header</name></decl></param>,
<param><decl><type><name>apr_hash_t</name> **</type><name>headers</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr>*<name>headers</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr>1</expr>)</condition> <block>{
<decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>header_str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl>, *<decl><type ref="prev"/><name>value</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>eof</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>first_header</name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>header_str</name> = <name>first_header</name></expr>;</expr_stmt>
<expr_stmt><expr><name>first_header</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>eof</name> = <name>FALSE</name></expr>;</expr_stmt>
}</block></then>
<else>else
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_readline</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr>&amp;<name>header_str</name></expr></argument>, <argument><expr>"\n"</expr></argument>, <argument><expr>&amp;<name>eof</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<if>if <condition>(<expr><call><name>svn_stringbuf_isempty</name><argument_list>(<argument><expr><name>header_str</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<break>break;</break></then>
<else>else <if>if <condition>(<expr><name>eof</name></expr>)</condition><then>
<return>return <expr><call><name>stream_ran_dry</name><argument_list>()</argument_list></call></expr>;</return></then></if></else></if>
<while>while <condition>(<expr><name><name>header_str</name>-&gt;<name>data</name><index>[<expr><name>i</name></expr>]</index></name> != ':'</expr>)</condition> <block>{
<if>if <condition>(<expr><name><name>header_str</name>-&gt;<name>data</name><index>[<expr><name>i</name></expr>]</index></name> == '\0'</expr>)</condition><then>
<return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_STREAM_MALFORMED_DATA</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr>"Dump stream contains a malformed "
"header (with no ':') at '%.20s'"</expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>header_str</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
}</block></while>
<expr_stmt><expr><name><name>header_str</name>-&gt;<name>data</name><index>[<expr><name>i</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
<expr_stmt><expr><name>name</name> = <name><name>header_str</name>-&gt;<name>data</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> += 2</expr>;</expr_stmt>
<if>if <condition>(<expr><name>i</name> &gt; <name><name>header_str</name>-&gt;<name>len</name></name></expr>)</condition><then>
<return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_STREAM_MALFORMED_DATA</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr>"Dump stream contains a malformed "
"header (with no value) at '%.20s'"</expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>header_str</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>value</name> = <name><name>header_str</name>-&gt;<name>data</name></name> + <name>i</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr>*<name>headers</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></while>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>read_key_or_val</name><parameter_list>(<param><decl><type><name>char</name> **</type><name>pbuf</name></decl></param>,
<param><decl><type><name>svn_filesize_t</name> *</type><name>actual_length</name></decl></param>,
<param><decl><type><name>svn_stream_t</name> *</type><name>stream</name></decl></param>,
<param><decl><type><name>apr_size_t</name></type> <name>len</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>buf</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>len</name> + 1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>numread</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>
<expr_stmt><expr><name>numread</name> = <name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_read</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr>&amp;<name>numread</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>actual_length</name> += <name>numread</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>numread</name> != <name>len</name></expr>)</condition><then>
<return>return <expr><call><name>stream_ran_dry</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name><name>buf</name><index>[<expr><name>len</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
<expr_stmt><expr><name>numread</name> = 1</expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_read</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr>&amp;<name>c</name></expr></argument>, <argument><expr>&amp;<name>numread</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>actual_length</name> += <name>numread</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>numread</name> != 1</expr>)</condition><then>
<return>return <expr><call><name>stream_ran_dry</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><name>c</name> != '\n'</expr>)</condition><then>
<return>return <expr><call><name>stream_malformed</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr>*<name>pbuf</name> = <name>buf</name></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>prefix_mergeinfo_paths</name><parameter_list>(<param><decl><type><name>svn_string_t</name> **</type><name>mergeinfo_val</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>mergeinfo_orig</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>parent_dir</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>prefixed_mergeinfo</name></decl>, *<decl><type ref="prev"/><name>mergeinfo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> *</type><name>rangelist</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo_parse</name><argument_list>(<argument><expr>&amp;<name>mergeinfo</name></expr></argument>, <argument><expr><name><name>mergeinfo_orig</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>prefixed_mergeinfo</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>mergeinfo</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>hi</name></expr>;</condition> <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>) <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>merge_source</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>merge_source</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>rangelist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>path</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>parent_dir</name></expr></argument>, <argument><expr>(const <name>char</name>*)<name>merge_source</name>+1</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>prefixed_mergeinfo</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>rangelist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo_to_string</name><argument_list>(<argument><expr><name>mergeinfo_val</name></expr></argument>, <argument><expr><name>prefixed_mergeinfo</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>renumber_mergeinfo_revs</name><parameter_list>(<param><decl><type><name>svn_string_t</name> **</type><name>final_val</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>initial_val</name></decl></param>,
<param><decl><type>struct <name>revision_baton</name> *</type><name>rb</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>mergeinfo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>final_mergeinfo</name> <init>= <expr><call><name>apr_hash_make</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo_parse</name><argument_list>(<argument><expr>&amp;<name>mergeinfo</name></expr></argument>, <argument><expr><name><name>initial_val</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>mergeinfo</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>hi</name></expr>;</condition> <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>) <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>merge_source</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>rangelist</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>parse_baton</name> *</type><name>pb</name> <init>= <expr><name><name>rb</name>-&gt;<name>pb</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>merge_source</name> = (const <name>char</name> *) <name>key</name></expr>;</expr_stmt>
<expr_stmt><expr><name>rangelist</name> = (<name>apr_array_header_t</name> *) <name>val</name></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>rangelist</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>svn_revnum_t</name> *</type><name>rev_from_map</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_merge_range_t</name> *</type><name>range</name> <init>= <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>rangelist</name></expr></argument>, <argument><expr><name>i</name></expr></argument>,
<argument><expr><name>svn_merge_range_t</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>rev_from_map</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name><name>pb</name>-&gt;<name>rev_map</name></name></expr></argument>, <argument><expr>&amp;<name><name>range</name>-&gt;<name>start</name></name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>svn_revnum_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rev_from_map</name> &amp;&amp; <call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr>*<name>rev_from_map</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name><name>range</name>-&gt;<name>start</name></name> = *<name>rev_from_map</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>rev_from_map</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name><name>pb</name>-&gt;<name>rev_map</name></name></expr></argument>, <argument><expr>&amp;<name><name>range</name>-&gt;<name>end</name></name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>svn_revnum_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rev_from_map</name> &amp;&amp; <call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr>*<name>rev_from_map</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name><name>range</name>-&gt;<name>end</name></name> = *<name>rev_from_map</name></expr>;</expr_stmt></then></if>
}</block></for>
<expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>final_mergeinfo</name></expr></argument>, <argument><expr><name>merge_source</name></expr></argument>,
<argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>rangelist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo_sort</name><argument_list>(<argument><expr><name>final_mergeinfo</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo_to_string</name><argument_list>(<argument><expr><name>final_val</name></expr></argument>, <argument><expr><name>final_mergeinfo</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>parse_property_block</name><parameter_list>(<param><decl><type><name>svn_stream_t</name> *</type><name>stream</name></decl></param>,
<param><decl><type><name>svn_filesize_t</name></type> <name>content_length</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>svn_repos_parse_fns2_t</name> *</type><name>parse_fns</name></decl></param>,
<param><decl><type><name>void</name> *</type><name>record_baton</name></decl></param>,
<param><decl><type><name>svn_boolean_t</name></type> <name>is_node</name></decl></param>,
<param><decl><type><name>svn_filesize_t</name> *</type><name>actual_length</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>strbuf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>proppool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr>*<name>actual_length</name> = 0</expr>;</expr_stmt>
<while>while <condition>(<expr><name>content_length</name> != *<name>actual_length</name></expr>)</condition> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>eof</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>proppool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_readline</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr>&amp;<name>strbuf</name></expr></argument>, <argument><expr>"\n"</expr></argument>, <argument><expr>&amp;<name>eof</name></expr></argument>, <argument><expr><name>proppool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>eof</name></expr>)</condition><then> <block>{
<return>return <expr><call><name>svn_error_create</name>
<argument_list>(<argument><expr><name>SVN_ERR_STREAM_MALFORMED_DATA</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr>"Incomplete or unterminated property block"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<expr_stmt><expr>*<name>actual_length</name> += (<name><name>strbuf</name>-&gt;<name>len</name></name> + 1)</expr>;</expr_stmt>
<expr_stmt><expr><name>buf</name> = <name><name>strbuf</name>-&gt;<name>data</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr>! <call><name>strcmp</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>"PROPS-END"</expr></argument>)</argument_list></call></expr>)</condition><then>
<break>break;</break></then>
<else>else <if>if <condition>(<expr>(<name><name>buf</name><index>[<expr>0</expr>]</index></name> == 'K') &amp;&amp; (<name><name>buf</name><index>[<expr>1</expr>]</index></name> == ' ')</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>keybuf</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>read_key_or_val</name><argument_list>(<argument><expr>&amp;<name>keybuf</name></expr></argument>, <argument><expr><name>actual_length</name></expr></argument>,
<argument><expr><name>stream</name></expr></argument>, <argument><expr><call><name>atoi</name><argument_list>(<argument><expr><name>buf</name> + 2</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>proppool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_readline</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr>&amp;<name>strbuf</name></expr></argument>, <argument><expr>"\n"</expr></argument>, <argument><expr>&amp;<name>eof</name></expr></argument>, <argument><expr><name>proppool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>eof</name></expr>)</condition><then>
<return>return <expr><call><name>stream_ran_dry</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr>*<name>actual_length</name> += (<name><name>strbuf</name>-&gt;<name>len</name></name> + 1)</expr>;</expr_stmt>
<expr_stmt><expr><name>buf</name> = <name><name>strbuf</name>-&gt;<name>data</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr>(<name><name>buf</name><index>[<expr>0</expr>]</index></name> == 'V') &amp;&amp; (<name><name>buf</name><index>[<expr>1</expr>]</index></name> == ' ')</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>svn_string_t</name></type> <name>propstring</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>valbuf</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>propstring</name>.<name>len</name></name> = <call><name>atoi</name><argument_list>(<argument><expr><name>buf</name> + 2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>read_key_or_val</name><argument_list>(<argument><expr>&amp;<name>valbuf</name></expr></argument>, <argument><expr><name>actual_length</name></expr></argument>,
<argument><expr><name>stream</name></expr></argument>, <argument><expr><name><name>propstring</name>.<name>len</name></name></expr></argument>, <argument><expr><name>proppool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>propstring</name>.<name>data</name></name> = <name>valbuf</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>is_node</name></expr>)</condition><then>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>parse_fns</name>-&gt;<name>set_node_property</name></name><argument_list>(<argument><expr><name>record_baton</name></expr></argument>,
<argument><expr><name>keybuf</name></expr></argument>,
<argument><expr>&amp;<name>propstring</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>parse_fns</name>-&gt;<name>set_revision_property</name></name><argument_list>(<argument><expr><name>record_baton</name></expr></argument>,
<argument><expr><name>keybuf</name></expr></argument>,
<argument><expr>&amp;<name>propstring</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
}</block></then> <else>else
<return>return <expr><call><name>stream_malformed</name><argument_list>()</argument_list></call></expr>;</return></else></if>
}</block></then> <else>else <if>if <condition>(<expr>(<name><name>buf</name><index>[<expr>0</expr>]</index></name> == 'D') &amp;&amp; (<name><name>buf</name><index>[<expr>1</expr>]</index></name> == ' ')</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>keybuf</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>read_key_or_val</name><argument_list>(<argument><expr>&amp;<name>keybuf</name></expr></argument>, <argument><expr><name>actual_length</name></expr></argument>,
<argument><expr><name>stream</name></expr></argument>, <argument><expr><call><name>atoi</name><argument_list>(<argument><expr><name>buf</name> + 2</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>proppool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>is_node</name> || !<name><name>parse_fns</name>-&gt;<name>delete_node_property</name></name></expr>)</condition><then>
<return>return <expr><call><name>stream_malformed</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>parse_fns</name>-&gt;<name>delete_node_property</name></name><argument_list>(<argument><expr><name>record_baton</name></expr></argument>, <argument><expr><name>keybuf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else
<return>return <expr><call><name>stream_malformed</name><argument_list>()</argument_list></call></expr>;</return></else></if></else></if></else></if>
}</block></while>
<expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>proppool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>parse_text_block</name><parameter_list>(<param><decl><type><name>svn_stream_t</name> *</type><name>stream</name></decl></param>,
<param><decl><type><name>svn_filesize_t</name></type> <name>content_length</name></decl></param>,
<param><decl><type><name>svn_boolean_t</name></type> <name>is_delta</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>svn_repos_parse_fns2_t</name> *</type><name>parse_fns</name></decl></param>,
<param><decl><type><name>void</name> *</type><name>record_baton</name></decl></param>,
<param><decl><type><name>char</name> *</type><name>buffer</name></decl></param>,
<param><decl><type><name>apr_size_t</name></type> <name>buflen</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>text_stream</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>num_to_read</name></decl>, <decl><type ref="prev"/><name>rlen</name></decl>, <decl><type ref="prev"/><name>wlen</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>is_delta</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>svn_txdelta_window_handler_t</name></type> <name>wh</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> *</type><name>whb</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>parse_fns</name>-&gt;<name>apply_textdelta</name></name><argument_list>(<argument><expr>&amp;<name>wh</name></expr></argument>, <argument><expr>&amp;<name>whb</name></expr></argument>, <argument><expr><name>record_baton</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>wh</name></expr>)</condition><then>
<expr_stmt><expr><name>text_stream</name> = <call><name>svn_txdelta_parse_svndiff</name><argument_list>(<argument><expr><name>wh</name></expr></argument>, <argument><expr><name>whb</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>parse_fns</name>-&gt;<name>set_fulltext</name></name><argument_list>(<argument><expr>&amp;<name>text_stream</name></expr></argument>, <argument><expr><name>record_baton</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<if>if <condition>(<expr><name>content_length</name> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>wlen</name> = 0</expr>;</expr_stmt>
<if>if <condition>(<expr><name>text_stream</name></expr>)</condition><then>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_write</name><argument_list>(<argument><expr><name>text_stream</name></expr></argument>, <argument><expr>""</expr></argument>, <argument><expr>&amp;<name>wlen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></then></if>
<while>while <condition>(<expr><name>content_length</name></expr>)</condition> <block>{
<if>if <condition>(<expr><name>content_length</name> &gt;= <name>buflen</name></expr>)</condition><then>
<expr_stmt><expr><name>rlen</name> = <name>buflen</name></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>rlen</name> = (<name>apr_size_t</name>) <name>content_length</name></expr>;</expr_stmt></else></if>
<expr_stmt><expr><name>num_to_read</name> = <name>rlen</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_read</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr>&amp;<name>rlen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>content_length</name> -= <name>rlen</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rlen</name> != <name>num_to_read</name></expr>)</condition><then>
<return>return <expr><call><name>stream_ran_dry</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><name>text_stream</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>wlen</name> = <name>rlen</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_write</name><argument_list>(<argument><expr><name>text_stream</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr>&amp;<name>wlen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>wlen</name> != <name>rlen</name></expr>)</condition><then> <block>{
<return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_STREAM_UNEXPECTED_EOF</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr>"Unexpected EOF writing contents"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
}</block></then></if>
}</block></while>
<if>if <condition>(<expr><name>text_stream</name></expr>)</condition><then>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_close</name><argument_list>(<argument><expr><name>text_stream</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>parse_format_version</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>versionstring</name></decl></param>, <param><decl><type><name>int</name> *</type><name>version</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name>magic_len</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>SVN_REPOS_DUMPFILE_MAGIC_HEADER</name></expr></argument>)</argument_list></sizeof> - 1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>versionstring</name></expr></argument>, <argument><expr>':'</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>value</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>p</name> == <name>NULL</name>
|| <name>p</name> != (<name>versionstring</name> + <name>magic_len</name>)
|| <call><name>strncmp</name><argument_list>(<argument><expr><name>versionstring</name></expr></argument>,
<argument><expr><name>SVN_REPOS_DUMPFILE_MAGIC_HEADER</name></expr></argument>,
<argument><expr><name>magic_len</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_STREAM_MALFORMED_DATA</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr>"Malformed dumpfile header"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>value</name> = <call><name>atoi</name><argument_list>(<argument><expr><name>p</name>+1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>value</name> &gt; <name>SVN_REPOS_DUMPFILE_FORMAT_VERSION</name></expr>)</condition><then>
<return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_STREAM_MALFORMED_DATA</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr>"Unsupported dumpfile version: %d"</expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr>*<name>version</name> = <name>value</name></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><name>svn_error_t</name> *</type>
<name>svn_repos_parse_dumpstream2</name><parameter_list>(<param><decl><type><name>svn_stream_t</name> *</type><name>stream</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>svn_repos_parse_fns2_t</name> *</type><name>parse_fns</name></decl></param>,
<param><decl><type><name>void</name> *</type><name>parse_baton</name></decl></param>,
<param><decl><type><name>svn_cancel_func_t</name></type> <name>cancel_func</name></decl></param>,
<param><decl><type><name>void</name> *</type><name>cancel_baton</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>eof</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>linebuf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> *</type><name>rev_baton</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>buffer</name> <init>= <expr><call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>SVN__STREAM_CHUNK_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>buflen</name> <init>= <expr><name>SVN__STREAM_CHUNK_SIZE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>linepool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>revpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>nodepool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>version</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_readline</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr>&amp;<name>linebuf</name></expr></argument>, <argument><expr>"\n"</expr></argument>, <argument><expr>&amp;<name>eof</name></expr></argument>, <argument><expr><name>linepool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>eof</name></expr>)</condition><then>
<return>return <expr><call><name>stream_ran_dry</name><argument_list>()</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>parse_format_version</name><argument_list>(<argument><expr><name><name>linebuf</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr>&amp;<name>version</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>version</name> == <name>SVN_REPOS_DUMPFILE_FORMAT_VERSION</name>
&amp;&amp; (!<name><name>parse_fns</name>-&gt;<name>delete_node_property</name></name> || !<name><name>parse_fns</name>-&gt;<name>apply_textdelta</name></name>)</expr>)</condition><then>
<return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_STREAM_MALFORMED_DATA</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr>"Unsupported dumpfile version: %d"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<while>while <condition>(<expr>1</expr>)</condition> <block>{
<decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>headers</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> *</type><name>node_baton</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>found_node</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>old_v1_with_cl</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>content_length</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>prop_cl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>text_cl</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>value</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_filesize_t</name></type> <name>actual_prop_length</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>linepool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>cancel_func</name></expr>)</condition><then>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>cancel_func</name><argument_list>(<argument><expr><name>cancel_baton</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_readline</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr>&amp;<name>linebuf</name></expr></argument>, <argument><expr>"\n"</expr></argument>, <argument><expr>&amp;<name>eof</name></expr></argument>, <argument><expr><name>linepool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>eof</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>svn_stringbuf_isempty</name><argument_list>(<argument><expr><name>linebuf</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<break>break;</break></then>
<else>else
<return>return <expr><call><name>stream_ran_dry</name><argument_list>()</argument_list></call></expr>;</return></else></if>
}</block></then></if>
<if>if <condition>(<expr>(<name><name>linebuf</name>-&gt;<name>len</name></name> == 0) || (<call><name>apr_isspace</name><argument_list>(<argument><expr><name><name>linebuf</name>-&gt;<name>data</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
<continue>continue;</continue></then></if>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>read_header_block</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><name>linebuf</name></expr></argument>, <argument><expr>&amp;<name>headers</name></expr></argument>, <argument><expr><name>linepool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>apr_hash_get</name><argument_list>(<argument><expr><name>headers</name></expr></argument>, <argument><expr><name>SVN_REPOS_DUMPFILE_REVISION_NUMBER</name></expr></argument>,
<argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>rev_baton</name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>parse_fns</name>-&gt;<name>close_revision</name></name><argument_list>(<argument><expr><name>rev_baton</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>revpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>parse_fns</name>-&gt;<name>new_revision_record</name></name><argument_list>(<argument><expr>&amp;<name>rev_baton</name></expr></argument>,
<argument><expr><name>headers</name></expr></argument>, <argument><expr><name>parse_baton</name></expr></argument>,
<argument><expr><name>revpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then>
<else>else <if>if <condition>(<expr><call><name>apr_hash_get</name><argument_list>(<argument><expr><name>headers</name></expr></argument>, <argument><expr><name>SVN_REPOS_DUMPFILE_NODE_PATH</name></expr></argument>,
<argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>parse_fns</name>-&gt;<name>new_node_record</name></name><argument_list>(<argument><expr>&amp;<name>node_baton</name></expr></argument>,
<argument><expr><name>headers</name></expr></argument>,
<argument><expr><name>rev_baton</name></expr></argument>,
<argument><expr><name>nodepool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>found_node</name> = <name>TRUE</name></expr>;</expr_stmt>
}</block></then>
<else>else <if>if <condition>(<expr>(<name>value</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>headers</name></expr></argument>, <argument><expr><name>SVN_REPOS_DUMPFILE_UUID</name></expr></argument>,
<argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>parse_fns</name>-&gt;<name>uuid_record</name></name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>parse_baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then>
<else>else <if>if <condition>(<expr>(<name>value</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>headers</name></expr></argument>,
<argument><expr><name>SVN_REPOS_DUMPFILE_MAGIC_HEADER</name></expr></argument>,
<argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
<expr_stmt><expr><name>version</name> = <call><name>atoi</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then>
<else>else <block>{
<return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_STREAM_MALFORMED_DATA</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr>"Unrecognized record type in stream"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></else></if></else></if></else></if></else></if>
<expr_stmt><expr><name>content_length</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>headers</name></expr></argument>,
<argument><expr><name>SVN_REPOS_DUMPFILE_CONTENT_LENGTH</name></expr></argument>,
<argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>prop_cl</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>headers</name></expr></argument>,
<argument><expr><name>SVN_REPOS_DUMPFILE_PROP_CONTENT_LENGTH</name></expr></argument>,
<argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>text_cl</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>headers</name></expr></argument>,
<argument><expr><name>SVN_REPOS_DUMPFILE_TEXT_CONTENT_LENGTH</name></expr></argument>,
<argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>old_v1_with_cl</name> =
<name>version</name> == 1 &amp;&amp; <name>content_length</name> &amp;&amp; ! <name>prop_cl</name> &amp;&amp; ! <name>text_cl</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>prop_cl</name> || <name>old_v1_with_cl</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>delta</name> <init>= <expr><call><name>apr_hash_get</name><argument_list>(<argument><expr><name>headers</name></expr></argument>,
<argument><expr><name>SVN_REPOS_DUMPFILE_PROP_DELTA</name></expr></argument>,
<argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>is_delta</name> <init>= <expr>(<name>delta</name> &amp;&amp; <call><name>strcmp</name><argument_list>(<argument><expr><name>delta</name></expr></argument>, <argument><expr>"true"</expr></argument>)</argument_list></call> == 0)</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>found_node</name> &amp;&amp; !<name>is_delta</name></expr>)</condition><then>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>parse_fns</name>-&gt;<name>remove_node_props</name></name><argument_list>(<argument><expr><name>node_baton</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>parse_property_block</name>
<argument_list>(<argument><expr><name>stream</name></expr></argument>,
<argument><expr><call><name>svn__atoui64</name><argument_list>(<argument><expr><name>prop_cl</name> ? <name>prop_cl</name> : <name>content_length</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>parse_fns</name></expr></argument>,
<argument><expr><name>found_node</name> ? <name>node_baton</name> : <name>rev_baton</name></expr></argument>,
<argument><expr><name>found_node</name></expr></argument>,
<argument><expr>&amp;<name>actual_prop_length</name></expr></argument>,
<argument><expr><name>found_node</name> ? <name>nodepool</name> : <name>revpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>text_cl</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>delta</name> <init>= <expr><call><name>apr_hash_get</name><argument_list>(<argument><expr><name>headers</name></expr></argument>,
<argument><expr><name>SVN_REPOS_DUMPFILE_TEXT_DELTA</name></expr></argument>,
<argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>is_delta</name> <init>= <expr>(<name>delta</name> &amp;&amp; <call><name>strcmp</name><argument_list>(<argument><expr><name>delta</name></expr></argument>, <argument><expr>"true"</expr></argument>)</argument_list></call> == 0)</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>parse_text_block</name><argument_list>(<argument><expr><name>stream</name></expr></argument>,
<argument><expr><call><name>svn__atoui64</name><argument_list>(<argument><expr><name>text_cl</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>is_delta</name></expr></argument>,
<argument><expr><name>parse_fns</name></expr></argument>,
<argument><expr><name>found_node</name> ? <name>node_baton</name> : <name>rev_baton</name></expr></argument>,
<argument><expr><name>buffer</name></expr></argument>,
<argument><expr><name>buflen</name></expr></argument>,
<argument><expr><name>found_node</name> ? <name>nodepool</name> : <name>revpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>old_v1_with_cl</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>node_kind</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_filesize_t</name></type> <name>cl_value</name> <init>= <expr><call><name>svn__atoui64</name><argument_list>(<argument><expr><name>content_length</name></expr></argument>)</argument_list></call>
- <name>actual_prop_length</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>cl_value</name> ||
((<name>node_kind</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>headers</name></expr></argument>,
<argument><expr><name>SVN_REPOS_DUMPFILE_NODE_KIND</name></expr></argument>,
<argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call>)
&amp;&amp; <call><name>strcmp</name><argument_list>(<argument><expr><name>node_kind</name></expr></argument>, <argument><expr>"file"</expr></argument>)</argument_list></call> == 0)</expr>
)</condition><then>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>parse_text_block</name><argument_list>(<argument><expr><name>stream</name></expr></argument>,
<argument><expr><name>cl_value</name></expr></argument>,
<argument><expr><name>FALSE</name></expr></argument>,
<argument><expr><name>parse_fns</name></expr></argument>,
<argument><expr><name>found_node</name> ? <name>node_baton</name> : <name>rev_baton</name></expr></argument>,
<argument><expr><name>buffer</name></expr></argument>,
<argument><expr><name>buflen</name></expr></argument>,
<argument><expr><name>found_node</name> ? <name>nodepool</name> : <name>revpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></then></if></else></if>
<if>if <condition>(<expr><name>content_length</name> &amp;&amp; ! <name>old_v1_with_cl</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>rlen</name></decl>, <decl><type ref="prev"/><name>num_to_read</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_filesize_t</name></type> <name>remaining</name> <init>=
<expr><call><name>svn__atoui64</name><argument_list>(<argument><expr><name>content_length</name></expr></argument>)</argument_list></call> -
(<name>prop_cl</name> ? <call><name>svn__atoui64</name><argument_list>(<argument><expr><name>prop_cl</name></expr></argument>)</argument_list></call> : 0) -
(<name>text_cl</name> ? <call><name>svn__atoui64</name><argument_list>(<argument><expr><name>text_cl</name></expr></argument>)</argument_list></call> : 0)</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>remaining</name> &lt; 0</expr>)</condition><then>
<return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_STREAM_MALFORMED_DATA</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr>"Sum of subblock sizes larger than "
"total block content length"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
<while>while <condition>(<expr><name>remaining</name> &gt; 0</expr>)</condition> <block>{
<if>if <condition>(<expr><name>remaining</name> &gt;= <name>buflen</name></expr>)</condition><then>
<expr_stmt><expr><name>rlen</name> = <name>buflen</name></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>rlen</name> = (<name>apr_size_t</name>) <name>remaining</name></expr>;</expr_stmt></else></if>
<expr_stmt><expr><name>num_to_read</name> = <name>rlen</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_read</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr>&amp;<name>rlen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>remaining</name> -= <name>rlen</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rlen</name> != <name>num_to_read</name></expr>)</condition><then>
<return>return <expr><call><name>stream_ran_dry</name><argument_list>()</argument_list></call></expr>;</return></then></if>
}</block></while>
}</block></then></if>
<if>if <condition>(<expr><name>found_node</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>parse_fns</name>-&gt;<name>close_node</name></name><argument_list>(<argument><expr><name>node_baton</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>nodepool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></while>
<if>if <condition>(<expr><name>rev_baton</name> != <name>NULL</name></expr>)</condition><then>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>parse_fns</name>-&gt;<name>close_revision</name></name><argument_list>(<argument><expr><name>rev_baton</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>linepool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>revpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>nodepool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><name>svn_error_t</name> *</type>
<name>svn_repos_parse_dumpstream</name><parameter_list>(<param><decl><type><name>svn_stream_t</name> *</type><name>stream</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>svn_repos_parser_fns_t</name> *</type><name>parse_fns</name></decl></param>,
<param><decl><type><name>void</name> *</type><name>parse_baton</name></decl></param>,
<param><decl><type><name>svn_cancel_func_t</name></type> <name>cancel_func</name></decl></param>,
<param><decl><type><name>void</name> *</type><name>cancel_baton</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>svn_repos_parse_fns2_t</name> *</type><name>fns2</name> <init>= <expr><call><name>fns2_from_fns</name><argument_list>(<argument><expr><name>parse_fns</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>svn_repos_parse_dumpstream2</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><name>fns2</name></expr></argument>, <argument><expr><name>parse_baton</name></expr></argument>,
<argument><expr><name>cancel_func</name></expr></argument>, <argument><expr><name>cancel_baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> struct <name>node_baton</name> *</type>
<name>make_node_baton</name><parameter_list>(<param><decl><type><name>apr_hash_t</name> *</type><name>headers</name></decl></param>,
<param><decl><type>struct <name>revision_baton</name> *</type><name>rb</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>node_baton</name> *</type><name>nb</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>nb</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>val</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>nb</name>-&gt;<name>rb</name></name> = <name>rb</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>nb</name>-&gt;<name>pool</name></name> = <name>pool</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>nb</name>-&gt;<name>kind</name></name> = <name>svn_node_unknown</name></expr>;</expr_stmt>
<if>if <condition>(<expr>(<name>val</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>headers</name></expr></argument>, <argument><expr><name>SVN_REPOS_DUMPFILE_NODE_PATH</name></expr></argument>,
<argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>rb</name>-&gt;<name>pb</name>-&gt;<name>parent_dir</name></name></expr>)</condition><then>
<expr_stmt><expr><name><name>nb</name>-&gt;<name>path</name></name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name><name>rb</name>-&gt;<name>pb</name>-&gt;<name>parent_dir</name></name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name><name>nb</name>-&gt;<name>path</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
}</block></then></if>
<if>if <condition>(<expr>(<name>val</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>headers</name></expr></argument>, <argument><expr><name>SVN_REPOS_DUMPFILE_NODE_KIND</name></expr></argument>,
<argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
<if>if <condition>(<expr>! <call><name>strcmp</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr>"file"</expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name><name>nb</name>-&gt;<name>kind</name></name> = <name>svn_node_file</name></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr>! <call><name>strcmp</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr>"dir"</expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name><name>nb</name>-&gt;<name>kind</name></name> = <name>svn_node_dir</name></expr>;</expr_stmt></then></if></else></if>
}</block></then></if>
<expr_stmt><expr><name><name>nb</name>-&gt;<name>action</name></name> = (enum <name>svn_node_action</name>)(-1)</expr>;</expr_stmt>
<if>if <condition>(<expr>(<name>val</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>headers</name></expr></argument>, <argument><expr><name>SVN_REPOS_DUMPFILE_NODE_ACTION</name></expr></argument>,
<argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
<if>if <condition>(<expr>! <call><name>strcmp</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr>"change"</expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name><name>nb</name>-&gt;<name>action</name></name> = <name>svn_node_action_change</name></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr>! <call><name>strcmp</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr>"add"</expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name><name>nb</name>-&gt;<name>action</name></name> = <name>svn_node_action_add</name></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr>! <call><name>strcmp</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr>"delete"</expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name><name>nb</name>-&gt;<name>action</name></name> = <name>svn_node_action_delete</name></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr>! <call><name>strcmp</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr>"replace"</expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name><name>nb</name>-&gt;<name>action</name></name> = <name>svn_node_action_replace</name></expr>;</expr_stmt></then></if></else></if></else></if></else></if>
}</block></then></if>
<expr_stmt><expr><name><name>nb</name>-&gt;<name>copyfrom_rev</name></name> = <name>SVN_INVALID_REVNUM</name></expr>;</expr_stmt>
<if>if <condition>(<expr>(<name>val</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>headers</name></expr></argument>, <argument><expr><name>SVN_REPOS_DUMPFILE_NODE_COPYFROM_REV</name></expr></argument>,
<argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>nb</name>-&gt;<name>copyfrom_rev</name></name> = (<name>svn_revnum_t</name>) <call><name>atoi</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr>(<name>val</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>headers</name></expr></argument>, <argument><expr><name>SVN_REPOS_DUMPFILE_NODE_COPYFROM_PATH</name></expr></argument>,
<argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>rb</name>-&gt;<name>pb</name>-&gt;<name>parent_dir</name></name></expr>)</condition><then>
<expr_stmt><expr><name><name>nb</name>-&gt;<name>copyfrom_path</name></name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name><name>rb</name>-&gt;<name>pb</name>-&gt;<name>parent_dir</name></name></expr></argument>,
<argument><expr>(*<name>val</name> == '/' ? <name>val</name> + 1 : <name>val</name>)</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name><name>nb</name>-&gt;<name>copyfrom_path</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
}</block></then></if>
<if>if <condition>(<expr>(<name>val</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>headers</name></expr></argument>, <argument><expr><name>SVN_REPOS_DUMPFILE_TEXT_CONTENT_CHECKSUM</name></expr></argument>,
<argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>nb</name>-&gt;<name>result_checksum</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr>(<name>val</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>headers</name></expr></argument>, <argument><expr><name>SVN_REPOS_DUMPFILE_TEXT_DELTA_BASE_CHECKSUM</name></expr></argument>,
<argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>nb</name>-&gt;<name>base_checksum</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr>(<name>val</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>headers</name></expr></argument>, <argument><expr><name>SVN_REPOS_DUMPFILE_TEXT_COPY_SOURCE_CHECKSUM</name></expr></argument>,
<argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>nb</name>-&gt;<name>copy_source_checksum</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>nb</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> struct <name>revision_baton</name> *</type>
<name>make_revision_baton</name><parameter_list>(<param><decl><type><name>apr_hash_t</name> *</type><name>headers</name></decl></param>,
<param><decl><type>struct <name>parse_baton</name> *</type><name>pb</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>revision_baton</name> *</type><name>rb</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>rb</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>val</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>rb</name>-&gt;<name>pb</name></name> = <name>pb</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rb</name>-&gt;<name>pool</name></name> = <name>pool</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rb</name>-&gt;<name>rev</name></name> = <name>SVN_INVALID_REVNUM</name></expr>;</expr_stmt>
<if>if <condition>(<expr>(<name>val</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>headers</name></expr></argument>, <argument><expr><name>SVN_REPOS_DUMPFILE_REVISION_NUMBER</name></expr></argument>,
<argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
<expr_stmt><expr><name><name>rb</name>-&gt;<name>rev</name></name> = <call><name>SVN_STR_TO_REV</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>rb</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>new_revision_record</name><parameter_list>(<param><decl><type><name>void</name> **</type><name>revision_baton</name></decl></param>,
<param><decl><type><name>apr_hash_t</name> *</type><name>headers</name></decl></param>,
<param><decl><type><name>void</name> *</type><name>parse_baton</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>parse_baton</name> *</type><name>pb</name> <init>= <expr><name>parse_baton</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>revision_baton</name> *</type><name>rb</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>head_rev</name></decl>;</decl_stmt>
<expr_stmt><expr><name>rb</name> = <call><name>make_revision_baton</name><argument_list>(<argument><expr><name>headers</name></expr></argument>, <argument><expr><name>pb</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_youngest_rev</name><argument_list>(<argument><expr>&amp;<name>head_rev</name></expr></argument>, <argument><expr><name><name>pb</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rb</name>-&gt;<name>rev_offset</name></name> = (<name><name>rb</name>-&gt;<name>rev</name></name>) - (<name>head_rev</name> + 1)</expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>rb</name>-&gt;<name>rev</name></name> &gt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_begin_txn2</name><argument_list>(<argument><expr>&amp;(<name><name>rb</name>-&gt;<name>txn</name></name>)</expr></argument>, <argument><expr><name><name>pb</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>head_rev</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_txn_root</name><argument_list>(<argument><expr>&amp;(<name><name>rb</name>-&gt;<name>txn_root</name></name>)</expr></argument>, <argument><expr><name><name>rb</name>-&gt;<name>txn</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_printf</name><argument_list>(<argument><expr><name><name>pb</name>-&gt;<name>outstream</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr>"&lt;&lt;&lt; Started new transaction, based on "
"original revision %ld\n"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>rb</name>-&gt;<name>rev</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr>*<name>revision_baton</name> = <name>rb</name></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>maybe_add_with_history</name><parameter_list>(<param><decl><type>struct <name>node_baton</name> *</type><name>nb</name></decl></param>,
<param><decl><type>struct <name>revision_baton</name> *</type><name>rb</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>parse_baton</name> *</type><name>pb</name> <init>= <expr><name><name>rb</name>-&gt;<name>pb</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name></decl>;</decl_stmt>
<if>if <condition>(<expr>(<name><name>nb</name>-&gt;<name>copyfrom_path</name></name> == <name>NULL</name>) || (! <name><name>pb</name>-&gt;<name>use_history</name></name>)</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>nb</name>-&gt;<name>kind</name></name> == <name>svn_node_file</name></expr>)</condition><then>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_make_file</name><argument_list>(<argument><expr><name><name>rb</name>-&gt;<name>txn_root</name></name></expr></argument>, <argument><expr><name><name>nb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name><name>nb</name>-&gt;<name>kind</name></name> == <name>svn_node_dir</name></expr>)</condition><then>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_make_dir</name><argument_list>(<argument><expr><name><name>rb</name>-&gt;<name>txn_root</name></name></expr></argument>, <argument><expr><name><name>nb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>copy_root</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>src_rev</name> <init>= <expr><name><name>nb</name>-&gt;<name>copyfrom_rev</name></name> - <name><name>rb</name>-&gt;<name>rev_offset</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_revnum_t</name> *</type><name>src_rev_from_map</name></decl>;</decl_stmt>
<if>if <condition>(<expr>(<name>src_rev_from_map</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name><name>pb</name>-&gt;<name>rev_map</name></name></expr></argument>, <argument><expr>&amp;<name><name>nb</name>-&gt;<name>copyfrom_rev</name></name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>nb</name>-&gt;<name>copyfrom_rev</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call>)</expr>)</condition><then>
<expr_stmt><expr><name>src_rev</name> = *<name>src_rev_from_map</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr>! <call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name>src_rev</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_FS_NO_SUCH_REVISION</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr>"Relative source revision %ld is not"
" available in current repository"</expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>src_rev</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_revision_root</name><argument_list>(<argument><expr>&amp;<name>copy_root</name></expr></argument>, <argument><expr><name><name>pb</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>src_rev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>nb</name>-&gt;<name>copy_source_checksum</name></name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>md5_digest</name><index>[<expr><name>APR_MD5_DIGESTSIZE</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>hex</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_file_md5_checksum</name><argument_list>(<argument><expr><name>md5_digest</name></expr></argument>, <argument><expr><name>copy_root</name></expr></argument>,
<argument><expr><name><name>nb</name>-&gt;<name>copyfrom_path</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>hex</name> = <call><name>svn_md5_digest_to_cstring</name><argument_list>(<argument><expr><name>md5_digest</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>hex</name> &amp;&amp; (<call><name>strcmp</name><argument_list>(<argument><expr><name><name>nb</name>-&gt;<name>copy_source_checksum</name></name></expr></argument>, <argument><expr><name>hex</name></expr></argument>)</argument_list></call> != 0)</expr>)</condition><then>
<return>return <expr><call><name>svn_error_createf</name>
<argument_list>(<argument><expr><name>SVN_ERR_CHECKSUM_MISMATCH</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr>"Copy source checksum mismatch on copy from '%s'@%ld\n"
" to '%s' in rev based on r%ld:\n"
" expected: %s\n"
" actual: %s\n"</expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>nb</name>-&gt;<name>copyfrom_path</name></name></expr></argument>, <argument><expr><name>src_rev</name></expr></argument>,
<argument><expr><name><name>nb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name><name>rb</name>-&gt;<name>rev</name></name></expr></argument>,
<argument><expr><name><name>nb</name>-&gt;<name>copy_source_checksum</name></name></expr></argument>, <argument><expr><name>hex</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
}</block></then></if>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_copy</name><argument_list>(<argument><expr><name>copy_root</name></expr></argument>, <argument><expr><name><name>nb</name>-&gt;<name>copyfrom_path</name></name></expr></argument>,
<argument><expr><name><name>rb</name>-&gt;<name>txn_root</name></name></expr></argument>, <argument><expr><name><name>nb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> = 9</expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_write</name><argument_list>(<argument><expr><name><name>pb</name>-&gt;<name>outstream</name></name></expr></argument>, <argument><expr>"COPIED..."</expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>uuid_record</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>uuid</name></decl></param>,
<param><decl><type><name>void</name> *</type><name>parse_baton</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>parse_baton</name> *</type><name>pb</name> <init>= <expr><name>parse_baton</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>youngest_rev</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>pb</name>-&gt;<name>uuid_action</name></name> == <name>svn_repos_load_uuid_ignore</name></expr>)</condition><then>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>
<if>if <condition>(<expr><name><name>pb</name>-&gt;<name>uuid_action</name></name> != <name>svn_repos_load_uuid_force</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_youngest_rev</name><argument_list>(<argument><expr>&amp;<name>youngest_rev</name></expr></argument>, <argument><expr><name><name>pb</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>youngest_rev</name> != 0</expr>)</condition><then>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>
}</block></then></if>
<return>return <expr><call><name>svn_fs_set_uuid</name><argument_list>(<argument><expr><name><name>pb</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>uuid</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>new_node_record</name><parameter_list>(<param><decl><type><name>void</name> **</type><name>node_baton</name></decl></param>,
<param><decl><type><name>apr_hash_t</name> *</type><name>headers</name></decl></param>,
<param><decl><type><name>void</name> *</type><name>revision_baton</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>revision_baton</name> *</type><name>rb</name> <init>= <expr><name>revision_baton</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>parse_baton</name> *</type><name>pb</name> <init>= <expr><name><name>rb</name>-&gt;<name>pb</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>node_baton</name> *</type><name>nb</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>rb</name>-&gt;<name>rev</name></name> == 0</expr>)</condition><then>
<return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_STREAM_MALFORMED_DATA</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr>"Malformed dumpstream: "
"Revision 0 must not contain node records"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>nb</name> = <call><name>make_node_baton</name><argument_list>(<argument><expr><name>headers</name></expr></argument>, <argument><expr><name>rb</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name><name>nb</name>-&gt;<name>action</name></name></expr>)</condition> <block>{
<case>case <expr><name>svn_node_action_change</name></expr>: <block>{
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_printf</name><argument_list>(<argument><expr><name><name>pb</name>-&gt;<name>outstream</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr>" * editing path : %s ..."</expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>nb</name>-&gt;<name>path</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
}</block>
</case><case>case <expr><name>svn_node_action_delete</name></expr>: <block>{
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_printf</name><argument_list>(<argument><expr><name><name>pb</name>-&gt;<name>outstream</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr>" * deleting path : %s ..."</expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>nb</name>-&gt;<name>path</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_delete</name><argument_list>(<argument><expr><name><name>rb</name>-&gt;<name>txn_root</name></name></expr></argument>, <argument><expr><name><name>nb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
}</block>
</case><case>case <expr><name>svn_node_action_add</name></expr>: <block>{
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_printf</name><argument_list>(<argument><expr><name><name>pb</name>-&gt;<name>outstream</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr>" * adding path : %s ..."</expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>nb</name>-&gt;<name>path</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>maybe_add_with_history</name><argument_list>(<argument><expr><name>nb</name></expr></argument>, <argument><expr><name>rb</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
}</block>
</case><case>case <expr><name>svn_node_action_replace</name></expr>: <block>{
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_printf</name><argument_list>(<argument><expr><name><name>pb</name>-&gt;<name>outstream</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr>" * replacing path : %s ..."</expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>nb</name>-&gt;<name>path</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_delete</name><argument_list>(<argument><expr><name><name>rb</name>-&gt;<name>txn_root</name></name></expr></argument>, <argument><expr><name><name>nb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>maybe_add_with_history</name><argument_list>(<argument><expr><name>nb</name></expr></argument>, <argument><expr><name>rb</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
}</block>
</case><default>default:
<return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_STREAM_UNRECOGNIZED_DATA</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr>"Unrecognized node-action on node '%s'"</expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>nb</name>-&gt;<name>path</name></name></expr></argument>)</argument_list></call></expr>;</return>
</default>}</block></switch>
<expr_stmt><expr>*<name>node_baton</name> = <name>nb</name></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>set_revision_property</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>value</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>revision_baton</name> *</type><name>rb</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>rb</name>-&gt;<name>rev</name></name> &gt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_change_txn_prop</name><argument_list>(<argument><expr><name><name>rb</name>-&gt;<name>txn</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name><name>rb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>! <call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>SVN_PROP_REVISION_DATE</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name><name>rb</name>-&gt;<name>datestamp</name></name> = <call><name>svn_string_dup</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name><name>rb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></then> <else>else <if>if <condition>(<expr><name><name>rb</name>-&gt;<name>rev</name></name> == 0</expr>)</condition><then> <block>{
<decl_stmt><decl><type>struct <name>parse_baton</name> *</type><name>pb</name> <init>= <expr><name><name>rb</name>-&gt;<name>pb</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>youngest_rev</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_youngest_rev</name><argument_list>(<argument><expr>&amp;<name>youngest_rev</name></expr></argument>, <argument><expr><name><name>pb</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name><name>rb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>youngest_rev</name> == 0</expr>)</condition><then>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_change_rev_prop</name><argument_list>(<argument><expr><name><name>pb</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name><name>rb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></then></if></else></if>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>set_node_property</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>value</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>node_baton</name> *</type><name>nb</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>revision_baton</name> *</type><name>rb</name> <init>= <expr><name><name>nb</name>-&gt;<name>rb</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>parent_dir</name> <init>= <expr><name><name>rb</name>-&gt;<name>pb</name>-&gt;<name>parent_dir</name></name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>SVN_PROP_MERGEINFO</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>svn_string_t</name> *</type><name>renumbered_mergeinfo</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>renumber_mergeinfo_revs</name><argument_list>(<argument><expr>&amp;<name>renumbered_mergeinfo</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>rb</name></expr></argument>,
<argument><expr><name><name>nb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>value</name> = <name>renumbered_mergeinfo</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>parent_dir</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>svn_string_t</name> *</type><name>mergeinfo_val</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>prefix_mergeinfo_paths</name><argument_list>(<argument><expr>&amp;<name>mergeinfo_val</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>parent_dir</name></expr></argument>,
<argument><expr><name><name>nb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>value</name> = <name>mergeinfo_val</name></expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_change_node_prop</name><argument_list>(<argument><expr><name><name>rb</name>-&gt;<name>txn_root</name></name></expr></argument>, <argument><expr><name><name>nb</name>-&gt;<name>path</name></name></expr></argument>,
<argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name><name>nb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>delete_node_property</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>node_baton</name> *</type><name>nb</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>revision_baton</name> *</type><name>rb</name> <init>= <expr><name><name>nb</name>-&gt;<name>rb</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_change_node_prop</name><argument_list>(<argument><expr><name><name>rb</name>-&gt;<name>txn_root</name></name></expr></argument>, <argument><expr><name><name>nb</name>-&gt;<name>path</name></name></expr></argument>,
<argument><expr><name>name</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>nb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>remove_node_props</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>node_baton</name> *</type><name>nb</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>revision_baton</name> *</type><name>rb</name> <init>= <expr><name><name>nb</name>-&gt;<name>rb</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>proplist</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_node_proplist</name><argument_list>(<argument><expr>&amp;<name>proplist</name></expr></argument>,
<argument><expr><name><name>rb</name>-&gt;<name>txn_root</name></name></expr></argument>, <argument><expr><name><name>nb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name><name>nb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name><name>nb</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>proplist</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>hi</name></expr>;</condition> <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>) <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_change_node_prop</name><argument_list>(<argument><expr><name><name>rb</name>-&gt;<name>txn_root</name></name></expr></argument>, <argument><expr><name><name>nb</name>-&gt;<name>path</name></name></expr></argument>,
<argument><expr>(const <name>char</name> *) <name>key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><name><name>nb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>apply_textdelta</name><parameter_list>(<param><decl><type><name>svn_txdelta_window_handler_t</name> *</type><name>handler</name></decl></param>,
<param><decl><type><name>void</name> **</type><name>handler_baton</name></decl></param>,
<param><decl><type><name>void</name> *</type><name>node_baton</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>node_baton</name> *</type><name>nb</name> <init>= <expr><name>node_baton</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>revision_baton</name> *</type><name>rb</name> <init>= <expr><name><name>nb</name>-&gt;<name>rb</name></name></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>svn_fs_apply_textdelta</name><argument_list>(<argument><expr><name>handler</name></expr></argument>, <argument><expr><name>handler_baton</name></expr></argument>,
<argument><expr><name><name>rb</name>-&gt;<name>txn_root</name></name></expr></argument>, <argument><expr><name><name>nb</name>-&gt;<name>path</name></name></expr></argument>,
<argument><expr><name><name>nb</name>-&gt;<name>base_checksum</name></name></expr></argument>, <argument><expr><name><name>nb</name>-&gt;<name>result_checksum</name></name></expr></argument>,
<argument><expr><name><name>nb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>set_fulltext</name><parameter_list>(<param><decl><type><name>svn_stream_t</name> **</type><name>stream</name></decl></param>,
<param><decl><type><name>void</name> *</type><name>node_baton</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>node_baton</name> *</type><name>nb</name> <init>= <expr><name>node_baton</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>revision_baton</name> *</type><name>rb</name> <init>= <expr><name><name>nb</name>-&gt;<name>rb</name></name></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>svn_fs_apply_text</name><argument_list>(<argument><expr><name>stream</name></expr></argument>,
<argument><expr><name><name>rb</name>-&gt;<name>txn_root</name></name></expr></argument>, <argument><expr><name><name>nb</name>-&gt;<name>path</name></name></expr></argument>,
<argument><expr><name><name>nb</name>-&gt;<name>result_checksum</name></name></expr></argument>,
<argument><expr><name><name>nb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>close_node</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>node_baton</name> *</type><name>nb</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>revision_baton</name> *</type><name>rb</name> <init>= <expr><name><name>nb</name>-&gt;<name>rb</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>parse_baton</name> *</type><name>pb</name> <init>= <expr><name><name>rb</name>-&gt;<name>pb</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name> <init>= <expr>7</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_write</name><argument_list>(<argument><expr><name><name>pb</name>-&gt;<name>outstream</name></name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>" done.\n"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>close_revision</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>revision_baton</name> *</type><name>rb</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>parse_baton</name> *</type><name>pb</name> <init>= <expr><name><name>rb</name>-&gt;<name>pb</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>conflict_msg</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_revnum_t</name> *</type><name>old_rev</name></decl>, *<decl><type ref="prev"/><name>new_rev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>rb</name>-&gt;<name>rev</name></name> &lt;= 0</expr>)</condition><then>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>
<expr_stmt><expr><name>old_rev</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>pb</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>old_rev</name></expr></argument>)</argument_list></sizeof> * 2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>new_rev</name> = <name>old_rev</name> + 1</expr>;</expr_stmt>
<expr_stmt><expr>*<name>old_rev</name> = <name><name>rb</name>-&gt;<name>rev</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>pb</name>-&gt;<name>use_pre_commit_hook</name></name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_name</name></decl>;</decl_stmt>
<expr_stmt><expr><name>err</name> = <call><name>svn_fs_txn_name</name><argument_list>(<argument><expr>&amp;<name>txn_name</name></expr></argument>, <argument><expr><name><name>rb</name>-&gt;<name>txn</name></name></expr></argument>, <argument><expr><name><name>rb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>! <name>err</name></expr>)</condition><then>
<expr_stmt><expr><name>err</name> = <call><name>svn_repos__hooks_pre_commit</name><argument_list>(<argument><expr><name><name>pb</name>-&gt;<name>repos</name></name></expr></argument>, <argument><expr><name>txn_name</name></expr></argument>, <argument><expr><name><name>rb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>err</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><call><name>svn_fs_abort_txn</name><argument_list>(<argument><expr><name><name>rb</name>-&gt;<name>txn</name></name></expr></argument>, <argument><expr><name><name>rb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>err</name></expr>;</return>
}</block></then></if>
}</block></then></if>
<if>if <condition>(<expr>(<name>err</name> = <call><name>svn_fs_commit_txn</name><argument_list>(<argument><expr>&amp;<name>conflict_msg</name></expr></argument>, <argument><expr><name>new_rev</name></expr></argument>, <argument><expr><name><name>rb</name>-&gt;<name>txn</name></name></expr></argument>, <argument><expr><name><name>rb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><call><name>svn_fs_abort_txn</name><argument_list>(<argument><expr><name><name>rb</name>-&gt;<name>txn</name></name></expr></argument>, <argument><expr><name><name>rb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>conflict_msg</name></expr>)</condition><then>
<return>return <expr><call><name>svn_error_quick_wrap</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>conflict_msg</name></expr></argument>)</argument_list></call></expr>;</return></then>
<else>else
<return>return <expr><name>err</name></expr>;</return></else></if>
}</block></then></if>
<if>if <condition>(<expr><name><name>pb</name>-&gt;<name>use_post_commit_hook</name></name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>(<name>err</name> = <call><name>svn_repos__hooks_post_commit</name><argument_list>(<argument><expr><name><name>pb</name>-&gt;<name>repos</name></name></expr></argument>, <argument><expr>*<name>new_rev</name></expr></argument>, <argument><expr><name><name>rb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
<return>return <expr><call><name>svn_error_create</name>
<argument_list>(<argument><expr><name>SVN_ERR_REPOS_POST_COMMIT_HOOK_FAILED</name></expr></argument>, <argument><expr><name>err</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr>"Commit succeeded, but post-commit hook failed"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
}</block></then></if>
<expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name><name>pb</name>-&gt;<name>rev_map</name></name></expr></argument>, <argument><expr><name>old_rev</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>svn_revnum_t</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>new_rev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_deltify_revision</name><argument_list>(<argument><expr><name><name>pb</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr>*<name>new_rev</name></expr></argument>, <argument><expr><name><name>rb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_change_rev_prop</name><argument_list>(<argument><expr><name><name>pb</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr>*<name>new_rev</name></expr></argument>,
<argument><expr><name>SVN_PROP_REVISION_DATE</name></expr></argument>, <argument><expr><name><name>rb</name>-&gt;<name>datestamp</name></name></expr></argument>,
<argument><expr><name><name>rb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>*<name>new_rev</name> == <name><name>rb</name>-&gt;<name>rev</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_printf</name><argument_list>(<argument><expr><name><name>pb</name>-&gt;<name>outstream</name></name></expr></argument>, <argument><expr><name><name>rb</name>-&gt;<name>pool</name></name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr>"\n------- Committed revision %ld"
" &gt;&gt;&gt;\n\n"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>*<name>new_rev</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_printf</name><argument_list>(<argument><expr><name><name>pb</name>-&gt;<name>outstream</name></name></expr></argument>, <argument><expr><name><name>rb</name>-&gt;<name>pool</name></name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr>"\n------- Committed new rev %ld"
" (loaded from original rev %ld"
") &gt;&gt;&gt;\n\n"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr>*<name>new_rev</name></expr></argument>, <argument><expr><name><name>rb</name>-&gt;<name>rev</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<decl_stmt><decl><type><name>svn_error_t</name> *</type>
<name>svn_repos_get_fs_build_parser2</name><argument_list>(<argument><expr>const <name>svn_repos_parse_fns2_t</name> **<name>callbacks</name></expr></argument>,
<argument><expr><name>void</name> **<name>parse_baton</name></expr></argument>,
<argument><expr><name>svn_repos_t</name> *<name>repos</name></expr></argument>,
<argument><expr><name>svn_boolean_t</name> <name>use_history</name></expr></argument>,
<argument>enum <expr><name>svn_repos_load_uuid</name> <name>uuid_action</name></expr></argument>,
<argument><expr><name>svn_stream_t</name> *<name>outstream</name></expr></argument>,
<argument><expr>const <name>char</name> *<name>parent_dir</name></expr></argument>,
<argument><expr><name>apr_pool_t</name> *<name>pool</name></expr></argument>)</argument_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>svn_repos_parser_fns_t</name> *</type><name>fns</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_repos_parse_fns2_t</name> *</type><name>parser</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_repos_get_fs_build_parser</name><argument_list>(<argument><expr>&amp;<name>fns</name></expr></argument>, <argument><expr><name>parse_baton</name></expr></argument>, <argument><expr><name>repos</name></expr></argument>,
<argument><expr><name>use_history</name></expr></argument>, <argument><expr><name>uuid_action</name></expr></argument>, <argument><expr><name>outstream</name></expr></argument>,
<argument><expr><name>parent_dir</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>parser</name> = <call><name>fns2_from_fns</name><argument_list>(<argument><expr><name>fns</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name>-&gt;<name>delete_node_property</name></name> = <name>delete_node_property</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name>-&gt;<name>apply_textdelta</name></name> = <name>apply_textdelta</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>callbacks</name> = <name>parser</name></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></decl></decl_stmt>
<decl_stmt><decl><type><name>svn_error_t</name> *</type>
<name>svn_repos_get_fs_build_parser</name><argument_list>(<argument><expr>const <name>svn_repos_parser_fns_t</name> **<name>parser_callbacks</name></expr></argument>,
<argument><expr><name>void</name> **<name>parse_baton</name></expr></argument>,
<argument><expr><name>svn_repos_t</name> *<name>repos</name></expr></argument>,
<argument><expr><name>svn_boolean_t</name> <name>use_history</name></expr></argument>,
<argument>enum <expr><name>svn_repos_load_uuid</name> <name>uuid_action</name></expr></argument>,
<argument><expr><name>svn_stream_t</name> *<name>outstream</name></expr></argument>,
<argument><expr>const <name>char</name> *<name>parent_dir</name></expr></argument>,
<argument><expr><name>apr_pool_t</name> *<name>pool</name></expr></argument>)</argument_list> <block>{
<decl_stmt><decl><type><name>svn_repos_parser_fns_t</name> *</type><name>parser</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>parser</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>parse_baton</name> *</type><name>pb</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>pb</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>parser</name>-&gt;<name>new_revision_record</name></name> = <name>new_revision_record</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name>-&gt;<name>new_node_record</name></name> = <name>new_node_record</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name>-&gt;<name>uuid_record</name></name> = <name>uuid_record</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name>-&gt;<name>set_revision_property</name></name> = <name>set_revision_property</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name>-&gt;<name>set_node_property</name></name> = <name>set_node_property</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name>-&gt;<name>remove_node_props</name></name> = <name>remove_node_props</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name>-&gt;<name>set_fulltext</name></name> = <name>set_fulltext</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name>-&gt;<name>close_node</name></name> = <name>close_node</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parser</name>-&gt;<name>close_revision</name></name> = <name>close_revision</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pb</name>-&gt;<name>repos</name></name> = <name>repos</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pb</name>-&gt;<name>fs</name></name> = <call><name>svn_repos_fs</name><argument_list>(<argument><expr><name>repos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pb</name>-&gt;<name>use_history</name></name> = <name>use_history</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pb</name>-&gt;<name>outstream</name></name> = <name>outstream</name> ? <name>outstream</name> : <call><name>svn_stream_empty</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pb</name>-&gt;<name>uuid_action</name></name> = <name>uuid_action</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pb</name>-&gt;<name>parent_dir</name></name> = <name>parent_dir</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pb</name>-&gt;<name>pool</name></name> = <name>pool</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pb</name>-&gt;<name>rev_map</name></name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>parser_callbacks</name> = <name>parser</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>parse_baton</name> = <name>pb</name></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></decl></decl_stmt>
<decl_stmt><decl><type><name>svn_error_t</name> *</type>
<name>svn_repos_load_fs2</name><argument_list>(<argument><expr><name>svn_repos_t</name> *<name>repos</name></expr></argument>,
<argument><expr><name>svn_stream_t</name> *<name>dumpstream</name></expr></argument>,
<argument><expr><name>svn_stream_t</name> *<name>feedback_stream</name></expr></argument>,
<argument>enum <expr><name>svn_repos_load_uuid</name> <name>uuid_action</name></expr></argument>,
<argument><expr>const <name>char</name> *<name>parent_dir</name></expr></argument>,
<argument><expr><name>svn_boolean_t</name> <name>use_pre_commit_hook</name></expr></argument>,
<argument><expr><name>svn_boolean_t</name> <name>use_post_commit_hook</name></expr></argument>,
<argument><expr><name>svn_cancel_func_t</name> <name>cancel_func</name></expr></argument>,
<argument><expr><name>void</name> *<name>cancel_baton</name></expr></argument>,
<argument><expr><name>apr_pool_t</name> *<name>pool</name></expr></argument>)</argument_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>svn_repos_parse_fns2_t</name> *</type><name>parser</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> *</type><name>parse_baton</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>parse_baton</name> *</type><name>pb</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_repos_get_fs_build_parser2</name><argument_list>(<argument><expr>&amp;<name>parser</name></expr></argument>, <argument><expr>&amp;<name>parse_baton</name></expr></argument>,
<argument><expr><name>repos</name></expr></argument>,
<argument><expr><name>TRUE</name></expr></argument>,
<argument><expr><name>uuid_action</name></expr></argument>,
<argument><expr><name>feedback_stream</name></expr></argument>,
<argument><expr><name>parent_dir</name></expr></argument>,
<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>pb</name> = <name>parse_baton</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pb</name>-&gt;<name>use_pre_commit_hook</name></name> = <name>use_pre_commit_hook</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>pb</name>-&gt;<name>use_post_commit_hook</name></name> = <name>use_post_commit_hook</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_repos_parse_dumpstream2</name><argument_list>(<argument><expr><name>dumpstream</name></expr></argument>, <argument><expr><name>parser</name></expr></argument>, <argument><expr><name>parse_baton</name></expr></argument>,
<argument><expr><name>cancel_func</name></expr></argument>, <argument><expr><name>cancel_baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></decl></decl_stmt>
<decl_stmt><decl><type><name>svn_error_t</name> *</type>
<name>svn_repos_load_fs</name><argument_list>(<argument><expr><name>svn_repos_t</name> *<name>repos</name></expr></argument>,
<argument><expr><name>svn_stream_t</name> *<name>dumpstream</name></expr></argument>,
<argument><expr><name>svn_stream_t</name> *<name>feedback_stream</name></expr></argument>,
<argument>enum <expr><name>svn_repos_load_uuid</name> <name>uuid_action</name></expr></argument>,
<argument><expr>const <name>char</name> *<name>parent_dir</name></expr></argument>,
<argument><expr><name>svn_cancel_func_t</name> <name>cancel_func</name></expr></argument>,
<argument><expr><name>void</name> *<name>cancel_baton</name></expr></argument>,
<argument><expr><name>apr_pool_t</name> *<name>pool</name></expr></argument>)</argument_list> <block>{
<return>return <expr><call><name>svn_repos_load_fs2</name><argument_list>(<argument><expr><name>repos</name></expr></argument>, <argument><expr><name>dumpstream</name></expr></argument>, <argument><expr><name>feedback_stream</name></expr></argument>,
<argument><expr><name>uuid_action</name></expr></argument>, <argument><expr><name>parent_dir</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
<argument><expr><name>cancel_func</name></expr></argument>, <argument><expr><name>cancel_baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></decl></decl_stmt>
</unit>
