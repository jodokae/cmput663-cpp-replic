<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/subversion-1.5.1/_cppstats/subversion/tests/libsvn_delta/range-index-test.h"><cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>SVN_RANGE_INDEX_TEST_H</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_RANGE_INDEX_TEST_H</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../../libsvn_delta/compose_delta.c"</cpp:file></cpp:include>
<decl_stmt><decl><type><specifier>static</specifier> <name>range_index_node_t</name> *</type><name>prev_node</name></decl>, *<decl><type ref="prev"/><name>prev_prev_node</name></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>apr_off_t</name></type>
<name>walk_range_index</name><parameter_list>(<param><decl><type><name>range_index_node_t</name> *</type><name>node</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>msg</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_off_t</name></type> <name>ret</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>node</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<expr_stmt><expr><name>ret</name> = <call><name>walk_range_index</name><argument_list>(<argument><expr><name><name>node</name>-&gt;<name>left</name></name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ret</name> &gt; 0</expr>)</condition><then>
<return>return <expr><name>ret</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>prev_node</name> != <name>NULL</name>
&amp;&amp; <name><name>node</name>-&gt;<name>target_offset</name></name> &gt; 0
&amp;&amp; (<name><name>prev_node</name>-&gt;<name>offset</name></name> &gt;= <name><name>node</name>-&gt;<name>offset</name></name>
|| (<name><name>prev_node</name>-&gt;<name>limit</name></name> &gt;= <name><name>node</name>-&gt;<name>limit</name></name>))</expr>)</condition><then> <block>{
<expr_stmt><expr><name>ret</name> = <name><name>node</name>-&gt;<name>target_offset</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>node</name>-&gt;<name>target_offset</name></name> = -<name><name>node</name>-&gt;<name>target_offset</name></name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>msg</name> = "Oops, the previous node ate me."</expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>prev_prev_node</name> != <name>NULL</name>
&amp;&amp; <name><name>prev_node</name>-&gt;<name>target_offset</name></name> &gt; 0
&amp;&amp; <name><name>prev_prev_node</name>-&gt;<name>limit</name></name> &gt; <name><name>node</name>-&gt;<name>offset</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>ret</name> = <name><name>prev_node</name>-&gt;<name>target_offset</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>prev_node</name>-&gt;<name>target_offset</name></name> = -<name><name>prev_node</name>-&gt;<name>target_offset</name></name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>msg</name> = "Arrgh, my neighbours are conspiring against me."</expr>;</expr_stmt>
<return>return <expr><name>ret</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>prev_prev_node</name> = <name>prev_node</name></expr>;</expr_stmt>
<expr_stmt><expr><name>prev_node</name> = <name>node</name></expr>;</expr_stmt>
<return>return <expr><call><name>walk_range_index</name><argument_list>(<argument><expr><name><name>node</name>-&gt;<name>right</name></name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>print_node_data</name><parameter_list>(<param><decl><type><name>range_index_node_t</name> *</type><name>node</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>msg</name></decl></param>, <param><decl><type><name>apr_off_t</name></type> <name>ndx</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr>-<name><name>node</name>-&gt;<name>target_offset</name></name> == <name>ndx</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>" * Node: [%3"<name>APR_OFF_T_FMT</name>
",%3"<name>APR_OFF_T_FMT</name>
") = %-5"<name>APR_OFF_T_FMT</name>"%s\n"</expr></argument>,
<argument><expr><name><name>node</name>-&gt;<name>offset</name></name></expr></argument>, <argument><expr><name><name>node</name>-&gt;<name>limit</name></name></expr></argument>, <argument><expr>-<name><name>node</name>-&gt;<name>target_offset</name></name></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>" Node: [%3"<name>APR_OFF_T_FMT</name>
",%3"<name>APR_OFF_T_FMT</name>
") = %"<name>APR_OFF_T_FMT</name>"\n"</expr></argument>,
<argument><expr><name><name>node</name>-&gt;<name>offset</name></name></expr></argument>, <argument><expr><name><name>node</name>-&gt;<name>limit</name></name></expr></argument>,
<argument><expr>(<name><name>node</name>-&gt;<name>target_offset</name></name> &lt; 0
? -<name><name>node</name>-&gt;<name>target_offset</name></name> : <name><name>node</name>-&gt;<name>target_offset</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>print_range_index_r</name><parameter_list>(<param><decl><type><name>range_index_node_t</name> *</type><name>node</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>msg</name></decl></param>, <param><decl><type><name>apr_off_t</name></type> <name>ndx</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name>node</name> == <name>NULL</name></expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><call><name>print_range_index_r</name><argument_list>(<argument><expr><name><name>node</name>-&gt;<name>left</name></name></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><name>ndx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>print_node_data</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><name>ndx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>print_range_index_r</name><argument_list>(<argument><expr><name><name>node</name>-&gt;<name>right</name></name></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><name>ndx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>print_range_index_i</name><parameter_list>(<param><decl><type><name>range_index_node_t</name> *</type><name>node</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>msg</name></decl></param>, <param><decl><type><name>apr_off_t</name></type> <name>ndx</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name>node</name> == <name>NULL</name></expr>)</condition><then>
<return>return;</return></then></if>
<while>while <condition>(<expr><name><name>node</name>-&gt;<name>prev</name></name></expr>)</condition>
<expr_stmt><expr><name>node</name> = <name><name>node</name>-&gt;<name>prev</name></name></expr>;</expr_stmt></while>
<do>do <block>{
<expr_stmt><expr><call><name>print_node_data</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><name>ndx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>node</name> = <name><name>node</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
}</block> while <condition>(<expr><name>node</name></expr>)</condition>;</do>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>print_range_index</name><parameter_list>(<param><decl><type><name>range_index_node_t</name> *</type><name>node</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>msg</name></decl></param>, <param><decl><type><name>apr_off_t</name></type> <name>ndx</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>" (recursive)\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>print_range_index_r</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><name>ndx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>" (iterative)\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>print_range_index_i</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>msg</name></expr></argument>, <argument><expr><name>ndx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_copy_count</name><parameter_list>(<param><decl><type><name>int</name></type> <name>src_cp</name></decl></param>, <param><decl><type><name>int</name></type> <name>tgt_cp</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"Source copies: %d Target copies: %d\n"</expr></argument>, <argument><expr><name>src_cp</name></expr></argument>, <argument><expr><name>tgt_cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>src_cp</name> &gt; <name>tgt_cp</name></expr>)</condition><then>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"WARN: More source than target copies; inefficient combiner?\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>random_range_index_test</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>msg</name></decl></param>,
<param><decl><type><name>svn_boolean_t</name></type> <name>msg_only</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>msg_buff</name><index>[<expr>256</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>seed</name></decl>, <decl><type ref="prev"/><name>bytes_range</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>maxlen</name></decl>, <decl><type ref="prev"/><name>iterations</name></decl>, <decl><type ref="prev"/><name>dump_files</name></decl>, <decl><type ref="prev"/><name>print_windows</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>random_bytes</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>range_index_t</name> *</type><name>ndx</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>tgt_cp</name> <init>= <expr>0</expr></init>, <name>src_cp</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>init_params</name><argument_list>(<argument><expr>&amp;<name>seed</name></expr></argument>, <argument><expr>&amp;<name>maxlen</name></expr></argument>, <argument><expr>&amp;<name>iterations</name></expr></argument>, <argument><expr>&amp;<name>dump_files</name></expr></argument>, <argument><expr>&amp;<name>print_windows</name></expr></argument>,
<argument><expr>&amp;<name>random_bytes</name></expr></argument>, <argument><expr>&amp;<name>bytes_range</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>msg_buff</name></expr></argument>, <argument><expr>"random range index test, seed = %lu"</expr></argument>, <argument><expr><name>seed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>msg</name> = <name>msg_buff</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>msg_only</name></expr>)</condition><then>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then>
<else>else
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"SEED: %s\n"</expr></argument>, <argument><expr><name>msg_buff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<expr_stmt><expr><name>ndx</name> = <call><name>create_range_index</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 1</expr>;</init> <condition><expr><name>i</name> &lt;= <name>iterations</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<decl_stmt><decl><type><name>apr_off_t</name></type> <name>offset</name> <init>= <expr><call><name>myrand</name><argument_list>(<argument><expr>&amp;<name>seed</name></expr></argument>)</argument_list></call> % 47</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_off_t</name></type> <name>limit</name> <init>= <expr><name>offset</name> + <call><name>myrand</name><argument_list>(<argument><expr>&amp;<name>seed</name></expr></argument>)</argument_list></call> % 16 + 1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>range_list_node_t</name> *</type><name>list</name></decl>, *<decl><type ref="prev"/><name>r</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_off_t</name></type> <name>ret</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>msg2</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"%3d: Inserting [%3"<name>APR_OFF_T_FMT</name>",%3"<name>APR_OFF_T_FMT</name>") ..."</expr></argument>,
<argument><expr><name>i</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>, <argument><expr><name>limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>splay_range_index</name><argument_list>(<argument><expr><name>offset</name></expr></argument>, <argument><expr><name>ndx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>list</name> = <call><name>build_range_list</name><argument_list>(<argument><expr><name>offset</name></expr></argument>, <argument><expr><name>limit</name></expr></argument>, <argument><expr><name>ndx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>insert_range</name><argument_list>(<argument><expr><name>offset</name></expr></argument>, <argument><expr><name>limit</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>ndx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>prev_prev_node</name> = <name>prev_node</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>ret</name> = <call><name>walk_range_index</name><argument_list>(<argument><expr><name><name>ndx</name>-&gt;<name>tree</name></name></expr></argument>, <argument><expr>&amp;<name>msg2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ret</name> == 0</expr>)</condition><then> <block>{
<for>for (<init><expr><name>r</name> = <name>list</name></expr>;</init> <condition><expr><name>r</name></expr>;</condition> <incr><expr><name>r</name> = <name><name>r</name>-&gt;<name>next</name></name></expr></incr>)
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>" %s[%3"<name>APR_OFF_T_FMT</name>",%3"<name>APR_OFF_T_FMT</name>")"</expr></argument>,
<argument><expr>(<name><name>r</name>-&gt;<name>kind</name></name> == <name>range_from_source</name> ?
(++<name>src_cp</name>, "S") : (++<name>tgt_cp</name>, "T"))</expr></argument>,
<argument><expr><name><name>r</name>-&gt;<name>offset</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>limit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
<expr_stmt><expr><call><name>free_range_list</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>ndx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>" OK\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>" Ooops!\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>print_range_index</name><argument_list>(<argument><expr><name><name>ndx</name>-&gt;<name>tree</name></name></expr></argument>, <argument><expr><name>msg2</name></expr></argument>, <argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>check_copy_count</name><argument_list>(<argument><expr><name>src_cp</name></expr></argument>, <argument><expr><name>tgt_cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_TEST_FAILED</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>,
<argument><expr>"insert_range"</expr></argument>)</argument_list></call></expr>;</return>
}</block></else></if>
}</block></for>
<expr_stmt><expr><call><name>printf</name><argument_list>(<argument><expr>"Final tree state:\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>print_range_index</name><argument_list>(<argument><expr><name><name>ndx</name>-&gt;<name>tree</name></name></expr></argument>, <argument><expr>""</expr></argument>, <argument><expr><name>iterations</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>check_copy_count</name><argument_list>(<argument><expr><name>src_cp</name></expr></argument>, <argument><expr><name>tgt_cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
