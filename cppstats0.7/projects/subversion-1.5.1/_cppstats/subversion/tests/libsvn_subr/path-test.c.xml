<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="subversion/tests/libsvn_subr/path-test.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_pools.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_path.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_general.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../svn_test.h"</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_EMPTY_PATH</name></cpp:macro> <cpp:value>""</cpp:value></cpp:define>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>test_path_is_child</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>msg</name></decl></param>,
<param><decl><type><name>svn_boolean_t</name></type> <name>msg_only</name></decl></param>,
<param><decl><type><name>svn_test_opts_t</name> *</type><name>opts</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_TEST_PATHS</name></cpp:macro> <cpp:value>11</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> * <specifier>const</specifier></type> <name><name>paths</name><index>[<expr><name>NUM_TEST_PATHS</name></expr>]</index></name> <init>= <expr><block>{
<expr>"/foo/bar"</expr>,
<expr>"/foo/bars"</expr>,
<expr>"/foo/baz"</expr>,
<expr>"/foo/bar/baz"</expr>,
<expr>"/flu/blar/blaz"</expr>,
<expr>"/foo/bar/baz/bing/boom"</expr>,
<expr><name>SVN_EMPTY_PATH</name></expr>,
<expr>"foo"</expr>,
<expr>".foo"</expr>,
<expr>"/"</expr>,
<expr>"foo2"</expr>,
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> * <specifier>const</specifier></type> <name><name>remainders</name><index>[<expr><name>NUM_TEST_PATHS</name></expr>]</index><index>[<expr><name>NUM_TEST_PATHS</name></expr>]</index></name> <init>= <expr><block>{
<expr><block>{ <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>"baz"</expr>, <expr>0</expr>, <expr>"baz/bing/boom"</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr> }</block></expr>,
<expr><block>{ <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr> }</block></expr>,
<expr><block>{ <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr> }</block></expr>,
<expr><block>{ <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>"bing/boom"</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr> }</block></expr>,
<expr><block>{ <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr> }</block></expr>,
<expr><block>{ <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr> }</block></expr>,
<expr><block>{ <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>"foo"</expr>, <expr>".foo"</expr>, <expr>0</expr>, <expr>"foo2"</expr> }</block></expr>,
<expr><block>{ <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr> }</block></expr>,
<expr><block>{ <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr> }</block></expr>,
<expr><block>{
<expr>"foo/bar"</expr>, <expr>"foo/bars"</expr>, <expr>"foo/baz"</expr>, <expr>"foo/bar/baz"</expr>, <expr>"flu/blar/blaz"</expr>,
<expr>"foo/bar/baz/bing/boom"</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>
}</block></expr>,
<expr><block>{ <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr> }</block></expr>,
}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr>*<name>msg</name> = "test svn_path_is_child"</expr>;</expr_stmt>
<if>if <condition>(<expr><name>msg_only</name></expr>)</condition><then>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>NUM_TEST_PATHS</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name>NUM_TEST_PATHS</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>remainder</name></decl>;</decl_stmt>
<expr_stmt><expr><name>remainder</name> = <call><name>svn_path_is_child</name><argument_list>(<argument><expr><name><name>paths</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>paths</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>((<name>remainder</name>) &amp;&amp; (! <name><name>remainders</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name>))
|| ((! <name>remainder</name>) &amp;&amp; (<name><name>remainders</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name>))
|| (<name>remainder</name> &amp;&amp; <call><name>strcmp</name><argument_list>(<argument><expr><name>remainder</name></expr></argument>, <argument><expr><name><name>remainders</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
<return>return <expr><call><name>svn_error_createf</name>
<argument_list>(<argument><expr><name>SVN_ERR_TEST_FAILED</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr>"svn_path_is_child (%s, %s) returned '%s' instead of '%s'"</expr></argument>,
<argument><expr><name><name>paths</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>paths</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>,
<argument><expr><name>remainder</name> ? <name>remainder</name> : "(null)"</expr></argument>,
<argument><expr><name><name>remainders</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> ? <name><name>remainders</name><index>[<expr><name>i</name></expr>]</index><index>[<expr><name>j</name></expr>]</index></name> : "(null)"</expr></argument> )</argument_list></call></expr>;</return></then></if>
}</block></for>
}</block></for>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>NUM_TEST_PATHS</name></cpp:undef>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>test_path_split</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>msg</name></decl></param>,
<param><decl><type><name>svn_boolean_t</name></type> <name>msg_only</name></decl></param>,
<param><decl><type><name>svn_test_opts_t</name> *</type><name>opts</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> * <specifier>const</specifier></type> <name><name>paths</name><index>[]</index><index>[<expr>3</expr>]</index></name> <init>= <expr><block>{
<expr><block>{ <expr>"/foo/bar"</expr>, <expr>"/foo"</expr>, <expr>"bar"</expr> }</block></expr>,
<expr><block>{ <expr>"/foo/bar/ "</expr>, <expr>"/foo/bar"</expr>, <expr>" "</expr> }</block></expr>,
<expr><block>{ <expr>"/foo"</expr>, <expr>"/"</expr>, <expr>"foo"</expr> }</block></expr>,
<expr><block>{ <expr>"foo"</expr>, <expr><name>SVN_EMPTY_PATH</name></expr>, <expr>"foo"</expr> }</block></expr>,
<expr><block>{ <expr>".bar"</expr>, <expr><name>SVN_EMPTY_PATH</name></expr>, <expr>".bar"</expr> }</block></expr>,
<expr><block>{ <expr>"/.bar"</expr>, <expr>"/"</expr>, <expr>".bar"</expr> }</block></expr>,
<expr><block>{ <expr>"foo/bar"</expr>, <expr>"foo"</expr>, <expr>"bar"</expr> }</block></expr>,
<expr><block>{ <expr>"/foo/bar"</expr>, <expr>"/foo"</expr>, <expr>"bar"</expr> }</block></expr>,
<expr><block>{ <expr>"foo/bar"</expr>, <expr>"foo"</expr>, <expr>"bar"</expr> }</block></expr>,
<expr><block>{ <expr>"foo./.bar"</expr>, <expr>"foo."</expr>, <expr>".bar"</expr> }</block></expr>,
<expr><block>{ <expr>"../foo"</expr>, <expr>".."</expr>, <expr>"foo"</expr> }</block></expr>,
<expr><block>{ <expr><name>SVN_EMPTY_PATH</name></expr>, <expr><name>SVN_EMPTY_PATH</name></expr>, <expr><name>SVN_EMPTY_PATH</name></expr> }</block></expr>,
<expr><block>{ <expr>"/flu\\b/\\blarg"</expr>, <expr>"/flu\\b"</expr>, <expr>"\\blarg"</expr> }</block></expr>,
<expr><block>{ <expr>"/"</expr>, <expr>"/"</expr>, <expr>"/"</expr> }</block></expr>,
}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr>*<name>msg</name> = "test svn_path_split"</expr>;</expr_stmt>
<if>if <condition>(<expr><name>msg_only</name></expr>)</condition><then>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <sizeof>sizeof<argument_list>(<argument><expr><name>paths</name></expr></argument>)</argument_list></sizeof> / <sizeof>sizeof<argument_list>(<argument><expr><name><name>paths</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dir</name></decl>, *<decl><type ref="prev"/><name>base_name</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>svn_path_split</name><argument_list>(<argument><expr><name><name>paths</name><index>[<expr><name>i</name></expr>]</index><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr>&amp;<name>dir</name></expr></argument>, <argument><expr>&amp;<name>base_name</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>dir</name></expr></argument>, <argument><expr><name><name>paths</name><index>[<expr><name>i</name></expr>]</index><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<return>return <expr><call><name>svn_error_createf</name>
<argument_list>(<argument><expr><name>SVN_ERR_TEST_FAILED</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr>"svn_path_split (%s) returned dirname '%s' instead of '%s'"</expr></argument>,
<argument><expr><name><name>paths</name><index>[<expr><name>i</name></expr>]</index><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><name><name>paths</name><index>[<expr><name>i</name></expr>]</index><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>base_name</name></expr></argument>, <argument><expr><name><name>paths</name><index>[<expr><name>i</name></expr>]</index><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<return>return <expr><call><name>svn_error_createf</name>
<argument_list>(<argument><expr><name>SVN_ERR_TEST_FAILED</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr>"svn_path_split (%s) returned basename '%s' instead of '%s'"</expr></argument>,
<argument><expr><name><name>paths</name><index>[<expr><name>i</name></expr>]</index><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name>base_name</name></expr></argument>, <argument><expr><name><name>paths</name><index>[<expr><name>i</name></expr>]</index><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
}</block></for>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>test_is_url</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>msg</name></decl></param>,
<param><decl><type><name>svn_boolean_t</name></type> <name>msg_only</name></decl></param>,
<param><decl><type><name>svn_test_opts_t</name> *</type><name>opts</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>i</name></decl>;</decl_stmt>
<struct>struct <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>result</name></decl>;</decl_stmt>
}</block> <decl><name><name>tests</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr>""</expr>, <expr><name>FALSE</name></expr> }</block></expr>,
<expr><block>{ <expr>"/blah/blah"</expr>, <expr><name>FALSE</name></expr> }</block></expr>,
<expr><block>{ <expr>"//blah/blah"</expr>, <expr><name>FALSE</name></expr> }</block></expr>,
<expr><block>{ <expr>"://blah/blah"</expr>, <expr><name>FALSE</name></expr> }</block></expr>,
<expr><block>{ <expr>"a:abb://boo/"</expr>, <expr><name>FALSE</name></expr> }</block></expr>,
<expr><block>{ <expr>"http://svn.collab.net/repos/svn"</expr>, <expr><name>TRUE</name></expr> }</block></expr>,
<expr><block>{ <expr>"scheme/with"</expr>, <expr><name>FALSE</name></expr> }</block></expr>,
<expr><block>{ <expr>"scheme/with:"</expr>, <expr><name>FALSE</name></expr> }</block></expr>,
<expr><block>{ <expr>"scheme/with:/"</expr>, <expr><name>FALSE</name></expr> }</block></expr>,
<expr><block>{ <expr>"scheme/with://"</expr>, <expr><name>FALSE</name></expr> }</block></expr>,
<expr><block>{ <expr>"scheme/with://slash/"</expr>, <expr><name>FALSE</name></expr> }</block></expr>,
<expr><block>{ <expr>"file:///path/to/repository"</expr>, <expr><name>TRUE</name></expr> }</block></expr>,
<expr><block>{ <expr>"file://"</expr>, <expr><name>TRUE</name></expr> }</block></expr>,
<expr><block>{ <expr>"file:/"</expr>, <expr><name>FALSE</name></expr> }</block></expr>,
<expr><block>{ <expr>"file:"</expr>, <expr><name>FALSE</name></expr> }</block></expr>,
<expr><block>{ <expr>"file"</expr>, <expr><name>FALSE</name></expr> }</block></expr>,
}</block></expr></init></decl>;</struct>
<expr_stmt><expr>*<name>msg</name> = "test svn_path_is_url"</expr>;</expr_stmt>
<if>if <condition>(<expr><name>msg_only</name></expr>)</condition><then>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <sizeof>sizeof<argument_list>(<argument><expr><name>tests</name></expr></argument>)</argument_list></sizeof> / <sizeof>sizeof<argument_list>(<argument><expr><name><name>tests</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>retval</name></decl>;</decl_stmt>
<expr_stmt><expr><name>retval</name> = <call><name>svn_path_is_url</name><argument_list>(<argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>result</name> != <name>retval</name></expr>)</condition><then>
<return>return <expr><call><name>svn_error_createf</name>
<argument_list>(<argument><expr><name>SVN_ERR_TEST_FAILED</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr>"svn_path_is_url (%s) returned %s instead of %s"</expr></argument>,
<argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>path</name></expr></argument>, <argument><expr><name>retval</name> ? "TRUE" : "FALSE"</expr></argument>,
<argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>result</name> ? "TRUE" : "FALSE"</expr></argument>)</argument_list></call></expr>;</return></then></if>
}</block></for>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>test_is_uri_safe</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>msg</name></decl></param>,
<param><decl><type><name>svn_boolean_t</name></type> <name>msg_only</name></decl></param>,
<param><decl><type><name>svn_test_opts_t</name> *</type><name>opts</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>i</name></decl>;</decl_stmt>
<struct>struct <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>result</name></decl>;</decl_stmt>
}</block> <decl><name><name>tests</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr>"http://svn.collab.net/repos"</expr>, <expr><name>TRUE</name></expr> }</block></expr>,
<expr><block>{ <expr>"http://svn.collab.net/repos%"</expr>, <expr><name>FALSE</name></expr> }</block></expr>,
<expr><block>{ <expr>"http://svn.collab.net/repos%/svn"</expr>, <expr><name>FALSE</name></expr> }</block></expr>,
<expr><block>{ <expr>"http://svn.collab.net/repos%2g"</expr>, <expr><name>FALSE</name></expr> }</block></expr>,
<expr><block>{ <expr>"http://svn.collab.net/repos%2g/svn"</expr>, <expr><name>FALSE</name></expr> }</block></expr>,
<expr><block>{ <expr>"http://svn.collab.net/repos%%"</expr>, <expr><name>FALSE</name></expr> }</block></expr>,
<expr><block>{ <expr>"http://svn.collab.net/repos%%/svn"</expr>, <expr><name>FALSE</name></expr> }</block></expr>,
<expr><block>{ <expr>"http://svn.collab.net/repos%2a"</expr>, <expr><name>TRUE</name></expr> }</block></expr>,
<expr><block>{ <expr>"http://svn.collab.net/repos%2a/svn"</expr>, <expr><name>TRUE</name></expr> }</block></expr>,
}</block></expr></init></decl>;</struct>
<expr_stmt><expr>*<name>msg</name> = "test svn_path_is_uri_safe"</expr>;</expr_stmt>
<if>if <condition>(<expr><name>msg_only</name></expr>)</condition><then>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; (<sizeof>sizeof<argument_list>(<argument><expr><name>tests</name></expr></argument>)</argument_list></sizeof> / <sizeof>sizeof<argument_list>(<argument><expr><name><name>tests</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></sizeof>)</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>retval</name></decl>;</decl_stmt>
<expr_stmt><expr><name>retval</name> = <call><name>svn_path_is_uri_safe</name><argument_list>(<argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>result</name> != <name>retval</name></expr>)</condition><then>
<return>return <expr><call><name>svn_error_createf</name>
<argument_list>(<argument><expr><name>SVN_ERR_TEST_FAILED</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr>"svn_path_is_uri_safe (%s) returned %s instead of %s"</expr></argument>,
<argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>path</name></expr></argument>, <argument><expr><name>retval</name> ? "TRUE" : "FALSE"</expr></argument>,
<argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>result</name> ? "TRUE" : "FALSE"</expr></argument>)</argument_list></call></expr>;</return></then></if>
}</block></for>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>test_uri_encode</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>msg</name></decl></param>,
<param><decl><type><name>svn_boolean_t</name></type> <name>msg_only</name></decl></param>,
<param><decl><type><name>svn_test_opts_t</name> *</type><name>opts</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<struct>struct <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>result</name></decl>;</decl_stmt>
}</block> <decl><name><name>tests</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{
<expr>"http://subversion.tigris.org"</expr>,
<expr>"http://subversion.tigris.org"</expr>
}</block></expr>,
<expr><block>{
<expr>" special_at_beginning"</expr>,
<expr>"%20special_at_beginning"</expr>
}</block></expr>,
<expr><block>{
<expr>"special_at_end "</expr>,
<expr>"special_at_end%20"</expr>
}</block></expr>,
<expr><block>{
<expr>"special in middle"</expr>,
<expr>"special%20in%20middle"</expr>
}</block></expr>,
<expr><block>{
<expr>"\"Ouch!\" \"Did that hurt?\""</expr>,
<expr>"%22Ouch!%22%20%20%22Did%20that%20hurt%3F%22"</expr>
}</block></expr>
}</block></expr></init></decl>;</struct>
<expr_stmt><expr>*<name>msg</name> = "test svn_path_uri_[en/de]code"</expr>;</expr_stmt>
<if>if <condition>(<expr><name>msg_only</name></expr>)</condition><then>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; 5</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>en_path</name></decl>, *<decl><type ref="prev"/><name>de_path</name></decl>;</decl_stmt>
<expr_stmt><expr><name>en_path</name> = <call><name>svn_path_uri_encode</name><argument_list>(<argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>en_path</name></expr></argument>, <argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<return>return <expr><call><name>svn_error_createf</name>
<argument_list>(<argument><expr><name>SVN_ERR_TEST_FAILED</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr>"svn_path_uri_encode ('%s') returned '%s' instead of '%s'"</expr></argument>,
<argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>path</name></expr></argument>, <argument><expr><name>en_path</name></expr></argument>, <argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>result</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>de_path</name> = <call><name>svn_path_uri_decode</name><argument_list>(<argument><expr><name>en_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>de_path</name></expr></argument>, <argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>path</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<return>return <expr><call><name>svn_error_createf</name>
<argument_list>(<argument><expr><name>SVN_ERR_TEST_FAILED</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr>"svn_path_uri_decode ('%s') returned '%s' instead of '%s'"</expr></argument>,
<argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>result</name></expr></argument>, <argument><expr><name>de_path</name></expr></argument>, <argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>path</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
}</block></for>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>test_uri_decode</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>msg</name></decl></param>,
<param><decl><type><name>svn_boolean_t</name></type> <name>msg_only</name></decl></param>,
<param><decl><type><name>svn_test_opts_t</name> *</type><name>opts</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<struct>struct <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>result</name></decl>;</decl_stmt>
}</block> <decl><name><name>tests</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{
<expr>"http://c.r.a/s%\0008me"</expr>,
<expr>"http://c.r.a/s%"</expr>
}</block></expr>,
<expr><block>{
<expr>"http://c.r.a/s%6\000me"</expr>,
<expr>"http://c.r.a/s%6"</expr>
}</block></expr>,
<expr><block>{
<expr>"http://c.r.a/s%68me"</expr>,
<expr>"http://c.r.a/shme"</expr>
}</block></expr>,
}</block></expr></init></decl>;</struct>
<expr_stmt><expr>*<name>msg</name> = "test svn_path_uri_decode with invalid escape"</expr>;</expr_stmt>
<if>if <condition>(<expr><name>msg_only</name></expr>)</condition><then>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; 3</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>de_path</name></decl>;</decl_stmt>
<expr_stmt><expr><name>de_path</name> = <call><name>svn_path_uri_decode</name><argument_list>(<argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>de_path</name></expr></argument>, <argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<return>return <expr><call><name>svn_error_createf</name>
<argument_list>(<argument><expr><name>SVN_ERR_TEST_FAILED</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr>"svn_path_uri_decode ('%s') returned '%s' instead of '%s'"</expr></argument>,
<argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>path</name></expr></argument>, <argument><expr><name>de_path</name></expr></argument>, <argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>result</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
}</block></for>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>test_uri_autoescape</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>msg</name></decl></param>,
<param><decl><type><name>svn_boolean_t</name></type> <name>msg_only</name></decl></param>,
<param><decl><type><name>svn_test_opts_t</name> *</type><name>opts</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<struct>struct <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>result</name></decl>;</decl_stmt>
}</block> <decl><name><name>tests</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr>"http://svn.collab.net/"</expr>, <expr>"http://svn.collab.net/"</expr> }</block></expr>,
<expr><block>{ <expr>"file:///&lt;&gt;\" {}|\\^`"</expr>, <expr>"file:///%3C%3E%22%20%7B%7D%7C%5C%5E%60"</expr> }</block></expr>,
<expr><block>{ <expr>"http://[::1]"</expr>, <expr>"http://[::1]"</expr> }</block></expr>
}</block></expr></init></decl>;</struct>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr>*<name>msg</name> = "test svn_path_uri_autoescape"</expr>;</expr_stmt>
<if>if <condition>(<expr><name>msg_only</name></expr>)</condition><then>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; 3</expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>uri</name> <init>= <expr><call><name>svn_path_uri_autoescape</name><argument_list>(<argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>uri</name></expr></argument>, <argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>result</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
<return>return <expr><call><name>svn_error_createf</name>
<argument_list>(<argument><expr><name>SVN_ERR_TEST_FAILED</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr>"svn_path_uri_autoescape on '%s' returned '%s' instead of '%s'"</expr></argument>,
<argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>path</name></expr></argument>, <argument><expr><name>uri</name></expr></argument>, <argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>result</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>path</name></expr></argument>, <argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>result</name></expr></argument>)</argument_list></call> == 0
&amp;&amp; <name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>path</name> != <name>uri</name></expr>)</condition><then>
<return>return <expr><call><name>svn_error_createf</name>
<argument_list>(<argument><expr><name>SVN_ERR_TEST_FAILED</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr>"svn_path_uri_autoescape on '%s' returned identical but not same"
" string"</expr></argument>, <argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>path</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
}</block></for>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>test_uri_from_iri</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>msg</name></decl></param>,
<param><decl><type><name>svn_boolean_t</name></type> <name>msg_only</name></decl></param>,
<param><decl><type><name>svn_test_opts_t</name> *</type><name>opts</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>p1</name><index>[]</index></name> <init>= <expr><block>{
<expr>'\x66'</expr>, <expr>'\x69'</expr>, <expr>'\x6C'</expr>, <expr>'\x65'</expr>, <expr>'\x3A'</expr>, <expr>'\x2F'</expr>, <expr>'\x2F'</expr>, <expr>'\x2F'</expr>,
<expr>'\x72'</expr>, <expr>'\xC3'</expr>, <expr>'\xA4'</expr>, <expr>'\x6B'</expr>, <expr>'\x73'</expr>, <expr>'\x6D'</expr>, <expr>'\xC3'</expr>, <expr>'\xB6'</expr>, <expr>'\x72'</expr>,
<expr>'\x67'</expr>, <expr>'\xC3'</expr>, <expr>'\xA5'</expr>, <expr>'\x73'</expr>, <expr>'\0'</expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>p2</name><index>[]</index></name> <init>= <expr><block>{
<expr>'\x66'</expr>, <expr>'\x69'</expr>, <expr>'\x6C'</expr>, <expr>'\x65'</expr>, <expr>'\x3A'</expr>, <expr>'\x2F'</expr>, <expr>'\x2F'</expr>, <expr>'\x2F'</expr>,
<expr>'\x61'</expr>, <expr>'\x62'</expr>, <expr>'\x25'</expr>, <expr>'\x32'</expr>, <expr>'\x30'</expr>, <expr>'\x63'</expr>, <expr>'\x64'</expr>, <expr>'\0'</expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name><name>paths</name><index>[<expr>2</expr>]</index><index>[<expr>2</expr>]</index></name> <init>= <expr><block>{
<expr><block>{
<expr><name>p1</name></expr>,
<expr>"file:///r%C3%A4ksm%C3%B6rg%C3%A5s"</expr>
}</block></expr>,
<expr><block>{
<expr><name>p2</name></expr>,
<expr>"file:///ab%20cd"</expr>
}</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr>*<name>msg</name> = "test svn_path_uri_from_iri"</expr>;</expr_stmt>
<if>if <condition>(<expr><name>msg_only</name></expr>)</condition><then>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; 2</expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>uri</name> <init>= <expr><call><name>svn_path_uri_from_iri</name><argument_list>(<argument><expr><name><name>paths</name><index>[<expr><name>i</name></expr>]</index><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>paths</name><index>[<expr><name>i</name></expr>]</index><index>[<expr>1</expr>]</index></name></expr></argument>, <argument><expr><name>uri</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
<return>return <expr><call><name>svn_error_createf</name>
<argument_list>(<argument><expr><name>SVN_ERR_TEST_FAILED</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr>"svn_path_uri_from_iri on '%s' returned '%s' instead of '%s'"</expr></argument>,
<argument><expr><name><name>paths</name><index>[<expr><name>i</name></expr>]</index><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name>uri</name></expr></argument>, <argument><expr><name><name>paths</name><index>[<expr><name>i</name></expr>]</index><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>paths</name><index>[<expr><name>i</name></expr>]</index><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name>uri</name></expr></argument>)</argument_list></call> == 0
&amp;&amp; <name><name>paths</name><index>[<expr><name>i</name></expr>]</index><index>[<expr>0</expr>]</index></name> != <name>uri</name></expr>)</condition><then>
<return>return <expr><call><name>svn_error_createf</name>
<argument_list>(<argument><expr><name>SVN_ERR_TEST_FAILED</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr>"svn_path_uri_from_iri on '%s' returned identical but not same"
" string"</expr></argument>, <argument><expr><name><name>paths</name><index>[<expr><name>i</name></expr>]</index><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return></then></if>
}</block></for>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>test_join</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>msg</name></decl></param>,
<param><decl><type><name>svn_boolean_t</name></type> <name>msg_only</name></decl></param>,
<param><decl><type><name>svn_test_opts_t</name> *</type><name>opts</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>result</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> * <specifier>const</specifier></type> <name><name>joins</name><index>[]</index><index>[<expr>3</expr>]</index></name> <init>= <expr><block>{
<expr><block>{ <expr>"abc"</expr>, <expr>"def"</expr>, <expr>"abc/def"</expr> }</block></expr>,
<expr><block>{ <expr>"a"</expr>, <expr>"def"</expr>, <expr>"a/def"</expr> }</block></expr>,
<expr><block>{ <expr>"a"</expr>, <expr>"d"</expr>, <expr>"a/d"</expr> }</block></expr>,
<expr><block>{ <expr>"/"</expr>, <expr>"d"</expr>, <expr>"/d"</expr> }</block></expr>,
<expr><block>{ <expr>"/abc"</expr>, <expr>"d"</expr>, <expr>"/abc/d"</expr> }</block></expr>,
<expr><block>{ <expr>"/abc"</expr>, <expr>"def"</expr>, <expr>"/abc/def"</expr> }</block></expr>,
<expr><block>{ <expr>"/abc"</expr>, <expr>"/def"</expr>, <expr>"/def"</expr> }</block></expr>,
<expr><block>{ <expr>"/abc"</expr>, <expr>"/d"</expr>, <expr>"/d"</expr> }</block></expr>,
<expr><block>{ <expr>"/abc"</expr>, <expr>"/"</expr>, <expr>"/"</expr> }</block></expr>,
<expr><block>{ <expr><name>SVN_EMPTY_PATH</name></expr>, <expr>"/"</expr>, <expr>"/"</expr> }</block></expr>,
<expr><block>{ <expr>"/"</expr>, <expr><name>SVN_EMPTY_PATH</name></expr>, <expr>"/"</expr> }</block></expr>,
<expr><block>{ <expr><name>SVN_EMPTY_PATH</name></expr>, <expr>"abc"</expr>, <expr>"abc"</expr> }</block></expr>,
<expr><block>{ <expr>"abc"</expr>, <expr><name>SVN_EMPTY_PATH</name></expr>, <expr>"abc"</expr> }</block></expr>,
<expr><block>{ <expr><name>SVN_EMPTY_PATH</name></expr>, <expr>"/abc"</expr>, <expr>"/abc"</expr> }</block></expr>,
<expr><block>{ <expr><name>SVN_EMPTY_PATH</name></expr>, <expr><name>SVN_EMPTY_PATH</name></expr>, <expr><name>SVN_EMPTY_PATH</name></expr> }</block></expr>,
}</block></expr></init></decl>;</decl_stmt>
<expr_stmt><expr>*<name>msg</name> = "test svn_path_join(_many)"</expr>;</expr_stmt>
<if>if <condition>(<expr><name>msg_only</name></expr>)</condition><then>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>
<for>for (<init><expr><name>i</name> = <sizeof>sizeof<argument_list>(<argument><expr><name>joins</name></expr></argument>)</argument_list></sizeof> / <sizeof>sizeof<argument_list>(<argument><expr><name><name>joins</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</init> <condition><expr><name>i</name>--</expr>;</condition> <incr/>) <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>base</name> <init>= <expr><name><name>joins</name><index>[<expr><name>i</name></expr>]</index><index>[<expr>0</expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>comp</name> <init>= <expr><name><name>joins</name><index>[<expr><name>i</name></expr>]</index><index>[<expr>1</expr>]</index></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>expect</name> <init>= <expr><name><name>joins</name><index>[<expr><name>i</name></expr>]</index><index>[<expr>2</expr>]</index></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>result</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>comp</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>expect</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_TEST_FAILED</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr>"svn_path_join(\"%s\", \"%s\") returned "
"\"%s\". expected \"%s\""</expr></argument>,
<argument><expr><name>base</name></expr></argument>, <argument><expr><name>comp</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>expect</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>result</name> = <call><name>svn_path_join_many</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>comp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>expect</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_TEST_FAILED</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr>"svn_path_join_many(\"%s\", \"%s\") returned "
"\"%s\". expected \"%s\""</expr></argument>,
<argument><expr><name>base</name></expr></argument>, <argument><expr><name>comp</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>expect</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
}</block></for>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TEST_MANY</name><parameter_list>(<param><type><name>args</name></type></param>, <param><type><name>expect</name></type></param>)</parameter_list></cpp:macro> <cpp:value>result = svn_path_join_many args ; if (strcmp(result, expect) != 0) return svn_error_createf(SVN_ERR_TEST_FAILED, NULL, "svn_path_join_many" #args " returns \"%s\". " "expected \"%s\"", result, expect); else</cpp:value></cpp:define>
<expr_stmt><expr><call><name>TEST_MANY</name><argument_list>(<argument><expr>(<name>pool</name>, "abc", <name>NULL</name>)</expr></argument>, <argument><expr>"abc"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TEST_MANY</name><argument_list>(<argument><expr>(<name>pool</name>, "/abc", <name>NULL</name>)</expr></argument>, <argument><expr>"/abc"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TEST_MANY</name><argument_list>(<argument><expr>(<name>pool</name>, "/", <name>NULL</name>)</expr></argument>, <argument><expr>"/"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TEST_MANY</name><argument_list>(<argument><expr>(<name>pool</name>, "abc", "def", "ghi", <name>NULL</name>)</expr></argument>, <argument><expr>"abc/def/ghi"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TEST_MANY</name><argument_list>(<argument><expr>(<name>pool</name>, "abc", "/def", "ghi", <name>NULL</name>)</expr></argument>, <argument><expr>"/def/ghi"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TEST_MANY</name><argument_list>(<argument><expr>(<name>pool</name>, "/abc", "def", "ghi", <name>NULL</name>)</expr></argument>, <argument><expr>"/abc/def/ghi"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TEST_MANY</name><argument_list>(<argument><expr>(<name>pool</name>, "abc", "def", "/ghi", <name>NULL</name>)</expr></argument>, <argument><expr>"/ghi"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TEST_MANY</name><argument_list>(<argument><expr>(<name>pool</name>, "/", "def", "/ghi", <name>NULL</name>)</expr></argument>, <argument><expr>"/ghi"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TEST_MANY</name><argument_list>(<argument><expr>(<name>pool</name>, "/", "/def", "/ghi", <name>NULL</name>)</expr></argument>, <argument><expr>"/ghi"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TEST_MANY</name><argument_list>(<argument><expr>(<name>pool</name>, <name>SVN_EMPTY_PATH</name>, "def", "ghi", <name>NULL</name>)</expr></argument>, <argument><expr>"def/ghi"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TEST_MANY</name><argument_list>(<argument><expr>(<name>pool</name>, "abc", <name>SVN_EMPTY_PATH</name>, "ghi", <name>NULL</name>)</expr></argument>, <argument><expr>"abc/ghi"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TEST_MANY</name><argument_list>(<argument><expr>(<name>pool</name>, "abc", "def", <name>SVN_EMPTY_PATH</name>, <name>NULL</name>)</expr></argument>, <argument><expr>"abc/def"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TEST_MANY</name><argument_list>(<argument><expr>(<name>pool</name>, <name>SVN_EMPTY_PATH</name>, "def", <name>SVN_EMPTY_PATH</name>, <name>NULL</name>)</expr></argument>, <argument><expr>"def"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TEST_MANY</name><argument_list>(<argument><expr>(<name>pool</name>, <name>SVN_EMPTY_PATH</name>, <name>SVN_EMPTY_PATH</name>, "ghi", <name>NULL</name>)</expr></argument>, <argument><expr>"ghi"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TEST_MANY</name><argument_list>(<argument><expr>(<name>pool</name>, "abc", <name>SVN_EMPTY_PATH</name>, <name>SVN_EMPTY_PATH</name>, <name>NULL</name>)</expr></argument>, <argument><expr>"abc"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TEST_MANY</name><argument_list>(<argument><expr>(<name>pool</name>, <name>SVN_EMPTY_PATH</name>, "def", "/ghi", <name>NULL</name>)</expr></argument>, <argument><expr>"/ghi"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TEST_MANY</name><argument_list>(<argument><expr>(<name>pool</name>, <name>SVN_EMPTY_PATH</name>, <name>SVN_EMPTY_PATH</name>, "/ghi", <name>NULL</name>)</expr></argument>, <argument><expr>"/ghi"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TEST_MANY</name><argument_list>(<argument><expr>(<name>pool</name>, "/", "def", "ghi", <name>NULL</name>)</expr></argument>, <argument><expr>"/def/ghi"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TEST_MANY</name><argument_list>(<argument><expr>(<name>pool</name>, "abc", "/", "ghi", <name>NULL</name>)</expr></argument>, <argument><expr>"/ghi"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TEST_MANY</name><argument_list>(<argument><expr>(<name>pool</name>, "abc", "def", "/", <name>NULL</name>)</expr></argument>, <argument><expr>"/"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TEST_MANY</name><argument_list>(<argument><expr>(<name>pool</name>, "/", "/", "ghi", <name>NULL</name>)</expr></argument>, <argument><expr>"/ghi"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TEST_MANY</name><argument_list>(<argument><expr>(<name>pool</name>, "/", "/", "/", <name>NULL</name>)</expr></argument>, <argument><expr>"/"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TEST_MANY</name><argument_list>(<argument><expr>(<name>pool</name>, "/", <name>SVN_EMPTY_PATH</name>, "ghi", <name>NULL</name>)</expr></argument>, <argument><expr>"/ghi"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TEST_MANY</name><argument_list>(<argument><expr>(<name>pool</name>, "/", "def", <name>SVN_EMPTY_PATH</name>, <name>NULL</name>)</expr></argument>, <argument><expr>"/def"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TEST_MANY</name><argument_list>(<argument><expr>(<name>pool</name>, <name>SVN_EMPTY_PATH</name>, "/", "ghi", <name>NULL</name>)</expr></argument>, <argument><expr>"/ghi"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TEST_MANY</name><argument_list>(<argument><expr>(<name>pool</name>, "/", <name>SVN_EMPTY_PATH</name>, <name>SVN_EMPTY_PATH</name>, <name>NULL</name>)</expr></argument>, <argument><expr>"/"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TEST_MANY</name><argument_list>(<argument><expr>(<name>pool</name>, <name>SVN_EMPTY_PATH</name>, "/", <name>SVN_EMPTY_PATH</name>, <name>NULL</name>)</expr></argument>, <argument><expr>"/"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>TEST_MANY</name><argument_list>(<argument><expr>(<name>pool</name>, <name>SVN_EMPTY_PATH</name>, <name>SVN_EMPTY_PATH</name>, "/", <name>NULL</name>)</expr></argument>, <argument><expr>"/"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>test_basename</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>msg</name></decl></param>,
<param><decl><type><name>svn_boolean_t</name></type> <name>msg_only</name></decl></param>,
<param><decl><type><name>svn_test_opts_t</name> *</type><name>opts</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>result</name></decl>;</decl_stmt>
<struct>struct <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>result</name></decl>;</decl_stmt>
}</block> <decl><name><name>tests</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr>"abc"</expr>, <expr>"abc"</expr> }</block></expr>,
<expr><block>{ <expr>"/abc"</expr>, <expr>"abc"</expr> }</block></expr>,
<expr><block>{ <expr>"/abc"</expr>, <expr>"abc"</expr> }</block></expr>,
<expr><block>{ <expr>"/x/abc"</expr>, <expr>"abc"</expr> }</block></expr>,
<expr><block>{ <expr>"/xx/abc"</expr>, <expr>"abc"</expr> }</block></expr>,
<expr><block>{ <expr>"/xx/abc"</expr>, <expr>"abc"</expr> }</block></expr>,
<expr><block>{ <expr>"/xx/abc"</expr>, <expr>"abc"</expr> }</block></expr>,
<expr><block>{ <expr>"a"</expr>, <expr>"a"</expr> }</block></expr>,
<expr><block>{ <expr>"/a"</expr>, <expr>"a"</expr> }</block></expr>,
<expr><block>{ <expr>"/b/a"</expr>, <expr>"a"</expr> }</block></expr>,
<expr><block>{ <expr>"/b/a"</expr>, <expr>"a"</expr> }</block></expr>,
<expr><block>{ <expr>"/"</expr>, <expr>"/"</expr> }</block></expr>,
<expr><block>{ <expr><name>SVN_EMPTY_PATH</name></expr>, <expr><name>SVN_EMPTY_PATH</name></expr> }</block></expr>,
}</block></expr></init></decl>;</struct>
<expr_stmt><expr>*<name>msg</name> = "test svn_path_basename"</expr>;</expr_stmt>
<if>if <condition>(<expr><name>msg_only</name></expr>)</condition><then>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>
<for>for (<init><expr><name>i</name> = <sizeof>sizeof<argument_list>(<argument><expr><name>tests</name></expr></argument>)</argument_list></sizeof> / <sizeof>sizeof<argument_list>(<argument><expr><name><name>tests</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</init> <condition><expr><name>i</name>--</expr>;</condition> <incr/>) <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name> <init>= <expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>path</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>expect</name> <init>= <expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>result</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>result</name> = <call><name>svn_path_basename</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>expect</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_TEST_FAILED</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr>"svn_path_basename(\"%s\") returned "
"\"%s\". expected \"%s\""</expr></argument>,
<argument><expr><name>path</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>expect</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
}</block></for>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>test_dirname</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>msg</name></decl></param>,
<param><decl><type><name>svn_boolean_t</name></type> <name>msg_only</name></decl></param>,
<param><decl><type><name>svn_test_opts_t</name> *</type><name>opts</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>result</name></decl>;</decl_stmt>
<struct>struct <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>result</name></decl>;</decl_stmt>
}</block> <decl><name><name>tests</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr>"abc"</expr>, <expr>""</expr> }</block></expr>,
<expr><block>{ <expr>"/abc"</expr>, <expr>"/"</expr> }</block></expr>,
<expr><block>{ <expr>"/x/abc"</expr>, <expr>"/x"</expr> }</block></expr>,
<expr><block>{ <expr>"/xx/abc"</expr>, <expr>"/xx"</expr> }</block></expr>,
<expr><block>{ <expr>"a"</expr>, <expr>""</expr> }</block></expr>,
<expr><block>{ <expr>"/a"</expr>, <expr>"/"</expr> }</block></expr>,
<expr><block>{ <expr>"/b/a"</expr>, <expr>"/b"</expr> }</block></expr>,
<expr><block>{ <expr>"/"</expr>, <expr>"/"</expr> }</block></expr>,
<expr><block>{ <expr><name>SVN_EMPTY_PATH</name></expr>, <expr><name>SVN_EMPTY_PATH</name></expr> }</block></expr>,
}</block></expr></init></decl>;</struct>
<expr_stmt><expr>*<name>msg</name> = "test svn_path_dirname"</expr>;</expr_stmt>
<if>if <condition>(<expr><name>msg_only</name></expr>)</condition><then>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>
<for>for (<init><expr><name>i</name> = <sizeof>sizeof<argument_list>(<argument><expr><name>tests</name></expr></argument>)</argument_list></sizeof> / <sizeof>sizeof<argument_list>(<argument><expr><name><name>tests</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</init> <condition><expr><name>i</name>--</expr>;</condition> <incr/>) <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name> <init>= <expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>path</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>expect</name> <init>= <expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>result</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>result</name> = <call><name>svn_path_dirname</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>expect</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_TEST_FAILED</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr>"svn_path_dirname(\"%s\") returned "
"\"%s\". expected \"%s\""</expr></argument>,
<argument><expr><name>path</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>expect</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
}</block></for>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>test_decompose</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>msg</name></decl></param>,
<param><decl><type><name>svn_boolean_t</name></type> <name>msg_only</name></decl></param>,
<param><decl><type><name>svn_test_opts_t</name> *</type><name>opts</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> * <specifier>const</specifier></type> <name><name>paths</name><index>[]</index></name> <init>= <expr><block>{
<expr>"/"</expr>, <expr>"/"</expr>, <expr><name>NULL</name></expr>,
<expr>"foo"</expr>, <expr>"foo"</expr>, <expr><name>NULL</name></expr>,
<expr>"/foo"</expr>, <expr>"/"</expr>, <expr>"foo"</expr>, <expr><name>NULL</name></expr>,
<expr>"/foo/bar"</expr>, <expr>"/"</expr>, <expr>"foo"</expr>, <expr>"bar"</expr>, <expr><name>NULL</name></expr>,
<expr>"foo/bar"</expr>, <expr>"foo"</expr>, <expr>"bar"</expr>, <expr><name>NULL</name></expr>,
<expr>"foo/bar"</expr>, <expr>"foo"</expr>, <expr>"bar"</expr>, <expr><name>NULL</name></expr>,
<expr><name>NULL</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<expr_stmt><expr>*<name>msg</name> = "test svn_path_decompose"</expr>;</expr_stmt>
<if>if <condition>(<expr><name>msg_only</name></expr>)</condition><then>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<if>if <condition>(<expr>! <name><name>paths</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then>
<break>break;</break></then>
<else>else <block>{
<decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>components</name> <init>= <expr><call><name>svn_path_decompose</name><argument_list>(<argument><expr><name><name>paths</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
<for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name><name>components</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr>++<name>j</name></expr></incr>) <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>component</name> <init>= <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>components</name></expr></argument>,
<argument><expr><name>j</name></expr></argument>,
<argument><expr>const <name>char</name>*</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>! <name><name>paths</name><index>[<expr><name>i</name>+<name>j</name>+1</expr>]</index></name></expr>)</condition><then>
<return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_TEST_FAILED</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr>"svn_path_decompose(\"%s\") returned "
"unexpected component \"%s\""</expr></argument>,
<argument><expr><name><name>paths</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>component</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>component</name></expr></argument>, <argument><expr><name><name>paths</name><index>[<expr><name>i</name>+<name>j</name>+1</expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_TEST_FAILED</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr>"svn_path_decompose(\"%s\") returned "
"\"%s\" expected \"%s\""</expr></argument>,
<argument><expr><name><name>paths</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>component</name></expr></argument>, <argument><expr><name><name>paths</name><index>[<expr><name>i</name>+<name>j</name>+1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return></then></if>
}</block></for>
<if>if <condition>(<expr><name><name>paths</name><index>[<expr><name>i</name>+<name>j</name>+1</expr>]</index></name></expr>)</condition><then>
<return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_TEST_FAILED</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr>"svn_path_decompose(\"%s\") failed "
"to return \"%s\""</expr></argument>,
<argument><expr><name><name>paths</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>paths</name><index>[<expr><name>i</name>+<name>j</name>+1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>i</name> += <name><name>components</name>-&gt;<name>nelts</name></name> + 2</expr>;</expr_stmt>
}</block></else></if>
}</block></for>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>test_canonicalize</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>msg</name></decl></param>,
<param><decl><type><name>svn_boolean_t</name></type> <name>msg_only</name></decl></param>,
<param><decl><type><name>svn_test_opts_t</name> *</type><name>opts</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<struct>struct <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>result</name></decl>;</decl_stmt>
}</block> <decl><name><name>tests</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr>""</expr>, <expr>""</expr> }</block></expr>,
<expr><block>{ <expr>"."</expr>, <expr>""</expr> }</block></expr>,
<expr><block>{ <expr>"/"</expr>, <expr>"/"</expr> }</block></expr>,
<expr><block>{ <expr>"/."</expr>, <expr>"/"</expr> }</block></expr>,
<expr><block>{ <expr>"./"</expr>, <expr>""</expr> }</block></expr>,
<expr><block>{ <expr>"./."</expr>, <expr>""</expr> }</block></expr>,
<expr><block>{ <expr>"//"</expr>, <expr>"/"</expr> }</block></expr>,
<expr><block>{ <expr>"/////"</expr>, <expr>"/"</expr> }</block></expr>,
<expr><block>{ <expr>"./././."</expr>, <expr>""</expr> }</block></expr>,
<expr><block>{ <expr>"////././."</expr>, <expr>"/"</expr> }</block></expr>,
<expr><block>{ <expr>"foo"</expr>, <expr>"foo"</expr> }</block></expr>,
<expr><block>{ <expr>".foo"</expr>, <expr>".foo"</expr> }</block></expr>,
<expr><block>{ <expr>"foo."</expr>, <expr>"foo."</expr> }</block></expr>,
<expr><block>{ <expr>"/foo"</expr>, <expr>"/foo"</expr> }</block></expr>,
<expr><block>{ <expr>"foo/"</expr>, <expr>"foo"</expr> }</block></expr>,
<expr><block>{ <expr>"foo./"</expr>, <expr>"foo."</expr> }</block></expr>,
<expr><block>{ <expr>"foo./."</expr>, <expr>"foo."</expr> }</block></expr>,
<expr><block>{ <expr>"foo././/."</expr>, <expr>"foo."</expr> }</block></expr>,
<expr><block>{ <expr>"/foo/bar"</expr>, <expr>"/foo/bar"</expr> }</block></expr>,
<expr><block>{ <expr>"foo/.."</expr>, <expr>"foo/.."</expr> }</block></expr>,
<expr><block>{ <expr>"foo/../"</expr>, <expr>"foo/.."</expr> }</block></expr>,
<expr><block>{ <expr>"foo/../."</expr>, <expr>"foo/.."</expr> }</block></expr>,
<expr><block>{ <expr>"foo//.//bar"</expr>, <expr>"foo/bar"</expr> }</block></expr>,
<expr><block>{ <expr>"///foo"</expr>, <expr>"/foo"</expr> }</block></expr>,
<expr><block>{ <expr>"/.//./.foo"</expr>, <expr>"/.foo"</expr> }</block></expr>,
<expr><block>{ <expr>".///.foo"</expr>, <expr>".foo"</expr> }</block></expr>,
<expr><block>{ <expr>"../foo"</expr>, <expr>"../foo"</expr> }</block></expr>,
<expr><block>{ <expr>"../../foo/"</expr>, <expr>"../../foo"</expr> }</block></expr>,
<expr><block>{ <expr>"../../foo/.."</expr>, <expr>"../../foo/.."</expr> }</block></expr>,
<expr><block>{ <expr>"/../../"</expr>, <expr>"/../.."</expr> }</block></expr>,
<expr><block>{ <expr>"http://hst"</expr>, <expr>"http://hst"</expr> }</block></expr>,
<expr><block>{ <expr>"http://hst/foo/../bar"</expr>,<expr>"http://hst/foo/../bar"</expr> }</block></expr>,
<expr><block>{ <expr>"http://hst/"</expr>, <expr>"http://hst"</expr> }</block></expr>,
<expr><block>{ <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr> }</block></expr>
}</block></expr></init></decl>;</struct>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr>*<name>msg</name> = "test svn_path_canonicalize"</expr>;</expr_stmt>
<if>if <condition>(<expr><name>msg_only</name></expr>)</condition><then>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>
<expr_stmt><expr><name>i</name> = 0</expr>;</expr_stmt>
<while>while <condition>(<expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>path</name></expr>)</condition> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>canonical</name> <init>= <expr><call><name>svn_path_canonicalize</name><argument_list>(<argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>canonical</name></expr></argument>, <argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_TEST_FAILED</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr>"svn_path_canonicalize(\"%s\") returned "
"\"%s\" expected \"%s\""</expr></argument>,
<argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>path</name></expr></argument>, <argument><expr><name>canonical</name></expr></argument>, <argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>result</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr>++<name>i</name></expr>;</expr_stmt>
}</block></while>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>test_remove_component</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>msg</name></decl></param>,
<param><decl><type><name>svn_boolean_t</name></type> <name>msg_only</name></decl></param>,
<param><decl><type><name>svn_test_opts_t</name> *</type><name>opts</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<struct>struct <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>result</name></decl>;</decl_stmt>
}</block> <decl><name><name>tests</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr>""</expr>, <expr>""</expr> }</block></expr>,
<expr><block>{ <expr>"/"</expr>, <expr>"/"</expr> }</block></expr>,
<expr><block>{ <expr>"foo"</expr>, <expr>""</expr> }</block></expr>,
<expr><block>{ <expr>"foo/bar"</expr>, <expr>"foo"</expr> }</block></expr>,
<expr><block>{ <expr>"/foo/bar"</expr>, <expr>"/foo"</expr> }</block></expr>,
<expr><block>{ <expr>"/foo"</expr>, <expr>"/"</expr> }</block></expr>,
<expr><block>{ <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr> }</block></expr>
}</block></expr></init></decl>;</struct>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>buf</name></decl>;</decl_stmt>
<expr_stmt><expr>*<name>msg</name> = "test svn_path_remove_component"</expr>;</expr_stmt>
<if>if <condition>(<expr><name>msg_only</name></expr>)</condition><then>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>
<expr_stmt><expr><name>buf</name> = <call><name>svn_stringbuf_create</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name> = 0</expr>;</expr_stmt>
<while>while <condition>(<expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>path</name></expr>)</condition> <block>{
<expr_stmt><expr><call><name>svn_stringbuf_set</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>svn_path_remove_component</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>buf</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>result</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_TEST_FAILED</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr>"svn_path_remove_component(\"%s\") returned "
"\"%s\" expected \"%s\""</expr></argument>,
<argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>path</name></expr></argument>, <argument><expr><name><name>buf</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>result</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr>++<name>i</name></expr>;</expr_stmt>
}</block></while>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>test_is_root</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>msg</name></decl></param>,
<param><decl><type><name>svn_boolean_t</name></type> <name>msg_only</name></decl></param>,
<param><decl><type><name>svn_test_opts_t</name> *</type><name>opts</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>i</name></decl>;</decl_stmt>
<struct>struct <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>result</name></decl>;</decl_stmt>
}</block> <decl><name><name>tests</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr>"/foo/bar"</expr>, <expr><name>FALSE</name></expr> }</block></expr>,
<expr><block>{ <expr>"/foo"</expr>, <expr><name>FALSE</name></expr> }</block></expr>,
<expr><block>{ <expr>"/"</expr>, <expr><name>TRUE</name></expr> }</block></expr>,
<expr><block>{ <expr>""</expr>, <expr><name>FALSE</name></expr> }</block></expr>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<expr><block>{ <expr>"X:/foo"</expr>, <expr><name>FALSE</name></expr> }</block></expr>,
<expr><block>{ <expr>"X:/"</expr>, <expr><name>TRUE</name></expr> }</block></expr>,
<expr><block>{ <expr>"X:foo"</expr>, <expr><name>FALSE</name></expr> }</block></expr>,
<expr><block>{ <expr>"X:"</expr>, <expr><name>TRUE</name></expr> }</block></expr>,
<expr><block>{ <expr>"//srv/shr"</expr>, <expr><name>TRUE</name></expr> }</block></expr>,
<expr><block>{ <expr>"//srv"</expr>, <expr><name>TRUE</name></expr> }</block></expr>,
<expr><block>{ <expr>"//srv/shr/fld"</expr>, <expr><name>FALSE</name></expr> }</block></expr>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<expr><block>{ <expr>"/X:foo"</expr>, <expr><name>FALSE</name></expr> }</block></expr>,
<expr><block>{ <expr>"/X:"</expr>, <expr><name>FALSE</name></expr> }</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></expr></init></decl>;</struct>
<expr_stmt><expr>*<name>msg</name> = "test svn_dirent_is_root"</expr>;</expr_stmt>
<if>if <condition>(<expr><name>msg_only</name></expr>)</condition><then>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <sizeof>sizeof<argument_list>(<argument><expr><name>tests</name></expr></argument>)</argument_list></sizeof> / <sizeof>sizeof<argument_list>(<argument><expr><name><name>tests</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>retval</name></decl>;</decl_stmt>
<expr_stmt><expr><name>retval</name> = <call><name>svn_dirent_is_root</name><argument_list>(<argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>path</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>result</name> != <name>retval</name></expr>)</condition><then>
<return>return <expr><call><name>svn_error_createf</name>
<argument_list>(<argument><expr><name>SVN_ERR_TEST_FAILED</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr>"svn_dirent_is_root (%s) returned %s instead of %s"</expr></argument>,
<argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>path</name></expr></argument>, <argument><expr><name>retval</name> ? "TRUE" : "FALSE"</expr></argument>,
<argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>result</name> ? "TRUE" : "FALSE"</expr></argument>)</argument_list></call></expr>;</return></then></if>
}</block></for>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>test_path_check_valid</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>msg</name></decl></param>,
<param><decl><type><name>svn_boolean_t</name></type> <name>msg_only</name></decl></param>,
<param><decl><type><name>svn_test_opts_t</name> *</type><name>opts</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>i</name></decl>;</decl_stmt>
<struct>struct <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>result</name></decl>;</decl_stmt>
}</block> <decl><name><name>tests</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr>"/foo/bar"</expr>, <expr><name>TRUE</name></expr> }</block></expr>,
<expr><block>{ <expr>"/foo"</expr>, <expr><name>TRUE</name></expr> }</block></expr>,
<expr><block>{ <expr>"/"</expr>, <expr><name>TRUE</name></expr> }</block></expr>,
<expr><block>{ <expr>"foo/bar"</expr>, <expr><name>TRUE</name></expr> }</block></expr>,
<expr><block>{ <expr>"foo bar"</expr>, <expr><name>TRUE</name></expr> }</block></expr>,
<expr><block>{ <expr>"foo\7bar"</expr>, <expr><name>FALSE</name></expr> }</block></expr>,
<expr><block>{ <expr>"foo\31bar"</expr>, <expr><name>FALSE</name></expr> }</block></expr>,
<expr><block>{ <expr>"\7foo\31bar"</expr>, <expr><name>FALSE</name></expr> }</block></expr>,
<expr><block>{ <expr>"\7"</expr>, <expr><name>FALSE</name></expr> }</block></expr>,
<expr><block>{ <expr>""</expr>, <expr><name>TRUE</name></expr> }</block></expr>,
}</block></expr></init></decl>;</struct>
<expr_stmt><expr>*<name>msg</name> = "test svn_path_check_valid"</expr>;</expr_stmt>
<if>if <condition>(<expr><name>msg_only</name></expr>)</condition><then>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <sizeof>sizeof<argument_list>(<argument><expr><name>tests</name></expr></argument>)</argument_list></sizeof> / <sizeof>sizeof<argument_list>(<argument><expr><name><name>tests</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name> <init>= <expr><call><name>svn_path_check_valid</name><argument_list>(<argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>retval</name> <init>= <expr>(<name>err</name> == <name>SVN_NO_ERROR</name>)</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>result</name> != <name>retval</name></expr>)</condition><then>
<return>return <expr><call><name>svn_error_createf</name>
<argument_list>(<argument><expr><name>SVN_ERR_TEST_FAILED</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr>"svn_path_check_valid (%s) returned %s instead of %s"</expr></argument>,
<argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>path</name></expr></argument>, <argument><expr><name>retval</name> ? "TRUE" : "FALSE"</expr></argument>,
<argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>result</name> ? "TRUE" : "FALSE"</expr></argument>)</argument_list></call></expr>;</return></then></if>
}</block></for>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>test_path_is_ancestor</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>msg</name></decl></param>,
<param><decl><type><name>svn_boolean_t</name></type> <name>msg_only</name></decl></param>,
<param><decl><type><name>svn_test_opts_t</name> *</type><name>opts</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>i</name></decl>;</decl_stmt>
<struct>struct <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path1</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>result</name></decl>;</decl_stmt>
}</block> <decl><name><name>tests</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr>"/foo"</expr>, <expr>"/foo/bar"</expr>, <expr><name>TRUE</name></expr>}</block></expr>,
<expr><block>{ <expr>"/foo/bar"</expr>, <expr>"/foo/bar/"</expr>, <expr><name>TRUE</name></expr>}</block></expr>,
<expr><block>{ <expr>"/"</expr>, <expr>"/foo"</expr>, <expr><name>TRUE</name></expr>}</block></expr>,
<expr><block>{ <expr><name>SVN_EMPTY_PATH</name></expr>, <expr>"foo"</expr>, <expr><name>TRUE</name></expr>}</block></expr>,
<expr><block>{ <expr><name>SVN_EMPTY_PATH</name></expr>, <expr>".bar"</expr>, <expr><name>TRUE</name></expr>}</block></expr>,
<expr><block>{ <expr>"/.bar"</expr>, <expr>"/"</expr>, <expr><name>FALSE</name></expr>}</block></expr>,
<expr><block>{ <expr>"foo/bar"</expr>, <expr>"foo"</expr>, <expr><name>FALSE</name></expr>}</block></expr>,
<expr><block>{ <expr>"/foo/bar"</expr>, <expr>"/foo"</expr>, <expr><name>FALSE</name></expr>}</block></expr>,
<expr><block>{ <expr>"foo"</expr>, <expr>"foo/bar"</expr>, <expr><name>TRUE</name></expr>}</block></expr>,
<expr><block>{ <expr>"foo."</expr>, <expr>"foo./.bar"</expr>, <expr><name>TRUE</name></expr>}</block></expr>,
<expr><block>{ <expr>"../foo"</expr>, <expr>".."</expr>, <expr><name>FALSE</name></expr>}</block></expr>,
<expr><block>{ <expr><name>SVN_EMPTY_PATH</name></expr>, <expr><name>SVN_EMPTY_PATH</name></expr>, <expr><name>TRUE</name></expr>}</block></expr>,
<expr><block>{ <expr>"/"</expr>, <expr>"/"</expr>, <expr><name>TRUE</name></expr>}</block></expr>,
}</block></expr></init></decl>;</struct>
<expr_stmt><expr>*<name>msg</name> = "test svn_path_is_ancestor"</expr>;</expr_stmt>
<if>if <condition>(<expr><name>msg_only</name></expr>)</condition><then>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <sizeof>sizeof<argument_list>(<argument><expr><name>tests</name></expr></argument>)</argument_list></sizeof> / <sizeof>sizeof<argument_list>(<argument><expr><name><name>tests</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>retval</name></decl>;</decl_stmt>
<expr_stmt><expr><name>retval</name> = <call><name>svn_path_is_ancestor</name><argument_list>(<argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>path1</name></expr></argument>, <argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>path2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>result</name> != <name>retval</name></expr>)</condition><then>
<return>return <expr><call><name>svn_error_createf</name>
<argument_list>(<argument><expr><name>SVN_ERR_TEST_FAILED</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr>"svn_path_is_ancestor (%s, %s) returned %s instead of %s"</expr></argument>,
<argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>path1</name></expr></argument>, <argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>path2</name></expr></argument>, <argument><expr><name>retval</name> ? "TRUE" : "FALSE"</expr></argument>,
<argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>result</name> ? "TRUE" : "FALSE"</expr></argument>)</argument_list></call></expr>;</return></then></if>
}</block></for>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>test_is_single_path_component</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>msg</name></decl></param>,
<param><decl><type><name>svn_boolean_t</name></type> <name>msg_only</name></decl></param>,
<param><decl><type><name>svn_test_opts_t</name> *</type><name>opts</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>i</name></decl>;</decl_stmt>
<struct>struct <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>result</name></decl>;</decl_stmt>
}</block> <decl><name><name>tests</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr>"/foo/bar"</expr>, <expr><name>FALSE</name></expr> }</block></expr>,
<expr><block>{ <expr>"/foo"</expr>, <expr><name>FALSE</name></expr> }</block></expr>,
<expr><block>{ <expr>"/"</expr>, <expr><name>FALSE</name></expr> }</block></expr>,
<expr><block>{ <expr>"foo/bar"</expr>, <expr><name>FALSE</name></expr> }</block></expr>,
<expr><block>{ <expr>"foo"</expr>, <expr><name>TRUE</name></expr> }</block></expr>,
<expr><block>{ <expr>"."</expr>, <expr><name>TRUE</name></expr> }</block></expr>,
<expr><block>{ <expr>".."</expr>, <expr><name>FALSE</name></expr> }</block></expr>,
<expr><block>{ <expr>""</expr>, <expr><name>FALSE</name></expr> }</block></expr>,
}</block></expr></init></decl>;</struct>
<expr_stmt><expr>*<name>msg</name> = "test svn_path_is_single_path_component"</expr>;</expr_stmt>
<if>if <condition>(<expr><name>msg_only</name></expr>)</condition><then>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <sizeof>sizeof<argument_list>(<argument><expr><name>tests</name></expr></argument>)</argument_list></sizeof> / <sizeof>sizeof<argument_list>(<argument><expr><name><name>tests</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>retval</name></decl>;</decl_stmt>
<expr_stmt><expr><name>retval</name> = <call><name>svn_path_is_single_path_component</name><argument_list>(<argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>result</name> != <name>retval</name></expr>)</condition><then>
<return>return <expr><call><name>svn_error_createf</name>
<argument_list>(<argument><expr><name>SVN_ERR_TEST_FAILED</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr>"svn_path_is_single_path_component (%s) returned %s instead of %s"</expr></argument>,
<argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>path</name></expr></argument>, <argument><expr><name>retval</name> ? "TRUE" : "FALSE"</expr></argument>,
<argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>result</name> ? "TRUE" : "FALSE"</expr></argument>)</argument_list></call></expr>;</return></then></if>
}</block></for>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>test_compare_paths</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>msg</name></decl></param>,
<param><decl><type><name>svn_boolean_t</name></type> <name>msg_only</name></decl></param>,
<param><decl><type><name>svn_test_opts_t</name> *</type><name>opts</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>i</name></decl>;</decl_stmt>
<struct>struct <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path1</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>
}</block> <decl><name><name>tests</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr>"/foo"</expr>, <expr>"/foo"</expr>, <expr>0</expr>}</block></expr>,
<expr><block>{ <expr>"/foo/bar"</expr>, <expr>"/foo/bar"</expr>, <expr>0</expr>}</block></expr>,
<expr><block>{ <expr>"/"</expr>, <expr>"/"</expr>, <expr>0</expr>}</block></expr>,
<expr><block>{ <expr><name>SVN_EMPTY_PATH</name></expr>, <expr><name>SVN_EMPTY_PATH</name></expr>, <expr>0</expr>}</block></expr>,
<expr><block>{ <expr>"foo"</expr>, <expr>"foo"</expr>, <expr>0</expr>}</block></expr>,
<expr><block>{ <expr>"foo"</expr>, <expr>"foo/bar"</expr>, <expr>-1</expr>}</block></expr>,
<expr><block>{ <expr>"foo/bar"</expr>, <expr>"foo/boo"</expr>, <expr>-1</expr>}</block></expr>,
<expr><block>{ <expr>"boo"</expr>, <expr>"foo"</expr>, <expr>-1</expr>}</block></expr>,
<expr><block>{ <expr>"foo"</expr>, <expr>"boo"</expr>, <expr>1</expr>}</block></expr>,
<expr><block>{ <expr>"foo/bar"</expr>, <expr>"foo"</expr>, <expr>1</expr>}</block></expr>,
<expr><block>{ <expr>"/"</expr>, <expr>"/foo"</expr>, <expr>-1</expr>}</block></expr>,
<expr><block>{ <expr>"/foo"</expr>, <expr>"/foo/bar"</expr>, <expr>-1</expr>}</block></expr>,
<expr><block>{ <expr>"/foo"</expr>, <expr>"/foo/bar/boo"</expr>, <expr>-1</expr>}</block></expr>,
<expr><block>{ <expr>"foo"</expr>, <expr>"/foo"</expr>, <expr>1</expr>}</block></expr>,
<expr><block>{ <expr>"foo\xe0""bar"</expr>, <expr>"foo"</expr>, <expr>1</expr>}</block></expr>,
}</block></expr></init></decl>;</struct>
<expr_stmt><expr>*<name>msg</name> = "test svn_path_compare_paths"</expr>;</expr_stmt>
<if>if <condition>(<expr><name>msg_only</name></expr>)</condition><then>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <sizeof>sizeof<argument_list>(<argument><expr><name>tests</name></expr></argument>)</argument_list></sizeof> / <sizeof>sizeof<argument_list>(<argument><expr><name><name>tests</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>int</name></type> <name>retval</name></decl>;</decl_stmt>
<expr_stmt><expr><name>retval</name> = <call><name>svn_path_compare_paths</name><argument_list>(<argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>path1</name></expr></argument>, <argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>path2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>! (<name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>result</name> * <name>retval</name> &gt; 0 ||
(<name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>result</name> == 0 &amp;&amp; <name>retval</name> == 0))</expr> )</condition><then>
<return>return <expr><call><name>svn_error_createf</name>
<argument_list>(<argument><expr><name>SVN_ERR_TEST_FAILED</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr>"svn_path_compare_paths (%s, %s) returned %d instead of %d"</expr></argument>,
<argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>path1</name></expr></argument>, <argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>path2</name></expr></argument>, <argument><expr><name>retval</name></expr></argument>, <argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>result</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
}</block></for>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>test_get_longest_ancestor</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>msg</name></decl></param>,
<param><decl><type><name>svn_boolean_t</name></type> <name>msg_only</name></decl></param>,
<param><decl><type><name>svn_test_opts_t</name> *</type><name>opts</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>i</name></decl>;</decl_stmt>
<struct>struct <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path1</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path2</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>result</name></decl>;</decl_stmt>
}</block> <decl><name><name>tests</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr>"/foo"</expr>, <expr>"/foo/bar"</expr>, <expr>"/foo"</expr>}</block></expr>,
<expr><block>{ <expr>"/foo/bar"</expr>, <expr>"foo/bar"</expr>, <expr>""</expr>}</block></expr>,
<expr><block>{ <expr>"/"</expr>, <expr>"/foo"</expr>, <expr>"/"</expr>}</block></expr>,
<expr><block>{ <expr><name>SVN_EMPTY_PATH</name></expr>, <expr>"foo"</expr>, <expr><name>SVN_EMPTY_PATH</name></expr>}</block></expr>,
<expr><block>{ <expr><name>SVN_EMPTY_PATH</name></expr>, <expr>".bar"</expr>, <expr><name>SVN_EMPTY_PATH</name></expr>}</block></expr>,
<expr><block>{ <expr>"/.bar"</expr>, <expr>"/"</expr>, <expr>"/"</expr>}</block></expr>,
<expr><block>{ <expr>"foo/bar"</expr>, <expr>"foo"</expr>, <expr>"foo"</expr>}</block></expr>,
<expr><block>{ <expr>"/foo/bar"</expr>, <expr>"/foo"</expr>, <expr>"/foo"</expr>}</block></expr>,
<expr><block>{ <expr>"/rif"</expr>, <expr>"/raf"</expr>, <expr>"/"</expr>}</block></expr>,
<expr><block>{ <expr>"foo"</expr>, <expr>"foo/bar"</expr>, <expr>"foo"</expr>}</block></expr>,
<expr><block>{ <expr>"foo."</expr>, <expr>"foo./.bar"</expr>, <expr>"foo."</expr>}</block></expr>,
<expr><block>{ <expr><name>SVN_EMPTY_PATH</name></expr>, <expr><name>SVN_EMPTY_PATH</name></expr>, <expr><name>SVN_EMPTY_PATH</name></expr>}</block></expr>,
<expr><block>{ <expr>"/"</expr>, <expr>"/"</expr>, <expr>"/"</expr>}</block></expr>,
<expr><block>{ <expr>"http://test"</expr>, <expr>"http://test"</expr>, <expr>"http://test"</expr>}</block></expr>,
<expr><block>{ <expr>"http://test"</expr>, <expr>"http://taste"</expr>, <expr>""</expr>}</block></expr>,
<expr><block>{ <expr>"http://test"</expr>, <expr>"http://test/foo"</expr>, <expr>"http://test"</expr>}</block></expr>,
<expr><block>{ <expr>"http://test"</expr>, <expr>"file://test/foo"</expr>, <expr>""</expr>}</block></expr>,
}</block></expr></init></decl>;</struct>
<expr_stmt><expr>*<name>msg</name> = "test svn_path_get_longest_ancestor"</expr>;</expr_stmt>
<if>if <condition>(<expr><name>msg_only</name></expr>)</condition><then>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <sizeof>sizeof<argument_list>(<argument><expr><name>tests</name></expr></argument>)</argument_list></sizeof> / <sizeof>sizeof<argument_list>(<argument><expr><name><name>tests</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>retval</name></decl>;</decl_stmt>
<expr_stmt><expr><name>retval</name> = <call><name>svn_path_get_longest_ancestor</name><argument_list>(<argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>path1</name></expr></argument>, <argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>path2</name></expr></argument>,
<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>result</name></expr></argument>, <argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>svn_error_createf</name>
<argument_list>(<argument><expr><name>SVN_ERR_TEST_FAILED</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr>"svn_path_get_longest_ancestor (%s, %s) returned %s instead of %s"</expr></argument>,
<argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>path1</name></expr></argument>, <argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>path2</name></expr></argument>, <argument><expr><name>retval</name></expr></argument>, <argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>result</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>retval</name> = <call><name>svn_path_get_longest_ancestor</name><argument_list>(<argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>path2</name></expr></argument>, <argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>path1</name></expr></argument>,
<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>result</name></expr></argument>, <argument><expr><name>retval</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>svn_error_createf</name>
<argument_list>(<argument><expr><name>SVN_ERR_TEST_FAILED</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr>"svn_path_get_longest_ancestor (%s, %s) returned %s instead of %s"</expr></argument>,
<argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>path2</name></expr></argument>, <argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>path1</name></expr></argument>, <argument><expr><name>retval</name></expr></argument>, <argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>result</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
}</block></for>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>test_splitext</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>msg</name></decl></param>,
<param><decl><type><name>svn_boolean_t</name></type> <name>msg_only</name></decl></param>,
<param><decl><type><name>svn_test_opts_t</name> *</type><name>opts</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<struct>struct <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path_root</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path_ext</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>result</name></decl>;</decl_stmt>
}</block> <decl><name><name>tests</name><index>[]</index></name> <init>= <expr><block>{
<expr><block>{ <expr>"no-ext"</expr>, <expr>"no-ext"</expr>, <expr>""</expr> }</block></expr>,
<expr><block>{ <expr>"test-file.py"</expr>, <expr>"test-file."</expr>, <expr>"py"</expr> }</block></expr>,
<expr><block>{ <expr>"period.file.ext"</expr>, <expr>"period.file."</expr>, <expr>"ext"</expr> }</block></expr>,
<expr><block>{ <expr>"multi-component/file.txt"</expr>, <expr>"multi-component/file."</expr>, <expr>"txt"</expr> }</block></expr>,
<expr><block>{ <expr>"yep.still/no-ext"</expr>, <expr>"yep.still/no-ext"</expr>, <expr>""</expr> }</block></expr>,
<expr><block>{ <expr>"folder.with/period.log"</expr>, <expr>"folder.with/period."</expr>, <expr>"log"</expr> }</block></expr>,
<expr><block>{ <expr>"period."</expr>, <expr>"period."</expr>, <expr>""</expr> }</block></expr>,
<expr><block>{ <expr>"file.ends-with/period."</expr>, <expr>"file.ends-with/period."</expr>, <expr>""</expr> }</block></expr>,
<expr><block>{ <expr>"two-periods..txt"</expr>, <expr>"two-periods.."</expr>, <expr>"txt"</expr> }</block></expr>,
<expr><block>{ <expr>".dot-file"</expr>, <expr>".dot-file"</expr>, <expr>""</expr> }</block></expr>,
<expr><block>{ <expr>"sub/.dot-file"</expr>, <expr>"sub/.dot-file"</expr>, <expr>""</expr> }</block></expr>,
<expr><block>{ <expr>".dot-file.withext"</expr>, <expr>".dot-file."</expr>, <expr>"withext"</expr> }</block></expr>,
<expr><block>{ <expr>"sub/.dot-file.withext"</expr>, <expr>"sub/.dot-file."</expr>, <expr>"withext"</expr> }</block></expr>,
<expr><block>{ <expr>"sub/a.out"</expr>, <expr>"sub/a."</expr>, <expr>"out"</expr> }</block></expr>,
<expr><block>{ <expr>"a.out"</expr>, <expr>"a."</expr>, <expr>"out"</expr> }</block></expr>,
<expr><block>{ <expr>""</expr>, <expr>""</expr>, <expr>""</expr> }</block></expr>,
}</block></expr></init></decl>;</struct>
<expr_stmt><expr>*<name>msg</name> = "test svn_path_splitext"</expr>;</expr_stmt>
<if>if <condition>(<expr><name>msg_only</name></expr>)</condition><then>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <sizeof>sizeof<argument_list>(<argument><expr><name>tests</name></expr></argument>)</argument_list></sizeof> / <sizeof>sizeof<argument_list>(<argument><expr><name><name>tests</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name> <init>= <expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>path</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path_root</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path_ext</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>svn_path_splitext</name><argument_list>(<argument><expr>&amp;<name>path_root</name></expr></argument>, <argument><expr>&amp;<name>path_ext</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>(<call><name>strcmp</name><argument_list>(<argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>path_root</name></expr></argument>, <argument><expr><name>path_root</name></expr></argument>)</argument_list></call>)
|| (<call><name>strcmp</name><argument_list>(<argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>path_ext</name></expr></argument>, <argument><expr><name>path_ext</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
<return>return <expr><call><name>svn_error_createf</name>
<argument_list>(<argument><expr><name>SVN_ERR_TEST_FAILED</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr>"svn_path_splitext (%s) returned ('%s', '%s') "
"instead of ('%s', '%s')"</expr></argument>,
<argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>path</name></expr></argument>, <argument><expr><name>path_root</name></expr></argument>, <argument><expr><name>path_ext</name></expr></argument>,
<argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>path_root</name></expr></argument>, <argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>path_ext</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>svn_path_splitext</name><argument_list>(<argument><expr>&amp;<name>path_root</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>path_root</name></expr></argument>, <argument><expr><name>path_root</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>svn_error_createf</name>
<argument_list>(<argument><expr><name>SVN_ERR_TEST_FAILED</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr>"svn_path_splitext (%s) with a NULL path_ext returned '%s' "
"for the path_root instead of '%s'"</expr></argument>,
<argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>path</name></expr></argument>, <argument><expr><name>path_root</name></expr></argument>, <argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>path_root</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>svn_path_splitext</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>path_ext</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>(<call><name>strcmp</name><argument_list>(<argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>path_root</name></expr></argument>, <argument><expr><name>path_root</name></expr></argument>)</argument_list></call>)
|| (<call><name>strcmp</name><argument_list>(<argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>path_ext</name></expr></argument>, <argument><expr><name>path_ext</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
<return>return <expr><call><name>svn_error_createf</name>
<argument_list>(<argument><expr><name>SVN_ERR_TEST_FAILED</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr>"svn_path_splitext (%s) with a NULL path_root returned '%s' "
"for the path_ext instead of '%s'"</expr></argument>,
<argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>path</name></expr></argument>, <argument><expr><name>path_ext</name></expr></argument>, <argument><expr><name><name>tests</name><index>[<expr><name>i</name></expr>]</index></name>.<name>path_ext</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
}</block></for>
<expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>test_compose</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>msg</name></decl></param>,
<param><decl><type><name>svn_boolean_t</name></type> <name>msg_only</name></decl></param>,
<param><decl><type><name>svn_test_opts_t</name> *</type><name>opts</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> * <specifier>const</specifier></type> <name><name>paths</name><index>[]</index></name> <init>= <expr><block>{
<expr>""</expr>,
<expr>"/"</expr>,
<expr>"/foo"</expr>,
<expr>"/foo/bar"</expr>,
<expr>"/foo/bar/baz"</expr>,
<expr>"foo"</expr>,
<expr>"foo/bar"</expr>,
<expr>"foo/bar/baz"</expr>,
<expr><name>NULL</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> * <specifier>const</specifier> *</type><name>path_ptr</name> <init>= <expr><name>paths</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>input_path</name></decl>;</decl_stmt>
<expr_stmt><expr>*<name>msg</name> = "test svn_path_decompose"</expr>;</expr_stmt>
<if>if <condition>(<expr><name>msg_only</name></expr>)</condition><then>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>
<for>for (<init><expr><name>input_path</name> = *<name>path_ptr</name></expr>;</init> <condition><expr>*<name>path_ptr</name></expr>;</condition> <incr><expr><name>input_path</name> = *++<name>path_ptr</name></expr></incr>) <block>{
<decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>components</name> <init>= <expr><call><name>svn_path_decompose</name><argument_list>(<argument><expr><name>input_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>output_path</name> <init>= <expr><call><name>svn_path_compose</name><argument_list>(<argument><expr><name>components</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>input_path</name></expr></argument>, <argument><expr><name>output_path</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_TEST_FAILED</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr>"svn_path_compose("
"svn_path_decompose(\"%s\")) "
"returned \"%s\" expected \"%s\""</expr></argument>,
<argument><expr><name>input_path</name></expr></argument>, <argument><expr><name>output_path</name></expr></argument>, <argument><expr><name>input_path</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
}</block></for>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WINDOWS_OR_CYGWIN</name></cpp:macro> <cpp:value>TRUE</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WINDOWS_OR_CYGWIN</name></cpp:macro> <cpp:value>FALSE</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<decl_stmt><decl><type>struct <name>svn_test_descriptor_t</name></type> <name><name>test_funcs</name><index>[]</index></name> <init>= <expr><block>{
<expr><name>SVN_TEST_NULL</name></expr>,
<expr><call><name>SVN_TEST_PASS</name><argument_list>(<argument><expr><name>test_path_is_child</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>SVN_TEST_PASS</name><argument_list>(<argument><expr><name>test_path_split</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>SVN_TEST_PASS</name><argument_list>(<argument><expr><name>test_is_url</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>SVN_TEST_PASS</name><argument_list>(<argument><expr><name>test_is_uri_safe</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>SVN_TEST_PASS</name><argument_list>(<argument><expr><name>test_uri_encode</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>SVN_TEST_PASS</name><argument_list>(<argument><expr><name>test_uri_decode</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>SVN_TEST_PASS</name><argument_list>(<argument><expr><name>test_uri_autoescape</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>SVN_TEST_PASS</name><argument_list>(<argument><expr><name>test_uri_from_iri</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>SVN_TEST_PASS</name><argument_list>(<argument><expr><name>test_join</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>SVN_TEST_PASS</name><argument_list>(<argument><expr><name>test_basename</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>SVN_TEST_PASS</name><argument_list>(<argument><expr><name>test_dirname</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>SVN_TEST_PASS</name><argument_list>(<argument><expr><name>test_decompose</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>SVN_TEST_PASS</name><argument_list>(<argument><expr><name>test_canonicalize</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>SVN_TEST_PASS</name><argument_list>(<argument><expr><name>test_remove_component</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>SVN_TEST_PASS</name><argument_list>(<argument><expr><name>test_is_root</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>SVN_TEST_PASS</name><argument_list>(<argument><expr><name>test_path_is_ancestor</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>SVN_TEST_PASS</name><argument_list>(<argument><expr><name>test_path_check_valid</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>SVN_TEST_PASS</name><argument_list>(<argument><expr><name>test_is_single_path_component</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>SVN_TEST_PASS</name><argument_list>(<argument><expr><name>test_compare_paths</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>SVN_TEST_PASS</name><argument_list>(<argument><expr><name>test_get_longest_ancestor</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>SVN_TEST_PASS</name><argument_list>(<argument><expr><name>test_splitext</name></expr></argument>)</argument_list></call></expr>,
<expr><call><name>SVN_TEST_PASS</name><argument_list>(<argument><expr><name>test_compose</name></expr></argument>)</argument_list></call></expr>,
<expr><name>SVN_TEST_NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>
</unit>
