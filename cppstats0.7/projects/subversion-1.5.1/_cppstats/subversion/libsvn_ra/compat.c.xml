<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="subversion/libsvn_ra/compat.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_pools.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_error.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_pools.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_sorts.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_path.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_ra.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_io.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_compat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ra_loader.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_private_config.h"</cpp:file></cpp:include>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compare_revisions</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>a</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>b</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>a_rev</name> <init>= <expr>*(const <name>svn_revnum_t</name> *)<name>a</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>b_rev</name> <init>= <expr>*(const <name>svn_revnum_t</name> *)<name>b</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>a_rev</name> == <name>b_rev</name></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<return>return <expr><name>a_rev</name> &lt; <name>b_rev</name> ? -1 : 1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>prev_log_path</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>prev_path_p</name></decl></param>,
<param><decl><type><name>char</name> *</type><name>action_p</name></decl></param>,
<param><decl><type><name>svn_revnum_t</name> *</type><name>copyfrom_rev_p</name></decl></param>,
<param><decl><type><name>apr_hash_t</name> *</type><name>changed_paths</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
<param><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl></param>,
<param><decl><type><name>svn_revnum_t</name></type> <name>revision</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>svn_log_changed_path_t</name> *</type><name>change</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>prev_path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>action_p</name></expr>)</condition><then>
<expr_stmt><expr>*<name>action_p</name> = 'M'</expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>copyfrom_rev_p</name></expr>)</condition><then>
<expr_stmt><expr>*<name>copyfrom_rev_p</name> = <name>SVN_INVALID_REVNUM</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>changed_paths</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>change</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>changed_paths</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>change</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>change</name>-&gt;<name>action</name></name> != 'A' &amp;&amp; <name><name>change</name>-&gt;<name>action</name></name> != 'R'</expr>)</condition><then> <block>{
<expr_stmt><expr><name>prev_path</name> = <name>path</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<if>if <condition>(<expr><name><name>change</name>-&gt;<name>copyfrom_path</name></name></expr>)</condition><then>
<expr_stmt><expr><name>prev_path</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>change</name>-&gt;<name>copyfrom_path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>prev_path</name> = <name>NULL</name></expr>;</expr_stmt></else></if>
<expr_stmt><expr>*<name>prev_path_p</name> = <name>prev_path</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>action_p</name></expr>)</condition><then>
<expr_stmt><expr>*<name>action_p</name> = <name><name>change</name>-&gt;<name>action</name></name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>copyfrom_rev_p</name></expr>)</condition><then>
<expr_stmt><expr>*<name>copyfrom_rev_p</name> = <name><name>change</name>-&gt;<name>copyfrom_rev</name></name></expr>;</expr_stmt></then></if>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></else></if>
}</block></then></if>
<if>if <condition>(<expr><call><name>apr_hash_count</name><argument_list>(<argument><expr><name>changed_paths</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>paths</name></decl>;</decl_stmt>
<expr_stmt><expr><name>paths</name> = <call><name>svn_sort__hash</name><argument_list>(<argument><expr><name>changed_paths</name></expr></argument>,
<argument><expr><name>svn_sort_compare_items_as_paths</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = <name><name>paths</name>-&gt;<name>nelts</name></name></expr>;</init> <condition><expr><name>i</name> &gt; 0</expr>;</condition> <incr><expr><name>i</name>--</expr></incr>) <block>{
<decl_stmt><decl><type><name>svn_sort__item_t</name></type> <name>item</name> <init>= <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>paths</name></expr></argument>,
<argument><expr><name>i</name> - 1</expr></argument>, <argument><expr><name>svn_sort__item_t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ch_path</name> <init>= <expr><name><name>item</name>.<name>key</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>ch_path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>! ((<call><name>strncmp</name><argument_list>(<argument><expr><name>ch_path</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> == 0) &amp;&amp; (<name><name>path</name><index>[<expr><name>len</name></expr>]</index></name> == '/'))</expr>)</condition><then>
<continue>continue;</continue></then></if>
<expr_stmt><expr><name>change</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>changed_paths</name></expr></argument>, <argument><expr><name>ch_path</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>change</name>-&gt;<name>copyfrom_path</name></name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>action_p</name></expr>)</condition><then>
<expr_stmt><expr>*<name>action_p</name> = <name><name>change</name>-&gt;<name>action</name></name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>copyfrom_rev_p</name></expr>)</condition><then>
<expr_stmt><expr>*<name>copyfrom_rev_p</name> = <name><name>change</name>-&gt;<name>copyfrom_rev</name></name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>prev_path</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name><name>change</name>-&gt;<name>copyfrom_path</name></name></expr></argument>,
<argument><expr><name>path</name> + <name>len</name> + 1</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
}</block></for>
}</block></then></if>
}</block></then></if>
<if>if <condition>(<expr>! <name>prev_path</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>kind</name> == <name>svn_node_dir</name></expr>)</condition><then>
<expr_stmt><expr><name>prev_path</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_CLIENT_UNRELATED_RESOURCES</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr>"Missing changed-path information for "
"'%s' in revision %ld"</expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>revision</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></then></if>
<expr_stmt><expr>*<name>prev_path_p</name> = <name>prev_path</name></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<struct>struct <name>log_receiver_baton</name> <block>{
<decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>last_path</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>peg_revision</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>location_revisions</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>peg_path</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>locations</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>
}</block>;</struct>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>log_receiver</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>,
<param><decl><type><name>svn_log_entry_t</name> *</type><name>log_entry</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>log_receiver_baton</name> *</type><name>lrb</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>hash_pool</name> <init>= <expr><call><name>apr_hash_pool_get</name><argument_list>(<argument><expr><name><name>lrb</name>-&gt;<name>locations</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>current_path</name> <init>= <expr><name><name>lrb</name>-&gt;<name>last_path</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>prev_path</name></decl>;</decl_stmt>
<if>if <condition>(<expr>! <name><name>log_entry</name>-&gt;<name>changed_paths</name></name></expr>)</condition><then>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>
<if>if <condition>(<expr>! <name>current_path</name></expr>)</condition><then>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>
<if>if <condition>(<expr>(! <name><name>lrb</name>-&gt;<name>peg_path</name></name>) &amp;&amp; (<name><name>log_entry</name>-&gt;<name>revision</name></name> &lt;= <name><name>lrb</name>-&gt;<name>peg_revision</name></name>)</expr>)</condition><then>
<expr_stmt><expr><name><name>lrb</name>-&gt;<name>peg_path</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>lrb</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>current_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<while>while <condition>(<expr><name><name>lrb</name>-&gt;<name>location_revisions</name>-&gt;<name>nelts</name></name></expr>)</condition> <block>{
<decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>next</name> <init>= <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name><name>lrb</name>-&gt;<name>location_revisions</name></name></expr></argument>,
<argument><expr><name><name>lrb</name>-&gt;<name>location_revisions</name>-&gt;<name>nelts</name></name> - 1</expr></argument>,
<argument><expr><name>svn_revnum_t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>log_entry</name>-&gt;<name>revision</name></name> &lt;= <name>next</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name><name>lrb</name>-&gt;<name>locations</name></name></expr></argument>,
<argument><expr><call><name>apr_pmemdup</name><argument_list>(<argument><expr><name>hash_pool</name></expr></argument>, <argument><expr>&amp;<name>next</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>next</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>next</name></expr></argument>)</argument_list></sizeof></expr></argument>,
<argument><expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>hash_pool</name></expr></argument>, <argument><expr><name>current_path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_array_pop</name><argument_list>(<argument><expr><name><name>lrb</name>-&gt;<name>location_revisions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else
<break>break;</break></else></if>
}</block></while>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>prev_log_path</name><argument_list>(<argument><expr>&amp;<name>prev_path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>log_entry</name>-&gt;<name>changed_paths</name></name></expr></argument>,
<argument><expr><name>current_path</name></expr></argument>, <argument><expr><name><name>lrb</name>-&gt;<name>kind</name></name></expr></argument>, <argument><expr><name><name>log_entry</name>-&gt;<name>revision</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>! <name>prev_path</name></expr>)</condition><then>
<expr_stmt><expr><name><name>lrb</name>-&gt;<name>last_path</name></name> = <name>NULL</name></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>prev_path</name></expr></argument>, <argument><expr><name>current_path</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
<expr_stmt><expr><name><name>lrb</name>-&gt;<name>last_path</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>lrb</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>prev_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><name>svn_error_t</name> *</type>
<name>svn_ra__locations_from_log</name><parameter_list>(<param><decl><type><name>svn_ra_session_t</name> *</type><name>session</name></decl></param>,
<param><decl><type><name>apr_hash_t</name> **</type><name>locations_p</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
<param><decl><type><name>svn_revnum_t</name></type> <name>peg_revision</name></decl></param>,
<param><decl><type><name>apr_array_header_t</name> *</type><name>location_revisions</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>locations</name> <init>= <expr><call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>log_receiver_baton</name></type> <name>lrb</name> <init>= <expr><block>{ <expr>0</expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>targets</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>youngest_requested</name></decl>, <decl><type ref="prev"/><name>oldest_requested</name></decl>, <decl><type ref="prev"/><name>youngest</name></decl>, <decl><type ref="prev"/><name>oldest</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>root_url</name></decl>, *<decl><type ref="prev"/><name>url</name></decl>, *<decl><type ref="prev"/><name>rel_path</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_get_repos_root2</name><argument_list>(<argument><expr><name>session</name></expr></argument>, <argument><expr>&amp;<name>root_url</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_get_session_url</name><argument_list>(<argument><expr><name>session</name></expr></argument>, <argument><expr>&amp;<name>url</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>url</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>url</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rel_path</name> = <call><name>svn_path_uri_decode</name><argument_list>(<argument><expr><name>url</name> + <call><name>strlen</name><argument_list>(<argument><expr><name>root_url</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_check_path</name><argument_list>(<argument><expr><name>session</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>peg_revision</name></expr></argument>, <argument><expr>&amp;<name>kind</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>kind</name> == <name>svn_node_none</name></expr>)</condition><then>
<return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_FS_NOT_FOUND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr>"Path '%s' doesn't exist in revision %ld"</expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>rel_path</name></expr></argument>, <argument><expr><name>peg_revision</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr>! <name><name>location_revisions</name>-&gt;<name>nelts</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>locations_p</name> = <name>locations</name></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name><name>location_revisions</name>-&gt;<name>elts</name></name></expr></argument>, <argument><expr><name><name>location_revisions</name>-&gt;<name>nelts</name></name></expr></argument>,
<argument><expr><name><name>location_revisions</name>-&gt;<name>elt_size</name></name></expr></argument>, <argument><expr><name>compare_revisions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>oldest_requested</name> = <call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>location_revisions</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>svn_revnum_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>youngest_requested</name> = <call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>location_revisions</name></expr></argument>,
<argument><expr><name><name>location_revisions</name>-&gt;<name>nelts</name></name> - 1</expr></argument>,
<argument><expr><name>svn_revnum_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>youngest</name> = <name>peg_revision</name></expr>;</expr_stmt>
<expr_stmt><expr><name>youngest</name> = (<name>oldest_requested</name> &gt; <name>youngest</name>) ? <name>oldest_requested</name> : <name>youngest</name></expr>;</expr_stmt>
<expr_stmt><expr><name>youngest</name> = (<name>youngest_requested</name> &gt; <name>youngest</name>) ? <name>youngest_requested</name> : <name>youngest</name></expr>;</expr_stmt>
<expr_stmt><expr><name>oldest</name> = <name>peg_revision</name></expr>;</expr_stmt>
<expr_stmt><expr><name>oldest</name> = (<name>oldest_requested</name> &lt; <name>oldest</name>) ? <name>oldest_requested</name> : <name>oldest</name></expr>;</expr_stmt>
<expr_stmt><expr><name>oldest</name> = (<name>youngest_requested</name> &lt; <name>oldest</name>) ? <name>youngest_requested</name> : <name>oldest</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lrb</name>.<name>kind</name></name> = <name>kind</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lrb</name>.<name>last_path</name></name> = <name>rel_path</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lrb</name>.<name>location_revisions</name></name> = <call><name>apr_array_copy</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>location_revisions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lrb</name>.<name>peg_revision</name></name> = <name>peg_revision</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lrb</name>.<name>peg_path</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lrb</name>.<name>locations</name></name> = <name>locations</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lrb</name>.<name>pool</name></name> = <name>pool</name></expr>;</expr_stmt>
<expr_stmt><expr><name>targets</name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>const <name>char</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>targets</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call> = <name>path</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_get_log2</name><argument_list>(<argument><expr><name>session</name></expr></argument>, <argument><expr><name>targets</name></expr></argument>, <argument><expr><name>youngest</name></expr></argument>, <argument><expr><name>oldest</name></expr></argument>, <argument><expr>0</expr></argument>,
<argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
<argument><expr><call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>const <name>char</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>log_receiver</name></expr></argument>, <argument><expr>&amp;<name>lrb</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>! <name><name>lrb</name>.<name>peg_path</name></name></expr>)</condition><then>
<expr_stmt><expr><name><name>lrb</name>.<name>peg_path</name></name> = <name><name>lrb</name>.<name>last_path</name></name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name><name>lrb</name>.<name>last_path</name></name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>location_revisions</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>rev</name> <init>= <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>location_revisions</name></expr></argument>, <argument><expr><name>i</name></expr></argument>,
<argument><expr><name>svn_revnum_t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>! <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>locations</name></expr></argument>, <argument><expr>&amp;<name>rev</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>rev</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>locations</name></expr></argument>, <argument><expr><call><name>apr_pmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>&amp;<name>rev</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>rev</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>rev</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>lrb</name>.<name>last_path</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></for>
}</block></then></if>
<if>if <condition>(<expr>! <name><name>lrb</name>.<name>peg_path</name></name></expr>)</condition><then>
<return>return <expr><call><name>svn_error_createf</name>
<argument_list>(<argument><expr><name>APR_EGENERAL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr>"Unable to find repository location for '%s' in revision %ld"</expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>rel_path</name></expr></argument>, <argument><expr><name>peg_revision</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>rel_path</name></expr></argument>, <argument><expr><name><name>lrb</name>.<name>peg_path</name></name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
<return>return <expr><call><name>svn_error_createf</name>
<argument_list>(<argument><expr><name>SVN_ERR_CLIENT_UNRELATED_RESOURCES</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr>"'%s' in revision %ld is an unrelated object"</expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>rel_path</name></expr></argument>, <argument><expr><name>youngest</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr>*<name>locations_p</name> = <name>locations</name></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<struct>struct <name>gls_log_receiver_baton</name> <block>{
<decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>done</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>last_path</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>start_rev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>range_end</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_location_segment_receiver_t</name></type> <name>receiver</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> *</type><name>receiver_baton</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>
}</block>;</struct>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>maybe_crop_and_send_segment</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
<param><decl><type><name>svn_revnum_t</name></type> <name>start_rev</name></decl></param>,
<param><decl><type><name>svn_revnum_t</name></type> <name>range_start</name></decl></param>,
<param><decl><type><name>svn_revnum_t</name></type> <name>range_end</name></decl></param>,
<param><decl><type><name>svn_location_segment_receiver_t</name></type> <name>receiver</name></decl></param>,
<param><decl><type><name>void</name> *</type><name>receiver_baton</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>svn_location_segment_t</name> *</type><name>segment</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>segment</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>segment</name>-&gt;<name>path</name></name> = <name>path</name> ? ((*<name>path</name> == '/') ? <name>path</name> + 1 : <name>path</name>) : <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>segment</name>-&gt;<name>range_start</name></name> = <name>range_start</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>segment</name>-&gt;<name>range_end</name></name> = <name>range_end</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>segment</name>-&gt;<name>range_start</name></name> &lt;= <name>start_rev</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>segment</name>-&gt;<name>range_end</name></name> &gt; <name>start_rev</name></expr>)</condition><then>
<expr_stmt><expr><name><name>segment</name>-&gt;<name>range_end</name></name> = <name>start_rev</name></expr>;</expr_stmt></then></if>
<return>return <expr><call><name>receiver</name><argument_list>(<argument><expr><name>segment</name></expr></argument>, <argument><expr><name>receiver_baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>gls_log_receiver</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>,
<param><decl><type><name>svn_log_entry_t</name> *</type><name>log_entry</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>gls_log_receiver_baton</name> *</type><name>lrb</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>current_path</name> <init>= <expr><name><name>lrb</name>-&gt;<name>last_path</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>prev_path</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>copyfrom_rev</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>lrb</name>-&gt;<name>done</name></name></expr>)</condition><then>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>prev_log_path</name><argument_list>(<argument><expr>&amp;<name>prev_path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>copyfrom_rev</name></expr></argument>,
<argument><expr><name><name>log_entry</name>-&gt;<name>changed_paths</name></name></expr></argument>, <argument><expr><name>current_path</name></expr></argument>,
<argument><expr><name><name>lrb</name>-&gt;<name>kind</name></name></expr></argument>, <argument><expr><name><name>log_entry</name>-&gt;<name>revision</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>! <name>prev_path</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>lrb</name>-&gt;<name>done</name></name> = <name>TRUE</name></expr>;</expr_stmt>
<return>return <expr><call><name>maybe_crop_and_send_segment</name><argument_list>(<argument><expr><name>current_path</name></expr></argument>, <argument><expr><name><name>lrb</name>-&gt;<name>start_rev</name></name></expr></argument>,
<argument><expr><name><name>log_entry</name>-&gt;<name>revision</name></name></expr></argument>, <argument><expr><name><name>lrb</name>-&gt;<name>range_end</name></name></expr></argument>,
<argument><expr><name><name>lrb</name>-&gt;<name>receiver</name></name></expr></argument>, <argument><expr><name><name>lrb</name>-&gt;<name>receiver_baton</name></name></expr></argument>,
<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name>copyfrom_rev</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>maybe_crop_and_send_segment</name><argument_list>(<argument><expr><name>current_path</name></expr></argument>, <argument><expr><name><name>lrb</name>-&gt;<name>start_rev</name></name></expr></argument>,
<argument><expr><name><name>log_entry</name>-&gt;<name>revision</name></name></expr></argument>, <argument><expr><name><name>lrb</name>-&gt;<name>range_end</name></name></expr></argument>,
<argument><expr><name><name>lrb</name>-&gt;<name>receiver</name></name></expr></argument>, <argument><expr><name><name>lrb</name>-&gt;<name>receiver_baton</name></name></expr></argument>,
<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lrb</name>-&gt;<name>range_end</name></name> = <name><name>log_entry</name>-&gt;<name>revision</name></name> - 1</expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>log_entry</name>-&gt;<name>revision</name></name> - <name>copyfrom_rev</name> &gt; 1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>maybe_crop_and_send_segment</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>lrb</name>-&gt;<name>start_rev</name></name></expr></argument>,
<argument><expr><name>copyfrom_rev</name> + 1</expr></argument>, <argument><expr><name><name>lrb</name>-&gt;<name>range_end</name></name></expr></argument>,
<argument><expr><name><name>lrb</name>-&gt;<name>receiver</name></name></expr></argument>,
<argument><expr><name><name>lrb</name>-&gt;<name>receiver_baton</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lrb</name>-&gt;<name>range_end</name></name> = <name>copyfrom_rev</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name><name>lrb</name>-&gt;<name>last_path</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>lrb</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>prev_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><name>svn_error_t</name> *</type>
<name>svn_ra__location_segments_from_log</name><parameter_list>(<param><decl><type><name>svn_ra_session_t</name> *</type><name>session</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
<param><decl><type><name>svn_revnum_t</name></type> <name>peg_revision</name></decl></param>,
<param><decl><type><name>svn_revnum_t</name></type> <name>start_rev</name></decl></param>,
<param><decl><type><name>svn_revnum_t</name></type> <name>end_rev</name></decl></param>,
<param><decl><type><name>svn_location_segment_receiver_t</name></type> <name>receiver</name></decl></param>,
<param><decl><type><name>void</name> *</type><name>receiver_baton</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>gls_log_receiver_baton</name></type> <name>lrb</name> <init>= <expr><block>{ <expr>0</expr> }</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>targets</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>youngest_rev</name> <init>= <expr><name>SVN_INVALID_REVNUM</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>root_url</name></decl>, *<decl><type ref="prev"/><name>url</name></decl>, *<decl><type ref="prev"/><name>rel_path</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_get_repos_root2</name><argument_list>(<argument><expr><name>session</name></expr></argument>, <argument><expr>&amp;<name>root_url</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_get_session_url</name><argument_list>(<argument><expr><name>session</name></expr></argument>, <argument><expr>&amp;<name>url</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>url</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>url</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>rel_path</name> = <call><name>svn_path_uri_decode</name><argument_list>(<argument><expr><name>url</name> + <call><name>strlen</name><argument_list>(<argument><expr><name>root_url</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>! <call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name>peg_revision</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_get_latest_revnum</name><argument_list>(<argument><expr><name>session</name></expr></argument>, <argument><expr>&amp;<name>youngest_rev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>peg_revision</name> = <name>youngest_rev</name></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr>! <call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name>start_rev</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name>youngest_rev</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>start_rev</name> = <name>youngest_rev</name></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_get_latest_revnum</name><argument_list>(<argument><expr><name>session</name></expr></argument>, <argument><expr>&amp;<name>start_rev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
}</block></then></if>
<if>if <condition>(<expr>! <call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name>end_rev</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>end_rev</name> = 0</expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>(<name>peg_revision</name> &gt;= <name>start_rev</name>) &amp;&amp; (<name>start_rev</name> &gt;= <name>end_rev</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_check_path</name><argument_list>(<argument><expr><name>session</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>peg_revision</name></expr></argument>, <argument><expr>&amp;<name>kind</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>kind</name> == <name>svn_node_none</name></expr>)</condition><then>
<return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_FS_NOT_FOUND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr>"Path '%s' doesn't exist in revision %ld"</expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>rel_path</name></expr></argument>, <argument><expr><name>start_rev</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name><name>lrb</name>.<name>kind</name></name> = <name>kind</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lrb</name>.<name>last_path</name></name> = <name>rel_path</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lrb</name>.<name>done</name></name> = <name>FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lrb</name>.<name>start_rev</name></name> = <name>start_rev</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lrb</name>.<name>range_end</name></name> = <name>start_rev</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lrb</name>.<name>receiver</name></name> = <name>receiver</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lrb</name>.<name>receiver_baton</name></name> = <name>receiver_baton</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lrb</name>.<name>pool</name></name> = <name>pool</name></expr>;</expr_stmt>
<expr_stmt><expr><name>targets</name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>const <name>char</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>targets</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call> = <name>path</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_get_log2</name><argument_list>(<argument><expr><name>session</name></expr></argument>, <argument><expr><name>targets</name></expr></argument>, <argument><expr><name>peg_revision</name></expr></argument>, <argument><expr><name>end_rev</name></expr></argument>, <argument><expr>0</expr></argument>,
<argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
<argument><expr><call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>const <name>char</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>gls_log_receiver</name></expr></argument>, <argument><expr>&amp;<name>lrb</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>! <name><name>lrb</name>.<name>done</name></name></expr>)</condition><then>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>maybe_crop_and_send_segment</name><argument_list>(<argument><expr><name><name>lrb</name>.<name>last_path</name></name></expr></argument>, <argument><expr><name>start_rev</name></expr></argument>,
<argument><expr><name>end_rev</name></expr></argument>, <argument><expr><name><name>lrb</name>.<name>range_end</name></name></expr></argument>,
<argument><expr><name>receiver</name></expr></argument>, <argument><expr><name>receiver_baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<struct>struct <name>rev</name> <block>{
<decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>revision</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>props</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>rev</name> *</type><name>next</name></decl>;</decl_stmt>
}</block>;</struct>
<struct>struct <name>fr_log_message_baton</name> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>rev</name> *</type><name>eldest</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name>action</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>copyrev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>
}</block>;</struct>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>fr_log_message_receiver</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>,
<param><decl><type><name>svn_log_entry_t</name> *</type><name>log_entry</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>fr_log_message_baton</name> *</type><name>lmb</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>rev</name> *</type><name>rev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>
<expr_stmt><expr><name>rev</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>lmb</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>rev</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rev</name>-&gt;<name>revision</name></name> = <name><name>log_entry</name>-&gt;<name>revision</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rev</name>-&gt;<name>path</name></name> = <name><name>lmb</name>-&gt;<name>path</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rev</name>-&gt;<name>next</name></name> = <name><name>lmb</name>-&gt;<name>eldest</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lmb</name>-&gt;<name>eldest</name></name> = <name>rev</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>rev</name>-&gt;<name>props</name></name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name><name>lmb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>log_entry</name>-&gt;<name>revprops</name></name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>hi</name></expr>;</condition>
<incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>) <block>{
<decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name><name>rev</name>-&gt;<name>props</name></name></expr></argument>, <argument><expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>lmb</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>,
<argument><expr><call><name>svn_string_dup</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name><name>lmb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<return>return <expr><call><name>prev_log_path</name><argument_list>(<argument><expr>&amp;<name><name>lmb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr>&amp;<name><name>lmb</name>-&gt;<name>action</name></name></expr></argument>,
<argument><expr>&amp;<name><name>lmb</name>-&gt;<name>copyrev</name></name></expr></argument>, <argument><expr><name><name>log_entry</name>-&gt;<name>changed_paths</name></name></expr></argument>,
<argument><expr><name><name>lmb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>svn_node_file</name></expr></argument>, <argument><expr><name><name>log_entry</name>-&gt;<name>revision</name></name></expr></argument>,
<argument><expr><name><name>lmb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>svn_error_t</name> *</type>
<name>svn_ra__file_revs_from_log</name><parameter_list>(<param><decl><type><name>svn_ra_session_t</name> *</type><name>ra_session</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
<param><decl><type><name>svn_revnum_t</name></type> <name>start</name></decl></param>,
<param><decl><type><name>svn_revnum_t</name></type> <name>end</name></decl></param>,
<param><decl><type><name>svn_file_rev_handler_t</name></type> <name>handler</name></decl></param>,
<param><decl><type><name>void</name> *</type><name>handler_baton</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>repos_url</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>session_url</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>tmp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>repos_abs_path</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>condensed_targets</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>fr_log_message_baton</name></type> <name>lmb</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>rev</name> *</type><name>rev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>last_props</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>last_path</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>last_stream</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>currpool</name></decl>, *<decl><type ref="prev"/><name>lastpool</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_get_repos_root2</name><argument_list>(<argument><expr><name>ra_session</name></expr></argument>, <argument><expr>&amp;<name>repos_url</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_get_session_url</name><argument_list>(<argument><expr><name>ra_session</name></expr></argument>, <argument><expr>&amp;<name>session_url</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tmp</name> = <call><name>svn_path_is_child</name><argument_list>(<argument><expr><name>repos_url</name></expr></argument>, <argument><expr><name>session_url</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>repos_abs_path</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>repos_abs_path</name><index>[<expr>0</expr>]</index></name> = '/'</expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>repos_abs_path</name> + 1</expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_check_path</name><argument_list>(<argument><expr><name>ra_session</name></expr></argument>, <argument><expr>""</expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr>&amp;<name>kind</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>kind</name> == <name>svn_node_dir</name></expr>)</condition><then>
<return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_FS_NOT_FILE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr>"'%s' is not a file"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>repos_abs_path</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>condensed_targets</name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>const <name>char</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>condensed_targets</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call> = ""</expr>;</expr_stmt>
<expr_stmt><expr><name><name>lmb</name>.<name>path</name></name> = <call><name>svn_path_uri_decode</name><argument_list>(<argument><expr><name>repos_abs_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lmb</name>.<name>eldest</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lmb</name>.<name>pool</name></name> = <name>pool</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_get_log2</name><argument_list>(<argument><expr><name>ra_session</name></expr></argument>,
<argument><expr><name>condensed_targets</name></expr></argument>,
<argument><expr><name>end</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr>0</expr></argument>,
<argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>fr_log_message_receiver</name></expr></argument>, <argument><expr>&amp;<name>lmb</name></expr></argument>,
<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_reparent</name><argument_list>(<argument><expr><name>ra_session</name></expr></argument>, <argument><expr><name>repos_url</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>currpool</name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lastpool</name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>last_props</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>lastpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>last_path</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>last_stream</name> = <call><name>svn_stream_empty</name><argument_list>(<argument><expr><name>lastpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>rev</name> = <name><name>lmb</name>.<name>eldest</name></name></expr>;</init> <condition><expr><name>rev</name></expr>;</condition> <incr><expr><name>rev</name> = <name><name>rev</name>-&gt;<name>next</name></name></expr></incr>) <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>temp_path</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>temp_dir</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>tmppool</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>props</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_file_t</name> *</type><name>file</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>stream</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>prop_diffs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_txdelta_stream_t</name> *</type><name>delta_stream</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_txdelta_window_handler_t</name></type> <name>delta_handler</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> *</type><name>delta_baton</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>currpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_temp_dir</name><argument_list>(<argument><expr>&amp;<name>temp_dir</name></expr></argument>, <argument><expr><name>currpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_open_unique_file2</name>
<argument_list>(<argument><expr>&amp;<name>file</name></expr></argument>, <argument><expr>&amp;<name>temp_path</name></expr></argument>,
<argument><expr><call><name>svn_path_join</name><argument_list>(<argument><expr><name>temp_dir</name></expr></argument>, <argument><expr>"tmp"</expr></argument>, <argument><expr><name>currpool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>".tmp"</expr></argument>,
<argument><expr><name>svn_io_file_del_on_pool_cleanup</name></expr></argument>, <argument><expr><name>currpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>stream</name> = <call><name>svn_stream_from_aprfile</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>currpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_get_file</name><argument_list>(<argument><expr><name>ra_session</name></expr></argument>, <argument><expr><name><name>rev</name>-&gt;<name>path</name></name> + 1</expr></argument>, <argument><expr><name><name>rev</name>-&gt;<name>revision</name></name></expr></argument>,
<argument><expr><name>stream</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>props</name></expr></argument>, <argument><expr><name>currpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_close</name><argument_list>(<argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_close</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>currpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_open</name><argument_list>(<argument><expr>&amp;<name>file</name></expr></argument>, <argument><expr><name>temp_path</name></expr></argument>, <argument><expr><name>APR_READ</name></expr></argument>, <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>,
<argument><expr><name>currpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>stream</name> = <call><name>svn_stream_from_aprfile2</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>currpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_prop_diffs</name><argument_list>(<argument><expr>&amp;<name>prop_diffs</name></expr></argument>, <argument><expr><name>props</name></expr></argument>, <argument><expr><name>last_props</name></expr></argument>, <argument><expr><name>lastpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>handler</name><argument_list>(<argument><expr><name>handler_baton</name></expr></argument>, <argument><expr><name><name>rev</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name><name>rev</name>-&gt;<name>revision</name></name></expr></argument>, <argument><expr><name><name>rev</name>-&gt;<name>props</name></name></expr></argument>,
<argument><expr><name>FALSE</name></expr></argument>,
<argument><expr>&amp;<name>delta_handler</name></expr></argument>, <argument><expr>&amp;<name>delta_baton</name></expr></argument>, <argument><expr><name>prop_diffs</name></expr></argument>, <argument><expr><name>lastpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>delta_handler</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>svn_txdelta</name><argument_list>(<argument><expr>&amp;<name>delta_stream</name></expr></argument>, <argument><expr><name>last_stream</name></expr></argument>, <argument><expr><name>stream</name></expr></argument>, <argument><expr><name>lastpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_txdelta_send_txstream</name><argument_list>(<argument><expr><name>delta_stream</name></expr></argument>, <argument><expr><name>delta_handler</name></expr></argument>,
<argument><expr><name>delta_baton</name></expr></argument>, <argument><expr><name>lastpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>tmppool</name> = <name>currpool</name></expr>;</expr_stmt>
<expr_stmt><expr><name>currpool</name> = <name>lastpool</name></expr>;</expr_stmt>
<expr_stmt><expr><name>lastpool</name> = <name>tmppool</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>svn_stream_close</name><argument_list>(<argument><expr><name>last_stream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>last_stream</name> = <name>stream</name></expr>;</expr_stmt>
<expr_stmt><expr><name>last_props</name> = <name>props</name></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><call><name>svn_stream_close</name><argument_list>(<argument><expr><name>last_stream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>currpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>lastpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>svn_ra_reparent</name><argument_list>(<argument><expr><name>ra_session</name></expr></argument>, <argument><expr><name>session_url</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
</unit>
