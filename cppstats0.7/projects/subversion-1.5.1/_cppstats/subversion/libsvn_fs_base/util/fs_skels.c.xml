<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="subversion/libsvn_fs_base/util/fs_skels.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_error.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_string.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_types.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_time.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fs_skels.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"skel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../id.h"</cpp:file></cpp:include>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>skel_err</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>skel_type</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_FS_MALFORMED_SKEL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr>"Malformed%s%s skeleton"</expr></argument>,
<argument><expr><name>skel_type</name> ? " " : ""</expr></argument>,
<argument><expr><name>skel_type</name> ? <name>skel_type</name> : ""</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_boolean_t</name></type>
<name>is_valid_checksum_skel</name><parameter_list>(<param><decl><type><name>skel_t</name> *</type><name>skel</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><call><name>svn_fs_base__list_length</name><argument_list>(<argument><expr><name>skel</name></expr></argument>)</argument_list></call> != 2</expr>)</condition><then>
<return>return <expr><name>FALSE</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>svn_fs_base__matches_atom</name><argument_list>(<argument><expr><name><name>skel</name>-&gt;<name>children</name></name></expr></argument>, <argument><expr>"md5"</expr></argument>)</argument_list></call>
&amp;&amp; <name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name></expr>)</condition><then>
<return>return <expr><name>TRUE</name></expr>;</return></then></if>
<return>return <expr><name>FALSE</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_boolean_t</name></type>
<name>is_valid_proplist_skel</name><parameter_list>(<param><decl><type><name>skel_t</name> *</type><name>skel</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>svn_fs_base__list_length</name><argument_list>(<argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>(<name>len</name> &gt;= 0) &amp;&amp; (<name>len</name> &amp; 1) == 0</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>skel_t</name> *</type><name>elt</name></decl>;</decl_stmt>
<for>for (<init><expr><name>elt</name> = <name><name>skel</name>-&gt;<name>children</name></name></expr>;</init> <condition><expr><name>elt</name></expr>;</condition> <incr><expr><name>elt</name> = <name><name>elt</name>-&gt;<name>next</name></name></expr></incr>)
<if>if <condition>(<expr>! <name><name>elt</name>-&gt;<name>is_atom</name></name></expr>)</condition><then>
<return>return <expr><name>FALSE</name></expr>;</return></then></if></for>
<return>return <expr><name>TRUE</name></expr>;</return>
}</block></then></if>
<return>return <expr><name>FALSE</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_boolean_t</name></type>
<name>is_valid_revision_skel</name><parameter_list>(<param><decl><type><name>skel_t</name> *</type><name>skel</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>svn_fs_base__list_length</name><argument_list>(<argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>(<name>len</name> == 2)
&amp;&amp; <call><name>svn_fs_base__matches_atom</name><argument_list>(<argument><expr><name><name>skel</name>-&gt;<name>children</name></name></expr></argument>, <argument><expr>"revision"</expr></argument>)</argument_list></call>
&amp;&amp; <name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name></expr>)</condition><then>
<return>return <expr><name>TRUE</name></expr>;</return></then></if>
<return>return <expr><name>FALSE</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_boolean_t</name></type>
<name>is_valid_transaction_skel</name><parameter_list>(<param><decl><type><name>skel_t</name> *</type><name>skel</name></decl></param>, <param><decl><type><name>transaction_kind_t</name> *</type><name>kind</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>svn_fs_base__list_length</name><argument_list>(<argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>len</name> != 5</expr>)</condition><then>
<return>return <expr><name>FALSE</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>svn_fs_base__matches_atom</name><argument_list>(<argument><expr><name><name>skel</name>-&gt;<name>children</name></name></expr></argument>, <argument><expr>"transaction"</expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr>*<name>kind</name> = <name>transaction_kind_normal</name></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><call><name>svn_fs_base__matches_atom</name><argument_list>(<argument><expr><name><name>skel</name>-&gt;<name>children</name></name></expr></argument>, <argument><expr>"committed"</expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr>*<name>kind</name> = <name>transaction_kind_committed</name></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><call><name>svn_fs_base__matches_atom</name><argument_list>(<argument><expr><name><name>skel</name>-&gt;<name>children</name></name></expr></argument>, <argument><expr>"dead"</expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr>*<name>kind</name> = <name>transaction_kind_dead</name></expr>;</expr_stmt></then>
<else>else
<return>return <expr><name>FALSE</name></expr>;</return></else></if></else></if></else></if>
<if>if <condition>(<expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name>
&amp;&amp; <name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name>
&amp;&amp; (! <name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name>)
&amp;&amp; (! <name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name>)</expr>)</condition><then>
<return>return <expr><name>TRUE</name></expr>;</return></then></if>
<return>return <expr><name>FALSE</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_boolean_t</name></type>
<name>is_valid_rep_delta_chunk_skel</name><parameter_list>(<param><decl><type><name>skel_t</name> *</type><name>skel</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>skel_t</name> *</type><name>window</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>skel_t</name> *</type><name>diff</name></decl>;</decl_stmt>
<if>if <condition>(<expr>(<call><name>svn_fs_base__list_length</name><argument_list>(<argument><expr><name>skel</name></expr></argument>)</argument_list></call> != 2)
|| (! <name><name>skel</name>-&gt;<name>children</name>-&gt;<name>is_atom</name></name>)</expr>)</condition><then>
<return>return <expr><name>FALSE</name></expr>;</return></then></if>
<expr_stmt><expr><name>window</name> = <name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>len</name> = <call><name>svn_fs_base__list_length</name><argument_list>(<argument><expr><name>window</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>(<name>len</name> &lt; 3) || (<name>len</name> &gt; 4)</expr>)</condition><then>
<return>return <expr><name>FALSE</name></expr>;</return></then></if>
<if>if <condition>(<expr>! ((! <name><name>window</name>-&gt;<name>children</name>-&gt;<name>is_atom</name></name>)
&amp;&amp; (<name><name>window</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name>)
&amp;&amp; (<name><name>window</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name>))</expr>)</condition><then>
<return>return <expr><name>FALSE</name></expr>;</return></then></if>
<if>if <condition>(<expr>(<name>len</name> == 4)
&amp;&amp; (! <name><name>window</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name>)</expr>)</condition><then>
<return>return <expr><name>FALSE</name></expr>;</return></then></if>
<expr_stmt><expr><name>diff</name> = <name><name>window</name>-&gt;<name>children</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr>(<call><name>svn_fs_base__list_length</name><argument_list>(<argument><expr><name>diff</name></expr></argument>)</argument_list></call> == 3)
&amp;&amp; (<call><name>svn_fs_base__matches_atom</name><argument_list>(<argument><expr><name><name>diff</name>-&gt;<name>children</name></name></expr></argument>, <argument><expr>"svndiff"</expr></argument>)</argument_list></call>)
&amp;&amp; ((<call><name>svn_fs_base__matches_atom</name><argument_list>(<argument><expr><name><name>diff</name>-&gt;<name>children</name>-&gt;<name>next</name></name></expr></argument>, <argument><expr>"0"</expr></argument>)</argument_list></call>)
|| (<call><name>svn_fs_base__matches_atom</name><argument_list>(<argument><expr><name><name>diff</name>-&gt;<name>children</name>-&gt;<name>next</name></name></expr></argument>, <argument><expr>"1"</expr></argument>)</argument_list></call>))
&amp;&amp; (<name><name>diff</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name>)</expr>)</condition><then>
<return>return <expr><name>TRUE</name></expr>;</return></then></if>
<return>return <expr><name>FALSE</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_boolean_t</name></type>
<name>is_valid_representation_skel</name><parameter_list>(<param><decl><type><name>skel_t</name> *</type><name>skel</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>svn_fs_base__list_length</name><argument_list>(<argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>skel_t</name> *</type><name>header</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>header_len</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>len</name> &lt; 2</expr>)</condition><then>
<return>return <expr><name>FALSE</name></expr>;</return></then></if>
<expr_stmt><expr><name>header</name> = <name><name>skel</name>-&gt;<name>children</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>header_len</name> = <call><name>svn_fs_base__list_length</name><argument_list>(<argument><expr><name>header</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>! (((<name>header_len</name> == 2)
&amp;&amp; (<name><name>header</name>-&gt;<name>children</name>-&gt;<name>is_atom</name></name>)
&amp;&amp; (<name><name>header</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name>))
|| ((<name>header_len</name> == 3)
&amp;&amp; (<name><name>header</name>-&gt;<name>children</name>-&gt;<name>is_atom</name></name>)
&amp;&amp; (<name><name>header</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name>)
&amp;&amp; (<call><name>is_valid_checksum_skel</name><argument_list>(<argument><expr><name><name>header</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name></name></expr></argument>)</argument_list></call>)))</expr>)</condition><then>
<return>return <expr><name>FALSE</name></expr>;</return></then></if>
<if>if <condition>(<expr>(<name>len</name> == 2)
&amp;&amp; (<call><name>svn_fs_base__matches_atom</name><argument_list>(<argument><expr><name><name>header</name>-&gt;<name>children</name></name></expr></argument>, <argument><expr>"fulltext"</expr></argument>)</argument_list></call>)</expr>)</condition><then>
<return>return <expr><name>TRUE</name></expr>;</return></then></if>
<if>if <condition>(<expr>(<name>len</name> &gt;= 2)
&amp;&amp; (<call><name>svn_fs_base__matches_atom</name><argument_list>(<argument><expr><name><name>header</name>-&gt;<name>children</name></name></expr></argument>, <argument><expr>"delta"</expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>skel_t</name> *</type><name>chunk</name> <init>= <expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name></name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>chunk</name></expr>)</condition> <block>{
<if>if <condition>(<expr>! <call><name>is_valid_rep_delta_chunk_skel</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>FALSE</name></expr>;</return></then></if>
<expr_stmt><expr><name>chunk</name> = <name><name>chunk</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
}</block></while>
<return>return <expr><name>TRUE</name></expr>;</return>
}</block></then></if>
<return>return <expr><name>FALSE</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_boolean_t</name></type>
<name>is_valid_node_revision_header_skel</name><parameter_list>(<param><decl><type><name>skel_t</name> *</type><name>skel</name></decl></param>, <param><decl><type><name>skel_t</name> **</type><name>kind_p</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>svn_fs_base__list_length</name><argument_list>(<argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>len</name> &lt; 2</expr>)</condition><then>
<return>return <expr><name>FALSE</name></expr>;</return></then></if>
<expr_stmt><expr>*<name>kind_p</name> = <name><name>skel</name>-&gt;<name>children</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr>! ((<name>len</name> == 2) || (<name>len</name> == 3) || (<name>len</name> == 4) || (<name>len</name> == 6))</expr>)</condition><then>
<return>return <expr><name>FALSE</name></expr>;</return></then></if>
<if>if <condition>(<expr>(<name>len</name> &gt; 4)
&amp;&amp; (! (<name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name>
&amp;&amp; <name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name>))</expr>)</condition><then>
<return>return <expr><name>FALSE</name></expr>;</return></then></if>
<if>if <condition>(<expr>(<name>len</name> &gt; 3)
&amp;&amp; (! <name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name>)</expr>)</condition><then>
<return>return <expr><name>FALSE</name></expr>;</return></then></if>
<if>if <condition>(<expr>(<name>len</name> &gt; 2)
&amp;&amp; (! <name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name>)</expr>)</condition><then>
<return>return <expr><name>FALSE</name></expr>;</return></then></if>
<if>if <condition>(<expr>! (<name><name>skel</name>-&gt;<name>children</name>-&gt;<name>is_atom</name></name>
&amp;&amp; <name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name>
&amp;&amp; (<name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>data</name><index>[<expr>0</expr>]</index></name> == '/'))</expr>)</condition><then>
<return>return <expr><name>FALSE</name></expr>;</return></then></if>
<return>return <expr><name>TRUE</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_boolean_t</name></type>
<name>is_valid_node_revision_skel</name><parameter_list>(<param><decl><type><name>skel_t</name> *</type><name>skel</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>svn_fs_base__list_length</name><argument_list>(<argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>len</name> &gt;= 1</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>skel_t</name> *</type><name>header</name> <init>= <expr><name><name>skel</name>-&gt;<name>children</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>skel_t</name> *</type><name>kind</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>is_valid_node_revision_header_skel</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr>&amp;<name>kind</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>svn_fs_base__matches_atom</name><argument_list>(<argument><expr><name>kind</name></expr></argument>, <argument><expr>"dir"</expr></argument>)</argument_list></call>
&amp;&amp; <name>len</name> == 3
&amp;&amp; <name><name>header</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name>
&amp;&amp; <name><name>header</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name></expr>)</condition><then>
<return>return <expr><name>TRUE</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>svn_fs_base__matches_atom</name><argument_list>(<argument><expr><name>kind</name></expr></argument>, <argument><expr>"file"</expr></argument>)</argument_list></call>
&amp;&amp; ((<name>len</name> == 3) || (<name>len</name> == 4))
&amp;&amp; <name><name>header</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name>
&amp;&amp; <name><name>header</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>(<name>len</name> == 4) &amp;&amp; (! <name><name>header</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name>)</expr>)</condition><then>
<return>return <expr><name>FALSE</name></expr>;</return></then></if>
<return>return <expr><name>TRUE</name></expr>;</return>
}</block></then></if>
}</block></then></if>
}</block></then></if>
<return>return <expr><name>FALSE</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_boolean_t</name></type>
<name>is_valid_copy_skel</name><parameter_list>(<param><decl><type><name>skel_t</name> *</type><name>skel</name></decl></param>)</parameter_list> <block>{
<return>return <expr>(((<call><name>svn_fs_base__list_length</name><argument_list>(<argument><expr><name>skel</name></expr></argument>)</argument_list></call> == 4)
&amp;&amp; (<call><name>svn_fs_base__matches_atom</name><argument_list>(<argument><expr><name><name>skel</name>-&gt;<name>children</name></name></expr></argument>, <argument><expr>"copy"</expr></argument>)</argument_list></call>
|| <call><name>svn_fs_base__matches_atom</name><argument_list>(<argument><expr><name><name>skel</name>-&gt;<name>children</name></name></expr></argument>, <argument><expr>"soft-copy"</expr></argument>)</argument_list></call>)
&amp;&amp; <name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name>
&amp;&amp; <name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name>
&amp;&amp; <name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name>) ? <name>TRUE</name> : <name>FALSE</name>)</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_boolean_t</name></type>
<name>is_valid_change_skel</name><parameter_list>(<param><decl><type><name>skel_t</name> *</type><name>skel</name></decl></param>, <param><decl><type><name>svn_fs_path_change_kind_t</name> *</type><name>kind</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr>(<call><name>svn_fs_base__list_length</name><argument_list>(<argument><expr><name>skel</name></expr></argument>)</argument_list></call> == 6)
&amp;&amp; <call><name>svn_fs_base__matches_atom</name><argument_list>(<argument><expr><name><name>skel</name>-&gt;<name>children</name></name></expr></argument>, <argument><expr>"change"</expr></argument>)</argument_list></call>
&amp;&amp; <name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name>
&amp;&amp; <name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name>
&amp;&amp; <name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name>
&amp;&amp; <name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name>
&amp;&amp; <name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>skel_t</name> *</type><name>kind_skel</name> <init>= <expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name></name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>svn_fs_base__matches_atom</name><argument_list>(<argument><expr><name>kind_skel</name></expr></argument>, <argument><expr>"reset"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>kind</name></expr>)</condition><then>
<expr_stmt><expr>*<name>kind</name> = <name>svn_fs_path_change_reset</name></expr>;</expr_stmt></then></if>
<return>return <expr><name>TRUE</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><call><name>svn_fs_base__matches_atom</name><argument_list>(<argument><expr><name>kind_skel</name></expr></argument>, <argument><expr>"add"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>kind</name></expr>)</condition><then>
<expr_stmt><expr>*<name>kind</name> = <name>svn_fs_path_change_add</name></expr>;</expr_stmt></then></if>
<return>return <expr><name>TRUE</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><call><name>svn_fs_base__matches_atom</name><argument_list>(<argument><expr><name>kind_skel</name></expr></argument>, <argument><expr>"delete"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>kind</name></expr>)</condition><then>
<expr_stmt><expr>*<name>kind</name> = <name>svn_fs_path_change_delete</name></expr>;</expr_stmt></then></if>
<return>return <expr><name>TRUE</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><call><name>svn_fs_base__matches_atom</name><argument_list>(<argument><expr><name>kind_skel</name></expr></argument>, <argument><expr>"replace"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>kind</name></expr>)</condition><then>
<expr_stmt><expr>*<name>kind</name> = <name>svn_fs_path_change_replace</name></expr>;</expr_stmt></then></if>
<return>return <expr><name>TRUE</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><call><name>svn_fs_base__matches_atom</name><argument_list>(<argument><expr><name>kind_skel</name></expr></argument>, <argument><expr>"modify"</expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>kind</name></expr>)</condition><then>
<expr_stmt><expr>*<name>kind</name> = <name>svn_fs_path_change_modify</name></expr>;</expr_stmt></then></if>
<return>return <expr><name>TRUE</name></expr>;</return>
}</block></then></if>
}</block></then></if>
<return>return <expr><name>FALSE</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_boolean_t</name></type>
<name>is_valid_lock_skel</name><parameter_list>(<param><decl><type><name>skel_t</name> *</type><name>skel</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr>(<call><name>svn_fs_base__list_length</name><argument_list>(<argument><expr><name>skel</name></expr></argument>)</argument_list></call> == 8)
&amp;&amp; <call><name>svn_fs_base__matches_atom</name><argument_list>(<argument><expr><name><name>skel</name>-&gt;<name>children</name></name></expr></argument>, <argument><expr>"lock"</expr></argument>)</argument_list></call>
&amp;&amp; <name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name>
&amp;&amp; <name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name>
&amp;&amp; <name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name>
&amp;&amp; <name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name>
&amp;&amp; <name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name>
&amp;&amp; <name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name>
&amp;&amp; <name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>is_atom</name></name></expr>)</condition><then>
<return>return <expr><name>TRUE</name></expr>;</return></then></if>
<return>return <expr><name>FALSE</name></expr>;</return>
}</block></function>
<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__parse_proplist_skel</name><parameter_list>(<param><decl><type><name>apr_hash_t</name> **</type><name>proplist_p</name></decl></param>,
<param><decl><type><name>skel_t</name> *</type><name>skel</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>proplist</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>skel_t</name> *</type><name>elt</name></decl>;</decl_stmt>
<if>if <condition>(<expr>! <call><name>is_valid_proplist_skel</name><argument_list>(<argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>skel_err</name><argument_list>(<argument><expr>"proplist"</expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><name><name>skel</name>-&gt;<name>children</name></name></expr>)</condition><then>
<expr_stmt><expr><name>proplist</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<for>for (<init><expr><name>elt</name> = <name><name>skel</name>-&gt;<name>children</name></name></expr>;</init> <condition><expr><name>elt</name></expr>;</condition> <incr><expr><name>elt</name> = <name><name>elt</name>-&gt;<name>next</name>-&gt;<name>next</name></name></expr></incr>) <block>{
<decl_stmt><decl><type><name>svn_string_t</name> *</type><name>value</name> <init>= <expr><call><name>svn_string_ncreate</name><argument_list>(<argument><expr><name><name>elt</name>-&gt;<name>next</name>-&gt;<name>data</name></name></expr></argument>,
<argument><expr><name><name>elt</name>-&gt;<name>next</name>-&gt;<name>len</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>proplist</name></expr></argument>,
<argument><expr><call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>elt</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>elt</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>elt</name>-&gt;<name>len</name></name></expr></argument>,
<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr>*<name>proplist_p</name> = <name>proplist</name></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__parse_revision_skel</name><parameter_list>(<param><decl><type><name>revision_t</name> **</type><name>revision_p</name></decl></param>,
<param><decl><type><name>skel_t</name> *</type><name>skel</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>revision_t</name> *</type><name>revision</name></decl>;</decl_stmt>
<if>if <condition>(<expr>! <call><name>is_valid_revision_skel</name><argument_list>(<argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>skel_err</name><argument_list>(<argument><expr>"revision"</expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>revision</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>revision</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>revision</name>-&gt;<name>txn_id</name></name> = <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>data</name></name></expr></argument>,
<argument><expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>revision_p</name> = <name>revision</name></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__parse_transaction_skel</name><parameter_list>(<param><decl><type><name>transaction_t</name> **</type><name>transaction_p</name></decl></param>,
<param><decl><type><name>skel_t</name> *</type><name>skel</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>transaction_t</name> *</type><name>transaction</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>transaction_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>skel_t</name> *</type><name>root_id</name></decl>, *<decl><type ref="prev"/><name>base_id_or_rev</name></decl>, *<decl><type ref="prev"/><name>proplist</name></decl>, *<decl><type ref="prev"/><name>copies</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
<if>if <condition>(<expr>! <call><name>is_valid_transaction_skel</name><argument_list>(<argument><expr><name>skel</name></expr></argument>, <argument><expr>&amp;<name>kind</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>skel_err</name><argument_list>(<argument><expr>"transaction"</expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>root_id</name> = <name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>base_id_or_rev</name> = <name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>proplist</name> = <name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>copies</name> = <name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>transaction</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>transaction</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>transaction</name>-&gt;<name>kind</name></name> = <name>kind</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>kind</name> == <name>transaction_kind_committed</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>transaction</name>-&gt;<name>base_id</name></name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>transaction</name>-&gt;<name>revision</name></name> = <call><name>atoi</name><argument_list>(<argument><expr><call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>base_id_or_rev</name>-&gt;<name>data</name></name></expr></argument>,
<argument><expr><name><name>base_id_or_rev</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>! <call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name><name>transaction</name>-&gt;<name>revision</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>skel_err</name><argument_list>(<argument><expr>"transaction"</expr></argument>)</argument_list></call></expr>;</return></then></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><name><name>transaction</name>-&gt;<name>revision</name></name> = <name>SVN_INVALID_REVNUM</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>transaction</name>-&gt;<name>base_id</name></name> = <call><name>svn_fs_base__id_parse</name><argument_list>(<argument><expr><name><name>base_id_or_rev</name>-&gt;<name>data</name></name></expr></argument>,
<argument><expr><name><name>base_id_or_rev</name>-&gt;<name>len</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><name><name>transaction</name>-&gt;<name>root_id</name></name> = <call><name>svn_fs_base__id_parse</name><argument_list>(<argument><expr><name><name>root_id</name>-&gt;<name>data</name></name></expr></argument>,
<argument><expr><name><name>root_id</name>-&gt;<name>len</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__parse_proplist_skel</name><argument_list>(<argument><expr>&amp;(<name><name>transaction</name>-&gt;<name>proplist</name></name>)</expr></argument>,
<argument><expr><name>proplist</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>(<name>len</name> = <call><name>svn_fs_base__list_length</name><argument_list>(<argument><expr><name>copies</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copy_id</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>txncopies</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>skel_t</name> *</type><name>cpy</name> <init>= <expr><name><name>copies</name>-&gt;<name>children</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>txncopies</name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>copy_id</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>cpy</name></expr>)</condition> <block>{
<expr_stmt><expr><name>copy_id</name> = <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>cpy</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>cpy</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>txncopies</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call> = <name>copy_id</name></expr>;</expr_stmt>
<expr_stmt><expr><name>cpy</name> = <name><name>cpy</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
}</block></while>
<expr_stmt><expr><name><name>transaction</name>-&gt;<name>copies</name></name> = <name>txncopies</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr>*<name>transaction_p</name> = <name>transaction</name></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__parse_representation_skel</name><parameter_list>(<param><decl><type><name>representation_t</name> **</type><name>rep_p</name></decl></param>,
<param><decl><type><name>skel_t</name> *</type><name>skel</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>representation_t</name> *</type><name>rep</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>skel_t</name> *</type><name>header_skel</name></decl>;</decl_stmt>
<if>if <condition>(<expr>! <call><name>is_valid_representation_skel</name><argument_list>(<argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>skel_err</name><argument_list>(<argument><expr>"representation"</expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>header_skel</name> = <name><name>skel</name>-&gt;<name>children</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>rep</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>rep</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>svn_fs_base__matches_atom</name><argument_list>(<argument><expr><name><name>header_skel</name>-&gt;<name>children</name></name></expr></argument>, <argument><expr>"fulltext"</expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name><name>rep</name>-&gt;<name>kind</name></name> = <name>rep_kind_fulltext</name></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name><name>rep</name>-&gt;<name>kind</name></name> = <name>rep_kind_delta</name></expr>;</expr_stmt></else></if>
<expr_stmt><expr><name><name>rep</name>-&gt;<name>txn_id</name></name> = <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>header_skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>data</name></name></expr></argument>,
<argument><expr><name><name>header_skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>header_skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>rep</name>-&gt;<name>checksum</name></name></expr></argument>,
<argument><expr><name><name>header_skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>data</name></name></expr></argument>,
<argument><expr><name>APR_MD5_DIGESTSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>rep</name>-&gt;<name>checksum</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>APR_MD5_DIGESTSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<if>if <condition>(<expr><name><name>rep</name>-&gt;<name>kind</name></name> == <name>rep_kind_fulltext</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>rep</name>-&gt;<name>contents</name>.<name>fulltext</name>.<name>string_key</name></name>
= <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>,
<argument><expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>data</name></name></expr></argument>,
<argument><expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>skel_t</name> *</type><name>chunk_skel</name> <init>= <expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>rep_delta_chunk_t</name> *</type><name>chunk</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>chunks</name></decl>;</decl_stmt>
<expr_stmt><expr><name>chunks</name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><call><name>svn_fs_base__list_length</name><argument_list>(<argument><expr><name>skel</name></expr></argument>)</argument_list></call> - 1</expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>chunk_skel</name></expr>)</condition> <block>{
<decl_stmt><decl><type><name>skel_t</name> *</type><name>window_skel</name> <init>= <expr><name><name>chunk_skel</name>-&gt;<name>children</name>-&gt;<name>next</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>skel_t</name> *</type><name>diff_skel</name> <init>= <expr><name><name>window_skel</name>-&gt;<name>children</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>chunk</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>chunk</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>chunk</name>-&gt;<name>version</name></name>
= (<name>apr_byte_t</name>)<call><name>atoi</name><argument_list>(<argument><expr><call><name>apr_pstrmemdup</name>
<argument_list>(<argument><expr><name>pool</name></expr></argument>,
<argument><expr><name><name>diff_skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>data</name></name></expr></argument>,
<argument><expr><name><name>diff_skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>chunk</name>-&gt;<name>string_key</name></name>
= <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>,
<argument><expr><name><name>diff_skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>data</name></name></expr></argument>,
<argument><expr><name><name>diff_skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>chunk</name>-&gt;<name>size</name></name>
= <call><name>atoi</name><argument_list>(<argument><expr><call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>,
<argument><expr><name><name>window_skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>data</name></name></expr></argument>,
<argument><expr><name><name>window_skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>chunk</name>-&gt;<name>rep_key</name></name>
= <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>,
<argument><expr><name><name>window_skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>data</name></name></expr></argument>,
<argument><expr><name><name>window_skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>chunk</name>-&gt;<name>offset</name></name> =
<call><name>svn__atoui64</name><argument_list>(<argument><expr><call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>,
<argument><expr><name><name>chunk_skel</name>-&gt;<name>children</name>-&gt;<name>data</name></name></expr></argument>,
<argument><expr><name><name>chunk_skel</name>-&gt;<name>children</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>chunks</name></expr></argument>, <argument><expr><name>rep_delta_chunk_t</name> *</expr></argument>)</argument_list></call> = <name>chunk</name></expr>;</expr_stmt>
<expr_stmt><expr><name>chunk_skel</name> = <name><name>chunk_skel</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
}</block></while>
<expr_stmt><expr><name><name>rep</name>-&gt;<name>contents</name>.<name>delta</name>.<name>chunks</name></name> = <name>chunks</name></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr>*<name>rep_p</name> = <name>rep</name></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__parse_node_revision_skel</name><parameter_list>(<param><decl><type><name>node_revision_t</name> **</type><name>noderev_p</name></decl></param>,
<param><decl><type><name>skel_t</name> *</type><name>skel</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>node_revision_t</name> *</type><name>noderev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>skel_t</name> *</type><name>header_skel</name></decl>, *<decl><type ref="prev"/><name>cur_skel</name></decl>;</decl_stmt>
<if>if <condition>(<expr>! <call><name>is_valid_node_revision_skel</name><argument_list>(<argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>skel_err</name><argument_list>(<argument><expr>"node-revision"</expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>header_skel</name> = <name><name>skel</name>-&gt;<name>children</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>noderev</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>noderev</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>svn_fs_base__matches_atom</name><argument_list>(<argument><expr><name><name>header_skel</name>-&gt;<name>children</name></name></expr></argument>, <argument><expr>"dir"</expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name><name>noderev</name>-&gt;<name>kind</name></name> = <name>svn_node_dir</name></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name><name>noderev</name>-&gt;<name>kind</name></name> = <name>svn_node_file</name></expr>;</expr_stmt></else></if>
<expr_stmt><expr><name><name>noderev</name>-&gt;<name>created_path</name></name> = <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>,
<argument><expr><name><name>header_skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>data</name></name></expr></argument>,
<argument><expr><name><name>header_skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>header_skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>cur_skel</name> = <name><name>header_skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>cur_skel</name>-&gt;<name>len</name></name></expr>)</condition><then>
<expr_stmt><expr><name><name>noderev</name>-&gt;<name>predecessor_id</name></name> = <call><name>svn_fs_base__id_parse</name><argument_list>(<argument><expr><name><name>cur_skel</name>-&gt;<name>data</name></name></expr></argument>,
<argument><expr><name><name>cur_skel</name>-&gt;<name>len</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name><name>noderev</name>-&gt;<name>predecessor_count</name></name> = -1</expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>cur_skel</name>-&gt;<name>next</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>cur_skel</name> = <name><name>cur_skel</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>cur_skel</name>-&gt;<name>len</name></name></expr>)</condition><then>
<expr_stmt><expr><name><name>noderev</name>-&gt;<name>predecessor_count</name></name> = <call><name>atoi</name><argument_list>(<argument><expr><call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>,
<argument><expr><name><name>cur_skel</name>-&gt;<name>data</name></name></expr></argument>,
<argument><expr><name><name>cur_skel</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name><name>cur_skel</name>-&gt;<name>next</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>cur_skel</name> = <name><name>cur_skel</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>noderev</name>-&gt;<name>has_mergeinfo</name></name> = <call><name>atoi</name><argument_list>(<argument><expr><call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>,
<argument><expr><name><name>cur_skel</name>-&gt;<name>data</name></name></expr></argument>,
<argument><expr><name><name>cur_skel</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
? <name>TRUE</name> : <name>FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>noderev</name>-&gt;<name>mergeinfo_count</name></name> =
<call><name>apr_atoi64</name><argument_list>(<argument><expr><call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>,
<argument><expr><name><name>cur_skel</name>-&gt;<name>next</name>-&gt;<name>data</name></name></expr></argument>,
<argument><expr><name><name>cur_skel</name>-&gt;<name>next</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
}</block></then></if>
<if>if <condition>(<expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>len</name></name></expr>)</condition><then>
<expr_stmt><expr><name><name>noderev</name>-&gt;<name>prop_key</name></name> = <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>data</name></name></expr></argument>,
<argument><expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>len</name></name></expr>)</condition><then>
<expr_stmt><expr><name><name>noderev</name>-&gt;<name>data_key</name></name> = <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>data</name></name></expr></argument>,
<argument><expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr>(<name><name>noderev</name>-&gt;<name>kind</name></name> == <name>svn_node_file</name>)
&amp;&amp; <name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name></name>
&amp;&amp; <name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>len</name></name></expr>)</condition><then>
<expr_stmt><expr><name><name>noderev</name>-&gt;<name>edit_key</name></name>
= <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>data</name></name></expr></argument>,
<argument><expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr>*<name>noderev_p</name> = <name>noderev</name></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__parse_copy_skel</name><parameter_list>(<param><decl><type><name>copy_t</name> **</type><name>copy_p</name></decl></param>,
<param><decl><type><name>skel_t</name> *</type><name>skel</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>copy_t</name> *</type><name>copy</name></decl>;</decl_stmt>
<if>if <condition>(<expr>! <call><name>is_valid_copy_skel</name><argument_list>(<argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>skel_err</name><argument_list>(<argument><expr>"copy"</expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>copy</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>copy</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>svn_fs_base__matches_atom</name><argument_list>(<argument><expr><name><name>skel</name>-&gt;<name>children</name></name></expr></argument>, <argument><expr>"soft-copy"</expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name><name>copy</name>-&gt;<name>kind</name></name> = <name>copy_kind_soft</name></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name><name>copy</name>-&gt;<name>kind</name></name> = <name>copy_kind_real</name></expr>;</expr_stmt></else></if>
<expr_stmt><expr><name><name>copy</name>-&gt;<name>src_path</name></name> = <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>,
<argument><expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>data</name></name></expr></argument>,
<argument><expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>copy</name>-&gt;<name>src_txn_id</name></name> = <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>,
<argument><expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>data</name></name></expr></argument>,
<argument><expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>copy</name>-&gt;<name>dst_noderev_id</name></name>
= <call><name>svn_fs_base__id_parse</name><argument_list>(<argument><expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>data</name></name></expr></argument>,
<argument><expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>len</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>copy_p</name> = <name>copy</name></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__parse_entries_skel</name><parameter_list>(<param><decl><type><name>apr_hash_t</name> **</type><name>entries_p</name></decl></param>,
<param><decl><type><name>skel_t</name> *</type><name>skel</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>entries</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>svn_fs_base__list_length</name><argument_list>(<argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>skel_t</name> *</type><name>elt</name></decl>;</decl_stmt>
<if>if <condition>(<expr>! (<name>len</name> &gt;= 0)</expr>)</condition><then>
<return>return <expr><call><name>skel_err</name><argument_list>(<argument><expr>"entries"</expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><name>len</name> &gt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>entries</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>elt</name> = <name><name>skel</name>-&gt;<name>children</name></name></expr>;</init> <condition><expr><name>elt</name></expr>;</condition> <incr><expr><name>elt</name> = <name><name>elt</name>-&gt;<name>next</name></name></expr></incr>) <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_fs_id_t</name> *</type><name>id</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>svn_fs_base__list_length</name><argument_list>(<argument><expr><name>elt</name></expr></argument>)</argument_list></call> != 2</expr>)</condition><then>
<return>return <expr><call><name>skel_err</name><argument_list>(<argument><expr>"entries"</expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>name</name> = <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>elt</name>-&gt;<name>children</name>-&gt;<name>data</name></name></expr></argument>,
<argument><expr><name><name>elt</name>-&gt;<name>children</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>id</name> = <call><name>svn_fs_base__id_parse</name><argument_list>(<argument><expr><name><name>elt</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>data</name></name></expr></argument>,
<argument><expr><name><name>elt</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>len</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>entries</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>elt</name>-&gt;<name>children</name>-&gt;<name>len</name></name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
}</block></then></if>
<expr_stmt><expr>*<name>entries_p</name> = <name>entries</name></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__parse_change_skel</name><parameter_list>(<param><decl><type><name>change_t</name> **</type><name>change_p</name></decl></param>,
<param><decl><type><name>skel_t</name> *</type><name>skel</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>change_t</name> *</type><name>change</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_fs_path_change_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>
<if>if <condition>(<expr>! <call><name>is_valid_change_skel</name><argument_list>(<argument><expr><name>skel</name></expr></argument>, <argument><expr>&amp;<name>kind</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>skel_err</name><argument_list>(<argument><expr>"change"</expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>change</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>change</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>change</name>-&gt;<name>path</name></name> = <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>data</name></name></expr></argument>,
<argument><expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>len</name></name></expr>)</condition><then>
<expr_stmt><expr><name><name>change</name>-&gt;<name>noderev_id</name></name> = <call><name>svn_fs_base__id_parse</name>
<argument_list>(<argument><expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>len</name></name></expr></argument>,
<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name><name>change</name>-&gt;<name>kind</name></name> = <name>kind</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>len</name></name></expr>)</condition><then>
<expr_stmt><expr><name><name>change</name>-&gt;<name>text_mod</name></name> = <name>TRUE</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>len</name></name></expr>)</condition><then>
<expr_stmt><expr><name><name>change</name>-&gt;<name>prop_mod</name></name> = <name>TRUE</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr>*<name>change_p</name> = <name>change</name></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__parse_lock_skel</name><parameter_list>(<param><decl><type><name>svn_lock_t</name> **</type><name>lock_p</name></decl></param>,
<param><decl><type><name>skel_t</name> *</type><name>skel</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>svn_lock_t</name> *</type><name>lock</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>timestr</name></decl>;</decl_stmt>
<if>if <condition>(<expr>! <call><name>is_valid_lock_skel</name><argument_list>(<argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>skel_err</name><argument_list>(<argument><expr>"lock"</expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>lock</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>lock</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lock</name>-&gt;<name>path</name></name> = <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>data</name></name></expr></argument>,
<argument><expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lock</name>-&gt;<name>token</name></name> = <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>,
<argument><expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>data</name></name></expr></argument>,
<argument><expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>lock</name>-&gt;<name>owner</name></name> = <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>,
<argument><expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>data</name></name></expr></argument>,
<argument><expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>len</name></name></expr>)</condition><then>
<expr_stmt><expr><name><name>lock</name>-&gt;<name>comment</name></name> =
<call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>,
<argument><expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>data</name></name></expr></argument>,
<argument><expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><call><name>svn_fs_base__matches_atom</name>
<argument_list>(<argument><expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name></name></expr></argument>, <argument><expr>"1"</expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name><name>lock</name>-&gt;<name>is_dav_comment</name></name> = <name>TRUE</name></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name><name>lock</name>-&gt;<name>is_dav_comment</name></name> = <name>FALSE</name></expr>;</expr_stmt></else></if>
<expr_stmt><expr><name>timestr</name> = <call><name>apr_pstrmemdup</name>
<argument_list>(<argument><expr><name>pool</name></expr></argument>,
<argument><expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>data</name></name></expr></argument>,
<argument><expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_time_from_cstring</name><argument_list>(<argument><expr>&amp;(<name><name>lock</name>-&gt;<name>creation_date</name></name>)</expr></argument>,
<argument><expr><name>timestr</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>len</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>timestr</name> =
<call><name>apr_pstrmemdup</name>
<argument_list>(<argument><expr><name>pool</name></expr></argument>,
<argument><expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>data</name></name></expr></argument>,
<argument><expr><name><name>skel</name>-&gt;<name>children</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>next</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_time_from_cstring</name><argument_list>(<argument><expr>&amp;(<name><name>lock</name>-&gt;<name>expiration_date</name></name>)</expr></argument>,
<argument><expr><name>timestr</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr>*<name>lock_p</name> = <name>lock</name></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__unparse_proplist_skel</name><parameter_list>(<param><decl><type><name>skel_t</name> **</type><name>skel_p</name></decl></param>,
<param><decl><type><name>apr_hash_t</name> *</type><name>proplist</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>skel_t</name> *</type><name>skel</name> <init>= <expr><call><name>svn_fs_base__make_empty_list</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>proplist</name></expr>)</condition><then> <block>{
<for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>proplist</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>hi</name></expr>;</condition> <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>) <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_ssize_t</name></type> <name>klen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_string_t</name> *</type><name>value</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr>&amp;<name>klen</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>value</name> = <name>val</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__mem_atom</name><argument_list>(<argument><expr><name><name>value</name>-&gt;<name>data</name></name></expr></argument>,
<argument><expr><name><name>value</name>-&gt;<name>len</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__mem_atom</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>klen</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
}</block></then></if>
<if>if <condition>(<expr>! <call><name>is_valid_proplist_skel</name><argument_list>(<argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>skel_err</name><argument_list>(<argument><expr>"proplist"</expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr>*<name>skel_p</name> = <name>skel</name></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__unparse_revision_skel</name><parameter_list>(<param><decl><type><name>skel_t</name> **</type><name>skel_p</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>revision_t</name> *</type><name>revision</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>skel_t</name> *</type><name>skel</name></decl>;</decl_stmt>
<expr_stmt><expr><name>skel</name> = <call><name>svn_fs_base__make_empty_list</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr><name><name>revision</name>-&gt;<name>txn_id</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr>"revision"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>! <call><name>is_valid_revision_skel</name><argument_list>(<argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>skel_err</name><argument_list>(<argument><expr>"revision"</expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr>*<name>skel_p</name> = <name>skel</name></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__unparse_transaction_skel</name><parameter_list>(<param><decl><type><name>skel_t</name> **</type><name>skel_p</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>transaction_t</name> *</type><name>transaction</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>skel_t</name> *</type><name>skel</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>skel_t</name> *</type><name>proplist_skel</name></decl>, *<decl><type ref="prev"/><name>copies_skel</name></decl>, *<decl><type ref="prev"/><name>header_skel</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_string_t</name> *</type><name>id_str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>transaction_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>
<expr_stmt><expr><name>skel</name> = <call><name>svn_fs_base__make_empty_list</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name><name>transaction</name>-&gt;<name>kind</name></name></expr>)</condition> <block>{
<case>case <expr><name>transaction_kind_committed</name></expr>:
<expr_stmt><expr><name>header_skel</name> = <call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr>"committed"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>(<name><name>transaction</name>-&gt;<name>base_id</name></name>)
|| (! <call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name><name>transaction</name>-&gt;<name>revision</name></name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
<return>return <expr><call><name>skel_err</name><argument_list>(<argument><expr>"transaction"</expr></argument>)</argument_list></call></expr>;</return></then></if>
<break>break;</break>
</case><case>case <expr><name>transaction_kind_dead</name></expr>:
<expr_stmt><expr><name>header_skel</name> = <call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr>"dead"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>(! <name><name>transaction</name>-&gt;<name>base_id</name></name>)
|| (<call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name><name>transaction</name>-&gt;<name>revision</name></name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
<return>return <expr><call><name>skel_err</name><argument_list>(<argument><expr>"transaction"</expr></argument>)</argument_list></call></expr>;</return></then></if>
<break>break;</break>
</case><case>case <expr><name>transaction_kind_normal</name></expr>:
<expr_stmt><expr><name>header_skel</name> = <call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr>"transaction"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>(! <name><name>transaction</name>-&gt;<name>base_id</name></name>)
|| (<call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name><name>transaction</name>-&gt;<name>revision</name></name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
<return>return <expr><call><name>skel_err</name><argument_list>(<argument><expr>"transaction"</expr></argument>)</argument_list></call></expr>;</return></then></if>
<break>break;</break>
</case><default>default:
<return>return <expr><call><name>skel_err</name><argument_list>(<argument><expr>"transaction"</expr></argument>)</argument_list></call></expr>;</return>
</default>}</block></switch>
<expr_stmt><expr><name>copies_skel</name> = <call><name>svn_fs_base__make_empty_list</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>transaction</name>-&gt;<name>copies</name></name> &amp;&amp; <name><name>transaction</name>-&gt;<name>copies</name>-&gt;<name>nelts</name></name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = <name><name>transaction</name>-&gt;<name>copies</name>-&gt;<name>nelts</name></name> - 1</expr>;</init> <condition><expr><name>i</name> &gt;= 0</expr>;</condition> <incr><expr><name>i</name>--</expr></incr>) <block>{
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name>
<argument_list>(<argument><expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name><name>transaction</name>-&gt;<name>copies</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>,
<argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>copies_skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
}</block></then></if>
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><name>copies_skel</name></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_base__unparse_proplist_skel</name><argument_list>(<argument><expr>&amp;<name>proplist_skel</name></expr></argument>,
<argument><expr><name><name>transaction</name>-&gt;<name>proplist</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><name>proplist_skel</name></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>transaction</name>-&gt;<name>kind</name></name> == <name>transaction_kind_committed</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name>
<argument_list>(<argument><expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%ld"</expr></argument>,
<argument><expr><name><name>transaction</name>-&gt;<name>revision</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>id_str</name> = <call><name>svn_fs_base__id_unparse</name><argument_list>(<argument><expr><name><name>transaction</name>-&gt;<name>base_id</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__mem_atom</name><argument_list>(<argument><expr><name><name>id_str</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>id_str</name>-&gt;<name>len</name></name></expr></argument>,
<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><name>id_str</name> = <call><name>svn_fs_base__id_unparse</name><argument_list>(<argument><expr><name><name>transaction</name>-&gt;<name>root_id</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__mem_atom</name><argument_list>(<argument><expr><name><name>id_str</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>id_str</name>-&gt;<name>len</name></name></expr></argument>,
<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><name>header_skel</name></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>! <call><name>is_valid_transaction_skel</name><argument_list>(<argument><expr><name>skel</name></expr></argument>, <argument><expr>&amp;<name>kind</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>skel_err</name><argument_list>(<argument><expr>"transaction"</expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><name>kind</name> != <name><name>transaction</name>-&gt;<name>kind</name></name></expr>)</condition><then>
<return>return <expr><call><name>skel_err</name><argument_list>(<argument><expr>"transaction"</expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr>*<name>skel_p</name> = <name>skel</name></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__unparse_representation_skel</name><parameter_list>(<param><decl><type><name>skel_t</name> **</type><name>skel_p</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>representation_t</name> *</type><name>rep</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>skel_t</name> *</type><name>skel</name> <init>= <expr><call><name>svn_fs_base__make_empty_list</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>skel_t</name> *</type><name>header_skel</name> <init>= <expr><call><name>svn_fs_base__make_empty_list</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<block>{
<decl_stmt><decl><type><name>skel_t</name> *</type><name>checksum_skel</name> <init>= <expr><call><name>svn_fs_base__make_empty_list</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__mem_atom</name>
<argument_list>(<argument><expr><name><name>rep</name>-&gt;<name>checksum</name></name></expr></argument>, <argument><expr><name>APR_MD5_DIGESTSIZE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>checksum_skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr>"md5"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>checksum_skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><name>checksum_skel</name></expr></argument>, <argument><expr><name>header_skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block>
<if>if <condition>(<expr><name><name>rep</name>-&gt;<name>txn_id</name></name></expr>)</condition><then>
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr><name><name>rep</name>-&gt;<name>txn_id</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>header_skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__mem_atom</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>header_skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<if>if <condition>(<expr><name><name>rep</name>-&gt;<name>kind</name></name> == <name>rep_kind_fulltext</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>(! <name><name>rep</name>-&gt;<name>contents</name>.<name>fulltext</name>.<name>string_key</name></name>)
|| (! *<name><name>rep</name>-&gt;<name>contents</name>.<name>fulltext</name>.<name>string_key</name></name>)</expr>)</condition><then>
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__mem_atom</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name>
<argument_list>(<argument><expr><name><name>rep</name>-&gt;<name>contents</name>.<name>fulltext</name>.<name>string_key</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr>"fulltext"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>header_skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><name>header_skel</name></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name><name>rep</name>-&gt;<name>kind</name></name> == <name>rep_kind_delta</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>chunks</name> <init>= <expr><name><name>rep</name>-&gt;<name>contents</name>.<name>delta</name>.<name>chunks</name></name></expr></init></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = <name><name>chunks</name>-&gt;<name>nelts</name></name></expr>;</init> <condition><expr><name>i</name> &gt; 0</expr>;</condition> <incr><expr><name>i</name>--</expr></incr>) <block>{
<decl_stmt><decl><type><name>skel_t</name> *</type><name>window_skel</name> <init>= <expr><call><name>svn_fs_base__make_empty_list</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>skel_t</name> *</type><name>chunk_skel</name> <init>= <expr><call><name>svn_fs_base__make_empty_list</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>skel_t</name> *</type><name>diff_skel</name> <init>= <expr><call><name>svn_fs_base__make_empty_list</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>size_str</name></decl>, *<decl><type ref="prev"/><name>offset_str</name></decl>, *<decl><type ref="prev"/><name>version_str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>rep_delta_chunk_t</name> *</type><name>chunk</name> <init>= <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>chunks</name></expr></argument>, <argument><expr><name>i</name> - 1</expr></argument>,
<argument><expr><name>rep_delta_chunk_t</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>offset_str</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%" <name>SVN_FILESIZE_T_FMT</name></expr></argument>,
<argument><expr><name><name>chunk</name>-&gt;<name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>size_str</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%" <name>APR_SIZE_T_FMT</name></expr></argument>, <argument><expr><name><name>chunk</name>-&gt;<name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>version_str</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%d"</expr></argument>, <argument><expr><name><name>chunk</name>-&gt;<name>version</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>(! <name><name>chunk</name>-&gt;<name>string_key</name></name>) || (! *<name><name>chunk</name>-&gt;<name>string_key</name></name>)</expr>)</condition><then>
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__mem_atom</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>diff_skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr><name><name>chunk</name>-&gt;<name>string_key</name></name></expr></argument>,
<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>diff_skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr><name>version_str</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>diff_skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr>"svndiff"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>diff_skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>(! <name><name>chunk</name>-&gt;<name>rep_key</name></name>) || (! *(<name><name>chunk</name>-&gt;<name>rep_key</name></name>))</expr>)</condition><then>
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__mem_atom</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>window_skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr><name><name>chunk</name>-&gt;<name>rep_key</name></name></expr></argument>,
<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>window_skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr><name>size_str</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>window_skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><name>diff_skel</name></expr></argument>, <argument><expr><name>window_skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><name>window_skel</name></expr></argument>, <argument><expr><name>chunk_skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr><name>offset_str</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>chunk_skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><name>chunk_skel</name></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr>"delta"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>header_skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><name>header_skel</name></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt></else></if></else></if>
<if>if <condition>(<expr>! <call><name>is_valid_representation_skel</name><argument_list>(<argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>skel_err</name><argument_list>(<argument><expr>"representation"</expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr>*<name>skel_p</name> = <name>skel</name></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__unparse_node_revision_skel</name><parameter_list>(<param><decl><type><name>skel_t</name> **</type><name>skel_p</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>node_revision_t</name> *</type><name>noderev</name></decl></param>,
<param><decl><type><name>int</name></type> <name>format</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>skel_t</name> *</type><name>skel</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>skel_t</name> *</type><name>header_skel</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>num_str</name></decl>;</decl_stmt>
<expr_stmt><expr><name>skel</name> = <call><name>svn_fs_base__make_empty_list</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>header_skel</name> = <call><name>svn_fs_base__make_empty_list</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>format</name> &gt;= <name>SVN_FS_BASE__MIN_MERGEINFO_FORMAT</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>num_str</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%" <name>APR_INT64_T_FMT</name></expr></argument>,
<argument><expr><name><name>noderev</name>-&gt;<name>mergeinfo_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr><name>num_str</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>header_skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__mem_atom</name><argument_list>(<argument><expr><name><name>noderev</name>-&gt;<name>has_mergeinfo</name></name>
? "1" : "0"</expr></argument>,
<argument><expr>1</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>header_skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>noderev</name>-&gt;<name>predecessor_count</name></name> == -1</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__mem_atom</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>header_skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
<if>if <condition>(<expr><name><name>noderev</name>-&gt;<name>predecessor_count</name></name> != -1</expr>)</condition><then> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>count_str</name> <init>= <expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%d"</expr></argument>,
<argument><expr><name><name>noderev</name>-&gt;<name>predecessor_count</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr><name>count_str</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>header_skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name><name>noderev</name>-&gt;<name>predecessor_id</name></name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>svn_string_t</name> *</type><name>id_str</name> <init>= <expr><call><name>svn_fs_base__id_unparse</name><argument_list>(<argument><expr><name><name>noderev</name>-&gt;<name>predecessor_id</name></name></expr></argument>,
<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__mem_atom</name><argument_list>(<argument><expr><name><name>id_str</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>id_str</name>-&gt;<name>len</name></name></expr></argument>,
<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>header_skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__mem_atom</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>header_skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr><name><name>noderev</name>-&gt;<name>created_path</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>header_skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>noderev</name>-&gt;<name>kind</name></name> == <name>svn_node_file</name></expr>)</condition><then>
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr>"file"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>header_skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name><name>noderev</name>-&gt;<name>kind</name></name> == <name>svn_node_dir</name></expr>)</condition><then>
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr>"dir"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>header_skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt></else></if></else></if>
<if>if <condition>(<expr>(<name><name>noderev</name>-&gt;<name>edit_key</name></name>) &amp;&amp; (*<name><name>noderev</name>-&gt;<name>edit_key</name></name>)</expr>)</condition><then>
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr><name><name>noderev</name>-&gt;<name>edit_key</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr>(<name><name>noderev</name>-&gt;<name>data_key</name></name>) &amp;&amp; (*<name><name>noderev</name>-&gt;<name>data_key</name></name>)</expr>)</condition><then>
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr><name><name>noderev</name>-&gt;<name>data_key</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__mem_atom</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<if>if <condition>(<expr>(<name><name>noderev</name>-&gt;<name>prop_key</name></name>) &amp;&amp; (*<name><name>noderev</name>-&gt;<name>prop_key</name></name>)</expr>)</condition><then>
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr><name><name>noderev</name>-&gt;<name>prop_key</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__mem_atom</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><name>header_skel</name></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>! <call><name>is_valid_node_revision_skel</name><argument_list>(<argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>skel_err</name><argument_list>(<argument><expr>"node-revision"</expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr>*<name>skel_p</name> = <name>skel</name></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__unparse_copy_skel</name><parameter_list>(<param><decl><type><name>skel_t</name> **</type><name>skel_p</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>copy_t</name> *</type><name>copy</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>skel_t</name> *</type><name>skel</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_string_t</name> *</type><name>tmp_str</name></decl>;</decl_stmt>
<expr_stmt><expr><name>skel</name> = <call><name>svn_fs_base__make_empty_list</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>tmp_str</name> = <call><name>svn_fs_base__id_unparse</name><argument_list>(<argument><expr><name><name>copy</name>-&gt;<name>dst_noderev_id</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__mem_atom</name><argument_list>(<argument><expr><name><name>tmp_str</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>tmp_str</name>-&gt;<name>len</name></name></expr></argument>,
<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>(<name><name>copy</name>-&gt;<name>src_txn_id</name></name>) &amp;&amp; (*<name><name>copy</name>-&gt;<name>src_txn_id</name></name>)</expr>)</condition><then>
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr><name><name>copy</name>-&gt;<name>src_txn_id</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__mem_atom</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<if>if <condition>(<expr>(<name><name>copy</name>-&gt;<name>src_path</name></name>) &amp;&amp; (*<name><name>copy</name>-&gt;<name>src_path</name></name>)</expr>)</condition><then>
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr><name><name>copy</name>-&gt;<name>src_path</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__mem_atom</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<if>if <condition>(<expr><name><name>copy</name>-&gt;<name>kind</name></name> == <name>copy_kind_real</name></expr>)</condition><then>
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr>"copy"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr>"soft-copy"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<if>if <condition>(<expr>! <call><name>is_valid_copy_skel</name><argument_list>(<argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>skel_err</name><argument_list>(<argument><expr>"copy"</expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr>*<name>skel_p</name> = <name>skel</name></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__unparse_entries_skel</name><parameter_list>(<param><decl><type><name>skel_t</name> **</type><name>skel_p</name></decl></param>,
<param><decl><type><name>apr_hash_t</name> *</type><name>entries</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>skel_t</name> *</type><name>skel</name> <init>= <expr><call><name>svn_fs_base__make_empty_list</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>entries</name></expr>)</condition><then> <block>{
<for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>entries</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>hi</name></expr>;</condition> <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>) <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_ssize_t</name></type> <name>klen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_fs_id_t</name> *</type><name>value</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_string_t</name> *</type><name>id_str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>skel_t</name> *</type><name>entry_skel</name> <init>= <expr><call><name>svn_fs_base__make_empty_list</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr>&amp;<name>klen</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>value</name> = <name>val</name></expr>;</expr_stmt>
<expr_stmt><expr><name>id_str</name> = <call><name>svn_fs_base__id_unparse</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__mem_atom</name><argument_list>(<argument><expr><name><name>id_str</name>-&gt;<name>data</name></name></expr></argument>,
<argument><expr><name><name>id_str</name>-&gt;<name>len</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>entry_skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__mem_atom</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>klen</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>entry_skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><name>entry_skel</name></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
}</block></then></if>
<expr_stmt><expr>*<name>skel_p</name> = <name>skel</name></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__unparse_change_skel</name><parameter_list>(<param><decl><type><name>skel_t</name> **</type><name>skel_p</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>change_t</name> *</type><name>change</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>skel_t</name> *</type><name>skel</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_string_t</name> *</type><name>tmp_str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_fs_path_change_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>
<expr_stmt><expr><name>skel</name> = <call><name>svn_fs_base__make_empty_list</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>change</name>-&gt;<name>prop_mod</name></name></expr>)</condition><then>
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr>"1"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__mem_atom</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<if>if <condition>(<expr><name><name>change</name>-&gt;<name>text_mod</name></name></expr>)</condition><then>
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr>"1"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__mem_atom</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<switch>switch <condition>(<expr><name><name>change</name>-&gt;<name>kind</name></name></expr>)</condition> <block>{
<case>case <expr><name>svn_fs_path_change_reset</name></expr>:
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr>"reset"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>svn_fs_path_change_add</name></expr>:
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr>"add"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>svn_fs_path_change_delete</name></expr>:
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr>"delete"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>svn_fs_path_change_replace</name></expr>:
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr>"replace"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>svn_fs_path_change_modify</name></expr>:
</case><default>default:
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr>"modify"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</default>}</block></switch>
<if>if <condition>(<expr><name><name>change</name>-&gt;<name>noderev_id</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>tmp_str</name> = <call><name>svn_fs_base__id_unparse</name><argument_list>(<argument><expr><name><name>change</name>-&gt;<name>noderev_id</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__mem_atom</name><argument_list>(<argument><expr><name><name>tmp_str</name>-&gt;<name>data</name></name></expr></argument>,
<argument><expr><name><name>tmp_str</name>-&gt;<name>len</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__mem_atom</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr><name><name>change</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr>"change"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>! <call><name>is_valid_change_skel</name><argument_list>(<argument><expr><name>skel</name></expr></argument>, <argument><expr>&amp;<name>kind</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>skel_err</name><argument_list>(<argument><expr>"change"</expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><name>kind</name> != <name><name>change</name>-&gt;<name>kind</name></name></expr>)</condition><then>
<return>return <expr><call><name>skel_err</name><argument_list>(<argument><expr>"change"</expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr>*<name>skel_p</name> = <name>skel</name></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_base__unparse_lock_skel</name><parameter_list>(<param><decl><type><name>skel_t</name> **</type><name>skel_p</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>svn_lock_t</name> *</type><name>lock</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>skel_t</name> *</type><name>skel</name></decl>;</decl_stmt>
<expr_stmt><expr><name>skel</name> = <call><name>svn_fs_base__make_empty_list</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>lock</name>-&gt;<name>expiration_date</name></name></expr>)</condition><then>
<expr_stmt><expr><call><name>svn_fs_base__prepend</name>
<argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name>
<argument_list>(<argument><expr><call><name>svn_time_to_cstring</name><argument_list>(<argument><expr><name><name>lock</name>-&gt;<name>expiration_date</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__mem_atom</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<expr_stmt><expr><call><name>svn_fs_base__prepend</name>
<argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name>
<argument_list>(<argument><expr><call><name>svn_time_to_cstring</name><argument_list>(<argument><expr><name><name>lock</name>-&gt;<name>creation_date</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>lock</name>-&gt;<name>is_dav_comment</name></name></expr>)</condition><then>
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr>"1"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr>"0"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<if>if <condition>(<expr><name><name>lock</name>-&gt;<name>comment</name></name></expr>)</condition><then>
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr><name><name>lock</name>-&gt;<name>comment</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__mem_atom</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr><name><name>lock</name>-&gt;<name>owner</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr><name><name>lock</name>-&gt;<name>token</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr><name><name>lock</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>svn_fs_base__prepend</name><argument_list>(<argument><expr><call><name>svn_fs_base__str_atom</name><argument_list>(<argument><expr>"lock"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>! <call><name>is_valid_lock_skel</name><argument_list>(<argument><expr><name>skel</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>skel_err</name><argument_list>(<argument><expr>"lock"</expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr>*<name>skel_p</name> = <name>skel</name></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
</unit>
