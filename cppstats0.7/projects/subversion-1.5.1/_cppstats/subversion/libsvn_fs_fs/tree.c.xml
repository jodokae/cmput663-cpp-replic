<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="subversion/libsvn_fs_fs/tree.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_pools.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_hash.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_private_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_pools.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_error.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_path.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_md5.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_mergeinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_fs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"err.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"key-gen.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dag.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fs_fs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"id.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"private/svn_mergeinfo_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"private/svn_fs_util.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../libsvn_fs/fs-loader.h"</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_BUFFER_SIZE</name></cpp:macro> <cpp:value>512000</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TXN_NODE_CACHE_MAX_KEYS</name></cpp:macro> <cpp:value>32</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REV_NODE_CACHE_MAX_KEYS</name></cpp:macro> <cpp:value>128</cpp:value></cpp:define>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>dag_node_t</name> *</type><name>root_dir</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>copyfrom_cache</name></decl>;</decl_stmt>
}</block></struct></type> <name>fs_rev_root_data_t</name>;</typedef>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>dag_node_cache_t</name></type> <name>txn_node_list</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>txn_node_cache</name></decl>;</decl_stmt>
}</block></struct></type> <name>fs_txn_root_data_t</name>;</typedef>
<function_decl><type><specifier>static</specifier> <name>svn_error_t</name> *</type> <name>get_dag</name><parameter_list>(<param><decl><type><name>dag_node_t</name> **</type><name>dag_node_p</name></decl></param>, <param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>svn_fs_root_t</name> *</type><name>make_revision_root</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>, <param><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl></param>,
<param><decl><type><name>dag_node_t</name> *</type><name>root_dir</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>svn_fs_root_t</name> *</type><name>make_txn_root</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn</name></decl></param>,
<param><decl><type><name>svn_revnum_t</name></type> <name>base_rev</name></decl></param>, <param><decl><type><name>apr_uint32_t</name></type> <name>flags</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>locate_cache</name><parameter_list>(<param><decl><type><name>dag_node_cache_t</name> **</type><name>node_list</name></decl></param>,
<param><decl><type><name>apr_hash_t</name> **</type><name>node_cache</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>key</name></decl></param>,
<param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name><name>root</name>-&gt;<name>is_txn_root</name></name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>fs_txn_root_data_t</name> *</type><name>frd</name> <init>= <expr><name><name>root</name>-&gt;<name>fsap_data</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr>*<name>node_list</name> = &amp;<name><name>frd</name>-&gt;<name>txn_node_list</name></name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>node_cache</name> = <name><name>frd</name>-&gt;<name>txn_node_cache</name></name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>key</name> = <name>path</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>fs_fs_data_t</name> *</type><name>ffd</name> <init>= <expr><name><name>root</name>-&gt;<name>fs</name>-&gt;<name>fsap_data</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr>*<name>node_list</name> = &amp;<name><name>ffd</name>-&gt;<name>rev_node_list</name></name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>node_cache</name> = <name><name>ffd</name>-&gt;<name>rev_node_cache</name></name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>key</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%ld%s"</expr></argument>,
<argument><expr><name><name>root</name>-&gt;<name>rev</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
}</block></function>
<function><type><specifier>static</specifier> <name>dag_node_t</name> *</type>
<name>dag_node_cache_get</name><parameter_list>(<param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>dag_node_cache_t</name> *</type><name>item</name></decl>, *<decl><type ref="prev"/><name>node_list</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>node_cache</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>key</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>*<name>path</name> == '/'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>locate_cache</name><argument_list>(<argument><expr>&amp;<name>node_list</name></expr></argument>, <argument><expr>&amp;<name>node_cache</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>,
<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>item</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>node_cache</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>item</name> &amp;&amp; <name><name>item</name>-&gt;<name>node</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>item</name>-&gt;<name>prev</name>-&gt;<name>next</name></name> = <name><name>item</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>item</name>-&gt;<name>next</name>-&gt;<name>prev</name></name> = <name><name>item</name>-&gt;<name>prev</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>item</name>-&gt;<name>prev</name></name> = <name>node_list</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>item</name>-&gt;<name>next</name></name> = <name><name>node_list</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>item</name>-&gt;<name>prev</name>-&gt;<name>next</name></name> = <name>item</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>item</name>-&gt;<name>next</name>-&gt;<name>prev</name></name> = <name>item</name></expr>;</expr_stmt>
<return>return <expr><call><name>svn_fs_fs__dag_dup</name><argument_list>(<argument><expr><name><name>item</name>-&gt;<name>node</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dag_node_cache_set</name><parameter_list>(<param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
<param><decl><type><name>dag_node_t</name> *</type><name>node</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>temp_pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>dag_node_cache_t</name> *</type><name>item</name></decl>, *<decl><type ref="prev"/><name>node_list</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>node_cache</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>key</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>max_keys</name> <init>= <expr><name><name>root</name>-&gt;<name>is_txn_root</name></name>
? <name>TXN_NODE_CACHE_MAX_KEYS</name> : <name>REV_NODE_CACHE_MAX_KEYS</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>*<name>path</name> == '/'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>locate_cache</name><argument_list>(<argument><expr>&amp;<name>node_list</name></expr></argument>, <argument><expr>&amp;<name>node_cache</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>,
<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>temp_pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>item</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>node_cache</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>item</name> &amp;&amp; <call><name>apr_hash_count</name><argument_list>(<argument><expr><name>node_cache</name></expr></argument>)</argument_list></call> == <name>max_keys</name></expr>)</condition><then>
<expr_stmt><expr><name>item</name> = <name><name>node_list</name>-&gt;<name>prev</name></name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>item</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>item</name>-&gt;<name>prev</name>-&gt;<name>next</name></name> = <name><name>item</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>item</name>-&gt;<name>next</name>-&gt;<name>prev</name></name> = <name><name>item</name>-&gt;<name>prev</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>node_cache</name></expr></argument>, <argument><expr><name><name>item</name>-&gt;<name>key</name></name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>pool</name> = <name><name>item</name>-&gt;<name>pool</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>parent_pool</name> <init>= <expr><name><name>root</name>-&gt;<name>is_txn_root</name></name> ? <name><name>root</name>-&gt;<name>pool</name></name> : <name><name>root</name>-&gt;<name>fs</name>-&gt;<name>pool</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>pool</name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name>parent_pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><name>item</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>item</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>item</name>-&gt;<name>key</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>item</name>-&gt;<name>node</name></name> = <call><name>svn_fs_fs__dag_dup</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>item</name>-&gt;<name>pool</name></name> = <name>pool</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>item</name>-&gt;<name>prev</name></name> = <name>node_list</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>item</name>-&gt;<name>next</name></name> = <name><name>node_list</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>item</name>-&gt;<name>prev</name>-&gt;<name>next</name></name> = <name>item</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>item</name>-&gt;<name>next</name>-&gt;<name>prev</name></name> = <name>item</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>node_cache</name></expr></argument>, <argument><expr><name><name>item</name>-&gt;<name>key</name></name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dag_node_cache_invalidate</name><parameter_list>(<param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>fs_txn_root_data_t</name> *</type><name>frd</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>key</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dag_node_cache_t</name> *</type><name>item</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>root</name>-&gt;<name>is_txn_root</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>frd</name> = <name><name>root</name>-&gt;<name>fsap_data</name></name></expr>;</expr_stmt>
<for>for (<init><expr><name>item</name> = <name><name>frd</name>-&gt;<name>txn_node_list</name>.<name>next</name></name></expr>;</init>
<condition><expr><name>item</name> != &amp;<name><name>frd</name>-&gt;<name>txn_node_list</name></name></expr>;</condition>
<incr><expr><name>item</name> = <name><name>item</name>-&gt;<name>next</name></name></expr></incr>) <block>{
<expr_stmt><expr><name>key</name> = <name><name>item</name>-&gt;<name>key</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> == 0 &amp;&amp; (<name><name>key</name><index>[<expr><name>len</name></expr>]</index></name> == '/' || !<name><name>key</name><index>[<expr><name>len</name></expr>]</index></name>)</expr>)</condition><then>
<expr_stmt><expr><name><name>item</name>-&gt;<name>node</name></name> = <name>NULL</name></expr>;</expr_stmt></then></if>
}</block></for>
}</block></function>
<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__txn_root</name><parameter_list>(<param><decl><type><name>svn_fs_root_t</name> **</type><name>root_p</name></decl></param>,
<param><decl><type><name>svn_fs_txn_t</name> *</type><name>txn</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_uint32_t</name></type> <name>flags</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>txnprops</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__txn_proplist</name><argument_list>(<argument><expr>&amp;<name>txnprops</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>txnprops</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>apr_hash_get</name><argument_list>(<argument><expr><name>txnprops</name></expr></argument>, <argument><expr><name>SVN_FS__PROP_TXN_CHECK_OOD</name></expr></argument>,
<argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>flags</name> |= <name>SVN_FS_TXN_CHECK_OOD</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><call><name>apr_hash_get</name><argument_list>(<argument><expr><name>txnprops</name></expr></argument>, <argument><expr><name>SVN_FS__PROP_TXN_CHECK_LOCKS</name></expr></argument>,
<argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>flags</name> |= <name>SVN_FS_TXN_CHECK_LOCKS</name></expr>;</expr_stmt></then></if>
}</block></then></if>
<expr_stmt><expr><name>root</name> = <call><name>make_txn_root</name><argument_list>(<argument><expr><name><name>txn</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name><name>txn</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name><name>txn</name>-&gt;<name>base_rev</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>root_p</name> = <name>root</name></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__revision_root</name><parameter_list>(<param><decl><type><name>svn_fs_root_t</name> **</type><name>root_p</name></decl></param>,
<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
<param><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>dag_node_t</name> *</type><name>root_dir</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs__check_fs</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_revision_root</name><argument_list>(<argument><expr>&amp;<name>root_dir</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>root_p</name> = <call><name>make_revision_root</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name>root_dir</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>root_node</name><parameter_list>(<param><decl><type><name>dag_node_t</name> **</type><name>node_p</name></decl></param>,
<param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name><name>root</name>-&gt;<name>is_txn_root</name></name></expr>)</condition><then> <block>{
<return>return <expr><call><name>svn_fs_fs__dag_txn_root</name><argument_list>(<argument><expr><name>node_p</name></expr></argument>, <argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name><name>root</name>-&gt;<name>txn</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>fs_rev_root_data_t</name> *</type><name>frd</name> <init>= <expr><name><name>root</name>-&gt;<name>fsap_data</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr>*<name>node_p</name> = <call><name>svn_fs_fs__dag_dup</name><argument_list>(<argument><expr><name><name>frd</name>-&gt;<name>root_dir</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></else></if>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>mutable_root_node</name><parameter_list>(<param><decl><type><name>dag_node_t</name> **</type><name>node_p</name></decl></param>,
<param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>error_path</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name><name>root</name>-&gt;<name>is_txn_root</name></name></expr>)</condition><then>
<return>return <expr><call><name>svn_fs_fs__dag_clone_root</name><argument_list>(<argument><expr><name>node_p</name></expr></argument>, <argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name><name>root</name>-&gt;<name>txn</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return></then>
<else>else
<return>return <expr><call><name>SVN_FS__ERR_NOT_MUTABLE</name><argument_list>(<argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name><name>root</name>-&gt;<name>rev</name></name></expr></argument>, <argument><expr><name>error_path</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>
<typedef>typedef <type><enum>enum <name>copy_id_inherit_t</name> <block>{
<decl><name>copy_id_inherit_unknown</name> <init>= <expr>0</expr></init></decl>,
<decl><name>copy_id_inherit_self</name></decl>,
<decl><name>copy_id_inherit_parent</name></decl>,
<decl><name>copy_id_inherit_new</name></decl>
}</block></enum></type> <name>copy_id_inherit_t</name>;</typedef>
<typedef>typedef <type><struct>struct <name>parent_path_t</name> <block>{
<decl_stmt><decl><type><name>dag_node_t</name> *</type><name>node</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>entry</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>parent_path_t</name> *</type><name>parent</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>copy_id_inherit_t</name></type> <name>copy_inherit</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copy_src_path</name></decl>;</decl_stmt>
}</block></struct></type> <name>parent_path_t</name>;</typedef>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type>
<name>parent_path_path</name><parameter_list>(<param><decl><type><name>parent_path_t</name> *</type><name>parent_path</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path_so_far</name> <init>= <expr>"/"</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>parent_path</name>-&gt;<name>parent</name></name></expr>)</condition><then>
<expr_stmt><expr><name>path_so_far</name> = <call><name>parent_path_path</name><argument_list>(<argument><expr><name><name>parent_path</name>-&gt;<name>parent</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name><name>parent_path</name>-&gt;<name>entry</name></name>
? <call><name>svn_path_join</name><argument_list>(<argument><expr><name>path_so_far</name></expr></argument>, <argument><expr><name><name>parent_path</name>-&gt;<name>entry</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call>
: <name>path_so_far</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type>
<name>parent_path_relpath</name><parameter_list>(<param><decl><type><name>parent_path_t</name> *</type><name>child</name></decl></param>,
<param><decl><type><name>parent_path_t</name> *</type><name>ancestor</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path_so_far</name> <init>= <expr>""</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>parent_path_t</name> *</type><name>this_node</name> <init>= <expr><name>child</name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr><name>this_node</name> != <name>ancestor</name></expr>)</condition> <block>{
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>this_node</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>path_so_far</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name><name>this_node</name>-&gt;<name>entry</name></name></expr></argument>, <argument><expr><name>path_so_far</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>this_node</name> = <name><name>this_node</name>-&gt;<name>parent</name></name></expr>;</expr_stmt>
}</block></while>
<return>return <expr><name>path_so_far</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>get_copy_inheritance</name><parameter_list>(<param><decl><type><name>copy_id_inherit_t</name> *</type><name>inherit_p</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>copy_src_path</name></decl></param>,
<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
<param><decl><type><name>parent_path_t</name> *</type><name>child</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>child_id</name></decl>, *<decl><type ref="prev"/><name>parent_id</name></decl>, *<decl><type ref="prev"/><name>copyroot_id</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>child_copy_id</name></decl>, *<decl><type ref="prev"/><name>parent_copy_id</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>id_path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>copyroot_root</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dag_node_t</name> *</type><name>copyroot_node</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>copyroot_rev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copyroot_path</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>child</name> &amp;&amp; <name><name>child</name>-&gt;<name>parent</name></name> &amp;&amp; <name>txn_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>child_id</name> = <call><name>svn_fs_fs__dag_get_id</name><argument_list>(<argument><expr><name><name>child</name>-&gt;<name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>parent_id</name> = <call><name>svn_fs_fs__dag_get_id</name><argument_list>(<argument><expr><name><name>child</name>-&gt;<name>parent</name>-&gt;<name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>child_copy_id</name> = <call><name>svn_fs_fs__id_copy_id</name><argument_list>(<argument><expr><name>child_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>parent_copy_id</name> = <call><name>svn_fs_fs__id_copy_id</name><argument_list>(<argument><expr><name>parent_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>svn_fs_fs__id_txn_id</name><argument_list>(<argument><expr><name>child_id</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>inherit_p</name> = <name>copy_id_inherit_self</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>copy_src_path</name> = <name>NULL</name></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr>*<name>inherit_p</name> = <name>copy_id_inherit_parent</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>copy_src_path</name> = <name>NULL</name></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>child_copy_id</name></expr></argument>, <argument><expr>"0"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>svn_fs_fs__key_compare</name><argument_list>(<argument><expr><name>child_copy_id</name></expr></argument>, <argument><expr><name>parent_copy_id</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_copyroot</name><argument_list>(<argument><expr>&amp;<name>copyroot_rev</name></expr></argument>, <argument><expr>&amp;<name>copyroot_path</name></expr></argument>,
<argument><expr><name><name>child</name>-&gt;<name>node</name></name></expr></argument>,<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__revision_root</name><argument_list>(<argument><expr>&amp;<name>copyroot_root</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>copyroot_rev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_dag</name><argument_list>(<argument><expr>&amp;<name>copyroot_node</name></expr></argument>, <argument><expr><name>copyroot_root</name></expr></argument>, <argument><expr><name>copyroot_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>copyroot_id</name> = <call><name>svn_fs_fs__dag_get_id</name><argument_list>(<argument><expr><name>copyroot_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>svn_fs_fs__id_compare</name><argument_list>(<argument><expr><name>copyroot_id</name></expr></argument>, <argument><expr><name>child_id</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>
<expr_stmt><expr><name>id_path</name> = <call><name>svn_fs_fs__dag_get_created_path</name><argument_list>(<argument><expr><name><name>child</name>-&gt;<name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>id_path</name></expr></argument>, <argument><expr><call><name>parent_path_path</name><argument_list>(<argument><expr><name>child</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>inherit_p</name> = <name>copy_id_inherit_self</name></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr>*<name>inherit_p</name> = <name>copy_id_inherit_new</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>copy_src_path</name> = <name>id_path</name></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>parent_path_t</name> *</type>
<name>make_parent_path</name><parameter_list>(<param><decl><type><name>dag_node_t</name> *</type><name>node</name></decl></param>,
<param><decl><type><name>char</name> *</type><name>entry</name></decl></param>,
<param><decl><type><name>parent_path_t</name> *</type><name>parent</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>parent_path_t</name> *</type><name>parent_path</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>parent_path</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>parent_path</name>-&gt;<name>node</name></name> = <name>node</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parent_path</name>-&gt;<name>entry</name></name> = <name>entry</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parent_path</name>-&gt;<name>parent</name></name> = <name>parent</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parent_path</name>-&gt;<name>copy_inherit</name></name> = <name>copy_id_inherit_unknown</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parent_path</name>-&gt;<name>copy_src_path</name></name> = <name>NULL</name></expr>;</expr_stmt>
<return>return <expr><name>parent_path</name></expr>;</return>
}</block></function>
<typedef>typedef <type><enum>enum <name>open_path_flags_t</name> <block>{
<decl><name>open_path_last_optional</name> <init>= <expr>1</expr></init></decl>
}</block></enum></type> <name>open_path_flags_t</name>;</typedef>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>open_path</name><parameter_list>(<param><decl><type><name>parent_path_t</name> **</type><name>parent_path_p</name></decl></param>,
<param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
<param><decl><type><name>int</name></type> <name>flags</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name> <init>= <expr><name><name>root</name>-&gt;<name>fs</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>id</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dag_node_t</name> *</type><name>here</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>parent_path_t</name> *</type><name>parent_path</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>rest</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>canon_path</name> <init>= <expr><call><name>svn_fs__canonicalize_abspath</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path_so_far</name> <init>= <expr>"/"</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>root_node</name><argument_list>(<argument><expr>&amp;<name>here</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>id</name> = <call><name>svn_fs_fs__dag_get_id</name><argument_list>(<argument><expr><name>here</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>parent_path</name> = <call><name>make_parent_path</name><argument_list>(<argument><expr><name>here</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parent_path</name>-&gt;<name>copy_inherit</name></name> = <name>copy_id_inherit_self</name></expr>;</expr_stmt>
<expr_stmt><expr><name>rest</name> = <name>canon_path</name> + 1</expr>;</expr_stmt>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>next</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>entry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dag_node_t</name> *</type><name>child</name></decl>;</decl_stmt>
<expr_stmt><expr><name>entry</name> = <call><name>svn_fs__next_entry_name</name><argument_list>(<argument><expr>&amp;<name>next</name></expr></argument>, <argument><expr><name>rest</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>path_so_far</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>path_so_far</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>*<name>entry</name> == '\0'</expr>)</condition><then> <block>{
<expr_stmt><expr><name>child</name> = <name>here</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>copy_id_inherit_t</name></type> <name>inherit</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copy_path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name> <init>= <expr><name>SVN_NO_ERROR</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dag_node_t</name> *</type><name>cached_node</name></decl>;</decl_stmt>
<expr_stmt><expr><name>cached_node</name> = <call><name>dag_node_cache_get</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path_so_far</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>cached_node</name></expr>)</condition><then>
<expr_stmt><expr><name>child</name> = <name>cached_node</name></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>err</name> = <call><name>svn_fs_fs__dag_open</name><argument_list>(<argument><expr>&amp;<name>child</name></expr></argument>, <argument><expr><name>here</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<if>if <condition>(<expr><name>err</name> &amp;&amp; <name><name>err</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_FS_NOT_FOUND</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>(<name>flags</name> &amp; <name>open_path_last_optional</name>)
&amp;&amp; (! <name>next</name> || *<name>next</name> == '\0')</expr>)</condition><then> <block>{
<expr_stmt><expr><name>parent_path</name> = <call><name>make_parent_path</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>parent_path</name></expr></argument>,
<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
}</block></then> <else>else <block>{
<return>return <expr><call><name>SVN_FS__NOT_FOUND</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></else></if>
}</block></then></if>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>parent_path</name> = <call><name>make_parent_path</name><argument_list>(<argument><expr><name>child</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>parent_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>txn_id</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_copy_inheritance</name><argument_list>(<argument><expr>&amp;<name>inherit</name></expr></argument>, <argument><expr>&amp;<name>copy_path</name></expr></argument>,
<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>parent_path</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parent_path</name>-&gt;<name>copy_inherit</name></name> = <name>inherit</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>parent_path</name>-&gt;<name>copy_src_path</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>copy_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr>! <name>cached_node</name></expr>)</condition><then>
<expr_stmt><expr><call><name>dag_node_cache_set</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path_so_far</name></expr></argument>, <argument><expr><name>child</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></else></if>
<if>if <condition>(<expr>! <name>next</name></expr>)</condition><then>
<break>break;</break></then></if>
<if>if <condition>(<expr><call><name>svn_fs_fs__dag_node_kind</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call> != <name>svn_node_dir</name></expr>)</condition><then>
<expr_stmt><expr><call><name>SVN_ERR_W</name><argument_list>(<argument><expr><call><name>SVN_FS__ERR_NOT_DIRECTORY</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>path_so_far</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Failure opening '%s'"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>rest</name> = <name>next</name></expr>;</expr_stmt>
<expr_stmt><expr><name>here</name> = <name>child</name></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr>*<name>parent_path_p</name> = <name>parent_path</name></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>make_path_mutable</name><parameter_list>(<param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
<param><decl><type><name>parent_path_t</name> *</type><name>parent_path</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>error_path</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>dag_node_t</name> *</type><name>clone</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name> <init>= <expr><name><name>root</name>-&gt;<name>txn</name></name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>svn_fs_fs__dag_check_mutable</name><argument_list>(<argument><expr><name><name>parent_path</name>-&gt;<name>node</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>
<if>if <condition>(<expr><name><name>parent_path</name>-&gt;<name>parent</name></name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>parent_id</name></decl>, *<decl><type ref="prev"/><name>child_id</name></decl>, *<decl><type ref="prev"/><name>copyroot_id</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copy_id</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>copy_id_inherit_t</name></type> <name>inherit</name> <init>= <expr><name><name>parent_path</name>-&gt;<name>copy_inherit</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>clone_path</name></decl>, *<decl><type ref="prev"/><name>copyroot_path</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>copyroot_rev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>is_parent_copyroot</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>copyroot_root</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dag_node_t</name> *</type><name>copyroot_node</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>make_path_mutable</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>parent_path</name>-&gt;<name>parent</name></name></expr></argument>,
<argument><expr><name>error_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name>inherit</name></expr>)</condition> <block>{
<case>case <expr><name>copy_id_inherit_parent</name></expr>:
<expr_stmt><expr><name>parent_id</name> = <call><name>svn_fs_fs__dag_get_id</name><argument_list>(<argument><expr><name><name>parent_path</name>-&gt;<name>parent</name>-&gt;<name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>copy_id</name> = <call><name>svn_fs_fs__id_copy_id</name><argument_list>(<argument><expr><name>parent_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>copy_id_inherit_new</name></expr>:
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__reserve_copy_id</name><argument_list>(<argument><expr>&amp;<name>copy_id</name></expr></argument>, <argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>,
<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>copy_id_inherit_self</name></expr>:
<expr_stmt><expr><name>copy_id</name> = <name>NULL</name></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>copy_id_inherit_unknown</name></expr>:
</case><default>default:
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</default>}</block></switch>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_copyroot</name><argument_list>(<argument><expr>&amp;<name>copyroot_rev</name></expr></argument>, <argument><expr>&amp;<name>copyroot_path</name></expr></argument>,
<argument><expr><name><name>parent_path</name>-&gt;<name>node</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__revision_root</name><argument_list>(<argument><expr>&amp;<name>copyroot_root</name></expr></argument>, <argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>,
<argument><expr><name>copyroot_rev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_dag</name><argument_list>(<argument><expr>&amp;<name>copyroot_node</name></expr></argument>, <argument><expr><name>copyroot_root</name></expr></argument>, <argument><expr><name>copyroot_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>child_id</name> = <call><name>svn_fs_fs__dag_get_id</name><argument_list>(<argument><expr><name><name>parent_path</name>-&gt;<name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>copyroot_id</name> = <call><name>svn_fs_fs__dag_get_id</name><argument_list>(<argument><expr><name>copyroot_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>svn_fs_fs__id_node_id</name><argument_list>(<argument><expr><name>child_id</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>svn_fs_fs__id_node_id</name><argument_list>(<argument><expr><name>copyroot_id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
<expr_stmt><expr><name>is_parent_copyroot</name> = <name>TRUE</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>clone_path</name> = <call><name>parent_path_path</name><argument_list>(<argument><expr><name><name>parent_path</name>-&gt;<name>parent</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_clone_child</name><argument_list>(<argument><expr>&amp;<name>clone</name></expr></argument>,
<argument><expr><name><name>parent_path</name>-&gt;<name>parent</name>-&gt;<name>node</name></name></expr></argument>,
<argument><expr><name>clone_path</name></expr></argument>,
<argument><expr><name><name>parent_path</name>-&gt;<name>entry</name></name></expr></argument>,
<argument><expr><name>copy_id</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>,
<argument><expr><name>is_parent_copyroot</name></expr></argument>,
<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dag_node_cache_set</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><call><name>parent_path_path</name><argument_list>(<argument><expr><name>parent_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>clone</name></expr></argument>,
<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>mutable_root_node</name><argument_list>(<argument><expr>&amp;<name>clone</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>error_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><name><name>parent_path</name>-&gt;<name>node</name></name> = <name>clone</name></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>get_dag</name><parameter_list>(<param><decl><type><name>dag_node_t</name> **</type><name>dag_node_p</name></decl></param>,
<param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>parent_path_t</name> *</type><name>parent_path</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dag_node_t</name> *</type><name>node</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>path</name> = <call><name>svn_fs__canonicalize_abspath</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>node</name> = <call><name>dag_node_cache_get</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>! <name>node</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>open_path</name><argument_list>(<argument><expr>&amp;<name>parent_path</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>node</name> = <name><name>parent_path</name>-&gt;<name>node</name></name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr>*<name>dag_node_p</name> = <name>node</name></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>add_change</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>noderev_id</name></decl></param>,
<param><decl><type><name>svn_fs_path_change_kind_t</name></type> <name>change_kind</name></decl></param>,
<param><decl><type><name>svn_boolean_t</name></type> <name>text_mod</name></decl></param>,
<param><decl><type><name>svn_boolean_t</name></type> <name>prop_mod</name></decl></param>,
<param><decl><type><name>svn_revnum_t</name></type> <name>copyfrom_rev</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copyfrom_path</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__add_change</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>,
<argument><expr><call><name>svn_fs__canonicalize_abspath</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>noderev_id</name></expr></argument>, <argument><expr><name>change_kind</name></expr></argument>, <argument><expr><name>text_mod</name></expr></argument>, <argument><expr><name>prop_mod</name></expr></argument>,
<argument><expr><name>copyfrom_rev</name></expr></argument>, <argument><expr><name>copyfrom_path</name></expr></argument>,
<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>fs_node_id</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> **</type><name>id_p</name></decl></param>,
<param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr>(! <name><name>root</name>-&gt;<name>is_txn_root</name></name>)
&amp;&amp; (<name><name>path</name><index>[<expr>0</expr>]</index></name> == '\0' || ((<name><name>path</name><index>[<expr>0</expr>]</index></name> == '/') &amp;&amp; (<name><name>path</name><index>[<expr>1</expr>]</index></name> == '\0')))</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>fs_rev_root_data_t</name> *</type><name>frd</name> <init>= <expr><name><name>root</name>-&gt;<name>fsap_data</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr>*<name>id_p</name> = <call><name>svn_fs_fs__id_copy</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_id</name><argument_list>(<argument><expr><name><name>frd</name>-&gt;<name>root_dir</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>dag_node_t</name> *</type><name>node</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_dag</name><argument_list>(<argument><expr>&amp;<name>node</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>id_p</name> = <call><name>svn_fs_fs__id_copy</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_id</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__node_created_rev</name><parameter_list>(<param><decl><type><name>svn_revnum_t</name> *</type><name>revision</name></decl></param>,
<param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>dag_node_t</name> *</type><name>node</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_dag</name><argument_list>(<argument><expr>&amp;<name>node</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_revision</name><argument_list>(<argument><expr><name>revision</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>fs_node_created_path</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>created_path</name></decl></param>,
<param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>dag_node_t</name> *</type><name>node</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_dag</name><argument_list>(<argument><expr>&amp;<name>node</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>created_path</name> = <call><name>svn_fs_fs__dag_get_created_path</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>node_kind</name><parameter_list>(<param><decl><type><name>svn_node_kind_t</name> *</type><name>kind_p</name></decl></param>,
<param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>node_id</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dag_node_t</name> *</type><name>node</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>fs_node_id</name><argument_list>(<argument><expr>&amp;<name>node_id</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_node</name><argument_list>(<argument><expr>&amp;<name>node</name></expr></argument>, <argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>node_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>kind_p</name> = <call><name>svn_fs_fs__dag_node_kind</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__check_path</name><parameter_list>(<param><decl><type><name>svn_node_kind_t</name> *</type><name>kind_p</name></decl></param>,
<param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name> <init>= <expr><call><name>node_kind</name><argument_list>(<argument><expr><name>kind_p</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>err</name> &amp;&amp;
((<name><name>err</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_FS_NOT_FOUND</name>)
|| (<name><name>err</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_FS_NOT_DIRECTORY</name>))</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>kind_p</name> = <name>svn_node_none</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>err</name></expr>)</condition><then> <block>{
<return>return <expr><name>err</name></expr>;</return>
}</block></then></if></else></if>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>fs_node_prop</name><parameter_list>(<param><decl><type><name>svn_string_t</name> **</type><name>value_p</name></decl></param>,
<param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>propname</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>dag_node_t</name> *</type><name>node</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>proplist</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_dag</name><argument_list>(<argument><expr>&amp;<name>node</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_proplist</name><argument_list>(<argument><expr>&amp;<name>proplist</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>value_p</name> = <name>NULL</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>proplist</name></expr>)</condition><then>
<expr_stmt><expr>*<name>value_p</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>proplist</name></expr></argument>, <argument><expr><name>propname</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>fs_node_proplist</name><parameter_list>(<param><decl><type><name>apr_hash_t</name> **</type><name>table_p</name></decl></param>,
<param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>table</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dag_node_t</name> *</type><name>node</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_dag</name><argument_list>(<argument><expr>&amp;<name>node</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_proplist</name><argument_list>(<argument><expr>&amp;<name>table</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>table_p</name> = <name>table</name> ? <name>table</name> : <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>increment_mergeinfo_up_tree</name><parameter_list>(<param><decl><type><name>parent_path_t</name> *</type><name>pp</name></decl></param>,
<param><decl><type><name>apr_int64_t</name></type> <name>increment</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<for>for (<init>;</init> <condition><expr><name>pp</name></expr>;</condition> <incr><expr><name>pp</name> = <name><name>pp</name>-&gt;<name>parent</name></name></expr></incr>)
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_increment_mergeinfo_count</name><argument_list>(<argument><expr><name><name>pp</name>-&gt;<name>node</name></name></expr></argument>,
<argument><expr><name>increment</name></expr></argument>,
<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>fs_change_node_prop</name><parameter_list>(<param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>value</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>parent_path_t</name> *</type><name>parent_path</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>proplist</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl>;</decl_stmt>
<if>if <condition>(<expr>! <name><name>root</name>-&gt;<name>is_txn_root</name></name></expr>)</condition><then>
<return>return <expr><call><name>SVN_FS__NOT_TXN</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>txn_id</name> = <name><name>root</name>-&gt;<name>txn</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>open_path</name><argument_list>(<argument><expr>&amp;<name>parent_path</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>root</name>-&gt;<name>txn_flags</name></name> &amp; <name>SVN_FS_TXN_CHECK_LOCKS</name></expr>)</condition><then>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__allow_locked_operation</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>make_path_mutable</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>parent_path</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_proplist</name><argument_list>(<argument><expr>&amp;<name>proplist</name></expr></argument>, <argument><expr><name><name>parent_path</name>-&gt;<name>node</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>(! <name>proplist</name>) &amp;&amp; (! <name>value</name>)</expr>)</condition><then>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>
<if>if <condition>(<expr>! <name>proplist</name></expr>)</condition><then>
<expr_stmt><expr><name>proplist</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><call><name>svn_fs_fs__fs_supports_mergeinfo</name><argument_list>(<argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>)</argument_list></call>
&amp;&amp; <call><name>strcmp</name> <argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>SVN_PROP_MERGEINFO</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>apr_int64_t</name></type> <name>increment</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>had_mergeinfo</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_has_mergeinfo</name><argument_list>(<argument><expr>&amp;<name>had_mergeinfo</name></expr></argument>, <argument><expr><name><name>parent_path</name>-&gt;<name>node</name></name></expr></argument>,
<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>value</name> &amp;&amp; !<name>had_mergeinfo</name></expr>)</condition><then>
<expr_stmt><expr><name>increment</name> = 1</expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr>!<name>value</name> &amp;&amp; <name>had_mergeinfo</name></expr>)</condition><then>
<expr_stmt><expr><name>increment</name> = -1</expr>;</expr_stmt></then></if></else></if>
<if>if <condition>(<expr><name>increment</name> != 0</expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>increment_mergeinfo_up_tree</name><argument_list>(<argument><expr><name>parent_path</name></expr></argument>, <argument><expr><name>increment</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_set_has_mergeinfo</name><argument_list>(<argument><expr><name><name>parent_path</name>-&gt;<name>node</name></name></expr></argument>,
<argument><expr>(<name>value</name> != <name>NULL</name>)</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
<expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>proplist</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_set_proplist</name><argument_list>(<argument><expr><name><name>parent_path</name>-&gt;<name>node</name></name></expr></argument>, <argument><expr><name>proplist</name></expr></argument>,
<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>add_change</name><argument_list>(<argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
<argument><expr><call><name>svn_fs_fs__dag_get_id</name><argument_list>(<argument><expr><name><name>parent_path</name>-&gt;<name>node</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>svn_fs_path_change_modify</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>SVN_INVALID_REVNUM</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>fs_props_changed</name><parameter_list>(<param><decl><type><name>svn_boolean_t</name> *</type><name>changed_p</name></decl></param>,
<param><decl><type><name>svn_fs_root_t</name> *</type><name>root1</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path1</name></decl></param>,
<param><decl><type><name>svn_fs_root_t</name> *</type><name>root2</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path2</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>dag_node_t</name> *</type><name>node1</name></decl>, *<decl><type ref="prev"/><name>node2</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>root1</name>-&gt;<name>fs</name></name> != <name><name>root2</name>-&gt;<name>fs</name></name></expr>)</condition><then>
<return>return <expr><call><name>svn_error_create</name>
<argument_list>(<argument><expr><name>SVN_ERR_FS_GENERAL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr>"Cannot compare property value between two different filesystems"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_dag</name><argument_list>(<argument><expr>&amp;<name>node1</name></expr></argument>, <argument><expr><name>root1</name></expr></argument>, <argument><expr><name>path1</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_dag</name><argument_list>(<argument><expr>&amp;<name>node2</name></expr></argument>, <argument><expr><name>root2</name></expr></argument>, <argument><expr><name>path2</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_things_different</name><argument_list>(<argument><expr><name>changed_p</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><name>node1</name></expr></argument>, <argument><expr><name>node2</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>get_root</name><parameter_list>(<param><decl><type><name>dag_node_t</name> **</type><name>node</name></decl></param>, <param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_dag</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr>""</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>update_ancestry</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>source_id</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>target_id</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>target_path</name></decl></param>,
<param><decl><type><name>int</name></type> <name>source_pred_count</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>node_revision_t</name> *</type><name>noderev</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>svn_fs_fs__id_txn_id</name><argument_list>(<argument><expr><name>target_id</name></expr></argument>)</argument_list></call> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><call><name>svn_error_createf</name>
<argument_list>(<argument><expr><name>SVN_ERR_FS_NOT_MUTABLE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr>"Unexpected immutable node at '%s'"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>target_path</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__get_node_revision</name><argument_list>(<argument><expr>&amp;<name>noderev</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>target_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>noderev</name>-&gt;<name>predecessor_id</name></name> = <name>source_id</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>noderev</name>-&gt;<name>predecessor_count</name></name> = <name>source_pred_count</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>noderev</name>-&gt;<name>predecessor_count</name></name> != -1</expr>)</condition><then>
<expr_stmt><expr><name><name>noderev</name>-&gt;<name>predecessor_count</name></name>++</expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__put_node_revision</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>target_id</name></expr></argument>, <argument><expr><name>noderev</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>conflict_err</name><parameter_list>(<param><decl><type><name>svn_stringbuf_t</name> *</type><name>conflict_path</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>svn_stringbuf_set</name><argument_list>(<argument><expr><name>conflict_path</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_FS_CONFLICT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr>"Conflict at '%s'"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>merge</name><parameter_list>(<param><decl><type><name>svn_stringbuf_t</name> *</type><name>conflict_p</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>target_path</name></decl></param>,
<param><decl><type><name>dag_node_t</name> *</type><name>target</name></decl></param>,
<param><decl><type><name>dag_node_t</name> *</type><name>source</name></decl></param>,
<param><decl><type><name>dag_node_t</name> *</type><name>ancestor</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>,
<param><decl><type><name>apr_int64_t</name> *</type><name>mergeinfo_increment_out</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>source_id</name></decl>, *<decl><type ref="prev"/><name>target_id</name></decl>, *<decl><type ref="prev"/><name>ancestor_id</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>s_entries</name></decl>, *<decl><type ref="prev"/><name>t_entries</name></decl>, *<decl><type ref="prev"/><name>a_entries</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>iterpool</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>pred_count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_int64_t</name></type> <name>mergeinfo_increment</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>fs</name> = <call><name>svn_fs_fs__dag_get_fs</name><argument_list>(<argument><expr><name>ancestor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>(<name>fs</name> != <call><name>svn_fs_fs__dag_get_fs</name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call>)
|| (<name>fs</name> != <call><name>svn_fs_fs__dag_get_fs</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
<return>return <expr><call><name>svn_error_create</name>
<argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr>"Bad merge; ancestor, source, and target not all in same fs"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs__check_fs</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>source_id</name> = <call><name>svn_fs_fs__dag_get_id</name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>target_id</name> = <call><name>svn_fs_fs__dag_get_id</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>ancestor_id</name> = <call><name>svn_fs_fs__dag_get_id</name><argument_list>(<argument><expr><name>ancestor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>svn_fs_fs__id_eq</name><argument_list>(<argument><expr><name>ancestor_id</name></expr></argument>, <argument><expr><name>target_id</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>svn_string_t</name> *</type><name>id_str</name> <init>= <expr><call><name>svn_fs_fs__id_unparse</name><argument_list>(<argument><expr><name>target_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>svn_error_createf</name>
<argument_list>(<argument><expr><name>SVN_ERR_FS_GENERAL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr>"Bad merge; target '%s' has id '%s', same as ancestor"</expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>target_path</name></expr></argument>, <argument><expr><name><name>id_str</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>svn_stringbuf_setempty</name><argument_list>(<argument><expr><name>conflict_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>svn_fs_fs__id_eq</name><argument_list>(<argument><expr><name>ancestor_id</name></expr></argument>, <argument><expr><name>source_id</name></expr></argument>)</argument_list></call>
|| (<call><name>svn_fs_fs__id_eq</name><argument_list>(<argument><expr><name>source_id</name></expr></argument>, <argument><expr><name>target_id</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>
<if>if <condition>(<expr>(<call><name>svn_fs_fs__dag_node_kind</name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call> != <name>svn_node_dir</name>)
|| (<call><name>svn_fs_fs__dag_node_kind</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call> != <name>svn_node_dir</name>)
|| (<call><name>svn_fs_fs__dag_node_kind</name><argument_list>(<argument><expr><name>ancestor</name></expr></argument>)</argument_list></call> != <name>svn_node_dir</name>)</expr>)</condition><then> <block>{
<return>return <expr><call><name>conflict_err</name><argument_list>(<argument><expr><name>conflict_p</name></expr></argument>, <argument><expr><name>target_path</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<block>{
<decl_stmt><decl><type><name>node_revision_t</name> *</type><name>tgt_nr</name></decl>, *<decl><type ref="prev"/><name>anc_nr</name></decl>, *<decl><type ref="prev"/><name>src_nr</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__get_node_revision</name><argument_list>(<argument><expr>&amp;<name>tgt_nr</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>target_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__get_node_revision</name><argument_list>(<argument><expr>&amp;<name>anc_nr</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>ancestor_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__get_node_revision</name><argument_list>(<argument><expr>&amp;<name>src_nr</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>source_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>! <call><name>svn_fs_fs__noderev_same_rep_key</name><argument_list>(<argument><expr><name><name>tgt_nr</name>-&gt;<name>prop_rep</name></name></expr></argument>, <argument><expr><name><name>anc_nr</name>-&gt;<name>prop_rep</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>conflict_err</name><argument_list>(<argument><expr><name>conflict_p</name></expr></argument>, <argument><expr><name>target_path</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr>! <call><name>svn_fs_fs__noderev_same_rep_key</name><argument_list>(<argument><expr><name><name>src_nr</name>-&gt;<name>prop_rep</name></name></expr></argument>, <argument><expr><name><name>anc_nr</name>-&gt;<name>prop_rep</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>conflict_err</name><argument_list>(<argument><expr><name>conflict_p</name></expr></argument>, <argument><expr><name>target_path</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
}</block>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_dir_entries</name><argument_list>(<argument><expr>&amp;<name>s_entries</name></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_dir_entries</name><argument_list>(<argument><expr>&amp;<name>t_entries</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_dir_entries</name><argument_list>(<argument><expr>&amp;<name>a_entries</name></expr></argument>, <argument><expr><name>ancestor</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>iterpool</name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>a_entries</name></expr></argument>)</argument_list></call></expr>;</init>
<condition><expr><name>hi</name></expr>;</condition>
<incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>) <block>{
<decl_stmt><decl><type><name>svn_fs_dirent_t</name> *</type><name>s_entry</name></decl>, *<decl><type ref="prev"/><name>t_entry</name></decl>, *<decl><type ref="prev"/><name>a_entry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_ssize_t</name></type> <name>klen</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr>&amp;<name>klen</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>a_entry</name> = <name>val</name></expr>;</expr_stmt>
<expr_stmt><expr><name>s_entry</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>s_entries</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>klen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>t_entry</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>t_entries</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>klen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>s_entry</name> &amp;&amp; <call><name>svn_fs_fs__id_eq</name><argument_list>(<argument><expr><name><name>a_entry</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name><name>s_entry</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
<goto>goto <name>end</name>;</goto></then>
<else>else <if>if <condition>(<expr><name>t_entry</name> &amp;&amp; <call><name>svn_fs_fs__id_eq</name><argument_list>(<argument><expr><name><name>a_entry</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name><name>t_entry</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>dag_node_t</name> *</type><name>t_ent_node</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_node</name><argument_list>(<argument><expr>&amp;<name>t_ent_node</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>,
<argument><expr><name><name>t_entry</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>svn_fs_fs__fs_supports_mergeinfo</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>apr_int64_t</name></type> <name>mergeinfo_start</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_mergeinfo_count</name><argument_list>(<argument><expr>&amp;<name>mergeinfo_start</name></expr></argument>,
<argument><expr><name>t_ent_node</name></expr></argument>,
<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>mergeinfo_increment</name> -= <name>mergeinfo_start</name></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>s_entry</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>dag_node_t</name> *</type><name>s_ent_node</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_node</name><argument_list>(<argument><expr>&amp;<name>s_ent_node</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>,
<argument><expr><name><name>s_entry</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>svn_fs_fs__fs_supports_mergeinfo</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>apr_int64_t</name></type> <name>mergeinfo_end</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_mergeinfo_count</name><argument_list>(<argument><expr>&amp;<name>mergeinfo_end</name></expr></argument>,
<argument><expr><name>s_ent_node</name></expr></argument>,
<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>mergeinfo_increment</name> += <name>mergeinfo_end</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_set_entry</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>key</name></expr></argument>,
<argument><expr><name><name>s_entry</name>-&gt;<name>id</name></name></expr></argument>,
<argument><expr><name><name>s_entry</name>-&gt;<name>kind</name></name></expr></argument>,
<argument><expr><name>txn_id</name></expr></argument>,
<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_delete</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
}</block></then>
<else>else <block>{
<decl_stmt><decl><type><name>dag_node_t</name> *</type><name>s_ent_node</name></decl>, *<decl><type ref="prev"/><name>t_ent_node</name></decl>, *<decl><type ref="prev"/><name>a_ent_node</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>new_tpath</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_int64_t</name></type> <name>sub_mergeinfo_increment</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>s_entry</name> == <name>NULL</name> || <name>t_entry</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><call><name>conflict_err</name><argument_list>(<argument><expr><name>conflict_p</name></expr></argument>,
<argument><expr><call><name>svn_path_join</name><argument_list>(<argument><expr><name>target_path</name></expr></argument>,
<argument><expr><name><name>a_entry</name>-&gt;<name>name</name></name></expr></argument>,
<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><name><name>s_entry</name>-&gt;<name>kind</name></name> == <name>svn_node_file</name>
|| <name><name>t_entry</name>-&gt;<name>kind</name></name> == <name>svn_node_file</name>
|| <name><name>a_entry</name>-&gt;<name>kind</name></name> == <name>svn_node_file</name></expr>)</condition><then>
<return>return <expr><call><name>conflict_err</name><argument_list>(<argument><expr><name>conflict_p</name></expr></argument>,
<argument><expr><call><name>svn_path_join</name><argument_list>(<argument><expr><name>target_path</name></expr></argument>,
<argument><expr><name><name>a_entry</name>-&gt;<name>name</name></name></expr></argument>,
<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>svn_fs_fs__id_node_id</name><argument_list>(<argument><expr><name><name>s_entry</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>svn_fs_fs__id_node_id</name><argument_list>(<argument><expr><name><name>a_entry</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> != 0
|| <call><name>strcmp</name><argument_list>(<argument><expr><call><name>svn_fs_fs__id_copy_id</name><argument_list>(<argument><expr><name><name>s_entry</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>svn_fs_fs__id_copy_id</name><argument_list>(<argument><expr><name><name>a_entry</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> != 0
|| <call><name>strcmp</name><argument_list>(<argument><expr><call><name>svn_fs_fs__id_node_id</name><argument_list>(<argument><expr><name><name>t_entry</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>svn_fs_fs__id_node_id</name><argument_list>(<argument><expr><name><name>a_entry</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> != 0
|| <call><name>strcmp</name><argument_list>(<argument><expr><call><name>svn_fs_fs__id_copy_id</name><argument_list>(<argument><expr><name><name>t_entry</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>svn_fs_fs__id_copy_id</name><argument_list>(<argument><expr><name><name>a_entry</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
<return>return <expr><call><name>conflict_err</name><argument_list>(<argument><expr><name>conflict_p</name></expr></argument>,
<argument><expr><call><name>svn_path_join</name><argument_list>(<argument><expr><name>target_path</name></expr></argument>,
<argument><expr><name><name>a_entry</name>-&gt;<name>name</name></name></expr></argument>,
<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_node</name><argument_list>(<argument><expr>&amp;<name>s_ent_node</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>,
<argument><expr><name><name>s_entry</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_node</name><argument_list>(<argument><expr>&amp;<name>t_ent_node</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>,
<argument><expr><name><name>t_entry</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_node</name><argument_list>(<argument><expr>&amp;<name>a_ent_node</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>,
<argument><expr><name><name>a_entry</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>new_tpath</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>target_path</name></expr></argument>, <argument><expr><name><name>t_entry</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>merge</name><argument_list>(<argument><expr><name>conflict_p</name></expr></argument>, <argument><expr><name>new_tpath</name></expr></argument>,
<argument><expr><name>t_ent_node</name></expr></argument>, <argument><expr><name>s_ent_node</name></expr></argument>, <argument><expr><name>a_ent_node</name></expr></argument>,
<argument><expr><name>txn_id</name></expr></argument>,
<argument><expr>&amp;<name>sub_mergeinfo_increment</name></expr></argument>,
<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>svn_fs_fs__fs_supports_mergeinfo</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><name>mergeinfo_increment</name> += <name>sub_mergeinfo_increment</name></expr>;</expr_stmt></then></if>
}</block></else></if></else></if>
<label><name>end</name>:</label>
<expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>s_entries</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>klen</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>s_entries</name></expr></argument>)</argument_list></call></expr>;</init>
<condition><expr><name>hi</name></expr>;</condition>
<incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>) <block>{
<decl_stmt><decl><type><name>svn_fs_dirent_t</name> *</type><name>s_entry</name></decl>, *<decl><type ref="prev"/><name>t_entry</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_ssize_t</name></type> <name>klen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dag_node_t</name> *</type><name>s_ent_node</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr>&amp;<name>klen</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>s_entry</name> = <name>val</name></expr>;</expr_stmt>
<expr_stmt><expr><name>t_entry</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>t_entries</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>klen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>t_entry</name></expr>)</condition><then>
<return>return <expr><call><name>conflict_err</name><argument_list>(<argument><expr><name>conflict_p</name></expr></argument>,
<argument><expr><call><name>svn_path_join</name><argument_list>(<argument><expr><name>target_path</name></expr></argument>,
<argument><expr><name><name>t_entry</name>-&gt;<name>name</name></name></expr></argument>,
<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_node</name><argument_list>(<argument><expr>&amp;<name>s_ent_node</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>,
<argument><expr><name><name>s_entry</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>svn_fs_fs__fs_supports_mergeinfo</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>apr_int64_t</name></type> <name>mergeinfo_s</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_mergeinfo_count</name><argument_list>(<argument><expr>&amp;<name>mergeinfo_s</name></expr></argument>,
<argument><expr><name>s_ent_node</name></expr></argument>,
<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>mergeinfo_increment</name> += <name>mergeinfo_s</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_set_entry</name>
<argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name><name>s_entry</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name><name>s_entry</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name><name>s_entry</name>-&gt;<name>kind</name></name></expr></argument>,
<argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_predecessor_count</name><argument_list>(<argument><expr>&amp;<name>pred_count</name></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>update_ancestry</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>source_id</name></expr></argument>, <argument><expr><name>target_id</name></expr></argument>, <argument><expr><name>target_path</name></expr></argument>,
<argument><expr><name>pred_count</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>svn_fs_fs__fs_supports_mergeinfo</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_increment_mergeinfo_count</name><argument_list>(<argument><expr><name>target</name></expr></argument>,
<argument><expr><name>mergeinfo_increment</name></expr></argument>,
<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>mergeinfo_increment_out</name></expr>)</condition><then>
<expr_stmt><expr>*<name>mergeinfo_increment_out</name> = <name>mergeinfo_increment</name></expr>;</expr_stmt></then></if>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>merge_changes</name><parameter_list>(<param><decl><type><name>dag_node_t</name> *</type><name>ancestor_node</name></decl></param>,
<param><decl><type><name>dag_node_t</name> *</type><name>source_node</name></decl></param>,
<param><decl><type><name>svn_fs_txn_t</name> *</type><name>txn</name></decl></param>,
<param><decl><type><name>svn_stringbuf_t</name> *</type><name>conflict</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>dag_node_t</name> *</type><name>txn_root_node</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>source_id</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name> <init>= <expr><name><name>txn</name>-&gt;<name>fs</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name> <init>= <expr><name><name>txn</name>-&gt;<name>id</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>source_id</name> = <call><name>svn_fs_fs__dag_get_id</name><argument_list>(<argument><expr><name>source_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_txn_root</name><argument_list>(<argument><expr>&amp;<name>txn_root_node</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ancestor_node</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_txn_base_root</name><argument_list>(<argument><expr>&amp;<name>ancestor_node</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>,
<argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><call><name>svn_fs_fs__id_eq</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_id</name><argument_list>(<argument><expr><name>ancestor_node</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>svn_fs_fs__dag_get_id</name><argument_list>(<argument><expr><name>txn_root_node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>merge</name><argument_list>(<argument><expr><name>conflict</name></expr></argument>, <argument><expr>"/"</expr></argument>, <argument><expr><name>txn_root_node</name></expr></argument>,
<argument><expr><name>source_node</name></expr></argument>, <argument><expr><name>ancestor_node</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__commit_txn</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>conflict_p</name></decl></param>,
<param><decl><type><name>svn_revnum_t</name> *</type><name>new_rev_p</name></decl></param>,
<param><decl><type><name>svn_fs_txn_t</name> *</type><name>txn</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>new_rev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name> <init>= <expr><name><name>txn</name>-&gt;<name>fs</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>new_rev</name> = <name>SVN_INVALID_REVNUM</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>conflict_p</name></expr>)</condition><then>
<expr_stmt><expr>*<name>conflict_p</name> = <name>NULL</name></expr>;</expr_stmt></then></if>
<while>while <condition>(<expr>1729</expr>)</condition> <block>{
<decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>youngish_rev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>youngish_root</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dag_node_t</name> *</type><name>youngish_root_node</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>conflict</name> <init>= <expr><call><name>svn_stringbuf_create</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__youngest_rev</name><argument_list>(<argument><expr>&amp;<name>youngish_rev</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__revision_root</name><argument_list>(<argument><expr>&amp;<name>youngish_root</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>youngish_rev</name></expr></argument>,
<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_root</name><argument_list>(<argument><expr>&amp;<name>youngish_root_node</name></expr></argument>, <argument><expr><name>youngish_root</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> = <call><name>merge_changes</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>youngish_root_node</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>, <argument><expr><name>conflict</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>err</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>(<name><name>err</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_FS_CONFLICT</name>) &amp;&amp; <name>conflict_p</name></expr>)</condition><then>
<expr_stmt><expr>*<name>conflict_p</name> = <name><name>conflict</name>-&gt;<name>data</name></name></expr>;</expr_stmt></then></if>
<return>return <expr><name>err</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name><name>txn</name>-&gt;<name>base_rev</name></name> = <name>youngish_rev</name></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> = <call><name>svn_fs_fs__commit</name><argument_list>(<argument><expr>&amp;<name>new_rev</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>err</name> &amp;&amp; (<name><name>err</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_FS_TXN_OUT_OF_DATE</name>)</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>youngest_rev</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__youngest_rev</name><argument_list>(<argument><expr>&amp;<name>youngest_rev</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>youngest_rev</name> == <name>youngish_rev</name></expr>)</condition><then>
<return>return <expr><name>err</name></expr>;</return></then>
<else>else
<expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
}</block></then> <else>else <if>if <condition>(<expr><name>err</name></expr>)</condition><then> <block>{
<return>return <expr><name>err</name></expr>;</return>
}</block></then> <else>else <block>{
<expr_stmt><expr>*<name>new_rev_p</name> = <name>new_rev</name></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></else></if></else></if>
}</block></while>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>fs_merge</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>conflict_p</name></decl></param>,
<param><decl><type><name>svn_fs_root_t</name> *</type><name>source_root</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>source_path</name></decl></param>,
<param><decl><type><name>svn_fs_root_t</name> *</type><name>target_root</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>target_path</name></decl></param>,
<param><decl><type><name>svn_fs_root_t</name> *</type><name>ancestor_root</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ancestor_path</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>dag_node_t</name> *</type><name>source</name></decl>, *<decl><type ref="prev"/><name>ancestor</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_fs_txn_t</name> *</type><name>txn</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>conflict</name> <init>= <expr><call><name>svn_stringbuf_create</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>! <name><name>target_root</name>-&gt;<name>is_txn_root</name></name></expr>)</condition><then>
<return>return <expr><call><name>SVN_FS__NOT_TXN</name><argument_list>(<argument><expr><name>target_root</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr>(<name><name>source_root</name>-&gt;<name>fs</name></name> != <name><name>ancestor_root</name>-&gt;<name>fs</name></name>)
|| (<name><name>target_root</name>-&gt;<name>fs</name></name> != <name><name>ancestor_root</name>-&gt;<name>fs</name></name>)</expr>)</condition><then> <block>{
<return>return <expr><call><name>svn_error_create</name>
<argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr>"Bad merge; ancestor, source, and target not all in same fs"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_root</name><argument_list>(<argument><expr>&amp;<name>ancestor</name></expr></argument>, <argument><expr><name>ancestor_root</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_root</name><argument_list>(<argument><expr>&amp;<name>source</name></expr></argument>, <argument><expr><name>source_root</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__open_txn</name><argument_list>(<argument><expr>&amp;<name>txn</name></expr></argument>, <argument><expr><name><name>ancestor_root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name><name>target_root</name>-&gt;<name>txn</name></name></expr></argument>,
<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> = <call><name>merge_changes</name><argument_list>(<argument><expr><name>ancestor</name></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>, <argument><expr><name>conflict</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>err</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>(<name><name>err</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_FS_CONFLICT</name>) &amp;&amp; <name>conflict_p</name></expr>)</condition><then>
<expr_stmt><expr>*<name>conflict_p</name> = <name><name>conflict</name>-&gt;<name>data</name></name></expr>;</expr_stmt></then></if>
<return>return <expr><name>err</name></expr>;</return>
}</block></then></if>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__deltify</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
<param><decl><type><name>svn_revnum_t</name></type> <name>revision</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>fs_dir_entries</name><parameter_list>(<param><decl><type><name>apr_hash_t</name> **</type><name>table_p</name></decl></param>,
<param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>dag_node_t</name> *</type><name>node</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_dag</name><argument_list>(<argument><expr>&amp;<name>node</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_dir_entries</name><argument_list>(<argument><expr><name>table_p</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>fs_make_dir</name><parameter_list>(<param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>parent_path_t</name> *</type><name>parent_path</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dag_node_t</name> *</type><name>sub_dir</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name> <init>= <expr><name><name>root</name>-&gt;<name>txn</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>open_path</name><argument_list>(<argument><expr>&amp;<name>parent_path</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>open_path_last_optional</name></expr></argument>,
<argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>root</name>-&gt;<name>txn_flags</name></name> &amp; <name>SVN_FS_TXN_CHECK_LOCKS</name></expr>)</condition><then>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__allow_locked_operation</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name><name>parent_path</name>-&gt;<name>node</name></name></expr>)</condition><then>
<return>return <expr><call><name>SVN_FS__ALREADY_EXISTS</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>make_path_mutable</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>parent_path</name>-&gt;<name>parent</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_make_dir</name><argument_list>(<argument><expr>&amp;<name>sub_dir</name></expr></argument>,
<argument><expr><name><name>parent_path</name>-&gt;<name>parent</name>-&gt;<name>node</name></name></expr></argument>,
<argument><expr><call><name>parent_path_path</name><argument_list>(<argument><expr><name><name>parent_path</name>-&gt;<name>parent</name></name></expr></argument>,
<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>parent_path</name>-&gt;<name>entry</name></name></expr></argument>,
<argument><expr><name>txn_id</name></expr></argument>,
<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dag_node_cache_set</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><call><name>parent_path_path</name><argument_list>(<argument><expr><name>parent_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sub_dir</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>add_change</name><argument_list>(<argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>svn_fs_fs__dag_get_id</name><argument_list>(<argument><expr><name>sub_dir</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>svn_fs_path_change_add</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>SVN_INVALID_REVNUM</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>fs_delete_node</name><parameter_list>(<param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>parent_path_t</name> *</type><name>parent_path</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name> <init>= <expr><name><name>root</name>-&gt;<name>txn</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_int64_t</name></type> <name>mergeinfo_count</name></decl>;</decl_stmt>
<if>if <condition>(<expr>! <name><name>root</name>-&gt;<name>is_txn_root</name></name></expr>)</condition><then>
<return>return <expr><call><name>SVN_FS__NOT_TXN</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>open_path</name><argument_list>(<argument><expr>&amp;<name>parent_path</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>! <name><name>parent_path</name>-&gt;<name>parent</name></name></expr>)</condition><then>
<return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_FS_ROOT_DIR</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr>"The root directory cannot be deleted"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><name><name>root</name>-&gt;<name>txn_flags</name></name> &amp; <name>SVN_FS_TXN_CHECK_LOCKS</name></expr>)</condition><then>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__allow_locked_operation</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>make_path_mutable</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>parent_path</name>-&gt;<name>parent</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>svn_fs_fs__fs_supports_mergeinfo</name><argument_list>(<argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_mergeinfo_count</name><argument_list>(<argument><expr>&amp;<name>mergeinfo_count</name></expr></argument>,
<argument><expr><name><name>parent_path</name>-&gt;<name>node</name></name></expr></argument>,
<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_delete</name><argument_list>(<argument><expr><name><name>parent_path</name>-&gt;<name>parent</name>-&gt;<name>node</name></name></expr></argument>,
<argument><expr><name><name>parent_path</name>-&gt;<name>entry</name></name></expr></argument>,
<argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dag_node_cache_invalidate</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><call><name>parent_path_path</name><argument_list>(<argument><expr><name>parent_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>svn_fs_fs__fs_supports_mergeinfo</name><argument_list>(<argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>)</argument_list></call> &amp;&amp; <name>mergeinfo_count</name> &gt; 0</expr>)</condition><then>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>increment_mergeinfo_up_tree</name><argument_list>(<argument><expr><name><name>parent_path</name>-&gt;<name>parent</name></name></expr></argument>,
<argument><expr>-<name>mergeinfo_count</name></expr></argument>,
<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>add_change</name><argument_list>(<argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
<argument><expr><call><name>svn_fs_fs__dag_get_id</name><argument_list>(<argument><expr><name><name>parent_path</name>-&gt;<name>node</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>svn_fs_path_change_delete</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
<argument><expr><name>SVN_INVALID_REVNUM</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>fs_same_p</name><parameter_list>(<param><decl><type><name>svn_boolean_t</name> *</type><name>same_p</name></decl></param>,
<param><decl><type><name>svn_fs_t</name> *</type><name>fs1</name></decl></param>,
<param><decl><type><name>svn_fs_t</name> *</type><name>fs2</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>uuid1</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>uuid2</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>fs1</name>-&gt;<name>vtable</name>-&gt;<name>get_uuid</name></name><argument_list>(<argument><expr><name>fs1</name></expr></argument>, <argument><expr>&amp;<name>uuid1</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>fs2</name>-&gt;<name>vtable</name>-&gt;<name>get_uuid</name></name><argument_list>(<argument><expr><name>fs2</name></expr></argument>, <argument><expr>&amp;<name>uuid2</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>same_p</name> = ! <call><name>strcmp</name><argument_list>(<argument><expr><name>uuid1</name></expr></argument>, <argument><expr><name>uuid2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>copy_helper</name><parameter_list>(<param><decl><type><name>svn_fs_root_t</name> *</type><name>from_root</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>from_path</name></decl></param>,
<param><decl><type><name>svn_fs_root_t</name> *</type><name>to_root</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>to_path</name></decl></param>,
<param><decl><type><name>svn_boolean_t</name></type> <name>preserve_history</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>dag_node_t</name> *</type><name>from_node</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>parent_path_t</name> *</type><name>to_parent_path</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name> <init>= <expr><name><name>to_root</name>-&gt;<name>txn</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>same_p</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>fs_same_p</name><argument_list>(<argument><expr>&amp;<name>same_p</name></expr></argument>, <argument><expr><name><name>from_root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name><name>to_root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>! <name>same_p</name></expr>)</condition><then>
<return>return <expr><call><name>svn_error_createf</name>
<argument_list>(<argument><expr><name>SVN_ERR_UNSUPPORTED_FEATURE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr>"Cannot copy between two different filesystems ('%s' and '%s')"</expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>from_root</name>-&gt;<name>fs</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name><name>to_root</name>-&gt;<name>fs</name>-&gt;<name>path</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><name><name>from_root</name>-&gt;<name>is_txn_root</name></name></expr>)</condition><then>
<return>return <expr><call><name>svn_error_create</name>
<argument_list>(<argument><expr><name>SVN_ERR_UNSUPPORTED_FEATURE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr>"Copy from mutable tree not currently supported"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_dag</name><argument_list>(<argument><expr>&amp;<name>from_node</name></expr></argument>, <argument><expr><name>from_root</name></expr></argument>, <argument><expr><name>from_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>open_path</name><argument_list>(<argument><expr>&amp;<name>to_parent_path</name></expr></argument>, <argument><expr><name>to_root</name></expr></argument>, <argument><expr><name>to_path</name></expr></argument>,
<argument><expr><name>open_path_last_optional</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>to_root</name>-&gt;<name>txn_flags</name></name> &amp; <name>SVN_FS_TXN_CHECK_LOCKS</name></expr>)</condition><then>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__allow_locked_operation</name><argument_list>(<argument><expr><name>to_path</name></expr></argument>, <argument><expr><name><name>to_root</name>-&gt;<name>fs</name></name></expr></argument>,
<argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name><name>to_parent_path</name>-&gt;<name>node</name></name> &amp;&amp;
<call><name>svn_fs_fs__id_eq</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_id</name><argument_list>(<argument><expr><name>from_node</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>svn_fs_fs__dag_get_id</name><argument_list>(<argument><expr><name><name>to_parent_path</name>-&gt;<name>node</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>
<if>if <condition>(<expr>! <name><name>from_root</name>-&gt;<name>is_txn_root</name></name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>svn_fs_path_change_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dag_node_t</name> *</type><name>new_node</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>from_canonpath</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_int64_t</name></type> <name>mergeinfo_start</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_int64_t</name></type> <name>mergeinfo_end</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>to_parent_path</name>-&gt;<name>node</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>kind</name> = <name>svn_fs_path_change_replace</name></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>svn_fs_fs__fs_supports_mergeinfo</name><argument_list>(<argument><expr><name><name>to_root</name>-&gt;<name>fs</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_mergeinfo_count</name><argument_list>(<argument><expr>&amp;<name>mergeinfo_start</name></expr></argument>,
<argument><expr><name><name>to_parent_path</name>-&gt;<name>node</name></name></expr></argument>,
<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>kind</name> = <name>svn_fs_path_change_add</name></expr>;</expr_stmt>
<expr_stmt><expr><name>mergeinfo_start</name> = 0</expr>;</expr_stmt>
}</block></else></if>
<if>if <condition>(<expr><call><name>svn_fs_fs__fs_supports_mergeinfo</name><argument_list>(<argument><expr><name><name>to_root</name>-&gt;<name>fs</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_mergeinfo_count</name><argument_list>(<argument><expr>&amp;<name>mergeinfo_end</name></expr></argument>,
<argument><expr><name>from_node</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>make_path_mutable</name><argument_list>(<argument><expr><name>to_root</name></expr></argument>, <argument><expr><name><name>to_parent_path</name>-&gt;<name>parent</name></name></expr></argument>,
<argument><expr><name>to_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>from_canonpath</name> = <call><name>svn_fs__canonicalize_abspath</name><argument_list>(<argument><expr><name>from_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_copy</name><argument_list>(<argument><expr><name><name>to_parent_path</name>-&gt;<name>parent</name>-&gt;<name>node</name></name></expr></argument>,
<argument><expr><name><name>to_parent_path</name>-&gt;<name>entry</name></name></expr></argument>,
<argument><expr><name>from_node</name></expr></argument>,
<argument><expr><name>preserve_history</name></expr></argument>,
<argument><expr><name><name>from_root</name>-&gt;<name>rev</name></name></expr></argument>,
<argument><expr><name>from_canonpath</name></expr></argument>,
<argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>kind</name> == <name>svn_fs_path_change_replace</name></expr>)</condition><then>
<expr_stmt><expr><call><name>dag_node_cache_invalidate</name><argument_list>(<argument><expr><name>to_root</name></expr></argument>, <argument><expr><call><name>parent_path_path</name><argument_list>(<argument><expr><name>to_parent_path</name></expr></argument>,
<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><call><name>svn_fs_fs__fs_supports_mergeinfo</name><argument_list>(<argument><expr><name><name>to_root</name>-&gt;<name>fs</name></name></expr></argument>)</argument_list></call>
&amp;&amp; <name>mergeinfo_start</name> != <name>mergeinfo_end</name></expr>)</condition><then>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>increment_mergeinfo_up_tree</name><argument_list>(<argument><expr><name><name>to_parent_path</name>-&gt;<name>parent</name></name></expr></argument>,
<argument><expr><name>mergeinfo_end</name> - <name>mergeinfo_start</name></expr></argument>,
<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_dag</name><argument_list>(<argument><expr>&amp;<name>new_node</name></expr></argument>, <argument><expr><name>to_root</name></expr></argument>, <argument><expr><name>to_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>add_change</name><argument_list>(<argument><expr><name><name>to_root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>to_path</name></expr></argument>,
<argument><expr><call><name>svn_fs_fs__dag_get_id</name><argument_list>(<argument><expr><name>new_node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>kind</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
<argument><expr><name><name>from_root</name>-&gt;<name>rev</name></name></expr></argument>, <argument><expr><name>from_canonpath</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>fs_copy</name><parameter_list>(<param><decl><type><name>svn_fs_root_t</name> *</type><name>from_root</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>from_path</name></decl></param>,
<param><decl><type><name>svn_fs_root_t</name> *</type><name>to_root</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>to_path</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>copy_helper</name><argument_list>(<argument><expr><name>from_root</name></expr></argument>, <argument><expr><name>from_path</name></expr></argument>, <argument><expr><name>to_root</name></expr></argument>, <argument><expr><name>to_path</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>fs_revision_link</name><parameter_list>(<param><decl><type><name>svn_fs_root_t</name> *</type><name>from_root</name></decl></param>,
<param><decl><type><name>svn_fs_root_t</name> *</type><name>to_root</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr>! <name><name>to_root</name>-&gt;<name>is_txn_root</name></name></expr>)</condition><then>
<return>return <expr><call><name>SVN_FS__NOT_TXN</name><argument_list>(<argument><expr><name>to_root</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<return>return <expr><call><name>copy_helper</name><argument_list>(<argument><expr><name>from_root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>to_root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>fs_copied_from</name><parameter_list>(<param><decl><type><name>svn_revnum_t</name> *</type><name>rev_p</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>path_p</name></decl></param>,
<param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>dag_node_t</name> *</type><name>node</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copyfrom_path</name></decl>, *<decl><type ref="prev"/><name>copyfrom_str</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>copyfrom_rev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>str</name></decl>, *<decl><type ref="prev"/><name>last_str</name></decl>, *<decl><type ref="prev"/><name>buf</name></decl>;</decl_stmt>
<if>if <condition>(<expr>! <name><name>root</name>-&gt;<name>is_txn_root</name></name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>fs_rev_root_data_t</name> *</type><name>frd</name> <init>= <expr><name><name>root</name>-&gt;<name>fsap_data</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>copyfrom_str</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name><name>frd</name>-&gt;<name>copyfrom_cache</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>copyfrom_str</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>copyfrom_str</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>copyfrom_rev</name> = <name>SVN_INVALID_REVNUM</name></expr>;</expr_stmt>
<expr_stmt><expr><name>copyfrom_path</name> = <name>NULL</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>buf</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>copyfrom_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>str</name> = <call><name>apr_strtok</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>" "</expr></argument>, <argument><expr>&amp;<name>last_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>copyfrom_rev</name> = <call><name>atol</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>copyfrom_path</name> = <name>last_str</name></expr>;</expr_stmt>
}</block></else></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_dag</name><argument_list>(<argument><expr>&amp;<name>node</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_copyfrom_rev</name><argument_list>(<argument><expr>&amp;<name>copyfrom_rev</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_copyfrom_path</name><argument_list>(<argument><expr>&amp;<name>copyfrom_path</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr>*<name>rev_p</name> = <name>copyfrom_rev</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>path_p</name> = <name>copyfrom_path</name></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>fs_make_file</name><parameter_list>(<param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>parent_path_t</name> *</type><name>parent_path</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dag_node_t</name> *</type><name>child</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name> <init>= <expr><name><name>root</name>-&gt;<name>txn</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>open_path</name><argument_list>(<argument><expr>&amp;<name>parent_path</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>open_path_last_optional</name></expr></argument>,
<argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>parent_path</name>-&gt;<name>node</name></name></expr>)</condition><then>
<return>return <expr><call><name>SVN_FS__ALREADY_EXISTS</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><name><name>root</name>-&gt;<name>txn_flags</name></name> &amp; <name>SVN_FS_TXN_CHECK_LOCKS</name></expr>)</condition><then>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__allow_locked_operation</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>make_path_mutable</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>parent_path</name>-&gt;<name>parent</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_make_file</name><argument_list>(<argument><expr>&amp;<name>child</name></expr></argument>,
<argument><expr><name><name>parent_path</name>-&gt;<name>parent</name>-&gt;<name>node</name></name></expr></argument>,
<argument><expr><call><name>parent_path_path</name><argument_list>(<argument><expr><name><name>parent_path</name>-&gt;<name>parent</name></name></expr></argument>,
<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>parent_path</name>-&gt;<name>entry</name></name></expr></argument>,
<argument><expr><name>txn_id</name></expr></argument>,
<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>dag_node_cache_set</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><call><name>parent_path_path</name><argument_list>(<argument><expr><name>parent_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>child</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>add_change</name><argument_list>(<argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>svn_fs_fs__dag_get_id</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>svn_fs_path_change_add</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>SVN_INVALID_REVNUM</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>fs_file_length</name><parameter_list>(<param><decl><type><name>svn_filesize_t</name> *</type><name>length_p</name></decl></param>,
<param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>dag_node_t</name> *</type><name>file</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_dag</name><argument_list>(<argument><expr>&amp;<name>file</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_file_length</name><argument_list>(<argument><expr><name>length_p</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>fs_file_md5_checksum</name><parameter_list>(<param><decl><type><name>unsigned</name> <name>char</name></type> <name><name>digest</name><index>[]</index></name></decl></param>,
<param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>dag_node_t</name> *</type><name>file</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_dag</name><argument_list>(<argument><expr>&amp;<name>file</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>svn_fs_fs__dag_file_checksum</name><argument_list>(<argument><expr><name>digest</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>fs_file_contents</name><parameter_list>(<param><decl><type><name>svn_stream_t</name> **</type><name>contents</name></decl></param>,
<param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>dag_node_t</name> *</type><name>node</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>file_stream</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_dag</name><argument_list>(<argument><expr>&amp;<name>node</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_contents</name><argument_list>(<argument><expr>&amp;<name>file_stream</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>contents</name> = <name>file_stream</name></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<typedef>typedef <type><struct>struct <name>txdelta_baton_t</name> <block>{
<decl_stmt><decl><type><name>svn_txdelta_window_handler_t</name></type> <name>interpreter</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> *</type><name>interpreter_baton</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dag_node_t</name> *</type><name>node</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>source_stream</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>target_stream</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>string_stream</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>target_string</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>base_checksum</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>result_checksum</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>
}</block></struct></type> <name>txdelta_baton_t</name>;</typedef>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>write_to_string</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name></decl></param>, <param><decl><type><name>apr_size_t</name> *</type><name>len</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>txdelta_baton_t</name> *</type><name>tb</name> <init>= <expr>(<name>txdelta_baton_t</name> *) <name>baton</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>svn_stringbuf_appendbytes</name><argument_list>(<argument><expr><name><name>tb</name>-&gt;<name>target_string</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr>*<name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>window_consumer</name><parameter_list>(<param><decl><type><name>svn_txdelta_window_t</name> *</type><name>window</name></decl></param>, <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>txdelta_baton_t</name> *</type><name>tb</name> <init>= <expr>(<name>txdelta_baton_t</name> *) <name>baton</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>tb</name>-&gt;<name>interpreter</name></name><argument_list>(<argument><expr><name>window</name></expr></argument>, <argument><expr><name><name>tb</name>-&gt;<name>interpreter_baton</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>(! <name>window</name>) || (<name><name>tb</name>-&gt;<name>target_string</name>-&gt;<name>len</name></name> &gt; <name>WRITE_BUFFER_SIZE</name>)</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name> <init>= <expr><name><name>tb</name>-&gt;<name>target_string</name>-&gt;<name>len</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_write</name><argument_list>(<argument><expr><name><name>tb</name>-&gt;<name>target_stream</name></name></expr></argument>,
<argument><expr><name><name>tb</name>-&gt;<name>target_string</name>-&gt;<name>data</name></name></expr></argument>,
<argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>svn_stringbuf_set</name><argument_list>(<argument><expr><name><name>tb</name>-&gt;<name>target_string</name></name></expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr>! <name>window</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_close</name><argument_list>(<argument><expr><name><name>tb</name>-&gt;<name>target_stream</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_finalize_edits</name><argument_list>(<argument><expr><name><name>tb</name>-&gt;<name>node</name></name></expr></argument>, <argument><expr><name><name>tb</name>-&gt;<name>result_checksum</name></name></expr></argument>,
<argument><expr><name><name>tb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>apply_textdelta</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>txdelta_baton_t</name> *</type><name>tb</name> <init>= <expr>(<name>txdelta_baton_t</name> *) <name>baton</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>parent_path_t</name> *</type><name>parent_path</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name> <init>= <expr><name><name>tb</name>-&gt;<name>root</name>-&gt;<name>txn</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>open_path</name><argument_list>(<argument><expr>&amp;<name>parent_path</name></expr></argument>, <argument><expr><name><name>tb</name>-&gt;<name>root</name></name></expr></argument>, <argument><expr><name><name>tb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>tb</name>-&gt;<name>root</name>-&gt;<name>txn_flags</name></name> &amp; <name>SVN_FS_TXN_CHECK_LOCKS</name></expr>)</condition><then>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__allow_locked_operation</name><argument_list>(<argument><expr><name><name>tb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name><name>tb</name>-&gt;<name>root</name>-&gt;<name>fs</name></name></expr></argument>,
<argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>make_path_mutable</name><argument_list>(<argument><expr><name><name>tb</name>-&gt;<name>root</name></name></expr></argument>, <argument><expr><name>parent_path</name></expr></argument>, <argument><expr><name><name>tb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tb</name>-&gt;<name>node</name></name> = <name><name>parent_path</name>-&gt;<name>node</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>tb</name>-&gt;<name>base_checksum</name></name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>digest</name><index>[<expr><name>APR_MD5_DIGESTSIZE</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>hex</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_file_checksum</name><argument_list>(<argument><expr><name>digest</name></expr></argument>, <argument><expr><name><name>tb</name>-&gt;<name>node</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>hex</name> = <call><name>svn_md5_digest_to_cstring</name><argument_list>(<argument><expr><name>digest</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>hex</name> &amp;&amp; (<call><name>strcmp</name><argument_list>(<argument><expr><name><name>tb</name>-&gt;<name>base_checksum</name></name></expr></argument>, <argument><expr><name>hex</name></expr></argument>)</argument_list></call> != 0)</expr>)</condition><then>
<return>return <expr><call><name>svn_error_createf</name>
<argument_list>(<argument><expr><name>SVN_ERR_CHECKSUM_MISMATCH</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr>"Base checksum mismatch on '%s':\n"
" expected: %s\n"
" actual: %s\n"</expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>tb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name><name>tb</name>-&gt;<name>base_checksum</name></name></expr></argument>, <argument><expr><name>hex</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
}</block></then></if>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_contents</name><argument_list>(<argument><expr>&amp;(<name><name>tb</name>-&gt;<name>source_stream</name></name>)</expr></argument>,
<argument><expr><name><name>tb</name>-&gt;<name>node</name></name></expr></argument>, <argument><expr><name><name>tb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_edit_stream</name><argument_list>(<argument><expr>&amp;(<name><name>tb</name>-&gt;<name>target_stream</name></name>)</expr></argument>, <argument><expr><name><name>tb</name>-&gt;<name>node</name></name></expr></argument>,
<argument><expr><name><name>tb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tb</name>-&gt;<name>target_string</name></name> = <call><name>svn_stringbuf_create</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr><name><name>tb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tb</name>-&gt;<name>string_stream</name></name> = <call><name>svn_stream_create</name><argument_list>(<argument><expr><name>tb</name></expr></argument>, <argument><expr><name><name>tb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>svn_stream_set_write</name><argument_list>(<argument><expr><name><name>tb</name>-&gt;<name>string_stream</name></name></expr></argument>, <argument><expr><name>write_to_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>svn_txdelta_apply</name><argument_list>(<argument><expr><name><name>tb</name>-&gt;<name>source_stream</name></name></expr></argument>,
<argument><expr><name><name>tb</name>-&gt;<name>string_stream</name></name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>,
<argument><expr><name><name>tb</name>-&gt;<name>path</name></name></expr></argument>,
<argument><expr><name><name>tb</name>-&gt;<name>pool</name></name></expr></argument>,
<argument><expr>&amp;(<name><name>tb</name>-&gt;<name>interpreter</name></name>)</expr></argument>,
<argument><expr>&amp;(<name><name>tb</name>-&gt;<name>interpreter_baton</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>add_change</name><argument_list>(<argument><expr><name><name>tb</name>-&gt;<name>root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name><name>tb</name>-&gt;<name>path</name></name></expr></argument>,
<argument><expr><call><name>svn_fs_fs__dag_get_id</name><argument_list>(<argument><expr><name><name>tb</name>-&gt;<name>node</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>svn_fs_path_change_modify</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>SVN_INVALID_REVNUM</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>fs_apply_textdelta</name><parameter_list>(<param><decl><type><name>svn_txdelta_window_handler_t</name> *</type><name>contents_p</name></decl></param>,
<param><decl><type><name>void</name> **</type><name>contents_baton_p</name></decl></param>,
<param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>base_checksum</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>result_checksum</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>txdelta_baton_t</name> *</type><name>tb</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>tb</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>tb</name>-&gt;<name>root</name></name> = <name>root</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tb</name>-&gt;<name>path</name></name> = <name>path</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tb</name>-&gt;<name>pool</name></name> = <name>pool</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>base_checksum</name></expr>)</condition><then>
<expr_stmt><expr><name><name>tb</name>-&gt;<name>base_checksum</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>base_checksum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name><name>tb</name>-&gt;<name>base_checksum</name></name> = <name>NULL</name></expr>;</expr_stmt></else></if>
<if>if <condition>(<expr><name>result_checksum</name></expr>)</condition><then>
<expr_stmt><expr><name><name>tb</name>-&gt;<name>result_checksum</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>result_checksum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name><name>tb</name>-&gt;<name>result_checksum</name></name> = <name>NULL</name></expr>;</expr_stmt></else></if>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>apply_textdelta</name><argument_list>(<argument><expr><name>tb</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>contents_p</name> = <name>window_consumer</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>contents_baton_p</name> = <name>tb</name></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<struct>struct <name>text_baton_t</name> <block>{
<decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dag_node_t</name> *</type><name>node</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>stream</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>file_stream</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>result_checksum</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>
}</block>;</struct>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>text_stream_writer</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name></decl></param>,
<param><decl><type><name>apr_size_t</name> *</type><name>len</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>text_baton_t</name> *</type><name>tb</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>svn_stream_write</name><argument_list>(<argument><expr><name><name>tb</name>-&gt;<name>file_stream</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>text_stream_closer</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>text_baton_t</name> *</type><name>tb</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_close</name><argument_list>(<argument><expr><name><name>tb</name>-&gt;<name>file_stream</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_finalize_edits</name><argument_list>(<argument><expr><name><name>tb</name>-&gt;<name>node</name></name></expr></argument>, <argument><expr><name><name>tb</name>-&gt;<name>result_checksum</name></name></expr></argument>,
<argument><expr><name><name>tb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>apply_text</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>text_baton_t</name> *</type><name>tb</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>parent_path_t</name> *</type><name>parent_path</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name> <init>= <expr><name><name>tb</name>-&gt;<name>root</name>-&gt;<name>txn</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>open_path</name><argument_list>(<argument><expr>&amp;<name>parent_path</name></expr></argument>, <argument><expr><name><name>tb</name>-&gt;<name>root</name></name></expr></argument>, <argument><expr><name><name>tb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>tb</name>-&gt;<name>root</name>-&gt;<name>txn_flags</name></name> &amp; <name>SVN_FS_TXN_CHECK_LOCKS</name></expr>)</condition><then>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__allow_locked_operation</name><argument_list>(<argument><expr><name><name>tb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name><name>tb</name>-&gt;<name>root</name>-&gt;<name>fs</name></name></expr></argument>,
<argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>make_path_mutable</name><argument_list>(<argument><expr><name><name>tb</name>-&gt;<name>root</name></name></expr></argument>, <argument><expr><name>parent_path</name></expr></argument>, <argument><expr><name><name>tb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tb</name>-&gt;<name>node</name></name> = <name><name>parent_path</name>-&gt;<name>node</name></name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_edit_stream</name><argument_list>(<argument><expr>&amp;(<name><name>tb</name>-&gt;<name>file_stream</name></name>)</expr></argument>, <argument><expr><name><name>tb</name>-&gt;<name>node</name></name></expr></argument>,
<argument><expr><name><name>tb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tb</name>-&gt;<name>stream</name></name> = <call><name>svn_stream_create</name><argument_list>(<argument><expr><name>tb</name></expr></argument>, <argument><expr><name><name>tb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>svn_stream_set_write</name><argument_list>(<argument><expr><name><name>tb</name>-&gt;<name>stream</name></name></expr></argument>, <argument><expr><name>text_stream_writer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>svn_stream_set_close</name><argument_list>(<argument><expr><name><name>tb</name>-&gt;<name>stream</name></name></expr></argument>, <argument><expr><name>text_stream_closer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>add_change</name><argument_list>(<argument><expr><name><name>tb</name>-&gt;<name>root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name><name>tb</name>-&gt;<name>path</name></name></expr></argument>,
<argument><expr><call><name>svn_fs_fs__dag_get_id</name><argument_list>(<argument><expr><name><name>tb</name>-&gt;<name>node</name></name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>svn_fs_path_change_modify</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>SVN_INVALID_REVNUM</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>fs_apply_text</name><parameter_list>(<param><decl><type><name>svn_stream_t</name> **</type><name>contents_p</name></decl></param>,
<param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>result_checksum</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>text_baton_t</name> *</type><name>tb</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>tb</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>tb</name>-&gt;<name>root</name></name> = <name>root</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tb</name>-&gt;<name>path</name></name> = <name>path</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>tb</name>-&gt;<name>pool</name></name> = <name>pool</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>result_checksum</name></expr>)</condition><then>
<expr_stmt><expr><name><name>tb</name>-&gt;<name>result_checksum</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>result_checksum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name><name>tb</name>-&gt;<name>result_checksum</name></name> = <name>NULL</name></expr>;</expr_stmt></else></if>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>apply_text</name><argument_list>(<argument><expr><name>tb</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>contents_p</name> = <name><name>tb</name>-&gt;<name>stream</name></name></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>fs_contents_changed</name><parameter_list>(<param><decl><type><name>svn_boolean_t</name> *</type><name>changed_p</name></decl></param>,
<param><decl><type><name>svn_fs_root_t</name> *</type><name>root1</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path1</name></decl></param>,
<param><decl><type><name>svn_fs_root_t</name> *</type><name>root2</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path2</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>dag_node_t</name> *</type><name>node1</name></decl>, *<decl><type ref="prev"/><name>node2</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>root1</name>-&gt;<name>fs</name></name> != <name><name>root2</name>-&gt;<name>fs</name></name></expr>)</condition><then>
<return>return <expr><call><name>svn_error_create</name>
<argument_list>(<argument><expr><name>SVN_ERR_FS_GENERAL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr>"Cannot compare file contents between two different filesystems"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
<block>{
<decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__check_path</name><argument_list>(<argument><expr>&amp;<name>kind</name></expr></argument>, <argument><expr><name>root1</name></expr></argument>, <argument><expr><name>path1</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>kind</name> != <name>svn_node_file</name></expr>)</condition><then>
<return>return <expr><call><name>svn_error_createf</name>
<argument_list>(<argument><expr><name>SVN_ERR_FS_GENERAL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"'%s' is not a file"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>path1</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__check_path</name><argument_list>(<argument><expr>&amp;<name>kind</name></expr></argument>, <argument><expr><name>root2</name></expr></argument>, <argument><expr><name>path2</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>kind</name> != <name>svn_node_file</name></expr>)</condition><then>
<return>return <expr><call><name>svn_error_createf</name>
<argument_list>(<argument><expr><name>SVN_ERR_FS_GENERAL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"'%s' is not a file"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>path2</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
}</block>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_dag</name><argument_list>(<argument><expr>&amp;<name>node1</name></expr></argument>, <argument><expr><name>root1</name></expr></argument>, <argument><expr><name>path1</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_dag</name><argument_list>(<argument><expr>&amp;<name>node2</name></expr></argument>, <argument><expr><name>root2</name></expr></argument>, <argument><expr><name>path2</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_things_different</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>changed_p</name></expr></argument>,
<argument><expr><name>node1</name></expr></argument>, <argument><expr><name>node2</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>fs_get_file_delta_stream</name><parameter_list>(<param><decl><type><name>svn_txdelta_stream_t</name> **</type><name>stream_p</name></decl></param>,
<param><decl><type><name>svn_fs_root_t</name> *</type><name>source_root</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>source_path</name></decl></param>,
<param><decl><type><name>svn_fs_root_t</name> *</type><name>target_root</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>target_path</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>dag_node_t</name> *</type><name>source_node</name></decl>, *<decl><type ref="prev"/><name>target_node</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>source_root</name> &amp;&amp; <name>source_path</name></expr>)</condition><then>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_dag</name><argument_list>(<argument><expr>&amp;<name>source_node</name></expr></argument>, <argument><expr><name>source_root</name></expr></argument>, <argument><expr><name>source_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>source_node</name> = <name>NULL</name></expr>;</expr_stmt></else></if>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_dag</name><argument_list>(<argument><expr>&amp;<name>target_node</name></expr></argument>, <argument><expr><name>target_root</name></expr></argument>, <argument><expr><name>target_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_file_delta_stream</name><argument_list>(<argument><expr><name>stream_p</name></expr></argument>, <argument><expr><name>source_node</name></expr></argument>,
<argument><expr><name>target_node</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>fs_paths_changed</name><parameter_list>(<param><decl><type><name>apr_hash_t</name> **</type><name>changed_paths_p</name></decl></param>,
<param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name><name>root</name>-&gt;<name>is_txn_root</name></name></expr>)</condition><then>
<return>return <expr><call><name>svn_fs_fs__txn_changes_fetch</name><argument_list>(<argument><expr><name>changed_paths_p</name></expr></argument>, <argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name><name>root</name>-&gt;<name>txn</name></name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return></then>
<else>else <block>{
<decl_stmt><decl><type><name>fs_rev_root_data_t</name> *</type><name>frd</name> <init>= <expr><name><name>root</name>-&gt;<name>fsap_data</name></name></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>svn_fs_fs__paths_changed</name><argument_list>(<argument><expr><name>changed_paths_p</name></expr></argument>, <argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name><name>root</name>-&gt;<name>rev</name></name></expr></argument>,
<argument><expr><name><name>frd</name>-&gt;<name>copyfrom_cache</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></else></if>
}</block></function>
<typedef>typedef <type><struct>struct <block>{
<decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>revision</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path_hint</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>rev_hint</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>is_interesting</name></decl>;</decl_stmt>
}</block></struct></type> <name>fs_history_data_t</name>;</typedef>
<function_decl><type><specifier>static</specifier> <name>svn_fs_history_t</name> *</type>
<name>assemble_history</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
<param><decl><type><name>svn_revnum_t</name></type> <name>revision</name></decl></param>,
<param><decl><type><name>svn_boolean_t</name></type> <name>is_interesting</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path_hint</name></decl></param>,
<param><decl><type><name>svn_revnum_t</name></type> <name>rev_hint</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>fs_node_history</name><parameter_list>(<param><decl><type><name>svn_fs_history_t</name> **</type><name>history_p</name></decl></param>,
<param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>root</name>-&gt;<name>is_txn_root</name></name></expr>)</condition><then>
<return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_FS_NOT_REVISION_ROOT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__check_path</name><argument_list>(<argument><expr>&amp;<name>kind</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>kind</name> == <name>svn_node_none</name></expr>)</condition><then>
<return>return <expr><call><name>SVN_FS__NOT_FOUND</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr>*<name>history_p</name> = <call><name>assemble_history</name><argument_list>(<argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>,
<argument><expr><call><name>svn_fs__canonicalize_abspath</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>root</name>-&gt;<name>rev</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><name>SVN_INVALID_REVNUM</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>find_youngest_copyroot</name><parameter_list>(<param><decl><type><name>svn_revnum_t</name> *</type><name>rev_p</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>path_p</name></decl></param>,
<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
<param><decl><type><name>parent_path_t</name> *</type><name>parent_path</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>rev_mine</name></decl>, <decl><type ref="prev"/><name>rev_parent</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path_mine</name></decl>, *<decl><type ref="prev"/><name>path_parent</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>parent_path</name>-&gt;<name>parent</name></name></expr>)</condition><then>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>find_youngest_copyroot</name><argument_list>(<argument><expr>&amp;<name>rev_parent</name></expr></argument>, <argument><expr>&amp;<name>path_parent</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>,
<argument><expr><name><name>parent_path</name>-&gt;<name>parent</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_copyroot</name><argument_list>(<argument><expr>&amp;<name>rev_mine</name></expr></argument>, <argument><expr>&amp;<name>path_mine</name></expr></argument>,
<argument><expr><name><name>parent_path</name>-&gt;<name>node</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>rev_mine</name> &gt;= <name>rev_parent</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>rev_p</name> = <name>rev_mine</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>path_p</name> = <name>path_mine</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr>*<name>rev_p</name> = <name>rev_parent</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>path_p</name> = <name>path_parent</name></expr>;</expr_stmt>
}</block></else></if>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type><name>fs_closest_copy</name><parameter_list>(<param><decl><type><name>svn_fs_root_t</name> **</type><name>root_p</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>path_p</name></decl></param>,
<param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name> <init>= <expr><name><name>root</name>-&gt;<name>fs</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>parent_path_t</name> *</type><name>parent_path</name></decl>, *<decl><type ref="prev"/><name>copy_dst_parent_path</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>copy_dst_rev</name></decl>, <decl><type ref="prev"/><name>created_rev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copy_dst_path</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>copy_dst_root</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dag_node_t</name> *</type><name>copy_dst_node</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>
<expr_stmt><expr>*<name>root_p</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>path_p</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>open_path</name><argument_list>(<argument><expr>&amp;<name>parent_path</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>find_youngest_copyroot</name><argument_list>(<argument><expr>&amp;<name>copy_dst_rev</name></expr></argument>, <argument><expr>&amp;<name>copy_dst_path</name></expr></argument>,
<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>parent_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>copy_dst_rev</name> == 0</expr>)</condition><then>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__revision_root</name><argument_list>(<argument><expr>&amp;<name>copy_dst_root</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>copy_dst_rev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__check_path</name><argument_list>(<argument><expr>&amp;<name>kind</name></expr></argument>, <argument><expr><name>copy_dst_root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>kind</name> == <name>svn_node_none</name></expr>)</condition><then>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>open_path</name><argument_list>(<argument><expr>&amp;<name>copy_dst_parent_path</name></expr></argument>, <argument><expr><name>copy_dst_root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
<argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>copy_dst_node</name> = <name><name>copy_dst_parent_path</name>-&gt;<name>node</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr>! <call><name>svn_fs_fs__id_check_related</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_id</name><argument_list>(<argument><expr><name>copy_dst_node</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>svn_fs_fs__dag_get_id</name><argument_list>(<argument><expr><name><name>parent_path</name>-&gt;<name>node</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_revision</name><argument_list>(<argument><expr>&amp;<name>created_rev</name></expr></argument>, <argument><expr><name>copy_dst_node</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>created_rev</name> == <name>copy_dst_rev</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>pred</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_predecessor_id</name><argument_list>(<argument><expr>&amp;<name>pred</name></expr></argument>, <argument><expr><name>copy_dst_node</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>! <name>pred</name></expr>)</condition><then>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>
}</block></then></if>
<expr_stmt><expr>*<name>root_p</name> = <name>copy_dst_root</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>path_p</name> = <name>copy_dst_path</name></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>prev_location</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>prev_path</name></decl></param>,
<param><decl><type><name>svn_revnum_t</name> *</type><name>prev_rev</name></decl></param>,
<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
<param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copy_path</name></decl>, *<decl><type ref="prev"/><name>copy_src_path</name></decl>, *<decl><type ref="prev"/><name>remainder</name> <init>= <expr>""</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>copy_root</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>copy_src_rev</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>fs_closest_copy</name><argument_list>(<argument><expr>&amp;<name>copy_root</name></expr></argument>, <argument><expr>&amp;<name>copy_path</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>! <name>copy_root</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>prev_rev</name> = <name>SVN_INVALID_REVNUM</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>prev_path</name> = <name>NULL</name></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>fs_copied_from</name><argument_list>(<argument><expr>&amp;<name>copy_src_rev</name></expr></argument>, <argument><expr>&amp;<name>copy_src_path</name></expr></argument>,
<argument><expr><name>copy_root</name></expr></argument>, <argument><expr><name>copy_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>copy_path</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
<expr_stmt><expr><name>remainder</name> = <call><name>svn_path_is_child</name><argument_list>(<argument><expr><name>copy_path</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr>*<name>prev_path</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>copy_src_path</name></expr></argument>, <argument><expr><name>remainder</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>prev_rev</name> = <name>copy_src_rev</name></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>fs_node_origin_rev</name><parameter_list>(<param><decl><type><name>svn_revnum_t</name> *</type><name>revision</name></decl></param>,
<param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name> <init>= <expr><name><name>root</name>-&gt;<name>fs</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>given_noderev_id</name></decl>, *<decl><type ref="prev"/><name>cached_origin_id</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>node_id</name></decl>, *<decl><type ref="prev"/><name>dash</name></decl>;</decl_stmt>
<expr_stmt><expr><name>path</name> = <call><name>svn_fs__canonicalize_abspath</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>fs_node_id</name><argument_list>(<argument><expr>&amp;<name>given_noderev_id</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>node_id</name> = <call><name>svn_fs_fs__id_node_id</name><argument_list>(<argument><expr><name>given_noderev_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>node_id</name><index>[<expr>0</expr>]</index></name> == '_'</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>revision</name> = <name>SVN_INVALID_REVNUM</name></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>dash</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>node_id</name></expr></argument>, <argument><expr>'-'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>dash</name> &amp;&amp; *(<name>dash</name>+1)</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>revision</name> = <call><name>SVN_STR_TO_REV</name><argument_list>(<argument><expr><name>dash</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__get_node_origin</name><argument_list>(<argument><expr>&amp;<name>cached_origin_id</name></expr></argument>,
<argument><expr><name>fs</name></expr></argument>,
<argument><expr><name>node_id</name></expr></argument>,
<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>cached_origin_id</name> != <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>revision</name> = <call><name>svn_fs_fs__id_rev</name><argument_list>(<argument><expr><name>cached_origin_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></then></if>
<block>{
<decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>curroot</name> <init>= <expr><name>root</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>predidpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>lastpath</name> <init>= <expr><call><name>svn_stringbuf_create</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>lastrev</name> <init>= <expr><name>SVN_INVALID_REVNUM</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dag_node_t</name> *</type><name>node</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>pred_id</name></decl>;</decl_stmt>
<while>while <condition>(<expr>1</expr>)</condition> <block>{
<decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>currev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>curpath</name> <init>= <expr><name><name>lastpath</name>-&gt;<name>data</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name>lastrev</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__revision_root</name><argument_list>(<argument><expr>&amp;<name>curroot</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>lastrev</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>prev_location</name><argument_list>(<argument><expr>&amp;<name>curpath</name></expr></argument>, <argument><expr>&amp;<name>currev</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>curroot</name></expr></argument>, <argument><expr><name>curpath</name></expr></argument>,
<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>! <name>curpath</name></expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr><call><name>svn_stringbuf_set</name><argument_list>(<argument><expr><name>lastpath</name></expr></argument>, <argument><expr><name>curpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>lastrev</name> = <name>currev</name></expr>;</expr_stmt>
}</block></while>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>fs_node_id</name><argument_list>(<argument><expr>&amp;<name>pred_id</name></expr></argument>, <argument><expr><name>curroot</name></expr></argument>, <argument><expr><name><name>lastpath</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name>predidpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>pred_id</name></expr>)</condition> <block>{
<expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_node</name><argument_list>(<argument><expr>&amp;<name>node</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>pred_id</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>predidpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_predecessor_id</name><argument_list>(<argument><expr>&amp;<name>pred_id</name></expr></argument>, <argument><expr><name>node</name></expr></argument>,
<argument><expr><name>predidpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></while>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_revision</name><argument_list>(<argument><expr><name>revision</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>node_id</name><index>[<expr>0</expr>]</index></name> != '_'</expr>)</condition><then>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__set_node_origin</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>node_id</name></expr></argument>,
<argument><expr><call><name>svn_fs_fs__dag_get_id</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>predidpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block>
}</block></function>
<struct>struct <name>history_prev_args</name> <block>{
<decl_stmt><decl><type><name>svn_fs_history_t</name> **</type><name>prev_history_p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_fs_history_t</name> *</type><name>history</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>cross_copies</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>
}</block>;</struct>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>history_prev</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>history_prev_args</name> *</type><name>args</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_fs_history_t</name> **</type><name>prev_history</name> <init>= <expr><name><name>args</name>-&gt;<name>prev_history_p</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_fs_history_t</name> *</type><name>history</name> <init>= <expr><name><name>args</name>-&gt;<name>history</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>fs_history_data_t</name> *</type><name>fhd</name> <init>= <expr><name><name>history</name>-&gt;<name>fsap_data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>commit_path</name></decl>, *<decl><type ref="prev"/><name>src_path</name></decl>, *<decl><type ref="prev"/><name>path</name> <init>= <expr><name><name>fhd</name>-&gt;<name>path</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>commit_rev</name></decl>, <decl><type ref="prev"/><name>src_rev</name></decl>, <decl><type ref="prev"/><name>dst_rev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>revision</name> <init>= <expr><name><name>fhd</name>-&gt;<name>revision</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>retpool</name> <init>= <expr><name><name>args</name>-&gt;<name>pool</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name> <init>= <expr><name><name>fhd</name>-&gt;<name>fs</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>parent_path_t</name> *</type><name>parent_path</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dag_node_t</name> *</type><name>node</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>node_id</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>reported</name> <init>= <expr><name><name>fhd</name>-&gt;<name>is_interesting</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>retry</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>copyroot_rev</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copyroot_path</name></decl>;</decl_stmt>
<expr_stmt><expr>*<name>prev_history</name> = <name>NULL</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>fhd</name>-&gt;<name>path_hint</name></name> &amp;&amp; <call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name><name>fhd</name>-&gt;<name>rev_hint</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>reported</name> = <name>FALSE</name></expr>;</expr_stmt>
<if>if <condition>(<expr>! <name><name>args</name>-&gt;<name>cross_copies</name></name></expr>)</condition><then>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>
<expr_stmt><expr><name>path</name> = <name><name>fhd</name>-&gt;<name>path_hint</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>revision</name> = <name><name>fhd</name>-&gt;<name>rev_hint</name></name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__revision_root</name><argument_list>(<argument><expr>&amp;<name>root</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>revision</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>open_path</name><argument_list>(<argument><expr>&amp;<name>parent_path</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>node</name> = <name><name>parent_path</name>-&gt;<name>node</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>node_id</name> = <call><name>svn_fs_fs__dag_get_id</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>commit_path</name> = <call><name>svn_fs_fs__dag_get_created_path</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_revision</name><argument_list>(<argument><expr>&amp;<name>commit_rev</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>revision</name> == <name>commit_rev</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>! <name>reported</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>prev_history</name> = <call><name>assemble_history</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,
<argument><expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>retpool</name></expr></argument>, <argument><expr><name>commit_path</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>commit_rev</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><name>SVN_INVALID_REVNUM</name></expr></argument>, <argument><expr><name>retpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>pred_id</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_predecessor_id</name><argument_list>(<argument><expr>&amp;<name>pred_id</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>! <name>pred_id</name></expr>)</condition><then>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_node</name><argument_list>(<argument><expr>&amp;<name>node</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>pred_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>node_id</name> = <call><name>svn_fs_fs__dag_get_id</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>commit_path</name> = <call><name>svn_fs_fs__dag_get_created_path</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_revision</name><argument_list>(<argument><expr>&amp;<name>commit_rev</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
}</block></then></if>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>find_youngest_copyroot</name><argument_list>(<argument><expr>&amp;<name>copyroot_rev</name></expr></argument>, <argument><expr>&amp;<name>copyroot_path</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>,
<argument><expr><name>parent_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>src_path</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>src_rev</name> = <name>SVN_INVALID_REVNUM</name></expr>;</expr_stmt>
<expr_stmt><expr><name>dst_rev</name> = <name>SVN_INVALID_REVNUM</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>copyroot_rev</name> &gt; <name>commit_rev</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>remainder</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copy_dst</name></decl>, *<decl><type ref="prev"/><name>copy_src</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>copyroot_root</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__revision_root</name><argument_list>(<argument><expr>&amp;<name>copyroot_root</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>copyroot_rev</name></expr></argument>,
<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_dag</name><argument_list>(<argument><expr>&amp;<name>node</name></expr></argument>, <argument><expr><name>copyroot_root</name></expr></argument>, <argument><expr><name>copyroot_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>copy_dst</name> = <call><name>svn_fs_fs__dag_get_created_path</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>copy_dst</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
<expr_stmt><expr><name>remainder</name> = ""</expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>remainder</name> = <call><name>svn_path_is_child</name><argument_list>(<argument><expr><name>copy_dst</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<if>if <condition>(<expr><name>remainder</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_copyfrom_rev</name><argument_list>(<argument><expr>&amp;<name>src_rev</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_copyfrom_path</name><argument_list>(<argument><expr>&amp;<name>copy_src</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dst_rev</name> = <name>copyroot_rev</name></expr>;</expr_stmt>
<expr_stmt><expr><name>src_path</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>copy_src</name></expr></argument>, <argument><expr><name>remainder</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
}</block></then></if>
<if>if <condition>(<expr><name>src_path</name> &amp;&amp; <call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name>src_rev</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr>(<name>dst_rev</name> == <name>revision</name>) &amp;&amp; <name>reported</name></expr>)</condition><then>
<expr_stmt><expr><name>retry</name> = <name>TRUE</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr>*<name>prev_history</name> = <call><name>assemble_history</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>retpool</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>dst_rev</name></expr></argument>, <argument><expr><name>retry</name> ? <name>FALSE</name> : <name>TRUE</name></expr></argument>,
<argument><expr><name>src_path</name></expr></argument>, <argument><expr><name>src_rev</name></expr></argument>, <argument><expr><name>retpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr>*<name>prev_history</name> = <call><name>assemble_history</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>retpool</name></expr></argument>, <argument><expr><name>commit_path</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>commit_rev</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><name>SVN_INVALID_REVNUM</name></expr></argument>, <argument><expr><name>retpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>fs_history_prev</name><parameter_list>(<param><decl><type><name>svn_fs_history_t</name> **</type><name>prev_history_p</name></decl></param>,
<param><decl><type><name>svn_fs_history_t</name> *</type><name>history</name></decl></param>,
<param><decl><type><name>svn_boolean_t</name></type> <name>cross_copies</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>svn_fs_history_t</name> *</type><name>prev_history</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>fs_history_data_t</name> *</type><name>fhd</name> <init>= <expr><name><name>history</name>-&gt;<name>fsap_data</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name> <init>= <expr><name><name>fhd</name>-&gt;<name>fs</name></name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>fhd</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr>"/"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then> <block>{
<if>if <condition>(<expr>! <name><name>fhd</name>-&gt;<name>is_interesting</name></name></expr>)</condition><then>
<expr_stmt><expr><name>prev_history</name> = <call><name>assemble_history</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr>"/"</expr></argument>, <argument><expr><name><name>fhd</name>-&gt;<name>revision</name></name></expr></argument>,
<argument><expr>1</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>SVN_INVALID_REVNUM</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><name><name>fhd</name>-&gt;<name>revision</name></name> &gt; 0</expr>)</condition><then>
<expr_stmt><expr><name>prev_history</name> = <call><name>assemble_history</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr>"/"</expr></argument>, <argument><expr><name><name>fhd</name>-&gt;<name>revision</name></name> - 1</expr></argument>,
<argument><expr>1</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>SVN_INVALID_REVNUM</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if>
}</block></then> <else>else <block>{
<decl_stmt><decl><type>struct <name>history_prev_args</name></type> <name>args</name></decl>;</decl_stmt>
<expr_stmt><expr><name>prev_history</name> = <name>history</name></expr>;</expr_stmt>
<while>while <condition>(<expr>1</expr>)</condition> <block>{
<expr_stmt><expr><name><name>args</name>.<name>prev_history_p</name></name> = &amp;<name>prev_history</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>args</name>.<name>history</name></name> = <name>prev_history</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>args</name>.<name>cross_copies</name></name> = <name>cross_copies</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>args</name>.<name>pool</name></name> = <name>pool</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>history_prev</name><argument_list>(<argument><expr>&amp;<name>args</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>! <name>prev_history</name></expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr><name>fhd</name> = <name><name>prev_history</name>-&gt;<name>fsap_data</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>fhd</name>-&gt;<name>is_interesting</name></name></expr>)</condition><then>
<break>break;</break></then></if>
}</block></while>
}</block></else></if>
<expr_stmt><expr>*<name>prev_history_p</name> = <name>prev_history</name></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>fs_history_location</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>path</name></decl></param>,
<param><decl><type><name>svn_revnum_t</name> *</type><name>revision</name></decl></param>,
<param><decl><type><name>svn_fs_history_t</name> *</type><name>history</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>fs_history_data_t</name> *</type><name>fhd</name> <init>= <expr><name><name>history</name>-&gt;<name>fsap_data</name></name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr>*<name>path</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>fhd</name>-&gt;<name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>revision</name> = <name><name>fhd</name>-&gt;<name>revision</name></name></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <name>history_vtable_t</name></type> <name>history_vtable</name> <init>= <expr><block>{
<expr><name>fs_history_prev</name></expr>,
<expr><name>fs_history_location</name></expr>
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>svn_fs_history_t</name> *</type>
<name>assemble_history</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
<param><decl><type><name>svn_revnum_t</name></type> <name>revision</name></decl></param>,
<param><decl><type><name>svn_boolean_t</name></type> <name>is_interesting</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path_hint</name></decl></param>,
<param><decl><type><name>svn_revnum_t</name></type> <name>rev_hint</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>svn_fs_history_t</name> *</type><name>history</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>history</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>fs_history_data_t</name> *</type><name>fhd</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>fhd</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>fhd</name>-&gt;<name>path</name></name> = <name>path</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fhd</name>-&gt;<name>revision</name></name> = <name>revision</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fhd</name>-&gt;<name>is_interesting</name></name> = <name>is_interesting</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fhd</name>-&gt;<name>path_hint</name></name> = <name>path_hint</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fhd</name>-&gt;<name>rev_hint</name></name> = <name>rev_hint</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>fhd</name>-&gt;<name>fs</name></name> = <name>fs</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>history</name>-&gt;<name>vtable</name></name> = &amp;<name>history_vtable</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>history</name>-&gt;<name>fsap_data</name></name> = <name>fhd</name></expr>;</expr_stmt>
<return>return <expr><name>history</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>crawl_directory_dag_for_mergeinfo</name><parameter_list>(<param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>this_path</name></decl></param>,
<param><decl><type><name>dag_node_t</name> *</type><name>dir_dag</name></decl></param>,
<param><decl><type><name>svn_mergeinfo_catalog_t</name></type> <name>result_catalog</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>result_pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>entries</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>iterpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_dir_entries</name><argument_list>(<argument><expr>&amp;<name>entries</name></expr></argument>, <argument><expr><name>dir_dag</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>entries</name></expr></argument>)</argument_list></call></expr>;</init>
<condition><expr><name>hi</name></expr>;</condition>
<incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>) <block>{
<decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_fs_dirent_t</name> *</type><name>dirent</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>kid_path</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>dag_node_t</name> *</type><name>kid_dag</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>has_mergeinfo</name></decl>, <decl><type ref="prev"/><name>go_down</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dirent</name> = <name>val</name></expr>;</expr_stmt>
<expr_stmt><expr><name>kid_path</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>this_path</name></expr></argument>, <argument><expr><name><name>dirent</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_dag</name><argument_list>(<argument><expr>&amp;<name>kid_dag</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>kid_path</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_has_mergeinfo</name><argument_list>(<argument><expr>&amp;<name>has_mergeinfo</name></expr></argument>, <argument><expr><name>kid_dag</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_has_descendants_with_mergeinfo</name><argument_list>(<argument><expr>&amp;<name>go_down</name></expr></argument>, <argument><expr><name>kid_dag</name></expr></argument>,
<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>has_mergeinfo</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>proplist</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_mergeinfo_t</name></type> <name>kid_mergeinfo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_string_t</name> *</type><name>mergeinfo_string</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_proplist</name><argument_list>(<argument><expr>&amp;<name>proplist</name></expr></argument>, <argument><expr><name>kid_dag</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>mergeinfo_string</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>proplist</name></expr></argument>, <argument><expr><name>SVN_PROP_MERGEINFO</name></expr></argument>,
<argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>mergeinfo_string</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>svn_string_t</name> *</type><name>idstr</name> <init>= <expr><call><name>svn_fs_fs__id_unparse</name><argument_list>(<argument><expr><name><name>dirent</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>svn_error_createf</name>
<argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr>"Node-revision #'%s' claims to have mergeinfo but doesn't"</expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name><name>idstr</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo_parse</name><argument_list>(<argument><expr>&amp;<name>kid_mergeinfo</name></expr></argument>,
<argument><expr><name><name>mergeinfo_string</name>-&gt;<name>data</name></name></expr></argument>,
<argument><expr><name>result_pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>result_catalog</name></expr></argument>,
<argument><expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>result_pool</name></expr></argument>, <argument><expr><name>kid_path</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>,
<argument><expr><name>kid_mergeinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>go_down</name></expr>)</condition><then>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>crawl_directory_dag_for_mergeinfo</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
<argument><expr><name>kid_path</name></expr></argument>,
<argument><expr><name>kid_dag</name></expr></argument>,
<argument><expr><name>result_catalog</name></expr></argument>,
<argument><expr><name>iterpool</name></expr></argument>,
<argument><expr><name>result_pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></for>
<expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>append_to_merged_froms</name><parameter_list>(<param><decl><type><name>svn_mergeinfo_t</name> *</type><name>output</name></decl></param>,
<param><decl><type><name>svn_mergeinfo_t</name></type> <name>input</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path_piece</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>
<expr_stmt><expr>*<name>output</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>hi</name></expr>;</condition> <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>) <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>newpath</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>newpath</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr>(const <name>char</name> *) <name>key</name></expr></argument>, <argument><expr><name>path_piece</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr>*<name>output</name></expr></argument>, <argument><expr><name>newpath</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>,
<argument><expr><call><name>svn_rangelist_dup</name><argument_list>(<argument><expr>(<name>apr_array_header_t</name> *) <name>val</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>get_mergeinfo_for_path</name><parameter_list>(<param><decl><type><name>svn_mergeinfo_t</name> *</type><name>mergeinfo</name></decl></param>,
<param><decl><type><name>svn_fs_root_t</name> *</type><name>rev_root</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
<param><decl><type><name>svn_mergeinfo_inheritance_t</name></type> <name>inherit</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>result_pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>parent_path_t</name> *</type><name>parent_path</name></decl>, *<decl><type ref="prev"/><name>nearest_ancestor</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>proplist</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_string_t</name> *</type><name>mergeinfo_string</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>iterpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr>*<name>mergeinfo</name> = <name>NULL</name></expr>;</expr_stmt>
<expr_stmt><expr><name>path</name> = <call><name>svn_fs__canonicalize_abspath</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>open_path</name><argument_list>(<argument><expr>&amp;<name>parent_path</name></expr></argument>, <argument><expr><name>rev_root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>inherit</name> == <name>svn_mergeinfo_nearest_ancestor</name> &amp;&amp; ! <name><name>parent_path</name>-&gt;<name>parent</name></name></expr>)</condition><then>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>inherit</name> == <name>svn_mergeinfo_nearest_ancestor</name></expr>)</condition><then>
<expr_stmt><expr><name>nearest_ancestor</name> = <name><name>parent_path</name>-&gt;<name>parent</name></name></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>nearest_ancestor</name> = <name>parent_path</name></expr>;</expr_stmt></else></if>
<while>while <condition>(<expr><name>TRUE</name></expr>)</condition> <block>{
<decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>has_mergeinfo</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_has_mergeinfo</name><argument_list>(<argument><expr>&amp;<name>has_mergeinfo</name></expr></argument>,
<argument><expr><name><name>nearest_ancestor</name>-&gt;<name>node</name></name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>has_mergeinfo</name></expr>)</condition><then>
<break>break;</break></then></if>
<if>if <condition>(<expr><name>inherit</name> == <name>svn_mergeinfo_explicit</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><name>nearest_ancestor</name> = <name><name>nearest_ancestor</name>-&gt;<name>parent</name></name></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>nearest_ancestor</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></then></if>
}</block></while>
<expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_proplist</name><argument_list>(<argument><expr>&amp;<name>proplist</name></expr></argument>, <argument><expr><name><name>nearest_ancestor</name>-&gt;<name>node</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>mergeinfo_string</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>proplist</name></expr></argument>, <argument><expr><name>SVN_PROP_MERGEINFO</name></expr></argument>,
<argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>mergeinfo_string</name></expr>)</condition><then>
<return>return <expr><call><name>svn_error_createf</name>
<argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr>"Node-revision '%s@%ld' claims to have mergeinfo but doesn't"</expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>parent_path_path</name><argument_list>(<argument><expr><name>nearest_ancestor</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>rev_root</name>-&gt;<name>rev</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><name>nearest_ancestor</name> == <name>parent_path</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo_parse</name><argument_list>(<argument><expr><name>mergeinfo</name></expr></argument>,
<argument><expr><name><name>mergeinfo_string</name>-&gt;<name>data</name></name></expr></argument>,
<argument><expr><name>result_pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></then> <else>else <block>{
<decl_stmt><decl><type><name>svn_mergeinfo_t</name></type> <name>temp_mergeinfo</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo_parse</name><argument_list>(<argument><expr>&amp;<name>temp_mergeinfo</name></expr></argument>,
<argument><expr><name><name>mergeinfo_string</name>-&gt;<name>data</name></name></expr></argument>,
<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo_inheritable</name><argument_list>(<argument><expr>&amp;<name>temp_mergeinfo</name></expr></argument>,
<argument><expr><name>temp_mergeinfo</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>SVN_INVALID_REVNUM</name></expr></argument>,
<argument><expr><name>SVN_INVALID_REVNUM</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>append_to_merged_froms</name><argument_list>(<argument><expr><name>mergeinfo</name></expr></argument>,
<argument><expr><name>temp_mergeinfo</name></expr></argument>,
<argument><expr><call><name>parent_path_relpath</name><argument_list>(<argument><expr><name>parent_path</name></expr></argument>,
<argument><expr><name>nearest_ancestor</name></expr></argument>,
<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>result_pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></else></if>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>add_descendant_mergeinfo</name><parameter_list>(<param><decl><type><name>svn_mergeinfo_catalog_t</name></type> <name>result_catalog</name></decl></param>,
<param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>result_pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>dag_node_t</name> *</type><name>this_dag</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>go_down</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_dag</name><argument_list>(<argument><expr>&amp;<name>this_dag</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_has_descendants_with_mergeinfo</name><argument_list>(<argument><expr>&amp;<name>go_down</name></expr></argument>,
<argument><expr><name>this_dag</name></expr></argument>,
<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>go_down</name></expr>)</condition><then>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>crawl_directory_dag_for_mergeinfo</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
<argument><expr><name>path</name></expr></argument>,
<argument><expr><name>this_dag</name></expr></argument>,
<argument><expr><name>result_catalog</name></expr></argument>,
<argument><expr><name>pool</name></expr></argument>,
<argument><expr><name>result_pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>get_mergeinfos_for_paths</name><parameter_list>(<param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
<param><decl><type><name>svn_mergeinfo_catalog_t</name> *</type><name>mergeinfo_catalog</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>apr_array_header_t</name> *</type><name>paths</name></decl></param>,
<param><decl><type><name>svn_mergeinfo_inheritance_t</name></type> <name>inherit</name></decl></param>,
<param><decl><type><name>svn_boolean_t</name></type> <name>include_descendants</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>svn_mergeinfo_catalog_t</name></type> <name>result_catalog</name> <init>= <expr><call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>iterpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>paths</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>svn_mergeinfo_t</name></type> <name>path_mergeinfo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name> <init>= <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>paths</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_mergeinfo_for_path</name><argument_list>(<argument><expr>&amp;<name>path_mergeinfo</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
<argument><expr><name>inherit</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>path_mergeinfo</name></expr>)</condition><then>
<expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>result_catalog</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>,
<argument><expr><name>path_mergeinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>include_descendants</name></expr>)</condition><then>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>add_descendant_mergeinfo</name><argument_list>(<argument><expr><name>result_catalog</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>,
<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></for>
<expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>mergeinfo_catalog</name> = <name>result_catalog</name></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>fs_get_mergeinfo</name><parameter_list>(<param><decl><type><name>svn_mergeinfo_catalog_t</name> *</type><name>catalog</name></decl></param>,
<param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>apr_array_header_t</name> *</type><name>paths</name></decl></param>,
<param><decl><type><name>svn_mergeinfo_inheritance_t</name></type> <name>inherit</name></decl></param>,
<param><decl><type><name>svn_boolean_t</name></type> <name>include_descendants</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>fs_fs_data_t</name> *</type><name>ffd</name> <init>= <expr><name><name>root</name>-&gt;<name>fs</name>-&gt;<name>fsap_data</name></name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>root</name>-&gt;<name>is_txn_root</name></name></expr>)</condition><then>
<return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_FS_NOT_REVISION_ROOT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr>! <call><name>svn_fs_fs__fs_supports_mergeinfo</name><argument_list>(<argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>svn_error_createf</name>
<argument_list>(<argument><expr><name>SVN_ERR_UNSUPPORTED_FEATURE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr>"Querying mergeinfo requires version %d of the FSFS filesystem "
"schema; filesystem '%s' uses only version %d"</expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>SVN_FS_FS__MIN_MERGEINFO_FORMAT</name></expr></argument>, <argument><expr><name><name>root</name>-&gt;<name>fs</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name><name>ffd</name>-&gt;<name>format</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<return>return <expr><call><name>get_mergeinfos_for_paths</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>paths</name></expr></argument>,
<argument><expr><name>inherit</name></expr></argument>, <argument><expr><name>include_descendants</name></expr></argument>,
<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <name>root_vtable_t</name></type> <name>root_vtable</name> <init>= <expr><block>{
<expr><name>fs_paths_changed</name></expr>,
<expr><name>svn_fs_fs__check_path</name></expr>,
<expr><name>fs_node_history</name></expr>,
<expr><name>fs_node_id</name></expr>,
<expr><name>svn_fs_fs__node_created_rev</name></expr>,
<expr><name>fs_node_origin_rev</name></expr>,
<expr><name>fs_node_created_path</name></expr>,
<expr><name>fs_delete_node</name></expr>,
<expr><name>fs_copied_from</name></expr>,
<expr><name>fs_closest_copy</name></expr>,
<expr><name>fs_node_prop</name></expr>,
<expr><name>fs_node_proplist</name></expr>,
<expr><name>fs_change_node_prop</name></expr>,
<expr><name>fs_props_changed</name></expr>,
<expr><name>fs_dir_entries</name></expr>,
<expr><name>fs_make_dir</name></expr>,
<expr><name>fs_copy</name></expr>,
<expr><name>fs_revision_link</name></expr>,
<expr><name>fs_file_length</name></expr>,
<expr><name>fs_file_md5_checksum</name></expr>,
<expr><name>fs_file_contents</name></expr>,
<expr><name>fs_make_file</name></expr>,
<expr><name>fs_apply_textdelta</name></expr>,
<expr><name>fs_apply_text</name></expr>,
<expr><name>fs_contents_changed</name></expr>,
<expr><name>fs_get_file_delta_stream</name></expr>,
<expr><name>fs_merge</name></expr>,
<expr><name>fs_get_mergeinfo</name></expr>
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>static</specifier> <name>svn_fs_root_t</name> *</type>
<name>make_root</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>root</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>root</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>root</name>-&gt;<name>fs</name></name> = <name>fs</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>root</name>-&gt;<name>pool</name></name> = <name>subpool</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>root</name>-&gt;<name>vtable</name></name> = &amp;<name>root_vtable</name></expr>;</expr_stmt>
<return>return <expr><name>root</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_fs_root_t</name> *</type>
<name>make_revision_root</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
<param><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl></param>,
<param><decl><type><name>dag_node_t</name> *</type><name>root_dir</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>root</name> <init>= <expr><call><name>make_root</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>fs_rev_root_data_t</name> *</type><name>frd</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name><name>root</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>frd</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>root</name>-&gt;<name>is_txn_root</name></name> = <name>FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>root</name>-&gt;<name>rev</name></name> = <name>rev</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>frd</name>-&gt;<name>root_dir</name></name> = <name>root_dir</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>frd</name>-&gt;<name>copyfrom_cache</name></name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name><name>root</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>root</name>-&gt;<name>fsap_data</name></name> = <name>frd</name></expr>;</expr_stmt>
<return>return <expr><name>root</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_fs_root_t</name> *</type>
<name>make_txn_root</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn</name></decl></param>,
<param><decl><type><name>svn_revnum_t</name></type> <name>base_rev</name></decl></param>,
<param><decl><type><name>apr_uint32_t</name></type> <name>flags</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>root</name> <init>= <expr><call><name>make_root</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>fs_txn_root_data_t</name> *</type><name>frd</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name><name>root</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>frd</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>root</name>-&gt;<name>is_txn_root</name></name> = <name>TRUE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>root</name>-&gt;<name>txn</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>root</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>txn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>root</name>-&gt;<name>txn_flags</name></name> = <name>flags</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>root</name>-&gt;<name>rev</name></name> = <name>base_rev</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>frd</name>-&gt;<name>txn_node_cache</name></name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name><name>root</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>frd</name>-&gt;<name>txn_node_list</name>.<name>prev</name></name> = &amp;<name><name>frd</name>-&gt;<name>txn_node_list</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>frd</name>-&gt;<name>txn_node_list</name>.<name>next</name></name> = &amp;<name><name>frd</name>-&gt;<name>txn_node_list</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>root</name>-&gt;<name>fsap_data</name></name> = <name>frd</name></expr>;</expr_stmt>
<return>return <expr><name>root</name></expr>;</return>
}</block></function>
</unit>
