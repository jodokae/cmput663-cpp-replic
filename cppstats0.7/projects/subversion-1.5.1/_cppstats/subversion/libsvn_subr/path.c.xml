<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/subversion-1.5.1/_cppstats/subversion/libsvn_subr/path.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_file_info.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_lib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_string.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_path.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_private_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_utf.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_io.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_ctype.h"</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_EMPTY_PATH</name></cpp:macro> <cpp:value>""</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_PATH_IS_EMPTY</name><parameter_list>(<param><type><name>s</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((s)[0] == '\0')</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_PATH_IS_PLATFORM_EMPTY</name><parameter_list>(<param><type><name>s</name></type></param>,<param><type><name>n</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((n) == 1 &amp;&amp; (s)[0] == '.')</cpp:value></cpp:define>
<function><type><specifier>const</specifier> <name>char</name> *</type>
<name>svn_path_internal_style</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr>'/' != <name>SVN_PATH_LOCAL_SEPARATOR</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>p</name> <init>= <expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>path</name> = <name>p</name></expr>;</expr_stmt>
<for>for (<init>;</init> <condition><expr>*<name>p</name> != '\0'</expr>;</condition> <incr><expr>++<name>p</name></expr></incr>)
<if>if <condition>(<expr>*<name>p</name> == <name>SVN_PATH_LOCAL_SEPARATOR</name></expr>)</condition><then>
<expr_stmt><expr>*<name>p</name> = '/'</expr>;</expr_stmt></then></if></for>
}</block></then></if>
<return>return <expr><call><name>svn_path_canonicalize</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>const</specifier> <name>char</name> *</type>
<name>svn_path_local_style</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>path</name> = <call><name>svn_path_canonicalize</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>SVN_PATH_IS_EMPTY</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>"."</expr>;</return></then></if>
<if>if <condition>(<expr><call><name>svn_path_is_url</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr>'/' != <name>SVN_PATH_LOCAL_SEPARATOR</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>p</name> <init>= <expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>path</name> = <name>p</name></expr>;</expr_stmt>
<for>for (<init>;</init> <condition><expr>*<name>p</name> != '\0'</expr>;</condition> <incr><expr>++<name>p</name></expr></incr>)
<if>if <condition>(<expr>*<name>p</name> == '/'</expr>)</condition><then>
<expr_stmt><expr>*<name>p</name> = <name>SVN_PATH_LOCAL_SEPARATOR</name></expr>;</expr_stmt></then></if></for>
}</block></then></if>
<return>return <expr><name>path</name></expr>;</return>
}</block></function>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr>!<call><name>defined</name><argument_list>(<argument><expr><name>NDEBUG</name></expr></argument>)</argument_list></call></expr></cpp:if>
<function><type><specifier>static</specifier> <name>svn_boolean_t</name></type>
<name>is_canonical</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
<param><decl><type><name>apr_size_t</name></type> <name>len</name></decl></param>)</parameter_list> <block>{
<return>return <expr>(! <call><name>SVN_PATH_IS_PLATFORM_EMPTY</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call>
&amp;&amp; (<call><name>svn_dirent_is_root</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> ||
(<name>len</name> &lt;= 1 || <name><name>path</name><index>[<expr><name>len</name>-1</expr>]</index></name> != '/')))</expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function><type><name>char</name> *</type><name>svn_path_join</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>base</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>component</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>blen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>clen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>component</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>path</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>is_canonical</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>blen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>is_canonical</name><argument_list>(<argument><expr><name>component</name></expr></argument>, <argument><expr><name>clen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>*<name>component</name> == '/'</expr>)</condition><then>
<return>return <expr><call><name>apr_pmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>component</name></expr></argument>, <argument><expr><name>clen</name> + 1</expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>SVN_PATH_IS_EMPTY</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>apr_pmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>component</name></expr></argument>, <argument><expr><name>clen</name> + 1</expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>SVN_PATH_IS_EMPTY</name><argument_list>(<argument><expr><name>component</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><call><name>apr_pmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>blen</name> + 1</expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><name>blen</name> == 1 &amp;&amp; <name><name>base</name><index>[<expr>0</expr>]</index></name> == '/'</expr>)</condition><then>
<expr_stmt><expr><name>blen</name> = 0</expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>path</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>blen</name> + 1 + <name>clen</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>blen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>path</name><index>[<expr><name>blen</name></expr>]</index></name> = '/'</expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>path</name> + <name>blen</name> + 1</expr></argument>, <argument><expr><name>component</name></expr></argument>, <argument><expr><name>clen</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>path</name></expr>;</return>
}</block></function>
<function><type><name>char</name> *</type><name>svn_path_join_many</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>base</name></decl></param>, <param><decl><type>...</type></decl></param>)</parameter_list> <block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_SAVED_LENGTHS</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name><name>saved_lengths</name><index>[<expr><name>MAX_SAVED_LENGTHS</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>total_len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>nargs</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>va_list</name></type> <name>va</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>path</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>base_is_empty</name> <init>= <expr><name>FALSE</name></expr></init>, <name>base_is_root</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>base_arg</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>total_len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>is_canonical</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>total_len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>total_len</name> == 1 &amp;&amp; *<name>base</name> == '/'</expr>)</condition><then>
<expr_stmt><expr><name>base_is_root</name> = <name>TRUE</name></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr><call><name>SVN_PATH_IS_EMPTY</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>total_len</name> = <sizeof>sizeof<argument_list>(<argument><expr><name>SVN_EMPTY_PATH</name></expr></argument>)</argument_list></sizeof> - 1</expr>;</expr_stmt>
<expr_stmt><expr><name>base_is_empty</name> = <name>TRUE</name></expr>;</expr_stmt>
}</block></then></if></else></if>
<expr_stmt><expr><name><name>saved_lengths</name><index>[<expr>0</expr>]</index></name> = <name>total_len</name></expr>;</expr_stmt>
<expr_stmt><expr><name>nargs</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>va</name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr>(<name>s</name> = <call><name>va_arg</name><argument_list>(<argument><expr><name>va</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition> <block>{
<expr_stmt><expr><name>len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>is_canonical</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>SVN_PATH_IS_EMPTY</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<continue>continue;</continue></then></if>
<if>if <condition>(<expr><name>nargs</name>++ &lt; <name>MAX_SAVED_LENGTHS</name></expr>)</condition><then>
<expr_stmt><expr><name><name>saved_lengths</name><index>[<expr><name>nargs</name></expr>]</index></name> = <name>len</name></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr>*<name>s</name> == '/'</expr>)</condition><then> <block>{
<expr_stmt><expr><name>total_len</name> = <name>len</name></expr>;</expr_stmt>
<expr_stmt><expr><name>base_arg</name> = <name>nargs</name></expr>;</expr_stmt>
<expr_stmt><expr><name>base_is_root</name> = <name>len</name> == 1</expr>;</expr_stmt>
<expr_stmt><expr><name>base_is_empty</name> = <name>FALSE</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>nargs</name> == <name>base_arg</name>
|| (<name>nargs</name> == <name>base_arg</name> + 1 &amp;&amp; <name>base_is_root</name>)
|| <name>base_is_empty</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>base_is_empty</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>base_is_empty</name> = <name>FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>total_len</name> = 0</expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>total_len</name> += <name>len</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>total_len</name> += 1 + <name>len</name></expr>;</expr_stmt>
}</block></else></if></else></if>
}</block></while>
<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>base_is_root</name> &amp;&amp; <name>total_len</name> == 1</expr>)</condition><then>
<return>return <expr><call><name>apr_pmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"/"</expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><name>path</name> = <name>p</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>total_len</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>base_arg</name> == 0 &amp;&amp; ! (<call><name>SVN_PATH_IS_EMPTY</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call> &amp;&amp; ! <name>base_is_empty</name>)</expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>SVN_PATH_IS_EMPTY</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SVN_EMPTY_PATH</name></expr></argument>, <argument><expr><name>len</name> = <name><name>saved_lengths</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>len</name> = <name><name>saved_lengths</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<expr_stmt><expr><name>p</name> += <name>len</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>nargs</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>va</name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr>(<name>s</name> = <call><name>va_arg</name><argument_list>(<argument><expr><name>va</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition> <block>{
<if>if <condition>(<expr><call><name>SVN_PATH_IS_EMPTY</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<continue>continue;</continue></then></if>
<if>if <condition>(<expr>++<name>nargs</name> &lt; <name>base_arg</name></expr>)</condition><then>
<continue>continue;</continue></then></if>
<if>if <condition>(<expr><name>nargs</name> &lt; <name>MAX_SAVED_LENGTHS</name></expr>)</condition><then>
<expr_stmt><expr><name>len</name> = <name><name>saved_lengths</name><index>[<expr><name>nargs</name></expr>]</index></name></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><name>len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<if>if <condition>(<expr><name>p</name> != <name>path</name> &amp;&amp; <name><name>p</name><index>[<expr>-1</expr>]</index></name> != '/'</expr>)</condition><then>
<expr_stmt><expr>*<name>p</name>++ = '/'</expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> += <name>len</name></expr>;</expr_stmt>
}</block></while>
<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>p</name> = '\0'</expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call>(<name>apr_size_t</name>)<argument_list>(<argument><expr><name>p</name> - <name>path</name></expr></argument>)</argument_list></call> == <name>total_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>path</name></expr>;</return>
}</block></function>
<function><type><name>apr_size_t</name></type>
<name>svn_path_component_count</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>count</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>is_canonical</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr>*<name>path</name></expr>)</condition> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>start</name></decl>;</decl_stmt>
<while>while <condition>(<expr>*<name>path</name> == '/'</expr>)</condition>
<expr_stmt><expr>++<name>path</name></expr>;</expr_stmt></while>
<expr_stmt><expr><name>start</name> = <name>path</name></expr>;</expr_stmt>
<while>while <condition>(<expr>*<name>path</name> &amp;&amp; *<name>path</name> != '/'</expr>)</condition>
<expr_stmt><expr>++<name>path</name></expr>;</expr_stmt></while>
<if>if <condition>(<expr><name>path</name> != <name>start</name></expr>)</condition><then>
<expr_stmt><expr>++<name>count</name></expr>;</expr_stmt></then></if>
}</block></while>
<return>return <expr><name>count</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>apr_size_t</name></type>
<name>previous_segment</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
<param><decl><type><name>apr_size_t</name></type> <name>len</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name>len</name> == 0</expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<while>while <condition>(<expr><name>len</name> &gt; 0 &amp;&amp; <name><name>path</name><index>[<expr>--<name>len</name></expr>]</index></name> != '/'</expr>)</condition>
<empty_stmt>;</empty_stmt></while>
<if>if <condition>(<expr><name>len</name> == 0 &amp;&amp; <name><name>path</name><index>[<expr>0</expr>]</index></name> == '/'</expr>)</condition><then>
<return>return <expr>1</expr>;</return></then>
<else>else
<return>return <expr><name>len</name></expr>;</return></else></if>
}</block></function>
<function><type><name>void</name></type>
<name>svn_path_add_component</name><parameter_list>(<param><decl><type><name>svn_stringbuf_t</name> *</type><name>path</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>component</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>component</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>is_canonical</name><argument_list>(<argument><expr><name><name>path</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>path</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>is_canonical</name><argument_list>(<argument><expr><name>component</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>(! <call><name>SVN_PATH_IS_EMPTY</name><argument_list>(<argument><expr><name><name>path</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call>)
&amp;&amp; (! ((<name><name>path</name>-&gt;<name>len</name></name> == 1) &amp;&amp; (*(<name><name>path</name>-&gt;<name>data</name></name>) == '/')))</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name></type> <name>dirsep</name> <init>= <expr>'/'</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>svn_stringbuf_appendbytes</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>&amp;<name>dirsep</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dirsep</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>svn_stringbuf_appendbytes</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>component</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<function><type><name>void</name></type>
<name>svn_path_remove_component</name><parameter_list>(<param><decl><type><name>svn_stringbuf_t</name> *</type><name>path</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>is_canonical</name><argument_list>(<argument><expr><name><name>path</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>path</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>path</name>-&gt;<name>len</name></name> = <call><name>previous_segment</name><argument_list>(<argument><expr><name><name>path</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>path</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>path</name>-&gt;<name>data</name><index>[<expr><name><name>path</name>-&gt;<name>len</name></name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
}</block></function>
<function><type><name>void</name></type>
<name>svn_path_remove_components</name><parameter_list>(<param><decl><type><name>svn_stringbuf_t</name> *</type><name>path</name></decl></param>, <param><decl><type><name>apr_size_t</name></type> <name>n</name></decl></param>)</parameter_list> <block>{
<while>while <condition>(<expr><name>n</name> &gt; 0</expr>)</condition> <block>{
<expr_stmt><expr><call><name>svn_path_remove_component</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>n</name>--</expr>;</expr_stmt>
}</block></while>
}</block></function>
<function><type><name>char</name> *</type>
<name>svn_path_dirname</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>is_canonical</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>previous_segment</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>char</name> *</type>
<name>svn_path_basename</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>start</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>is_canonical</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>len</name> == 1 &amp;&amp; <name><name>path</name><index>[<expr>0</expr>]</index></name> == '/'</expr>)</condition><then>
<expr_stmt><expr><name>start</name> = 0</expr>;</expr_stmt></then>
<else>else <block>{
<expr_stmt><expr><name>start</name> = <name>len</name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>start</name> &gt; 0 &amp;&amp; <name><name>path</name><index>[<expr><name>start</name> - 1</expr>]</index></name> != '/'</expr>)</condition>
<expr_stmt><expr>--<name>start</name></expr>;</expr_stmt></while>
}</block></else></if>
<return>return <expr><call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>path</name> + <name>start</name></expr></argument>, <argument><expr><name>len</name> - <name>start</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>void</name></type>
<name>svn_path_split</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>dirpath</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>base_name</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>dirpath</name> != <name>base_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>dirpath</name></expr>)</condition><then>
<expr_stmt><expr>*<name>dirpath</name> = <call><name>svn_path_dirname</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>base_name</name></expr>)</condition><then>
<expr_stmt><expr>*<name>base_name</name> = <call><name>svn_path_basename</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>
<function><type><name>int</name></type>
<name>svn_path_is_empty</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><call><name>SVN_PATH_IS_EMPTY</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>1</expr>;</return></then></if>
<return>return <expr>0</expr>;</return>
}</block></function>
<function><type><name>svn_boolean_t</name></type>
<name>svn_dirent_is_root</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dirent</name></decl></param>, <param><decl><type><name>apr_size_t</name></type> <name>len</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name>len</name> == 1 &amp;&amp; <name><name>dirent</name><index>[<expr>0</expr>]</index></name> == '/'</expr>)</condition><then>
<return>return <expr><name>TRUE</name></expr>;</return></then></if>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr>(<name>len</name> == 2 || <name>len</name> == 3) &amp;&amp;
(<name><name>dirent</name><index>[<expr>1</expr>]</index></name> == ':') &amp;&amp;
((<name><name>dirent</name><index>[<expr>0</expr>]</index></name> &gt;= 'A' &amp;&amp; <name><name>dirent</name><index>[<expr>0</expr>]</index></name> &lt;= 'Z') ||
(<name><name>dirent</name><index>[<expr>0</expr>]</index></name> &gt;= 'a' &amp;&amp; <name><name>dirent</name><index>[<expr>0</expr>]</index></name> &lt;= 'z')) &amp;&amp;
(<name>len</name> == 2 || (<name><name>dirent</name><index>[<expr>2</expr>]</index></name> == '/' &amp;&amp; <name>len</name> == 3))</expr>)</condition><then>
<return>return <expr><name>TRUE</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>len</name> &gt;= 2 &amp;&amp; <name><name>dirent</name><index>[<expr>0</expr>]</index></name> == '/' &amp;&amp; <name><name>dirent</name><index>[<expr>1</expr>]</index></name> == '/'
&amp;&amp; <name><name>dirent</name><index>[<expr><name>len</name> - 1</expr>]</index></name> != '/'</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>segments</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = <name>len</name></expr>;</init> <condition><expr><name>i</name> &gt;= 2</expr>;</condition> <incr><expr><name>i</name>--</expr></incr>) <block>{
<if>if <condition>(<expr><name><name>dirent</name><index>[<expr><name>i</name></expr>]</index></name> == '/'</expr>)</condition><then> <block>{
<expr_stmt><expr><name>segments</name> ++</expr>;</expr_stmt>
<if>if <condition>(<expr><name>segments</name> &gt; 1</expr>)</condition><then>
<return>return <expr><name>FALSE</name></expr>;</return></then></if>
}</block></then></if>
}</block></for>
<return>return <expr>(<name>segments</name> &lt;= 1)</expr>;</return>
}</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><name>FALSE</name></expr>;</return>
}</block></function>
<function><type><name>int</name></type>
<name>svn_path_compare_paths</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path1</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path2</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>path1_len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>path1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>path2_len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>path2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>min_len</name> <init>= <expr>((<name>path1_len</name> &lt; <name>path2_len</name>) ? <name>path1_len</name> : <name>path2_len</name>)</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>is_canonical</name><argument_list>(<argument><expr><name>path1</name></expr></argument>, <argument><expr><name>path1_len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>is_canonical</name><argument_list>(<argument><expr><name>path2</name></expr></argument>, <argument><expr><name>path2_len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>i</name> &lt; <name>min_len</name> &amp;&amp; <name><name>path1</name><index>[<expr><name>i</name></expr>]</index></name> == <name><name>path2</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
<expr_stmt><expr>++<name>i</name></expr>;</expr_stmt></while>
<if>if <condition>(<expr>(<name>path1_len</name> == <name>path2_len</name>) &amp;&amp; (<name>i</name> &gt;= <name>min_len</name>)</expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<if>if <condition>(<expr>(<name><name>path1</name><index>[<expr><name>i</name></expr>]</index></name> == '/') &amp;&amp; (<name><name>path2</name><index>[<expr><name>i</name></expr>]</index></name> == 0)</expr>)</condition><then>
<return>return <expr>1</expr>;</return></then></if>
<if>if <condition>(<expr>(<name><name>path2</name><index>[<expr><name>i</name></expr>]</index></name> == '/') &amp;&amp; (<name><name>path1</name><index>[<expr><name>i</name></expr>]</index></name> == 0)</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr><name><name>path1</name><index>[<expr><name>i</name></expr>]</index></name> == '/'</expr>)</condition><then>
<return>return <expr>-1</expr>;</return></then></if>
<if>if <condition>(<expr><name><name>path2</name><index>[<expr><name>i</name></expr>]</index></name> == '/'</expr>)</condition><then>
<return>return <expr>1</expr>;</return></then></if>
<return>return <expr><call>(<name>unsigned</name> <name>char</name>)<argument_list>(<argument><expr><name><name>path1</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> &lt; <call>(<name>unsigned</name> <name>char</name>)<argument_list>(<argument><expr><name><name>path2</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> ? -1 : 1</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>apr_size_t</name></type>
<name>get_path_ancestor_length</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path1</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path2</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>path1_len</name></decl>, <decl><type ref="prev"/><name>path2_len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>last_dirsep</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>path1_len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>path1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>path2_len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>path2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><call><name>SVN_PATH_IS_EMPTY</name><argument_list>(<argument><expr><name>path1</name></expr></argument>)</argument_list></call> || <call><name>SVN_PATH_IS_EMPTY</name><argument_list>(<argument><expr><name>path2</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>0</expr>;</return></then></if>
<while>while <condition>(<expr><name><name>path1</name><index>[<expr><name>i</name></expr>]</index></name> == <name><name>path2</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition> <block>{
<if>if <condition>(<expr><name><name>path1</name><index>[<expr><name>i</name></expr>]</index></name> == '/'</expr>)</condition><then>
<expr_stmt><expr><name>last_dirsep</name> = <name>i</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
<if>if <condition>(<expr>(<name>i</name> == <name>path1_len</name>) || (<name>i</name> == <name>path2_len</name>)</expr>)</condition><then>
<break>break;</break></then></if>
}</block></while>
<if>if <condition>(<expr><name>i</name> == 1 &amp;&amp; <name><name>path1</name><index>[<expr>0</expr>]</index></name> == '/' &amp;&amp; <name><name>path2</name><index>[<expr>0</expr>]</index></name> == '/'</expr>)</condition><then>
<return>return <expr>1</expr>;</return></then></if>
<if>if <condition>(<expr>((<name>i</name> == <name>path1_len</name>) &amp;&amp; (<name><name>path2</name><index>[<expr><name>i</name></expr>]</index></name> == '/'))
|| ((<name>i</name> == <name>path2_len</name>) &amp;&amp; (<name><name>path1</name><index>[<expr><name>i</name></expr>]</index></name> == '/'))
|| ((<name>i</name> == <name>path1_len</name>) &amp;&amp; (<name>i</name> == <name>path2_len</name>))</expr>)</condition><then>
<return>return <expr><name>i</name></expr>;</return></then>
<else>else <if>if <condition>(<expr><name>last_dirsep</name> == 0 &amp;&amp; <name><name>path1</name><index>[<expr>0</expr>]</index></name> == '/' &amp;&amp; <name><name>path2</name><index>[<expr>0</expr>]</index></name> == '/'</expr>)</condition><then>
<return>return <expr>1</expr>;</return></then></if></else></if>
<return>return <expr><name>last_dirsep</name></expr>;</return>
}</block></function>
<function><type><name>char</name> *</type>
<name>svn_path_get_longest_ancestor</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path1</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path2</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>path1_is_url</name></decl>, <decl><type ref="prev"/><name>path2_is_url</name></decl>;</decl_stmt>
<expr_stmt><expr><name>path1_is_url</name> = <call><name>svn_path_is_url</name><argument_list>(<argument><expr><name>path1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>path2_is_url</name> = <call><name>svn_path_is_url</name><argument_list>(<argument><expr><name>path2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>path1_is_url</name> &amp;&amp; <name>path2_is_url</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>path_ancestor_len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr>1</expr>)</condition> <block>{
<if>if <condition>(<expr><name><name>path1</name><index>[<expr><name>i</name></expr>]</index></name> != <name><name>path2</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then>
<return>return <expr><call><name>apr_pmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>SVN_EMPTY_PATH</name></expr></argument>,
<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SVN_EMPTY_PATH</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><name><name>path1</name><index>[<expr><name>i</name></expr>]</index></name> == ':'</expr>)</condition><then>
<break>break;</break></then></if>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>(<name><name>path1</name><index>[<expr><name>i</name></expr>]</index></name> != '\0') &amp;&amp; (<name><name>path2</name><index>[<expr><name>i</name></expr>]</index></name> != '\0')</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
}</block></while>
<expr_stmt><expr><name>i</name> += 3</expr>;</expr_stmt>
<expr_stmt><expr><name>path_ancestor_len</name> = <call><name>get_path_ancestor_length</name><argument_list>(<argument><expr><name>path1</name> + <name>i</name></expr></argument>, <argument><expr><name>path2</name> + <name>i</name></expr></argument>,
<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>path_ancestor_len</name> == 0 ||
(<name>path_ancestor_len</name> == 1 &amp;&amp; (<name>path1</name> + <name>i</name>)<index>[<expr>0</expr>]</index> == '/')</expr>)</condition><then>
<return>return <expr><call><name>apr_pmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>SVN_EMPTY_PATH</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SVN_EMPTY_PATH</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return></then>
<else>else
<return>return <expr><call><name>apr_pstrndup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>path1</name></expr></argument>, <argument><expr><name>path_ancestor_len</name> + <name>i</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></then>
<else>else <if>if <condition>(<expr>(! <name>path1_is_url</name>) &amp;&amp; (! <name>path2_is_url</name>)</expr>)</condition><then> <block>{
<return>return <expr><call><name>apr_pstrndup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>path1</name></expr></argument>,
<argument><expr><call><name>get_path_ancestor_length</name><argument_list>(<argument><expr><name>path1</name></expr></argument>, <argument><expr><name>path2</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></then>
<else>else <block>{
<return>return <expr><call><name>apr_pmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>SVN_EMPTY_PATH</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SVN_EMPTY_PATH</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
}</block></else></if></else></if>
}</block></function>
<function><type><specifier>const</specifier> <name>char</name> *</type>
<name>svn_path_is_child</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path1</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path2</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>i</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>SVN_PATH_IS_EMPTY</name><argument_list>(<argument><expr><name>path1</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>SVN_PATH_IS_EMPTY</name><argument_list>(<argument><expr><name>path2</name></expr></argument>)</argument_list></call>
|| <name><name>path2</name><index>[<expr>0</expr>]</index></name> == '/'</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then>
<else>else
<return>return <expr><name>pool</name> ? <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>path2</name></expr></argument>)</argument_list></call> : <name>path2</name></expr>;</return></else></if>
}</block></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name><name>path1</name><index>[<expr><name>i</name></expr>]</index></name> &amp;&amp; <name><name>path2</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
<if>if <condition>(<expr><name><name>path1</name><index>[<expr><name>i</name></expr>]</index></name> != <name><name>path2</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if></for>
<if>if <condition>(<expr><name><name>path1</name><index>[<expr><name>i</name></expr>]</index></name> == '\0' &amp;&amp; <name><name>path2</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>path2</name><index>[<expr><name>i</name></expr>]</index></name> == '/'</expr>)</condition><then>
<return>return <expr><name>pool</name> ? <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>path2</name> + <name>i</name> + 1</expr></argument>)</argument_list></call> : <name>path2</name> + <name>i</name> + 1</expr>;</return></then>
<else>else <if>if <condition>(<expr><name>i</name> == 1 &amp;&amp; <name><name>path1</name><index>[<expr>0</expr>]</index></name> == '/'</expr>)</condition><then>
<return>return <expr><name>pool</name> ? <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>path2</name> + 1</expr></argument>)</argument_list></call> : <name>path2</name> + 1</expr>;</return></then></if></else></if>
}</block></then></if>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><name>svn_boolean_t</name></type>
<name>svn_path_is_ancestor</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path1</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path2</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>path1_len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>path1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>SVN_PATH_IS_EMPTY</name><argument_list>(<argument><expr><name>path1</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr>*<name>path2</name> != '/'</expr>;</return></then></if>
<if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>path1</name></expr></argument>, <argument><expr><name>path2</name></expr></argument>, <argument><expr><name>path1_len</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
<return>return <expr><name><name>path1</name><index>[<expr><name>path1_len</name> - 1</expr>]</index></name> == '/'
|| (<name><name>path2</name><index>[<expr><name>path1_len</name></expr>]</index></name> == '/' || <name><name>path2</name><index>[<expr><name>path1_len</name></expr>]</index></name> == '\0')</expr>;</return></then></if>
<return>return <expr><name>FALSE</name></expr>;</return>
}</block></function>
<function><type><name>apr_array_header_t</name> *</type>
<name>svn_path_decompose</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>oldi</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>components</name> <init>=
<expr><call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>const <name>char</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>SVN_PATH_IS_EMPTY</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>components</name></expr>;</return></then></if>
<expr_stmt><expr><name>i</name> = <name>oldi</name> = 0</expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>path</name><index>[<expr><name>i</name></expr>]</index></name> == '/'</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name></type> <name>dirsep</name> <init>= <expr>'/'</expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>components</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call>
= <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>&amp;<name>dirsep</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dirsep</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
<expr_stmt><expr><name>oldi</name>++</expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>path</name><index>[<expr><name>i</name></expr>]</index></name> == '\0'</expr>)</condition><then>
<return>return <expr><name>components</name></expr>;</return></then></if>
}</block></then></if>
<do>do <block>{
<if>if <condition>(<expr>(<name><name>path</name><index>[<expr><name>i</name></expr>]</index></name> == '/') || (<name><name>path</name><index>[<expr><name>i</name></expr>]</index></name> == '\0')</expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>SVN_PATH_IS_PLATFORM_EMPTY</name><argument_list>(<argument><expr><name>path</name> + <name>oldi</name></expr></argument>, <argument><expr><name>i</name> - <name>oldi</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>components</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call> = <name>SVN_EMPTY_PATH</name></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>components</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call>
= <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>path</name> + <name>oldi</name></expr></argument>, <argument><expr><name>i</name> - <name>oldi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
<expr_stmt><expr><name>oldi</name> = <name>i</name></expr>;</expr_stmt>
<continue>continue;</continue>
}</block></then></if>
<expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
}</block> while <condition>(<expr><name><name>path</name><index>[<expr><name>i</name>-1</expr>]</index></name></expr>)</condition>;</do>
<return>return <expr><name>components</name></expr>;</return>
}</block></function>
<function><type><specifier>const</specifier> <name>char</name> *</type>
<name>svn_path_compose</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>apr_array_header_t</name> *</type><name>components</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_size_t</name> *</type><name>lengths</name> <init>= <expr><call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>components</name>-&gt;<name>nelts</name></name>*<sizeof>sizeof<argument_list>(<argument><expr>*<name>lengths</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>max_length</name> <init>= <expr><name><name>components</name>-&gt;<name>nelts</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>path</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>components</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>l</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>components</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name><name>lengths</name><index>[<expr><name>i</name></expr>]</index></name> = <name>l</name></expr>;</expr_stmt>
<expr_stmt><expr><name>max_length</name> += <name>l</name></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><name>path</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>max_length</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> = <name>path</name></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>components</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<if>if <condition>(<expr><name>i</name> &gt; 1 ||
(<name>i</name> == 1 &amp;&amp; <call><name>strcmp</name><argument_list>(<argument><expr>"/"</expr></argument>, <argument><expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>components</name></expr></argument>,
<argument><expr>0</expr></argument>,
<argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> != 0)</expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>p</name>++ = '/'</expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>components</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>lengths</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>p</name> += <name><name>lengths</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr>*<name>p</name> = '\0'</expr>;</expr_stmt>
<return>return <expr><name>path</name></expr>;</return>
}</block></function>
<function><type><name>svn_boolean_t</name></type>
<name>svn_path_is_single_path_component</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><call><name>SVN_PATH_IS_EMPTY</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call>
|| (<name><name>name</name><index>[<expr>0</expr>]</index></name> == '.' &amp;&amp; <name><name>name</name><index>[<expr>1</expr>]</index></name> == '.' &amp;&amp; <name><name>name</name><index>[<expr>2</expr>]</index></name> == '\0')</expr>)</condition><then>
<return>return <expr><name>FALSE</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>'/'</expr></argument>)</argument_list></call> != <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>FALSE</name></expr>;</return></then></if>
<return>return <expr><name>TRUE</name></expr>;</return>
}</block></function>
<function><type><name>svn_boolean_t</name></type>
<name>svn_path_is_backpath_present</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>! <call><name>strcmp</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>".."</expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>TRUE</name></expr>;</return></then></if>
<if>if <condition>(<expr>! <call><name>strncmp</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>"../"</expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>TRUE</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>"/../"</expr></argument>)</argument_list></call> != <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>TRUE</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>len</name> &gt;= 3
&amp;&amp; (! <call><name>strncmp</name><argument_list>(<argument><expr><name>path</name> + <name>len</name> - 3</expr></argument>, <argument><expr>"/.."</expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call>)</expr>)</condition><then>
<return>return <expr><name>TRUE</name></expr>;</return></then></if>
<return>return <expr><name>FALSE</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type>
<name>skip_uri_scheme</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>j</name></decl>;</decl_stmt>
<for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name><name>path</name><index>[<expr><name>j</name></expr>]</index></name> &amp;&amp; <name><name>path</name><index>[<expr><name>j</name></expr>]</index></name> != ':'</expr>;</condition> <incr><expr>++<name>j</name></expr></incr>)
<if>if <condition>(<expr><name><name>path</name><index>[<expr><name>j</name></expr>]</index></name> == '/'</expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if></for>
<if>if <condition>(<expr><name>j</name> &gt; 0 &amp;&amp; <name><name>path</name><index>[<expr><name>j</name></expr>]</index></name> == ':' &amp;&amp; <name><name>path</name><index>[<expr><name>j</name>+1</expr>]</index></name> == '/' &amp;&amp; <name><name>path</name><index>[<expr><name>j</name>+2</expr>]</index></name> == '/'</expr>)</condition><then>
<return>return <expr><name>path</name> + <name>j</name> + 3</expr>;</return></then></if>
<return>return <expr><name>NULL</name></expr>;</return>
}</block></function>
<function><type><name>svn_boolean_t</name></type>
<name>svn_path_is_url</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>skip_uri_scheme</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call> ? <name>TRUE</name> : <name>FALSE</name></expr>;</return>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>uri_char_validity</name><index>[<expr>256</expr>]</index></name> <init>= <expr><block>{
<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
<expr>0</expr>, <expr>1</expr>, <expr>0</expr>, <expr>0</expr>, <expr>1</expr>, <expr>0</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
<expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>0</expr>, <expr>0</expr>, <expr>1</expr>, <expr>0</expr>, <expr>0</expr>,
<expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
<expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>1</expr>,
<expr>0</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
<expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>1</expr>, <expr>0</expr>,
<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
}</block></expr></init></decl>;</decl_stmt>
<function><type><name>svn_boolean_t</name></type>
<name>svn_path_is_uri_safe</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr><name>path</name> = <call><name>skip_uri_scheme</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>! <name>path</name></expr>)</condition><then>
<return>return <expr><name>FALSE</name></expr>;</return></then></if>
<expr_stmt><expr><name>path</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>'/'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>path</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>TRUE</name></expr>;</return></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name><name>path</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<if>if <condition>(<expr><name><name>path</name><index>[<expr><name>i</name></expr>]</index></name> == '%'</expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>apr_isxdigit</name><argument_list>(<argument><expr><name><name>path</name><index>[<expr><name>i</name> + 1</expr>]</index></name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>apr_isxdigit</name><argument_list>(<argument><expr><name><name>path</name><index>[<expr><name>i</name> + 2</expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><name>i</name> += 2</expr>;</expr_stmt>
<continue>continue;</continue>
}</block></then></if>
<return>return <expr><name>FALSE</name></expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr>! <name><name>uri_char_validity</name><index>[<expr>((<name>unsigned</name> <name>char</name>)<name><name>path</name><index>[<expr><name>i</name></expr>]</index></name>)</expr>]</index></name></expr>)</condition><then> <block>{
<return>return <expr><name>FALSE</name></expr>;</return>
}</block></then></if></else></if>
}</block></for>
<return>return <expr><name>TRUE</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type>
<name>uri_escape</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>table</name><index>[]</index></name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>retstr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>copied</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
<expr_stmt><expr><name>retstr</name> = <call><name>svn_stringbuf_create</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name><name>path</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><name>c</name> = (<name>unsigned</name> <name>char</name>)<name><name>path</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>table</name><index>[<expr><name>c</name></expr>]</index></name></expr>)</condition><then>
<continue>continue;</continue></then></if>
<if>if <condition>(<expr><name>i</name> - <name>copied</name></expr>)</condition><then>
<expr_stmt><expr><call><name>svn_stringbuf_appendbytes</name><argument_list>(<argument><expr><name>retstr</name></expr></argument>, <argument><expr><name>path</name> + <name>copied</name></expr></argument>,
<argument><expr><name>i</name> - <name>copied</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>svn_stringbuf_ensure</name><argument_list>(<argument><expr><name>retstr</name></expr></argument>, <argument><expr><name><name>retstr</name>-&gt;<name>len</name></name> + 4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name><name>retstr</name>-&gt;<name>data</name></name> + <name><name>retstr</name>-&gt;<name>len</name></name></expr></argument>, <argument><expr>"%%%02X"</expr></argument>, <argument><expr>(<name>unsigned</name> <name>char</name>)<name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>retstr</name>-&gt;<name>len</name></name> += 3</expr>;</expr_stmt>
<expr_stmt><expr><name>copied</name> = <name>i</name> + 1</expr>;</expr_stmt>
}</block></for>
<if>if <condition>(<expr><name><name>retstr</name>-&gt;<name>len</name></name> == 0</expr>)</condition><then>
<return>return <expr><name>path</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>i</name> - <name>copied</name></expr>)</condition><then>
<expr_stmt><expr><call><name>svn_stringbuf_appendbytes</name><argument_list>(<argument><expr><name>retstr</name></expr></argument>, <argument><expr><name>path</name> + <name>copied</name></expr></argument>, <argument><expr><name>i</name> - <name>copied</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name><name>retstr</name>-&gt;<name>data</name></name></expr>;</return>
}</block></function>
<function><type><specifier>const</specifier> <name>char</name> *</type>
<name>svn_path_uri_encode</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ret</name></decl>;</decl_stmt>
<expr_stmt><expr><name>ret</name> = <call><name>uri_escape</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>uri_char_validity</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>ret</name> == <name>path</name></expr>)</condition><then>
<return>return <expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return></then>
<else>else
<return>return <expr><name>ret</name></expr>;</return></else></if>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>iri_escape_chars</name><index>[<expr>256</expr>]</index></name> <init>= <expr><block>{
<expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
<expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
<expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
<expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
<expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
<expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
<expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
<expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
<expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>const</specifier> <name>char</name> *</type>
<name>svn_path_uri_from_iri</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>iri</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>uri_escape</name><argument_list>(<argument><expr><name>iri</name></expr></argument>, <argument><expr><name>iri_escape_chars</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>uri_autoescape_chars</name><index>[<expr>256</expr>]</index></name> <init>= <expr><block>{
<expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
<expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
<expr>0</expr>, <expr>1</expr>, <expr>0</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
<expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>0</expr>, <expr>1</expr>, <expr>0</expr>, <expr>1</expr>,
<expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
<expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>0</expr>, <expr>1</expr>, <expr>0</expr>, <expr>1</expr>,
<expr>0</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
<expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>1</expr>, <expr>1</expr>,
<expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
<expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
<expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
<expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
<expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
<expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
<expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
<expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
}</block></expr></init></decl>;</decl_stmt>
<function><type><specifier>const</specifier> <name>char</name> *</type>
<name>svn_path_uri_autoescape</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>uri</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>uri_escape</name><argument_list>(<argument><expr><name>uri</name></expr></argument>, <argument><expr><name>uri_autoescape_chars</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>const</specifier> <name>char</name> *</type>
<name>svn_path_uri_decode</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>retstr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>i</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>query_start</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>retstr</name> = <call><name>svn_stringbuf_create</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>svn_stringbuf_ensure</name><argument_list>(<argument><expr><name>retstr</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>retstr</name>-&gt;<name>len</name></name> = 0</expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name><name>path</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<decl_stmt><decl><type><name>char</name></type> <name>c</name> <init>= <expr><name><name>path</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>c</name> == '?'</expr>)</condition><then> <block>{
<expr_stmt><expr><name>query_start</name> = <name>TRUE</name></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>c</name> == '+' &amp;&amp; <name>query_start</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>c</name> = ' '</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>c</name> == '%' &amp;&amp; <call><name>apr_isxdigit</name><argument_list>(<argument><expr><name><name>path</name><index>[<expr><name>i</name> + 1</expr>]</index></name></expr></argument>)</argument_list></call>
&amp;&amp; <call><name>apr_isxdigit</name><argument_list>(<argument><expr><name><name>path</name><index>[<expr><name>i</name>+2</expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>char</name></type> <name><name>digitz</name><index>[<expr>3</expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>digitz</name><index>[<expr>0</expr>]</index></name> = <name><name>path</name><index>[<expr>++<name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>digitz</name><index>[<expr>1</expr>]</index></name> = <name><name>path</name><index>[<expr>++<name>i</name></expr>]</index></name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>digitz</name><index>[<expr>2</expr>]</index></name> = '\0'</expr>;</expr_stmt>
<expr_stmt><expr><name>c</name> = <call>(<name>char</name>)<argument_list>(<argument><expr><call><name>strtol</name><argument_list>(<argument><expr><name>digitz</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>16</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if></else></if></else></if>
<expr_stmt><expr><name><name>retstr</name>-&gt;<name>data</name><index>[<expr><name><name>retstr</name>-&gt;<name>len</name></name>++</expr>]</index></name> = <name>c</name></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><name><name>retstr</name>-&gt;<name>data</name><index>[<expr><name><name>retstr</name>-&gt;<name>len</name></name></expr>]</index></name> = 0</expr>;</expr_stmt>
<return>return <expr><name><name>retstr</name>-&gt;<name>data</name></name></expr>;</return>
}</block></function>
<function><type><specifier>const</specifier> <name>char</name> *</type>
<name>svn_path_url_add_component</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>url</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>component</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<expr_stmt><expr><name>url</name> = <call><name>svn_path_canonicalize</name><argument_list>(<argument><expr><name>url</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><call><name>svn_path_join</name><argument_list>(<argument><expr><name>url</name></expr></argument>, <argument><expr><call><name>svn_path_uri_encode</name><argument_list>(<argument><expr><name>component</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>svn_error_t</name> *</type>
<name>svn_path_get_absolute</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>pabsolute</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>relative</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>buffer</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_status_t</name></type> <name>apr_err</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path_apr</name></decl>;</decl_stmt>
<if>if <condition>(<expr><call><name>svn_path_is_url</name><argument_list>(<argument><expr><name>relative</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>pabsolute</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>relative</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_path_cstring_from_utf8</name><argument_list>(<argument><expr>&amp;<name>path_apr</name></expr></argument>, <argument><expr><name>relative</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>apr_err</name> = <call><name>apr_filepath_merge</name><argument_list>(<argument><expr>&amp;<name>buffer</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><name>path_apr</name></expr></argument>,
<argument><expr><name>APR_FILEPATH_NOTRELATIVE</name>
| <name>APR_FILEPATH_TRUENAME</name></expr></argument>,
<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>apr_err</name></expr>)</condition><then>
<return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_BAD_FILENAME</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr>"Couldn't determine absolute path of '%s'"</expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>relative</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_path_cstring_to_utf8</name><argument_list>(<argument><expr><name>pabsolute</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>pabsolute</name> = <call><name>svn_path_canonicalize</name><argument_list>(<argument><expr>*<name>pabsolute</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><name>svn_error_t</name> *</type>
<name>svn_path_split_if_file</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>pdirectory</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>pfile</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_finfo_t</name></type> <name>finfo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>
<expr_stmt><expr><name>err</name> = <call><name>svn_io_stat</name><argument_list>(<argument><expr>&amp;<name>finfo</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>APR_FINFO_TYPE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>err</name> &amp;&amp; ! <call><name>APR_STATUS_IS_ENOENT</name><argument_list>(<argument><expr><name><name>err</name>-&gt;<name>apr_err</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>err</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>err</name> || <name><name>finfo</name>.<name>filetype</name></name> == <name>APR_REG</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>svn_path_split</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pdirectory</name></expr></argument>, <argument><expr><name>pfile</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name><name>finfo</name>.<name>filetype</name></name> == <name>APR_DIR</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>pdirectory</name> = <name>path</name></expr>;</expr_stmt>
<expr_stmt><expr>*<name>pfile</name> = <name>SVN_EMPTY_PATH</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_BAD_FILENAME</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr>"'%s' is neither a file nor a directory name"</expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></else></if></else></if>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>const</specifier> <name>char</name> *</type>
<name>svn_path_canonicalize</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>canon</name></decl>, *<decl><type ref="prev"/><name>dst</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>src</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>seglen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>canon_segments</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>uri</name></decl>;</decl_stmt>
<expr_stmt><expr><name>dst</name> = <name>canon</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>src</name> = <call><name>skip_uri_scheme</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>src</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>uri</name> = <name>TRUE</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>src</name> - <name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dst</name> += (<name>src</name> - <name>path</name>)</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>uri</name> = <name>FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><name>src</name> = <name>path</name></expr>;</expr_stmt>
}</block></else></if>
<if>if <condition>(<expr>*<name>src</name> == '/'</expr>)</condition><then> <block>{
<expr_stmt><expr>*(<name>dst</name>++) = *(<name>src</name>++)</expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr>!<name>uri</name> &amp;&amp; *<name>src</name> == '/'</expr>)</condition><then>
<expr_stmt><expr>*(<name>dst</name>++) = *(<name>src</name>++)</expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></then></if>
<while>while <condition>(<expr>*<name>src</name></expr>)</condition> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>next</name> <init>= <expr><name>src</name></expr></init></decl>;</decl_stmt>
<while>while <condition>(<expr>*<name>next</name> &amp;&amp; (*<name>next</name> != '/')</expr>)</condition>
<expr_stmt><expr>++<name>next</name></expr>;</expr_stmt></while>
<expr_stmt><expr><name>seglen</name> = <name>next</name> - <name>src</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>seglen</name> == 0 || (<name>seglen</name> == 1 &amp;&amp; <name><name>src</name><index>[<expr>0</expr>]</index></name> == '.')</expr>)</condition><then> <block>{
}</block></then> <else>else <block>{
<if>if <condition>(<expr>*<name>next</name></expr>)</condition><then>
<expr_stmt><expr><name>seglen</name>++</expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>seglen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dst</name> += <name>seglen</name></expr>;</expr_stmt>
<expr_stmt><expr><name>canon_segments</name>++</expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><name>src</name> = <name>next</name></expr>;</expr_stmt>
<if>if <condition>(<expr>*<name>src</name></expr>)</condition><then>
<expr_stmt><expr><name>src</name>++</expr>;</expr_stmt></then></if>
}</block></while>
<if>if <condition>(<expr>(<name>canon_segments</name> &gt; 0 || <name>uri</name>) &amp;&amp; *(<name>dst</name> - 1) == '/'</expr>)</condition><then>
<expr_stmt><expr><name>dst</name>--</expr>;</expr_stmt></then></if>
<expr_stmt><expr>*<name>dst</name> = '\0'</expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
<if>if <condition>(<expr><name>canon_segments</name> &lt; 2 &amp;&amp; <name><name>canon</name><index>[<expr>0</expr>]</index></name> == '/' &amp;&amp; <name><name>canon</name><index>[<expr>1</expr>]</index></name> == '/'</expr>)</condition><then>
<return>return <expr><name>canon</name> + 1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<return>return <expr><name>canon</name></expr>;</return>
}</block></function>
<function><type><name>svn_boolean_t</name></type>
<name>svn_path_is_canonical</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<return>return <expr>(<call><name>strcmp</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>svn_path_canonicalize</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == 0)</expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>get_path_encoding</name><parameter_list>(<param><decl><type><name>svn_boolean_t</name> *</type><name>path_is_utf8</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_status_t</name></type> <name>apr_err</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>encoding_style</name></decl>;</decl_stmt>
<expr_stmt><expr><name>apr_err</name> = <call><name>apr_filepath_encoding</name><argument_list>(<argument><expr>&amp;<name>encoding_style</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>apr_err</name></expr>)</condition><then>
<return>return <expr><call><name>svn_error_wrap_apr</name><argument_list>(<argument><expr><name>apr_err</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't determine the native path encoding"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr>*<name>path_is_utf8</name> = (<name>encoding_style</name> == <name>APR_FILEPATH_ENCODING_UTF8</name>)</expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><name>svn_error_t</name> *</type>
<name>svn_path_cstring_from_utf8</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>path_apr</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path_utf8</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>path_is_utf8</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_path_encoding</name><argument_list>(<argument><expr>&amp;<name>path_is_utf8</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>path_is_utf8</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>path_apr</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>path_utf8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></then> <else>else
<return>return <expr><call><name>svn_utf_cstring_from_utf8</name><argument_list>(<argument><expr><name>path_apr</name></expr></argument>, <argument><expr><name>path_utf8</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>
<function><type><name>svn_error_t</name> *</type>
<name>svn_path_cstring_to_utf8</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>path_utf8</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path_apr</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>path_is_utf8</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_path_encoding</name><argument_list>(<argument><expr>&amp;<name>path_is_utf8</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>path_is_utf8</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>path_utf8</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>path_apr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></then> <else>else
<return>return <expr><call><name>svn_utf_cstring_to_utf8</name><argument_list>(<argument><expr><name>path_utf8</name></expr></argument>, <argument><expr><name>path_apr</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type>
<name>illegal_path_escape</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>retstr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>copied</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>
<expr_stmt><expr><name>retstr</name> = <call><name>svn_stringbuf_create</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name><name>path</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>) <block>{
<expr_stmt><expr><name>c</name> = (<name>unsigned</name> <name>char</name>)<name><name>path</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
<if>if <condition>(<expr>! <call><name>svn_ctype_iscntrl</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<continue>continue;</continue></then></if>
<if>if <condition>(<expr><name>i</name> - <name>copied</name></expr>)</condition><then>
<expr_stmt><expr><call><name>svn_stringbuf_appendbytes</name><argument_list>(<argument><expr><name>retstr</name></expr></argument>, <argument><expr><name>path</name> + <name>copied</name></expr></argument>,
<argument><expr><name>i</name> - <name>copied</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>svn_stringbuf_ensure</name><argument_list>(<argument><expr><name>retstr</name></expr></argument>, <argument><expr><name><name>retstr</name>-&gt;<name>len</name></name> + 4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name><name>retstr</name>-&gt;<name>data</name></name> + <name><name>retstr</name>-&gt;<name>len</name></name></expr></argument>, <argument><expr>"\\%03o"</expr></argument>, <argument><expr>(<name>unsigned</name> <name>char</name>)<name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>retstr</name>-&gt;<name>len</name></name> += 4</expr>;</expr_stmt>
<expr_stmt><expr><name>copied</name> = <name>i</name> + 1</expr>;</expr_stmt>
}</block></for>
<if>if <condition>(<expr><name><name>retstr</name>-&gt;<name>len</name></name> == 0</expr>)</condition><then>
<return>return <expr><name>path</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>i</name> - <name>copied</name></expr>)</condition><then>
<expr_stmt><expr><call><name>svn_stringbuf_appendbytes</name><argument_list>(<argument><expr><name>retstr</name></expr></argument>, <argument><expr><name>path</name> + <name>copied</name></expr></argument>, <argument><expr><name>i</name> - <name>copied</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return <expr><name><name>retstr</name>-&gt;<name>data</name></name></expr>;</return>
}</block></function>
<function><type><name>svn_error_t</name> *</type>
<name>svn_path_check_valid</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>c</name></decl>;</decl_stmt>
<for>for (<init><expr><name>c</name> = <name>path</name></expr>;</init> <condition><expr>*<name>c</name></expr>;</condition> <incr><expr><name>c</name>++</expr></incr>) <block>{
<if>if <condition>(<expr><call><name>svn_ctype_iscntrl</name><argument_list>(<argument><expr>*<name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<return>return <expr><call><name>svn_error_createf</name>
<argument_list>(<argument><expr><name>SVN_ERR_FS_PATH_SYNTAX</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr>"Invalid control character '0x%02x' in path '%s'"</expr></argument>)</argument_list></call></expr></argument>,
<argument><expr>*<name>c</name></expr></argument>,
<argument><expr><call><name>illegal_path_escape</name><argument_list>(<argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
}</block></for>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><name>void</name></type>
<name>svn_path_splitext</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>path_root</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>path_ext</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>last_dot</name></decl>, *<decl><type ref="prev"/><name>last_slash</name></decl>;</decl_stmt>
<if>if <condition>(<expr>! (<name>path_root</name> || <name>path_ext</name>)</expr>)</condition><then>
<return>return;</return></then></if>
<expr_stmt><expr><name>last_dot</name> = <call><name>strrchr</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>'.'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>last_dot</name> &amp;&amp; (<name>last_dot</name> + 1 != '\0')</expr>)</condition><then> <block>{
<expr_stmt><expr><name>last_slash</name> = <call><name>strrchr</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>'/'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>(<name>last_slash</name> &amp;&amp; (<name>last_dot</name> &gt; (<name>last_slash</name> + 1)))
|| ((! <name>last_slash</name>) &amp;&amp; (<name>last_dot</name> &gt; <name>path</name>))</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>path_root</name></expr>)</condition><then>
<expr_stmt><expr>*<name>path_root</name> = <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
<argument><expr>(<name>last_dot</name> - <name>path</name> + 1) * <sizeof>sizeof<argument_list>(<argument><expr>*<name>path</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>path_ext</name></expr>)</condition><then>
<expr_stmt><expr>*<name>path_ext</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>last_dot</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<return>return;</return>
}</block></then></if>
}</block></then></if>
<if>if <condition>(<expr><name>path_root</name></expr>)</condition><then>
<expr_stmt><expr>*<name>path_root</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>path_ext</name></expr>)</condition><then>
<expr_stmt><expr>*<name>path_ext</name> = ""</expr>;</expr_stmt></then></if>
}</block></function>
</unit>
