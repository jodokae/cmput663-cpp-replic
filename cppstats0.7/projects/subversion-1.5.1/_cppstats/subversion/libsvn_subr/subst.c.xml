<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="subversion/libsvn_subr/subst.c"><cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APR_WANT_STRFUNC</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_want.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_pools.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_tables.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_file_io.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_strings.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_cmdline.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_types.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_string.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_time.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_path.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_error.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_utf.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_io.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_subst.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_pools.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_private_config.h"</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_SUBST__DEFAULT_EOL_STR</name></cpp:macro> <cpp:value>"\n"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_SUBST__SPECIAL_LINK_STR</name></cpp:macro> <cpp:value>"link"</cpp:value></cpp:define>
<function><type><name>void</name></type>
<name>svn_subst_eol_style_from_value</name><parameter_list>(<param><decl><type><name>svn_subst_eol_style_t</name> *</type><name>style</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>eol</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>value</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name>value</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>eol</name> = <name>NULL</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>style</name></expr>)</condition><then>
<expr_stmt><expr>*<name>style</name> = <name>svn_subst_eol_style_none</name></expr>;</expr_stmt></then></if>
}</block></then> <else>else <if>if <condition>(<expr>! <call><name>strcmp</name><argument_list>(<argument><expr>"native"</expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>eol</name> = <name>APR_EOL_STR</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>style</name></expr>)</condition><then>
<expr_stmt><expr>*<name>style</name> = <name>svn_subst_eol_style_native</name></expr>;</expr_stmt></then></if>
}</block></then> <else>else <if>if <condition>(<expr>! <call><name>strcmp</name><argument_list>(<argument><expr>"LF"</expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>eol</name> = "\n"</expr>;</expr_stmt>
<if>if <condition>(<expr><name>style</name></expr>)</condition><then>
<expr_stmt><expr>*<name>style</name> = <name>svn_subst_eol_style_fixed</name></expr>;</expr_stmt></then></if>
}</block></then> <else>else <if>if <condition>(<expr>! <call><name>strcmp</name><argument_list>(<argument><expr>"CR"</expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>eol</name> = "\r"</expr>;</expr_stmt>
<if>if <condition>(<expr><name>style</name></expr>)</condition><then>
<expr_stmt><expr>*<name>style</name> = <name>svn_subst_eol_style_fixed</name></expr>;</expr_stmt></then></if>
}</block></then> <else>else <if>if <condition>(<expr>! <call><name>strcmp</name><argument_list>(<argument><expr>"CRLF"</expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>eol</name> = "\r\n"</expr>;</expr_stmt>
<if>if <condition>(<expr><name>style</name></expr>)</condition><then>
<expr_stmt><expr>*<name>style</name> = <name>svn_subst_eol_style_fixed</name></expr>;</expr_stmt></then></if>
}</block></then> <else>else <block>{
<expr_stmt><expr>*<name>eol</name> = <name>NULL</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>style</name></expr>)</condition><then>
<expr_stmt><expr>*<name>style</name> = <name>svn_subst_eol_style_unknown</name></expr>;</expr_stmt></then></if>
}</block></else></if></else></if></else></if></else></if></else></if>
}</block></function>
<function><type><name>svn_boolean_t</name></type>
<name>svn_subst_translation_required</name><parameter_list>(<param><decl><type><name>svn_subst_eol_style_t</name></type> <name>style</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>eol</name></decl></param>,
<param><decl><type><name>apr_hash_t</name> *</type><name>keywords</name></decl></param>,
<param><decl><type><name>svn_boolean_t</name></type> <name>special</name></decl></param>,
<param><decl><type><name>svn_boolean_t</name></type> <name>force_eol_check</name></decl></param>)</parameter_list> <block>{
<return>return <expr>(<name>special</name> || <name>keywords</name>
|| (<name>style</name> != <name>svn_subst_eol_style_none</name> &amp;&amp; <name>force_eol_check</name>)
|| (<name>style</name> == <name>svn_subst_eol_style_native</name> &amp;&amp;
<call><name>strcmp</name><argument_list>(<argument><expr><name>APR_EOL_STR</name></expr></argument>, <argument><expr><name>SVN_SUBST__DEFAULT_EOL_STR</name></expr></argument>)</argument_list></call> != 0)
|| (<name>style</name> == <name>svn_subst_eol_style_fixed</name> &amp;&amp;
<call><name>strcmp</name><argument_list>(<argument><expr><name>APR_EOL_STR</name></expr></argument>, <argument><expr><name>eol</name></expr></argument>)</argument_list></call> != 0))</expr>;</return>
}</block></function>
<function><type><name>svn_error_t</name> *</type>
<name>svn_subst_translate_to_normal_form</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>src</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dst</name></decl></param>,
<param><decl><type><name>svn_subst_eol_style_t</name></type> <name>eol_style</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>eol_str</name></decl></param>,
<param><decl><type><name>svn_boolean_t</name></type> <name>always_repair_eols</name></decl></param>,
<param><decl><type><name>apr_hash_t</name> *</type><name>keywords</name></decl></param>,
<param><decl><type><name>svn_boolean_t</name></type> <name>special</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name>eol_style</name> == <name>svn_subst_eol_style_native</name></expr>)</condition><then>
<expr_stmt><expr><name>eol_str</name> = <name>SVN_SUBST__DEFAULT_EOL_STR</name></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr>! (<name>eol_style</name> == <name>svn_subst_eol_style_fixed</name>
|| <name>eol_style</name> == <name>svn_subst_eol_style_none</name>)</expr>)</condition><then>
<return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_IO_UNKNOWN_EOL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></then></if></else></if>
<return>return <expr><call><name>svn_subst_copy_and_translate3</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>eol_str</name></expr></argument>,
<argument><expr><name>eol_style</name> == <name>svn_subst_eol_style_fixed</name>
|| <name>always_repair_eols</name></expr></argument>,
<argument><expr><name>keywords</name></expr></argument>,
<argument><expr><name>FALSE</name></expr></argument> ,
<argument><expr><name>special</name></expr></argument>,
<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>svn_error_t</name> *</type>
<name>svn_subst_stream_translated_to_normal_form</name><parameter_list>(<param><decl><type><name>svn_stream_t</name> **</type><name>stream</name></decl></param>,
<param><decl><type><name>svn_stream_t</name> *</type><name>source</name></decl></param>,
<param><decl><type><name>svn_subst_eol_style_t</name></type> <name>eol_style</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>eol_str</name></decl></param>,
<param><decl><type><name>svn_boolean_t</name></type> <name>always_repair_eols</name></decl></param>,
<param><decl><type><name>apr_hash_t</name> *</type><name>keywords</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr><name>eol_style</name> == <name>svn_subst_eol_style_native</name></expr>)</condition><then>
<expr_stmt><expr><name>eol_str</name> = <name>SVN_SUBST__DEFAULT_EOL_STR</name></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr>! (<name>eol_style</name> == <name>svn_subst_eol_style_fixed</name>
|| <name>eol_style</name> == <name>svn_subst_eol_style_none</name>)</expr>)</condition><then>
<return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_IO_UNKNOWN_EOL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></then></if></else></if>
<expr_stmt><expr>*<name>stream</name> = <call><name>svn_subst_stream_translated</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr><name>eol_str</name></expr></argument>,
<argument><expr><name>eol_style</name> == <name>svn_subst_eol_style_fixed</name>
|| <name>always_repair_eols</name></expr></argument>,
<argument><expr><name>keywords</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_string_t</name> *</type>
<name>keyword_printf</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fmt</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>rev</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>url</name></decl></param>,
<param><decl><type><name>apr_time_t</name></type> <name>date</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>author</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>value</name> <init>= <expr><call><name>svn_stringbuf_ncreate</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>cur</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
<for>for (<init>;</init><condition>;</condition><incr/>) <block>{
<expr_stmt><expr><name>cur</name> = <name>fmt</name></expr>;</expr_stmt>
<while>while <condition>(<expr>*<name>cur</name> != '\0' &amp;&amp; *<name>cur</name> != '%'</expr>)</condition>
<expr_stmt><expr><name>cur</name>++</expr>;</expr_stmt></while>
<if>if <condition>(<expr>(<name>n</name> = <name>cur</name> - <name>fmt</name>) &gt; 0</expr>)</condition><then>
<expr_stmt><expr><call><name>svn_stringbuf_appendbytes</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr>*<name>cur</name> == '\0'</expr>)</condition><then>
<break>break;</break></then></if>
<switch>switch <condition>(<expr><name><name>cur</name><index>[<expr>1</expr>]</index></name></expr>)</condition> <block>{
<case>case <expr>'a'</expr>:
<if>if <condition>(<expr><name>author</name></expr>)</condition><then>
<expr_stmt><expr><call><name>svn_stringbuf_appendcstr</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>author</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<break>break;</break>
</case><case>case <expr>'b'</expr>:
<if>if <condition>(<expr><name>url</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>base_name</name>
<init>= <expr><call><name>svn_path_uri_decode</name><argument_list>(<argument><expr><call><name>svn_path_basename</name><argument_list>(<argument><expr><name>url</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>svn_stringbuf_appendcstr</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>base_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<break>break;</break>
</case><case>case <expr>'d'</expr>:
<if>if <condition>(<expr><name>date</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>apr_time_exp_t</name></type> <name>exploded_time</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>human</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>apr_time_exp_gmt</name><argument_list>(<argument><expr>&amp;<name>exploded_time</name></expr></argument>, <argument><expr><name>date</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>human</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%04d-%02d-%02d %02d:%02d:%02dZ"</expr></argument>,
<argument><expr><name><name>exploded_time</name>.<name>tm_year</name></name> + 1900</expr></argument>,
<argument><expr><name><name>exploded_time</name>.<name>tm_mon</name></name> + 1</expr></argument>,
<argument><expr><name><name>exploded_time</name>.<name>tm_mday</name></name></expr></argument>,
<argument><expr><name><name>exploded_time</name>.<name>tm_hour</name></name></expr></argument>,
<argument><expr><name><name>exploded_time</name>.<name>tm_min</name></name></expr></argument>,
<argument><expr><name><name>exploded_time</name>.<name>tm_sec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>svn_stringbuf_appendcstr</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>human</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<break>break;</break>
</case><case>case <expr>'D'</expr>:
<if>if <condition>(<expr><name>date</name></expr>)</condition><then>
<expr_stmt><expr><call><name>svn_stringbuf_appendcstr</name><argument_list>(<argument><expr><name>value</name></expr></argument>,
<argument><expr><call><name>svn_time_to_human_cstring</name><argument_list>(<argument><expr><name>date</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<break>break;</break>
</case><case>case <expr>'r'</expr>:
<if>if <condition>(<expr><name>rev</name></expr>)</condition><then>
<expr_stmt><expr><call><name>svn_stringbuf_appendcstr</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>rev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<break>break;</break>
</case><case>case <expr>'u'</expr>:
<if>if <condition>(<expr><name>url</name></expr>)</condition><then>
<expr_stmt><expr><call><name>svn_stringbuf_appendcstr</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>url</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<break>break;</break>
</case><case>case <expr>'%'</expr>:
<expr_stmt><expr><call><name>svn_stringbuf_appendbytes</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'\0'</expr>:
<expr_stmt><expr><call><name>svn_stringbuf_appendbytes</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>cur</name>--</expr>;</expr_stmt>
<break>break;</break>
</case><default>default:
<expr_stmt><expr><call><name>svn_stringbuf_appendbytes</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>cur</name></expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</default>}</block></switch>
<expr_stmt><expr><name>fmt</name> = <name>cur</name> + 2</expr>;</expr_stmt>
}</block></for>
<return>return <expr><call><name>svn_string_create_from_buf</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>apr_hash_t</name> *</type>
<name>kwstruct_to_kwhash</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>svn_subst_keywords_t</name> *</type><name>kwstruct</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>kwhash</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>kwstruct</name> == <name>NULL</name></expr>)</condition><then>
<return>return <expr><name>NULL</name></expr>;</return></then></if>
<expr_stmt><expr><name>kwhash</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>kwstruct</name>-&gt;<name>revision</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>kwhash</name></expr></argument>, <argument><expr><name>SVN_KEYWORD_REVISION_LONG</name></expr></argument>,
<argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name><name>kwstruct</name>-&gt;<name>revision</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>kwhash</name></expr></argument>, <argument><expr><name>SVN_KEYWORD_REVISION_MEDIUM</name></expr></argument>,
<argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name><name>kwstruct</name>-&gt;<name>revision</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>kwhash</name></expr></argument>, <argument><expr><name>SVN_KEYWORD_REVISION_SHORT</name></expr></argument>,
<argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name><name>kwstruct</name>-&gt;<name>revision</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name><name>kwstruct</name>-&gt;<name>date</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>kwhash</name></expr></argument>, <argument><expr><name>SVN_KEYWORD_DATE_LONG</name></expr></argument>,
<argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name><name>kwstruct</name>-&gt;<name>date</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>kwhash</name></expr></argument>, <argument><expr><name>SVN_KEYWORD_DATE_SHORT</name></expr></argument>,
<argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name><name>kwstruct</name>-&gt;<name>date</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name><name>kwstruct</name>-&gt;<name>author</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>kwhash</name></expr></argument>, <argument><expr><name>SVN_KEYWORD_AUTHOR_LONG</name></expr></argument>,
<argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name><name>kwstruct</name>-&gt;<name>author</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>kwhash</name></expr></argument>, <argument><expr><name>SVN_KEYWORD_AUTHOR_SHORT</name></expr></argument>,
<argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name><name>kwstruct</name>-&gt;<name>author</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name><name>kwstruct</name>-&gt;<name>url</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>kwhash</name></expr></argument>, <argument><expr><name>SVN_KEYWORD_URL_LONG</name></expr></argument>,
<argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name><name>kwstruct</name>-&gt;<name>url</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>kwhash</name></expr></argument>, <argument><expr><name>SVN_KEYWORD_URL_SHORT</name></expr></argument>,
<argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name><name>kwstruct</name>-&gt;<name>url</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name><name>kwstruct</name>-&gt;<name>id</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>kwhash</name></expr></argument>, <argument><expr><name>SVN_KEYWORD_ID</name></expr></argument>,
<argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name><name>kwstruct</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>kwhash</name></expr>;</return>
}</block></function>
<function><type><name>svn_error_t</name> *</type>
<name>svn_subst_build_keywords</name><parameter_list>(<param><decl><type><name>svn_subst_keywords_t</name> *</type><name>kw</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>keywords_val</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>rev</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>url</name></decl></param>,
<param><decl><type><name>apr_time_t</name></type> <name>date</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>author</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>kwhash</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>val</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_subst_build_keywords2</name><argument_list>(<argument><expr>&amp;<name>kwhash</name></expr></argument>, <argument><expr><name>keywords_val</name></expr></argument>, <argument><expr><name>rev</name></expr></argument>,
<argument><expr><name>url</name></expr></argument>, <argument><expr><name>date</name></expr></argument>, <argument><expr><name>author</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>val</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>kwhash</name></expr></argument>, <argument><expr><name>SVN_KEYWORD_REVISION_LONG</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>val</name></expr>)</condition><then>
<expr_stmt><expr><name><name>kw</name>-&gt;<name>revision</name></name> = <name>val</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>val</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>kwhash</name></expr></argument>, <argument><expr><name>SVN_KEYWORD_DATE_LONG</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>val</name></expr>)</condition><then>
<expr_stmt><expr><name><name>kw</name>-&gt;<name>date</name></name> = <name>val</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>val</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>kwhash</name></expr></argument>, <argument><expr><name>SVN_KEYWORD_AUTHOR_LONG</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>val</name></expr>)</condition><then>
<expr_stmt><expr><name><name>kw</name>-&gt;<name>author</name></name> = <name>val</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>val</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>kwhash</name></expr></argument>, <argument><expr><name>SVN_KEYWORD_URL_LONG</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>val</name></expr>)</condition><then>
<expr_stmt><expr><name><name>kw</name>-&gt;<name>url</name></name> = <name>val</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>val</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>kwhash</name></expr></argument>, <argument><expr><name>SVN_KEYWORD_ID</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>val</name></expr>)</condition><then>
<expr_stmt><expr><name><name>kw</name>-&gt;<name>id</name></name> = <name>val</name></expr>;</expr_stmt></then></if>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><name>svn_error_t</name> *</type>
<name>svn_subst_build_keywords2</name><parameter_list>(<param><decl><type><name>apr_hash_t</name> **</type><name>kw</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>keywords_val</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>rev</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>url</name></decl></param>,
<param><decl><type><name>apr_time_t</name></type> <name>date</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>author</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>keyword_tokens</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
<expr_stmt><expr>*<name>kw</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>keyword_tokens</name> = <call><name>svn_cstring_split</name><argument_list>(<argument><expr><name>keywords_val</name></expr></argument>, <argument><expr>" \t\v\n\b\r\f"</expr></argument>,
<argument><expr><name>TRUE</name></expr></argument> , <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>keyword_tokens</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>) <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>keyword</name> <init>= <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>keyword_tokens</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>(! <call><name>strcmp</name><argument_list>(<argument><expr><name>keyword</name></expr></argument>, <argument><expr><name>SVN_KEYWORD_REVISION_LONG</name></expr></argument>)</argument_list></call>)
|| (! <call><name>strcmp</name><argument_list>(<argument><expr><name>keyword</name></expr></argument>, <argument><expr><name>SVN_KEYWORD_REVISION_MEDIUM</name></expr></argument>)</argument_list></call>)
|| (! <call><name>svn_cstring_casecmp</name><argument_list>(<argument><expr><name>keyword</name></expr></argument>, <argument><expr><name>SVN_KEYWORD_REVISION_SHORT</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>svn_string_t</name> *</type><name>revision_val</name></decl>;</decl_stmt>
<expr_stmt><expr><name>revision_val</name> = <call><name>keyword_printf</name><argument_list>(<argument><expr>"%r"</expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name>url</name></expr></argument>, <argument><expr><name>date</name></expr></argument>, <argument><expr><name>author</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr>*<name>kw</name></expr></argument>, <argument><expr><name>SVN_KEYWORD_REVISION_LONG</name></expr></argument>,
<argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>revision_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr>*<name>kw</name></expr></argument>, <argument><expr><name>SVN_KEYWORD_REVISION_MEDIUM</name></expr></argument>,
<argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>revision_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr>*<name>kw</name></expr></argument>, <argument><expr><name>SVN_KEYWORD_REVISION_SHORT</name></expr></argument>,
<argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>revision_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr>(! <call><name>strcmp</name><argument_list>(<argument><expr><name>keyword</name></expr></argument>, <argument><expr><name>SVN_KEYWORD_DATE_LONG</name></expr></argument>)</argument_list></call>)
|| (! <call><name>svn_cstring_casecmp</name><argument_list>(<argument><expr><name>keyword</name></expr></argument>, <argument><expr><name>SVN_KEYWORD_DATE_SHORT</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>svn_string_t</name> *</type><name>date_val</name></decl>;</decl_stmt>
<expr_stmt><expr><name>date_val</name> = <call><name>keyword_printf</name><argument_list>(<argument><expr>"%D"</expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name>url</name></expr></argument>, <argument><expr><name>date</name></expr></argument>, <argument><expr><name>author</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr>*<name>kw</name></expr></argument>, <argument><expr><name>SVN_KEYWORD_DATE_LONG</name></expr></argument>,
<argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>date_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr>*<name>kw</name></expr></argument>, <argument><expr><name>SVN_KEYWORD_DATE_SHORT</name></expr></argument>,
<argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>date_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr>(! <call><name>strcmp</name><argument_list>(<argument><expr><name>keyword</name></expr></argument>, <argument><expr><name>SVN_KEYWORD_AUTHOR_LONG</name></expr></argument>)</argument_list></call>)
|| (! <call><name>svn_cstring_casecmp</name><argument_list>(<argument><expr><name>keyword</name></expr></argument>, <argument><expr><name>SVN_KEYWORD_AUTHOR_SHORT</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>svn_string_t</name> *</type><name>author_val</name></decl>;</decl_stmt>
<expr_stmt><expr><name>author_val</name> = <call><name>keyword_printf</name><argument_list>(<argument><expr>"%a"</expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name>url</name></expr></argument>, <argument><expr><name>date</name></expr></argument>, <argument><expr><name>author</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr>*<name>kw</name></expr></argument>, <argument><expr><name>SVN_KEYWORD_AUTHOR_LONG</name></expr></argument>,
<argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>author_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr>*<name>kw</name></expr></argument>, <argument><expr><name>SVN_KEYWORD_AUTHOR_SHORT</name></expr></argument>,
<argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>author_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr>(! <call><name>strcmp</name><argument_list>(<argument><expr><name>keyword</name></expr></argument>, <argument><expr><name>SVN_KEYWORD_URL_LONG</name></expr></argument>)</argument_list></call>)
|| (! <call><name>svn_cstring_casecmp</name><argument_list>(<argument><expr><name>keyword</name></expr></argument>, <argument><expr><name>SVN_KEYWORD_URL_SHORT</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>svn_string_t</name> *</type><name>url_val</name></decl>;</decl_stmt>
<expr_stmt><expr><name>url_val</name> = <call><name>keyword_printf</name><argument_list>(<argument><expr>"%u"</expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name>url</name></expr></argument>, <argument><expr><name>date</name></expr></argument>, <argument><expr><name>author</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr>*<name>kw</name></expr></argument>, <argument><expr><name>SVN_KEYWORD_URL_LONG</name></expr></argument>,
<argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>url_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr>*<name>kw</name></expr></argument>, <argument><expr><name>SVN_KEYWORD_URL_SHORT</name></expr></argument>,
<argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>url_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr>(! <call><name>svn_cstring_casecmp</name><argument_list>(<argument><expr><name>keyword</name></expr></argument>, <argument><expr><name>SVN_KEYWORD_ID</name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>svn_string_t</name> *</type><name>id_val</name></decl>;</decl_stmt>
<expr_stmt><expr><name>id_val</name> = <call><name>keyword_printf</name><argument_list>(<argument><expr>"%b %r %d %a"</expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name>url</name></expr></argument>, <argument><expr><name>date</name></expr></argument>, <argument><expr><name>author</name></expr></argument>,
<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr>*<name>kw</name></expr></argument>, <argument><expr><name>SVN_KEYWORD_ID</name></expr></argument>,
<argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>id_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if></else></if></else></if></else></if></else></if>
}</block></for>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>translate_write</name><parameter_list>(<param><decl><type><name>svn_stream_t</name> *</type><name>stream</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>buf</name></decl></param>,
<param><decl><type><name>apr_size_t</name></type> <name>len</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>wrote</name> <init>= <expr><name>len</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_error_t</name> *</type><name>write_err</name> <init>= <expr><call><name>svn_stream_write</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr>&amp;<name>wrote</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>(<name>write_err</name>) || (<name>len</name> != <name>wrote</name>)</expr>)</condition><then>
<return>return <expr><name>write_err</name></expr>;</return></then></if>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_boolean_t</name></type>
<name>translate_keyword_subst</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>buf</name></decl></param>,
<param><decl><type><name>apr_size_t</name> *</type><name>len</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>keyword</name></decl></param>,
<param><decl><type><name>apr_size_t</name></type> <name>keyword_len</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>value</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>buf_ptr</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>*<name>len</name> &lt;= <name>SVN_KEYWORD_MAX_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>(<name><name>buf</name><index>[<expr>0</expr>]</index></name> == '$') &amp;&amp; (<name><name>buf</name><index>[<expr>*<name>len</name> - 1</expr>]</index></name> == '$')</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>*<name>len</name> &lt; <name>keyword_len</name> + 2</expr>)</condition><then>
<return>return <expr><name>FALSE</name></expr>;</return></then></if>
<if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>buf</name> + 1</expr></argument>, <argument><expr><name>keyword</name></expr></argument>, <argument><expr><name>keyword_len</name></expr></argument>)</argument_list></call></expr>)</condition><then>
<return>return <expr><name>FALSE</name></expr>;</return></then></if>
<expr_stmt><expr><name>buf_ptr</name> = <name>buf</name> + 1 + <name>keyword_len</name></expr>;</expr_stmt>
<if>if <condition>(<expr>(<name><name>buf_ptr</name><index>[<expr>0</expr>]</index></name> == ':')
&amp;&amp; (<name><name>buf_ptr</name><index>[<expr>1</expr>]</index></name> == ':')
&amp;&amp; (<name><name>buf_ptr</name><index>[<expr>2</expr>]</index></name> == ' ')
&amp;&amp; ((<name><name>buf</name><index>[<expr>*<name>len</name> - 2</expr>]</index></name> == ' ')
|| (<name><name>buf</name><index>[<expr>*<name>len</name> - 2</expr>]</index></name> == '#'))
&amp;&amp; ((6 + <name>keyword_len</name>) &lt; *<name>len</name>)</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>max_value_len</name> <init>= <expr>*<name>len</name> - (6 + <name>keyword_len</name>)</expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr>! <name>value</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>buf_ptr</name> += 2</expr>;</expr_stmt>
<while>while <condition>(<expr>*<name>buf_ptr</name> != '$'</expr>)</condition>
<expr_stmt><expr>*(<name>buf_ptr</name>++) = ' '</expr>;</expr_stmt></while>
}</block></then> <else>else <block>{
<if>if <condition>(<expr><name><name>value</name>-&gt;<name>len</name></name> &lt;= <name>max_value_len</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>buf_ptr</name> + 3</expr></argument>, <argument><expr><name><name>value</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>value</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>buf_ptr</name> += 3 + <name><name>value</name>-&gt;<name>len</name></name></expr>;</expr_stmt>
<while>while <condition>(<expr>*<name>buf_ptr</name> != '$'</expr>)</condition>
<expr_stmt><expr>*(<name>buf_ptr</name>++) = ' '</expr>;</expr_stmt></while>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>buf_ptr</name> + 3</expr></argument>, <argument><expr><name><name>value</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name>max_value_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr>*<name>len</name> - 2</expr>]</index></name> = '#'</expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf</name><index>[<expr>*<name>len</name> - 1</expr>]</index></name> = '$'</expr>;</expr_stmt>
}</block></else></if>
}</block></else></if>
<return>return <expr><name>TRUE</name></expr>;</return>
}</block></then>
<else>else <if>if <condition>(<expr><name><name>buf_ptr</name><index>[<expr>0</expr>]</index></name> == '$'</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>value</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>buf_ptr</name><index>[<expr>0</expr>]</index></name> = ':'</expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf_ptr</name><index>[<expr>1</expr>]</index></name> = ' '</expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>value</name>-&gt;<name>len</name></name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>vallen</name> <init>= <expr><name><name>value</name>-&gt;<name>len</name></name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>vallen</name> &gt; (<name>SVN_KEYWORD_MAX_LEN</name> - 5 - <name>keyword_len</name>)</expr>)</condition><then>
<expr_stmt><expr><name>vallen</name> = <name>SVN_KEYWORD_MAX_LEN</name> - 5 - <name>keyword_len</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>buf_ptr</name> + 2</expr></argument>, <argument><expr><name><name>value</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name>vallen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf_ptr</name><index>[<expr>2 + <name>vallen</name></expr>]</index></name> = ' '</expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf_ptr</name><index>[<expr>2 + <name>vallen</name> + 1</expr>]</index></name> = '$'</expr>;</expr_stmt>
<expr_stmt><expr>*<name>len</name> = 5 + <name>keyword_len</name> + <name>vallen</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name><name>buf_ptr</name><index>[<expr>2</expr>]</index></name> = '$'</expr>;</expr_stmt>
<expr_stmt><expr>*<name>len</name> = 4 + <name>keyword_len</name></expr>;</expr_stmt>
}</block></else></if>
}</block></then> <else>else <block>{
}</block></else></if>
<return>return <expr><name>TRUE</name></expr>;</return>
}</block></then>
<else>else <if>if <condition>(<expr>((*<name>len</name> &gt;= 4 + <name>keyword_len</name> )
&amp;&amp; (<name><name>buf_ptr</name><index>[<expr>0</expr>]</index></name> == ':')
&amp;&amp; (<name><name>buf_ptr</name><index>[<expr>1</expr>]</index></name> == ' ')
&amp;&amp; (<name><name>buf</name><index>[<expr>*<name>len</name> - 2</expr>]</index></name> == ' '))
|| ((*<name>len</name> &gt;= 3 + <name>keyword_len</name> )
&amp;&amp; (<name><name>buf_ptr</name><index>[<expr>0</expr>]</index></name> == ':')
&amp;&amp; (<name><name>buf_ptr</name><index>[<expr>1</expr>]</index></name> == '$'))</expr>)</condition><then> <block>{
<if>if <condition>(<expr>! <name>value</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>buf_ptr</name><index>[<expr>0</expr>]</index></name> = '$'</expr>;</expr_stmt>
<expr_stmt><expr>*<name>len</name> = 2 + <name>keyword_len</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name><name>buf_ptr</name><index>[<expr>0</expr>]</index></name> = ':'</expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf_ptr</name><index>[<expr>1</expr>]</index></name> = ' '</expr>;</expr_stmt>
<if>if <condition>(<expr><name><name>value</name>-&gt;<name>len</name></name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>vallen</name> <init>= <expr><name><name>value</name>-&gt;<name>len</name></name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>vallen</name> &gt; (<name>SVN_KEYWORD_MAX_LEN</name> - 5)</expr>)</condition><then>
<expr_stmt><expr><name>vallen</name> = <name>SVN_KEYWORD_MAX_LEN</name> - 5</expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>buf_ptr</name> + 2</expr></argument>, <argument><expr><name><name>value</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name>vallen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf_ptr</name><index>[<expr>2 + <name>vallen</name></expr>]</index></name> = ' '</expr>;</expr_stmt>
<expr_stmt><expr><name><name>buf_ptr</name><index>[<expr>2 + <name>vallen</name> + 1</expr>]</index></name> = '$'</expr>;</expr_stmt>
<expr_stmt><expr>*<name>len</name> = 5 + <name>keyword_len</name> + <name>vallen</name></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><name><name>buf_ptr</name><index>[<expr>2</expr>]</index></name> = '$'</expr>;</expr_stmt>
<expr_stmt><expr>*<name>len</name> = 4 + <name>keyword_len</name></expr>;</expr_stmt>
}</block></else></if>
}</block></else></if>
<return>return <expr><name>TRUE</name></expr>;</return>
}</block></then></if></else></if></else></if>
<return>return <expr><name>FALSE</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_boolean_t</name></type>
<name>match_keyword</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>buf</name></decl></param>,
<param><decl><type><name>apr_size_t</name></type> <name>len</name></decl></param>,
<param><decl><type><name>char</name> *</type><name>keyword_name</name></decl></param>,
<param><decl><type><name>apr_hash_t</name> *</type><name>keywords</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>i</name></decl>;</decl_stmt>
<if>if <condition>(<expr>! <name>keywords</name></expr>)</condition><then>
<return>return <expr><name>FALSE</name></expr>;</return></then></if>
<for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>len</name> - 2 &amp;&amp; <name><name>buf</name><index>[<expr><name>i</name> + 1</expr>]</index></name> != ':'</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
<expr_stmt><expr><name><name>keyword_name</name><index>[<expr><name>i</name></expr>]</index></name> = <name><name>buf</name><index>[<expr><name>i</name> + 1</expr>]</index></name></expr>;</expr_stmt></for>
<expr_stmt><expr><name><name>keyword_name</name><index>[<expr><name>i</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
<return>return <expr><call><name>apr_hash_get</name><argument_list>(<argument><expr><name>keywords</name></expr></argument>, <argument><expr><name>keyword_name</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call> != <name>NULL</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_boolean_t</name></type>
<name>translate_keyword</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>buf</name></decl></param>,
<param><decl><type><name>apr_size_t</name> *</type><name>len</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>keyword_name</name></decl></param>,
<param><decl><type><name>svn_boolean_t</name></type> <name>expand</name></decl></param>,
<param><decl><type><name>apr_hash_t</name> *</type><name>keywords</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>value</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>*<name>len</name> &lt;= <name>SVN_KEYWORD_MAX_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>(<name><name>buf</name><index>[<expr>0</expr>]</index></name> == '$') &amp;&amp; (<name><name>buf</name><index>[<expr>*<name>len</name> - 1</expr>]</index></name> == '$')</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>! <name>keywords</name></expr>)</condition><then>
<return>return <expr><name>FALSE</name></expr>;</return></then></if>
<expr_stmt><expr><name>value</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>keywords</name></expr></argument>, <argument><expr><name>keyword_name</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>value</name></expr>)</condition><then> <block>{
<return>return <expr><call><name>translate_keyword_subst</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>,
<argument><expr><name>keyword_name</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>keyword_name</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>expand</name> ? <name>value</name> : <name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></then></if>
<return>return <expr><name>FALSE</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>translate_newline</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>eol_str</name></decl></param>,
<param><decl><type><name>apr_size_t</name></type> <name>eol_str_len</name></decl></param>,
<param><decl><type><name>char</name> *</type><name>src_format</name></decl></param>,
<param><decl><type><name>apr_size_t</name> *</type><name>src_format_len</name></decl></param>,
<param><decl><type><name>char</name> *</type><name>newline_buf</name></decl></param>,
<param><decl><type><name>apr_size_t</name></type> <name>newline_len</name></decl></param>,
<param><decl><type><name>svn_stream_t</name> *</type><name>dst</name></decl></param>,
<param><decl><type><name>svn_boolean_t</name></type> <name>repair</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr>*<name>src_format_len</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>(! <name>repair</name>) &amp;&amp;
((*<name>src_format_len</name> != <name>newline_len</name>) ||
(<call><name>strncmp</name><argument_list>(<argument><expr><name>src_format</name></expr></argument>, <argument><expr><name>newline_buf</name></expr></argument>, <argument><expr><name>newline_len</name></expr></argument>)</argument_list></call>))</expr>)</condition><then>
<return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_IO_INCONSISTENT_EOL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>src_format</name></expr></argument>, <argument><expr><name>newline_buf</name></expr></argument>, <argument><expr><name>newline_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>src_format_len</name> = <name>newline_len</name></expr>;</expr_stmt>
}</block></else></if>
<return>return <expr><call><name>translate_write</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>eol_str</name></expr></argument>, <argument><expr><name>eol_str_len</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>svn_boolean_t</name></type>
<name>svn_subst_keywords_differ</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>svn_subst_keywords_t</name> *</type><name>a</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>svn_subst_keywords_t</name> *</type><name>b</name></decl></param>,
<param><decl><type><name>svn_boolean_t</name></type> <name>compare_values</name></decl></param>)</parameter_list> <block>{
<if>if <condition>(<expr>((<name>a</name> == <name>NULL</name>) &amp;&amp; (<name>b</name> == <name>NULL</name>))
|| ((<name>a</name> == <name>NULL</name>)
&amp;&amp; (<name><name>b</name>-&gt;<name>revision</name></name> == <name>NULL</name>)
&amp;&amp; (<name><name>b</name>-&gt;<name>date</name></name> == <name>NULL</name>)
&amp;&amp; (<name><name>b</name>-&gt;<name>author</name></name> == <name>NULL</name>)
&amp;&amp; (<name><name>b</name>-&gt;<name>url</name></name> == <name>NULL</name>))
|| ((<name>b</name> == <name>NULL</name>) &amp;&amp; (<name><name>a</name>-&gt;<name>revision</name></name> == <name>NULL</name>)
&amp;&amp; (<name><name>a</name>-&gt;<name>date</name></name> == <name>NULL</name>)
&amp;&amp; (<name><name>a</name>-&gt;<name>author</name></name> == <name>NULL</name>)
&amp;&amp; (<name><name>a</name>-&gt;<name>url</name></name> == <name>NULL</name>))
|| ((<name>a</name> != <name>NULL</name>) &amp;&amp; (<name>b</name> != <name>NULL</name>)
&amp;&amp; (<name><name>b</name>-&gt;<name>revision</name></name> == <name>NULL</name>)
&amp;&amp; (<name><name>b</name>-&gt;<name>date</name></name> == <name>NULL</name>)
&amp;&amp; (<name><name>b</name>-&gt;<name>author</name></name> == <name>NULL</name>)
&amp;&amp; (<name><name>b</name>-&gt;<name>url</name></name> == <name>NULL</name>)
&amp;&amp; (<name><name>a</name>-&gt;<name>revision</name></name> == <name>NULL</name>)
&amp;&amp; (<name><name>a</name>-&gt;<name>date</name></name> == <name>NULL</name>)
&amp;&amp; (<name><name>a</name>-&gt;<name>author</name></name> == <name>NULL</name>)
&amp;&amp; (<name><name>a</name>-&gt;<name>url</name></name> == <name>NULL</name>))</expr>)</condition><then> <block>{
<return>return <expr><name>FALSE</name></expr>;</return>
}</block></then> <else>else <if>if <condition>(<expr>(<name>a</name> == <name>NULL</name>) || (<name>b</name> == <name>NULL</name>)</expr>)</condition><then>
<return>return <expr><name>TRUE</name></expr>;</return></then></if></else></if>
<if>if <condition>(<expr>(! <name><name>a</name>-&gt;<name>revision</name></name>) != (! <name><name>b</name>-&gt;<name>revision</name></name>)</expr>)</condition><then>
<return>return <expr><name>TRUE</name></expr>;</return></then>
<else>else <if>if <condition>(<expr>(<name>compare_values</name> &amp;&amp; (<name><name>a</name>-&gt;<name>revision</name></name> != <name>NULL</name>))
&amp;&amp; (<call><name>strcmp</name><argument_list>(<argument><expr><name><name>a</name>-&gt;<name>revision</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>revision</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call> != 0)</expr>)</condition><then>
<return>return <expr><name>TRUE</name></expr>;</return></then></if></else></if>
<if>if <condition>(<expr>(! <name><name>a</name>-&gt;<name>date</name></name>) != (! <name><name>b</name>-&gt;<name>date</name></name>)</expr>)</condition><then>
<return>return <expr><name>TRUE</name></expr>;</return></then>
<else>else <if>if <condition>(<expr>(<name>compare_values</name> &amp;&amp; (<name><name>a</name>-&gt;<name>date</name></name> != <name>NULL</name>))
&amp;&amp; (<call><name>strcmp</name><argument_list>(<argument><expr><name><name>a</name>-&gt;<name>date</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>date</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call> != 0)</expr>)</condition><then>
<return>return <expr><name>TRUE</name></expr>;</return></then></if></else></if>
<if>if <condition>(<expr>(! <name><name>a</name>-&gt;<name>author</name></name>) != (! <name><name>b</name>-&gt;<name>author</name></name>)</expr>)</condition><then>
<return>return <expr><name>TRUE</name></expr>;</return></then>
<else>else <if>if <condition>(<expr>(<name>compare_values</name> &amp;&amp; (<name><name>a</name>-&gt;<name>author</name></name> != <name>NULL</name>))
&amp;&amp; (<call><name>strcmp</name><argument_list>(<argument><expr><name><name>a</name>-&gt;<name>author</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>author</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call> != 0)</expr>)</condition><then>
<return>return <expr><name>TRUE</name></expr>;</return></then></if></else></if>
<if>if <condition>(<expr>(! <name><name>a</name>-&gt;<name>url</name></name>) != (! <name><name>b</name>-&gt;<name>url</name></name>)</expr>)</condition><then>
<return>return <expr><name>TRUE</name></expr>;</return></then>
<else>else <if>if <condition>(<expr>(<name>compare_values</name> &amp;&amp; (<name><name>a</name>-&gt;<name>url</name></name> != <name>NULL</name>))
&amp;&amp; (<call><name>strcmp</name><argument_list>(<argument><expr><name><name>a</name>-&gt;<name>url</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>url</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call> != 0)</expr>)</condition><then>
<return>return <expr><name>TRUE</name></expr>;</return></then></if></else></if>
<return>return <expr><name>FALSE</name></expr>;</return>
}</block></function>
<function><type><name>svn_boolean_t</name></type>
<name>svn_subst_keywords_differ2</name><parameter_list>(<param><decl><type><name>apr_hash_t</name> *</type><name>a</name></decl></param>,
<param><decl><type><name>apr_hash_t</name> *</type><name>b</name></decl></param>,
<param><decl><type><name>svn_boolean_t</name></type> <name>compare_values</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>a_count</name></decl>, <decl><type ref="prev"/><name>b_count</name></decl>;</decl_stmt>
<expr_stmt><expr><name>a_count</name> = (<name>a</name> == <name>NULL</name>) ? 0 : <call><name>apr_hash_count</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>b_count</name> = (<name>b</name> == <name>NULL</name>) ? 0 : <call><name>apr_hash_count</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>a_count</name> != <name>b_count</name></expr>)</condition><then>
<return>return <expr><name>TRUE</name></expr>;</return></then></if>
<if>if <condition>(<expr><name>a_count</name> == 0</expr>)</condition><then>
<return>return <expr><name>FALSE</name></expr>;</return></then></if>
<for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>hi</name></expr>;</condition> <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>) <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_ssize_t</name></type> <name>klen</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> *</type><name>void_a_val</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_string_t</name> *</type><name>a_val</name></decl>, *<decl><type ref="prev"/><name>b_val</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr>&amp;<name>klen</name></expr></argument>, <argument><expr>&amp;<name>void_a_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>a_val</name> = <name>void_a_val</name></expr>;</expr_stmt>
<expr_stmt><expr><name>b_val</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>klen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>!<name>b_val</name> || (<name>compare_values</name> &amp;&amp; !<call><name>svn_string_compare</name><argument_list>(<argument><expr><name>a_val</name></expr></argument>, <argument><expr><name>b_val</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
<return>return <expr><name>TRUE</name></expr>;</return></then></if>
}</block></for>
<return>return <expr><name>FALSE</name></expr>;</return>
}</block></function>
<function><type><name>svn_error_t</name> *</type>
<name>svn_subst_translate_stream2</name><parameter_list>(<param><decl><type><name>svn_stream_t</name> *</type><name>s</name></decl></param>,
<param><decl><type><name>svn_stream_t</name> *</type><name>d</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>eol_str</name></decl></param>,
<param><decl><type><name>svn_boolean_t</name></type> <name>repair</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>svn_subst_keywords_t</name> *</type><name>keywords</name></decl></param>,
<param><decl><type><name>svn_boolean_t</name></type> <name>expand</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>kh</name> <init>= <expr><call><name>kwstruct_to_kwhash</name><argument_list>(<argument><expr><name>keywords</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>svn_subst_translate_stream3</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>eol_str</name></expr></argument>, <argument><expr><name>repair</name></expr></argument>, <argument><expr><name>kh</name></expr></argument>, <argument><expr><name>expand</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<struct>struct <name>translation_baton</name> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>eol_str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>repair</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>keywords</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>expand</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>interesting</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>eol_str_len</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>newline_buf</name><index>[<expr>2</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>newline_off</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>keyword_buf</name><index>[<expr><name>SVN_KEYWORD_MAX_LEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>keyword_off</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>src_format</name><index>[<expr>2</expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>src_format_len</name></decl>;</decl_stmt>
}</block>;</struct>
<function><type><specifier>static</specifier> struct <name>translation_baton</name> *</type>
<name>create_translation_baton</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>eol_str</name></decl></param>,
<param><decl><type><name>svn_boolean_t</name></type> <name>repair</name></decl></param>,
<param><decl><type><name>apr_hash_t</name> *</type><name>keywords</name></decl></param>,
<param><decl><type><name>svn_boolean_t</name></type> <name>expand</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>translation_baton</name> *</type><name>b</name> <init>= <expr><call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>b</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>keywords</name> &amp;&amp; (<call><name>apr_hash_count</name><argument_list>(<argument><expr><name>keywords</name></expr></argument>)</argument_list></call> == 0)</expr>)</condition><then>
<expr_stmt><expr><name>keywords</name> = <name>NULL</name></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name><name>b</name>-&gt;<name>eol_str</name></name> = <name>eol_str</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name>-&gt;<name>eol_str_len</name></name> = <name>eol_str</name> ? <call><name>strlen</name><argument_list>(<argument><expr><name>eol_str</name></expr></argument>)</argument_list></call> : 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name>-&gt;<name>repair</name></name> = <name>repair</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name>-&gt;<name>keywords</name></name> = <name>keywords</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name>-&gt;<name>expand</name></name> = <name>expand</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name>-&gt;<name>interesting</name></name> = (<name>eol_str</name> &amp;&amp; <name>keywords</name>) ? "$\r\n" : <name>eol_str</name> ? "\r\n" : "$"</expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name>-&gt;<name>newline_off</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name>-&gt;<name>keyword_off</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name>-&gt;<name>src_format_len</name></name> = 0</expr>;</expr_stmt>
<return>return <expr><name>b</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>translate_chunk</name><parameter_list>(<param><decl><type><name>svn_stream_t</name> *</type><name>dst</name></decl></param>,
<param><decl><type>struct <name>translation_baton</name> *</type><name>b</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>buf</name></decl></param>,
<param><decl><type><name>apr_size_t</name></type> <name>buflen</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>buf</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>end</name> <init>= <expr><name>buf</name> + <name>buflen</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>interesting</name> <init>= <expr><name><name>b</name>-&gt;<name>interesting</name></name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>next_sign_off</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<for>for (<init><expr><name>p</name> = <name>buf</name></expr>;</init> <condition><expr><name>p</name> &lt; <name>end</name></expr>;</condition><incr/>) <block>{
<if>if <condition>(<expr><name><name>b</name>-&gt;<name>newline_off</name></name></expr>)</condition><then> <block>{
<if>if <condition>(<expr>*<name>p</name> == '\n'</expr>)</condition><then>
<expr_stmt><expr><name><name>b</name>-&gt;<name>newline_buf</name><index>[<expr><name><name>b</name>-&gt;<name>newline_off</name></name>++</expr>]</index></name> = *<name>p</name>++</expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>translate_newline</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>eol_str</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>eol_str_len</name></name></expr></argument>,
<argument><expr><name><name>b</name>-&gt;<name>src_format</name></name></expr></argument>,
<argument><expr>&amp;<name><name>b</name>-&gt;<name>src_format_len</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>newline_buf</name></name></expr></argument>,
<argument><expr><name><name>b</name>-&gt;<name>newline_off</name></name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>repair</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name>-&gt;<name>newline_off</name></name> = 0</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name><name>b</name>-&gt;<name>keyword_off</name></name> &amp;&amp; *<name>p</name> == '$'</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>keyword_matches</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name></type> <name><name>keyword_name</name><index>[<expr><name>SVN_KEYWORD_MAX_LEN</name> + 1</expr>]</index></name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>b</name>-&gt;<name>keyword_buf</name><index>[<expr><name><name>b</name>-&gt;<name>keyword_off</name></name>++</expr>]</index></name> = *<name>p</name>++</expr>;</expr_stmt>
<expr_stmt><expr><name>keyword_matches</name> = <call><name>match_keyword</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>keyword_buf</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>keyword_off</name></name></expr></argument>,
<argument><expr><name>keyword_name</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>keywords</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>keyword_matches</name> == <name>FALSE</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>p</name>--</expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name>-&gt;<name>keyword_off</name></name>--</expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name>keyword_matches</name> == <name>FALSE</name> ||
<call><name>translate_keyword</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>keyword_buf</name></name></expr></argument>, <argument><expr>&amp;<name><name>b</name>-&gt;<name>keyword_off</name></name></expr></argument>,
<argument><expr><name>keyword_name</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>expand</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>keywords</name></name></expr></argument>)</argument_list></call> ||
<name><name>b</name>-&gt;<name>keyword_off</name></name> &gt;= <name>SVN_KEYWORD_MAX_LEN</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>translate_write</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>keyword_buf</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>keyword_off</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>next_sign_off</name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name>-&gt;<name>keyword_off</name></name> = 0</expr>;</expr_stmt>
}</block></then> <else>else <block>{
<if>if <condition>(<expr><name>next_sign_off</name> == 0</expr>)</condition><then>
<expr_stmt><expr><name>next_sign_off</name> = <name><name>b</name>-&gt;<name>keyword_off</name></name> - 1</expr>;</expr_stmt></then></if>
<continue>continue;</continue>
}</block></else></if>
}</block></then> <else>else <if>if <condition>(<expr><name><name>b</name>-&gt;<name>keyword_off</name></name> == <name>SVN_KEYWORD_MAX_LEN</name> - 1
|| (<name><name>b</name>-&gt;<name>keyword_off</name></name> &amp;&amp; (*<name>p</name> == '\r' || *<name>p</name> == '\n'))</expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>next_sign_off</name> &gt; 0</expr>)</condition><then> <block>{
<expr_stmt><expr><name>p</name> -= (<name><name>b</name>-&gt;<name>keyword_off</name></name> - <name>next_sign_off</name>)</expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name>-&gt;<name>keyword_off</name></name> = <name>next_sign_off</name></expr>;</expr_stmt>
<expr_stmt><expr><name>next_sign_off</name> = 0</expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>translate_write</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>keyword_buf</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>keyword_off</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name>-&gt;<name>keyword_off</name></name> = 0</expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name><name>b</name>-&gt;<name>keyword_off</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><name><name>b</name>-&gt;<name>keyword_buf</name><index>[<expr><name><name>b</name>-&gt;<name>keyword_off</name></name>++</expr>]</index></name> = *<name>p</name>++</expr>;</expr_stmt>
<continue>continue;</continue>
}</block></then></if></else></if></else></if></else></if>
<expr_stmt><expr><name>len</name> = 0</expr>;</expr_stmt>
<while>while <condition>(<expr>(<name>p</name> + <name>len</name>) &lt; <name>end</name>
&amp;&amp; (! <name><name>p</name><index>[<expr><name>len</name></expr>]</index></name> || ! <call><name>strchr</name><argument_list>(<argument><expr><name>interesting</name></expr></argument>, <argument><expr><name><name>p</name><index>[<expr><name>len</name></expr>]</index></name></expr></argument>)</argument_list></call>)</expr>)</condition>
<expr_stmt><expr><name>len</name>++</expr>;</expr_stmt></while>
<if>if <condition>(<expr><name>len</name></expr>)</condition><then>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>translate_write</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><name>p</name> += <name>len</name></expr>;</expr_stmt>
<if>if <condition>(<expr><name>p</name> &lt; <name>end</name></expr>)</condition><then> <block>{
<switch>switch <condition>(<expr>*<name>p</name></expr>)</condition> <block>{
<case>case <expr>'$'</expr>:
<expr_stmt><expr><name><name>b</name>-&gt;<name>keyword_buf</name><index>[<expr><name><name>b</name>-&gt;<name>keyword_off</name></name>++</expr>]</index></name> = *<name>p</name>++</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'\r'</expr>:
<expr_stmt><expr><name><name>b</name>-&gt;<name>newline_buf</name><index>[<expr><name><name>b</name>-&gt;<name>newline_off</name></name>++</expr>]</index></name> = *<name>p</name>++</expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr>'\n'</expr>:
<expr_stmt><expr><name><name>b</name>-&gt;<name>newline_buf</name><index>[<expr><name><name>b</name>-&gt;<name>newline_off</name></name>++</expr>]</index></name> = *<name>p</name>++</expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>translate_newline</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>eol_str</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>eol_str_len</name></name></expr></argument>,
<argument><expr><name><name>b</name>-&gt;<name>src_format</name></name></expr></argument>,
<argument><expr>&amp;<name><name>b</name>-&gt;<name>src_format_len</name></name></expr></argument>,
<argument><expr><name><name>b</name>-&gt;<name>newline_buf</name></name></expr></argument>,
<argument><expr><name><name>b</name>-&gt;<name>newline_off</name></name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>repair</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name>-&gt;<name>newline_off</name></name> = 0</expr>;</expr_stmt>
<break>break;</break>
</case>}</block></switch>
}</block></then></if>
}</block></for>
}</block></then> <else>else <block>{
<if>if <condition>(<expr><name><name>b</name>-&gt;<name>newline_off</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>translate_newline</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>eol_str</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>eol_str_len</name></name></expr></argument>,
<argument><expr><name><name>b</name>-&gt;<name>src_format</name></name></expr></argument>, <argument><expr>&amp;<name><name>b</name>-&gt;<name>src_format_len</name></name></expr></argument>,
<argument><expr><name><name>b</name>-&gt;<name>newline_buf</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>newline_off</name></name></expr></argument>,
<argument><expr><name>dst</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>repair</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name>-&gt;<name>newline_off</name></name> = 0</expr>;</expr_stmt>
}</block></then></if>
<if>if <condition>(<expr><name><name>b</name>-&gt;<name>keyword_off</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>translate_write</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>keyword_buf</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>keyword_off</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name>-&gt;<name>keyword_off</name></name> = 0</expr>;</expr_stmt>
}</block></then></if>
}</block></else></if>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<struct>struct <name>translated_stream_baton</name> <block>{
<decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>stream</name></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>translation_baton</name> *</type><name>in_baton</name></decl>, *<decl><type ref="prev"/><name>out_baton</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>written</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>readbuf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>readbuf_off</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>iterpool</name></decl>;</decl_stmt>
}</block>;</struct>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>translated_stream_read</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>,
<param><decl><type><name>char</name> *</type><name>buffer</name></decl></param>,
<param><decl><type><name>apr_size_t</name> *</type><name>len</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>translated_stream_baton</name> *</type><name>b</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>readlen</name> <init>= <expr><name>SVN__STREAM_CHUNK_SIZE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>unsatisfied</name> <init>= <expr>*<name>len</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>off</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>iterpool</name></decl>;</decl_stmt>
<expr_stmt><expr><name>iterpool</name> = <name><name>b</name>-&gt;<name>iterpool</name></name></expr>;</expr_stmt>
<while>while <condition>(<expr><name>readlen</name> == <name>SVN__STREAM_CHUNK_SIZE</name> &amp;&amp; <name>unsatisfied</name> &gt; 0</expr>)</condition> <block>{
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>to_copy</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>buffer_remainder</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>! (<name><name>b</name>-&gt;<name>readbuf_off</name></name> &lt; <name><name>b</name>-&gt;<name>readbuf</name>-&gt;<name>len</name></name>)</expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>buf_stream</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>svn_stringbuf_setempty</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>readbuf</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name>-&gt;<name>readbuf_off</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_read</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>stream</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>buf</name></name></expr></argument>, <argument><expr>&amp;<name>readlen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>buf_stream</name> = <call><name>svn_stream_from_stringbuf</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>readbuf</name></name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>translate_chunk</name><argument_list>(<argument><expr><name>buf_stream</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>in_baton</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>buf</name></name></expr></argument>,
<argument><expr><name>readlen</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>readlen</name> != <name>SVN__STREAM_CHUNK_SIZE</name></expr>)</condition><then>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>translate_chunk</name><argument_list>(<argument><expr><name>buf_stream</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>in_baton</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>,
<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_close</name><argument_list>(<argument><expr><name>buf_stream</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name>buffer_remainder</name> = <name><name>b</name>-&gt;<name>readbuf</name>-&gt;<name>len</name></name> - <name><name>b</name>-&gt;<name>readbuf_off</name></name></expr>;</expr_stmt>
<expr_stmt><expr><name>to_copy</name> = (<name>buffer_remainder</name> &gt; <name>unsatisfied</name>)
? <name>unsatisfied</name> : <name>buffer_remainder</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buffer</name> + <name>off</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>readbuf</name>-&gt;<name>data</name></name> + <name><name>b</name>-&gt;<name>readbuf_off</name></name></expr></argument>, <argument><expr><name>to_copy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>off</name> += <name>to_copy</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name>-&gt;<name>readbuf_off</name></name> += <name>to_copy</name></expr>;</expr_stmt>
<expr_stmt><expr><name>unsatisfied</name> -= <name>to_copy</name></expr>;</expr_stmt>
}</block></while>
<expr_stmt><expr>*<name>len</name> -= <name>unsatisfied</name></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>translated_stream_write</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>buffer</name></decl></param>,
<param><decl><type><name>apr_size_t</name> *</type><name>len</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>translated_stream_baton</name> *</type><name>b</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>iterpool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>b</name>-&gt;<name>written</name></name> = <name>TRUE</name></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>translate_chunk</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>stream</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>out_baton</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr>*<name>len</name></expr></argument>,
<argument><expr><name><name>b</name>-&gt;<name>iterpool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>translated_stream_close</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>translated_stream_baton</name> *</type><name>b</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>b</name>-&gt;<name>written</name></name></expr>)</condition><then>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>translate_chunk</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>stream</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>out_baton</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>iterpool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_close</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>stream</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>detranslated_stream_special</name><parameter_list>(<param><decl><type><name>svn_stream_t</name> **</type><name>translated_stream_p</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>src</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_finfo_t</name></type> <name>finfo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_file_t</name> *</type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_string_t</name> *</type><name>buf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>strbuf</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_stat</name><argument_list>(<argument><expr>&amp;<name>finfo</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>APR_FINFO_MIN</name> | <name>APR_FINFO_LINK</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name><name>finfo</name>.<name>filetype</name></name></expr>)</condition> <block>{
<case>case <expr><name>APR_REG</name></expr>:
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_open</name><argument_list>(<argument><expr>&amp;<name>s</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>APR_READ</name> | <name>APR_BUFFERED</name></expr></argument>,
<argument><expr><name>APR_OS_DEFAULT</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>translated_stream_p</name> = <call><name>svn_stream_from_aprfile2</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>APR_LNK</name></expr>:
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_read_link</name><argument_list>(<argument><expr>&amp;<name>buf</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>strbuf</name> = <call><name>svn_stringbuf_createf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"link %s"</expr></argument>, <argument><expr><name><name>buf</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>translated_stream_p</name> = <call><name>svn_stream_from_stringbuf</name><argument_list>(<argument><expr><name>strbuf</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><default>default:
<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</default>}</block></switch>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><name>svn_error_t</name> *</type>
<name>svn_subst_stream_detranslated</name><parameter_list>(<param><decl><type><name>svn_stream_t</name> **</type><name>stream_p</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>src</name></decl></param>,
<param><decl><type><name>svn_subst_eol_style_t</name></type> <name>eol_style</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>eol_str</name></decl></param>,
<param><decl><type><name>svn_boolean_t</name></type> <name>always_repair_eols</name></decl></param>,
<param><decl><type><name>apr_hash_t</name> *</type><name>keywords</name></decl></param>,
<param><decl><type><name>svn_boolean_t</name></type> <name>special</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_file_t</name> *</type><name>file_h</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>src_stream</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>special</name></expr>)</condition><then>
<return>return <expr><call><name>detranslated_stream_special</name><argument_list>(<argument><expr><name>stream_p</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<if>if <condition>(<expr><name>eol_style</name> == <name>svn_subst_eol_style_native</name></expr>)</condition><then>
<expr_stmt><expr><name>eol_str</name> = <name>SVN_SUBST__DEFAULT_EOL_STR</name></expr>;</expr_stmt></then>
<else>else <if>if <condition>(<expr>! (<name>eol_style</name> == <name>svn_subst_eol_style_fixed</name>
|| <name>eol_style</name> == <name>svn_subst_eol_style_none</name>)</expr>)</condition><then>
<return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_IO_UNKNOWN_EOL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></then></if></else></if>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_open</name><argument_list>(<argument><expr>&amp;<name>file_h</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>APR_READ</name></expr></argument>,
<argument><expr><name>APR_OS_DEFAULT</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>src_stream</name> = <call><name>svn_stream_from_aprfile2</name><argument_list>(<argument><expr><name>file_h</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>stream_p</name> = <call><name>svn_subst_stream_translated</name><argument_list>(
<argument><expr><name>src_stream</name></expr></argument>, <argument><expr><name>eol_str</name></expr></argument>,
<argument><expr><name>eol_style</name> == <name>svn_subst_eol_style_fixed</name> || <name>always_repair_eols</name></expr></argument>,
<argument><expr><name>keywords</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><name>svn_stream_t</name> *</type>
<name>svn_subst_stream_translated</name><parameter_list>(<param><decl><type><name>svn_stream_t</name> *</type><name>stream</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>eol_str</name></decl></param>,
<param><decl><type><name>svn_boolean_t</name></type> <name>repair</name></decl></param>,
<param><decl><type><name>apr_hash_t</name> *</type><name>keywords</name></decl></param>,
<param><decl><type><name>svn_boolean_t</name></type> <name>expand</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>baton_pool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>translated_stream_baton</name> *</type><name>baton</name>
<init>= <expr><call><name>apr_palloc</name><argument_list>(<argument><expr><name>baton_pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>baton</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>s</name> <init>= <expr><call><name>svn_stream_create</name><argument_list>(<argument><expr><name>baton</name></expr></argument>, <argument><expr><name>baton_pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>eol_str</name></expr>)</condition><then>
<expr_stmt><expr><name>eol_str</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>baton_pool</name></expr></argument>, <argument><expr><name>eol_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
<if>if <condition>(<expr><name>keywords</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><call><name>apr_hash_count</name><argument_list>(<argument><expr><name>keywords</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
<expr_stmt><expr><name>keywords</name> = <name>NULL</name></expr>;</expr_stmt></then>
<else>else <block>{
<decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>copy</name> <init>= <expr><call><name>apr_hash_make</name><argument_list>(<argument><expr><name>baton_pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>
<for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>keywords</name></expr></argument>)</argument_list></call></expr>;</init>
<condition><expr><name>hi</name></expr>;</condition> <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>) <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>copy</name></expr></argument>, <argument><expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>baton_pool</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>,
<argument><expr><call><name>svn_string_dup</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>baton_pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></for>
<expr_stmt><expr><name>keywords</name> = <name>copy</name></expr>;</expr_stmt>
}</block></else></if>
}</block></then></if>
<expr_stmt><expr><name><name>baton</name>-&gt;<name>stream</name></name> = <name>stream</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>baton</name>-&gt;<name>in_baton</name></name>
= <call><name>create_translation_baton</name><argument_list>(<argument><expr><name>eol_str</name></expr></argument>, <argument><expr><name>repair</name></expr></argument>, <argument><expr><name>keywords</name></expr></argument>, <argument><expr><name>expand</name></expr></argument>, <argument><expr><name>baton_pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>baton</name>-&gt;<name>out_baton</name></name>
= <call><name>create_translation_baton</name><argument_list>(<argument><expr><name>eol_str</name></expr></argument>, <argument><expr><name>repair</name></expr></argument>, <argument><expr><name>keywords</name></expr></argument>, <argument><expr><name>expand</name></expr></argument>, <argument><expr><name>baton_pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>baton</name>-&gt;<name>written</name></name> = <name>FALSE</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>baton</name>-&gt;<name>readbuf</name></name> = <call><name>svn_stringbuf_create</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr><name>baton_pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>baton</name>-&gt;<name>readbuf_off</name></name> = 0</expr>;</expr_stmt>
<expr_stmt><expr><name><name>baton</name>-&gt;<name>iterpool</name></name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name>baton_pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>baton</name>-&gt;<name>pool</name></name> = <name>baton_pool</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>baton</name>-&gt;<name>buf</name></name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>baton</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>SVN__STREAM_CHUNK_SIZE</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>svn_stream_set_read</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>translated_stream_read</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>svn_stream_set_write</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>translated_stream_write</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>svn_stream_set_close</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>translated_stream_close</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>s</name></expr>;</return>
}</block></function>
<function><type><name>svn_error_t</name> *</type>
<name>svn_subst_translate_stream3</name><parameter_list>(<param><decl><type><name>svn_stream_t</name> *</type><name>s</name></decl></param>,
<param><decl><type><name>svn_stream_t</name> *</type><name>d</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>eol_str</name></decl></param>,
<param><decl><type><name>svn_boolean_t</name></type> <name>repair</name></decl></param>,
<param><decl><type><name>apr_hash_t</name> *</type><name>keywords</name></decl></param>,
<param><decl><type><name>svn_boolean_t</name></type> <name>expand</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>iterpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type>struct <name>translation_baton</name> *</type><name>baton</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>readlen</name> <init>= <expr><name>SVN__STREAM_CHUNK_SIZE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name> *</type><name>buf</name> <init>= <expr><call><name>apr_palloc</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>, <argument><expr><name>SVN__STREAM_CHUNK_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>eol_str</name> || <name>keywords</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>baton</name> = <call><name>create_translation_baton</name><argument_list>(<argument><expr><name>eol_str</name></expr></argument>, <argument><expr><name>repair</name></expr></argument>, <argument><expr><name>keywords</name></expr></argument>, <argument><expr><name>expand</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<while>while <condition>(<expr><name>readlen</name> == <name>SVN__STREAM_CHUNK_SIZE</name></expr>)</condition> <block>{
<expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_read</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr>&amp;<name>readlen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>translate_chunk</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>baton</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>readlen</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></while>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>translate_chunk</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>baton</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><name>svn_error_t</name> *</type>
<name>svn_subst_translate_stream</name><parameter_list>(<param><decl><type><name>svn_stream_t</name> *</type><name>s</name></decl></param>,
<param><decl><type><name>svn_stream_t</name> *</type><name>d</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>eol_str</name></decl></param>,
<param><decl><type><name>svn_boolean_t</name></type> <name>repair</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>svn_subst_keywords_t</name> *</type><name>keywords</name></decl></param>,
<param><decl><type><name>svn_boolean_t</name></type> <name>expand</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name> <init>= <expr><call><name>svn_subst_translate_stream2</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>eol_str</name></expr></argument>, <argument><expr><name>repair</name></expr></argument>,
<argument><expr><name>keywords</name></expr></argument>, <argument><expr><name>expand</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>err</name></expr>;</return>
}</block></function>
<function><type><name>svn_error_t</name> *</type>
<name>svn_subst_translate_cstring</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>src</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>dst</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>eol_str</name></decl></param>,
<param><decl><type><name>svn_boolean_t</name></type> <name>repair</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>svn_subst_keywords_t</name> *</type><name>keywords</name></decl></param>,
<param><decl><type><name>svn_boolean_t</name></type> <name>expand</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>kh</name> <init>= <expr><call><name>kwstruct_to_kwhash</name><argument_list>(<argument><expr><name>keywords</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>svn_subst_translate_cstring2</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>eol_str</name></expr></argument>, <argument><expr><name>repair</name></expr></argument>,
<argument><expr><name>kh</name></expr></argument>, <argument><expr><name>expand</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>svn_error_t</name> *</type>
<name>svn_subst_translate_cstring2</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>src</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>dst</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>eol_str</name></decl></param>,
<param><decl><type><name>svn_boolean_t</name></type> <name>repair</name></decl></param>,
<param><decl><type><name>apr_hash_t</name> *</type><name>keywords</name></decl></param>,
<param><decl><type><name>svn_boolean_t</name></type> <name>expand</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>src_stringbuf</name></decl>, *<decl><type ref="prev"/><name>dst_stringbuf</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>src_stream</name></decl>, *<decl><type ref="prev"/><name>dst_stream</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>
<expr_stmt><expr><name>src_stringbuf</name> = <call><name>svn_stringbuf_create</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr>! (<name>eol_str</name> || (<name>keywords</name> &amp;&amp; (<call><name>apr_hash_count</name><argument_list>(<argument><expr><name>keywords</name></expr></argument>)</argument_list></call> &gt; 0)))</expr>)</condition><then> <block>{
<expr_stmt><expr><name>dst_stringbuf</name> = <call><name>svn_stringbuf_dup</name><argument_list>(<argument><expr><name>src_stringbuf</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<goto>goto <name>all_good</name>;</goto>
}</block></then></if>
<expr_stmt><expr><name>src_stream</name> = <call><name>svn_stream_from_stringbuf</name><argument_list>(<argument><expr><name>src_stringbuf</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dst_stringbuf</name> = <call><name>svn_stringbuf_create</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dst_stream</name> = <call><name>svn_stream_from_stringbuf</name><argument_list>(<argument><expr><name>dst_stringbuf</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> = <call><name>svn_subst_translate_stream3</name><argument_list>(<argument><expr><name>src_stream</name></expr></argument>, <argument><expr><name>dst_stream</name></expr></argument>,
<argument><expr><name>eol_str</name></expr></argument>, <argument><expr><name>repair</name></expr></argument>, <argument><expr><name>keywords</name></expr></argument>, <argument><expr><name>expand</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>err</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><call><name>svn_stream_close</name><argument_list>(<argument><expr><name>src_stream</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><call><name>svn_stream_close</name><argument_list>(<argument><expr><name>dst_stream</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>err</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_close</name><argument_list>(<argument><expr><name>src_stream</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_close</name><argument_list>(<argument><expr><name>dst_stream</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<label><name>all_good</name>:</label>
<expr_stmt><expr>*<name>dst</name> = <name><name>dst_stringbuf</name>-&gt;<name>data</name></name></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><name>svn_error_t</name> *</type>
<name>svn_subst_copy_and_translate</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>src</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dst</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>eol_str</name></decl></param>,
<param><decl><type><name>svn_boolean_t</name></type> <name>repair</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>svn_subst_keywords_t</name> *</type><name>keywords</name></decl></param>,
<param><decl><type><name>svn_boolean_t</name></type> <name>expand</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<return>return <expr><call><name>svn_subst_copy_and_translate2</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>eol_str</name></expr></argument>, <argument><expr><name>repair</name></expr></argument>, <argument><expr><name>keywords</name></expr></argument>,
<argument><expr><name>expand</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>detranslate_special_file_to_stream</name><parameter_list>(<param><decl><type><name>svn_stream_t</name> **</type><name>src_stream</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>src</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_finfo_t</name></type> <name>finfo</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_file_t</name> *</type><name>s</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_string_t</name> *</type><name>buf</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_stat</name><argument_list>(<argument><expr>&amp;<name>finfo</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>APR_FINFO_MIN</name> | <name>APR_FINFO_LINK</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<switch>switch <condition>(<expr><name><name>finfo</name>.<name>filetype</name></name></expr>)</condition> <block>{
<case>case <expr><name>APR_REG</name></expr>:
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_open</name><argument_list>(<argument><expr>&amp;<name>s</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>APR_READ</name> | <name>APR_BUFFERED</name></expr></argument>,
<argument><expr><name>APR_OS_DEFAULT</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>src_stream</name> = <call><name>svn_stream_from_aprfile</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><case>case <expr><name>APR_LNK</name></expr>:
<expr_stmt><expr>*<name>src_stream</name> = <call><name>svn_stream_from_stringbuf</name><argument_list>(<argument><expr><call><name>svn_stringbuf_create</name> <argument_list>(<argument><expr>""</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_read_link</name><argument_list>(<argument><expr>&amp;<name>buf</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_printf</name><argument_list>(<argument><expr>*<name>src_stream</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"link %s"</expr></argument>,
<argument><expr><name><name>buf</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<break>break;</break>
</case><default>default:
<expr_stmt><expr><call><name>abort</name> <argument_list>()</argument_list></call></expr>;</expr_stmt>
</default>}</block></switch>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>detranslate_special_file</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>src</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dst</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dst_tmp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_file_t</name> *</type><name>d</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>src_stream</name></decl>, *<decl><type ref="prev"/><name>dst_stream</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_open_unique_file2</name><argument_list>(<argument><expr>&amp;<name>d</name></expr></argument>, <argument><expr>&amp;<name>dst_tmp</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>,
<argument><expr>".tmp"</expr></argument>, <argument><expr><name>svn_io_file_del_none</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dst_stream</name> = <call><name>svn_stream_from_aprfile2</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>detranslate_special_file_to_stream</name><argument_list>(<argument><expr>&amp;<name>src_stream</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_copy</name><argument_list>(<argument><expr><name>src_stream</name></expr></argument>, <argument><expr><name>dst_stream</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_close</name><argument_list>(<argument><expr><name>dst_stream</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_rename</name><argument_list>(<argument><expr><name>dst_tmp</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>create_special_file_from_stringbuf</name><parameter_list>(<param><decl><type><name>svn_stringbuf_t</name> *</type><name>src</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dst</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>char</name> *</type><name>identifier</name></decl>, *<decl><type ref="prev"/><name>remainder</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dst_tmp</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>create_using_internal_representation</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<expr_stmt><expr><name>identifier</name> = <name><name>src</name>-&gt;<name>data</name></name></expr>;</expr_stmt>
<for>for (<init><expr><name>remainder</name> = <name>identifier</name></expr>;</init> <condition><expr>*<name>remainder</name></expr>;</condition> <incr><expr><name>remainder</name>++</expr></incr>) <block>{
<if>if <condition>(<expr>*<name>remainder</name> == ' '</expr>)</condition><then> <block>{
<expr_stmt><expr><name>remainder</name>++</expr>;</expr_stmt>
<break>break;</break>
}</block></then></if>
}</block></for>
<if>if <condition>(<expr>! <call><name>strncmp</name><argument_list>(<argument><expr><name>identifier</name></expr></argument>, <argument><expr><name>SVN_SUBST__SPECIAL_LINK_STR</name> " "</expr></argument>,
<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>SVN_SUBST__SPECIAL_LINK_STR</name> " "</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name> <init>= <expr><call><name>svn_io_create_unique_link</name><argument_list>(<argument><expr>&amp;<name>dst_tmp</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>remainder</name></expr></argument>,
<argument><expr>".tmp"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name>err</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>err</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_UNSUPPORTED_FEATURE</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>create_using_internal_representation</name> = <name>TRUE</name></expr>;</expr_stmt>
}</block></then> <else>else
<return>return <expr><name>err</name></expr>;</return></else></if>
}</block></then></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>create_using_internal_representation</name> = <name>TRUE</name></expr>;</expr_stmt>
}</block></else></if>
<if>if <condition>(<expr><name>create_using_internal_representation</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>apr_file_t</name> *</type><name>dst_tmp_file</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_size_t</name></type> <name>written</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_open_unique_file2</name><argument_list>(<argument><expr>&amp;<name>dst_tmp_file</name></expr></argument>, <argument><expr>&amp;<name>dst_tmp</name></expr></argument>,
<argument><expr><name>dst</name></expr></argument>, <argument><expr>".tmp"</expr></argument>, <argument><expr><name>svn_io_file_del_none</name></expr></argument>,
<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_write_full</name><argument_list>(<argument><expr><name>dst_tmp_file</name></expr></argument>, <argument><expr><name><name>src</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>src</name>-&gt;<name>len</name></name></expr></argument>,
<argument><expr>&amp;<name>written</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_close</name><argument_list>(<argument><expr><name>dst_tmp_file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><call><name>svn_io_file_rename</name><argument_list>(<argument><expr><name>dst_tmp</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>create_special_file</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>src</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dst</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>contents</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>is_special</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>source</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_check_special_path</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr>&amp;<name>kind</name></expr></argument>, <argument><expr>&amp;<name>is_special</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>is_special</name></expr>)</condition><then> <block>{
<decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>eof</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>detranslate_special_file_to_stream</name><argument_list>(<argument><expr>&amp;<name>source</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_readline</name><argument_list>(<argument><expr><name>source</name></expr></argument>, <argument><expr>&amp;<name>contents</name></expr></argument>, <argument><expr>"\n"</expr></argument>, <argument><expr>&amp;<name>eof</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stringbuf_from_file</name><argument_list>(<argument><expr>&amp;<name>contents</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<return>return <expr><call><name>create_special_file_from_stringbuf</name><argument_list>(<argument><expr><name>contents</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>svn_error_t</name> *</type>
<name>svn_subst_copy_and_translate2</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>src</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dst</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>eol_str</name></decl></param>,
<param><decl><type><name>svn_boolean_t</name></type> <name>repair</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>svn_subst_keywords_t</name> *</type><name>keywords</name></decl></param>,
<param><decl><type><name>svn_boolean_t</name></type> <name>expand</name></decl></param>,
<param><decl><type><name>svn_boolean_t</name></type> <name>special</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>kh</name> <init>= <expr><call><name>kwstruct_to_kwhash</name><argument_list>(<argument><expr><name>keywords</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>svn_subst_copy_and_translate3</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>eol_str</name></expr></argument>,
<argument><expr><name>repair</name></expr></argument>, <argument><expr><name>kh</name></expr></argument>, <argument><expr><name>expand</name></expr></argument>, <argument><expr><name>special</name></expr></argument>,
<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><name>svn_error_t</name> *</type>
<name>svn_subst_copy_and_translate3</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>src</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dst</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>eol_str</name></decl></param>,
<param><decl><type><name>svn_boolean_t</name></type> <name>repair</name></decl></param>,
<param><decl><type><name>apr_hash_t</name> *</type><name>keywords</name></decl></param>,
<param><decl><type><name>svn_boolean_t</name></type> <name>expand</name></decl></param>,
<param><decl><type><name>svn_boolean_t</name></type> <name>special</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dst_tmp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>src_stream</name></decl>, *<decl><type ref="prev"/><name>dst_stream</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_file_t</name> *</type><name>s</name> <init>= <expr><name>NULL</name></expr></init>, *<name>d</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>path_special</name></decl>;</decl_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_check_special_path</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr>&amp;<name>kind</name></expr></argument>, <argument><expr>&amp;<name>path_special</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>special</name> || <name>path_special</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name>expand</name></expr>)</condition><then>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>create_special_file</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
<else>else
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>detranslate_special_file</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr>! (<name>eol_str</name> || (<name>keywords</name> &amp;&amp; (<call><name>apr_hash_count</name><argument_list>(<argument><expr><name>keywords</name></expr></argument>)</argument_list></call> &gt; 0)))</expr>)</condition><then>
<return>return <expr><call><name>svn_io_copy_file</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_open</name><argument_list>(<argument><expr>&amp;<name>s</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>APR_READ</name> | <name>APR_BUFFERED</name></expr></argument>,
<argument><expr><name>APR_OS_DEFAULT</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_open_unique_file2</name><argument_list>(<argument><expr>&amp;<name>d</name></expr></argument>, <argument><expr>&amp;<name>dst_tmp</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>,
<argument><expr>".tmp"</expr></argument>, <argument><expr><name>svn_io_file_del_on_pool_cleanup</name></expr></argument>,
<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>src_stream</name> = <call><name>svn_stream_from_aprfile</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>dst_stream</name> = <call><name>svn_stream_from_aprfile</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> = <call><name>svn_subst_translate_stream3</name><argument_list>(<argument><expr><name>src_stream</name></expr></argument>, <argument><expr><name>dst_stream</name></expr></argument>, <argument><expr><name>eol_str</name></expr></argument>,
<argument><expr><name>repair</name></expr></argument>, <argument><expr><name>keywords</name></expr></argument>, <argument><expr><name>expand</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>err</name></expr>)</condition><then> <block>{
<if>if <condition>(<expr><name><name>err</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_IO_INCONSISTENT_EOL</name></expr>)</condition><then>
<return>return <expr><call><name>svn_error_createf</name>
<argument_list>(<argument><expr><name>SVN_ERR_IO_INCONSISTENT_EOL</name></expr></argument>, <argument><expr><name>err</name></expr></argument>,
<argument><expr><call><name>_</name><argument_list>(<argument><expr>"File '%s' has inconsistent newlines"</expr></argument>)</argument_list></call></expr></argument>,
<argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>src</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then>
<else>else
<return>return <expr><name>err</name></expr>;</return></else></if>
}</block></then></if>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_close</name><argument_list>(<argument><expr><name>src_stream</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_close</name><argument_list>(<argument><expr><name>dst_stream</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_close</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_close</name><argument_list>(<argument><expr><name>d</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_rename</name><argument_list>(<argument><expr><name>dst_tmp</name></expr></argument>, <argument><expr><name>dst</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<struct>struct <name>special_stream_baton</name> <block>{
<decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>read_stream</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>write_content</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>write_stream</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>
}</block>;</struct>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>read_handler_special</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>char</name> *</type><name>buffer</name></decl></param>, <param><decl><type><name>apr_size_t</name> *</type><name>len</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>special_stream_baton</name> *</type><name>btn</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>btn</name>-&gt;<name>read_stream</name></name></expr>)</condition><then>
<return>return <expr><call><name>svn_stream_read</name><argument_list>(<argument><expr><name><name>btn</name>-&gt;<name>read_stream</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return></then>
<else>else
<return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>APR_ENOENT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
<argument><expr>"Can't read special file: File '%s' not found"</expr></argument>,
<argument><expr><call><name>svn_path_local_style</name> <argument_list>(<argument><expr><name><name>btn</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name><name>btn</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>write_handler_special</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>buffer</name></decl></param>, <param><decl><type><name>apr_size_t</name> *</type><name>len</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>special_stream_baton</name> *</type><name>btn</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
<return>return <expr><call><name>svn_stream_write</name><argument_list>(<argument><expr><name><name>btn</name>-&gt;<name>write_stream</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>close_handler_special</name> <parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>special_stream_baton</name> *</type><name>btn</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
<if>if <condition>(<expr><name><name>btn</name>-&gt;<name>write_content</name>-&gt;<name>len</name></name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>create_special_file_from_stringbuf</name><argument_list>(<argument><expr><name><name>btn</name>-&gt;<name>write_content</name></name></expr></argument>,
<argument><expr><name><name>btn</name>-&gt;<name>path</name></name></expr></argument>,
<argument><expr><name><name>btn</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then></if>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><name>svn_error_t</name> *</type>
<name>svn_subst_stream_from_specialfile</name><parameter_list>(<param><decl><type><name>svn_stream_t</name> **</type><name>stream</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type>struct <name>special_stream_baton</name> *</type><name>baton</name> <init>= <expr><call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>baton</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>
<expr_stmt><expr><name><name>baton</name>-&gt;<name>pool</name></name> = <name>pool</name></expr>;</expr_stmt>
<expr_stmt><expr><name><name>baton</name>-&gt;<name>path</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name>err</name> = <call><name>detranslate_special_file_to_stream</name><argument_list>(<argument><expr>&amp;<name><name>baton</name>-&gt;<name>read_stream</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>err</name> &amp;&amp; <call><name>APR_STATUS_IS_ENOENT</name><argument_list>(<argument><expr><name><name>err</name>-&gt;<name>apr_err</name></name></expr></argument>)</argument_list></call></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>baton</name>-&gt;<name>read_stream</name></name> = <name>NULL</name></expr>;</expr_stmt>
}</block></then></if>
<expr_stmt><expr><name><name>baton</name>-&gt;<name>write_content</name></name> = <call><name>svn_stringbuf_create</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><name><name>baton</name>-&gt;<name>write_stream</name></name> = <call><name>svn_stream_from_stringbuf</name><argument_list>(<argument><expr><name><name>baton</name>-&gt;<name>write_content</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>stream</name> = <call><name>svn_stream_create</name><argument_list>(<argument><expr><name>baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>svn_stream_set_read</name><argument_list>(<argument><expr>*<name>stream</name></expr></argument>, <argument><expr><name>read_handler_special</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>svn_stream_set_write</name><argument_list>(<argument><expr>*<name>stream</name></expr></argument>, <argument><expr><name>write_handler_special</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>svn_stream_set_close</name><argument_list>(<argument><expr>*<name>stream</name></expr></argument>, <argument><expr><name>close_handler_special</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><name>svn_error_t</name> *</type>
<name>svn_subst_translate_string</name><parameter_list>(<param><decl><type><name>svn_string_t</name> **</type><name>new_value</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>value</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>encoding</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>val_utf8</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>val_utf8_lf</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>value</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>new_value</name> = <name>NULL</name></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></then></if>
<if>if <condition>(<expr><name>encoding</name></expr>)</condition><then> <block>{
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_utf_cstring_to_utf8_ex2</name><argument_list>(<argument><expr>&amp;<name>val_utf8</name></expr></argument>, <argument><expr><name><name>value</name>-&gt;<name>data</name></name></expr></argument>,
<argument><expr><name>encoding</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <block>{
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_utf_cstring_to_utf8</name><argument_list>(<argument><expr>&amp;<name>val_utf8</name></expr></argument>, <argument><expr><name><name>value</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></else></if>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_subst_translate_cstring2</name><argument_list>(<argument><expr><name>val_utf8</name></expr></argument>,
<argument><expr>&amp;<name>val_utf8_lf</name></expr></argument>,
<argument><expr>"\n"</expr></argument>,
<argument><expr><name>FALSE</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>,
<argument><expr><name>FALSE</name></expr></argument>,
<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr>*<name>new_value</name> = <call><name>svn_string_create</name><argument_list>(<argument><expr><name>val_utf8_lf</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
<function><type><name>svn_error_t</name> *</type>
<name>svn_subst_detranslate_string</name><parameter_list>(<param><decl><type><name>svn_string_t</name> **</type><name>new_value</name></decl></param>,
<param><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>value</name></decl></param>,
<param><decl><type><name>svn_boolean_t</name></type> <name>for_output</name></decl></param>,
<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list> <block>{
<decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>val_neol</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>val_nlocale_neol</name></decl>;</decl_stmt>
<if>if <condition>(<expr><name>value</name> == <name>NULL</name></expr>)</condition><then> <block>{
<expr_stmt><expr>*<name>new_value</name> = <name>NULL</name></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></then></if>
<expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_subst_translate_cstring2</name><argument_list>(<argument><expr><name><name>value</name>-&gt;<name>data</name></name></expr></argument>,
<argument><expr>&amp;<name>val_neol</name></expr></argument>,
<argument><expr><name>APR_EOL_STR</name></expr></argument>,
<argument><expr><name>FALSE</name></expr></argument>,
<argument><expr><name>NULL</name></expr></argument>,
<argument><expr><name>FALSE</name></expr></argument>,
<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>for_output</name></expr>)</condition><then> <block>{
<expr_stmt><expr><name>err</name> = <call><name>svn_cmdline_cstring_from_utf8</name><argument_list>(<argument><expr>&amp;<name>val_nlocale_neol</name></expr></argument>, <argument><expr><name>val_neol</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>err</name> &amp;&amp; (<call><name>APR_STATUS_IS_EINVAL</name><argument_list>(<argument><expr><name><name>err</name>-&gt;<name>apr_err</name></name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
<expr_stmt><expr><name>val_nlocale_neol</name> =
<call><name>svn_cmdline_cstring_from_utf8_fuzzy</name><argument_list>(<argument><expr><name>val_neol</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
<return>return <expr><name>err</name></expr>;</return></then></if></else></if>
}</block></then> <else>else <block>{
<expr_stmt><expr><name>err</name> = <call><name>svn_utf_cstring_from_utf8</name><argument_list>(<argument><expr>&amp;<name>val_nlocale_neol</name></expr></argument>, <argument><expr><name>val_neol</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<if>if <condition>(<expr><name>err</name> &amp;&amp; (<call><name>APR_STATUS_IS_EINVAL</name><argument_list>(<argument><expr><name><name>err</name>-&gt;<name>apr_err</name></name></expr></argument>)</argument_list></call>)</expr>)</condition><then> <block>{
<expr_stmt><expr><name>val_nlocale_neol</name> = <call><name>svn_utf_cstring_from_utf8_fuzzy</name><argument_list>(<argument><expr><name>val_neol</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></then> <else>else <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
<return>return <expr><name>err</name></expr>;</return></then></if></else></if>
}</block></else></if>
<expr_stmt><expr>*<name>new_value</name> = <call><name>svn_string_create</name><argument_list>(<argument><expr><name>val_nlocale_neol</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
</unit>
