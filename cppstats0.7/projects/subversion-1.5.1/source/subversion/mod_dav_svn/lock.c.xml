<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/subversion-1.5.1/source/subversion/mod_dav_svn/lock.c"><comment type="block">/*
 * lock.c: mod_dav_svn locking provider functions
 *
 * ====================================================================
 * Copyright (c) 2000-2006 CollabNet.  All rights reserved.
 *
 * This software is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at http://subversion.tigris.org/license-1.html.
 * If newer versions of this license are posted there, you may use a
 * newer version instead, at your option.
 *
 * This software consists of voluntary contributions made by many
 * individuals.  For exact contribution history, see the revision
 * history and logs, available at http://subversion.tigris.org/.
 * ====================================================================
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_uuid.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_time.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;httpd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;http_log.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;mod_dav.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_fs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_repos.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_dav.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_time.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_pools.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dav_svn.h"</cpp:file></cpp:include>


<struct>struct <name>dav_lockdb_private</name>
<block>{
  <comment type="block">/* These represent 'custom' request hearders only sent by svn clients: */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>lock_steal</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>lock_break</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>keep_locks</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>working_revnum</name></decl>;</decl_stmt>

  <comment type="block">/* The original request, so we can set 'custom' output headers. */</comment>
  <decl_stmt><decl><type><name>request_rec</name> *</type><name>r</name></decl>;</decl_stmt>
}</block>;</struct>


<comment type="block">/* Helper func:  convert an svn_lock_t to a dav_lock, allocated in
   pool.  EXISTS_P indicates whether slock-&gt;path actually exists or not.
   If HIDE_AUTH_USER is set, then do not return the svn lock's 'owner'
   as dlock-&gt;auth_user.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>svn_lock_to_dav_lock</name><parameter_list>(<param><decl><type><name>dav_lock</name> **</type><name>dlock</name></decl></param>,
                     <param><decl><type><specifier>const</specifier> <name>svn_lock_t</name> *</type><name>slock</name></decl></param>,
                     <param><decl><type><name>svn_boolean_t</name></type> <name>hide_auth_user</name></decl></param>,
                     <param><decl><type><name>svn_boolean_t</name></type> <name>exists_p</name></decl></param>,
                     <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>dav_lock</name> *</type><name>lock</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>lock</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dav_locktoken</name> *</type><name>token</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>token</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>lock</name>-&gt;<name>rectype</name></name> = <name>DAV_LOCKREC_DIRECT</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>lock</name>-&gt;<name>scope</name></name> = <name>DAV_LOCKSCOPE_EXCLUSIVE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>lock</name>-&gt;<name>type</name></name> = <name>DAV_LOCKTYPE_WRITE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>lock</name>-&gt;<name>depth</name></name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>lock</name>-&gt;<name>is_locknull</name></name> = <name>exists_p</name></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>token</name>-&gt;<name>uuid_str</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>slock</name>-&gt;<name>token</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>lock</name>-&gt;<name>locktoken</name></name> = <name>token</name></expr>;</expr_stmt>

  <comment type="block">/* the svn_lock_t 'comment' field maps to the 'DAV:owner' field. */</comment>
  <if>if <condition>(<expr><name><name>slock</name>-&gt;<name>comment</name></name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr>! <name><name>slock</name>-&gt;<name>is_dav_comment</name></name></expr>)</condition><then>
        <block>{
          <comment type="block">/* This comment was originally given to us by an svn client,
             so, we need to wrap the naked comment with &lt;DAV:owner&gt;,
             and xml-escape it for safe transport, lest we send back
             an invalid http response.  (mod_dav won't do it for us,
             because it assumes that it personally created every lock
             in the repository.) */</comment>
          <expr_stmt><expr><name><name>lock</name>-&gt;<name>owner</name></name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name>pool</name></expr></argument>,
                                    <argument><expr>"&lt;D:owner xmlns:D=\"DAV:\"&gt;"</expr></argument>,
                                    <argument><expr><call><name>apr_xml_quote_string</name><argument_list>(<argument><expr><name>pool</name></expr></argument>,
                                                         <argument><expr><name><name>slock</name>-&gt;<name>comment</name></name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>,
                                    <argument><expr>"&lt;/D:owner&gt;"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
      <else>else
        <block>{
          <expr_stmt><expr><name><name>lock</name>-&gt;<name>owner</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>slock</name>-&gt;<name>comment</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></then>
  <else>else
    <expr_stmt><expr><name><name>lock</name>-&gt;<name>owner</name></name> = <name>NULL</name></expr>;</expr_stmt></else></if>

  <comment type="block">/* the svn_lock_t 'owner' is the actual authenticated owner of the
     lock, and maps to the 'auth_user' field in the mod_dav lock. */</comment>

  <comment type="block">/* (If the client ran 'svn unlock --force', then we don't want to
     return lock-&gt;auth_user.  Otherwise mod_dav will throw an error
     when lock-&gt;auth_user and r-&gt;user don't match.) */</comment>
  <if>if <condition>(<expr>! <name>hide_auth_user</name></expr>)</condition><then>
    <expr_stmt><expr><name><name>lock</name>-&gt;<name>auth_user</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>slock</name>-&gt;<name>owner</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* This is absurd.  apr_time.h has an apr_time_t-&gt;time_t func,
     but not the reverse?? */</comment>
  <if>if <condition>(<expr><name><name>slock</name>-&gt;<name>expiration_date</name></name></expr>)</condition><then>
    <expr_stmt><expr><name><name>lock</name>-&gt;<name>timeout</name></name> = <call>(<name>time_t</name>) <argument_list>(<argument><expr><name><name>slock</name>-&gt;<name>expiration_date</name></name> / <name>APR_USEC_PER_SEC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name><name>lock</name>-&gt;<name>timeout</name></name> = <name>DAV_TIMEOUT_INFINITE</name></expr>;</expr_stmt></else></if>

  <expr_stmt><expr>*<name>dlock</name> = <name>lock</name></expr>;</expr_stmt>
}</block></function>


<comment type="block">/* Helper func for dav_lock_to_svn_lock:  take an incoming
   "&lt;D:owner&gt;&amp;lt;foo&amp;gt;&lt;/D:owner&gt;" tag and convert it to
   "&lt;foo&gt;". */</comment>
<function><type><specifier>static</specifier> <name>dav_error</name> *</type>
<name>unescape_xml</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>output</name></decl></param>,
             <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>input</name></decl></param>,
             <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_xml_parser</name> *</type><name>xml_parser</name> <init>= <expr><call><name>apr_xml_parser_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_xml_doc</name> *</type><name>xml_doc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_status_t</name></type> <name>apr_err</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>xml_input</name> <init>= <expr><call><name>apr_pstrcat</name>
    <argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;"</expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>apr_err</name> = <call><name>apr_xml_parser_feed</name><argument_list>(<argument><expr><name>xml_parser</name></expr></argument>, <argument><expr><name>xml_input</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>xml_input</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<name>apr_err</name></expr>)</condition><then>
    <expr_stmt><expr><name>apr_err</name> = <call><name>apr_xml_parser_done</name><argument_list>(<argument><expr><name>xml_parser</name></expr></argument>, <argument><expr>&amp;<name>xml_doc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <if>if <condition>(<expr><name>apr_err</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>char</name></type> <name><name>errbuf</name><index>[<expr>1024</expr>]</index></name></decl>;</decl_stmt>
      <expr_stmt><expr>(<name>void</name>)<call><name>apr_xml_parser_geterror</name><argument_list>(<argument><expr><name>xml_parser</name></expr></argument>, <argument><expr><name>errbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>,
                           <argument><expr><name>DAV_ERR_LOCK_SAVE_LOCK</name></expr></argument>, <argument><expr><name>errbuf</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

  <expr_stmt><expr><call><name>apr_xml_to_text</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>xml_doc</name>-&gt;<name>root</name></name></expr></argument>, <argument><expr><name>APR_XML_X2T_INNER</name></expr></argument>,
                  <argument><expr><name><name>xml_doc</name>-&gt;<name>namespaces</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>output</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Helper func:  convert a dav_lock to an svn_lock_t, allocated in pool. */</comment>
<function><type><specifier>static</specifier> <name>dav_error</name> *</type>
<name>dav_lock_to_svn_lock</name><parameter_list>(<param><decl><type><name>svn_lock_t</name> **</type><name>slock</name></decl></param>,
                     <param><decl><type><specifier>const</specifier> <name>dav_lock</name> *</type><name>dlock</name></decl></param>,
                     <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                     <param><decl><type><name>dav_lockdb_private</name> *</type><name>info</name></decl></param>,
                     <param><decl><type><name>svn_boolean_t</name></type> <name>is_svn_client</name></decl></param>,
                     <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_lock_t</name> *</type><name>lock</name></decl>;</decl_stmt>

  <comment type="block">/* Sanity checks */</comment>
  <if>if <condition>(<expr><name><name>dlock</name>-&gt;<name>type</name></name> != <name>DAV_LOCKTYPE_WRITE</name></expr>)</condition><then>
    <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>HTTP_BAD_REQUEST</name></expr></argument>,
                         <argument><expr><name>DAV_ERR_LOCK_SAVE_LOCK</name></expr></argument>,
                         <argument><expr>"Only 'write' locks are supported."</expr></argument>)</argument_list></call></expr>;</return></then></if>

  <if>if <condition>(<expr><name><name>dlock</name>-&gt;<name>scope</name></name> != <name>DAV_LOCKSCOPE_EXCLUSIVE</name></expr>)</condition><then>
    <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>HTTP_BAD_REQUEST</name></expr></argument>,
                         <argument><expr><name>DAV_ERR_LOCK_SAVE_LOCK</name></expr></argument>,
                         <argument><expr>"Only exclusive locks are supported."</expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><name>lock</name> = <call><name>svn_lock_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>lock</name>-&gt;<name>path</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>lock</name>-&gt;<name>token</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>dlock</name>-&gt;<name>locktoken</name>-&gt;<name>uuid_str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* DAV has no concept of lock creationdate, so assume 'now' */</comment>
  <expr_stmt><expr><name><name>lock</name>-&gt;<name>creation_date</name></name> = <call><name>apr_time_now</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name><name>dlock</name>-&gt;<name>auth_user</name></name></expr>)</condition><then>
    <expr_stmt><expr><name><name>lock</name>-&gt;<name>owner</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>dlock</name>-&gt;<name>auth_user</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* We need to be very careful about stripping the &lt;D:owner&gt; tag away
     from the cdata.  It's okay to do for svn clients, but not other
     DAV clients! */</comment>
  <if>if <condition>(<expr><name><name>dlock</name>-&gt;<name>owner</name></name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr><name>is_svn_client</name></expr>)</condition><then>
        <block>{
          <comment type="block">/* mod_dav has forcibly xml-escaped the comment before
             handing it to us; we need to xml-unescape it (and remove
             the &lt;D:owner&gt; wrapper) when storing in the repository, so
             it looks reasonable to the rest of svn. */</comment>
          <decl_stmt><decl><type><name>dav_error</name> *</type><name>derr</name></decl>;</decl_stmt>
          <expr_stmt><expr><name><name>lock</name>-&gt;<name>is_dav_comment</name></name> = 0</expr>;</expr_stmt>  <comment type="block">/* comment is NOT xml-wrapped. */</comment>
          <expr_stmt><expr><name>derr</name> = <call><name>unescape_xml</name><argument_list>(<argument><expr>&amp;(<name><name>lock</name>-&gt;<name>comment</name></name>)</expr></argument>, <argument><expr><name><name>dlock</name>-&gt;<name>owner</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>derr</name></expr>)</condition><then>
            <return>return <expr><name>derr</name></expr>;</return></then></if>
        }</block></then>
      <else>else
        <block>{
          <comment type="block">/* The comment comes from a non-svn client;  don't touch
             this data at all. */</comment>
          <expr_stmt><expr><name><name>lock</name>-&gt;<name>comment</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>dlock</name>-&gt;<name>owner</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>lock</name>-&gt;<name>is_dav_comment</name></name> = 1</expr>;</expr_stmt> <comment type="block">/* comment IS xml-wrapped. */</comment>
        }</block></else></if>
    }</block></then></if>

  <if>if <condition>(<expr><name><name>dlock</name>-&gt;<name>timeout</name></name> == <name>DAV_TIMEOUT_INFINITE</name></expr>)</condition><then>
    <expr_stmt><expr><name><name>lock</name>-&gt;<name>expiration_date</name></name> = 0</expr>;</expr_stmt></then> <comment type="block">/* never expires */</comment>
  <else>else
    <expr_stmt><expr><name><name>lock</name>-&gt;<name>expiration_date</name></name> = ((<name>apr_time_t</name>)<name><name>dlock</name>-&gt;<name>timeout</name></name>) * <name>APR_USEC_PER_SEC</name></expr>;</expr_stmt></else></if>

  <expr_stmt><expr>*<name>slock</name> = <name>lock</name></expr>;</expr_stmt>
  <return>return <expr>0</expr>;</return>
}</block></function>


<comment type="block">/* ---------------------------------------------------------------- */</comment>
<comment type="block">/* mod_dav locking vtable starts here: */</comment>


<comment type="block">/* Return the supportedlock property for a resource */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type>
<name>get_supportedlock</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* This is imitating what mod_dav_fs is doing.  Note that unlike
     mod_dav_fs, however, we don't support "shared" locks, only
     "exclusive" ones.  Nor do we support locks on collections. */</comment>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>supported</name><index>[]</index></name> <init>= <expr><name>DEBUG_CR</name>
    "&lt;D:lockentry&gt;" <name>DEBUG_CR</name>
    "&lt;D:lockscope&gt;&lt;D:exclusive/&gt;&lt;/D:lockscope&gt;" <name>DEBUG_CR</name>
    "&lt;D:locktype&gt;&lt;D:write/&gt;&lt;/D:locktype&gt;" <name>DEBUG_CR</name>
    "&lt;/D:lockentry&gt;" <name>DEBUG_CR</name></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name><name>resource</name>-&gt;<name>collection</name></name></expr>)</condition><then>
    <return>return <expr><name>NULL</name></expr>;</return></then>
  <else>else
    <return>return <expr><name>supported</name></expr>;</return></else></if>
}</block></function>


<comment type="block">/* Parse a lock token URI, returning a lock token object allocated
 * in the given pool.
 */</comment>
<function><type><specifier>static</specifier> <name>dav_error</name> *</type>
<name>parse_locktoken</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>char_token</name></decl></param>,
                <param><decl><type><name>dav_locktoken</name> **</type><name>locktoken_p</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>dav_locktoken</name> *</type><name>token</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>token</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="block">/* libsvn_fs already produces a valid locktoken URI. */</comment>
  <expr_stmt><expr><name><name>token</name>-&gt;<name>uuid_str</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>char_token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>locktoken_p</name> = <name>token</name></expr>;</expr_stmt>
  <return>return <expr>0</expr>;</return>
}</block></function>


<comment type="block">/* Format a lock token object into a URI string, allocated in
 * the given pool.
 *
 * Always returns non-NULL.
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type>
<name>format_locktoken</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>dav_locktoken</name> *</type><name>locktoken</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* libsvn_fs already produces a valid locktoken URI. */</comment>
  <return>return <expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>locktoken</name>-&gt;<name>uuid_str</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<comment type="block">/* Compare two lock tokens.
 *
 * Result &lt; 0  =&gt; lt1 &lt; lt2
 * Result == 0 =&gt; lt1 == lt2
 * Result &gt; 0  =&gt; lt1 &gt; lt2
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compare_locktoken</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>dav_locktoken</name> *</type><name>lt1</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>dav_locktoken</name> *</type><name>lt2</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>lt1</name>-&gt;<name>uuid_str</name></name></expr></argument>, <argument><expr><name><name>lt2</name>-&gt;<name>uuid_str</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<comment type="block">/* Open the provider's lock database.
 *
 * The provider may or may not use a "real" database for locks
 * (a lock could be an attribute on a resource, for example).
 *
 * The provider may choose to use the value of the DAVLockDB directive
 * (as returned by dav_get_lockdb_path()) to decide where to place
 * any storage it may need.
 *
 * The request storage pool should be associated with the lockdb,
 * so it can be used in subsequent operations.
 *
 * If ro != 0, only readonly operations will be performed.
 * If force == 0, the open can be "lazy"; no subsequent locking operations
 * may occur.
 * If force != 0, locking operations will definitely occur.
 */</comment>
<function><type><specifier>static</specifier> <name>dav_error</name> *</type>
<name>open_lockdb</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>, <param><decl><type><name>int</name></type> <name>ro</name></decl></param>, <param><decl><type><name>int</name></type> <name>force</name></decl></param>, <param><decl><type><name>dav_lockdb</name> **</type><name>lockdb</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>svn_client_options</name></decl>, *<decl><type ref="prev"/><name>version_name</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dav_lockdb</name> *</type><name>db</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>db</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dav_lockdb_private</name> *</type><name>info</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>info</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>info</name>-&gt;<name>r</name></name> = <name>r</name></expr>;</expr_stmt>

  <comment type="block">/* Is this an svn client? */</comment>

  <comment type="block">/* Check to see if an svn client sent any custom X-SVN-* headers in
     the request. */</comment>
  <expr_stmt><expr><name>svn_client_options</name> = <call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_in</name></name></expr></argument>, <argument><expr><name>SVN_DAV_OPTIONS_HEADER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>svn_client_options</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* 'svn [lock | unlock] --force' */</comment>
      <if>if <condition>(<expr><call><name>ap_strstr_c</name><argument_list>(<argument><expr><name>svn_client_options</name></expr></argument>, <argument><expr><name>SVN_DAV_OPTION_LOCK_BREAK</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><name><name>info</name>-&gt;<name>lock_break</name></name> = <name>TRUE</name></expr>;</expr_stmt></then></if>
      <if>if <condition>(<expr><call><name>ap_strstr_c</name><argument_list>(<argument><expr><name>svn_client_options</name></expr></argument>, <argument><expr><name>SVN_DAV_OPTION_LOCK_STEAL</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><name><name>info</name>-&gt;<name>lock_steal</name></name> = <name>TRUE</name></expr>;</expr_stmt></then></if>
      <if>if <condition>(<expr><call><name>ap_strstr_c</name><argument_list>(<argument><expr><name>svn_client_options</name></expr></argument>, <argument><expr><name>SVN_DAV_OPTION_KEEP_LOCKS</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><name><name>info</name>-&gt;<name>keep_locks</name></name> = <name>TRUE</name></expr>;</expr_stmt></then></if>
    }</block></then></if>

  <comment type="block">/* 'svn lock' wants to make svn_fs_lock() do an out-of-dateness check. */</comment>
  <expr_stmt><expr><name>version_name</name> = <call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_in</name></name></expr></argument>, <argument><expr><name>SVN_DAV_VERSION_NAME_HEADER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>info</name>-&gt;<name>working_revnum</name></name> = <name>version_name</name> ?
                         <call><name>SVN_STR_TO_REV</name><argument_list>(<argument><expr><name>version_name</name></expr></argument>)</argument_list></call>: <name>SVN_INVALID_REVNUM</name></expr>;</expr_stmt>

  <comment type="block">/* The generic lockdb structure.  */</comment>
  <expr_stmt><expr><name><name>db</name>-&gt;<name>hooks</name></name> = &amp;<name>dav_svn__hooks_locks</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name>-&gt;<name>ro</name></name> = <name>ro</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name>-&gt;<name>info</name></name> = <name>info</name></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>lockdb</name> = <name>db</name></expr>;</expr_stmt>
  <return>return <expr>0</expr>;</return>
}</block></function>


<comment type="block">/* Indicates completion of locking operations */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>close_lockdb</name><parameter_list>(<param><decl><type><name>dav_lockdb</name> *</type><name>lockdb</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* nothing to do here. */</comment>
  <return>return;</return>
}</block></function>


<comment type="block">/* Take a resource out of the lock-null state. */</comment>
<function><type><specifier>static</specifier> <name>dav_error</name> *</type>
<name>remove_locknull_state</name><parameter_list>(<param><decl><type><name>dav_lockdb</name> *</type><name>lockdb</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl></param>)</parameter_list>
<block>{

  <comment type="block">/* mod_dav_svn supports RFC2518bis which does not actually require
     the server to create lock-null resources.  Instead, we create
     zero byte files when a lock comes in on a non-existent path.
     mod_dav_svn never creates any lock-null resources, so this
     function is never called by mod_dav. */</comment>

  <return>return <expr>0</expr>;</return>  <comment type="block">/* Just to suppress compiler warnings. */</comment>
}</block></function>


<comment type="block">/*
** Create a (direct) lock structure for the given resource. A locktoken
** will be created.
**
** The lock provider may store private information into lock-&gt;info.
*/</comment>
<function><type><specifier>static</specifier> <name>dav_error</name> *</type>
<name>create_lock</name><parameter_list>(<param><decl><type><name>dav_lockdb</name> *</type><name>lockdb</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl></param>, <param><decl><type><name>dav_lock</name> **</type><name>lock</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>serr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dav_locktoken</name> *</type><name>token</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>token</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dav_lock</name> *</type><name>dlock</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>dlock</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>dlock</name>-&gt;<name>rectype</name></name> = <name>DAV_LOCKREC_DIRECT</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>dlock</name>-&gt;<name>is_locknull</name></name> = <name><name>resource</name>-&gt;<name>exists</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>dlock</name>-&gt;<name>scope</name></name> = <name>DAV_LOCKSCOPE_UNKNOWN</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>dlock</name>-&gt;<name>type</name></name> = <name>DAV_LOCKTYPE_UNKNOWN</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>dlock</name>-&gt;<name>depth</name></name> = 0</expr>;</expr_stmt>

  <expr_stmt><expr><name>serr</name> = <call><name>svn_fs_generate_lock_token</name><argument_list>(<argument><expr>&amp;(<name><name>token</name>-&gt;<name>uuid_str</name></name>)</expr></argument>,
                                    <argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>repos</name>-&gt;<name>fs</name></name></expr></argument>,
                                    <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>serr</name></expr>)</condition><then>
    <return>return <expr><call><name>dav_svn__convert_err</name><argument_list>(<argument><expr><name>serr</name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>,
                                <argument><expr>"Failed to generate a lock token."</expr></argument>,
                                <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>
  <expr_stmt><expr><name><name>dlock</name>-&gt;<name>locktoken</name></name> = <name>token</name></expr>;</expr_stmt>

  <comment type="block">/* allowing mod_dav to fill in dlock-&gt;timeout, owner, auth_user. */</comment>
  <comment type="block">/* dlock-&gt;info and dlock-&gt;next are NULL by default. */</comment>

  <expr_stmt><expr>*<name>lock</name> = <name>dlock</name></expr>;</expr_stmt>
  <return>return <expr>0</expr>;</return>
}</block></function>


<comment type="block">/*
** Get the locks associated with the specified resource.
**
** If resolve_locks is true (non-zero), then any indirect locks are
** resolved to their actual, direct lock (i.e. the reference to followed
** to the original lock).
**
** The locks, if any, are returned as a linked list in no particular
** order. If no locks are present, then *locks will be NULL.
**
** #define DAV_GETLOCKS_RESOLVED   0    -- resolve indirects to directs
** #define DAV_GETLOCKS_PARTIAL    1    -- leave indirects partially filled
** #define DAV_GETLOCKS_COMPLETE   2    -- fill out indirect locks
*/</comment>
<function><type><specifier>static</specifier> <name>dav_error</name> *</type>
<name>get_locks</name><parameter_list>(<param><decl><type><name>dav_lockdb</name> *</type><name>lockdb</name></decl></param>,
          <param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl></param>,
          <param><decl><type><name>int</name></type> <name>calltype</name></decl></param>,
          <param><decl><type><name>dav_lock</name> **</type><name>locks</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>dav_lockdb_private</name> *</type><name>info</name> <init>= <expr><name><name>lockdb</name>-&gt;<name>info</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>serr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_lock_t</name> *</type><name>slock</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dav_lock</name> *</type><name>lock</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* We only support exclusive locks, not shared ones.  So this
     function always returns a "list" of exactly one lock, or just a
     NULL list.  The 'calltype' arg is also meaningless, since we
     don't support locks on collections.  */</comment>

  <comment type="block">/* Sanity check:  if the resource has no associated path in the fs,
     then there's nothing to do.  */</comment>
  <if>if <condition>(<expr>! <name><name>resource</name>-&gt;<name>info</name>-&gt;<name>repos_path</name></name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr>*<name>locks</name> = <name>NULL</name></expr>;</expr_stmt>
      <return>return <expr>0</expr>;</return>
    }</block></then></if>

  <comment type="block">/* The Big Lie: if the client ran 'svn lock', then we have
     to pretend that there's no existing lock.  Otherwise mod_dav will
     throw '403 Locked' without even attempting to create a new
     lock.  For the --force case, this is required and for the non-force case,
     we allow the filesystem to produce a better error for svn clients.
  */</comment>
  <if>if <condition>(<expr><name><name>info</name>-&gt;<name>r</name>-&gt;<name>method_number</name></name> == <name>M_LOCK</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr>*<name>locks</name> = <name>NULL</name></expr>;</expr_stmt>
      <return>return <expr>0</expr>;</return>
    }</block></then></if>

  <comment type="block">/* If the resource's fs path is unreadable, we don't want to say
     anything about locks attached to it.*/</comment>
  <if>if <condition>(<expr>! <call><name>dav_svn__allow_read</name><argument_list>(<argument><expr><name>resource</name></expr></argument>, <argument><expr><name>SVN_INVALID_REVNUM</name></expr></argument>, <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>HTTP_FORBIDDEN</name></expr></argument>,
                         <argument><expr><name>DAV_ERR_LOCK_SAVE_LOCK</name></expr></argument>,
                         <argument><expr>"Path is not accessible."</expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><name>serr</name> = <call><name>svn_fs_get_lock</name><argument_list>(<argument><expr>&amp;<name>slock</name></expr></argument>,
                         <argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>repos</name>-&gt;<name>fs</name></name></expr></argument>,
                         <argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>repos_path</name></name></expr></argument>,
                         <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>serr</name></expr>)</condition><then>
    <return>return <expr><call><name>dav_svn__convert_err</name><argument_list>(<argument><expr><name>serr</name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>,
                                <argument><expr>"Failed to check path for a lock."</expr></argument>,
                                <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <if>if <condition>(<expr><name>slock</name> != <name>NULL</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>svn_lock_to_dav_lock</name><argument_list>(<argument><expr>&amp;<name>lock</name></expr></argument>, <argument><expr><name>slock</name></expr></argument>, <argument><expr><name><name>info</name>-&gt;<name>lock_break</name></name></expr></argument>,
                           <argument><expr><name><name>resource</name>-&gt;<name>exists</name></name></expr></argument>, <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Let svn clients know the creationdate of the slock. */</comment>
      <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>info</name>-&gt;<name>r</name>-&gt;<name>headers_out</name></name></expr></argument>, <argument><expr><name>SVN_DAV_CREATIONDATE_HEADER</name></expr></argument>,
                     <argument><expr><call><name>svn_time_to_cstring</name><argument_list>(<argument><expr><name><name>slock</name>-&gt;<name>creation_date</name></name></expr></argument>,
                                         <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Let svn clients know who "owns" the slock. */</comment>
      <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>info</name>-&gt;<name>r</name>-&gt;<name>headers_out</name></name></expr></argument>, <argument><expr><name>SVN_DAV_LOCK_OWNER_HEADER</name></expr></argument>,
                     <argument><expr><name><name>slock</name>-&gt;<name>owner</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <expr_stmt><expr>*<name>locks</name> = <name>lock</name></expr>;</expr_stmt>
  <return>return <expr>0</expr>;</return>
}</block></function>


<comment type="block">/*
** Find a particular lock on a resource (specified by its locktoken).
**
** *lock will be set to NULL if the lock is not found.
**
** Note that the provider can optimize the unmarshalling -- only one
** lock (or none) must be constructed and returned.
**
** If partial_ok is true (non-zero), then an indirect lock can be
** partially filled in. Otherwise, another lookup is done and the
** lock structure will be filled out as a DAV_LOCKREC_INDIRECT.
*/</comment>
<function><type><specifier>static</specifier> <name>dav_error</name> *</type>
<name>find_lock</name><parameter_list>(<param><decl><type><name>dav_lockdb</name> *</type><name>lockdb</name></decl></param>,
          <param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl></param>,
          <param><decl><type><specifier>const</specifier> <name>dav_locktoken</name> *</type><name>locktoken</name></decl></param>,
          <param><decl><type><name>int</name></type> <name>partial_ok</name></decl></param>,
          <param><decl><type><name>dav_lock</name> **</type><name>lock</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>dav_lockdb_private</name> *</type><name>info</name> <init>= <expr><name><name>lockdb</name>-&gt;<name>info</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>serr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_lock_t</name> *</type><name>slock</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dav_lock</name> *</type><name>dlock</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* If the resource's fs path is unreadable, we don't want to say
     anything about locks attached to it.*/</comment>
  <if>if <condition>(<expr>! <call><name>dav_svn__allow_read</name><argument_list>(<argument><expr><name>resource</name></expr></argument>, <argument><expr><name>SVN_INVALID_REVNUM</name></expr></argument>, <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>HTTP_FORBIDDEN</name></expr></argument>,
                         <argument><expr><name>DAV_ERR_LOCK_SAVE_LOCK</name></expr></argument>,
                         <argument><expr>"Path is not accessible."</expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><name>serr</name> = <call><name>svn_fs_get_lock</name><argument_list>(<argument><expr>&amp;<name>slock</name></expr></argument>,
                         <argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>repos</name>-&gt;<name>fs</name></name></expr></argument>,
                         <argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>repos_path</name></name></expr></argument>,
                         <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>serr</name></expr>)</condition><then>
    <return>return <expr><call><name>dav_svn__convert_err</name><argument_list>(<argument><expr><name>serr</name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>,
                                <argument><expr>"Failed to look up lock by path."</expr></argument>,
                                <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <if>if <condition>(<expr><name>slock</name> != <name>NULL</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* Sanity check. */</comment>
      <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>locktoken</name>-&gt;<name>uuid_str</name></name></expr></argument>, <argument><expr><name><name>slock</name>-&gt;<name>token</name></name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
        <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>HTTP_BAD_REQUEST</name></expr></argument>,
                             <argument><expr><name>DAV_ERR_LOCK_SAVE_LOCK</name></expr></argument>,
                             <argument><expr>"Incoming token doesn't match existing lock."</expr></argument>)</argument_list></call></expr>;</return></then></if>

      <expr_stmt><expr><call><name>svn_lock_to_dav_lock</name><argument_list>(<argument><expr>&amp;<name>dlock</name></expr></argument>, <argument><expr><name>slock</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                           <argument><expr><name><name>resource</name>-&gt;<name>exists</name></name></expr></argument>, <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Let svn clients know the creationdate of the slock. */</comment>
      <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>info</name>-&gt;<name>r</name>-&gt;<name>headers_out</name></name></expr></argument>, <argument><expr><name>SVN_DAV_CREATIONDATE_HEADER</name></expr></argument>,
                     <argument><expr><call><name>svn_time_to_cstring</name><argument_list>(<argument><expr><name><name>slock</name>-&gt;<name>creation_date</name></name></expr></argument>,
                                         <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Let svn clients know the 'owner' of the slock. */</comment>
      <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>info</name>-&gt;<name>r</name>-&gt;<name>headers_out</name></name></expr></argument>, <argument><expr><name>SVN_DAV_LOCK_OWNER_HEADER</name></expr></argument>,
                     <argument><expr><name><name>slock</name>-&gt;<name>owner</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <expr_stmt><expr>*<name>lock</name> = <name>dlock</name></expr>;</expr_stmt>
  <return>return <expr>0</expr>;</return>
}</block></function>


<comment type="block">/*
** Quick test to see if the resource has *any* locks on it.
**
** This is typically used to determine if a non-existent resource
** has a lock and is (therefore) a locknull resource.
**
** WARNING: this function may return TRUE even when timed-out locks
**          exist (i.e. it may not perform timeout checks).
*/</comment>
<function><type><specifier>static</specifier> <name>dav_error</name> *</type>
<name>has_locks</name><parameter_list>(<param><decl><type><name>dav_lockdb</name> *</type><name>lockdb</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl></param>, <param><decl><type><name>int</name> *</type><name>locks_present</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>dav_lockdb_private</name> *</type><name>info</name> <init>= <expr><name><name>lockdb</name>-&gt;<name>info</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>serr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_lock_t</name> *</type><name>slock</name></decl>;</decl_stmt>

  <comment type="block">/* Sanity check:  if the resource has no associated path in the fs,
     then there's nothing to do.  */</comment>
  <if>if <condition>(<expr>! <name><name>resource</name>-&gt;<name>info</name>-&gt;<name>repos_path</name></name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr>*<name>locks_present</name> = 0</expr>;</expr_stmt>
      <return>return <expr>0</expr>;</return>
    }</block></then></if>

  <comment type="block">/* The Big Lie: if the client ran 'svn lock', then we have
     to pretend that there's no existing lock.  Otherwise mod_dav will
     throw '403 Locked' without even attempting to create a new
     lock.  For the --force case, this is required and for the non-force case,
     we allow the filesystem to produce a better error for svn clients.
  */</comment>
  <if>if <condition>(<expr><name><name>info</name>-&gt;<name>r</name>-&gt;<name>method_number</name></name> == <name>M_LOCK</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr>*<name>locks_present</name> = 0</expr>;</expr_stmt>
      <return>return <expr>0</expr>;</return>
    }</block></then></if>

  <comment type="block">/* If the resource's fs path is unreadable, we don't want to say
     anything about locks attached to it.*/</comment>
  <if>if <condition>(<expr>! <call><name>dav_svn__allow_read</name><argument_list>(<argument><expr><name>resource</name></expr></argument>, <argument><expr><name>SVN_INVALID_REVNUM</name></expr></argument>, <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>HTTP_FORBIDDEN</name></expr></argument>,
                         <argument><expr><name>DAV_ERR_LOCK_SAVE_LOCK</name></expr></argument>,
                         <argument><expr>"Path is not accessible."</expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><name>serr</name> = <call><name>svn_fs_get_lock</name><argument_list>(<argument><expr>&amp;<name>slock</name></expr></argument>,
                         <argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>repos</name>-&gt;<name>fs</name></name></expr></argument>,
                         <argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>repos_path</name></name></expr></argument>,
                         <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>serr</name></expr>)</condition><then>
    <return>return <expr><call><name>dav_svn__convert_err</name><argument_list>(<argument><expr><name>serr</name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>,
                                <argument><expr>"Failed to check path for a lock."</expr></argument>,
                                <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr>*<name>locks_present</name> = <name>slock</name> ? 1 : 0</expr>;</expr_stmt>
  <return>return <expr>0</expr>;</return>
}</block></function>


<comment type="block">/*
** Append the specified lock(s) to the set of locks on this resource.
**
** If "make_indirect" is true (non-zero), then the specified lock(s)
** should be converted to an indirect lock (if it is a direct lock)
** before appending. Note that the conversion to an indirect lock does
** not alter the passed-in lock -- the change is internal the
** append_locks function.
**
** Multiple locks are specified using the lock-&gt;next links.
*/</comment>
<function><type><specifier>static</specifier> <name>dav_error</name> *</type>
<name>append_locks</name><parameter_list>(<param><decl><type><name>dav_lockdb</name> *</type><name>lockdb</name></decl></param>,
             <param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl></param>,
             <param><decl><type><name>int</name></type> <name>make_indirect</name></decl></param>,
             <param><decl><type><specifier>const</specifier> <name>dav_lock</name> *</type><name>lock</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>dav_lockdb_private</name> *</type><name>info</name> <init>= <expr><name><name>lockdb</name>-&gt;<name>info</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_lock_t</name> *</type><name>slock</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>serr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dav_error</name> *</type><name>derr</name></decl>;</decl_stmt>

  <comment type="block">/* If the resource's fs path is unreadable, we don't allow a lock to
     be created on it. */</comment>
  <if>if <condition>(<expr>! <call><name>dav_svn__allow_read</name><argument_list>(<argument><expr><name>resource</name></expr></argument>, <argument><expr><name>SVN_INVALID_REVNUM</name></expr></argument>, <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>HTTP_FORBIDDEN</name></expr></argument>,
                         <argument><expr><name>DAV_ERR_LOCK_SAVE_LOCK</name></expr></argument>,
                         <argument><expr>"Path is not accessible."</expr></argument>)</argument_list></call></expr>;</return></then></if>

  <if>if <condition>(<expr><name><name>lock</name>-&gt;<name>next</name></name></expr>)</condition><then>
    <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>HTTP_BAD_REQUEST</name></expr></argument>,
                         <argument><expr><name>DAV_ERR_LOCK_SAVE_LOCK</name></expr></argument>,
                         <argument><expr>"Tried to attach multiple locks to a resource."</expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* RFC2518bis (section 7.4) doesn't require us to support
     'lock-null' resources at all.  Instead, it asks that we treat
     'LOCK nonexistentURL' as a PUT (followed by a LOCK) of a 0-byte file.  */</comment>
  <if>if <condition>(<expr>! <name><name>resource</name>-&gt;<name>exists</name></name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl>, <decl><type ref="prev"/><name>new_rev</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_fs_txn_t</name> *</type><name>txn</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>txn_root</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>conflict_msg</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>dav_svn_repos</name> *</type><name>repos</name> <init>= <expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>repos</name></name></expr></init></decl>;</decl_stmt>

      <if>if <condition>(<expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>repos</name>-&gt;<name>is_svn_client</name></name></expr>)</condition><then>
        <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>HTTP_METHOD_NOT_ALLOWED</name></expr></argument>,
                             <argument><expr><name>DAV_ERR_LOCK_SAVE_LOCK</name></expr></argument>,
                             <argument><expr>"Subversion clients may not lock "
                             "nonexistent paths."</expr></argument>)</argument_list></call></expr>;</return></then>

      <else>else <if>if <condition>(<expr>! <name><name>resource</name>-&gt;<name>info</name>-&gt;<name>repos</name>-&gt;<name>autoversioning</name></name></expr>)</condition><then>
        <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>HTTP_METHOD_NOT_ALLOWED</name></expr></argument>,
                             <argument><expr><name>DAV_ERR_LOCK_SAVE_LOCK</name></expr></argument>,
                             <argument><expr>"Attempted to lock non-existent path;"
                             " turn on autoversioning first."</expr></argument>)</argument_list></call></expr>;</return></then></if></else></if>

      <comment type="block">/* Commit a 0-byte file: */</comment>

      <if>if <condition>(<expr>(<name>serr</name> = <call><name>svn_fs_youngest_rev</name><argument_list>(<argument><expr>&amp;<name>rev</name></expr></argument>, <argument><expr><name><name>repos</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
        <return>return <expr><call><name>dav_svn__convert_err</name><argument_list>(<argument><expr><name>serr</name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>,
                                    <argument><expr>"Could not determine youngest revision"</expr></argument>,
                                    <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>

      <if>if <condition>(<expr>(<name>serr</name> = <call><name>svn_repos_fs_begin_txn_for_commit</name><argument_list>(<argument><expr>&amp;<name>txn</name></expr></argument>, <argument><expr><name><name>repos</name>-&gt;<name>repos</name></name></expr></argument>, <argument><expr><name>rev</name></expr></argument>,
                                                    <argument><expr><name><name>repos</name>-&gt;<name>username</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                                    <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
        <return>return <expr><call><name>dav_svn__convert_err</name><argument_list>(<argument><expr><name>serr</name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>,
                                    <argument><expr>"Could not begin a transaction"</expr></argument>,
                                    <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>

      <if>if <condition>(<expr>(<name>serr</name> = <call><name>svn_fs_txn_root</name><argument_list>(<argument><expr>&amp;<name>txn_root</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>, <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
        <return>return <expr><call><name>dav_svn__convert_err</name><argument_list>(<argument><expr><name>serr</name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>,
                                    <argument><expr>"Could not begin a transaction"</expr></argument>,
                                    <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>

      <if>if <condition>(<expr>(<name>serr</name> = <call><name>svn_fs_make_file</name><argument_list>(<argument><expr><name>txn_root</name></expr></argument>, <argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>repos_path</name></name></expr></argument>,
                                   <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
        <return>return <expr><call><name>dav_svn__convert_err</name><argument_list>(<argument><expr><name>serr</name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>,
                                    <argument><expr>"Could not create empty file."</expr></argument>,
                                    <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>

      <if>if <condition>(<expr>(<name>serr</name> = <call><name>dav_svn__attach_auto_revprops</name><argument_list>(<argument><expr><name>txn</name></expr></argument>,
                                                <argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>repos_path</name></name></expr></argument>,
                                                <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
        <return>return <expr><call><name>dav_svn__convert_err</name><argument_list>(<argument><expr><name>serr</name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>,
                                    <argument><expr>"Could not create empty file."</expr></argument>,
                                    <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>

      <if>if <condition>(<expr>(<name>serr</name> = <call><name>svn_repos_fs_commit_txn</name><argument_list>(<argument><expr>&amp;<name>conflict_msg</name></expr></argument>, <argument><expr><name><name>repos</name>-&gt;<name>repos</name></name></expr></argument>,
                                          <argument><expr>&amp;<name>new_rev</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>, <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><call><name>svn_fs_abort_txn</name><argument_list>(<argument><expr><name>txn</name></expr></argument>, <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><call><name>dav_svn__convert_err</name><argument_list>(<argument><expr><name>serr</name></expr></argument>, <argument><expr><name>HTTP_CONFLICT</name></expr></argument>,
                                      <argument><expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>,
                                                   <argument><expr>"Conflict when committing "
                                                   "'%s'."</expr></argument>, <argument><expr><name>conflict_msg</name></expr></argument>)</argument_list></call></expr></argument>,
                                      <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
    }</block></then></if>

  <comment type="block">/* Convert the dav_lock into an svn_lock_t. */</comment>
  <expr_stmt><expr><name>derr</name> = <call><name>dav_lock_to_svn_lock</name><argument_list>(<argument><expr>&amp;<name>slock</name></expr></argument>, <argument><expr><name>lock</name></expr></argument>, <argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>repos_path</name></name></expr></argument>,
                              <argument><expr><name>info</name></expr></argument>, <argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>repos</name>-&gt;<name>is_svn_client</name></name></expr></argument>,
                              <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>derr</name></expr>)</condition><then>
    <return>return <expr><name>derr</name></expr>;</return></then></if>

  <comment type="block">/* Now use the svn_lock_t to actually perform the lock. */</comment>
  <expr_stmt><expr><name>serr</name> = <call><name>svn_repos_fs_lock</name><argument_list>(<argument><expr>&amp;<name>slock</name></expr></argument>,
                           <argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>repos</name>-&gt;<name>repos</name></name></expr></argument>,
                           <argument><expr><name><name>slock</name>-&gt;<name>path</name></name></expr></argument>,
                           <argument><expr><name><name>slock</name>-&gt;<name>token</name></name></expr></argument>,
                           <argument><expr><name><name>slock</name>-&gt;<name>comment</name></name></expr></argument>,
                           <argument><expr><name><name>slock</name>-&gt;<name>is_dav_comment</name></name></expr></argument>,
                           <argument><expr><name><name>slock</name>-&gt;<name>expiration_date</name></name></expr></argument>,
                           <argument><expr><name><name>info</name>-&gt;<name>working_revnum</name></name></expr></argument>,
                           <argument><expr><name><name>info</name>-&gt;<name>lock_steal</name></name></expr></argument>,
                           <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>serr</name> &amp;&amp; <name><name>serr</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_FS_NO_USER</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>serr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>HTTP_UNAUTHORIZED</name></expr></argument>,
                           <argument><expr><name>DAV_ERR_LOCK_SAVE_LOCK</name></expr></argument>,
                           <argument><expr>"Anonymous lock creation is not allowed."</expr></argument>)</argument_list></call></expr>;</return>
    }</block></then>
  <else>else <if>if <condition>(<expr><name>serr</name></expr>)</condition><then>
    <return>return <expr><call><name>dav_svn__convert_err</name><argument_list>(<argument><expr><name>serr</name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>,
                                <argument><expr>"Failed to create new lock."</expr></argument>,
                                <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if></else></if>


  <comment type="block">/* A standard webdav LOCK response doesn't include any information
     about the creation date.  We send it in a custom header, so that
     svn clients can fill in svn_lock_t-&gt;creation_date.  A generic DAV
     client should just ignore the header. */</comment>
  <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>info</name>-&gt;<name>r</name>-&gt;<name>headers_out</name></name></expr></argument>, <argument><expr><name>SVN_DAV_CREATIONDATE_HEADER</name></expr></argument>,
                 <argument><expr><call><name>svn_time_to_cstring</name><argument_list>(<argument><expr><name><name>slock</name>-&gt;<name>creation_date</name></name></expr></argument>, <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* A standard webdav LOCK response doesn't include any information
     about the owner of the lock.  ('DAV:owner' has nothing to do with
     authorization, it's just a comment that we map to
     svn_lock_t-&gt;comment.)  We send the owner in a custom header, so
     that svn clients can fill in svn_lock_t-&gt;owner.  A generic DAV
     client should just ignore the header. */</comment>
  <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>info</name>-&gt;<name>r</name>-&gt;<name>headers_out</name></name></expr></argument>, <argument><expr><name>SVN_DAV_LOCK_OWNER_HEADER</name></expr></argument>,
                 <argument><expr><name><name>slock</name>-&gt;<name>owner</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Log the locking as a 'high-level' action. */</comment>
  <expr_stmt><expr><call><name>dav_svn__operational_log</name><argument_list>(<argument><expr><name><name>resource</name>-&gt;<name>info</name></name></expr></argument>,
                           <argument><expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>r</name>-&gt;<name>pool</name></name></expr></argument>,
                                        <argument><expr>"lock (%s)%s"</expr></argument>,
                                        <argument><expr><call><name>svn_path_uri_encode</name><argument_list>(<argument><expr><name><name>slock</name>-&gt;<name>path</name></name></expr></argument>,
                                                 <argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>r</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                        <argument><expr><name><name>info</name>-&gt;<name>lock_steal</name></name> ? " steal" : ""</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr>0</expr>;</return>
}</block></function>


<comment type="block">/*
** Remove any lock that has the specified locktoken.
**
** If locktoken == NULL, then ALL locks are removed.
*/</comment>
<function><type><specifier>static</specifier> <name>dav_error</name> *</type>
<name>remove_lock</name><parameter_list>(<param><decl><type><name>dav_lockdb</name> *</type><name>lockdb</name></decl></param>,
            <param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl></param>,
            <param><decl><type><specifier>const</specifier> <name>dav_locktoken</name> *</type><name>locktoken</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>dav_lockdb_private</name> *</type><name>info</name> <init>= <expr><name><name>lockdb</name>-&gt;<name>info</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>serr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_lock_t</name> *</type><name>slock</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>token</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Sanity check:  if the resource has no associated path in the fs,
     then there's nothing to do.  */</comment>
  <if>if <condition>(<expr>! <name><name>resource</name>-&gt;<name>info</name>-&gt;<name>repos_path</name></name></expr>)</condition><then>
    <return>return <expr>0</expr>;</return></then></if>

  <comment type="block">/* Another easy out: if an svn client sent a 'keep_locks' header
     (typically in a DELETE request, as part of 'svn commit
     --no-unlock'), then ignore dav_method_delete()'s attempt to
     unconditionally remove the lock.  */</comment>
  <if>if <condition>(<expr><name><name>info</name>-&gt;<name>keep_locks</name></name></expr>)</condition><then>
    <return>return <expr>0</expr>;</return></then></if>

  <comment type="block">/* If the resource's fs path is unreadable, we don't allow a lock to
     be removed from it. */</comment>
  <if>if <condition>(<expr>! <call><name>dav_svn__allow_read</name><argument_list>(<argument><expr><name>resource</name></expr></argument>, <argument><expr><name>SVN_INVALID_REVNUM</name></expr></argument>, <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>HTTP_FORBIDDEN</name></expr></argument>,
                         <argument><expr><name>DAV_ERR_LOCK_SAVE_LOCK</name></expr></argument>,
                         <argument><expr>"Path is not accessible."</expr></argument>)</argument_list></call></expr>;</return></then></if>

  <if>if <condition>(<expr><name>locktoken</name> == <name>NULL</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* Need to manually discover any lock on the resource. */</comment>
      <expr_stmt><expr><name>serr</name> = <call><name>svn_fs_get_lock</name><argument_list>(<argument><expr>&amp;<name>slock</name></expr></argument>,
                             <argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>repos</name>-&gt;<name>fs</name></name></expr></argument>,
                             <argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>repos_path</name></name></expr></argument>,
                             <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>serr</name></expr>)</condition><then>
        <return>return <expr><call><name>dav_svn__convert_err</name><argument_list>(<argument><expr><name>serr</name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>,
                                    <argument><expr>"Failed to check path for a lock."</expr></argument>,
                                    <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>
      <if>if <condition>(<expr><name>slock</name></expr>)</condition><then>
        <expr_stmt><expr><name>token</name> = <name><name>slock</name>-&gt;<name>token</name></name></expr>;</expr_stmt></then></if>
    }</block></then>
  <else>else
    <block>{
      <expr_stmt><expr><name>token</name> = <name><name>locktoken</name>-&gt;<name>uuid_str</name></name></expr>;</expr_stmt>
    }</block></else></if>

  <if>if <condition>(<expr><name>token</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* Notice that a generic DAV client is unable to forcibly
         'break' a lock, because info-&gt;lock_break will always be
         FALSE.  An svn client, however, can request a 'forced' break.*/</comment>
      <expr_stmt><expr><name>serr</name> = <call><name>svn_repos_fs_unlock</name><argument_list>(<argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>repos</name>-&gt;<name>repos</name></name></expr></argument>,
                                 <argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>repos_path</name></name></expr></argument>,
                                 <argument><expr><name>token</name></expr></argument>,
                                 <argument><expr><name><name>info</name>-&gt;<name>lock_break</name></name></expr></argument>,
                                 <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr><name>serr</name> &amp;&amp; <name><name>serr</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_FS_NO_USER</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>serr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>HTTP_UNAUTHORIZED</name></expr></argument>,
                               <argument><expr><name>DAV_ERR_LOCK_SAVE_LOCK</name></expr></argument>,
                               <argument><expr>"Anonymous lock removal is not allowed."</expr></argument>)</argument_list></call></expr>;</return>
        }</block></then>
      <else>else <if>if <condition>(<expr><name>serr</name></expr>)</condition><then>
        <return>return <expr><call><name>dav_svn__convert_err</name><argument_list>(<argument><expr><name>serr</name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>,
                                    <argument><expr>"Failed to remove a lock."</expr></argument>,
                                    <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if></else></if>

      <comment type="block">/* Log the unlocking as a 'high-level' action. */</comment>
      <expr_stmt><expr><call><name>dav_svn__operational_log</name><argument_list>(<argument><expr><name><name>resource</name>-&gt;<name>info</name></name></expr></argument>,
                               <argument><expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>r</name>-&gt;<name>pool</name></name></expr></argument>,
                                 <argument><expr>"unlock (%s)%s"</expr></argument>,
                                 <argument><expr><call><name>svn_path_uri_encode</name><argument_list>(<argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>repos_path</name></name></expr></argument>,
                                                     <argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>r</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                            <argument><expr><name><name>info</name>-&gt;<name>lock_break</name></name> ? " break" : ""</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <return>return <expr>0</expr>;</return>
}</block></function>


<comment type="block">/*
** Refresh all locks, found on the specified resource, which has a
** locktoken in the provided list.
**
** If the lock is indirect, then the direct lock is referenced and
** refreshed.
**
** Each lock that is updated is returned in the &lt;locks&gt; argument.
** Note that the locks will be fully resolved.
*/</comment>
<function><type><specifier>static</specifier> <name>dav_error</name> *</type>
<name>refresh_locks</name><parameter_list>(<param><decl><type><name>dav_lockdb</name> *</type><name>lockdb</name></decl></param>,
              <param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl></param>,
              <param><decl><type><specifier>const</specifier> <name>dav_locktoken_list</name> *</type><name>ltl</name></decl></param>,
              <param><decl><type><name>time_t</name></type> <name>new_time</name></decl></param>,
              <param><decl><type><name>dav_lock</name> **</type><name>locks</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* We're not looping over a list of locks, since we only support one
     lock per resource. */</comment>
  <decl_stmt><decl><type><name>dav_locktoken</name> *</type><name>token</name> <init>= <expr><name><name>ltl</name>-&gt;<name>locktoken</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>serr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_lock_t</name> *</type><name>slock</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dav_lock</name> *</type><name>dlock</name></decl>;</decl_stmt>

  <comment type="block">/* If the resource's fs path is unreadable, we don't want to say
     anything about locks attached to it.*/</comment>
  <if>if <condition>(<expr>! <call><name>dav_svn__allow_read</name><argument_list>(<argument><expr><name>resource</name></expr></argument>, <argument><expr><name>SVN_INVALID_REVNUM</name></expr></argument>, <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>HTTP_FORBIDDEN</name></expr></argument>,
                         <argument><expr><name>DAV_ERR_LOCK_SAVE_LOCK</name></expr></argument>,
                         <argument><expr>"Path is not accessible."</expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Convert the path into an svn_lock_t. */</comment>
  <expr_stmt><expr><name>serr</name> = <call><name>svn_fs_get_lock</name><argument_list>(<argument><expr>&amp;<name>slock</name></expr></argument>,
                         <argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>repos</name>-&gt;<name>fs</name></name></expr></argument>,
                         <argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>repos_path</name></name></expr></argument>,
                         <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>serr</name></expr>)</condition><then>
    <return>return <expr><call><name>dav_svn__convert_err</name><argument_list>(<argument><expr><name>serr</name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>,
                                <argument><expr>"Token doesn't point to a lock."</expr></argument>,
                                <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Sanity check: does the incoming token actually represent the
     current lock on the incoming resource? */</comment>
  <if>if <condition>(<expr>(! <name>slock</name>)
      || (<call><name>strcmp</name><argument_list>(<argument><expr><name><name>token</name>-&gt;<name>uuid_str</name></name></expr></argument>, <argument><expr><name><name>slock</name>-&gt;<name>token</name></name></expr></argument>)</argument_list></call> != 0)</expr>)</condition><then>
    <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>HTTP_UNAUTHORIZED</name></expr></argument>,
                         <argument><expr><name>DAV_ERR_LOCK_SAVE_LOCK</name></expr></argument>,
                         <argument><expr>"Lock refresh request doesn't match existing lock."</expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Now use the tweaked svn_lock_t to 'refresh' the existing lock. */</comment>
  <expr_stmt><expr><name>serr</name> = <call><name>svn_repos_fs_lock</name><argument_list>(<argument><expr>&amp;<name>slock</name></expr></argument>,
                           <argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>repos</name>-&gt;<name>repos</name></name></expr></argument>,
                           <argument><expr><name><name>slock</name>-&gt;<name>path</name></name></expr></argument>,
                           <argument><expr><name><name>slock</name>-&gt;<name>token</name></name></expr></argument>,
                           <argument><expr><name><name>slock</name>-&gt;<name>comment</name></name></expr></argument>,
                           <argument><expr><name><name>slock</name>-&gt;<name>is_dav_comment</name></name></expr></argument>,
                           <argument><expr>(<name>new_time</name> == <name>DAV_TIMEOUT_INFINITE</name>)
                             ? 0 : (<name>apr_time_t</name>)<name>new_time</name> * <name>APR_USEC_PER_SEC</name></expr></argument>,
                           <argument><expr><name>SVN_INVALID_REVNUM</name></expr></argument>,
                           <argument><expr><name>TRUE</name></expr></argument>, <comment type="block">/* forcibly steal existing lock */</comment>
                           <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>serr</name> &amp;&amp; <name><name>serr</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_FS_NO_USER</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>serr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>HTTP_UNAUTHORIZED</name></expr></argument>,
                           <argument><expr><name>DAV_ERR_LOCK_SAVE_LOCK</name></expr></argument>,
                           <argument><expr>"Anonymous lock refreshing is not allowed."</expr></argument>)</argument_list></call></expr>;</return>
    }</block></then>
  <else>else <if>if <condition>(<expr><name>serr</name></expr>)</condition><then>
    <return>return <expr><call><name>dav_svn__convert_err</name><argument_list>(<argument><expr><name>serr</name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>,
                                <argument><expr>"Failed to refresh existing lock."</expr></argument>,
                                <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if></else></if>

  <comment type="block">/* Convert the refreshed lock into a dav_lock and return it. */</comment>
  <expr_stmt><expr><call><name>svn_lock_to_dav_lock</name><argument_list>(<argument><expr>&amp;<name>dlock</name></expr></argument>, <argument><expr><name>slock</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name><name>resource</name>-&gt;<name>exists</name></name></expr></argument>, <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>locks</name> = <name>dlock</name></expr>;</expr_stmt>

  <return>return <expr>0</expr>;</return>
}</block></function>


<comment type="block">/* The main locking vtable, provided to mod_dav */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>dav_hooks_locks</name></type> <name>dav_svn__hooks_locks</name> <init>= <expr><block>{
  <expr><name>get_supportedlock</name></expr>,
  <expr><name>parse_locktoken</name></expr>,
  <expr><name>format_locktoken</name></expr>,
  <expr><name>compare_locktoken</name></expr>,
  <expr><name>open_lockdb</name></expr>,
  <expr><name>close_lockdb</name></expr>,
  <expr><name>remove_locknull_state</name></expr>,
  <expr><name>create_lock</name></expr>,
  <expr><name>get_locks</name></expr>,
  <expr><name>find_lock</name></expr>,
  <expr><name>has_locks</name></expr>,
  <expr><name>append_locks</name></expr>,
  <expr><name>remove_lock</name></expr>,
  <expr><name>refresh_locks</name></expr>,
  <expr><name>NULL</name></expr>,
  <expr><name>NULL</name></expr>                          <comment type="block">/* hook structure context */</comment>
}</block></expr></init></decl>;</decl_stmt>
</unit>
