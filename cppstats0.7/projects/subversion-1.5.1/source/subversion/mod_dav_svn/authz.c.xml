<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/subversion-1.5.1/source/subversion/mod_dav_svn/authz.c"><comment type="block">/*
 * authz.c: authorization related code
 *
 * ====================================================================
 * Copyright (c) 2000-2006 CollabNet.  All rights reserved.
 *
 * This software is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at http://subversion.tigris.org/license-1.html.
 * If newer versions of this license are posted there, you may use a
 * newer version instead, at your option.
 *
 * This software consists of voluntary contributions made by many
 * individuals.  For exact contribution history, see the revision
 * history and logs, available at http://subversion.tigris.org/.
 * ====================================================================
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;http_request.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;http_log.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_pools.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_path.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mod_authz_svn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dav_svn.h"</cpp:file></cpp:include>


<comment type="block">/* Convert incoming REV and PATH from request R into a version-resource URI
   for REPOS and perform a GET subrequest on it.  This will invoke any authz
   modules loaded into apache.  Return TRUE if the subrequest succeeds, FALSE
   otherwise. If REV is SVN_INVALID_REVNUM, then we look at HEAD.
*/</comment>
<function><type><specifier>static</specifier> <name>svn_boolean_t</name></type>
<name>allow_read</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>,
           <param><decl><type><specifier>const</specifier> <name>dav_svn_repos</name> *</type><name>repos</name></decl></param>,
           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
           <param><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl></param>,
           <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>uri</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>request_rec</name> *</type><name>subreq</name></decl>;</decl_stmt>
  <enum>enum <name>dav_svn__build_what</name> <name>uri_type</name>;</enum>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>allowed</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>authz_svn__subreq_bypass_func_t</name></type> <name>allow_read_bypass</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Easy out:  if the admin has explicitly set 'SVNPathAuthz Off',
     then this whole callback does nothing. */</comment>
  <if>if <condition>(<expr>! <call><name>dav_svn__get_pathauthz_flag</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <return>return <expr><name>TRUE</name></expr>;</return>
    }</block></then></if>

  <comment type="block">/* If bypass is specified and authz has exported the provider.
     Otherwise, we fall through to the full version.  This should be
     safer than allowing or disallowing all accesses if there is a
     configuration error.
     XXX: Is this the proper thing to do in this case? */</comment>
  <expr_stmt><expr><name>allow_read_bypass</name> = <call><name>dav_svn__get_pathauthz_bypass</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>allow_read_bypass</name> != <name>NULL</name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr><call><name>allow_read_bypass</name><argument_list>(<argument><expr><name>r</name></expr></argument>,<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>repos</name>-&gt;<name>repo_name</name></name></expr></argument>)</argument_list></call> == <name>OK</name></expr>)</condition><then>
        <return>return <expr><name>TRUE</name></expr>;</return></then>
      <else>else
        <return>return <expr><name>FALSE</name></expr>;</return></else></if>
    }</block></then></if>

  <comment type="block">/* If no revnum is specified, assume HEAD. */</comment>
  <if>if <condition>(<expr><call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name>rev</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <expr_stmt><expr><name>uri_type</name> = <name>DAV_SVN__BUILD_URI_VERSION</name></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name>uri_type</name> = <name>DAV_SVN__BUILD_URI_PUBLIC</name></expr>;</expr_stmt></else></if>

  <comment type="block">/* Build a Version Resource uri representing (rev, path). */</comment>
  <expr_stmt><expr><name>uri</name> = <call><name>dav_svn__build_uri</name><argument_list>(<argument><expr><name>repos</name></expr></argument>, <argument><expr><name>uri_type</name></expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check if GET would work against this uri. */</comment>
  <expr_stmt><expr><name>subreq</name> = <call><name>ap_sub_req_method_uri</name><argument_list>(<argument><expr>"GET"</expr></argument>, <argument><expr><name>uri</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>output_filters</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>subreq</name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr><name><name>subreq</name>-&gt;<name>status</name></name> == <name>HTTP_OK</name></expr>)</condition><then>
        <expr_stmt><expr><name>allowed</name> = <name>TRUE</name></expr>;</expr_stmt></then></if>

      <expr_stmt><expr><call><name>ap_destroy_sub_req</name><argument_list>(<argument><expr><name>subreq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <return>return <expr><name>allowed</name></expr>;</return>
}</block></function>


<comment type="block">/* This function implements 'svn_repos_authz_func_t', specifically
   for read authorization.

   Convert incoming ROOT and PATH into a version-resource URI and
   perform a GET subrequest on it.  This will invoke any authz modules
   loaded into apache.  Set *ALLOWED to TRUE if the subrequest
   succeeds, FALSE otherwise.

   BATON must be a pointer to a dav_svn__authz_read_baton.
   Use POOL for for any temporary allocation.
*/</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>authz_read</name><parameter_list>(<param><decl><type><name>svn_boolean_t</name> *</type><name>allowed</name></decl></param>,
           <param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
           <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>,
           <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>dav_svn__authz_read_baton</name> *</type><name>arb</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>rev</name> <init>= <expr><name>SVN_INVALID_REVNUM</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>revpath</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Our ultimate goal here is to create a Version Resource (VR) url,
     which is a url that represents a path within a revision.  We then
     send a subrequest to apache, so that any installed authz modules
     can allow/disallow the path.

     ### That means that we're assuming that any installed authz
     module is *only* paying attention to revision-paths, not paths in
     uncommitted transactions.  Someday we need to widen our horizons. */</comment>

  <if>if <condition>(<expr><call><name>svn_fs_is_txn_root</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <comment type="block">/* This means svn_repos_dir_delta2 is comparing two txn trees,
         rather than a txn and revision.  It's probably updating a
         working copy that contains 'disjoint urls'.

         Because the 2nd transaction is likely to have all sorts of
         paths linked in from random places, we need to find the
         original (rev,path) of each txn path.  That's what needs
         authorization.  */</comment>

      <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>path_s</name> <init>= <expr><call><name>svn_stringbuf_create</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>lopped_path</name> <init>= <expr>""</expr></init></decl>;</decl_stmt>

      <comment type="block">/* The path might be copied implicitly, because it's down in a
         copied tree.  So we start at path and walk up its parents
         asking if anyone was copied, and if so where from.  */</comment>
      <while>while <condition>(<expr>! (<call><name>svn_path_is_empty</name><argument_list>(<argument><expr><name><name>path_s</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call>
                || ((<name><name>path_s</name>-&gt;<name>len</name></name> == 1) &amp;&amp; (<name><name>path_s</name>-&gt;<name>data</name><index>[<expr>0</expr>]</index></name> == '/')))</expr>)</condition>
        <block>{
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_copied_from</name><argument_list>(<argument><expr>&amp;<name>rev</name></expr></argument>, <argument><expr>&amp;<name>revpath</name></expr></argument>, <argument><expr><name>root</name></expr></argument>,
                                     <argument><expr><name><name>path_s</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <if>if <condition>(<expr><call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name>rev</name></expr></argument>)</argument_list></call> &amp;&amp; <name>revpath</name></expr>)</condition><then>
            <block>{
              <expr_stmt><expr><name>revpath</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>revpath</name></expr></argument>, <argument><expr><name>lopped_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <break>break;</break>
            }</block></then></if>

          <comment type="block">/* Lop off the basename and try again. */</comment>
          <expr_stmt><expr><name>lopped_path</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><call><name>svn_path_basename</name>
                                      <argument_list>(<argument><expr><name><name>path_s</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>lopped_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>svn_path_remove_component</name><argument_list>(<argument><expr><name>path_s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></while>

      <comment type="block">/* If no copy produced this path, its path in the original
         revision is the same as its path in this txn. */</comment>
      <if>if <condition>(<expr>(<name>rev</name> == <name>SVN_INVALID_REVNUM</name>) &amp;&amp; (<name>revpath</name> == <name>NULL</name>)</expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>rev</name> = <call><name>svn_fs_txn_root_base_revision</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>revpath</name> = <name>path</name></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then>
  <else>else  <comment type="block">/* revision root */</comment>
    <block>{
      <expr_stmt><expr><name>rev</name> = <call><name>svn_fs_revision_root_revision</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>revpath</name> = <name>path</name></expr>;</expr_stmt>
    }</block></else></if>

  <comment type="block">/* We have a (rev, path) pair to check authorization on. */</comment>
  <expr_stmt><expr>*<name>allowed</name> = <call><name>allow_read</name><argument_list>(<argument><expr><name><name>arb</name>-&gt;<name>r</name></name></expr></argument>, <argument><expr><name><name>arb</name>-&gt;<name>repos</name></name></expr></argument>, <argument><expr><name>revpath</name></expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_repos_authz_func_t</name></type>
<name>dav_svn__authz_read_func</name><parameter_list>(<param><decl><type><name>dav_svn__authz_read_baton</name> *</type><name>baton</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* Easy out: If the admin has explicitly set 'SVNPathAuthz Off',
     then we don't need to do any authorization checks. */</comment>
  <if>if <condition>(<expr>! <call><name>dav_svn__get_pathauthz_flag</name><argument_list>(<argument><expr><name><name>baton</name>-&gt;<name>r</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>NULL</name></expr>;</return></then></if>

  <return>return <expr><name>authz_read</name></expr>;</return>
}</block></function>


<function><type><name>svn_boolean_t</name></type>
<name>dav_svn__allow_read</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl></param>,
                   <param><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl></param>,
                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>allow_read</name><argument_list>(<argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>r</name></name></expr></argument>, <argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>repos</name></name></expr></argument>,
                    <argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>repos_path</name></name></expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
</unit>
