<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/subversion-1.5.1/source/subversion/mod_dav_svn/repos.c"><comment type="block">/*
 * repos.c: mod_dav_svn repository provider functions for Subversion
 *
 * ====================================================================
 * Copyright (c) 2000-2007 CollabNet.  All rights reserved.
 *
 * This software is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at http://subversion.tigris.org/license-1.html.
 * If newer versions of this license are posted there, you may use a
 * newer version instead, at your option.
 *
 * This software consists of voluntary contributions made by many
 * individuals.  For exact contribution history, see the revision
 * history and logs, available at http://subversion.tigris.org/.
 * ====================================================================
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APR_WANT_STRFUNC</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_want.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_strings.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_hash.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_lib.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;httpd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;http_request.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;http_protocol.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;http_log.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;http_core.h&gt;</cpp:file></cpp:include>  <comment type="block">/* for ap_construct_url */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;mod_dav.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_types.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_pools.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_error.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_time.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_fs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_repos.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_dav.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_sorts.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_version.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_props.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mod_dav_svn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_ra.h"</cpp:file></cpp:include>  <comment type="block">/* for SVN_RA_CAPABILITY_* */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dav_svn.h"</cpp:file></cpp:include>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_ACTIVITY_DB</name></cpp:macro> <cpp:value>"dav/activities.d"</cpp:value></cpp:define>


<struct>struct <name>dav_stream</name> <block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>res</name></decl>;</decl_stmt>

  <comment type="block">/* for reading from the FS */</comment>
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>rstream</name></decl>;</decl_stmt>

  <comment type="block">/* for writing to the FS. we use wstream OR the handler/baton. */</comment>
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>wstream</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_txdelta_window_handler_t</name></type> <name>delta_handler</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> *</type><name>delta_baton</name></decl>;</decl_stmt>
}</block>;</struct>


<comment type="block">/* Convenience structure that facilitates combined memory allocation of
   a dav_resource and dav_resource_private pair. */</comment>
<typedef>typedef <type><struct>struct <block>{
  <decl_stmt><decl><type><name>dav_resource</name></type> <name>res</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dav_resource_private</name></type> <name>priv</name></decl>;</decl_stmt>
}</block></struct></type> <name>dav_resource_combined</name>;</typedef>


<comment type="block">/* Helper-wrapper around svn_fs_check_path(), which takes the same
   arguments.  But: if we attempt to stat a path like "file1/file2",
   then still return 'svn_node_none' to signal nonexistence, rather
   than a full-blown filesystem error.  This allows mod_dav to throw
   404 instead of 500. */</comment>
<function><type><specifier>static</specifier> <name>dav_error</name> *</type>
<name>fs_check_path</name><parameter_list>(<param><decl><type><name>svn_node_kind_t</name> *</type><name>kind</name></decl></param>,
              <param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
              <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
              <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>serr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>my_kind</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>serr</name> = <call><name>svn_fs_check_path</name><argument_list>(<argument><expr>&amp;<name>my_kind</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Possibly trap other fs-errors here someday -- errors which may
     simply indicate the path's nonexistence, rather than a critical
     problem. */</comment>
  <if>if <condition>(<expr><name>serr</name> &amp;&amp; <name><name>serr</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_FS_NOT_DIRECTORY</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>serr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>kind</name> = <name>svn_node_none</name></expr>;</expr_stmt>
      <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then>
  <else>else <if>if <condition>(<expr><name>serr</name></expr>)</condition><then>
    <block>{
      <return>return <expr><call><name>dav_svn__convert_err</name><argument_list>(<argument><expr><name>serr</name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>,
                                  <argument><expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"Error checking kind of "
                                               "path '%s' in repository"</expr></argument>,
                                               <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>,
                                  <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if></else></if>

  <expr_stmt><expr>*<name>kind</name> = <name>my_kind</name></expr>;</expr_stmt>
  <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>parse_version_uri</name><parameter_list>(<param><decl><type><name>dav_resource_combined</name> *</type><name>comb</name></decl></param>,
                  <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                  <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>label</name></decl></param>,
                  <param><decl><type><name>int</name></type> <name>use_checked_in</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>slash</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>created_rev_str</name></decl>;</decl_stmt>

  <comment type="block">/* format: CREATED_REV/REPOS_PATH */</comment>

  <comment type="block">/* ### what to do with LABEL and USE_CHECKED_IN ?? */</comment>

  <expr_stmt><expr><name><name>comb</name>-&gt;<name>res</name>.<name>type</name></name> = <name>DAV_RESOURCE_TYPE_VERSION</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>comb</name>-&gt;<name>res</name>.<name>versioned</name></name> = <name>TRUE</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>slash</name> = <call><name>ap_strchr_c</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>'/'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>slash</name> == <name>NULL</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* http://host.name/repos/$svn/ver/0

         This URL form refers to the root path of the repository.
      */</comment>
      <expr_stmt><expr><name>created_rev_str</name> = <call><name>apr_pstrndup</name><argument_list>(<argument><expr><name><name>comb</name>-&gt;<name>res</name>.<name>pool</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>comb</name>-&gt;<name>priv</name>.<name>root</name>.<name>rev</name></name> = <call><name>SVN_STR_TO_REV</name><argument_list>(<argument><expr><name>created_rev_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>comb</name>-&gt;<name>priv</name>.<name>repos_path</name></name> = "/"</expr>;</expr_stmt>
    }</block></then>
  <else>else <if>if <condition>(<expr><name>slash</name> == <name>path</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* the CREATED_REV was missing(?)

         ### not sure this can happen, though, because it would imply two
         ### slashes, yet those are cleaned out within get_resource
      */</comment>
      <return>return <expr><name>TRUE</name></expr>;</return>
    }</block></then>
  <else>else
    <block>{
      <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name> <init>= <expr><name>slash</name> - <name>path</name></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><name>created_rev_str</name> = <call><name>apr_pstrndup</name><argument_list>(<argument><expr><name><name>comb</name>-&gt;<name>res</name>.<name>pool</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>comb</name>-&gt;<name>priv</name>.<name>root</name>.<name>rev</name></name> = <call><name>SVN_STR_TO_REV</name><argument_list>(<argument><expr><name>created_rev_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>comb</name>-&gt;<name>priv</name>.<name>repos_path</name></name> = <name>slash</name></expr>;</expr_stmt>
    }</block></else></if></else></if>

  <comment type="block">/* if the CREATED_REV parsing blew, then propagate it. */</comment>
  <if>if <condition>(<expr><name><name>comb</name>-&gt;<name>priv</name>.<name>root</name>.<name>rev</name></name> == <name>SVN_INVALID_REVNUM</name></expr>)</condition><then>
    <return>return <expr><name>TRUE</name></expr>;</return></then></if>

  <return>return <expr><name>FALSE</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>parse_history_uri</name><parameter_list>(<param><decl><type><name>dav_resource_combined</name> *</type><name>comb</name></decl></param>,
                  <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                  <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>label</name></decl></param>,
                  <param><decl><type><name>int</name></type> <name>use_checked_in</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* format: ??? */</comment>

  <comment type="block">/* ### what to do with LABEL and USE_CHECKED_IN ?? */</comment>

  <expr_stmt><expr><name><name>comb</name>-&gt;<name>res</name>.<name>type</name></name> = <name>DAV_RESOURCE_TYPE_HISTORY</name></expr>;</expr_stmt>

  <comment type="block">/* ### parse path */</comment>
  <expr_stmt><expr><name><name>comb</name>-&gt;<name>priv</name>.<name>repos_path</name></name> = <name>path</name></expr>;</expr_stmt>

  <return>return <expr><name>FALSE</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>parse_working_uri</name><parameter_list>(<param><decl><type><name>dav_resource_combined</name> *</type><name>comb</name></decl></param>,
                  <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                  <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>label</name></decl></param>,
                  <param><decl><type><name>int</name></type> <name>use_checked_in</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>slash</name></decl>;</decl_stmt>

  <comment type="block">/* format: ACTIVITY_ID/REPOS_PATH */</comment>

  <comment type="block">/* ### what to do with LABEL and USE_CHECKED_IN ?? */</comment>

  <expr_stmt><expr><name><name>comb</name>-&gt;<name>res</name>.<name>type</name></name> = <name>DAV_RESOURCE_TYPE_WORKING</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>comb</name>-&gt;<name>res</name>.<name>working</name></name> = <name>TRUE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>comb</name>-&gt;<name>res</name>.<name>versioned</name></name> = <name>TRUE</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>slash</name> = <call><name>ap_strchr_c</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>'/'</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* This sucker starts with a slash.  That's bogus. */</comment>
  <if>if <condition>(<expr><name>slash</name> == <name>path</name></expr>)</condition><then>
    <return>return <expr><name>TRUE</name></expr>;</return></then></if>

  <if>if <condition>(<expr><name>slash</name> == <name>NULL</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* There's no slash character in our path.  Assume it's just an
         ACTIVITY_ID pointing to the root path.  That should be cool.
         We'll just drop through to the normal case handling below. */</comment>
      <expr_stmt><expr><name><name>comb</name>-&gt;<name>priv</name>.<name>root</name>.<name>activity_id</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>comb</name>-&gt;<name>res</name>.<name>pool</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>comb</name>-&gt;<name>priv</name>.<name>repos_path</name></name> = "/"</expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <expr_stmt><expr><name><name>comb</name>-&gt;<name>priv</name>.<name>root</name>.<name>activity_id</name></name> = <call><name>apr_pstrndup</name><argument_list>(<argument><expr><name><name>comb</name>-&gt;<name>res</name>.<name>pool</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
                                                 <argument><expr><name>slash</name> - <name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>comb</name>-&gt;<name>priv</name>.<name>repos_path</name></name> = <name>slash</name></expr>;</expr_stmt>
    }</block></else></if>

  <return>return <expr><name>FALSE</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>parse_activity_uri</name><parameter_list>(<param><decl><type><name>dav_resource_combined</name> *</type><name>comb</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>label</name></decl></param>,
                   <param><decl><type><name>int</name></type> <name>use_checked_in</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* format: ACTIVITY_ID */</comment>

  <comment type="block">/* ### what to do with LABEL and USE_CHECKED_IN ?? */</comment>

  <expr_stmt><expr><name><name>comb</name>-&gt;<name>res</name>.<name>type</name></name> = <name>DAV_RESOURCE_TYPE_ACTIVITY</name></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>comb</name>-&gt;<name>priv</name>.<name>root</name>.<name>activity_id</name></name> = <name>path</name></expr>;</expr_stmt>

  <return>return <expr><name>FALSE</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>parse_vcc_uri</name><parameter_list>(<param><decl><type><name>dav_resource_combined</name> *</type><name>comb</name></decl></param>,
              <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
              <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>label</name></decl></param>,
              <param><decl><type><name>int</name></type> <name>use_checked_in</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* format: "default" (a singleton) */</comment>

  <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>DAV_SVN__DEFAULT_VCC_NAME</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
    <return>return <expr><name>TRUE</name></expr>;</return></then></if>

  <if>if <condition>(<expr><name>label</name> == <name>NULL</name> &amp;&amp; !<name>use_checked_in</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* Version Controlled Configuration (baseline selector) */</comment>

      <comment type="block">/* ### mod_dav has a proper model for these. technically, they are
         ### version-controlled resources (REGULAR), but that just monkeys
         ### up a lot of stuff for us. use a PRIVATE for now. */</comment>

      <expr_stmt><expr><name><name>comb</name>-&gt;<name>res</name>.<name>type</name></name> = <name>DAV_RESOURCE_TYPE_PRIVATE</name></expr>;</expr_stmt>   <comment type="block">/* _REGULAR */</comment>
      <expr_stmt><expr><name><name>comb</name>-&gt;<name>priv</name>.<name>restype</name></name> = <name>DAV_SVN_RESTYPE_VCC</name></expr>;</expr_stmt>

      <expr_stmt><expr><name><name>comb</name>-&gt;<name>res</name>.<name>exists</name></name> = <name>TRUE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>comb</name>-&gt;<name>res</name>.<name>versioned</name></name> = <name>TRUE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>comb</name>-&gt;<name>res</name>.<name>baselined</name></name> = <name>TRUE</name></expr>;</expr_stmt>

      <comment type="block">/* NOTE: comb-&gt;priv.repos_path == NULL */</comment>
    }</block></then>
  <else>else
    <block>{
      <comment type="block">/* a specific Version Resource; in this case, a Baseline */</comment>

      <decl_stmt><decl><type><name>int</name></type> <name>revnum</name></decl>;</decl_stmt>

      <if>if <condition>(<expr><name>label</name> != <name>NULL</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>revnum</name> = <call><name>SVN_STR_TO_REV</name><argument_list>(<argument><expr><name>label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* assume slash terminates */</comment>
          <if>if <condition>(<expr>!<call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name>revnum</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>TRUE</name></expr>;</return></then></if>        <comment type="block">/* ### be nice to get better feedback */</comment>
        }</block></then>
      <else>else <comment type="block">/* use_checked_in */</comment>
        <block>{
          <comment type="block">/* use the DAV:checked-in value of the VCC. this is always the
             "latest" (or "youngest") revision. */</comment>

          <comment type="block">/* signal prep_version to look it up */</comment>
          <expr_stmt><expr><name>revnum</name> = <name>SVN_INVALID_REVNUM</name></expr>;</expr_stmt>
        }</block></else></if>

      <expr_stmt><expr><name><name>comb</name>-&gt;<name>res</name>.<name>type</name></name> = <name>DAV_RESOURCE_TYPE_VERSION</name></expr>;</expr_stmt>

      <comment type="block">/* exists? need to wait for now */</comment>
      <expr_stmt><expr><name><name>comb</name>-&gt;<name>res</name>.<name>versioned</name></name> = <name>TRUE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>comb</name>-&gt;<name>res</name>.<name>baselined</name></name> = <name>TRUE</name></expr>;</expr_stmt>

      <comment type="block">/* which baseline (revision tree) to access */</comment>
      <expr_stmt><expr><name><name>comb</name>-&gt;<name>priv</name>.<name>root</name>.<name>rev</name></name> = <name>revnum</name></expr>;</expr_stmt>

      <comment type="block">/* NOTE: comb-&gt;priv.repos_path == NULL */</comment>
      <comment type="block">/* NOTE: comb-&gt;priv.created_rev == SVN_INVALID_REVNUM */</comment>
    }</block></else></if>

  <return>return <expr><name>FALSE</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>parse_baseline_coll_uri</name><parameter_list>(<param><decl><type><name>dav_resource_combined</name> *</type><name>comb</name></decl></param>,
                        <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                        <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>label</name></decl></param>,
                        <param><decl><type><name>int</name></type> <name>use_checked_in</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>slash</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>revnum</name></decl>;</decl_stmt>

  <comment type="block">/* format: REVISION/REPOS_PATH */</comment>

  <comment type="block">/* ### what to do with LABEL and USE_CHECKED_IN ?? */</comment>

  <expr_stmt><expr><name>slash</name> = <call><name>ap_strchr_c</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>'/'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>slash</name> == <name>NULL</name></expr>)</condition><then>
    <expr_stmt><expr><name>slash</name> = "/"</expr>;</expr_stmt></then>        <comment type="block">/* they are referring to the root of the BC */</comment>
  <else>else <if>if <condition>(<expr><name>slash</name> == <name>path</name></expr>)</condition><then>
    <return>return <expr><name>TRUE</name></expr>;</return></then></if></else></if>        <comment type="block">/* the REVISION was missing(?)
                           ### not sure this can happen, though, because
                           ### it would imply two slashes, yet those are
                           ### cleaned out within get_resource */</comment>

  <expr_stmt><expr><name>revnum</name> = <call><name>SVN_STR_TO_REV</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* assume slash terminates conversion */</comment>
  <if>if <condition>(<expr>!<call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name>revnum</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>TRUE</name></expr>;</return></then></if>        <comment type="block">/* ### be nice to get better feedback */</comment>

  <comment type="block">/* ### mod_dav doesn't have a proper model for these. they are standard
     ### VCRs, but we need some additional semantics attached to them.
     ### need to figure out a way to label them as special. */</comment>

  <expr_stmt><expr><name><name>comb</name>-&gt;<name>res</name>.<name>type</name></name> = <name>DAV_RESOURCE_TYPE_REGULAR</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>comb</name>-&gt;<name>res</name>.<name>versioned</name></name> = <name>TRUE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>comb</name>-&gt;<name>priv</name>.<name>root</name>.<name>rev</name></name> = <name>revnum</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>comb</name>-&gt;<name>priv</name>.<name>repos_path</name></name> = <name>slash</name></expr>;</expr_stmt>

  <return>return <expr><name>FALSE</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>parse_baseline_uri</name><parameter_list>(<param><decl><type><name>dav_resource_combined</name> *</type><name>comb</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>label</name></decl></param>,
                   <param><decl><type><name>int</name></type> <name>use_checked_in</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>revnum</name></decl>;</decl_stmt>

  <comment type="block">/* format: REVISION */</comment>

  <comment type="block">/* ### what to do with LABEL and USE_CHECKED_IN ?? */</comment>

  <expr_stmt><expr><name>revnum</name> = <call><name>SVN_STR_TO_REV</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name>revnum</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>TRUE</name></expr>;</return></then></if>        <comment type="block">/* ### be nice to get better feedback */</comment>

  <comment type="block">/* create a Baseline resource (a special Version Resource) */</comment>

  <expr_stmt><expr><name><name>comb</name>-&gt;<name>res</name>.<name>type</name></name> = <name>DAV_RESOURCE_TYPE_VERSION</name></expr>;</expr_stmt>

  <comment type="block">/* exists? need to wait for now */</comment>
  <expr_stmt><expr><name><name>comb</name>-&gt;<name>res</name>.<name>versioned</name></name> = <name>TRUE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>comb</name>-&gt;<name>res</name>.<name>baselined</name></name> = <name>TRUE</name></expr>;</expr_stmt>

  <comment type="block">/* which baseline (revision tree) to access */</comment>
  <expr_stmt><expr><name><name>comb</name>-&gt;<name>priv</name>.<name>root</name>.<name>rev</name></name> = <name>revnum</name></expr>;</expr_stmt>

  <comment type="block">/* NOTE: comb-&gt;priv.repos_path == NULL */</comment>
  <comment type="block">/* NOTE: comb-&gt;priv.created_rev == SVN_INVALID_REVNUM */</comment>

  <return>return <expr><name>FALSE</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>parse_wrk_baseline_uri</name><parameter_list>(<param><decl><type><name>dav_resource_combined</name> *</type><name>comb</name></decl></param>,
                       <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                       <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>label</name></decl></param>,
                       <param><decl><type><name>int</name></type> <name>use_checked_in</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>slash</name></decl>;</decl_stmt>

  <comment type="block">/* format: ACTIVITY_ID/REVISION */</comment>

  <comment type="block">/* ### what to do with LABEL and USE_CHECKED_IN ?? */</comment>

  <expr_stmt><expr><name><name>comb</name>-&gt;<name>res</name>.<name>type</name></name> = <name>DAV_RESOURCE_TYPE_WORKING</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>comb</name>-&gt;<name>res</name>.<name>working</name></name> = <name>TRUE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>comb</name>-&gt;<name>res</name>.<name>versioned</name></name> = <name>TRUE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>comb</name>-&gt;<name>res</name>.<name>baselined</name></name> = <name>TRUE</name></expr>;</expr_stmt>

  <if>if <condition>(<expr>(<name>slash</name> = <call><name>ap_strchr_c</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>'/'</expr></argument>)</argument_list></call>) == <name>NULL</name>
      || <name>slash</name> == <name>path</name>
      || <name><name>slash</name><index>[<expr>1</expr>]</index></name> == '\0'</expr>)</condition><then>
    <return>return <expr><name>TRUE</name></expr>;</return></then></if>

  <expr_stmt><expr><name><name>comb</name>-&gt;<name>priv</name>.<name>root</name>.<name>activity_id</name></name> = <call><name>apr_pstrndup</name><argument_list>(<argument><expr><name><name>comb</name>-&gt;<name>res</name>.<name>pool</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
                                             <argument><expr><name>slash</name> - <name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>comb</name>-&gt;<name>priv</name>.<name>root</name>.<name>rev</name></name> = <call><name>SVN_STR_TO_REV</name><argument_list>(<argument><expr><name>slash</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE: comb-&gt;priv.repos_path == NULL */</comment>

  <return>return <expr><name>FALSE</name></expr>;</return>
}</block></function>


<struct><specifier>static</specifier> <specifier>const</specifier> struct <name>special_defn</name>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl>;</decl_stmt>

  <comment type="block">/*
   * COMB is the resource that we are constructing. Any elements that
   * can be determined from the PATH may be set in COMB. However, further
   * operations are not allowed (we don't want anything besides a parse
   * error to occur).
   *
   * At a minimum, the parse function must set COMB-&gt;res.type and
   * COMB-&gt;priv.repos_path.
   *
   * PATH does not contain a leading slash. Given "/root/$svn/xxx/the/path"
   * as the request URI, the PATH variable will be "the/path"
   */</comment>
  <function_decl><type><name>int</name></type> (*<name>parse</name>)<parameter_list>(<param><decl><type><name>dav_resource_combined</name> *</type><name>comb</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
               <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>label</name></decl></param>, <param><decl><type><name>int</name></type> <name>use_checked_in</name></decl></param>)</parameter_list>;</function_decl>

  <comment type="block">/* The number of subcompenents after the !svn/xxx/... before we
     reach the actual path within the repository. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>numcomponents</name></decl>;</decl_stmt>

  <comment type="block">/* Boolean:  are the subcomponents followed by a repos path? */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>has_repos_path</name></decl>;</decl_stmt>

  <comment type="block">/* The private resource type for the /$svn/xxx/ collection. */</comment>
  <enum>enum <name>dav_svn_private_restype</name> <name>restype</name>;</enum>

}</block> <decl><name><name>special_subdirs</name><index>[]</index></name> <init>=
<expr><block>{
  <expr><block>{ <expr>"ver"</expr>, <expr><name>parse_version_uri</name></expr>, <expr>1</expr>, <expr><name>TRUE</name></expr>, <expr><name>DAV_SVN_RESTYPE_VER_COLLECTION</name></expr> }</block></expr>,
  <expr><block>{ <expr>"his"</expr>, <expr><name>parse_history_uri</name></expr>, <expr>0</expr>, <expr><name>FALSE</name></expr>, <expr><name>DAV_SVN_RESTYPE_HIS_COLLECTION</name></expr> }</block></expr>,
  <expr><block>{ <expr>"wrk"</expr>, <expr><name>parse_working_uri</name></expr>, <expr>1</expr>, <expr><name>TRUE</name></expr>,  <expr><name>DAV_SVN_RESTYPE_WRK_COLLECTION</name></expr> }</block></expr>,
  <expr><block>{ <expr>"act"</expr>, <expr><name>parse_activity_uri</name></expr>, <expr>1</expr>, <expr><name>FALSE</name></expr>, <expr><name>DAV_SVN_RESTYPE_ACT_COLLECTION</name></expr> }</block></expr>,
  <expr><block>{ <expr>"vcc"</expr>, <expr><name>parse_vcc_uri</name></expr>, <expr>1</expr>, <expr><name>FALSE</name></expr>, <expr><name>DAV_SVN_RESTYPE_VCC_COLLECTION</name></expr> }</block></expr>,
  <expr><block>{ <expr>"bc"</expr>, <expr><name>parse_baseline_coll_uri</name></expr>, <expr>1</expr>, <expr><name>TRUE</name></expr>, <expr><name>DAV_SVN_RESTYPE_BC_COLLECTION</name></expr> }</block></expr>,
  <expr><block>{ <expr>"bln"</expr>, <expr><name>parse_baseline_uri</name></expr>, <expr>1</expr>, <expr><name>FALSE</name></expr>, <expr><name>DAV_SVN_RESTYPE_BLN_COLLECTION</name></expr> }</block></expr>,
  <expr><block>{ <expr>"wbl"</expr>, <expr><name>parse_wrk_baseline_uri</name></expr>, <expr>2</expr>, <expr><name>FALSE</name></expr>, <expr><name>DAV_SVN_RESTYPE_WBL_COLLECTION</name></expr> }</block></expr>,
  <expr><block>{ <expr><name>NULL</name></expr> }</block></expr> <comment type="block">/* sentinel */</comment>
}</block></expr></init></decl>;</struct>


<comment type="block">/*
 * parse_uri: parse the provided URI into its various bits
 *
 * URI will contain a path relative to our configured root URI. It should
 * not have a leading "/". The root is identified by "".
 *
 * On output: *COMB will contain all of the information parsed out of
 * the URI -- the resource type, activity ID, path, etc.
 *
 * Note: this function will only parse the URI. Validation of the pieces,
 * opening data stores, etc, are not part of this function.
 *
 * TRUE is returned if a parsing error occurred. FALSE for success.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>parse_uri</name><parameter_list>(<param><decl><type><name>dav_resource_combined</name> *</type><name>comb</name></decl></param>,
          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>uri</name></decl></param>,
          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>label</name></decl></param>,
          <param><decl><type><name>int</name></type> <name>use_checked_in</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>special_uri</name> <init>= <expr><name><name>comb</name>-&gt;<name>priv</name>.<name>repos</name>-&gt;<name>special_uri</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len1</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name>ch</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>len1</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>uri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>len2</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>special_uri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>len1</name> &gt; <name>len2</name>
      &amp;&amp; ((<name>ch</name> = <name><name>uri</name><index>[<expr><name>len2</name></expr>]</index></name>) == '/' || <name>ch</name> == '\0')
      &amp;&amp; <call><name>memcmp</name><argument_list>(<argument><expr><name>uri</name></expr></argument>, <argument><expr><name>special_uri</name></expr></argument>, <argument><expr><name>len2</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr><name>ch</name> == '\0'</expr>)</condition><then>
        <block>{
          <comment type="block">/* URI was "/root/!svn". It exists, but has restricted usage. */</comment>
          <expr_stmt><expr><name><name>comb</name>-&gt;<name>res</name>.<name>type</name></name> = <name>DAV_RESOURCE_TYPE_PRIVATE</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>comb</name>-&gt;<name>priv</name>.<name>restype</name></name> = <name>DAV_SVN_RESTYPE_ROOT_COLLECTION</name></expr>;</expr_stmt>
        }</block></then>
      <else>else
        <block>{
          <decl_stmt><decl><type><specifier>const</specifier> struct <name>special_defn</name> *</type><name>defn</name></decl>;</decl_stmt>

          <comment type="block">/* skip past the "!svn/" prefix */</comment>
          <expr_stmt><expr><name>uri</name> += <name>len2</name> + 1</expr>;</expr_stmt>
          <expr_stmt><expr><name>len1</name> -= <name>len2</name> + 1</expr>;</expr_stmt>

          <for>for (<init><expr><name>defn</name> = <name>special_subdirs</name></expr> ;</init> <condition><expr><name><name>defn</name>-&gt;<name>name</name></name> != <name>NULL</name></expr>;</condition> <incr><expr>++<name>defn</name></expr></incr>)
            <block>{
              <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len3</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>defn</name>-&gt;<name>name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

              <if>if <condition>(<expr><name>len1</name> &gt;= <name>len3</name> &amp;&amp; <call><name>memcmp</name><argument_list>(<argument><expr><name>uri</name></expr></argument>, <argument><expr><name><name>defn</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>len3</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
                <block>{
                  <if>if <condition>(<expr><name><name>uri</name><index>[<expr><name>len3</name></expr>]</index></name> == '\0'</expr>)</condition><then>
                    <block>{
                      <comment type="block">/* URI was "/root/!svn/XXX". The location exists, but
                         has restricted usage. */</comment>
                      <expr_stmt><expr><name><name>comb</name>-&gt;<name>res</name>.<name>type</name></name> = <name>DAV_RESOURCE_TYPE_PRIVATE</name></expr>;</expr_stmt>

                      <comment type="block">/* store the resource type so that we can PROPFIND
                         on this collection. */</comment>
                      <expr_stmt><expr><name><name>comb</name>-&gt;<name>priv</name>.<name>restype</name></name> = <name><name>defn</name>-&gt;<name>restype</name></name></expr>;</expr_stmt>
                    }</block></then>
                  <else>else <if>if <condition>(<expr><name><name>uri</name><index>[<expr><name>len3</name></expr>]</index></name> == '/'</expr>)</condition><then>
                    <block>{
                      <if>if <condition>(<expr><call>(*<name><name>defn</name>-&gt;<name>parse</name></name>)<argument_list>(<argument><expr><name>comb</name></expr></argument>, <argument><expr><name>uri</name> + <name>len3</name> + 1</expr></argument>, <argument><expr><name>label</name></expr></argument>,
                                         <argument><expr><name>use_checked_in</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                        <return>return <expr><name>TRUE</name></expr>;</return></then></if>
                    }</block></then>
                  <else>else
                    <block>{
                      <comment type="block">/* e.g. "/root/!svn/activity" (we just know "act") */</comment>
                      <return>return <expr><name>TRUE</name></expr>;</return>
                    }</block></else></if></else></if>

                  <break>break;</break>
                }</block></then></if>
            }</block></for>

          <comment type="block">/* if completed the loop, then it is an unrecognized subdir */</comment>
          <if>if <condition>(<expr><name><name>defn</name>-&gt;<name>name</name></name> == <name>NULL</name></expr>)</condition><then>
            <return>return <expr><name>TRUE</name></expr>;</return></then></if>
        }</block></else></if>
    }</block></then>
  <else>else
    <block>{
      <comment type="block">/* Anything under the root, but not under "!svn". These are all
         version-controlled resources. */</comment>
      <expr_stmt><expr><name><name>comb</name>-&gt;<name>res</name>.<name>type</name></name> = <name>DAV_RESOURCE_TYPE_REGULAR</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>comb</name>-&gt;<name>res</name>.<name>versioned</name></name> = <name>TRUE</name></expr>;</expr_stmt>

      <comment type="block">/* The location of these resources corresponds directly to the URI,
         and we keep the leading "/". */</comment>
      <expr_stmt><expr><name><name>comb</name>-&gt;<name>priv</name>.<name>repos_path</name></name> = <name><name>comb</name>-&gt;<name>priv</name>.<name>uri_path</name>-&gt;<name>data</name></name></expr>;</expr_stmt>
    }</block></else></if>

  <return>return <expr><name>FALSE</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>dav_error</name> *</type>
<name>prep_regular</name><parameter_list>(<param><decl><type><name>dav_resource_combined</name> *</type><name>comb</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name> <init>= <expr><name><name>comb</name>-&gt;<name>res</name>.<name>pool</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dav_svn_repos</name> *</type><name>repos</name> <init>= <expr><name><name>comb</name>-&gt;<name>priv</name>.<name>repos</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>serr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dav_error</name> *</type><name>derr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>

  <comment type="block">/* A REGULAR resource might have a specific revision already (e.g. if it
     is part of a baseline collection). However, if it doesn't, then we
     will assume that we need the youngest revision.
     ### other cases besides a BC? */</comment>
  <if>if <condition>(<expr><name><name>comb</name>-&gt;<name>priv</name>.<name>root</name>.<name>rev</name></name> == <name>SVN_INVALID_REVNUM</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>serr</name> = <call><name>svn_fs_youngest_rev</name><argument_list>(<argument><expr>&amp;<name><name>comb</name>-&gt;<name>priv</name>.<name>root</name>.<name>rev</name></name></expr></argument>, <argument><expr><name><name>repos</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>serr</name> != <name>NULL</name></expr>)</condition><then>
        <block>{
          <return>return <expr><call><name>dav_svn__convert_err</name><argument_list>(<argument><expr><name>serr</name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>,
                                      <argument><expr>"Could not determine the proper "
                                      "revision to access"</expr></argument>,
                                      <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
    }</block></then></if>

  <comment type="block">/* get the root of the tree */</comment>
  <expr_stmt><expr><name>serr</name> = <call><name>svn_fs_revision_root</name><argument_list>(<argument><expr>&amp;<name><name>comb</name>-&gt;<name>priv</name>.<name>root</name>.<name>root</name></name></expr></argument>, <argument><expr><name><name>repos</name>-&gt;<name>fs</name></name></expr></argument>,
                              <argument><expr><name><name>comb</name>-&gt;<name>priv</name>.<name>root</name>.<name>rev</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>serr</name> != <name>NULL</name></expr>)</condition><then>
    <block>{
      <return>return <expr><call><name>dav_svn__convert_err</name><argument_list>(<argument><expr><name>serr</name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>,
                                  <argument><expr>"Could not open the root of the "
                                  "repository"</expr></argument>,
                                  <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

  <expr_stmt><expr><name>derr</name> = <call><name>fs_check_path</name><argument_list>(<argument><expr>&amp;<name>kind</name></expr></argument>, <argument><expr><name><name>comb</name>-&gt;<name>priv</name>.<name>root</name>.<name>root</name></name></expr></argument>,
                       <argument><expr><name><name>comb</name>-&gt;<name>priv</name>.<name>repos_path</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>derr</name> != <name>NULL</name></expr>)</condition><then>
    <return>return <expr><name>derr</name></expr>;</return></then></if>

  <expr_stmt><expr><name><name>comb</name>-&gt;<name>res</name>.<name>exists</name></name> = (<name>kind</name> == <name>svn_node_none</name>) ? <name>FALSE</name> : <name>TRUE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>comb</name>-&gt;<name>res</name>.<name>collection</name></name> = (<name>kind</name> == <name>svn_node_dir</name>) ? <name>TRUE</name> : <name>FALSE</name></expr>;</expr_stmt>

  <comment type="block">/* HACK:  dav_get_resource_state() is making shortcut assumptions
     about how to distinguish a null resource from a lock-null
     resource.  This is the only way to get around that problem.
     Without it, it won't ever detect lock-nulls, and thus 'svn unlock
     nonexistentURL' will always return 404's. */</comment>
  <if>if <condition>(<expr>! <name><name>comb</name>-&gt;<name>res</name>.<name>exists</name></name></expr>)</condition><then>
    <expr_stmt><expr><name><name>comb</name>-&gt;<name>priv</name>.<name>r</name>-&gt;<name>path_info</name></name> = (<name>char</name> *) ""</expr>;</expr_stmt></then></if>

  <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>dav_error</name> *</type>
<name>prep_version</name><parameter_list>(<param><decl><type><name>dav_resource_combined</name> *</type><name>comb</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>serr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name> <init>= <expr><name><name>comb</name>-&gt;<name>res</name>.<name>pool</name></name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* we are accessing the Version Resource by REV/PATH */</comment>

  <comment type="block">/* ### assert: .baselined = TRUE */</comment>

  <comment type="block">/* if we don't have a revision, then assume the youngest */</comment>
  <if>if <condition>(<expr>!<call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name><name>comb</name>-&gt;<name>priv</name>.<name>root</name>.<name>rev</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>serr</name> = <call><name>svn_fs_youngest_rev</name><argument_list>(<argument><expr>&amp;<name><name>comb</name>-&gt;<name>priv</name>.<name>root</name>.<name>rev</name></name></expr></argument>,
                                 <argument><expr><name><name>comb</name>-&gt;<name>priv</name>.<name>repos</name>-&gt;<name>fs</name></name></expr></argument>,
                                 <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>serr</name> != <name>NULL</name></expr>)</condition><then>
        <block>{
          <comment type="block">/* ### might not be a baseline */</comment>

          <return>return <expr><call><name>dav_svn__convert_err</name><argument_list>(<argument><expr><name>serr</name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>,
                                      <argument><expr>"Could not fetch 'youngest' revision "
                                      "to enable accessing the latest "
                                      "baseline resource."</expr></argument>,
                                      <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
    }</block></then></if>

  <comment type="block">/* ### baselines have no repos_path, and we don't need to open
     ### a root (yet). we just needed to ensure that we have the proper
     ### revision number. */</comment>

  <if>if <condition>(<expr>!<name><name>comb</name>-&gt;<name>priv</name>.<name>root</name>.<name>root</name></name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>serr</name> = <call><name>svn_fs_revision_root</name><argument_list>(<argument><expr>&amp;<name><name>comb</name>-&gt;<name>priv</name>.<name>root</name>.<name>root</name></name></expr></argument>,
                                  <argument><expr><name><name>comb</name>-&gt;<name>priv</name>.<name>repos</name>-&gt;<name>fs</name></name></expr></argument>,
                                  <argument><expr><name><name>comb</name>-&gt;<name>priv</name>.<name>root</name>.<name>rev</name></name></expr></argument>,
                                  <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>serr</name> != <name>NULL</name></expr>)</condition><then>
        <block>{
          <return>return <expr><call><name>dav_svn__convert_err</name><argument_list>(<argument><expr><name>serr</name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>,
                                      <argument><expr>"Could not open a revision root."</expr></argument>,
                                      <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
    }</block></then></if>

  <comment type="block">/* ### we should probably check that the revision is valid */</comment>
  <expr_stmt><expr><name><name>comb</name>-&gt;<name>res</name>.<name>exists</name></name> = <name>TRUE</name></expr>;</expr_stmt>

  <comment type="block">/* Set up the proper URI. Most likely, we arrived here via a VCC,
     so the URI will be incorrect. Set the canonical form. */</comment>
  <comment type="block">/* ### assuming a baseline */</comment>
  <expr_stmt><expr><name><name>comb</name>-&gt;<name>res</name>.<name>uri</name></name> = <call><name>dav_svn__build_uri</name><argument_list>(<argument><expr><name><name>comb</name>-&gt;<name>priv</name>.<name>repos</name></name></expr></argument>,
                                     <argument><expr><name>DAV_SVN__BUILD_URI_BASELINE</name></expr></argument>,
                                     <argument><expr><name><name>comb</name>-&gt;<name>priv</name>.<name>root</name>.<name>rev</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                     <argument><expr>0</expr></argument> <comment type="block">/* add_href */</comment>,
                                     <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>dav_error</name> *</type>
<name>prep_history</name><parameter_list>(<param><decl><type><name>dav_resource_combined</name> *</type><name>comb</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>dav_error</name> *</type>
<name>prep_working</name><parameter_list>(<param><decl><type><name>dav_resource_combined</name> *</type><name>comb</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_name</name> <init>= <expr><call><name>dav_svn__get_txn</name><argument_list>(<argument><expr><name><name>comb</name>-&gt;<name>priv</name>.<name>repos</name></name></expr></argument>,
                                          <argument><expr><name><name>comb</name>-&gt;<name>priv</name>.<name>root</name>.<name>activity_id</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name> <init>= <expr><name><name>comb</name>-&gt;<name>res</name>.<name>pool</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>serr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dav_error</name> *</type><name>derr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>txn_name</name> == <name>NULL</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* ### HTTP_BAD_REQUEST is probably wrong */</comment>
      <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>HTTP_BAD_REQUEST</name></expr></argument>, <argument><expr>0</expr></argument>,
                           <argument><expr>"An unknown activity was specified in the URL. "
                           "This is generally caused by a problem in the "
                           "client software."</expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>
  <expr_stmt><expr><name><name>comb</name>-&gt;<name>priv</name>.<name>root</name>.<name>txn_name</name></name> = <name>txn_name</name></expr>;</expr_stmt>

  <comment type="block">/* get the FS transaction, given its name */</comment>
  <expr_stmt><expr><name>serr</name> = <call><name>svn_fs_open_txn</name><argument_list>(<argument><expr>&amp;<name><name>comb</name>-&gt;<name>priv</name>.<name>root</name>.<name>txn</name></name></expr></argument>, <argument><expr><name><name>comb</name>-&gt;<name>priv</name>.<name>repos</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>txn_name</name></expr></argument>,
                         <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>serr</name> != <name>NULL</name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr><name><name>serr</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_FS_NO_SUCH_TRANSACTION</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>serr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>, <argument><expr>0</expr></argument>,
                               <argument><expr>"An activity was specified and found, but the "
                               "corresponding SVN FS transaction was not "
                               "found."</expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
      <return>return <expr><call><name>dav_svn__convert_err</name><argument_list>(<argument><expr><name>serr</name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>,
                                  <argument><expr>"Could not open the SVN FS transaction "
                                  "corresponding to the specified activity."</expr></argument>,
                                  <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

  <if>if <condition>(<expr><name><name>comb</name>-&gt;<name>res</name>.<name>baselined</name></name></expr>)</condition><then>
    <block>{
      <comment type="block">/* a Working Baseline */</comment>

      <comment type="block">/* if the transaction exists, then the working resource exists */</comment>
      <expr_stmt><expr><name><name>comb</name>-&gt;<name>res</name>.<name>exists</name></name> = <name>TRUE</name></expr>;</expr_stmt>

      <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>

  <comment type="block">/* Set the txn author if not previously set.  Protect against multi-author
   * commits by verifying authenticated user associated with the current
   * request is the same as the txn author.
   * Note that anonymous requests are being excluded as being a change
   * in author, because the commit may touch areas of the repository
   * that are anonymous writeable as well as areas that are not.
   */</comment>
  <if>if <condition>(<expr><name><name>comb</name>-&gt;<name>priv</name>.<name>repos</name>-&gt;<name>username</name></name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>current_author</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_string_t</name></type> <name>request_author</name></decl>;</decl_stmt>

      <expr_stmt><expr><name>serr</name> = <call><name>svn_fs_txn_prop</name><argument_list>(<argument><expr>&amp;<name>current_author</name></expr></argument>, <argument><expr><name><name>comb</name>-&gt;<name>priv</name>.<name>root</name>.<name>txn</name></name></expr></argument>,
               <argument><expr><name>SVN_PROP_REVISION_AUTHOR</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>serr</name> != <name>NULL</name></expr>)</condition><then>
        <block>{
          <return>return <expr><call><name>dav_svn__convert_err</name><argument_list>(<argument><expr><name>serr</name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>,
                   <argument><expr>"Failed to retrieve author of the SVN FS transaction "
                   "corresponding to the specified activity."</expr></argument>,
                   <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>

      <expr_stmt><expr><name><name>request_author</name>.<name>data</name></name> = <name><name>comb</name>-&gt;<name>priv</name>.<name>repos</name>-&gt;<name>username</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>request_author</name>.<name>len</name></name> = <call><name>strlen</name><argument_list>(<argument><expr><name><name>request_author</name>.<name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr>!<name>current_author</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>serr</name> = <call><name>svn_fs_change_txn_prop</name><argument_list>(<argument><expr><name><name>comb</name>-&gt;<name>priv</name>.<name>root</name>.<name>txn</name></name></expr></argument>,
                   <argument><expr><name>SVN_PROP_REVISION_AUTHOR</name></expr></argument>, <argument><expr>&amp;<name>request_author</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>serr</name> != <name>NULL</name></expr>)</condition><then>
            <block>{
              <return>return <expr><call><name>dav_svn__convert_err</name><argument_list>(<argument><expr><name>serr</name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>,
                       <argument><expr>"Failed to set the author of the SVN FS transaction "
                       "corresponding to the specified activity."</expr></argument>,
                       <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
            }</block></then></if>
        }</block></then>
      <else>else <if>if <condition>(<expr>!<call><name>svn_string_compare</name><argument_list>(<argument><expr><name>current_author</name></expr></argument>, <argument><expr>&amp;<name>request_author</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>HTTP_NOT_IMPLEMENTED</name></expr></argument>, <argument><expr>0</expr></argument>,
                   <argument><expr>"Multi-author commits not supported."</expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if></else></if>
    }</block></then></if>

  <comment type="block">/* get the root of the tree */</comment>
  <expr_stmt><expr><name>serr</name> = <call><name>svn_fs_txn_root</name><argument_list>(<argument><expr>&amp;<name><name>comb</name>-&gt;<name>priv</name>.<name>root</name>.<name>root</name></name></expr></argument>, <argument><expr><name><name>comb</name>-&gt;<name>priv</name>.<name>root</name>.<name>txn</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>serr</name> != <name>NULL</name></expr>)</condition><then>
    <block>{
      <return>return <expr><call><name>dav_svn__convert_err</name><argument_list>(<argument><expr><name>serr</name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>,
                                  <argument><expr>"Could not open the (transaction) root of "
                                  "the repository"</expr></argument>,
                                  <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

  <expr_stmt><expr><name>derr</name> = <call><name>fs_check_path</name><argument_list>(<argument><expr>&amp;<name>kind</name></expr></argument>, <argument><expr><name><name>comb</name>-&gt;<name>priv</name>.<name>root</name>.<name>root</name></name></expr></argument>,
                       <argument><expr><name><name>comb</name>-&gt;<name>priv</name>.<name>repos_path</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>derr</name> != <name>NULL</name></expr>)</condition><then>
    <return>return <expr><name>derr</name></expr>;</return></then></if>

  <expr_stmt><expr><name><name>comb</name>-&gt;<name>res</name>.<name>exists</name></name> = (<name>kind</name> == <name>svn_node_none</name>) ? <name>FALSE</name> : <name>TRUE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>comb</name>-&gt;<name>res</name>.<name>collection</name></name> = (<name>kind</name> == <name>svn_node_dir</name>) ? <name>TRUE</name> : <name>FALSE</name></expr>;</expr_stmt>

  <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>dav_error</name> *</type>
<name>prep_activity</name><parameter_list>(<param><decl><type><name>dav_resource_combined</name> *</type><name>comb</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_name</name> <init>= <expr><call><name>dav_svn__get_txn</name><argument_list>(<argument><expr><name><name>comb</name>-&gt;<name>priv</name>.<name>repos</name></name></expr></argument>,
                                          <argument><expr><name><name>comb</name>-&gt;<name>priv</name>.<name>root</name>.<name>activity_id</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>comb</name>-&gt;<name>priv</name>.<name>root</name>.<name>txn_name</name></name> = <name>txn_name</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>comb</name>-&gt;<name>res</name>.<name>exists</name></name> = <name>txn_name</name> != <name>NULL</name></expr>;</expr_stmt>

  <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>dav_error</name> *</type>
<name>prep_private</name><parameter_list>(<param><decl><type><name>dav_resource_combined</name> *</type><name>comb</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name><name>comb</name>-&gt;<name>priv</name>.<name>restype</name></name> == <name>DAV_SVN_RESTYPE_VCC</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* ### what to do */</comment>
    }</block></then></if>
  <comment type="block">/* else nothing to do (### for now) */</comment>

  <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>


<struct><specifier>static</specifier> <specifier>const</specifier> struct <name>res_type_handler</name>
<block>{
  <decl_stmt><decl><type><name>dav_resource_type</name></type> <name>type</name></decl>;</decl_stmt>
  <function_decl><type><name>dav_error</name> *</type> (*<name>prep</name>)<parameter_list>(<param><decl><type><name>dav_resource_combined</name> *</type><name>comb</name></decl></param>)</parameter_list>;</function_decl>

}</block> <decl><name><name>res_type_handlers</name><index>[]</index></name> <init>=
<expr><block>{
  <comment type="block">/* skip UNKNOWN */</comment>
  <expr><block>{ <expr><name>DAV_RESOURCE_TYPE_REGULAR</name></expr>, <expr><name>prep_regular</name></expr> }</block></expr>,
  <expr><block>{ <expr><name>DAV_RESOURCE_TYPE_VERSION</name></expr>, <expr><name>prep_version</name></expr> }</block></expr>,
  <expr><block>{ <expr><name>DAV_RESOURCE_TYPE_HISTORY</name></expr>, <expr><name>prep_history</name></expr> }</block></expr>,
  <expr><block>{ <expr><name>DAV_RESOURCE_TYPE_WORKING</name></expr>, <expr><name>prep_working</name></expr> }</block></expr>,
  <comment type="block">/* skip WORKSPACE */</comment>
  <expr><block>{ <expr><name>DAV_RESOURCE_TYPE_ACTIVITY</name></expr>, <expr><name>prep_activity</name></expr> }</block></expr>,
  <expr><block>{ <expr><name>DAV_RESOURCE_TYPE_PRIVATE</name></expr>, <expr><name>prep_private</name></expr> }</block></expr>,

  <expr><block>{ <expr>0</expr>, <expr><name>NULL</name></expr> }</block></expr>   <comment type="block">/* sentinel */</comment>
}</block></expr></init></decl>;</struct>


<comment type="block">/*
** ### docco...
**
** Set .exists and .collection
** open other, internal bits...
*/</comment>
<function><type><specifier>static</specifier> <name>dav_error</name> *</type>
<name>prep_resource</name><parameter_list>(<param><decl><type><name>dav_resource_combined</name> *</type><name>comb</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> struct <name>res_type_handler</name> *</type><name>scan</name></decl>;</decl_stmt>

  <for>for (<init><expr><name>scan</name> = <name>res_type_handlers</name></expr>;</init> <condition><expr><name><name>scan</name>-&gt;<name>prep</name></name> != <name>NULL</name></expr>;</condition> <incr><expr>++<name>scan</name></expr></incr>)
    <block>{
      <if>if <condition>(<expr><name><name>comb</name>-&gt;<name>res</name>.<name>type</name></name> == <name><name>scan</name>-&gt;<name>type</name></name></expr>)</condition><then>
        <return>return <expr><call>(*<name><name>scan</name>-&gt;<name>prep</name></name>)<argument_list>(<argument><expr><name>comb</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
    }</block></for>

  <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name><name>comb</name>-&gt;<name>res</name>.<name>pool</name></name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>, <argument><expr>0</expr></argument>,
                       <argument><expr>"DESIGN FAILURE: unknown resource type"</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<decl_stmt><decl><type><specifier>static</specifier> <name>dav_resource</name> *</type>
<name>create_private_resource</name><argument_list>(<argument><expr>const <name>dav_resource</name> *<name>base</name></expr></argument>,
                        <argument>enum <expr><name>dav_svn_private_restype</name> <name>restype</name></expr></argument>)</argument_list>
<block>{
  <decl_stmt><decl><type><name>dav_resource_combined</name> *</type><name>comb</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> struct <name>special_defn</name> *</type><name>defn</name></decl>;</decl_stmt>

  <for>for (<init><expr><name>defn</name> = <name>special_subdirs</name></expr>;</init> <condition><expr><name><name>defn</name>-&gt;<name>name</name></name> != <name>NULL</name></expr>;</condition> <incr><expr>++<name>defn</name></expr></incr>)
    <if>if <condition>(<expr><name><name>defn</name>-&gt;<name>restype</name></name> == <name>restype</name></expr>)</condition><then>
      <break>break;</break></then></if></for>
  <comment type="block">/* assert: defn-&gt;name != NULL */</comment>

  <expr_stmt><expr><name>path</name> = <call><name>svn_stringbuf_createf</name><argument_list>(<argument><expr><name><name>base</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>"/%s/%s"</expr></argument>,
                            <argument><expr><name><name>base</name>-&gt;<name>info</name>-&gt;<name>repos</name>-&gt;<name>special_uri</name></name></expr></argument>, <argument><expr><name><name>defn</name>-&gt;<name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>comb</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name><name>base</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>comb</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* ### can/should we leverage prep_resource */</comment>

  <expr_stmt><expr><name><name>comb</name>-&gt;<name>res</name>.<name>type</name></name> = <name>DAV_RESOURCE_TYPE_PRIVATE</name></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>comb</name>-&gt;<name>res</name>.<name>exists</name></name> = <name>TRUE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>comb</name>-&gt;<name>res</name>.<name>collection</name></name> = <name>TRUE</name></expr>;</expr_stmt>                  <comment type="block">/* ### always true? */</comment>
  <comment type="block">/* versioned = baselined = working = FALSE */</comment>

  <expr_stmt><expr><name><name>comb</name>-&gt;<name>res</name>.<name>uri</name></name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>base</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>base</name>-&gt;<name>info</name>-&gt;<name>repos</name>-&gt;<name>root_path</name></name></expr></argument>,
                              <argument><expr><name><name>path</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>comb</name>-&gt;<name>res</name>.<name>info</name></name> = &amp;<name><name>comb</name>-&gt;<name>priv</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>comb</name>-&gt;<name>res</name>.<name>hooks</name></name> = &amp;<name>dav_svn__hooks_repository</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>comb</name>-&gt;<name>res</name>.<name>pool</name></name> = <name><name>base</name>-&gt;<name>pool</name></name></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>comb</name>-&gt;<name>priv</name>.<name>uri_path</name></name> = <name>path</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>comb</name>-&gt;<name>priv</name>.<name>repos</name></name> = <name><name>base</name>-&gt;<name>info</name>-&gt;<name>repos</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>comb</name>-&gt;<name>priv</name>.<name>root</name>.<name>rev</name></name> = <name>SVN_INVALID_REVNUM</name></expr>;</expr_stmt>
  <return>return <expr>&amp;<name><name>comb</name>-&gt;<name>res</name></name></expr>;</return>
}</block></decl></decl_stmt>


<function><type><specifier>static</specifier> <name>void</name></type> <name>log_warning</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>svn_error_t</name> *</type><name>err</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>request_rec</name> *</type><name>r</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* ### hmm. the FS is cleaned up at request cleanup time. "r" might
     ### not really be valid. we should probably put the FS into a
     ### subpool to ensure it gets cleaned before the request.

     ### is there a good way to create and use a subpool for all
     ### of our functions ... ??
  */</comment>

  <expr_stmt><expr><call><name>ap_log_rerror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr><name>APR_EGENERAL</name></expr></argument>, <argument><expr><name>r</name></expr></argument>, <argument><expr>"%s"</expr></argument>, <argument><expr><name><name>err</name>-&gt;<name>message</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<macro><name>AP_MODULE_DECLARE</name><argument_list>(<argument>dav_error *</argument>)</argument_list></macro>
<macro><name>dav_svn_split_uri</name><argument_list>(<argument>request_rec *r</argument>,
                  <argument>const char *uri_to_split</argument>,
                  <argument>const char *root_path</argument>,
                  <argument>const char **cleaned_uri</argument>,
                  <argument>int *trailing_slash</argument>,
                  <argument>const char **repos_name</argument>,
                  <argument>const char **relative_path</argument>,
                  <argument>const char **repos_path</argument>)</argument_list></macro>
<block>{
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len1</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>had_slash</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fs_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fs_parent_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>relative</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>uri</name></decl>;</decl_stmt>

  <comment type="block">/* one of these is NULL, the other non-NULL. */</comment>
  <expr_stmt><expr><name>fs_path</name> = <call><name>dav_svn__get_fs_path</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>fs_parent_path</name> = <call><name>dav_svn__get_fs_parent_path</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr>(<name>fs_path</name> == <name>NULL</name>) &amp;&amp; (<name>fs_parent_path</name> == <name>NULL</name>)</expr>)</condition><then>
    <block>{
      <comment type="block">/* ### are SVN_ERR_APMOD codes within the right numeric space? */</comment>
      <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>,
                           <argument><expr><name>SVN_ERR_APMOD_MISSING_PATH_TO_FS</name></expr></argument>,
                           <argument><expr>"The server is misconfigured: "
                           "either an SVNPath or SVNParentPath "
                           "directive is required to specify the location "
                           "of this resource's repository."</expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

  <comment type="block">/* make a copy so that we can do some work on it */</comment>
  <expr_stmt><expr><name>uri</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>uri_to_split</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* remove duplicate slashes, and make sure URI has no trailing '/' */</comment>
  <expr_stmt><expr><call><name>ap_no2slash</name><argument_list>(<argument><expr><name>uri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>len1</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>uri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>had_slash</name> = (<name>len1</name> &gt; 0 &amp;&amp; <name><name>uri</name><index>[<expr><name>len1</name> - 1</expr>]</index></name> == '/')</expr>;</expr_stmt>
  <if>if <condition>(<expr><name>len1</name> &gt; 1 &amp;&amp; <name>had_slash</name></expr>)</condition><then>
    <expr_stmt><expr><name><name>uri</name><index>[<expr><name>len1</name> - 1</expr>]</index></name> = '\0'</expr>;</expr_stmt></then></if>

  <if>if <condition>(<expr><name>had_slash</name></expr>)</condition><then>
    <expr_stmt><expr>*<name>trailing_slash</name> = <name>TRUE</name></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr>*<name>trailing_slash</name> = <name>FALSE</name></expr>;</expr_stmt></else></if>

  <comment type="block">/* return the first item.  */</comment>
  <expr_stmt><expr>*<name>cleaned_uri</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>uri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* The URL space defined by the SVN provider is always a virtual
     space. Construct the path relative to the configured Location
     (root_path). So... the relative location is simply the URL used,
     skipping the root_path.

     Note: mod_dav has canonialized root_path. It will not have a trailing
     slash (unless it is "/").

     Note: given a URI of /something and a root of /some, then it is
           impossible to be here (and end up with "thing"). This is simply
           because we control /some and are dispatched to here for its
           URIs. We do not control /something, so we don't get here. Or,
           if we *do* control /something, then it is for THAT root.
  */</comment>
  <expr_stmt><expr><name>relative</name> = <call><name>ap_stripprefix</name><argument_list>(<argument><expr><name>uri</name></expr></argument>, <argument><expr><name>root_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* We want a leading slash on the path specified by &lt;relative&gt;. This
     will almost always be the case since root_path does not have a trailing
     slash. However, if the root is "/", then the slash will be removed
     from &lt;relative&gt;. Backing up a character will put the leading slash
     back.

     Watch out for the empty string! This can happen when URI == ROOT_PATH.
     We simply turn the path into "/" for this case. */</comment>
  <if>if <condition>(<expr>*<name>relative</name> == '\0'</expr>)</condition><then>
    <expr_stmt><expr><name>relative</name> = "/"</expr>;</expr_stmt></then>
  <else>else <if>if <condition>(<expr>*<name>relative</name> != '/'</expr>)</condition><then>
    <expr_stmt><expr>--<name>relative</name></expr>;</expr_stmt></then></if></else></if>
  <comment type="block">/* ### need a better name... it isn't "relative" because of the leading
     ### slash. something about SVN-private-path */</comment>

  <comment type="block">/* Depending on whether SVNPath or SVNParentPath was used, we need
     to compute 'relative' and 'repos_name' differently.  */</comment>

  <comment type="block">/* Normal case:  the SVNPath command was used to specify a
     particular repository.  */</comment>
  <if>if <condition>(<expr><name>fs_path</name> != <name>NULL</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* the repos_name is the last component of root_path. */</comment>
      <expr_stmt><expr>*<name>repos_name</name> = <call><name>svn_path_basename</name><argument_list>(<argument><expr><name>root_path</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* 'relative' is already correct for SVNPath; the root_path
         already contains the name of the repository, so relative is
         everything beyond that.  */</comment>
    }</block></then>

  <else>else
    <block>{
      <comment type="block">/* SVNParentPath was used instead: assume the first component of
         'relative' is the name of a repository. */</comment>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>magic_component</name></decl>, *<decl><type ref="prev"/><name>magic_end</name></decl>;</decl_stmt>

      <comment type="block">/* A repository name is required here.
         Remember that 'relative' always starts with a "/". */</comment>
      <if>if <condition>(<expr><name><name>relative</name><index>[<expr>1</expr>]</index></name> == '\0'</expr>)</condition><then>
        <block>{
          <comment type="block">/* ### are SVN_ERR_APMOD codes within the right numeric space? */</comment>
          <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>HTTP_FORBIDDEN</name></expr></argument>,
                               <argument><expr><name>SVN_ERR_APMOD_MALFORMED_URI</name></expr></argument>,
                               <argument><expr>"The URI does not contain the name "
                               "of a repository."</expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>

      <expr_stmt><expr><name>magic_end</name> = <call><name>ap_strchr_c</name><argument_list>(<argument><expr><name>relative</name> + 1</expr></argument>, <argument><expr>'/'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr>!<name>magic_end</name></expr>)</condition><then>
        <block>{
          <comment type="block">/* ### Request was for parent directory with no trailing
             slash; we probably ought to just redirect to same with
             trailing slash appended. */</comment>
          <expr_stmt><expr><name>magic_component</name> = <name>relative</name> + 1</expr>;</expr_stmt>
          <expr_stmt><expr><name>relative</name> = "/"</expr>;</expr_stmt>
        }</block></then>
      <else>else
        <block>{
          <expr_stmt><expr><name>magic_component</name> = <call><name>apr_pstrndup</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>relative</name> + 1</expr></argument>,
                                         <argument><expr><name>magic_end</name> - <name>relative</name> - 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>relative</name> = <name>magic_end</name></expr>;</expr_stmt>
        }</block></else></if>

      <comment type="block">/* return answer */</comment>
      <expr_stmt><expr>*<name>repos_name</name> = <name>magic_component</name></expr>;</expr_stmt>
    }</block></else></if>

  <comment type="block">/* We can return 'relative' at this point too. */</comment>
  <expr_stmt><expr>*<name>relative_path</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>relative</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Code to remove the !svn junk from the front of the relative path,
     mainly stolen from parse_uri().  This code assumes that
     the 'relative' string being parsed doesn't start with '/'. */</comment>
  <expr_stmt><expr><name>relative</name>++</expr>;</expr_stmt>

  <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>special_uri</name> <init>= <expr><call><name>dav_svn__get_special_uri</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name>ch</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>len1</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>relative</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>len2</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>special_uri</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>len1</name> &gt; <name>len2</name>
        &amp;&amp; ((<name>ch</name> = <name><name>relative</name><index>[<expr><name>len2</name></expr>]</index></name>) == '/' || <name>ch</name> == '\0')
        &amp;&amp; <call><name>memcmp</name><argument_list>(<argument><expr><name>relative</name></expr></argument>, <argument><expr><name>special_uri</name></expr></argument>, <argument><expr><name>len2</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
      <block>{
        <if>if <condition>(<expr><name>ch</name> == '\0'</expr>)</condition><then>
          <block>{
            <comment type="block">/* relative is just "!svn", which is malformed. */</comment>
            <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>,
                                 <argument><expr><name>SVN_ERR_APMOD_MALFORMED_URI</name></expr></argument>,
                                 <argument><expr>"Nothing follows the svn special_uri."</expr></argument>)</argument_list></call></expr>;</return>
          }</block></then>
        <else>else
          <block>{
            <decl_stmt><decl><type><specifier>const</specifier> struct <name>special_defn</name> *</type><name>defn</name></decl>;</decl_stmt>

            <comment type="block">/* skip past the "!svn/" prefix */</comment>
            <expr_stmt><expr><name>relative</name> += <name>len2</name> + 1</expr>;</expr_stmt>
            <expr_stmt><expr><name>len1</name> -= <name>len2</name> + 1</expr>;</expr_stmt>

            <for>for (<init><expr><name>defn</name> = <name>special_subdirs</name></expr> ;</init> <condition><expr><name><name>defn</name>-&gt;<name>name</name></name> != <name>NULL</name></expr>;</condition> <incr><expr>++<name>defn</name></expr></incr>)
              <block>{
                <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len3</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>defn</name>-&gt;<name>name</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                <if>if <condition>(<expr><name>len1</name> &gt;= <name>len3</name> &amp;&amp; <call><name>memcmp</name><argument_list>(<argument><expr><name>relative</name></expr></argument>, <argument><expr><name><name>defn</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>len3</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
                  <block>{
                    <comment type="block">/* Found a matching special dir. */</comment>

                    <if>if <condition>(<expr><name><name>relative</name><index>[<expr><name>len3</name></expr>]</index></name> == '\0'</expr>)</condition><then>
                      <block>{
                        <comment type="block">/* relative is "!svn/xxx"  */</comment>
                        <if>if <condition>(<expr><name><name>defn</name>-&gt;<name>numcomponents</name></name> == 0</expr>)</condition><then>
                          <expr_stmt><expr>*<name>repos_path</name> = <name>NULL</name></expr>;</expr_stmt></then>
                        <else>else
                          <return>return
                            <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>,
                                          <argument><expr><name>SVN_ERR_APMOD_MALFORMED_URI</name></expr></argument>,
                                          <argument><expr>"Missing info after special_uri."</expr></argument>)</argument_list></call></expr>;</return></else></if>
                      }</block></then>
                    <else>else <if>if <condition>(<expr><name><name>relative</name><index>[<expr><name>len3</name></expr>]</index></name> == '/'</expr>)</condition><then>
                      <block>{
                        <comment type="block">/* Skip past defn-&gt;numcomponents components,
                           return everything beyond that.*/</comment>
                        <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
                        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>end</name> <init>= <expr><name>NULL</name></expr></init>, *<name>start</name> <init>= <expr><name>relative</name> + <name>len3</name> + 1</expr></init></decl>;</decl_stmt>

                        <for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name><name>defn</name>-&gt;<name>numcomponents</name></name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>)
                          <block>{
                            <expr_stmt><expr><name>end</name> = <call><name>ap_strchr_c</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr>'/'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
                            <if>if <condition>(<expr>! <name>end</name></expr>)</condition><then>
                              <break>break;</break></then></if>
                            <expr_stmt><expr><name>start</name> = <name>end</name> + 1</expr>;</expr_stmt>
                          }</block></for>

                        <if>if <condition>(<expr>! <name>end</name></expr>)</condition><then>
                          <block>{
                            <comment type="block">/* Did we break from the loop prematurely? */</comment>
                            <if>if <condition>(<expr><name>j</name> != (<name><name>defn</name>-&gt;<name>numcomponents</name></name> - 1)</expr>)</condition><then>
                              <return>return
                                <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>,
                                              <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>,
                                              <argument><expr><name>SVN_ERR_APMOD_MALFORMED_URI</name></expr></argument>,
                                              <argument><expr>"Not enough components"
                                              " after special_uri."</expr></argument>)</argument_list></call></expr>;</return></then></if>

                            <if>if <condition>(<expr>! <name><name>defn</name>-&gt;<name>has_repos_path</name></name></expr>)</condition><then>
                              <comment type="block">/* It's okay to not have found a slash. */</comment>
                              <expr_stmt><expr>*<name>repos_path</name> = <name>NULL</name></expr>;</expr_stmt></then>
                            <else>else
                              <expr_stmt><expr>*<name>repos_path</name> = "/"</expr>;</expr_stmt></else></if>
                          }</block></then>
                        <else>else
                          <block>{
                            <comment type="block">/* Found a slash after the special components. */</comment>
                            <expr_stmt><expr>*<name>repos_path</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                          }</block></else></if>
                      }</block></then>
                    <else>else
                      <block>{
                        <return>return
                          <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>,
                                        <argument><expr><name>SVN_ERR_APMOD_MALFORMED_URI</name></expr></argument>,
                                        <argument><expr>"Unknown data after special_uri."</expr></argument>)</argument_list></call></expr>;</return>
                      }</block></else></if></else></if>

                  <break>break;</break>
                  }</block></then></if>
              }</block></for>

            <if>if <condition>(<expr><name><name>defn</name>-&gt;<name>name</name></name> == <name>NULL</name></expr>)</condition><then>
              <return>return
                <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>,
                              <argument><expr><name>SVN_ERR_APMOD_MALFORMED_URI</name></expr></argument>,
                              <argument><expr>"Couldn't match subdir after special_uri."</expr></argument>)</argument_list></call></expr>;</return></then></if>
          }</block></else></if>
      }</block></then>
    <else>else
      <block>{
        <comment type="block">/* There's no "!svn/" at all, so the relative path is already
           a valid path within the repository.  */</comment>
        <expr_stmt><expr>*<name>repos_path</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>relative</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></else></if>
  }</block>

  <return>return <expr><name>NULL</name></expr>;</return>
}</block>


<comment type="block">/* Context for cleanup handler. */</comment>
<struct>struct <name>cleanup_fs_access_baton</name>
<block>{
  <decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>
}</block>;</struct>


<comment type="block">/* Pool cleanup handler.  Make sure fs's access ctx points to NULL
   when request pool is destroyed. */</comment>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type>
<name>cleanup_fs_access</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>data</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>serr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>cleanup_fs_access_baton</name> *</type><name>baton</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>serr</name> = <call><name>svn_fs_set_access</name><argument_list>(<argument><expr><name><name>baton</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>serr</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>ap_log_perror</name><argument_list>(<argument><expr><name>APLOG_MARK</name></expr></argument>, <argument><expr><name>APLOG_ERR</name></expr></argument>, <argument><expr><name><name>serr</name>-&gt;<name>apr_err</name></name></expr></argument>, <argument><expr><name><name>baton</name>-&gt;<name>pool</name></name></expr></argument>,
                    <argument><expr>"cleanup_fs_access: error clearing fs access context"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>serr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>


<comment type="block">/* Helper func to construct a special 'parentpath' private resource. */</comment>
<function><type><specifier>static</specifier> <name>dav_error</name> *</type>
<name>get_parentpath_resource</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>,
                        <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>root_path</name></decl></param>,
                        <param><decl><type><name>dav_resource</name> **</type><name>resource</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>new_uri</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dav_svn_root</name> *</type><name>droot</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>droot</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dav_svn_repos</name> *</type><name>repos</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>repos</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dav_resource_combined</name> *</type><name>comb</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>comb</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>uri</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>comb</name>-&gt;<name>res</name>.<name>exists</name></name> = <name>TRUE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>comb</name>-&gt;<name>res</name>.<name>collection</name></name> = <name>TRUE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>comb</name>-&gt;<name>res</name>.<name>uri</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>uri</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>comb</name>-&gt;<name>res</name>.<name>info</name></name> = &amp;<name><name>comb</name>-&gt;<name>priv</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>comb</name>-&gt;<name>res</name>.<name>hooks</name></name> = &amp;<name>dav_svn__hooks_repository</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>comb</name>-&gt;<name>res</name>.<name>pool</name></name> = <name><name>r</name>-&gt;<name>pool</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>comb</name>-&gt;<name>res</name>.<name>type</name></name> = <name>DAV_RESOURCE_TYPE_PRIVATE</name></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>comb</name>-&gt;<name>priv</name>.<name>restype</name></name> = <name>DAV_SVN_RESTYPE_PARENTPATH_COLLECTION</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>comb</name>-&gt;<name>priv</name>.<name>r</name></name> = <name>r</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>comb</name>-&gt;<name>priv</name>.<name>repos_path</name></name> = "Collection of Repositories"</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>comb</name>-&gt;<name>priv</name>.<name>root</name></name> = *<name>droot</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>droot</name>-&gt;<name>rev</name></name> = <name>SVN_INVALID_REVNUM</name></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>comb</name>-&gt;<name>priv</name>.<name>repos</name></name> = <name>repos</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>repos</name>-&gt;<name>pool</name></name> = <name><name>r</name>-&gt;<name>pool</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>repos</name>-&gt;<name>xslt_uri</name></name> = <call><name>dav_svn__get_xslt_uri</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>repos</name>-&gt;<name>autoversioning</name></name> = <call><name>dav_svn__get_autoversioning_flag</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>repos</name>-&gt;<name>bulk_updates</name></name> = <call><name>dav_svn__get_bulk_updates_flag</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>repos</name>-&gt;<name>base_url</name></name> = <call><name>ap_construct_url</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>""</expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>repos</name>-&gt;<name>special_uri</name></name> = <call><name>dav_svn__get_special_uri</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>repos</name>-&gt;<name>username</name></name> = <name><name>r</name>-&gt;<name>user</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>repos</name>-&gt;<name>capabilities</name></name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name><name>repos</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Make sure this type of resource always has a trailing slash; if
     not, redirect to a URI that does. */</comment>
  <if>if <condition>(<expr><name><name>r</name>-&gt;<name>uri</name><index>[<expr><name>len</name>-1</expr>]</index></name> != '/'</expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>new_uri</name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><call><name>ap_escape_uri</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>uri</name></name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr>"/"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_out</name></name></expr></argument>, <argument><expr>"Location"</expr></argument>,
                     <argument><expr><call><name>ap_construct_url</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>new_uri</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>HTTP_MOVED_PERMANENTLY</name></expr></argument>, <argument><expr>0</expr></argument>,
                           <argument><expr>"Requests for a collection must have a "
                           "trailing slash on the URI."</expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

  <comment type="block">/* No other "prepping" of resource needs to happen -- no opening
     of a repository or anything like that, because, well, there's
     no repository to open. */</comment>
  <expr_stmt><expr>*<name>resource</name> = &amp;<name><name>comb</name>-&gt;<name>res</name></name></expr>;</expr_stmt>
  <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<comment type="block">/* --------------- Borrowed from httpd's mod_negotiation.c -------------- */</comment>

<typedef>typedef <type><struct>struct <name>accept_rec</name> <block>{
  <decl_stmt><decl><type><name>char</name> *</type><name>name</name></decl>;</decl_stmt>                 <comment type="block">/* MUST be lowercase */</comment>
  <decl_stmt><decl><type><name>float</name></type> <name>quality</name></decl>;</decl_stmt>
}</block></struct></type> <name>accept_rec</name>;</typedef>

<comment type="block">/*
 * Get a single Accept-encoding line from ACCEPT_LINE, and place the
 * information we have parsed out of it into RESULT.
 */</comment>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>get_entry</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>, <param><decl><type><name>accept_rec</name> *</type><name>result</name></decl></param>,
                             <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>accept_line</name></decl></param>)</parameter_list>
<block>{
    <expr_stmt><expr><name><name>result</name>-&gt;<name>quality</name></name> = 1.0f</expr>;</expr_stmt>

    <comment type="block">/*
     * Note that this handles what I gather is the "old format",
     *
     *    Accept: text/html text/plain moo/zot
     *
     * without any compatibility kludges --- if the token after the
     * MIME type begins with a semicolon, we know we're looking at parms,
     * otherwise, we know we aren't.  (So why all the pissing and moaning
     * in the CERN server code?  I must be missing something).
     */</comment>

    <expr_stmt><expr><name><name>result</name>-&gt;<name>name</name></name> = <call><name>ap_get_token</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>&amp;<name>accept_line</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>ap_str_tolower</name><argument_list>(<argument><expr><name><name>result</name>-&gt;<name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>     <comment type="block">/* You want case insensitive,
                                       * you'll *get* case insensitive.
                                       */</comment>

    <while>while <condition>(<expr>*<name>accept_line</name> == ';'</expr>)</condition>
      <block>{
        <comment type="block">/* Parameters ... */</comment>

        <decl_stmt><decl><type><name>char</name> *</type><name>parm</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> *</type><name>cp</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>char</name> *</type><name>end</name></decl>;</decl_stmt>

        <expr_stmt><expr>++<name>accept_line</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>parm</name> = <call><name>ap_get_token</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>&amp;<name>accept_line</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Look for 'var = value' --- and make sure the var is in lcase. */</comment>

        <for>for (<init><expr><name>cp</name> = <name>parm</name></expr>;</init> <condition><expr>(*<name>cp</name> &amp;&amp; !<call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>cp</name></expr></argument>)</argument_list></call> &amp;&amp; *<name>cp</name> != '=')</expr>;</condition> <incr><expr>++<name>cp</name></expr></incr>)
          <block>{
            <expr_stmt><expr>*<name>cp</name> = <call><name>apr_tolower</name><argument_list>(<argument><expr>*<name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></for>

        <if>if <condition>(<expr>!*<name>cp</name></expr>)</condition><then>
          <block>{
            <continue>continue;</continue>           <comment type="block">/* No '='; just ignore it. */</comment>
          }</block></then></if>

        <expr_stmt><expr>*<name>cp</name>++ = '\0'</expr>;</expr_stmt>           <comment type="block">/* Delimit var */</comment>
        <while>while <condition>(<expr>*<name>cp</name> &amp;&amp; (<call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>cp</name></expr></argument>)</argument_list></call> || *<name>cp</name> == '=')</expr>)</condition>
          <block>{
            <expr_stmt><expr>++<name>cp</name></expr>;</expr_stmt>
          }</block></while>

        <if>if <condition>(<expr>*<name>cp</name> == '"'</expr>)</condition><then>
          <block>{
            <expr_stmt><expr>++<name>cp</name></expr>;</expr_stmt>
            <for>for (<init><expr><name>end</name> = <name>cp</name></expr>;</init>
                 <condition><expr>(*<name>end</name> &amp;&amp; *<name>end</name> != '\n' &amp;&amp; *<name>end</name> != '\r' &amp;&amp; *<name>end</name> != '\"')</expr>;</condition>
                 <incr><expr><name>end</name>++</expr></incr>)<empty_stmt>;</empty_stmt></for>
          }</block></then>
        <else>else
          <block>{
            <for>for (<init><expr><name>end</name> = <name>cp</name></expr>;</init> <condition><expr>(*<name>end</name> &amp;&amp; !<call><name>apr_isspace</name><argument_list>(<argument><expr>*<name>end</name></expr></argument>)</argument_list></call>)</expr>;</condition> <incr><expr><name>end</name>++</expr></incr>)<empty_stmt>;</empty_stmt></for>
          }</block></else></if>
        <if>if <condition>(<expr>*<name>end</name></expr>)</condition><then>
          <block>{
            <expr_stmt><expr>*<name>end</name> = '\0'</expr>;</expr_stmt>        <comment type="block">/* strip ending quote or return */</comment>
          }</block></then></if>
        <expr_stmt><expr><call><name>ap_str_tolower</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><name><name>parm</name><index>[<expr>0</expr>]</index></name> == 'q'
            &amp;&amp; (<name><name>parm</name><index>[<expr>1</expr>]</index></name> == '\0' || (<name><name>parm</name><index>[<expr>1</expr>]</index></name> == 's' &amp;&amp; <name><name>parm</name><index>[<expr>2</expr>]</index></name> == '\0'))</expr>)</condition><then>
          <block>{
            <expr_stmt><expr><name><name>result</name>-&gt;<name>quality</name></name> = (<name>float</name>) <call><name>atof</name><argument_list>(<argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></then></if>
      }</block></while>

    <if>if <condition>(<expr>*<name>accept_line</name> == ','</expr>)</condition><then>
      <block>{
        <expr_stmt><expr>++<name>accept_line</name></expr>;</expr_stmt>
      }</block></then></if>

    <return>return <expr><name>accept_line</name></expr>;</return>
}</block></function>

<comment type="block">/* @a accept_line is the Accept-Encoding header, which is of the
   format:

     Accept-Encoding: name; q=N;

   This function will return an array of accept_rec structures that
   contain the accepted encodings and the quality each one has
   associated with them.
*/</comment>
<function><type><specifier>static</specifier> <name>apr_array_header_t</name> *</type><name>do_header_line</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>p</name></decl></param>,
                                          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>accept_line</name></decl></param>)</parameter_list>
<block>{
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>accept_recs</name></decl>;</decl_stmt>

    <if>if <condition>(<expr>!<name>accept_line</name></expr>)</condition><then>
      <return>return <expr><name>NULL</name></expr>;</return></then></if>

    <expr_stmt><expr><name>accept_recs</name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr>10</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>accept_rec</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <while>while <condition>(<expr>*<name>accept_line</name></expr>)</condition>
      <block>{
        <decl_stmt><decl><type><name>accept_rec</name> *</type><name>prefs</name> <init>= <expr>(<name>accept_rec</name> *) <call><name>apr_array_push</name><argument_list>(<argument><expr><name>accept_recs</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>accept_line</name> = <call><name>get_entry</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>prefs</name></expr></argument>, <argument><expr><name>accept_line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></while>

    <return>return <expr><name>accept_recs</name></expr>;</return>
}</block></function>

<comment type="block">/* ---------------------------------------------------------------------- */</comment>


<comment type="block">/* qsort comparison function for the quality field of the accept_rec
   structure */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>sort_encoding_pref</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>accept_rec1</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>accept_rec2</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>float</name></type> <name>diff</name> <init>= <expr>((const <name>accept_rec</name> *) <name>accept_rec1</name>)-&gt;<name>quality</name> -
      ((const <name>accept_rec</name> *) <name>accept_rec2</name>)-&gt;<name>quality</name></expr></init></decl>;</decl_stmt>
  <return>return <expr>(<name>diff</name> == 0 ? 0 : (<name>diff</name> &gt; 0 ? -1 : 1))</expr>;</return>
}</block></function>

<comment type="block">/* Parse and handle any possible Accept-Encoding header that has been
   sent as part of the request.  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>negotiate_encoding_prefs</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>, <param><decl><type><name>int</name> *</type><name>svndiff_version</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* It would be nice if mod_negotiation
     &lt;http://httpd.apache.org/docs-2.1/mod/mod_negotiation.html&gt; could
     handle the Accept-Encoding header parsing for us.  Sadly, it
     looks like its data structures and routines are private (see
     httpd/modules/mappers/mod_negotiation.c).  Thus, we duplicate the
     necessary ones in this file. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>apr_array_header_t</name> *</type><name>encoding_prefs</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>encoding_prefs</name> = <call><name>do_header_line</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>,
                                  <argument><expr><call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_in</name></name></expr></argument>,
                                                <argument><expr>"Accept-Encoding"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr>!<name>encoding_prefs</name> || <call><name>apr_is_empty_array</name><argument_list>(<argument><expr><name>encoding_prefs</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <expr_stmt><expr>*<name>svndiff_version</name> = 0</expr>;</expr_stmt>
      <return>return;</return>
    }</block></then></if>

  <expr_stmt><expr>*<name>svndiff_version</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name><name>encoding_prefs</name>-&gt;<name>elts</name></name></expr></argument>, <argument><expr>(<name>size_t</name>) <name><name>encoding_prefs</name>-&gt;<name>nelts</name></name></expr></argument>,
        <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>accept_rec</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>sort_encoding_pref</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>encoding_prefs</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <decl_stmt><decl><type>struct <name>accept_rec</name></type> <name>rec</name> <init>= <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>encoding_prefs</name></expr></argument>, <argument><expr><name>i</name></expr></argument>,
                                            <argument>struct <expr><name>accept_rec</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>rec</name>.<name>name</name></name></expr></argument>, <argument><expr>"svndiff1"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
        <block>{
          <expr_stmt><expr>*<name>svndiff_version</name> = 1</expr>;</expr_stmt>
          <break>break;</break>
        }</block></then>
      <else>else <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>rec</name>.<name>name</name></name></expr></argument>, <argument><expr>"svndiff"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
        <block>{
          <expr_stmt><expr>*<name>svndiff_version</name> = 0</expr>;</expr_stmt>
          <break>break;</break>
        }</block></then></if></else></if>
    }</block></for>
}</block></function>


<comment type="block">/* The only two possible values for a capability. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>capability_yes</name> <init>= <expr>"yes"</expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>capability_no</name> <init>= <expr>"no"</expr></init></decl>;</decl_stmt>

<comment type="block">/* Convert CAPABILITIES, a hash table mapping 'const char *' keys to
 * "yes" or "no" values, to a list of all keys whose value is "yes".
 * Return the list, allocated in POOL, and use POOL for all temporary
 * allocation.
 */</comment>
<function><type><specifier>static</specifier> <name>apr_array_header_t</name> *</type>
<name>capabilities_as_list</name><parameter_list>(<param><decl><type><name>apr_hash_t</name> *</type><name>capabilities</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>list</name> <init>= <expr><call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><call><name>apr_hash_count</name><argument_list>(<argument><expr><name>capabilities</name></expr></argument>)</argument_list></call></expr></argument>,
                                            <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>

  <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>capabilities</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>hi</name></expr>;</condition> <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr>(const <name>char</name> *) <name>val</name></expr></argument>, <argument><expr>"yes"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
        <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call> = <name>key</name></expr>;</expr_stmt></then></if>
    }</block></for>

  <return>return <expr><name>list</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>dav_error</name> *</type>
<name>get_resource</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>,
             <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>root_path</name></decl></param>,
             <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>label</name></decl></param>,
             <param><decl><type><name>int</name></type> <name>use_checked_in</name></decl></param>,
             <param><decl><type><name>dav_resource</name> **</type><name>resource</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fs_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>repo_name</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>xslt_uri</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fs_parent_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dav_resource_combined</name> *</type><name>comb</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dav_svn_repos</name> *</type><name>repos</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>cleaned_uri</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>repos_name</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>relative</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>repos_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>repos_key</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>version_name</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>serr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dav_error</name> *</type><name>err</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>had_slash</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dav_locktoken_list</name> *</type><name>ltl</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>cleanup_fs_access_baton</name> *</type><name>cleanup_baton</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> *</type><name>userdata</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>repo_name</name> = <call><name>dav_svn__get_repo_name</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>xslt_uri</name> = <call><name>dav_svn__get_xslt_uri</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>fs_parent_path</name> = <call><name>dav_svn__get_fs_parent_path</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Special case: detect and build the SVNParentPath as a unique type
     of private resource, iff the SVNListParentPath directive is 'on'. */</comment>
  <if>if <condition>(<expr><name>fs_parent_path</name> &amp;&amp; <call><name>dav_svn__get_list_parentpath_flag</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>char</name> *</type><name>uri</name> <init>= <expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>uri</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> *</type><name>parentpath</name> <init>= <expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>root_path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_size_t</name></type> <name>uri_len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>uri</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_size_t</name></type> <name>parentpath_len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>parentpath</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <if>if <condition>(<expr><name><name>uri</name><index>[<expr><name>uri_len</name>-1</expr>]</index></name> == '/'</expr>)</condition><then>
        <expr_stmt><expr><name><name>uri</name><index>[<expr><name>uri_len</name>-1</expr>]</index></name> = '\0'</expr>;</expr_stmt></then></if>

      <if>if <condition>(<expr><name><name>parentpath</name><index>[<expr><name>parentpath_len</name>-1</expr>]</index></name> == '/'</expr>)</condition><then>
        <expr_stmt><expr><name><name>parentpath</name><index>[<expr><name>parentpath_len</name>-1</expr>]</index></name> = '\0'</expr>;</expr_stmt></then></if>

      <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>parentpath</name></expr></argument>, <argument><expr><name>uri</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>err</name> = <call><name>get_parentpath_resource</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>root_path</name></expr></argument>, <argument><expr><name>resource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
            <return>return <expr><name>err</name></expr>;</return></then></if>
          <return>return <expr><name>NULL</name></expr>;</return>
        }</block></then></if>
    }</block></then></if>

  <comment type="block">/* This does all the work of interpreting/splitting the request uri. */</comment>
  <expr_stmt><expr><name>err</name> = <call><name>dav_svn_split_uri</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>uri</name></name></expr></argument>, <argument><expr><name>root_path</name></expr></argument>,
                          <argument><expr>&amp;<name>cleaned_uri</name></expr></argument>, <argument><expr>&amp;<name>had_slash</name></expr></argument>,
                          <argument><expr>&amp;<name>repos_name</name></expr></argument>, <argument><expr>&amp;<name>relative</name></expr></argument>, <argument><expr>&amp;<name>repos_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
    <return>return <expr><name>err</name></expr>;</return></then></if>

  <comment type="block">/* The path that we will eventually try to open as an svn
     repository.  Normally defined by the SVNPath directive. */</comment>
  <expr_stmt><expr><name>fs_path</name> = <call><name>dav_svn__get_fs_path</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If the SVNParentPath directive was used instead... */</comment>
  <if>if <condition>(<expr><name>fs_parent_path</name> != <name>NULL</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* ...then the URL to the repository is actually one implicit
         component longer... */</comment>
      <expr_stmt><expr><name>root_path</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>root_path</name></expr></argument>, <argument><expr><name>repos_name</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* ...and we need to specify exactly what repository to open. */</comment>
      <expr_stmt><expr><name>fs_path</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>fs_parent_path</name></expr></argument>, <argument><expr><name>repos_name</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* Start building and filling a 'combination' object. */</comment>
  <expr_stmt><expr><name>comb</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>comb</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>comb</name>-&gt;<name>res</name>.<name>info</name></name> = &amp;<name><name>comb</name>-&gt;<name>priv</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>comb</name>-&gt;<name>res</name>.<name>hooks</name></name> = &amp;<name>dav_svn__hooks_repository</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>comb</name>-&gt;<name>res</name>.<name>pool</name></name> = <name><name>r</name>-&gt;<name>pool</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>comb</name>-&gt;<name>res</name>.<name>uri</name></name> = <name>cleaned_uri</name></expr>;</expr_stmt>

  <comment type="block">/* Original request, off which to generate subrequests later. */</comment>
  <expr_stmt><expr><name><name>comb</name>-&gt;<name>priv</name>.<name>r</name></name> = <name>r</name></expr>;</expr_stmt>

  <comment type="block">/* ### ugly hack to carry over Content-Type data to the open_stream, which
     ### does not have access to the request headers. */</comment>
  <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ct</name> <init>= <expr><call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_in</name></name></expr></argument>, <argument><expr>"content-type"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>comb</name>-&gt;<name>priv</name>.<name>is_svndiff</name></name> =
      <name>ct</name> != <name>NULL</name>
      &amp;&amp; <call><name>strcmp</name><argument_list>(<argument><expr><name>ct</name></expr></argument>, <argument><expr><name>SVN_SVNDIFF_MIME_TYPE</name></expr></argument>)</argument_list></call> == 0</expr>;</expr_stmt>
  }</block>

  <expr_stmt><expr><call><name>negotiate_encoding_prefs</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr>&amp;<name><name>comb</name>-&gt;<name>priv</name>.<name>svndiff_version</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* ### and another hack for computing diffs to send to the client */</comment>
  <expr_stmt><expr><name><name>comb</name>-&gt;<name>priv</name>.<name>delta_base</name></name> = <call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_in</name></name></expr></argument>,
                                        <argument><expr><name>SVN_DAV_DELTA_BASE_HEADER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Gather any options requested by an svn client. */</comment>
  <expr_stmt><expr><name><name>comb</name>-&gt;<name>priv</name>.<name>svn_client_options</name></name> = <call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_in</name></name></expr></argument>,
                                                <argument><expr><name>SVN_DAV_OPTIONS_HEADER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* See if the client sent a custom 'version name' request header. */</comment>
  <expr_stmt><expr><name>version_name</name> = <call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_in</name></name></expr></argument>, <argument><expr><name>SVN_DAV_VERSION_NAME_HEADER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>comb</name>-&gt;<name>priv</name>.<name>version_name</name></name>
    = <name>version_name</name> ? <call><name>SVN_STR_TO_REV</name><argument_list>(<argument><expr><name>version_name</name></expr></argument>)</argument_list></call>: <name>SVN_INVALID_REVNUM</name></expr>;</expr_stmt>

  <comment type="block">/* Remember checksums, if any. */</comment>
  <expr_stmt><expr><name><name>comb</name>-&gt;<name>priv</name>.<name>base_checksum</name></name> =
    <call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_in</name></name></expr></argument>, <argument><expr><name>SVN_DAV_BASE_FULLTEXT_MD5_HEADER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>comb</name>-&gt;<name>priv</name>.<name>result_checksum</name></name> =
    <call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_in</name></name></expr></argument>, <argument><expr><name>SVN_DAV_RESULT_FULLTEXT_MD5_HEADER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* "relative" is part of the "uri" string, so it has the proper
     lifetime to store here. */</comment>
  <comment type="block">/* ### that comment no longer applies. we're creating a string with its
     ### own lifetime now. so WHY are we using a string? hmm... */</comment>
  <expr_stmt><expr><name><name>comb</name>-&gt;<name>priv</name>.<name>uri_path</name></name> = <call><name>svn_stringbuf_create</name><argument_list>(<argument><expr><name>relative</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* initialize this until we put something real here */</comment>
  <expr_stmt><expr><name><name>comb</name>-&gt;<name>priv</name>.<name>root</name>.<name>rev</name></name> = <name>SVN_INVALID_REVNUM</name></expr>;</expr_stmt>

  <comment type="block">/* create the repository structure and stash it away */</comment>
  <expr_stmt><expr><name>repos</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>repos</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>repos</name>-&gt;<name>pool</name></name> = <name><name>r</name>-&gt;<name>pool</name></name></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>comb</name>-&gt;<name>priv</name>.<name>repos</name></name> = <name>repos</name></expr>;</expr_stmt>

  <comment type="block">/* We are assuming the root_path will live at least as long as this
     resource. Considering that it typically comes from the per-dir
     config in mod_dav, this is valid for now. */</comment>
  <expr_stmt><expr><name><name>repos</name>-&gt;<name>root_path</name></name> = <call><name>svn_path_uri_encode</name><argument_list>(<argument><expr><name>root_path</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* where is the SVN FS for this resource? */</comment>
  <expr_stmt><expr><name><name>repos</name>-&gt;<name>fs_path</name></name> = <name>fs_path</name></expr>;</expr_stmt>

  <comment type="block">/* A name for the repository */</comment>
  <expr_stmt><expr><name><name>repos</name>-&gt;<name>repo_name</name></name> = <name>repo_name</name></expr>;</expr_stmt>

  <comment type="block">/* The repository filesystem basename */</comment>
  <expr_stmt><expr><name><name>repos</name>-&gt;<name>repo_basename</name></name> = <name>repos_name</name></expr>;</expr_stmt>

  <comment type="block">/* An XSL transformation */</comment>
  <expr_stmt><expr><name><name>repos</name>-&gt;<name>xslt_uri</name></name> = <name>xslt_uri</name></expr>;</expr_stmt>

  <comment type="block">/* Is autoversioning active in this repos? */</comment>
  <expr_stmt><expr><name><name>repos</name>-&gt;<name>autoversioning</name></name> = <call><name>dav_svn__get_autoversioning_flag</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Are bulk updates allowed in this repos? */</comment>
  <expr_stmt><expr><name><name>repos</name>-&gt;<name>bulk_updates</name></name> = <call><name>dav_svn__get_bulk_updates_flag</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Path to activities database */</comment>
  <expr_stmt><expr><name><name>repos</name>-&gt;<name>activities_db</name></name> = <call><name>dav_svn__get_activities_db</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name><name>repos</name>-&gt;<name>activities_db</name></name> == <name>NULL</name></expr>)</condition><then>
    <comment type="block">/* If not specified, use default ($repos/dav/activities.d). */</comment>
    <expr_stmt><expr><name><name>repos</name>-&gt;<name>activities_db</name></name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name><name>repos</name>-&gt;<name>fs_path</name></name></expr></argument>,
                                         <argument><expr><name>DEFAULT_ACTIVITY_DB</name></expr></argument>,
                                         <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else <if>if <condition>(<expr><name>fs_parent_path</name> != <name>NULL</name></expr>)</condition><then>
    <comment type="block">/* If this is a ParentPath-based repository, treat the specified
       path as a similar parent directory. */</comment>
    <expr_stmt><expr><name><name>repos</name>-&gt;<name>activities_db</name></name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name><name>repos</name>-&gt;<name>activities_db</name></name></expr></argument>,
                                         <argument><expr><call><name>svn_path_basename</name><argument_list>(<argument><expr><name><name>repos</name>-&gt;<name>fs_path</name></name></expr></argument>,
                                                           <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                         <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if>

  <comment type="block">/* Remember various bits for later URL construction */</comment>
  <expr_stmt><expr><name><name>repos</name>-&gt;<name>base_url</name></name> = <call><name>ap_construct_url</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>""</expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>repos</name>-&gt;<name>special_uri</name></name> = <call><name>dav_svn__get_special_uri</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Remember who is making this request */</comment>
  <expr_stmt><expr><name><name>repos</name>-&gt;<name>username</name></name> = <name><name>r</name>-&gt;<name>user</name></name></expr>;</expr_stmt>

  <comment type="block">/* Allocate room for capabilities, but don't search for any until
     we know that this is a Subversion client. */</comment>
  <expr_stmt><expr><name><name>repos</name>-&gt;<name>capabilities</name></name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name><name>repos</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Remember if the requesting client is a Subversion client, and if
     so, what its capabilities are. */</comment>
  <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>val</name> <init>= <expr><call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_in</name></name></expr></argument>, <argument><expr>"User-Agent"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <if>if <condition>(<expr><name>val</name> &amp;&amp; (<call><name>ap_strstr_c</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr>"SVN/"</expr></argument>)</argument_list></call> == <name>val</name>)</expr>)</condition><then>
      <block>{
        <expr_stmt><expr><name><name>repos</name>-&gt;<name>is_svn_client</name></name> = <name>TRUE</name></expr>;</expr_stmt>

        <comment type="block">/* Client capabilities are self-reported.  There is no
           guarantee the client actually has the capabilities it says
           it has, we just assume it is in the client's interests to
           report accurately.  Also, we only remember the capabilities
           the server cares about (even though the client may send
           more than that). */</comment>

        <comment type="block">/* Start out assuming no capabilities. */</comment>
        <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name><name>repos</name>-&gt;<name>capabilities</name></name></expr></argument>, <argument><expr><name>SVN_RA_CAPABILITY_MERGEINFO</name></expr></argument>,
                     <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>capability_no</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Then see what we can find. */</comment>
        <expr_stmt><expr><name>val</name> = <call><name>apr_table_get</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_in</name></name></expr></argument>, <argument><expr>"DAV"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>val</name></expr>)</condition><then>
          <block>{
            <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>vals</name>
              <init>= <expr><call><name>svn_cstring_split</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr>","</expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

            <if>if <condition>(<expr><call><name>svn_cstring_match_glob_list</name><argument_list>(<argument><expr><name>SVN_DAV_NS_DAV_SVN_MERGEINFO</name></expr></argument>,
                                            <argument><expr><name>vals</name></expr></argument>)</argument_list></call></expr>)</condition><then>
              <block>{
                <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name><name>repos</name>-&gt;<name>capabilities</name></name></expr></argument>, <argument><expr><name>SVN_RA_CAPABILITY_MERGEINFO</name></expr></argument>,
                             <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>capability_yes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              }</block></then></if>
          }</block></then></if>
      }</block></then></if>
  }</block>

  <comment type="block">/* Retrieve/cache open repository */</comment>
  <expr_stmt><expr><name>repos_key</name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>"mod_dav_svn:"</expr></argument>, <argument><expr><name>fs_path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>apr_pool_userdata_get</name><argument_list>(<argument><expr>&amp;<name>userdata</name></expr></argument>, <argument><expr><name>repos_key</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>connection</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>repos</name>-&gt;<name>repos</name></name> = <name>userdata</name></expr>;</expr_stmt>
  <if>if <condition>(<expr><name><name>repos</name>-&gt;<name>repos</name></name> == <name>NULL</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>serr</name> = <call><name>svn_repos_open</name><argument_list>(<argument><expr>&amp;(<name><name>repos</name>-&gt;<name>repos</name></name>)</expr></argument>, <argument><expr><name>fs_path</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>connection</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>serr</name> != <name>NULL</name></expr>)</condition><then>
        <block>{
          <comment type="block">/* The error returned by svn_repos_open might contain the
             actual path to the failed repository.  We don't want to
             leak that path back to the client, because that would be
             a security risk, but we do want to log the real error on
             the server side. */</comment>
          <return>return <expr><call><name>dav_svn__sanitize_error</name><argument_list>(<argument><expr><name>serr</name></expr></argument>, <argument><expr>"Could not open the requested "
                                         "SVN filesystem"</expr></argument>,
                                         <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>

      <comment type="block">/* Cache the open repos for the next request on this connection */</comment>
      <expr_stmt><expr><call><name>apr_pool_userdata_set</name><argument_list>(<argument><expr><name><name>repos</name>-&gt;<name>repos</name></name></expr></argument>, <argument><expr><name>repos_key</name></expr></argument>,
                            <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>connection</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Store the capabilities of the current connection, making sure
         to use the same pool repos-&gt;repos itself was created in. */</comment>
      <expr_stmt><expr><name>serr</name> = <call><name>svn_repos_remember_client_capabilities</name>
        <argument_list>(<argument><expr><name><name>repos</name>-&gt;<name>repos</name></name></expr></argument>, <argument><expr><call><name>capabilities_as_list</name><argument_list>(<argument><expr><name><name>repos</name>-&gt;<name>capabilities</name></name></expr></argument>,
                                            <argument><expr><name><name>r</name>-&gt;<name>connection</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>serr</name> != <name>NULL</name></expr>)</condition><then>
        <block>{
          <return>return <expr><call><name>dav_svn__sanitize_error</name><argument_list>(<argument><expr><name>serr</name></expr></argument>,
                                         <argument><expr>"Error storing client capabilities "
                                         "in repos object"</expr></argument>,
                                         <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
    }</block></then></if>

  <comment type="block">/* cache the filesystem object */</comment>
  <expr_stmt><expr><name><name>repos</name>-&gt;<name>fs</name></name> = <call><name>svn_repos_fs</name><argument_list>(<argument><expr><name><name>repos</name>-&gt;<name>repos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* capture warnings during cleanup of the FS */</comment>
  <expr_stmt><expr><call><name>svn_fs_set_warning_func</name><argument_list>(<argument><expr><name><name>repos</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>log_warning</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* if an authenticated username is present, attach it to the FS */</comment>
  <if>if <condition>(<expr><name><name>r</name>-&gt;<name>user</name></name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_fs_access_t</name> *</type><name>access_ctx</name></decl>;</decl_stmt>

      <comment type="block">/* The fs is cached in connection-&gt;pool, but the fs access
         context lives in r-&gt;pool.  Because the username or token
         could change on each request, we need to make sure that the
         fs points to a NULL access context after the request is gone. */</comment>
      <expr_stmt><expr><name>cleanup_baton</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>cleanup_baton</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>cleanup_baton</name>-&gt;<name>pool</name></name> = <name><name>r</name>-&gt;<name>pool</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>cleanup_baton</name>-&gt;<name>fs</name></name> = <name><name>repos</name>-&gt;<name>fs</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>apr_pool_cleanup_register</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>cleanup_baton</name></expr></argument>, <argument><expr><name>cleanup_fs_access</name></expr></argument>,
                                <argument><expr><name>apr_pool_cleanup_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Create an access context based on the authenticated username. */</comment>
      <expr_stmt><expr><name>serr</name> = <call><name>svn_fs_create_access</name><argument_list>(<argument><expr>&amp;<name>access_ctx</name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>user</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>serr</name></expr>)</condition><then>
        <block>{
          <return>return <expr><call><name>dav_svn__sanitize_error</name><argument_list>(<argument><expr><name>serr</name></expr></argument>,
                                         <argument><expr>"Could not create fs access context"</expr></argument>,
                                         <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>

      <comment type="block">/* Attach the access context to the fs. */</comment>
      <expr_stmt><expr><name>serr</name> = <call><name>svn_fs_set_access</name><argument_list>(<argument><expr><name><name>repos</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>access_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>serr</name></expr>)</condition><then>
        <block>{
          <return>return <expr><call><name>dav_svn__sanitize_error</name><argument_list>(<argument><expr><name>serr</name></expr></argument>, <argument><expr>"Could not attach access "
                                         "context to fs"</expr></argument>,
                                         <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
    }</block></then></if>

  <comment type="block">/* Look for locktokens in the "If:" request header. */</comment>
  <expr_stmt><expr><name>err</name> = <call><name>dav_get_locktoken_list</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr>&amp;<name>ltl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* dav_get_locktoken_list claims to return a NULL list when no
     locktokens are present.  But it actually throws this error
     instead!  So we're deliberately trapping/ignoring it.

     This is a workaround for a bug in mod_dav.  Remove this when the
     bug is fixed in mod_dav.  See Subversion Issue #2248 */</comment>
  <if>if <condition>(<expr><name>err</name> &amp;&amp; (<name><name>err</name>-&gt;<name>error_id</name></name> != <name>DAV_ERR_IF_ABSENT</name>)</expr>)</condition><then>
    <return>return <expr><name>err</name></expr>;</return></then></if>

  <comment type="block">/* If one or more locktokens are present in the header, push them
     into the filesystem access context. */</comment>
  <if>if <condition>(<expr><name>ltl</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_fs_access_t</name> *</type><name>access_ctx</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>dav_locktoken_list</name> *</type><name>list</name> <init>= <expr><name>ltl</name></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><name>serr</name> = <call><name>svn_fs_get_access</name><argument_list>(<argument><expr>&amp;<name>access_ctx</name></expr></argument>, <argument><expr><name><name>repos</name>-&gt;<name>fs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>serr</name></expr>)</condition><then>
        <block>{
          <return>return <expr><call><name>dav_svn__sanitize_error</name><argument_list>(<argument><expr><name>serr</name></expr></argument>, <argument><expr>"Lock token is in request, "
                                         "but no user name"</expr></argument>,
                                         <argument><expr><name>HTTP_BAD_REQUEST</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>

      <do>do <block>{
        <expr_stmt><expr><name>serr</name> = <call><name>svn_fs_access_add_lock_token</name><argument_list>(<argument><expr><name>access_ctx</name></expr></argument>,
                                            <argument><expr><name><name>list</name>-&gt;<name>locktoken</name>-&gt;<name>uuid_str</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>serr</name></expr>)</condition><then>
          <return>return <expr><call><name>dav_svn__convert_err</name><argument_list>(<argument><expr><name>serr</name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>,
                                      <argument><expr>"Error pushing token into filesystem."</expr></argument>,
                                      <argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>
        <expr_stmt><expr><name>list</name> = <name><name>list</name>-&gt;<name>next</name></name></expr>;</expr_stmt>

      }</block> while <condition>(<expr><name>list</name></expr>)</condition>;</do>
    }</block></then></if>


  <comment type="block">/* Figure out the type of the resource. Note that we have a PARSE step
     which is separate from a PREP step. This is because the PARSE can
     map multiple URLs to the same resource type. The PREP operates on
     the type of the resource. */</comment>

  <comment type="block">/* skip over the leading "/" in the relative URI */</comment>
  <if>if <condition>(<expr><call><name>parse_uri</name><argument_list>(<argument><expr><name>comb</name></expr></argument>, <argument><expr><name>relative</name> + 1</expr></argument>, <argument><expr><name>label</name></expr></argument>, <argument><expr><name>use_checked_in</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <goto>goto <name>malformed_URI</name>;</goto></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SVN_DEBUG</name></cpp:ifdef>
  <if>if <condition>(<expr><name><name>comb</name>-&gt;<name>res</name>.<name>type</name></name> == <name>DAV_RESOURCE_TYPE_UNKNOWN</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* Unknown URI. Return NULL to indicate "no resource" */</comment>
      <expr_stmt><expr><call><name>DBG0</name><argument_list>(<argument><expr>"DESIGN FAILURE: should not be UNKNOWN at this point"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>resource</name> = <name>NULL</name></expr>;</expr_stmt>
      <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* prepare the resource for operation */</comment>
  <if>if <condition>(<expr>(<name>err</name> = <call><name>prep_resource</name><argument_list>(<argument><expr><name>comb</name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then>
    <return>return <expr><name>err</name></expr>;</return></then></if>

  <comment type="block">/* a GET request for a REGULAR collection resource MUST have a trailing
     slash. Redirect to include one if it does not. */</comment>
  <if>if <condition>(<expr><name><name>comb</name>-&gt;<name>res</name>.<name>collection</name></name> &amp;&amp; <name><name>comb</name>-&gt;<name>res</name>.<name>type</name></name> == <name>DAV_RESOURCE_TYPE_REGULAR</name>
      &amp;&amp; !<name>had_slash</name> &amp;&amp; <name><name>r</name>-&gt;<name>method_number</name></name> == <name>M_GET</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* note that we drop r-&gt;args. we don't deal with them anyways */</comment>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>new_path</name> <init>= <expr><call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>,
                                         <argument><expr><call><name>ap_escape_uri</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>r</name>-&gt;<name>uri</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                         <argument><expr>"/"</expr></argument>,
                                         <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_out</name></name></expr></argument>, <argument><expr>"Location"</expr></argument>,
                     <argument><expr><call><name>ap_construct_url</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>new_path</name></expr></argument>, <argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>HTTP_MOVED_PERMANENTLY</name></expr></argument>, <argument><expr>0</expr></argument>,
                           <argument><expr>"Requests for a collection must have a "
                           "trailing slash on the URI."</expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

  <expr_stmt><expr>*<name>resource</name> = &amp;<name><name>comb</name>-&gt;<name>res</name></name></expr>;</expr_stmt>
  <return>return <expr><name>NULL</name></expr>;</return>

 <label><name>malformed_URI</name>:</label>
  <comment type="block">/* A malformed URI error occurs when a URI indicates the "special" area,
     yet it has an improper construction. Generally, this is because some
     doofus typed it in manually or has a buggy client. */</comment>
  <comment type="block">/* ### pick something other than HTTP_INTERNAL_SERVER_ERROR */</comment>
  <comment type="block">/* ### are SVN_ERR_APMOD codes within the right numeric space? */</comment>
  <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>,
                       <argument><expr><name>SVN_ERR_APMOD_MALFORMED_URI</name></expr></argument>,
                       <argument><expr>"The URI indicated a resource within Subversion's "
                       "special resource area, but does not exist. This is "
                       "generally caused by a problem in the client "
                       "software."</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<comment type="block">/* Helper func:  return the parent of PATH, allocated in POOL. */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type>
<name>get_parent_path</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>parentpath</name></decl>, *<decl><type ref="prev"/><name>base_name</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>tmp</name> <init>= <expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>len</name> &gt; 0</expr>)</condition><then>
    <block>{
      <comment type="block">/* Remove any trailing slash; else svn_path_split() asserts. */</comment>
      <if>if <condition>(<expr><name><name>tmp</name><index>[<expr><name>len</name>-1</expr>]</index></name> == '/'</expr>)</condition><then>
        <expr_stmt><expr><name><name>tmp</name><index>[<expr><name>len</name>-1</expr>]</index></name> = '\0'</expr>;</expr_stmt></then></if>
      <expr_stmt><expr><call><name>svn_path_split</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr>&amp;<name>parentpath</name></expr></argument>, <argument><expr>&amp;<name>base_name</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <return>return <expr><name>parentpath</name></expr>;</return>
    }</block></then></if>

  <return>return <expr><name>path</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>dav_error</name> *</type>
<name>get_parent_resource</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl></param>,
                    <param><decl><type><name>dav_resource</name> **</type><name>parent_resource</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>dav_resource</name> *</type><name>parent</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dav_resource_private</name> *</type><name>parentinfo</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>path</name> <init>= <expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>uri_path</name></name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* the root of the repository has no parent */</comment>
  <if>if <condition>(<expr><name><name>path</name>-&gt;<name>len</name></name> == 1 &amp;&amp; *<name><name>path</name>-&gt;<name>data</name></name> == '/'</expr>)</condition><then>
    <block>{
      <expr_stmt><expr>*<name>parent_resource</name> = <name>NULL</name></expr>;</expr_stmt>
      <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>

  <switch>switch <condition>(<expr><name><name>resource</name>-&gt;<name>type</name></name></expr>)</condition>
    <block>{
    <case>case <expr><name>DAV_RESOURCE_TYPE_REGULAR</name></expr>:

      <expr_stmt><expr><name>parent</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>parent</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>parentinfo</name>  = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>parentinfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name><name>parent</name>-&gt;<name>type</name></name> = <name>DAV_RESOURCE_TYPE_REGULAR</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>parent</name>-&gt;<name>exists</name></name> = 1</expr>;</expr_stmt>
      <expr_stmt><expr><name><name>parent</name>-&gt;<name>collection</name></name> = 1</expr>;</expr_stmt>
      <expr_stmt><expr><name><name>parent</name>-&gt;<name>versioned</name></name> = 1</expr>;</expr_stmt>
      <expr_stmt><expr><name><name>parent</name>-&gt;<name>hooks</name></name> = <name><name>resource</name>-&gt;<name>hooks</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>parent</name>-&gt;<name>pool</name></name> = <name><name>resource</name>-&gt;<name>pool</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>parent</name>-&gt;<name>uri</name></name> = <call><name>get_parent_path</name><argument_list>(<argument><expr><name><name>resource</name>-&gt;<name>uri</name></name></expr></argument>, <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>parent</name>-&gt;<name>info</name></name> = <name>parentinfo</name></expr>;</expr_stmt>

      <expr_stmt><expr><name><name>parentinfo</name>-&gt;<name>pool</name></name> = <name><name>resource</name>-&gt;<name>info</name>-&gt;<name>pool</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>parentinfo</name>-&gt;<name>uri_path</name></name> =
        <call><name>svn_stringbuf_create</name><argument_list>(<argument><expr><call><name>get_parent_path</name><argument_list>(<argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>uri_path</name>-&gt;<name>data</name></name></expr></argument>,
                                             <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>parentinfo</name>-&gt;<name>repos</name></name> = <name><name>resource</name>-&gt;<name>info</name>-&gt;<name>repos</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>parentinfo</name>-&gt;<name>root</name></name> = <name><name>resource</name>-&gt;<name>info</name>-&gt;<name>root</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>parentinfo</name>-&gt;<name>r</name></name> = <name><name>resource</name>-&gt;<name>info</name>-&gt;<name>r</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>parentinfo</name>-&gt;<name>svn_client_options</name></name> = <name><name>resource</name>-&gt;<name>info</name>-&gt;<name>svn_client_options</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>parentinfo</name>-&gt;<name>repos_path</name></name> = <call><name>get_parent_path</name><argument_list>(<argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>repos_path</name></name></expr></argument>,
                                               <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr>*<name>parent_resource</name> = <name>parent</name></expr>;</expr_stmt>
      <break>break;</break>

    </case><case>case <expr><name>DAV_RESOURCE_TYPE_WORKING</name></expr>:
      <comment type="block">/* The "/" occurring within the URL of working resources is part of
         its identifier; it does not establish parent resource relationships.
         All working resources have the same parent, which is:
         http://host.name/path2repos/$svn/wrk/
      */</comment>
      <expr_stmt><expr>*<name>parent_resource</name> =
        <call><name>create_private_resource</name><argument_list>(<argument><expr><name>resource</name></expr></argument>, <argument><expr><name>DAV_SVN_RESTYPE_WRK_COLLECTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    </case><case>case <expr><name>DAV_RESOURCE_TYPE_ACTIVITY</name></expr>:
      <expr_stmt><expr>*<name>parent_resource</name> =
        <call><name>create_private_resource</name><argument_list>(<argument><expr><name>resource</name></expr></argument>, <argument><expr><name>DAV_SVN_RESTYPE_ACT_COLLECTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    </case><default>default:
      <comment type="block">/* ### needs more work. need parents for other resource types
         ###
         ### return an error so we can easily identify the cases where
         ### we've called this function unexpectedly. */</comment>
      <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>, <argument><expr>0</expr></argument>,
                           <argument><expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>,
                                        <argument><expr>"get_parent_resource was called for "
                                        "%s (type %d)"</expr></argument>,
                                        <argument><expr><name><name>resource</name>-&gt;<name>uri</name></name></expr></argument>, <argument><expr><name><name>resource</name>-&gt;<name>type</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
      <break>break;</break>
    </default>}</block></switch>

  <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>


<comment type="block">/* does RES2 live in the same repository as RES1? */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>is_our_resource</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>res1</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>res2</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name><name>res1</name>-&gt;<name>hooks</name></name> != <name><name>res2</name>-&gt;<name>hooks</name></name>
      || <call><name>strcmp</name><argument_list>(<argument><expr><name><name>res1</name>-&gt;<name>info</name>-&gt;<name>repos</name>-&gt;<name>fs_path</name></name></expr></argument>, <argument><expr><name><name>res2</name>-&gt;<name>info</name>-&gt;<name>repos</name>-&gt;<name>fs_path</name></name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
    <block>{
      <comment type="block">/* a different provider, or a different FS repository */</comment>
      <return>return <expr>0</expr>;</return>
    }</block></then></if>

  <comment type="block">/* coalesce the repository */</comment>
  <if>if <condition>(<expr><name><name>res1</name>-&gt;<name>info</name>-&gt;<name>repos</name></name> != <name><name>res2</name>-&gt;<name>info</name>-&gt;<name>repos</name></name></expr>)</condition><then>
    <block>{
      <comment type="block">/* ### might be nice to have a pool which we can clear to toss
         ### out the old, redundant repos/fs.  */</comment>

      <comment type="block">/* have res2 point to res1's filesystem */</comment>
      <expr_stmt><expr><name><name>res2</name>-&gt;<name>info</name>-&gt;<name>repos</name></name> = <name><name>res1</name>-&gt;<name>info</name>-&gt;<name>repos</name></name></expr>;</expr_stmt>

      <comment type="block">/* res2's fs_root object is now invalid.  regenerate it using
         the now-shared filesystem. */</comment>
      <if>if <condition>(<expr><name><name>res2</name>-&gt;<name>info</name>-&gt;<name>root</name>.<name>txn_name</name></name></expr>)</condition><then>
        <block>{
          <comment type="block">/* reopen the txn by name */</comment>
          <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><call><name>svn_fs_open_txn</name><argument_list>(<argument><expr>&amp;(<name><name>res2</name>-&gt;<name>info</name>-&gt;<name>root</name>.<name>txn</name></name>)</expr></argument>,
                                          <argument><expr><name><name>res2</name>-&gt;<name>info</name>-&gt;<name>repos</name>-&gt;<name>fs</name></name></expr></argument>,
                                          <argument><expr><name><name>res2</name>-&gt;<name>info</name>-&gt;<name>root</name>.<name>txn_name</name></name></expr></argument>,
                                          <argument><expr><name><name>res2</name>-&gt;<name>info</name>-&gt;<name>repos</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* regenerate the txn "root" object */</comment>
          <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><call><name>svn_fs_txn_root</name><argument_list>(<argument><expr>&amp;(<name><name>res2</name>-&gt;<name>info</name>-&gt;<name>root</name>.<name>root</name></name>)</expr></argument>,
                                          <argument><expr><name><name>res2</name>-&gt;<name>info</name>-&gt;<name>root</name>.<name>txn</name></name></expr></argument>,
                                          <argument><expr><name><name>res2</name>-&gt;<name>info</name>-&gt;<name>repos</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
      <else>else <if>if <condition>(<expr><name><name>res2</name>-&gt;<name>info</name>-&gt;<name>root</name>.<name>rev</name></name></expr>)</condition><then>
        <block>{
          <comment type="block">/* default:  regenerate the revision "root" object */</comment>
          <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><call><name>svn_fs_revision_root</name><argument_list>(<argument><expr>&amp;(<name><name>res2</name>-&gt;<name>info</name>-&gt;<name>root</name>.<name>root</name></name>)</expr></argument>,
                                               <argument><expr><name><name>res2</name>-&gt;<name>info</name>-&gt;<name>repos</name>-&gt;<name>fs</name></name></expr></argument>,
                                               <argument><expr><name><name>res2</name>-&gt;<name>info</name>-&gt;<name>root</name>.<name>rev</name></name></expr></argument>,
                                               <argument><expr><name><name>res2</name>-&gt;<name>info</name>-&gt;<name>repos</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if></else></if>
    }</block></then></if>

  <return>return <expr>1</expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>is_same_resource</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>res1</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>res2</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>!<call><name>is_our_resource</name><argument_list>(<argument><expr><name>res1</name></expr></argument>, <argument><expr><name>res2</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr>0</expr>;</return></then></if>

  <comment type="block">/* ### what if the same resource were reached via two URIs? */</comment>

  <return>return <expr><call><name>svn_stringbuf_compare</name><argument_list>(<argument><expr><name><name>res1</name>-&gt;<name>info</name>-&gt;<name>uri_path</name></name></expr></argument>, <argument><expr><name><name>res2</name>-&gt;<name>info</name>-&gt;<name>uri_path</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>is_parent_resource</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>res1</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>res2</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len1</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>res1</name>-&gt;<name>info</name>-&gt;<name>uri_path</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len2</name></decl>;</decl_stmt>

  <if>if <condition>(<expr>!<call><name>is_our_resource</name><argument_list>(<argument><expr><name>res1</name></expr></argument>, <argument><expr><name>res2</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr>0</expr>;</return></then></if>

  <comment type="block">/* ### what if a resource were reached via two URIs? we ought to define
     ### parent/child relations for resources independent of URIs.
     ### i.e. define a "canonical" location for each resource, then return
     ### the parent based on that location. */</comment>

  <comment type="block">/* res2 is one of our resources, we can use its -&gt;info ptr */</comment>
  <expr_stmt><expr><name>len2</name> = <call><name>strlen</name><argument_list>(<argument><expr><name><name>res2</name>-&gt;<name>info</name>-&gt;<name>uri_path</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr>(<name>len2</name> &gt; <name>len1</name>
          &amp;&amp; <call><name>memcmp</name><argument_list>(<argument><expr><name><name>res1</name>-&gt;<name>info</name>-&gt;<name>uri_path</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>res2</name>-&gt;<name>info</name>-&gt;<name>uri_path</name>-&gt;<name>data</name></name></expr></argument>,
                    <argument><expr><name>len1</name></expr></argument>)</argument_list></call> == 0
          &amp;&amp; <name><name>res2</name>-&gt;<name>info</name>-&gt;<name>uri_path</name>-&gt;<name>data</name><index>[<expr><name>len1</name></expr>]</index></name> == '/')</expr>;</return>
}</block></function>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
<comment type="block">/* Given an apache request R and a ROOT_PATH to the svn location
   block, set *KIND to the node-kind of the URI's associated
   (revision, path) pair, if possible.

   Public uris, baseline collections, version resources, and working
   (non-baseline) resources all have associated (revision, path)
   pairs, and thus one of {svn_node_file, svn_node_dir, svn_node_none}
   will be returned.

   If URI is something more abstract, then set *KIND to
   svn_node_unknown.  This is true for baselines, working baselines,
   version controled configurations, activities, histories, and other
   private resources.
*/</comment>
static dav_error *
resource_kind(request_rec *r,
              const char *uri,
              const char *root_path,
              svn_node_kind_t *kind)
{
  dav_error *derr;
  svn_error_t *serr;
  dav_resource *resource;
  svn_revnum_t base_rev;
  svn_fs_root_t *base_rev_root;
  char *saved_uri;

  <comment type="block">/* Temporarily insert the uri that the user actually wants us to
     convert into a resource.  Typically, this is already r-&gt;uri, so
     this is usually a no-op.  But sometimes the caller may pass in
     the Destination: header uri.

     ### WHAT WE REALLY WANT here is to refactor get_resource,
     so that some alternate interface actually allows us to specify
     the URI to process, i.e. not always process r-&gt;uri.
  */</comment>
  saved_uri = r-&gt;uri;
  r-&gt;uri = apr_pstrdup(r-&gt;pool, uri);

  <comment type="block">/* parse the uri and prep the associated resource. */</comment>
  derr = get_resource(r, root_path,
                      <comment type="block">/* ### I can't believe that every single
                         parser ignores the LABEL and USE_CHECKED_IN
                         args below!! */</comment>
                      "ignored_label", 1,
                      &amp;resource);
  <comment type="block">/* Restore r back to normal. */</comment>
  r-&gt;uri = saved_uri;

  if (derr)
    return derr;

  if (resource-&gt;type == DAV_RESOURCE_TYPE_REGULAR)
    {
      <comment type="block">/* Either a public URI or a bc.  In both cases, prep_regular()
         has already set the 'exists' and 'collection' flags by
         querying the appropriate revision root and path.  */</comment>
      if (! resource-&gt;exists)
        *kind = svn_node_none;
      else
        *kind = resource-&gt;collection ? svn_node_dir : svn_node_file;
    }

  else if (resource-&gt;type == DAV_RESOURCE_TYPE_VERSION)
    {
      if (resource-&gt;baselined)  <comment type="block">/* bln */</comment>
        *kind = svn_node_unknown;

      else <comment type="block">/* ver */</comment>
        {
          derr = fs_check_path(kind, resource-&gt;info-&gt;root.root,
                               resource-&gt;info-&gt;repos_path, r-&gt;pool);
          if (derr != NULL)
            return derr;
        }
    }

  else if (resource-&gt;type == DAV_RESOURCE_TYPE_WORKING)
    {
      if (resource-&gt;baselined) <comment type="block">/* wbl */</comment>
        *kind = svn_node_unknown;

      else <comment type="block">/* wrk */</comment>
        {
          <comment type="block">/* don't call fs_check_path on the txn, but on the original
             revision that the txn is based on. */</comment>
          base_rev = svn_fs_txn_base_revision(resource-&gt;info-&gt;root.txn);
          serr = svn_fs_revision_root(&amp;base_rev_root,
                                      resource-&gt;info-&gt;repos-&gt;fs,
                                      base_rev, r-&gt;pool);
          if (serr)
            return dav_svn__convert_err
              (serr, HTTP_INTERNAL_SERVER_ERROR,
               apr_psprintf(r-&gt;pool,
                            "Could not open root of revision %ld",
                            base_rev),
               r-&gt;pool);

          derr = fs_check_path(kind, base_rev_root,
                               resource-&gt;info-&gt;repos_path, r-&gt;pool);
          if (derr != NULL)
            return derr;
        }
    }

  else
    <comment type="block">/* act, his, vcc, or some other private resource */</comment>
    *kind = svn_node_unknown;

  return NULL;
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<function><type><specifier>static</specifier> <name>dav_error</name> *</type>
<name>open_stream</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl></param>,
            <param><decl><type><name>dav_stream_mode</name></type> <name>mode</name></decl></param>,
            <param><decl><type><name>dav_stream</name> **</type><name>stream</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dav_error</name> *</type><name>derr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>serr</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>mode</name> == <name>DAV_MODE_WRITE_TRUNC</name> || <name>mode</name> == <name>DAV_MODE_WRITE_SEEKABLE</name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr><name><name>resource</name>-&gt;<name>type</name></name> != <name>DAV_RESOURCE_TYPE_WORKING</name></expr>)</condition><then>
        <block>{
          <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>HTTP_METHOD_NOT_ALLOWED</name></expr></argument>, <argument><expr>0</expr></argument>,
                               <argument><expr>"Resource body changes may only be made to "
                               "working resources [at this time]."</expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
    }</block></then></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>1</expr></cpp:if>
  <if>if <condition>(<expr><name>mode</name> == <name>DAV_MODE_WRITE_SEEKABLE</name></expr>)</condition><then>
    <block>{
      <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>HTTP_NOT_IMPLEMENTED</name></expr></argument>, <argument><expr>0</expr></argument>,
                           <argument><expr>"Resource body writes cannot use ranges "
                           "[at this time]."</expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* start building the stream structure */</comment>
  <expr_stmt><expr>*<name>stream</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>**<name>stream</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>(*<name>stream</name>)-&gt;<name>res</name></name> = <name>resource</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>derr</name> = <call><name>fs_check_path</name><argument_list>(<argument><expr>&amp;<name>kind</name></expr></argument>, <argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>root</name>.<name>root</name></name></expr></argument>,
                       <argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>repos_path</name></name></expr></argument>, <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>derr</name> != <name>NULL</name></expr>)</condition><then>
    <return>return <expr><name>derr</name></expr>;</return></then></if>

  <if>if <condition>(<expr><name>kind</name> == <name>svn_node_none</name></expr>)</condition><then> <comment type="block">/* No existing file. */</comment>
    <block>{
      <expr_stmt><expr><name>serr</name> = <call><name>svn_fs_make_file</name><argument_list>(<argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>root</name>.<name>root</name></name></expr></argument>,
                              <argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>repos_path</name></name></expr></argument>,
                              <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr><name>serr</name> != <name>NULL</name></expr>)</condition><then>
        <block>{
          <return>return <expr><call><name>dav_svn__convert_err</name><argument_list>(<argument><expr><name>serr</name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>,
                                      <argument><expr>"Could not create file within the "
                                      "repository."</expr></argument>,
                                      <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
    }</block></then></if>

  <comment type="block">/* if the working-resource was auto-checked-out (i.e. came into
     existence through the autoversioning feature), then possibly set
     the svn:mime-type property based on whatever value mod_mime has
     chosen.  If the path already has an svn:mime-type property
     set, do nothing. */</comment>
  <if>if <condition>(<expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>auto_checked_out</name></name>
      &amp;&amp; <name><name>resource</name>-&gt;<name>info</name>-&gt;<name>r</name>-&gt;<name>content_type</name></name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>mime_type</name></decl>;</decl_stmt>

      <expr_stmt><expr><name>serr</name> = <call><name>svn_fs_node_prop</name><argument_list>(<argument><expr>&amp;<name>mime_type</name></expr></argument>,
                              <argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>root</name>.<name>root</name></name></expr></argument>,
                              <argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>repos_path</name></name></expr></argument>,
                              <argument><expr><name>SVN_PROP_MIME_TYPE</name></expr></argument>,
                              <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr><name>serr</name> != <name>NULL</name></expr>)</condition><then>
        <block>{
          <return>return <expr><call><name>dav_svn__convert_err</name><argument_list>(<argument><expr><name>serr</name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>,
                                      <argument><expr>"Error fetching mime-type property."</expr></argument>,
                                      <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>

      <if>if <condition>(<expr>!<name>mime_type</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>serr</name> = <call><name>svn_fs_change_node_prop</name><argument_list>(<argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>root</name>.<name>root</name></name></expr></argument>,
                                         <argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>repos_path</name></name></expr></argument>,
                                         <argument><expr><name>SVN_PROP_MIME_TYPE</name></expr></argument>,
                                         <argument><expr><call><name>svn_string_create</name>
                                             <argument_list>(<argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>r</name>-&gt;<name>content_type</name></name></expr></argument>,
                                              <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                         <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>serr</name> != <name>NULL</name></expr>)</condition><then>
            <block>{
              <return>return <expr><call><name>dav_svn__convert_err</name><argument_list>(<argument><expr><name>serr</name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>,
                                          <argument><expr>"Could not set mime-type property."</expr></argument>,
                                          <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</return>
            }</block></then></if>
        }</block></then></if>
    }</block></then></if>

  <expr_stmt><expr><name>serr</name> = <call><name>svn_fs_apply_textdelta</name><argument_list>(<argument><expr>&amp;<name>(*<name>stream</name>)-&gt;<name>delta_handler</name></name></expr></argument>,
                                <argument><expr>&amp;<name>(*<name>stream</name>)-&gt;<name>delta_baton</name></name></expr></argument>,
                                <argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>root</name>.<name>root</name></name></expr></argument>,
                                <argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>repos_path</name></name></expr></argument>,
                                <argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>base_checksum</name></name></expr></argument>,
                                <argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>result_checksum</name></name></expr></argument>,
                                <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>serr</name> != <name>NULL</name></expr>)</condition><then>
    <block>{
      <return>return <expr><call><name>dav_svn__convert_err</name><argument_list>(<argument><expr><name>serr</name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>,
                                  <argument><expr>"Could not prepare to write the file"</expr></argument>,
                                  <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

  <comment type="block">/* if the incoming data is an SVNDIFF, then create a stream that
     will process the data into windows and invoke the FS window handler
     when a window is ready. */</comment>
  <comment type="block">/* ### we need a better way to check the content-type! this is bogus
     ### because we're effectively looking at the request_rec. doubly
     ### bogus because this means you cannot open arbitrary streams and
     ### feed them content (the type is always tied to a request_rec).
     ### probably ought to pass the type to open_stream */</comment>
  <if>if <condition>(<expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>is_svndiff</name></name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>(*<name>stream</name>)-&gt;<name>wstream</name></name> =
        <call><name>svn_txdelta_parse_svndiff</name><argument_list>(<argument><expr><name>(*<name>stream</name>)-&gt;<name>delta_handler</name></name></expr></argument>,
                                  <argument><expr><name>(*<name>stream</name>)-&gt;<name>delta_baton</name></name></expr></argument>,
                                  <argument><expr><name>TRUE</name></expr></argument>,
                                  <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>dav_error</name> *</type>
<name>close_stream</name><parameter_list>(<param><decl><type><name>dav_stream</name> *</type><name>stream</name></decl></param>, <param><decl><type><name>int</name></type> <name>commit</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>serr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name> <init>= <expr><name><name>stream</name>-&gt;<name>res</name>-&gt;<name>pool</name></name></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name><name>stream</name>-&gt;<name>rstream</name></name> != <name>NULL</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>serr</name> = <call><name>svn_stream_close</name><argument_list>(<argument><expr><name><name>stream</name>-&gt;<name>rstream</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>serr</name></expr>)</condition><then>
        <return>return <expr><call><name>dav_svn__convert_err</name>
          <argument_list>(<argument><expr><name>serr</name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>,
           <argument><expr>"mod_dav_svn close_stream: error closing read stream"</expr></argument>,
           <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
    }</block></then></if>

  <comment type="block">/* if we have a write-stream, then closing it also takes care of the
     handler (so make sure not to send a NULL to it, too) */</comment>
  <if>if <condition>(<expr><name><name>stream</name>-&gt;<name>wstream</name></name> != <name>NULL</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>serr</name> = <call><name>svn_stream_close</name><argument_list>(<argument><expr><name><name>stream</name>-&gt;<name>wstream</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>serr</name></expr>)</condition><then>
        <return>return <expr><call><name>dav_svn__convert_err</name>
          <argument_list>(<argument><expr><name>serr</name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>,
           <argument><expr>"mod_dav_svn close_stream: error closing write stream"</expr></argument>,
           <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
    }</block></then>
  <else>else <if>if <condition>(<expr><name><name>stream</name>-&gt;<name>delta_handler</name></name> != <name>NULL</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>serr</name> = <call>(*<name><name>stream</name>-&gt;<name>delta_handler</name></name>)<argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>stream</name>-&gt;<name>delta_baton</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>serr</name></expr>)</condition><then>
        <return>return <expr><call><name>dav_svn__convert_err</name>
          <argument_list>(<argument><expr><name>serr</name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>,
           <argument><expr>"mod_dav_svn close_stream: error sending final (null) delta window"</expr></argument>,
           <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
    }</block></then></if></else></if>

  <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>dav_error</name> *</type>
<name>write_stream</name><parameter_list>(<param><decl><type><name>dav_stream</name> *</type><name>stream</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>buf</name></decl></param>, <param><decl><type><name>apr_size_t</name></type> <name>bufsize</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>serr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name> <init>= <expr><name><name>stream</name>-&gt;<name>res</name>-&gt;<name>pool</name></name></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name><name>stream</name>-&gt;<name>wstream</name></name> != <name>NULL</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>serr</name> = <call><name>svn_stream_write</name><argument_list>(<argument><expr><name><name>stream</name>-&gt;<name>wstream</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr>&amp;<name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* ### would the returned bufsize ever not match the requested amt? */</comment>
    }</block></then>
  <else>else
    <block>{
      <decl_stmt><decl><type><name>svn_txdelta_window_t</name></type> <name>window</name> <init>= <expr><block>{ <expr>0</expr> }</block></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_txdelta_op_t</name></type> <name>op</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_string_t</name></type> <name>data</name></decl>;</decl_stmt>

      <expr_stmt><expr><name><name>data</name>.<name>data</name></name> = <name>buf</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>data</name>.<name>len</name></name> = <name>bufsize</name></expr>;</expr_stmt>

      <expr_stmt><expr><name><name>op</name>.<name>action_code</name></name> = <name>svn_txdelta_new</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>op</name>.<name>offset</name></name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name><name>op</name>.<name>length</name></name> = <name>bufsize</name></expr>;</expr_stmt>

      <expr_stmt><expr><name><name>window</name>.<name>tview_len</name></name> = <name>bufsize</name></expr>;</expr_stmt>   <comment type="block">/* result will be this long */</comment>
      <expr_stmt><expr><name><name>window</name>.<name>num_ops</name></name> = 1</expr>;</expr_stmt>
      <expr_stmt><expr><name><name>window</name>.<name>ops</name></name> = &amp;<name>op</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>window</name>.<name>new_data</name></name> = &amp;<name>data</name></expr>;</expr_stmt>

      <expr_stmt><expr><name>serr</name> = <call>(*<name><name>stream</name>-&gt;<name>delta_handler</name></name>)<argument_list>(<argument><expr>&amp;<name>window</name></expr></argument>, <argument><expr><name><name>stream</name>-&gt;<name>delta_baton</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

  <if>if <condition>(<expr><name>serr</name></expr>)</condition><then>
    <block>{
      <return>return <expr><call><name>dav_svn__convert_err</name><argument_list>(<argument><expr><name>serr</name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>,
                                  <argument><expr>"could not write the file contents"</expr></argument>,
                                  <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>
  <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>dav_error</name> *</type>
<name>seek_stream</name><parameter_list>(<param><decl><type><name>dav_stream</name> *</type><name>stream</name></decl></param>, <param><decl><type><name>apr_off_t</name></type> <name>abs_position</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* ### fill this in */</comment>

  <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name><name>stream</name>-&gt;<name>res</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>HTTP_NOT_IMPLEMENTED</name></expr></argument>, <argument><expr>0</expr></argument>,
                       <argument><expr>"Resource body read/write cannot use ranges "
                       "(at this time)"</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Returns whether the DAV resource lacks potential for generation of
   an ETag (defined as any of the following):
   - it doesn't exist
   - the resource type isn't REGULAR or VERSION
   - the resource is a Baseline */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RESOURCE_LACKS_ETAG_POTENTIAL</name><parameter_list>(<param><type><name>resource</name></type></param>)</parameter_list></cpp:macro> \
  <cpp:value>(!resource-&gt;exists \
   || (resource-&gt;type != DAV_RESOURCE_TYPE_REGULAR \
       &amp;&amp; resource-&gt;type != DAV_RESOURCE_TYPE_VERSION) \
   || (resource-&gt;type == DAV_RESOURCE_TYPE_VERSION \
       &amp;&amp; resource-&gt;baselined))</cpp:value></cpp:define>


<comment type="block">/* Return the last modification time of RESOURCE, or -1 if the DAV
   resource type is not handled, or if an error occurs.  Temporary
   allocations are made from RESOURCE-&gt;POOL. */</comment>
<function><type><specifier>static</specifier> <name>apr_time_t</name></type>
<name>get_last_modified</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_time_t</name></type> <name>last_modified</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>serr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>created_rev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>date_time</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><call><name>RESOURCE_LACKS_ETAG_POTENTIAL</name><argument_list>(<argument><expr><name>resource</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr>-1</expr>;</return></then></if>

  <if>if <condition>(<expr>(<name>serr</name> = <call><name>svn_fs_node_created_rev</name><argument_list>(<argument><expr>&amp;<name>created_rev</name></expr></argument>, <argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>root</name>.<name>root</name></name></expr></argument>,
                                      <argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>repos_path</name></name></expr></argument>,
                                      <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>serr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr>-1</expr>;</return>
    }</block></then></if>

  <if>if <condition>(<expr>(<name>serr</name> = <call><name>svn_fs_revision_prop</name><argument_list>(<argument><expr>&amp;<name>date_time</name></expr></argument>, <argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>repos</name>-&gt;<name>fs</name></name></expr></argument>,
                                   <argument><expr><name>created_rev</name></expr></argument>, <argument><expr>"svn:date"</expr></argument>, <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>serr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr>-1</expr>;</return>
    }</block></then></if>

  <if>if <condition>(<expr><name>date_time</name> == <name>NULL</name> || <name><name>date_time</name>-&gt;<name>data</name></name> == <name>NULL</name></expr>)</condition><then>
    <return>return <expr>-1</expr>;</return></then></if>

  <if>if <condition>(<expr>(<name>serr</name> = <call><name>svn_time_from_cstring</name><argument_list>(<argument><expr>&amp;<name>last_modified</name></expr></argument>, <argument><expr><name><name>date_time</name>-&gt;<name>data</name></name></expr></argument>,
                                    <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>serr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr>-1</expr>;</return>
    }</block></then></if>

  <return>return <expr><name>last_modified</name></expr>;</return>
}</block></function>


<function><type><specifier>const</specifier> <name>char</name> *</type>
<name>dav_svn__getetag</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>serr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>created_rev</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><call><name>RESOURCE_LACKS_ETAG_POTENTIAL</name><argument_list>(<argument><expr><name>resource</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr>""</expr>;</return></then></if>

  <comment type="block">/* ### what kind of etag to return for activities, etc.? */</comment>

  <if>if <condition>(<expr>(<name>serr</name> = <call><name>svn_fs_node_created_rev</name><argument_list>(<argument><expr>&amp;<name>created_rev</name></expr></argument>, <argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>root</name>.<name>root</name></name></expr></argument>,
                                      <argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>repos_path</name></name></expr></argument>,
                                      <argument><expr><name>pool</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
    <block>{
      <comment type="block">/* ### what to do? */</comment>
      <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>serr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr>""</expr>;</return>
    }</block></then></if>

  <comment type="block">/* Use the "weak" format of the etag for collections because our GET
     requests on collections include dynamic data (the HEAD revision,
     the build version of Subversion, etc.). */</comment>
  <return>return <expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%s\"%ld/%s\""</expr></argument>,
                      <argument><expr><name><name>resource</name>-&gt;<name>collection</name></name> ? "W/" : ""</expr></argument>,
                      <argument><expr><name>created_rev</name></expr></argument>,
                      <argument><expr><call><name>apr_xml_quote_string</name><argument_list>(<argument><expr><name>pool</name></expr></argument>,
                                           <argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>repos_path</name></name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<comment type="block">/* Since dav_svn__getetag() takes a pool argument, this wrapper is for
   the mod_dav hooks vtable entry, which does not. */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type>
<name>getetag_pathetic</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>dav_svn__getetag</name><argument_list>(<argument><expr><name>resource</name></expr></argument>, <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>dav_error</name> *</type>
<name>set_headers</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>serr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_filesize_t</name></type> <name>length</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>mimetype</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_time_t</name></type> <name>last_modified</name></decl>;</decl_stmt>

  <if>if <condition>(<expr>!<name><name>resource</name>-&gt;<name>exists</name></name></expr>)</condition><then>
    <return>return <expr><name>NULL</name></expr>;</return></then></if>

  <expr_stmt><expr><name>last_modified</name> = <call><name>get_last_modified</name><argument_list>(<argument><expr><name>resource</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>last_modified</name> != -1</expr>)</condition><then>
    <block>{
      <comment type="block">/* Note the modification time for the requested resource, and
         include the Last-Modified header in the response. */</comment>
      <expr_stmt><expr><call><name>ap_update_mtime</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>last_modified</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>ap_set_last_modified</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* generate our etag and place it into the output */</comment>
  <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_out</name></name></expr></argument>, <argument><expr>"ETag"</expr></argument>,
                 <argument><expr><call><name>dav_svn__getetag</name><argument_list>(<argument><expr><name>resource</name></expr></argument>, <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
  <comment type="block">/* As version resources don't change, encourage caching. */</comment>
  <comment type="block">/* ### FIXME: This conditional is wrong -- type is often REGULAR,
     ### and the resource doesn't seem to be baselined. */</comment>
  if (resource-&gt;type == DAV_RESOURCE_TYPE_VERSION)
    <comment type="block">/* Cache resource for one week (specified in seconds). */</comment>
    apr_table_setn(r-&gt;headers_out, "Cache-Control", "max-age=604800");
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* we accept byte-ranges */</comment>
  <expr_stmt><expr><call><name>apr_table_setn</name><argument_list>(<argument><expr><name><name>r</name>-&gt;<name>headers_out</name></name></expr></argument>, <argument><expr>"Accept-Ranges"</expr></argument>, <argument><expr>"bytes"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* For a directory, we will send text/html or text/xml. If we have a delta
     base, then we will always be generating an svndiff.  Otherwise,
     we need to fetch the appropriate MIME type from the resource's
     properties (and use text/plain if it isn't there). */</comment>
  <if>if <condition>(<expr><name><name>resource</name>-&gt;<name>collection</name></name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>repos</name>-&gt;<name>xslt_uri</name></name></expr>)</condition><then>
        <expr_stmt><expr><name>mimetype</name> = "text/xml"</expr>;</expr_stmt></then>
      <else>else
        <expr_stmt><expr><name>mimetype</name> = "text/html; charset=UTF-8"</expr>;</expr_stmt></else></if>
    }</block></then>
  <else>else <if>if <condition>(<expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>delta_base</name></name> != <name>NULL</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>dav_svn__uri_info</name></type> <name>info</name></decl>;</decl_stmt>

      <comment type="block">/* First order of business is to parse it. */</comment>
      <expr_stmt><expr><name>serr</name> = <call><name>dav_svn__simple_parse_uri</name><argument_list>(<argument><expr>&amp;<name>info</name></expr></argument>, <argument><expr><name>resource</name></expr></argument>,
                                       <argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>delta_base</name></name></expr></argument>,
                                       <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* If we successfully parse the base URL, then send an svndiff. */</comment>
      <if>if <condition>(<expr>(<name>serr</name> == <name>NULL</name>) &amp;&amp; (<name><name>info</name>.<name>rev</name></name> != <name>SVN_INVALID_REVNUM</name>)</expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>mimetype</name> = <name>SVN_SVNDIFF_MIME_TYPE</name></expr>;</expr_stmt>
        }</block></then></if>
      <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>serr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if></else></if>

  <if>if <condition>(<expr>(<name>mimetype</name> == <name>NULL</name>)
      &amp;&amp; ((<name><name>resource</name>-&gt;<name>type</name></name> == <name>DAV_RESOURCE_TYPE_VERSION</name>)
          || (<name><name>resource</name>-&gt;<name>type</name></name> == <name>DAV_RESOURCE_TYPE_REGULAR</name>))
      &amp;&amp; (<name><name>resource</name>-&gt;<name>info</name>-&gt;<name>repos_path</name></name> != <name>NULL</name>)</expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>value</name></decl>;</decl_stmt>

      <expr_stmt><expr><name>serr</name> = <call><name>svn_fs_node_prop</name><argument_list>(<argument><expr>&amp;<name>value</name></expr></argument>,
                              <argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>root</name>.<name>root</name></name></expr></argument>,
                              <argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>repos_path</name></name></expr></argument>,
                              <argument><expr><name>SVN_PROP_MIME_TYPE</name></expr></argument>,
                              <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>serr</name> != <name>NULL</name></expr>)</condition><then>
        <return>return <expr><call><name>dav_svn__convert_err</name><argument_list>(<argument><expr><name>serr</name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>,
                                    <argument><expr>"could not fetch the resource's MIME type"</expr></argument>,
                                    <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>

      <if>if <condition>(<expr><name>value</name></expr>)</condition><then>
        <expr_stmt><expr><name>mimetype</name> = <name><name>value</name>-&gt;<name>data</name></name></expr>;</expr_stmt></then>
      <else>else <if>if <condition>(<expr>(! <name><name>resource</name>-&gt;<name>info</name>-&gt;<name>repos</name>-&gt;<name>is_svn_client</name></name>)
               &amp;&amp; <name><name>r</name>-&gt;<name>content_type</name></name></expr>)</condition><then>
        <expr_stmt><expr><name>mimetype</name> = <name><name>r</name>-&gt;<name>content_type</name></name></expr>;</expr_stmt></then>
      <else>else
        <expr_stmt><expr><name>mimetype</name> = <call><name>ap_default_type</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if>

      <expr_stmt><expr><name>serr</name> = <call><name>svn_mime_type_validate</name><argument_list>(<argument><expr><name>mimetype</name></expr></argument>, <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>serr</name></expr>)</condition><then>
        <block>{
          <comment type="block">/* Probably serr-&gt;apr == SVN_ERR_BAD_MIME_TYPE, but
             there's no point even checking.  No matter what the
             error is, we can't derive the mime type from the
             svn:mime-type property.  So we resort to the infamous
             "mime type of last resort." */</comment>
          <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>serr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>mimetype</name> = "application/octet-stream"</expr>;</expr_stmt>
        }</block></then></if>

      <comment type="block">/* if we aren't sending a diff, then we know the length of the file,
         so set up the Content-Length header */</comment>
      <expr_stmt><expr><name>serr</name> = <call><name>svn_fs_file_length</name><argument_list>(<argument><expr>&amp;<name>length</name></expr></argument>,
                                <argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>root</name>.<name>root</name></name></expr></argument>,
                                <argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>repos_path</name></name></expr></argument>,
                                <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>serr</name> != <name>NULL</name></expr>)</condition><then>
        <block>{
          <return>return <expr><call><name>dav_svn__convert_err</name><argument_list>(<argument><expr><name>serr</name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>,
                                      <argument><expr>"could not fetch the resource length"</expr></argument>,
                                      <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
      <expr_stmt><expr><call><name>ap_set_content_length</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr>(<name>apr_off_t</name>) <name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* set the discovered MIME type */</comment>
  <comment type="block">/* ### it would be best to do this during the findct phase... */</comment>
  <expr_stmt><expr><call><name>ap_set_content_type</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>mimetype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>


<typedef>typedef <type><struct>struct <block>{
  <decl_stmt><decl><type><name>ap_filter_t</name> *</type><name>output</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>
}</block></struct></type> <name>diff_ctx_t</name>;</typedef>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>write_to_filter</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>buffer</name></decl></param>, <param><decl><type><name>apr_size_t</name> *</type><name>len</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>diff_ctx_t</name> *</type><name>dc</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_bucket</name> *</type><name>bkt</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name></decl>;</decl_stmt>

  <comment type="block">/* take the current data and shove it into the filter */</comment>
  <expr_stmt><expr><name>bb</name> = <call><name>apr_brigade_create</name><argument_list>(<argument><expr><name><name>dc</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>dc</name>-&gt;<name>output</name>-&gt;<name>c</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>bkt</name> = <call><name>apr_bucket_transient_create</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr>*<name>len</name></expr></argument>, <argument><expr><name><name>dc</name>-&gt;<name>output</name>-&gt;<name>c</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>APR_BRIGADE_INSERT_TAIL</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name>bkt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>(<name>status</name> = <call><name>ap_pass_brigade</name><argument_list>(<argument><expr><name><name>dc</name>-&gt;<name>output</name></name></expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call>) != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
    <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>status</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                            <argument><expr>"Could not write data to filter"</expr></argument>)</argument_list></call></expr>;</return>
  }</block></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>close_filter</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>diff_ctx_t</name> *</type><name>dc</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_bucket</name> *</type><name>bkt</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name></decl>;</decl_stmt>

  <comment type="block">/* done with the file. write an EOS bucket now. */</comment>
  <expr_stmt><expr><name>bb</name> = <call><name>apr_brigade_create</name><argument_list>(<argument><expr><name><name>dc</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>dc</name>-&gt;<name>output</name>-&gt;<name>c</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>bkt</name> = <call><name>apr_bucket_eos_create</name><argument_list>(<argument><expr><name><name>dc</name>-&gt;<name>output</name>-&gt;<name>c</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>APR_BRIGADE_INSERT_TAIL</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name>bkt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>(<name>status</name> = <call><name>ap_pass_brigade</name><argument_list>(<argument><expr><name><name>dc</name>-&gt;<name>output</name></name></expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call>) != <name>APR_SUCCESS</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>status</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>"Could not write EOS to filter"</expr></argument>)</argument_list></call></expr>;</return></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>dav_error</name> *</type>
<name>deliver</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl></param>, <param><decl><type><name>ap_filter_t</name> *</type><name>output</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>serr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_bucket</name> *</type><name>bkt</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name></decl>;</decl_stmt>

  <comment type="block">/* Check resource type */</comment>
  <if>if <condition>(<expr><name><name>resource</name>-&gt;<name>type</name></name> != <name>DAV_RESOURCE_TYPE_REGULAR</name>
      &amp;&amp; <name><name>resource</name>-&gt;<name>type</name></name> != <name>DAV_RESOURCE_TYPE_VERSION</name>
      &amp;&amp; <name><name>resource</name>-&gt;<name>type</name></name> != <name>DAV_RESOURCE_TYPE_WORKING</name>
      &amp;&amp; <name><name>resource</name>-&gt;<name>info</name>-&gt;<name>restype</name></name> != <name>DAV_SVN_RESTYPE_PARENTPATH_COLLECTION</name></expr>)</condition><then>
    <block>{
      <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>HTTP_CONFLICT</name></expr></argument>, <argument><expr>0</expr></argument>,
                           <argument><expr>"Cannot GET this type of resource."</expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

  <if>if <condition>(<expr><name><name>resource</name>-&gt;<name>collection</name></name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>gen_html</name> <init>= <expr>!<name><name>resource</name>-&gt;<name>info</name>-&gt;<name>repos</name>-&gt;<name>xslt_uri</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>entries</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>entry_pool</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>sorted</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

      <comment type="block">/* XML schema for the directory index if xslt_uri is set:

         &lt;?xml version="1.0"?&gt;
         &lt;?xml-stylesheet type="text/xsl" href="[info-&gt;repos-&gt;xslt_uri]"?&gt; */</comment>
      <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>xml_index_dtd</name><index>[]</index></name> <init>=
        <expr>"&lt;!DOCTYPE svn [\n"
        "  &lt;!ELEMENT svn   (index)&gt;\n"
        "  &lt;!ATTLIST svn   version CDATA #REQUIRED\n"
        "                  href    CDATA #REQUIRED&gt;\n"
        "  &lt;!ELEMENT index (updir?, (file | dir)*)&gt;\n"
        "  &lt;!ATTLIST index name    CDATA #IMPLIED\n"
        "                  path    CDATA #IMPLIED\n"
        "                  rev     CDATA #IMPLIED\n"
        "                  base    CDATA #IMPLIED&gt;\n"
        "  &lt;!ELEMENT updir EMPTY&gt;\n"
        "  &lt;!ELEMENT file  EMPTY&gt;\n"
        "  &lt;!ATTLIST file  name    CDATA #REQUIRED\n"
        "                  href    CDATA #REQUIRED&gt;\n"
        "  &lt;!ELEMENT dir   EMPTY&gt;\n"
        "  &lt;!ATTLIST dir   name    CDATA #REQUIRED\n"
        "                  href    CDATA #REQUIRED&gt;\n"
        "]&gt;\n"</expr></init></decl>;</decl_stmt>

      <comment type="block">/* &lt;svn version="1.3.0 (dev-build)"
              href="http://subversion.tigris.org"&gt;
           &lt;index name="[info-&gt;repos-&gt;repo_name]"
                  path="[info-&gt;repos_path]"
                  rev="[info-&gt;root.rev]"&gt;
             &lt;file name="foo" href="foo" /&gt;
             &lt;dir name="bar" href="bar/" /&gt;
           &lt;/index&gt;
         &lt;/svn&gt; */</comment>


      <comment type="block">/* ### TO-DO:  check for a new mod_dav_svn directive here also. */</comment>
      <if>if <condition>(<expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>restype</name></name> == <name>DAV_SVN_RESTYPE_PARENTPATH_COLLECTION</name></expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>dirents</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fs_parent_path</name> <init>=
            <expr><call><name>dav_svn__get_fs_parent_path</name><argument_list>(<argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>r</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

          <expr_stmt><expr><name>serr</name> = <call><name>svn_io_get_dirents2</name><argument_list>(<argument><expr>&amp;<name>dirents</name></expr></argument>, <argument><expr><name>fs_parent_path</name></expr></argument>, <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>serr</name> != <name>NULL</name></expr>)</condition><then>
            <return>return <expr><call><name>dav_svn__convert_err</name><argument_list>(<argument><expr><name>serr</name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>,
                                        <argument><expr>"couldn't fetch dirents of SVNParentPath"</expr></argument>,
                                        <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>

          <comment type="block">/* convert an io dirent hash to an fs dirent hash. */</comment>
          <expr_stmt><expr><name>entries</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>dirents</name></expr></argument>)</argument_list></call></expr>;</init>
               <condition><expr><name>hi</name></expr>;</condition> <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
            <block>{
              <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl>;</decl_stmt>
              <decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>
              <decl_stmt><decl><type><name>svn_io_dirent_t</name> *</type><name>dirent</name></decl>;</decl_stmt>
              <decl_stmt><decl><type><name>svn_fs_dirent_t</name> *</type><name>ent</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>ent</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

              <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>dirent</name> = <name>val</name></expr>;</expr_stmt>

              <if>if <condition>(<expr><name><name>dirent</name>-&gt;<name>kind</name></name> != <name>svn_node_dir</name></expr>)</condition><then>
                <continue>continue;</continue></then></if>

              <expr_stmt><expr><name><name>ent</name>-&gt;<name>name</name></name> = <name>key</name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>ent</name>-&gt;<name>id</name></name> = <name>NULL</name></expr>;</expr_stmt>     <comment type="block">/* ### does it matter? */</comment>
              <expr_stmt><expr><name><name>ent</name>-&gt;<name>kind</name></name> = <name><name>dirent</name>-&gt;<name>kind</name></name></expr>;</expr_stmt>

              <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>entries</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>ent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>

        }</block></then>
      <else>else
        <block>{
          <expr_stmt><expr><name>serr</name> = <call><name>svn_fs_dir_entries</name><argument_list>(<argument><expr>&amp;<name>entries</name></expr></argument>, <argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>root</name>.<name>root</name></name></expr></argument>,
                                    <argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>repos_path</name></name></expr></argument>, <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>serr</name> != <name>NULL</name></expr>)</condition><then>
            <return>return <expr><call><name>dav_svn__convert_err</name><argument_list>(<argument><expr><name>serr</name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>,
                                        <argument><expr>"could not fetch directory entries"</expr></argument>,
                                        <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>
        }</block></else></if>

      <expr_stmt><expr><name>bb</name> = <call><name>apr_brigade_create</name><argument_list>(<argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>output</name>-&gt;<name>c</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr><name>gen_html</name></expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>title</name></decl>;</decl_stmt>
          <if>if <condition>(<expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>repos_path</name></name> == <name>NULL</name></expr>)</condition><then>
            <expr_stmt><expr><name>title</name> = "unknown location"</expr>;</expr_stmt></then>
          <else>else
            <expr_stmt><expr><name>title</name> = <name><name>resource</name>-&gt;<name>info</name>-&gt;<name>repos_path</name></name></expr>;</expr_stmt></else></if>

          <if>if <condition>(<expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>restype</name></name> != <name>DAV_SVN_RESTYPE_PARENTPATH_COLLECTION</name></expr>)</condition><then>
            <block>{
              <if>if <condition>(<expr><call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>root</name>.<name>rev</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <expr_stmt><expr><name>title</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>,
                                     <argument><expr>"Revision %ld: %s"</expr></argument>,
                                     <argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>root</name>.<name>rev</name></name></expr></argument>, <argument><expr><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
              <if>if <condition>(<expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>repos</name>-&gt;<name>repo_basename</name></name></expr>)</condition><then>
                <expr_stmt><expr><name>title</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>"%s - %s"</expr></argument>,
                                     <argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>repos</name>-&gt;<name>repo_basename</name></name></expr></argument>,
                                     <argument><expr><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
              <if>if <condition>(<expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>repos</name>-&gt;<name>repo_name</name></name></expr>)</condition><then>
                <expr_stmt><expr><name>title</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>"%s: %s"</expr></argument>,
                                     <argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>repos</name>-&gt;<name>repo_name</name></name></expr></argument>,
                                     <argument><expr><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            }</block></then></if>

          <expr_stmt><expr><call><name>ap_fprintf</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>, <argument><expr>"&lt;html&gt;&lt;head&gt;&lt;title&gt;%s&lt;/title&gt;&lt;/head&gt;\n"
                     "&lt;body&gt;\n &lt;h2&gt;%s&lt;/h2&gt;\n &lt;ul&gt;\n"</expr></argument>, <argument><expr><name>title</name></expr></argument>, <argument><expr><name>title</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
      <else>else
        <block>{
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name> <init>= <expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>repos</name>-&gt;<name>repo_name</name></name></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>href</name> <init>= <expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>repos_path</name></name></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>base</name> <init>= <expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>repos</name>-&gt;<name>repo_basename</name></name></expr></init></decl>;</decl_stmt>

          <expr_stmt><expr><call><name>ap_fputs</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>, <argument><expr>"&lt;?xml version=\"1.0\"?&gt;\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>ap_fprintf</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>,
                     <argument><expr>"&lt;?xml-stylesheet type=\"text/xsl\" href=\"%s\"?&gt;\n"</expr></argument>,
                     <argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>repos</name>-&gt;<name>xslt_uri</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>ap_fputs</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>, <argument><expr><name>xml_index_dtd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>ap_fputs</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>,
                   <argument><expr>"&lt;svn version=\"" <name>SVN_VERSION</name> "\"\n"
                   "     href=\"http://subversion.tigris.org/\"&gt;\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>ap_fputs</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>, <argument><expr>"  &lt;index"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>name</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>ap_fprintf</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>, <argument><expr>" name=\"%s\""</expr></argument>,
                       <argument><expr><call><name>apr_xml_quote_string</name><argument_list>(<argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
          <if>if <condition>(<expr><call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>root</name>.<name>rev</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name>ap_fprintf</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>, <argument><expr>" rev=\"%ld\""</expr></argument>,
                       <argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>root</name>.<name>rev</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
          <if>if <condition>(<expr><name>href</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>ap_fprintf</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>, <argument><expr>" path=\"%s\""</expr></argument>,
                       <argument><expr><call><name>apr_xml_quote_string</name><argument_list>(<argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>,
                                            <argument><expr><name>href</name></expr></argument>,
                                            <argument><expr>1</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
          <if>if <condition>(<expr><name>base</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>ap_fprintf</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>, <argument><expr>" base=\"%s\""</expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

          <expr_stmt><expr><call><name>ap_fputs</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>, <argument><expr>"&gt;\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>

      <if>if <condition>(<expr>(<name><name>resource</name>-&gt;<name>info</name>-&gt;<name>repos_path</name></name> &amp;&amp; <name><name>resource</name>-&gt;<name>info</name>-&gt;<name>repos_path</name><index>[<expr>1</expr>]</index></name> != '\0')
          &amp;&amp; (<name><name>resource</name>-&gt;<name>info</name>-&gt;<name>restype</name></name> != <name>DAV_SVN_RESTYPE_PARENTPATH_COLLECTION</name>)</expr>)</condition><then>
        <block>{
          <if>if <condition>(<expr><name>gen_html</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>ap_fprintf</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>, <argument><expr>"  &lt;li&gt;&lt;a href=\"../\"&gt;..&lt;/a&gt;&lt;/li&gt;\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
          <else>else
            <expr_stmt><expr><call><name>ap_fprintf</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>, <argument><expr>"    &lt;updir /&gt;\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
        }</block></then></if>

      <comment type="block">/* get a sorted list of the entries */</comment>
      <expr_stmt><expr><name>sorted</name> = <call><name>svn_sort__hash</name><argument_list>(<argument><expr><name>entries</name></expr></argument>, <argument><expr><name>svn_sort_compare_items_as_paths</name></expr></argument>,
                              <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>entry_pool</name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>sorted</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>)
        <block>{
          <decl_stmt><decl><type><specifier>const</specifier> <name>svn_sort__item_t</name> *</type><name>item</name> <init>= <expr>&amp;<call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>sorted</name></expr></argument>, <argument><expr><name>i</name></expr></argument>,
                                                        <argument><expr>const <name>svn_sort__item_t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_dirent_t</name> *</type><name>entry</name> <init>= <expr><name><name>item</name>-&gt;<name>value</name></name></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name> <init>= <expr><name><name>item</name>-&gt;<name>key</name></name></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>href</name> <init>= <expr><name>name</name></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>is_dir</name> <init>= <expr>(<name><name>entry</name>-&gt;<name>kind</name></name> == <name>svn_node_dir</name>)</expr></init></decl>;</decl_stmt>

          <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>entry_pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* append a trailing slash onto the name for directories. we NEED
             this for the href portion so that the relative reference will
             descend properly. for the visible portion, it is just nice. */</comment>
          <comment type="block">/* ### The xml output doesn't like to see a trailing slash on
             ### the visible portion, so avoid that. */</comment>
          <if>if <condition>(<expr><name>is_dir</name></expr>)</condition><then>
            <expr_stmt><expr><name>href</name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name>entry_pool</name></expr></argument>, <argument><expr><name>href</name></expr></argument>, <argument><expr>"/"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

          <if>if <condition>(<expr><name>gen_html</name></expr>)</condition><then>
            <expr_stmt><expr><name>name</name> = <name>href</name></expr>;</expr_stmt></then></if>

          <comment type="block">/* We quote special characters in both XML and HTML. */</comment>
          <expr_stmt><expr><name>name</name> = <call><name>apr_xml_quote_string</name><argument_list>(<argument><expr><name>entry_pool</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr>!<name>gen_html</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* According to httpd-2.0.54/include/httpd.h, ap_os_escape_path()
             behaves differently on different platforms.  It claims to
             "convert an OS path to a URL in an OS dependant way".
             Nevertheless, there appears to be only one implementation
             of the function in httpd, and the code seems completely
             platform independent, so we'll assume it's appropriate for
             mod_dav_svn to use it to quote outbound paths. */</comment>
          <expr_stmt><expr><name>href</name> = <call><name>ap_os_escape_path</name><argument_list>(<argument><expr><name>entry_pool</name></expr></argument>, <argument><expr><name>href</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>href</name> = <call><name>apr_xml_quote_string</name><argument_list>(<argument><expr><name>entry_pool</name></expr></argument>, <argument><expr><name>href</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <if>if <condition>(<expr><name>gen_html</name></expr>)</condition><then>
            <block>{
              <expr_stmt><expr><call><name>ap_fprintf</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>,
                         <argument><expr>"  &lt;li&gt;&lt;a href=\"%s\"&gt;%s&lt;/a&gt;&lt;/li&gt;\n"</expr></argument>,
                         <argument><expr><name>href</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
          <else>else
            <block>{
              <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *<specifier>const</specifier></type> <name>tag</name> <init>= <expr>(<name>is_dir</name> ? "dir" : "file")</expr></init></decl>;</decl_stmt>

              <comment type="block">/* This is where we could search for props */</comment>

              <expr_stmt><expr><call><name>ap_fprintf</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>,
                         <argument><expr>"    &lt;%s name=\"%s\" href=\"%s\" /&gt;\n"</expr></argument>,
                         <argument><expr><name>tag</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>href</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></for>

      <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>entry_pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr><name>gen_html</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>ap_fputs</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>,
                 <argument><expr>" &lt;/ul&gt;\n &lt;hr noshade&gt;&lt;em&gt;Powered by "
                 "&lt;a href=\"http://subversion.tigris.org/\"&gt;Subversion&lt;/a&gt; "
                 "version " <name>SVN_VERSION</name> "."
                 "&lt;/em&gt;\n&lt;/body&gt;&lt;/html&gt;"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
      <else>else
        <expr_stmt><expr><call><name>ap_fputs</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>, <argument><expr>"  &lt;/index&gt;\n&lt;/svn&gt;\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

      <expr_stmt><expr><name>bkt</name> = <call><name>apr_bucket_eos_create</name><argument_list>(<argument><expr><name><name>output</name>-&gt;<name>c</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>APR_BRIGADE_INSERT_TAIL</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name>bkt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr>(<name>status</name> = <call><name>ap_pass_brigade</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call>) != <name>APR_SUCCESS</name></expr>)</condition><then>
        <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>, <argument><expr>0</expr></argument>,
                             <argument><expr>"Could not write EOS to filter."</expr></argument>)</argument_list></call></expr>;</return></then></if>

      <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>


  <comment type="block">/* If we have a base for a delta, then we want to compute an svndiff
     between the provided base and the requested resource. For a simple
     request, then we just grab the file contents. */</comment>
  <if>if <condition>(<expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>delta_base</name></name> != <name>NULL</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>dav_svn__uri_info</name></type> <name>info</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>is_file</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_txdelta_stream_t</name> *</type><name>txd_stream</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>o_stream</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_txdelta_window_handler_t</name></type> <name>handler</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>void</name> *</type> <name>h_baton</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>diff_ctx_t</name></type> <name>dc</name> <init>= <expr><block>{ <expr>0</expr> }</block></expr></init></decl>;</decl_stmt>

      <comment type="block">/* First order of business is to parse it. */</comment>
      <expr_stmt><expr><name>serr</name> = <call><name>dav_svn__simple_parse_uri</name><argument_list>(<argument><expr>&amp;<name>info</name></expr></argument>, <argument><expr><name>resource</name></expr></argument>,
                                       <argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>delta_base</name></name></expr></argument>,
                                       <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* If we successfully parse the base URL, then send an svndiff. */</comment>
      <if>if <condition>(<expr>(<name>serr</name> == <name>NULL</name>) &amp;&amp; (<name><name>info</name>.<name>rev</name></name> != <name>SVN_INVALID_REVNUM</name>)</expr>)</condition><then>
        <block>{
          <comment type="block">/* We are always accessing the base resource by ID, so open
             an ID root. */</comment>
          <expr_stmt><expr><name>serr</name> = <call><name>svn_fs_revision_root</name><argument_list>(<argument><expr>&amp;<name>root</name></expr></argument>, <argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>repos</name>-&gt;<name>fs</name></name></expr></argument>,
                                      <argument><expr><name><name>info</name>.<name>rev</name></name></expr></argument>, <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>serr</name> != <name>NULL</name></expr>)</condition><then>
            <return>return <expr><call><name>dav_svn__convert_err</name><argument_list>(<argument><expr><name>serr</name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>,
                                        <argument><expr>"could not open a root for the base"</expr></argument>,
                                        <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>

          <comment type="block">/* verify that it is a file */</comment>
          <expr_stmt><expr><name>serr</name> = <call><name>svn_fs_is_file</name><argument_list>(<argument><expr>&amp;<name>is_file</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>info</name>.<name>repos_path</name></name></expr></argument>,
                                <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>serr</name> != <name>NULL</name></expr>)</condition><then>
            <return>return <expr><call><name>dav_svn__convert_err</name><argument_list>(<argument><expr><name>serr</name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>,
                                        <argument><expr>"could not determine if the base "
                                        "is really a file"</expr></argument>,
                                        <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>
          <if>if <condition>(<expr>!<name>is_file</name></expr>)</condition><then>
            <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>HTTP_BAD_REQUEST</name></expr></argument>, <argument><expr>0</expr></argument>,
                                 <argument><expr>"the delta base does not refer to a file"</expr></argument>)</argument_list></call></expr>;</return></then></if>

          <comment type="block">/* Okay. Let's open up a delta stream for the client to read. */</comment>
          <expr_stmt><expr><name>serr</name> = <call><name>svn_fs_get_file_delta_stream</name><argument_list>(<argument><expr>&amp;<name>txd_stream</name></expr></argument>,
                                              <argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>info</name>.<name>repos_path</name></name></expr></argument>,
                                              <argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>root</name>.<name>root</name></name></expr></argument>,
                                              <argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>repos_path</name></name></expr></argument>,
                                              <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>serr</name> != <name>NULL</name></expr>)</condition><then>
            <return>return <expr><call><name>dav_svn__convert_err</name><argument_list>(<argument><expr><name>serr</name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>,
                                        <argument><expr>"could not prepare to read a delta"</expr></argument>,
                                        <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>

          <comment type="block">/* create a stream that svndiff data will be written to,
             which will copy it to the network */</comment>
          <expr_stmt><expr><name><name>dc</name>.<name>output</name></name> = <name>output</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>dc</name>.<name>pool</name></name> = <name><name>resource</name>-&gt;<name>pool</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name>o_stream</name> = <call><name>svn_stream_create</name><argument_list>(<argument><expr>&amp;<name>dc</name></expr></argument>, <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>svn_stream_set_write</name><argument_list>(<argument><expr><name>o_stream</name></expr></argument>, <argument><expr><name>write_to_filter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>svn_stream_set_close</name><argument_list>(<argument><expr><name>o_stream</name></expr></argument>, <argument><expr><name>close_filter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* get a handler/baton for writing into the output stream */</comment>
          <expr_stmt><expr><call><name>svn_txdelta_to_svndiff2</name><argument_list>(<argument><expr>&amp;<name>handler</name></expr></argument>, <argument><expr>&amp;<name>h_baton</name></expr></argument>,
                                  <argument><expr><name>o_stream</name></expr></argument>, <argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>svndiff_version</name></name></expr></argument>,
                                  <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* got everything set up. read in delta windows and shove them into
             the handler, which pushes data into the output stream, which goes
             to the network. */</comment>
          <expr_stmt><expr><name>serr</name> = <call><name>svn_txdelta_send_txstream</name><argument_list>(<argument><expr><name>txd_stream</name></expr></argument>, <argument><expr><name>handler</name></expr></argument>, <argument><expr><name>h_baton</name></expr></argument>,
                                           <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>serr</name> != <name>NULL</name></expr>)</condition><then>
            <return>return <expr><call><name>dav_svn__convert_err</name><argument_list>(<argument><expr><name>serr</name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>,
                                        <argument><expr>"could not deliver the txdelta stream"</expr></argument>,
                                        <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>


          <return>return <expr><name>NULL</name></expr>;</return>
        }</block></then>
      <else>else
        <block>{
          <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>serr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></then></if>

  <comment type="block">/* resource-&gt;info-&gt;delta_base is NULL, or we had an invalid base URL */</comment>
    <block>{
      <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>stream</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> *</type><name>block</name></decl>;</decl_stmt>

      <expr_stmt><expr><name>serr</name> = <call><name>svn_fs_file_contents</name><argument_list>(<argument><expr>&amp;<name>stream</name></expr></argument>,
                                  <argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>root</name>.<name>root</name></name></expr></argument>,
                                  <argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>repos_path</name></name></expr></argument>,
                                  <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>serr</name> != <name>NULL</name></expr>)</condition><then>
        <block>{
          <return>return <expr><call><name>dav_svn__convert_err</name><argument_list>(<argument><expr><name>serr</name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>,
                                      <argument><expr>"could not prepare to read the file"</expr></argument>,
                                      <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>

      <comment type="block">/* ### one day in the future, we can create a custom bucket type
         ### which will read from the FS stream on demand */</comment>

      <expr_stmt><expr><name>block</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>SVN__STREAM_CHUNK_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <while>while <condition>(<expr>1</expr>)</condition> <block>{
        <decl_stmt><decl><type><name>apr_size_t</name></type> <name>bufsize</name> <init>= <expr><name>SVN__STREAM_CHUNK_SIZE</name></expr></init></decl>;</decl_stmt>

        <comment type="block">/* read from the FS ... */</comment>
        <expr_stmt><expr><name>serr</name> = <call><name>svn_stream_read</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><name>block</name></expr></argument>, <argument><expr>&amp;<name>bufsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>serr</name> != <name>NULL</name></expr>)</condition><then>
          <block>{
            <return>return <expr><call><name>dav_svn__convert_err</name><argument_list>(<argument><expr><name>serr</name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>,
                                        <argument><expr>"could not read the file contents"</expr></argument>,
                                        <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</return>
          }</block></then></if>
        <if>if <condition>(<expr><name>bufsize</name> == 0</expr>)</condition><then>
          <break>break;</break></then></if>

        <comment type="block">/* build a brigade and write to the filter ... */</comment>
        <expr_stmt><expr><name>bb</name> = <call><name>apr_brigade_create</name><argument_list>(<argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>output</name>-&gt;<name>c</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>bkt</name> = <call><name>apr_bucket_transient_create</name><argument_list>(<argument><expr><name>block</name></expr></argument>, <argument><expr><name>bufsize</name></expr></argument>,
                                          <argument><expr><name><name>output</name>-&gt;<name>c</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>APR_BRIGADE_INSERT_TAIL</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name>bkt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>(<name>status</name> = <call><name>ap_pass_brigade</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call>) != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
          <comment type="block">/* ### what to do with status; and that HTTP code... */</comment>
          <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>, <argument><expr>0</expr></argument>,
                               <argument><expr>"Could not write data to filter."</expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
      }</block></while>

      <comment type="block">/* done with the file. write an EOS bucket now. */</comment>
      <expr_stmt><expr><name>bb</name> = <call><name>apr_brigade_create</name><argument_list>(<argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>output</name>-&gt;<name>c</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>bkt</name> = <call><name>apr_bucket_eos_create</name><argument_list>(<argument><expr><name><name>output</name>-&gt;<name>c</name>-&gt;<name>bucket_alloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>APR_BRIGADE_INSERT_TAIL</name><argument_list>(<argument><expr><name>bb</name></expr></argument>, <argument><expr><name>bkt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr>(<name>status</name> = <call><name>ap_pass_brigade</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name>bb</name></expr></argument>)</argument_list></call>) != <name>APR_SUCCESS</name></expr>)</condition><then> <block>{
        <comment type="block">/* ### what to do with status; and that HTTP code... */</comment>
        <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>, <argument><expr>0</expr></argument>,
                             <argument><expr>"Could not write EOS to filter."</expr></argument>)</argument_list></call></expr>;</return>
      }</block></then></if>

      <return>return <expr><name>NULL</name></expr>;</return>
    }</block>
}</block></function>


<function><type><specifier>static</specifier> <name>dav_error</name> *</type>
<name>create_collection</name><parameter_list>(<param><decl><type><name>dav_resource</name> *</type><name>resource</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>serr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dav_error</name> *</type><name>err</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><name><name>resource</name>-&gt;<name>type</name></name> != <name>DAV_RESOURCE_TYPE_WORKING</name>
      &amp;&amp; <name><name>resource</name>-&gt;<name>type</name></name> != <name>DAV_RESOURCE_TYPE_REGULAR</name></expr>)</condition><then>
    <block>{
      <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>HTTP_METHOD_NOT_ALLOWED</name></expr></argument>, <argument><expr>0</expr></argument>,
                           <argument><expr>"Collections can only be created within a working "
                           "or regular collection [at this time]."</expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

  <comment type="block">/* ...regular resources allowed only if autoversioning is turned on. */</comment>
  <if>if <condition>(<expr><name><name>resource</name>-&gt;<name>type</name></name> == <name>DAV_RESOURCE_TYPE_REGULAR</name>
      &amp;&amp; ! (<name><name>resource</name>-&gt;<name>info</name>-&gt;<name>repos</name>-&gt;<name>autoversioning</name></name>)</expr>)</condition><then>
    <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>HTTP_METHOD_NOT_ALLOWED</name></expr></argument>, <argument><expr>0</expr></argument>,
                         <argument><expr>"MKCOL called on regular resource, but "
                         "autoversioning is not active."</expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* ### note that the parent was checked out at some point, and this
     ### is being preformed relative to the working rsrc for that parent */</comment>

  <comment type="block">/* Auto-versioning mkcol of regular resource: */</comment>
  <if>if <condition>(<expr><name><name>resource</name>-&gt;<name>type</name></name> == <name>DAV_RESOURCE_TYPE_REGULAR</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* Change the VCR into a WR, in place.  This creates a txn and
         changes resource-&gt;info-&gt;root from a rev-root into a txn-root. */</comment>
      <expr_stmt><expr><name>err</name> = <call><name>dav_svn__checkout</name><argument_list>(<argument><expr><name>resource</name></expr></argument>,
                              <argument><expr>1</expr></argument> <comment type="block">/* auto-checkout */</comment>,
                              <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
        <return>return <expr><name>err</name></expr>;</return></then></if>
    }</block></then></if>

  <if>if <condition>(<expr>(<name>serr</name> = <call><name>svn_fs_make_dir</name><argument_list>(<argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>root</name>.<name>root</name></name></expr></argument>,
                              <argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>repos_path</name></name></expr></argument>,
                              <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* ### need a better error */</comment>
      <return>return <expr><call><name>dav_svn__convert_err</name><argument_list>(<argument><expr><name>serr</name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>,
                                  <argument><expr>"Could not create the collection."</expr></argument>,
                                  <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

  <comment type="block">/* Auto-versioning commit of the txn. */</comment>
  <if>if <condition>(<expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>auto_checked_out</name></name></expr>)</condition><then>
    <block>{
      <comment type="block">/* This also changes the WR back into a VCR, in place. */</comment>
      <expr_stmt><expr><name>err</name> = <call><name>dav_svn__checkin</name><argument_list>(<argument><expr><name>resource</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
        <return>return <expr><name>err</name></expr>;</return></then></if>
    }</block></then></if>

  <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>dav_error</name> *</type>
<name>copy_resource</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>src</name></decl></param>,
              <param><decl><type><name>dav_resource</name> *</type><name>dst</name></decl></param>,
              <param><decl><type><name>int</name></type> <name>depth</name></decl></param>,
              <param><decl><type><name>dav_response</name> **</type><name>response</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>serr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dav_error</name> *</type><name>err</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>src_repos_path</name></decl>, *<decl><type ref="prev"/><name>dst_repos_path</name></decl>;</decl_stmt>

  <comment type="block">/* ### source must be from a collection under baseline control. the
     ### baseline will (implicitly) indicate the source revision, and the
     ### path will be derived simply from the URL path */</comment>

  <comment type="block">/* ### the destination's parent must be a working collection */</comment>

  <comment type="block">/* ### ben goofing around: */</comment>
  <comment type="block">/*  char *msg;
      apr_psprintf
      (src-&gt;pool, "Got a COPY request with src arg '%s' and dst arg '%s'",
      src-&gt;uri, dst-&gt;uri);

      return dav_new_error(src-&gt;pool, HTTP_NOT_IMPLEMENTED, 0, msg);
  */</comment>

  <comment type="block">/* ### Safeguard: see issue #916, whereby we're allowing an
     auto-checkout of a baseline for PROPPATCHing, *without* creating
     a new baseline afterwards.  We need to safeguard here that nobody
     is calling COPY with the baseline as a Destination! */</comment>
  <if>if <condition>(<expr><name><name>dst</name>-&gt;<name>baselined</name></name> &amp;&amp; <name><name>dst</name>-&gt;<name>type</name></name> == <name>DAV_RESOURCE_TYPE_VERSION</name></expr>)</condition><then>
    <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name><name>src</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>HTTP_PRECONDITION_FAILED</name></expr></argument>, <argument><expr>0</expr></argument>,
                         <argument><expr>"Illegal: COPY Destination is a baseline."</expr></argument>)</argument_list></call></expr>;</return></then></if>

  <if>if <condition>(<expr><name><name>dst</name>-&gt;<name>type</name></name> == <name>DAV_RESOURCE_TYPE_REGULAR</name>
      &amp;&amp; !(<name><name>dst</name>-&gt;<name>info</name>-&gt;<name>repos</name>-&gt;<name>autoversioning</name></name>)</expr>)</condition><then>
    <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name><name>dst</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>HTTP_METHOD_NOT_ALLOWED</name></expr></argument>, <argument><expr>0</expr></argument>,
                         <argument><expr>"COPY called on regular resource, but "
                         "autoversioning is not active."</expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Auto-versioning copy of regular resource: */</comment>
  <if>if <condition>(<expr><name><name>dst</name>-&gt;<name>type</name></name> == <name>DAV_RESOURCE_TYPE_REGULAR</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* Change the VCR into a WR, in place.  This creates a txn and
         changes dst-&gt;info-&gt;root from a rev-root into a txn-root. */</comment>
      <expr_stmt><expr><name>err</name> = <call><name>dav_svn__checkout</name><argument_list>(<argument><expr><name>dst</name></expr></argument>,
                              <argument><expr>1</expr></argument> <comment type="block">/* auto-checkout */</comment>,
                              <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
        <return>return <expr><name>err</name></expr>;</return></then></if>
    }</block></then></if>

  <expr_stmt><expr><name>serr</name> = <call><name>svn_path_get_absolute</name><argument_list>(<argument><expr>&amp;<name>src_repos_path</name></expr></argument>,
                               <argument><expr><call><name>svn_repos_path</name><argument_list>(<argument><expr><name><name>src</name>-&gt;<name>info</name>-&gt;<name>repos</name>-&gt;<name>repos</name></name></expr></argument>,
                                              <argument><expr><name><name>src</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>,
                               <argument><expr><name><name>src</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<name>serr</name></expr>)</condition><then>
    <expr_stmt><expr><name>serr</name> = <call><name>svn_path_get_absolute</name><argument_list>(<argument><expr>&amp;<name>dst_repos_path</name></expr></argument>,
                                 <argument><expr><call><name>svn_repos_path</name><argument_list>(<argument><expr><name><name>dst</name>-&gt;<name>info</name>-&gt;<name>repos</name>-&gt;<name>repos</name></name></expr></argument>,
                                                <argument><expr><name><name>dst</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><name><name>dst</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <if>if <condition>(<expr>!<name>serr</name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>src_repos_path</name></expr></argument>, <argument><expr><name>dst_repos_path</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
        <return>return <expr><call><name>dav_svn__new_error_tag</name>
          <argument_list>(<argument><expr><name><name>dst</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>, <argument><expr>0</expr></argument>,
           <argument><expr>"Copy source and destination are in different repositories."</expr></argument>,
           <argument><expr><name>SVN_DAV_ERROR_NAMESPACE</name></expr></argument>, <argument><expr><name>SVN_DAV_ERROR_TAG</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
      <expr_stmt><expr><name>serr</name> = <call><name>svn_fs_copy</name><argument_list>(<argument><expr><name><name>src</name>-&gt;<name>info</name>-&gt;<name>root</name>.<name>root</name></name></expr></argument>,  <comment type="block">/* root object of src rev*/</comment>
                         <argument><expr><name><name>src</name>-&gt;<name>info</name>-&gt;<name>repos_path</name></name></expr></argument>, <comment type="block">/* relative path of src */</comment>
                         <argument><expr><name><name>dst</name>-&gt;<name>info</name>-&gt;<name>root</name>.<name>root</name></name></expr></argument>,  <comment type="block">/* root object of dst txn*/</comment>
                         <argument><expr><name><name>dst</name>-&gt;<name>info</name>-&gt;<name>repos_path</name></name></expr></argument>, <comment type="block">/* relative path of dst */</comment>
                         <argument><expr><name><name>src</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  <if>if <condition>(<expr><name>serr</name></expr>)</condition><then>
    <return>return <expr><call><name>dav_svn__convert_err</name><argument_list>(<argument><expr><name>serr</name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>,
                                <argument><expr>"Unable to make a filesystem copy."</expr></argument>,
                                <argument><expr><name><name>dst</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Auto-versioning commit of the txn. */</comment>
  <if>if <condition>(<expr><name><name>dst</name>-&gt;<name>info</name>-&gt;<name>auto_checked_out</name></name></expr>)</condition><then>
    <block>{
      <comment type="block">/* This also changes the WR back into a VCR, in place. */</comment>
      <expr_stmt><expr><name>err</name> = <call><name>dav_svn__checkin</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
        <return>return <expr><name>err</name></expr>;</return></then></if>
    }</block></then></if>

  <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>dav_error</name> *</type>
<name>remove_resource</name><parameter_list>(<param><decl><type><name>dav_resource</name> *</type><name>resource</name></decl></param>, <param><decl><type><name>dav_response</name> **</type><name>response</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>serr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dav_error</name> *</type><name>err</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>locks</name></decl>;</decl_stmt>

  <comment type="block">/* Only activities, and working or regular resources can be deleted... */</comment>
  <if>if <condition>(<expr><name><name>resource</name>-&gt;<name>type</name></name> != <name>DAV_RESOURCE_TYPE_WORKING</name>
      &amp;&amp; <name><name>resource</name>-&gt;<name>type</name></name> != <name>DAV_RESOURCE_TYPE_REGULAR</name>
      &amp;&amp; <name><name>resource</name>-&gt;<name>type</name></name> != <name>DAV_RESOURCE_TYPE_ACTIVITY</name></expr>)</condition><then>
    <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>HTTP_METHOD_NOT_ALLOWED</name></expr></argument>, <argument><expr>0</expr></argument>,
                           <argument><expr>"DELETE called on invalid resource type."</expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* ...and regular resources only if autoversioning is turned on. */</comment>
  <if>if <condition>(<expr><name><name>resource</name>-&gt;<name>type</name></name> == <name>DAV_RESOURCE_TYPE_REGULAR</name>
      &amp;&amp; ! (<name><name>resource</name>-&gt;<name>info</name>-&gt;<name>repos</name>-&gt;<name>autoversioning</name></name>)</expr>)</condition><then>
    <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>HTTP_METHOD_NOT_ALLOWED</name></expr></argument>, <argument><expr>0</expr></argument>,
                         <argument><expr>"DELETE called on regular resource, but "
                         "autoversioning is not active."</expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Handle activity deletions (early exit). */</comment>
  <if>if <condition>(<expr><name><name>resource</name>-&gt;<name>type</name></name> == <name>DAV_RESOURCE_TYPE_ACTIVITY</name></expr>)</condition><then>
    <block>{
      <return>return <expr><call><name>dav_svn__delete_activity</name><argument_list>(<argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>repos</name></name></expr></argument>,
                                      <argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>root</name>.<name>activity_id</name></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

  <comment type="block">/* ### note that the parent was checked out at some point, and this
     ### is being preformed relative to the working rsrc for that parent */</comment>

  <comment type="block">/* NOTE: strictly speaking, we cannot determine whether the parent was
     ever checked out, and that this working resource is relative to that
     checked out parent. It is entirely possible the client checked out
     the target resource and just deleted it. Subversion doesn't mind, but
     this does imply we are not enforcing the "checkout the parent, then
     delete from within" semantic. */</comment>

  <comment type="block">/* Auto-versioning delete of regular resource: */</comment>
  <if>if <condition>(<expr><name><name>resource</name>-&gt;<name>type</name></name> == <name>DAV_RESOURCE_TYPE_REGULAR</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* Change the VCR into a WR, in place.  This creates a txn and
         changes resource-&gt;info-&gt;root from a rev-root into a txn-root. */</comment>
      <expr_stmt><expr><name>err</name> = <call><name>dav_svn__checkout</name><argument_list>(<argument><expr><name>resource</name></expr></argument>,
                              <argument><expr>1</expr></argument> <comment type="block">/* auto-checkout */</comment>,
                              <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
        <return>return <expr><name>err</name></expr>;</return></then></if>
    }</block></then></if>

  <comment type="block">/* Sanity check: an svn client may have sent a custom request header
     containing the revision of the item it thinks it's deleting.  In
     this case, we enforce the svn-specific semantic that the item
     must be up-to-date. */</comment>
  <if>if <condition>(<expr><call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>version_name</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>created_rev</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>serr</name> = <call><name>svn_fs_node_created_rev</name><argument_list>(<argument><expr>&amp;<name>created_rev</name></expr></argument>,
                                     <argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>root</name>.<name>root</name></name></expr></argument>,
                                     <argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>repos_path</name></name></expr></argument>,
                                     <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>serr</name></expr>)</condition><then>
        <return>return <expr><call><name>dav_svn__convert_err</name><argument_list>(<argument><expr><name>serr</name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>,
                                    <argument><expr>"Could not get created rev of resource"</expr></argument>,
                                    <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>

      <if>if <condition>(<expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>version_name</name></name> &lt; <name>created_rev</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>serr</name> = <call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_RA_OUT_OF_DATE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                   <argument><expr>"Item '%s' is out of date"</expr></argument>,
                                   <argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>repos_path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><call><name>dav_svn__convert_err</name><argument_list>(<argument><expr><name>serr</name></expr></argument>, <argument><expr><name>HTTP_CONFLICT</name></expr></argument>,
                                      <argument><expr>"Can't DELETE out-of-date resource"</expr></argument>,
                                      <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
    }</block></then></if>

  <comment type="block">/* Before attempting the filesystem delete, we need to push any
     incoming lock-tokens into the filesystem's access_t.  Normally
     they come in via 'If:' header, and get_resource()
     automatically notices them and does this work for us.  In the
     case of a directory deletion, however, svn clients are sending
     'child' lock-tokens in the DELETE request body. */</comment>

  <expr_stmt><expr><name>err</name> = <call><name>dav_svn__build_lock_hash</name><argument_list>(<argument><expr>&amp;<name>locks</name></expr></argument>, <argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>r</name></name></expr></argument>,
                                 <argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>repos_path</name></name></expr></argument>, <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>err</name> != <name>NULL</name></expr>)</condition><then>
    <return>return <expr><name>err</name></expr>;</return></then></if>

  <if>if <condition>(<expr><call><name>apr_hash_count</name><argument_list>(<argument><expr><name>locks</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>err</name> = <call><name>dav_svn__push_locks</name><argument_list>(<argument><expr><name>resource</name></expr></argument>, <argument><expr><name>locks</name></expr></argument>, <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>err</name> != <name>NULL</name></expr>)</condition><then>
        <return>return <expr><name>err</name></expr>;</return></then></if>
    }</block></then></if>

  <if>if <condition>(<expr>(<name>serr</name> = <call><name>svn_fs_delete</name><argument_list>(<argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>root</name>.<name>root</name></name></expr></argument>,
                            <argument><expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>repos_path</name></name></expr></argument>,
                            <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* ### need a better error */</comment>
      <return>return <expr><call><name>dav_svn__convert_err</name><argument_list>(<argument><expr><name>serr</name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>,
                                  <argument><expr>"Could not delete the resource"</expr></argument>,
                                  <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

  <comment type="block">/* Auto-versioning commit of the txn. */</comment>
  <if>if <condition>(<expr><name><name>resource</name>-&gt;<name>info</name>-&gt;<name>auto_checked_out</name></name></expr>)</condition><then>
    <block>{
      <comment type="block">/* This also changes the WR back into a VCR, in place. */</comment>
      <expr_stmt><expr><name>err</name> = <call><name>dav_svn__checkin</name><argument_list>(<argument><expr><name>resource</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
        <return>return <expr><name>err</name></expr>;</return></then></if>
    }</block></then></if>

  <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>dav_error</name> *</type>
<name>move_resource</name><parameter_list>(<param><decl><type><name>dav_resource</name> *</type><name>src</name></decl></param>,
              <param><decl><type><name>dav_resource</name> *</type><name>dst</name></decl></param>,
              <param><decl><type><name>dav_response</name> **</type><name>response</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>serr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dav_error</name> *</type><name>err</name></decl>;</decl_stmt>

  <comment type="block">/* NOTE: The svn client does not call the MOVE method yet. Strictly
     speaking, we do not need to implement this repository function.
     But we do so anyway, so non-deltaV clients can work against the
     repository when autoversioning is turned on.  Like the svn client,
     itself, we define a move to be a copy + delete within a single txn. */</comment>

  <comment type="block">/* Because we have no 'atomic' move, we only allow this method on
     two regular resources with autoversioning active.  That way we
     can auto-checkout a single resource and do the copy + delete
     within a single txn.  (If we had two working resources, which txn
     would we use?) */</comment>
  <if>if <condition>(<expr><name><name>src</name>-&gt;<name>type</name></name> != <name>DAV_RESOURCE_TYPE_REGULAR</name>
      || <name><name>dst</name>-&gt;<name>type</name></name> != <name>DAV_RESOURCE_TYPE_REGULAR</name>
      || !(<name><name>src</name>-&gt;<name>info</name>-&gt;<name>repos</name>-&gt;<name>autoversioning</name></name>)</expr>)</condition><then>
    <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name><name>dst</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>HTTP_METHOD_NOT_ALLOWED</name></expr></argument>, <argument><expr>0</expr></argument>,
                         <argument><expr>"MOVE only allowed on two public URIs, and "
                         "autoversioning must be active."</expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Change the dst VCR into a WR, in place.  This creates a txn and
     changes dst-&gt;info-&gt;root from a rev-root into a txn-root. */</comment>
  <expr_stmt><expr><name>err</name> = <call><name>dav_svn__checkout</name><argument_list>(<argument><expr><name>dst</name></expr></argument>,
                          <argument><expr>1</expr></argument> <comment type="block">/* auto-checkout */</comment>,
                          <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
    <return>return <expr><name>err</name></expr>;</return></then></if>

  <comment type="block">/* Copy the src to the dst. */</comment>
  <expr_stmt><expr><name>serr</name> = <call><name>svn_fs_copy</name><argument_list>(<argument><expr><name><name>src</name>-&gt;<name>info</name>-&gt;<name>root</name>.<name>root</name></name></expr></argument>,  <comment type="block">/* the root object of src rev*/</comment>
                     <argument><expr><name><name>src</name>-&gt;<name>info</name>-&gt;<name>repos_path</name></name></expr></argument>, <comment type="block">/* the relative path of src */</comment>
                     <argument><expr><name><name>dst</name>-&gt;<name>info</name>-&gt;<name>root</name>.<name>root</name></name></expr></argument>,  <comment type="block">/* the root object of dst txn*/</comment>
                     <argument><expr><name><name>dst</name>-&gt;<name>info</name>-&gt;<name>repos_path</name></name></expr></argument>, <comment type="block">/* the relative path of dst */</comment>
                     <argument><expr><name><name>src</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>serr</name></expr>)</condition><then>
    <return>return <expr><call><name>dav_svn__convert_err</name><argument_list>(<argument><expr><name>serr</name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>,
                                <argument><expr>"Unable to make a filesystem copy."</expr></argument>,
                                <argument><expr><name><name>dst</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Notice: we're deleting the src repos path from the dst's txn_root. */</comment>
  <if>if <condition>(<expr>(<name>serr</name> = <call><name>svn_fs_delete</name><argument_list>(<argument><expr><name><name>dst</name>-&gt;<name>info</name>-&gt;<name>root</name>.<name>root</name></name></expr></argument>,
                            <argument><expr><name><name>src</name>-&gt;<name>info</name>-&gt;<name>repos_path</name></name></expr></argument>,
                            <argument><expr><name><name>dst</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition><then>
    <return>return <expr><call><name>dav_svn__convert_err</name><argument_list>(<argument><expr><name>serr</name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>,
                                <argument><expr>"Could not delete the src resource."</expr></argument>,
                                <argument><expr><name><name>dst</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Commit:  this also changes the WR back into a VCR, in place. */</comment>
  <expr_stmt><expr><name>err</name> = <call><name>dav_svn__checkin</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
    <return>return <expr><name>err</name></expr>;</return></then></if>

  <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>


<typedef>typedef <type><struct>struct <block>{
  <comment type="block">/* the input walk parameters */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>dav_walk_params</name> *</type><name>params</name></decl>;</decl_stmt>

  <comment type="block">/* reused as we walk */</comment>
  <decl_stmt><decl><type><name>dav_walk_resource</name></type> <name>wres</name></decl>;</decl_stmt>

  <comment type="block">/* the current resource */</comment>
  <decl_stmt><decl><type><name>dav_resource</name></type> <name>res</name></decl>;</decl_stmt>             <comment type="block">/* wres.resource refers here */</comment>
  <decl_stmt><decl><type><name>dav_resource_private</name></type> <name>info</name></decl>;</decl_stmt>    <comment type="block">/* the info in res */</comment>
  <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>uri</name></decl>;</decl_stmt>            <comment type="block">/* the uri within res */</comment>
  <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>repos_path</name></decl>;</decl_stmt>     <comment type="block">/* the repos_path within res */</comment>

}</block></struct></type> <name>walker_ctx_t</name>;</typedef>


<function><type><specifier>static</specifier> <name>dav_error</name> *</type>
<name>do_walk</name><parameter_list>(<param><decl><type><name>walker_ctx_t</name> *</type><name>ctx</name></decl></param>, <param><decl><type><name>int</name></type> <name>depth</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>dav_walk_params</name> *</type><name>params</name> <init>= <expr><name><name>ctx</name>-&gt;<name>params</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>isdir</name> <init>= <expr><name><name>ctx</name>-&gt;<name>res</name>.<name>collection</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dav_error</name> *</type><name>err</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>serr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>path_len</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>uri_len</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>repos_len</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>children</name></decl>;</decl_stmt>

  <comment type="block">/* Clear the temporary pool. */</comment>
  <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>info</name>.<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* The current resource is a collection (possibly here thru recursion)
     and this is the invocation for the collection. Alternatively, this is
     the first [and only] entry to do_walk() for a member resource, so
     this will be the invocation for the member. */</comment>
  <expr_stmt><expr><name>err</name> = <call>(*<name><name>params</name>-&gt;<name>func</name></name>)<argument_list>(<argument><expr>&amp;<name><name>ctx</name>-&gt;<name>wres</name></name></expr></argument>,
                        <argument><expr><name>isdir</name> ? <name>DAV_CALLTYPE_COLLECTION</name> : <name>DAV_CALLTYPE_MEMBER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>err</name> != <name>NULL</name></expr>)</condition><then>
    <return>return <expr><name>err</name></expr>;</return></then></if>

  <comment type="block">/* if we are not to recurse, or this is a member, then we're done */</comment>
  <if>if <condition>(<expr><name>depth</name> == 0 || !<name>isdir</name></expr>)</condition><then>
    <return>return <expr><name>NULL</name></expr>;</return></then></if>

  <comment type="block">/* ### for now, let's say that working resources have no children. of
     ### course, this isn't true (or "right") for working collections, but
     ### we don't actually need to do a walk right now. */</comment>
  <if>if <condition>(<expr><name><name>params</name>-&gt;<name>root</name>-&gt;<name>type</name></name> == <name>DAV_RESOURCE_TYPE_WORKING</name></expr>)</condition><then>
    <return>return <expr><name>NULL</name></expr>;</return></then></if>

  <comment type="block">/* ### need to allow more walking in the future */</comment>
  <if>if <condition>(<expr><name><name>params</name>-&gt;<name>root</name>-&gt;<name>type</name></name> != <name>DAV_RESOURCE_TYPE_REGULAR</name></expr>)</condition><then>
    <block>{
      <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name><name>params</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>HTTP_METHOD_NOT_ALLOWED</name></expr></argument>, <argument><expr>0</expr></argument>,
                           <argument><expr>"Walking the resource hierarchy can only be done "
                           "on 'regular' resources [at this time]."</expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

  <comment type="block">/* assert: collection resource. isdir == TRUE. repos_path != NULL. */</comment>

  <comment type="block">/* append "/" to the paths, in preparation for appending child names.
     don't add "/" if the paths are simply "/" */</comment>
  <if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>info</name>.<name>uri_path</name>-&gt;<name>data</name><index>[<expr><name><name>ctx</name>-&gt;<name>info</name>.<name>uri_path</name>-&gt;<name>len</name></name> - 1</expr>]</index></name> != '/'</expr>)</condition><then>
    <expr_stmt><expr><call><name>svn_stringbuf_appendcstr</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>info</name>.<name>uri_path</name></name></expr></argument>, <argument><expr>"/"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <if>if <condition>(<expr><name><name>ctx</name>-&gt;<name>repos_path</name>-&gt;<name>data</name><index>[<expr><name><name>ctx</name>-&gt;<name>repos_path</name>-&gt;<name>len</name></name> - 1</expr>]</index></name> != '/'</expr>)</condition><then>
    <expr_stmt><expr><call><name>svn_stringbuf_appendcstr</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>repos_path</name></name></expr></argument>, <argument><expr>"/"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* NOTE: the URI should already have a trailing "/" */</comment>

  <comment type="block">/* fix up the dependent pointers */</comment>
  <expr_stmt><expr><name><name>ctx</name>-&gt;<name>info</name>.<name>repos_path</name></name> = <name><name>ctx</name>-&gt;<name>repos_path</name>-&gt;<name>data</name></name></expr>;</expr_stmt>

  <comment type="block">/* all of the children exist. also initialize the collection flag. */</comment>
  <expr_stmt><expr><name><name>ctx</name>-&gt;<name>res</name>.<name>exists</name></name> = <name>TRUE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ctx</name>-&gt;<name>res</name>.<name>collection</name></name> = <name>FALSE</name></expr>;</expr_stmt>

  <comment type="block">/* remember these values so we can chop back to them after each time
     we append a child name to the path/uri/repos */</comment>
  <expr_stmt><expr><name>path_len</name> = <name><name>ctx</name>-&gt;<name>info</name>.<name>uri_path</name>-&gt;<name>len</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>uri_len</name> = <name><name>ctx</name>-&gt;<name>uri</name>-&gt;<name>len</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>repos_len</name> = <name><name>ctx</name>-&gt;<name>repos_path</name>-&gt;<name>len</name></name></expr>;</expr_stmt>

  <comment type="block">/* Tell our logging subsystem that we're listing a directory.

     Note: if we cared, we could look at the 'User-Agent:' request
     header and distinguish an svn client ('svn ls') from a generic
     DAV client.  */</comment>
  <expr_stmt><expr><call><name>dav_svn__operational_log</name><argument_list>(<argument><expr>&amp;<name><name>ctx</name>-&gt;<name>info</name></name></expr></argument>,
                           <argument><expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>params</name>-&gt;<name>pool</name></name></expr></argument>,
                             <argument><expr>"get-dir %s r%ld text"</expr></argument>,
                             <argument><expr><call><name>svn_path_uri_encode</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>info</name>.<name>repos_path</name></name></expr></argument>,
                                                 <argument><expr><name><name>params</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><name><name>ctx</name>-&gt;<name>info</name>.<name>root</name>.<name>rev</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* fetch this collection's children */</comment>
  <expr_stmt><expr><name>serr</name> = <call><name>svn_fs_dir_entries</name><argument_list>(<argument><expr>&amp;<name>children</name></expr></argument>, <argument><expr><name><name>ctx</name>-&gt;<name>info</name>.<name>root</name>.<name>root</name></name></expr></argument>,
                            <argument><expr><name><name>ctx</name>-&gt;<name>info</name>.<name>repos_path</name></name></expr></argument>, <argument><expr><name><name>params</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>serr</name> != <name>NULL</name></expr>)</condition><then>
    <return>return <expr><call><name>dav_svn__convert_err</name><argument_list>(<argument><expr><name>serr</name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>,
                                <argument><expr>"could not fetch collection members"</expr></argument>,
                                <argument><expr><name><name>params</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* iterate over the children in this collection */</comment>
  <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name><name>params</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>children</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>hi</name></expr>;</condition> <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_ssize_t</name></type> <name>klen</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_fs_dirent_t</name> *</type><name>dirent</name></decl>;</decl_stmt>

      <comment type="block">/* fetch one of the children */</comment>
      <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr>&amp;<name>klen</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>dirent</name> = <name>val</name></expr>;</expr_stmt>

      <comment type="block">/* authorize access to this resource, if applicable */</comment>
      <if>if <condition>(<expr><name><name>params</name>-&gt;<name>walk_type</name></name> &amp; <name>DAV_WALKTYPE_AUTH</name></expr>)</condition><then>
        <block>{
          <comment type="block">/* ### how/what to do? */</comment>
        }</block></then></if>

      <comment type="block">/* append this child to our buffers */</comment>
      <expr_stmt><expr><call><name>svn_stringbuf_appendbytes</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>info</name>.<name>uri_path</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>klen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>svn_stringbuf_appendbytes</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>uri</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>klen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>svn_stringbuf_appendbytes</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>repos_path</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>klen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* reset the pointers since the above may have changed them */</comment>
      <expr_stmt><expr><name><name>ctx</name>-&gt;<name>res</name>.<name>uri</name></name> = <name><name>ctx</name>-&gt;<name>uri</name>-&gt;<name>data</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>ctx</name>-&gt;<name>info</name>.<name>repos_path</name></name> = <name><name>ctx</name>-&gt;<name>repos_path</name>-&gt;<name>data</name></name></expr>;</expr_stmt>

      <if>if <condition>(<expr><name><name>dirent</name>-&gt;<name>kind</name></name> == <name>svn_node_file</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>err</name> = <call>(*<name><name>params</name>-&gt;<name>func</name></name>)<argument_list>(<argument><expr>&amp;<name><name>ctx</name>-&gt;<name>wres</name></name></expr></argument>, <argument><expr><name>DAV_CALLTYPE_MEMBER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>err</name> != <name>NULL</name></expr>)</condition><then>
            <return>return <expr><name>err</name></expr>;</return></then></if>
        }</block></then>
      <else>else
        <block>{
          <comment type="block">/* this resource is a collection */</comment>
          <expr_stmt><expr><name><name>ctx</name>-&gt;<name>res</name>.<name>collection</name></name> = <name>TRUE</name></expr>;</expr_stmt>

          <comment type="block">/* append a slash to the URI (the path doesn't need it yet) */</comment>
          <expr_stmt><expr><call><name>svn_stringbuf_appendcstr</name><argument_list>(<argument><expr><name><name>ctx</name>-&gt;<name>uri</name></name></expr></argument>, <argument><expr>"/"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>ctx</name>-&gt;<name>res</name>.<name>uri</name></name> = <name><name>ctx</name>-&gt;<name>uri</name>-&gt;<name>data</name></name></expr>;</expr_stmt>

          <comment type="block">/* recurse on this collection */</comment>
          <expr_stmt><expr><name>err</name> = <call><name>do_walk</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>depth</name> - 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>err</name> != <name>NULL</name></expr>)</condition><then>
            <return>return <expr><name>err</name></expr>;</return></then></if>

          <comment type="block">/* restore the data */</comment>
          <expr_stmt><expr><name><name>ctx</name>-&gt;<name>res</name>.<name>collection</name></name> = <name>FALSE</name></expr>;</expr_stmt>
        }</block></else></if>

      <comment type="block">/* chop the child off the paths and uri. NOTE: no null-term. */</comment>
      <expr_stmt><expr><name><name>ctx</name>-&gt;<name>info</name>.<name>uri_path</name>-&gt;<name>len</name></name> = <name>path_len</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>ctx</name>-&gt;<name>uri</name>-&gt;<name>len</name></name> = <name>uri_len</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>ctx</name>-&gt;<name>repos_path</name>-&gt;<name>len</name></name> = <name>repos_len</name></expr>;</expr_stmt>
    }</block></for>
  <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>dav_error</name> *</type>
<name>walk</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>dav_walk_params</name> *</type><name>params</name></decl></param>, <param><decl><type><name>int</name></type> <name>depth</name></decl></param>, <param><decl><type><name>dav_response</name> **</type><name>response</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* Thinking about adding support for LOCKNULL resources in this
     walker?  Check out the (working) code that was removed here:
          Author: cmpilato
          Date: Fri Mar 18 14:54:02 2005
          New Revision: 13475
     */</comment>

  <decl_stmt><decl><type><name>walker_ctx_t</name></type> <name>ctx</name> <init>= <expr><block>{ <expr>0</expr> }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dav_error</name> *</type><name>err</name></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>ctx</name>.<name>params</name></name> = <name>params</name></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>ctx</name>.<name>wres</name>.<name>walk_ctx</name></name> = <name><name>params</name>-&gt;<name>walk_ctx</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ctx</name>.<name>wres</name>.<name>pool</name></name> = <name><name>params</name>-&gt;<name>pool</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ctx</name>.<name>wres</name>.<name>resource</name></name> = &amp;<name><name>ctx</name>.<name>res</name></name></expr>;</expr_stmt>

  <comment type="block">/* copy the resource over and adjust the "info" reference */</comment>
  <expr_stmt><expr><name><name>ctx</name>.<name>res</name></name> = *<name><name>params</name>-&gt;<name>root</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ctx</name>.<name>info</name></name> = *<name><name>ctx</name>.<name>res</name>.<name>info</name></name></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>ctx</name>.<name>res</name>.<name>info</name></name> = &amp;<name><name>ctx</name>.<name>info</name></name></expr>;</expr_stmt>

  <comment type="block">/* operate within the proper pool */</comment>
  <expr_stmt><expr><name><name>ctx</name>.<name>res</name>.<name>pool</name></name> = <name><name>params</name>-&gt;<name>pool</name></name></expr>;</expr_stmt>

  <comment type="block">/* Don't monkey with the path from params-&gt;root. Create a new one.
     This path will then be extended/shortened as necessary. */</comment>
  <expr_stmt><expr><name><name>ctx</name>.<name>info</name>.<name>uri_path</name></name> = <call><name>svn_stringbuf_dup</name><argument_list>(<argument><expr><name><name>ctx</name>.<name>info</name>.<name>uri_path</name></name></expr></argument>, <argument><expr><name><name>params</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* prep the URI buffer */</comment>
  <expr_stmt><expr><name><name>ctx</name>.<name>uri</name></name> = <call><name>svn_stringbuf_create</name><argument_list>(<argument><expr><name><name>params</name>-&gt;<name>root</name>-&gt;<name>uri</name></name></expr></argument>, <argument><expr><name><name>params</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* same for repos_path */</comment>
  <if>if <condition>(<expr><name><name>ctx</name>.<name>info</name>.<name>repos_path</name></name> == <name>NULL</name></expr>)</condition><then>
    <expr_stmt><expr><name><name>ctx</name>.<name>repos_path</name></name> = <name>NULL</name></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name><name>ctx</name>.<name>repos_path</name></name> = <call><name>svn_stringbuf_create</name><argument_list>(<argument><expr><name><name>ctx</name>.<name>info</name>.<name>repos_path</name></name></expr></argument>, <argument><expr><name><name>params</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

  <comment type="block">/* if we have a collection, then ensure the URI has a trailing "/" */</comment>
  <comment type="block">/* ### get_resource always kills the trailing slash... */</comment>
  <if>if <condition>(<expr><name><name>ctx</name>.<name>res</name>.<name>collection</name></name> &amp;&amp; <name><name>ctx</name>.<name>uri</name>-&gt;<name>data</name><index>[<expr><name><name>ctx</name>.<name>uri</name>-&gt;<name>len</name></name> - 1</expr>]</index></name> != '/'</expr>)</condition><then> <block>{
    <expr_stmt><expr><call><name>svn_stringbuf_appendcstr</name><argument_list>(<argument><expr><name><name>ctx</name>.<name>uri</name></name></expr></argument>, <argument><expr>"/"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <comment type="block">/* the current resource's URI is stored in the (telescoping) ctx.uri */</comment>
  <expr_stmt><expr><name><name>ctx</name>.<name>res</name>.<name>uri</name></name> = <name><name>ctx</name>.<name>uri</name>-&gt;<name>data</name></name></expr>;</expr_stmt>

  <comment type="block">/* the current resource's repos_path is stored in ctx.repos_path */</comment>
  <if>if <condition>(<expr><name><name>ctx</name>.<name>repos_path</name></name> != <name>NULL</name></expr>)</condition><then>
    <expr_stmt><expr><name><name>ctx</name>.<name>info</name>.<name>repos_path</name></name> = <name><name>ctx</name>.<name>repos_path</name>-&gt;<name>data</name></name></expr>;</expr_stmt></then></if>

  <comment type="block">/* Create a pool usable by the response. */</comment>
  <expr_stmt><expr><name><name>ctx</name>.<name>info</name>.<name>pool</name></name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name><name>params</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* ### is the root already/always open? need to verify */</comment>

  <comment type="block">/* always return the error, and any/all multistatus responses */</comment>
  <expr_stmt><expr><name>err</name> = <call><name>do_walk</name><argument_list>(<argument><expr>&amp;<name>ctx</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>response</name> = <name><name>ctx</name>.<name>wres</name>.<name>response</name></name></expr>;</expr_stmt>

  <return>return <expr><name>err</name></expr>;</return>
}</block></function>


<escape char="0xc"/>
<comment type="block">/*** Utility functions for resource management ***/</comment>

<function><type><name>dav_resource</name> *</type>
<name>dav_svn__create_working_resource</name><parameter_list>(<param><decl><type><name>dav_resource</name> *</type><name>base</name></decl></param>,
                                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>activity_id</name></decl></param>,
                                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_name</name></decl></param>,
                                 <param><decl><type><name>int</name></type> <name>tweak_in_place</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dav_resource</name> *</type><name>res</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><name><name>base</name>-&gt;<name>baselined</name></name></expr>)</condition><then>
    <expr_stmt><expr><name>path</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>base</name>-&gt;<name>pool</name></name></expr></argument>,
                        <argument><expr>"/%s/wbl/%s/%ld"</expr></argument>,
                        <argument><expr><name><name>base</name>-&gt;<name>info</name>-&gt;<name>repos</name>-&gt;<name>special_uri</name></name></expr></argument>,
                        <argument><expr><name>activity_id</name></expr></argument>, <argument><expr><name><name>base</name>-&gt;<name>info</name>-&gt;<name>root</name>.<name>rev</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name>path</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>base</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>"/%s/wrk/%s%s"</expr></argument>,
                        <argument><expr><name><name>base</name>-&gt;<name>info</name>-&gt;<name>repos</name>-&gt;<name>special_uri</name></name></expr></argument>,
                        <argument><expr><name>activity_id</name></expr></argument>, <argument><expr><name><name>base</name>-&gt;<name>info</name>-&gt;<name>repos_path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
  <expr_stmt><expr><name>path</name> = <call><name>svn_path_uri_encode</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>base</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>tweak_in_place</name></expr>)</condition><then>
    <expr_stmt><expr><name>res</name> = <name>base</name></expr>;</expr_stmt></then>
  <else>else
    <block>{
      <expr_stmt><expr><name>res</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name><name>base</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>res</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>res</name>-&gt;<name>info</name></name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name><name>base</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name><name>res</name>-&gt;<name>info</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

  <expr_stmt><expr><name><name>res</name>-&gt;<name>type</name></name> = <name>DAV_RESOURCE_TYPE_WORKING</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>res</name>-&gt;<name>exists</name></name> = <name>TRUE</name></expr>;</expr_stmt>      <comment type="block">/* ### not necessarily correct */</comment>
  <expr_stmt><expr><name><name>res</name>-&gt;<name>versioned</name></name> = <name>TRUE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>res</name>-&gt;<name>working</name></name> = <name>TRUE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>res</name>-&gt;<name>baselined</name></name> = <name><name>base</name>-&gt;<name>baselined</name></name></expr>;</expr_stmt>
  <comment type="block">/* collection = FALSE.   ### not necessarily correct */</comment>

  <expr_stmt><expr><name><name>res</name>-&gt;<name>uri</name></name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name><name>base</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>base</name>-&gt;<name>info</name>-&gt;<name>repos</name>-&gt;<name>root_path</name></name></expr></argument>,
                         <argument><expr><name>path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>res</name>-&gt;<name>hooks</name></name> = &amp;<name>dav_svn__hooks_repository</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>res</name>-&gt;<name>pool</name></name> = <name><name>base</name>-&gt;<name>pool</name></name></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>res</name>-&gt;<name>info</name>-&gt;<name>uri_path</name></name> = <call><name>svn_stringbuf_create</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>base</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>res</name>-&gt;<name>info</name>-&gt;<name>repos</name></name> = <name><name>base</name>-&gt;<name>info</name>-&gt;<name>repos</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>res</name>-&gt;<name>info</name>-&gt;<name>repos_path</name></name> = <name><name>base</name>-&gt;<name>info</name>-&gt;<name>repos_path</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>res</name>-&gt;<name>info</name>-&gt;<name>root</name>.<name>rev</name></name> = <name><name>base</name>-&gt;<name>info</name>-&gt;<name>root</name>.<name>rev</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>res</name>-&gt;<name>info</name>-&gt;<name>root</name>.<name>activity_id</name></name> = <name>activity_id</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>res</name>-&gt;<name>info</name>-&gt;<name>root</name>.<name>txn_name</name></name> = <name>txn_name</name></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>tweak_in_place</name></expr>)</condition><then>
    <return>return <expr><name>NULL</name></expr>;</return></then>
  <else>else
    <return>return <expr><name>res</name></expr>;</return></else></if>
}</block></function>


<function><type><name>dav_error</name> *</type>
<name>dav_svn__working_to_regular_resource</name><parameter_list>(<param><decl><type><name>dav_resource</name> *</type><name>resource</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>dav_resource_private</name> *</type><name>priv</name> <init>= <expr><name><name>resource</name>-&gt;<name>info</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dav_svn_repos</name> *</type><name>repos</name> <init>= <expr><name><name>priv</name>-&gt;<name>repos</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>serr</name></decl>;</decl_stmt>

  <comment type="block">/* no need to change the repos object or repos_path */</comment>

  <comment type="block">/* set type back to REGULAR */</comment>
  <expr_stmt><expr><name><name>resource</name>-&gt;<name>type</name></name> = <name>DAV_RESOURCE_TYPE_REGULAR</name></expr>;</expr_stmt>

  <comment type="block">/* remove the working flag */</comment>
  <expr_stmt><expr><name><name>resource</name>-&gt;<name>working</name></name> = <name>FALSE</name></expr>;</expr_stmt>

  <comment type="block">/* Change the URL into either a baseline-collection or a public one. */</comment>
  <if>if <condition>(<expr><name><name>priv</name>-&gt;<name>root</name>.<name>rev</name></name> == <name>SVN_INVALID_REVNUM</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>serr</name> = <call><name>svn_fs_youngest_rev</name><argument_list>(<argument><expr>&amp;<name><name>priv</name>-&gt;<name>root</name>.<name>rev</name></name></expr></argument>, <argument><expr><name><name>repos</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>serr</name> != <name>NULL</name></expr>)</condition><then>
        <return>return <expr><call><name>dav_svn__convert_err</name><argument_list>(<argument><expr><name>serr</name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>,
                                    <argument><expr>"Could not determine youngest rev."</expr></argument>,
                                    <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>

      <comment type="block">/* create public URL */</comment>
      <expr_stmt><expr><name>path</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>"%s"</expr></argument>, <argument><expr><name><name>priv</name>-&gt;<name>repos_path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <comment type="block">/* if rev was specific, create baseline-collection URL */</comment>
      <expr_stmt><expr><name>path</name> = <call><name>dav_svn__build_uri</name><argument_list>(<argument><expr><name>repos</name></expr></argument>, <argument><expr><name>DAV_SVN__BUILD_URI_BC</name></expr></argument>,
                                <argument><expr><name><name>priv</name>-&gt;<name>root</name>.<name>rev</name></name></expr></argument>, <argument><expr><name><name>priv</name>-&gt;<name>repos_path</name></name></expr></argument>,
                                <argument><expr>0</expr></argument>, <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
  <expr_stmt><expr><name>path</name> = <call><name>svn_path_uri_encode</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>priv</name>-&gt;<name>uri_path</name></name> = <call><name>svn_stringbuf_create</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* change root.root back into a revision root. */</comment>
  <expr_stmt><expr><name>serr</name> = <call><name>svn_fs_revision_root</name><argument_list>(<argument><expr>&amp;<name><name>priv</name>-&gt;<name>root</name>.<name>root</name></name></expr></argument>, <argument><expr><name><name>repos</name>-&gt;<name>fs</name></name></expr></argument>,
                              <argument><expr><name><name>priv</name>-&gt;<name>root</name>.<name>rev</name></name></expr></argument>, <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>serr</name> != <name>NULL</name></expr>)</condition><then>
    <return>return <expr><call><name>dav_svn__convert_err</name><argument_list>(<argument><expr><name>serr</name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>,
                                <argument><expr>"Could not open revision root."</expr></argument>,
                                <argument><expr><name><name>resource</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>


<function><type><name>dav_error</name> *</type>
<name>dav_svn__create_version_resource</name><parameter_list>(<param><decl><type><name>dav_resource</name> **</type><name>version_res</name></decl></param>,
                                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>uri</name></decl></param>,
                                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>result</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dav_error</name> *</type><name>err</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>dav_resource_combined</name> *</type><name>comb</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>comb</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>result</name> = <call><name>parse_version_uri</name><argument_list>(<argument><expr><name>comb</name></expr></argument>, <argument><expr><name>uri</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>result</name> != 0</expr>)</condition><then>
    <return>return <expr><call><name>dav_new_error</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>HTTP_INTERNAL_SERVER_ERROR</name></expr></argument>, <argument><expr>0</expr></argument>,
                         <argument><expr>"Could not parse version resource uri."</expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><name>err</name> = <call><name>prep_version</name><argument_list>(<argument><expr><name>comb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
    <return>return <expr><name>err</name></expr>;</return></then></if>

  <expr_stmt><expr>*<name>version_res</name> = &amp;<name><name>comb</name>-&gt;<name>res</name></name></expr>;</expr_stmt>
  <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>


<decl_stmt><decl><type><specifier>const</specifier> <name>dav_hooks_repository</name></type> <name>dav_svn__hooks_repository</name> <init>=
<expr><block>{
  <expr>1</expr>,                            <comment type="block">/* special GET handling */</comment>
  <expr><name>get_resource</name></expr>,
  <expr><name>get_parent_resource</name></expr>,
  <expr><name>is_same_resource</name></expr>,
  <expr><name>is_parent_resource</name></expr>,
  <expr><name>open_stream</name></expr>,
  <expr><name>close_stream</name></expr>,
  <expr><name>write_stream</name></expr>,
  <expr><name>seek_stream</name></expr>,
  <expr><name>set_headers</name></expr>,
  <expr><name>deliver</name></expr>,
  <expr><name>create_collection</name></expr>,
  <expr><name>copy_resource</name></expr>,
  <expr><name>move_resource</name></expr>,
  <expr><name>remove_resource</name></expr>,
  <expr><name>walk</name></expr>,
  <expr><name>getetag_pathetic</name></expr>
}</block></expr></init></decl>;</decl_stmt>
</unit>
