<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/subversion-1.5.1/source/subversion/mod_dav_svn/dav_svn.h"><comment type="block">/*
 * dav_svn.h: types, functions, macros for the DAV/SVN Apache module
 *
 * ====================================================================
 * Copyright (c) 2000-2007 CollabNet.  All rights reserved.
 *
 * This software is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at http://subversion.tigris.org/license-1.html.
 * If newer versions of this license are posted there, you may use a
 * newer version instead, at your option.
 *
 * This software consists of voluntary contributions made by many
 * individuals.  For exact contribution history, see the revision
 * history and logs, available at http://subversion.tigris.org/.
 * ====================================================================
 */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>DAV_SVN_H</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_SVN_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_tables.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_xml.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;httpd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;http_log.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;mod_dav.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_error.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_fs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_repos.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_path.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_xml.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"private/svn_dav_protocol.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mod_authz_svn.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
<extern>extern "C" <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* __cplusplus */</comment>

<escape char="0xc"/>
<comment type="block">/* what the one VCC is called */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_SVN__DEFAULT_VCC_NAME</name></cpp:macro>        <cpp:value>"default"</cpp:value></cpp:define>

<comment type="block">/* a pool-key for the shared dav_svn_root used by autoversioning  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DAV_SVN__AUTOVERSIONING_ACTIVITY</name></cpp:macro> <cpp:value>"svn-autoversioning-activity"</cpp:value></cpp:define>


<comment type="block">/* dav_svn_repos
 *
 * Record information about the repository that a resource belongs to.
 * This structure will be shared between multiple resources so that we
 * can optimized our FS access.
 *
 * Note that we do not refcount this structure. Presumably, we will need
 * it throughout the life of the request. Therefore, we can just leave it
 * for the request pool to cleanup/close.
 *
 * Also, note that it is possible that two resources may have distinct
 * dav_svn_repos structures, yet refer to the same repository. This is
 * allowed by the SVN FS interface.
 *
 * ### should we attempt to merge them when we detect this situation in
 * ### places like is_same_resource, is_parent_resource, or copy/move?
 * ### I say yes: the FS will certainly have an easier time if there is
 * ### only a single FS open; otherwise, it will have to work a bit harder
 * ### to keep the things in sync.
 */</comment>
<typedef>typedef <type><struct>struct <block>{
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>     <comment type="block">/* request_rec -&gt; pool */</comment>

  <comment type="block">/* Remember the root URL path of this repository (just a path; no
     scheme, host, or port).

     Example: the URI is "http://host/repos/file", this will be "/repos".

     This always starts with "/", and if there are any components
     beyond that, then it does not end with "/".
  */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>root_path</name></decl>;</decl_stmt>

  <comment type="block">/* Remember an absolute URL for constructing other URLs. In the above
     example, this would be "http://host" (note: no trailing slash)
  */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>base_url</name></decl>;</decl_stmt>

  <comment type="block">/* Remember the special URI component for this repository */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>special_uri</name></decl>;</decl_stmt>

  <comment type="block">/* This records the filesystem path to the SVN FS */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fs_path</name></decl>;</decl_stmt>

  <comment type="block">/* The name of this repository */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>repo_name</name></decl>;</decl_stmt>

  <comment type="block">/* The repository filesystem basename */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>repo_basename</name></decl>;</decl_stmt>

  <comment type="block">/* The URI of the XSL transform for directory indexes */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>xslt_uri</name></decl>;</decl_stmt>

  <comment type="block">/* Whether autoversioning is active for this repository. */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>autoversioning</name></decl>;</decl_stmt>

  <comment type="block">/* Whether bulk updates are allowed for this repository. */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>bulk_updates</name></decl>;</decl_stmt>

  <comment type="block">/* the open repository */</comment>
  <decl_stmt><decl><type><name>svn_repos_t</name> *</type><name>repos</name></decl>;</decl_stmt>

  <comment type="block">/* a cached copy of REPOS-&gt;fs above. */</comment>
  <decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl>;</decl_stmt>

  <comment type="block">/* the user operating against this repository */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>username</name></decl>;</decl_stmt>

  <comment type="block">/* is the client a Subversion client? */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>is_svn_client</name></decl>;</decl_stmt>

  <comment type="block">/* The client's capabilities.  Maps SVN_RA_CAPABILITY_* keys to
     "yes" or "no" values.  If a capability is not yet discovered, it
     is absent from the table.  The table itself is allocated in this
     structure's 'pool' field, and the keys and values must have at
     least that lifetime.  Most likely the keys and values are
     constants anyway (and sufficiently well-informed internal code
     may therefore compare against those constants' addresses).  If
     'is_svn_client' is false, then 'capabilities' should be empty. */</comment>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>capabilities</name></decl>;</decl_stmt>

  <comment type="block">/* The path to the activities db */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>activities_db</name></decl>;</decl_stmt>

}</block></struct></type> <name>dav_svn_repos</name>;</typedef>


<comment type="block">/*
** dav_svn_private_restype: identifiers for our different private resources
**
** There are some resources within mod_dav_svn that are "privately defined".
** This isn't so much to prevent other people from knowing what they are,
** but merely that mod_dav doesn't have a standard name for them.
*/</comment>
<enum>enum <name>dav_svn_private_restype</name> <block>{
  <decl><name>DAV_SVN_RESTYPE_UNSET</name></decl>,

  <decl><name>DAV_SVN_RESTYPE_ROOT_COLLECTION</name></decl>,      <comment type="block">/* .../!svn/     */</comment>
  <decl><name>DAV_SVN_RESTYPE_VER_COLLECTION</name></decl>,       <comment type="block">/* .../!svn/ver/ */</comment>
  <decl><name>DAV_SVN_RESTYPE_HIS_COLLECTION</name></decl>,       <comment type="block">/* .../!svn/his/ */</comment>
  <decl><name>DAV_SVN_RESTYPE_WRK_COLLECTION</name></decl>,       <comment type="block">/* .../!svn/wrk/ */</comment>
  <decl><name>DAV_SVN_RESTYPE_ACT_COLLECTION</name></decl>,       <comment type="block">/* .../!svn/act/ */</comment>
  <decl><name>DAV_SVN_RESTYPE_VCC_COLLECTION</name></decl>,       <comment type="block">/* .../!svn/vcc/ */</comment>
  <decl><name>DAV_SVN_RESTYPE_BC_COLLECTION</name></decl>,        <comment type="block">/* .../!svn/bc/  */</comment>
  <decl><name>DAV_SVN_RESTYPE_BLN_COLLECTION</name></decl>,       <comment type="block">/* .../!svn/bln/ */</comment>
  <decl><name>DAV_SVN_RESTYPE_WBL_COLLECTION</name></decl>,       <comment type="block">/* .../!svn/wbl/ */</comment>
  <decl><name>DAV_SVN_RESTYPE_VCC</name></decl>,                  <comment type="block">/* .../!svn/vcc/NAME */</comment>
  <decl><name>DAV_SVN_RESTYPE_PARENTPATH_COLLECTION</name></decl> <comment type="block">/* see SVNParentPath directive */</comment>
}</block>;</enum>


<comment type="block">/* store info about a root in a repository */</comment>
<typedef>typedef <type><struct>struct <block>{
  <comment type="block">/* If a root within the FS has been opened, the value is stored here.
     Otherwise, this field is NULL. */</comment>
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl>;</decl_stmt>

  <comment type="block">/* If the root has been opened, and it was opened for a specific revision,
     then it is contained in REV. If the root is unopened or corresponds to
     a transaction, then REV will be SVN_INVALID_REVNUM. */</comment>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl>;</decl_stmt>

  <comment type="block">/* If this resource is an activity or part of an activity, this specifies
     the ID of that activity. It may not (yet) correspond to a transaction
     in the FS.

     WORKING and ACTIVITY resources use this field.
  */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>activity_id</name></decl>;</decl_stmt>

  <comment type="block">/* If the root is part of a transaction, this contains the FS's tranaction
     name. It may be NULL if this root corresponds to a specific revision.
     It may also be NULL if we have not opened the root yet.

     WORKING and ACTIVITY resources use this field.
  */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_name</name></decl>;</decl_stmt>

  <comment type="block">/* If the root is part of a transaction, this contains the FS's transaction
     handle. It may be NULL if this root corresponds to a specific revision.
     It may also be NULL if we have not opened the transaction yet.

     WORKING resources use this field.
  */</comment>
  <decl_stmt><decl><type><name>svn_fs_txn_t</name> *</type><name>txn</name></decl>;</decl_stmt>

}</block></struct></type> <name>dav_svn_root</name>;</typedef>


<comment type="block">/* internal structure to hold information about this resource */</comment>
<struct>struct <name>dav_resource_private</name> <block>{
  <comment type="block">/* Path from the SVN repository root to this resource. This value has
     a leading slash. It will never have a trailing slash, even if the
     resource represents a collection.

     For example: URI is http://host/repos/file -- path will be "/file".

     NOTE: this path is from the URI and does NOT necessarily correspond
           to a path within the FS repository.
  */</comment>
  <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>uri_path</name></decl>;</decl_stmt>

  <comment type="block">/* The FS repository path to this resource, with a leading "/". Note
     that this is "/" the root. This value will be NULL for resources
     that have no corresponding resource within the repository (such as
     the PRIVATE resources, Baselines, or Working Baselines). */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>repos_path</name></decl>;</decl_stmt>

  <comment type="block">/* the FS repository this resource is associated with */</comment>
  <decl_stmt><decl><type><name>dav_svn_repos</name> *</type><name>repos</name></decl>;</decl_stmt>

  <comment type="block">/* what FS root this resource occurs within */</comment>
  <decl_stmt><decl><type><name>dav_svn_root</name></type> <name>root</name></decl>;</decl_stmt>

  <comment type="block">/* for PRIVATE resources: the private resource type */</comment>
  <enum>enum <name>dav_svn_private_restype</name> <name>restype</name>;</enum>

  <comment type="block">/* The request which created this resource.  We need this to
     generate subrequests. */</comment>
  <decl_stmt><decl><type><name>request_rec</name> *</type><name>r</name></decl>;</decl_stmt>

  <comment type="block">/* ### hack to deal with the Content-Type header on a PUT */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>is_svndiff</name></decl>;</decl_stmt>

  <comment type="block">/* ### record the base for computing a delta during a GET */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>delta_base</name></decl>;</decl_stmt>

  <comment type="block">/* SVNDIFF version we can transmit to the client.  */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>svndiff_version</name></decl>;</decl_stmt>

  <comment type="block">/* the value of any SVN_DAV_OPTIONS_HEADER that came in the request */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>svn_client_options</name></decl>;</decl_stmt>

  <comment type="block">/* the revnum value from a possible SVN_DAV_VERSION_NAME_HEADER */</comment>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>version_name</name></decl>;</decl_stmt>

  <comment type="block">/* Hex MD5 digests for base text and resultant fulltext.
     Either or both of these may be null, in which case ignored. */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>base_checksum</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>result_checksum</name></decl>;</decl_stmt>

  <comment type="block">/* was this resource auto-checked-out? */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>auto_checked_out</name></decl>;</decl_stmt>

  <comment type="block">/* Pool to allocate temporary data from */</comment>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>
}</block>;</struct>


<comment type="block">/* Every provider needs to define an opaque locktoken type. */</comment>
<struct>struct <name>dav_locktoken</name>
<block>{
  <comment type="block">/* This is identical to the 'token' field of an svn_lock_t. */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>uuid_str</name></decl>;</decl_stmt>
}</block>;</struct>


<comment type="block">/* for the repository referred to by this request, where is the SVN FS? */</comment>
<function_decl><type><specifier>const</specifier> <name>char</name> *</type><name>dav_svn__get_fs_path</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><specifier>const</specifier> <name>char</name> *</type><name>dav_svn__get_fs_parent_path</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/* for the repository referred to by this request, is autoversioning active? */</comment>
<function_decl><type><name>svn_boolean_t</name></type> <name>dav_svn__get_autoversioning_flag</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/* for the repository referred to by this request, are bulk updates allowed? */</comment>
<function_decl><type><name>svn_boolean_t</name></type> <name>dav_svn__get_bulk_updates_flag</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/* for the repository referred to by this request, are subrequests active? */</comment>
<function_decl><type><name>svn_boolean_t</name></type> <name>dav_svn__get_pathauthz_flag</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/* for the repository referred to by this request, are subrequests bypassed?
 * A function pointer if yes, NULL if not.
 */</comment>
<function_decl><type><name>authz_svn__subreq_bypass_func_t</name></type> <name>dav_svn__get_pathauthz_bypass</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/* for the repository referred to by this request, is a GET of
   SVNParentPath allowed? */</comment>
<function_decl><type><name>svn_boolean_t</name></type> <name>dav_svn__get_list_parentpath_flag</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>;</function_decl>


<comment type="block">/* SPECIAL URI

   SVN needs to create many types of "pseudo resources" -- resources
   that don't correspond to the users' files/directories in the
   repository. Specifically, these are:

   - working resources
   - activities
   - version resources
   - version history resources

   Each of these will be placed under a portion of the URL namespace
   that defines the SVN repository. For example, let's say the user
   has configured an SVN repository at http://host/svn/repos. The
   special resources could be configured to live at .../!svn/ under
   that repository. Thus, an activity might be located at
   http://host/svn/repos/!svn/act/1234.

   The special URI is configurable on a per-server basis and defaults
   to "!svn".

   NOTE: the special URI is RELATIVE to the "root" of the
   repository. The root is generally available only to
   dav_svn_get_resource(). This is okay, however, because we can cache
   the root_dir when the resource structure is built.
*/</comment>

<comment type="block">/* Return the special URI to be used for this resource. */</comment>
<function_decl><type><specifier>const</specifier> <name>char</name> *</type><name>dav_svn__get_special_uri</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/* Return a descriptive name for the repository */</comment>
<function_decl><type><specifier>const</specifier> <name>char</name> *</type><name>dav_svn__get_repo_name</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/* Return the URI of an XSL transform stylesheet */</comment>
<function_decl><type><specifier>const</specifier> <name>char</name> *</type><name>dav_svn__get_xslt_uri</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/* Return the master URI (for mirroring) */</comment>
<function_decl><type><specifier>const</specifier> <name>char</name> *</type> <name>dav_svn__get_master_uri</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/* Return the activities db */</comment>
<function_decl><type><specifier>const</specifier> <name>char</name> *</type> <name>dav_svn__get_activities_db</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/* Return the root directory */</comment>
<function_decl><type><specifier>const</specifier> <name>char</name> *</type> <name>dav_svn__get_root_dir</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/*** activity.c ***/</comment>

<comment type="block">/* activity functions for looking up, storing, and deleting
   ACTIVITY-&gt;TXN mappings */</comment>
<function_decl><type><specifier>const</specifier> <name>char</name> *</type>
<name>dav_svn__get_txn</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>dav_svn_repos</name> *</type><name>repos</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>activity_id</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><name>dav_error</name> *</type>
<name>dav_svn__delete_activity</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>dav_svn_repos</name> *</type><name>repos</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>activity_id</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><name>dav_error</name> *</type>
<name>dav_svn__store_activity</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>dav_svn_repos</name> *</type><name>repos</name></decl></param>,
                        <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>activity_id</name></decl></param>,
                        <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_name</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><name>dav_error</name> *</type>
<name>dav_svn__create_activity</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>dav_svn_repos</name> *</type><name>repos</name></decl></param>,
                         <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>ptxn_name</name></decl></param>,
                         <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>


<comment type="block">/*** repos.c ***/</comment>

<comment type="block">/* generate an ETag for RESOURCE and return it, allocated in POOL. */</comment>
<function_decl><type><specifier>const</specifier> <name>char</name> *</type>
<name>dav_svn__getetag</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/*
  Construct a working resource for a given resource.

  The internal information (repository, URL parts, etc) for the new
  resource comes from BASE, the activity to use is specified by
  ACTIVITY_ID, and the name of the transaction is specified by
  TXN_NAME. These will be assembled into a new dav_resource and
  returned.

  If TWEAK_IN_PLACE is non-zero, then directly tweak BASE into a
  working resource and return NULL.
*/</comment>
<function_decl><type><name>dav_resource</name> *</type>
<name>dav_svn__create_working_resource</name><parameter_list>(<param><decl><type><name>dav_resource</name> *</type><name>base</name></decl></param>,
                                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>activity_id</name></decl></param>,
                                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_name</name></decl></param>,
                                 <param><decl><type><name>int</name></type> <name>tweak_in_place</name></decl></param>)</parameter_list>;</function_decl>
<comment type="block">/*
   Convert a working RESOURCE back into a regular one, in-place.

   In particular: change the resource type to regular, removing the
   'working' flag, change the fs root from a txn-root to a rev-root,
   and set the URL back into either a public URL or bc URL.
*/</comment>
<function_decl><type><name>dav_error</name> *</type>
<name>dav_svn__working_to_regular_resource</name><parameter_list>(<param><decl><type><name>dav_resource</name> *</type><name>resource</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/*
   Given a version-resource URI, construct a new version-resource in
   POOL and return it in  *VERSION_RES.
*/</comment>
<function_decl><type><name>dav_error</name> *</type>
<name>dav_svn__create_version_resource</name><parameter_list>(<param><decl><type><name>dav_resource</name> **</type><name>version_res</name></decl></param>,
                                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>uri</name></decl></param>,
                                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name>dav_hooks_repository</name></type> <name>dav_svn__hooks_repository</name></decl>;</decl_stmt>


<comment type="block">/*** deadprops.c ***/</comment>
<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name>dav_hooks_propdb</name></type> <name>dav_svn__hooks_propdb</name></decl>;</decl_stmt>


<comment type="block">/*** lock.c ***/</comment>
<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name>dav_hooks_locks</name></type> <name>dav_svn__hooks_locks</name></decl>;</decl_stmt>


<comment type="block">/*** version.c ***/</comment>

<comment type="block">/* For an autoversioning commit, a helper function which attaches an
   auto-generated 'svn:log' property to a txn, as well as a property
   that indicates the revision was made via autoversioning. */</comment>
<function_decl><type><name>svn_error_t</name> *</type>
<name>dav_svn__attach_auto_revprops</name><parameter_list>(<param><decl><type><name>svn_fs_txn_t</name> *</type><name>txn</name></decl></param>,
                              <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fs_path</name></decl></param>,
                              <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>


<comment type="block">/* Hook function of types 'checkout' and 'checkin', as defined in
   mod_dav.h's versioning provider hooks table (see dav_hooks_vsn).  */</comment>
<function_decl><type><name>dav_error</name> *</type>
<name>dav_svn__checkout</name><parameter_list>(<param><decl><type><name>dav_resource</name> *</type><name>resource</name></decl></param>,
                  <param><decl><type><name>int</name></type> <name>auto_checkout</name></decl></param>,
                  <param><decl><type><name>int</name></type> <name>is_unreserved</name></decl></param>,
                  <param><decl><type><name>int</name></type> <name>is_fork_ok</name></decl></param>,
                  <param><decl><type><name>int</name></type> <name>create_activity</name></decl></param>,
                  <param><decl><type><name>apr_array_header_t</name> *</type><name>activities</name></decl></param>,
                  <param><decl><type><name>dav_resource</name> **</type><name>working_resource</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><name>dav_error</name> *</type>
<name>dav_svn__checkin</name><parameter_list>(<param><decl><type><name>dav_resource</name> *</type><name>resource</name></decl></param>,
                 <param><decl><type><name>int</name></type> <name>keep_checked_out</name></decl></param>,
                 <param><decl><type><name>dav_resource</name> **</type><name>version_resource</name></decl></param>)</parameter_list>;</function_decl>


<comment type="block">/* Helper for reading lock-tokens out of request bodies, by looking
   for cached body in R-&gt;pool's userdata.

   Return a hash that maps (const char *) absolute fs paths to (const
   char *) locktokens.  Allocate the hash and all keys/vals in POOL.
   PATH_PREFIX is the prefix we need to prepend to each relative
   'lock-path' in the xml in order to create an absolute fs-path.  */</comment>
<function_decl><type><name>dav_error</name> *</type>
<name>dav_svn__build_lock_hash</name><parameter_list>(<param><decl><type><name>apr_hash_t</name> **</type><name>locks</name></decl></param>,
                         <param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>,
                         <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path_prefix</name></decl></param>,
                         <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>


<comment type="block">/* Helper: push all of the lock-tokens (hash values) in LOCKS into
   RESOURCE's already-open svn_fs_t. */</comment>
<function_decl><type><name>dav_error</name> *</type>
<name>dav_svn__push_locks</name><parameter_list>(<param><decl><type><name>dav_resource</name> *</type><name>resource</name></decl></param>,
                    <param><decl><type><name>apr_hash_t</name> *</type><name>locks</name></decl></param>,
                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>


<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name>dav_hooks_vsn</name></type> <name>dav_svn__hooks_vsn</name></decl>;</decl_stmt>


<comment type="block">/*** liveprops.c ***/</comment>

<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name>dav_liveprop_group</name></type> <name>dav_svn__liveprop_group</name></decl>;</decl_stmt>

<comment type="block">/*
  LIVE PROPERTY HOOKS

  These are standard hooks defined by mod_dav. We implement them to expose
  various live properties on the resources under our control.

  gather_propsets: appends URIs into the array; the property set URIs are
                   used to specify which sets of custom properties we
                   define/expose.
  find_liveprop: given a namespace and name, return the hooks for the
                 provider who defines that property.
  insert_all_liveprops: for a given resource, insert all of the live
                        properties defined on that resource. The properties
                        are inserted according to the WHAT parameter.
*/</comment>
<function_decl><type><name>void</name></type> <name>dav_svn__gather_propsets</name><parameter_list>(<param><decl><type><name>apr_array_header_t</name> *</type><name>uris</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><name>int</name></type>
<name>dav_svn__find_liveprop</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl></param>,
                       <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ns_uri</name></decl></param>,
                       <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>,
                       <param><decl><type><specifier>const</specifier> <name>dav_hooks_liveprop</name> **</type><name>hooks</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><name>void</name></type>
<name>dav_svn__insert_all_liveprops</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>,
                              <param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl></param>,
                              <param><decl><type><name>dav_prop_insert</name></type> <name>what</name></decl></param>,
                              <param><decl><type><name>apr_text_header</name> *</type><name>phdr</name></decl></param>)</parameter_list>;</function_decl>


<comment type="block">/*** merge.c ***/</comment>

<comment type="block">/* Generate the HTTP response body for a successful MERGE. */</comment>
<comment type="block">/* ### more docco */</comment>
<function_decl><type><name>dav_error</name> *</type>
<name>dav_svn__merge_response</name><parameter_list>(<param><decl><type><name>ap_filter_t</name> *</type><name>output</name></decl></param>,
                        <param><decl><type><specifier>const</specifier> <name>dav_svn_repos</name> *</type><name>repos</name></decl></param>,
                        <param><decl><type><name>svn_revnum_t</name></type> <name>new_rev</name></decl></param>,
                        <param><decl><type><name>char</name> *</type><name>post_commit_err</name></decl></param>,
                        <param><decl><type><name>apr_xml_elem</name> *</type><name>prop_elem</name></decl></param>,
                        <param><decl><type><name>svn_boolean_t</name></type> <name>disable_merge_response</name></decl></param>,
                        <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>


<comment type="block">/*** reports/ ***/</comment>

<comment type="block">/* The list of Subversion's custom REPORTs. */</comment>
<comment type="block">/* ### should move these report names to a public header to share with
   ### the client (and third parties). */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>dav_report_elem</name></type> <name><name>dav_svn__reports_list</name><index>[]</index></name> <init>= <expr><block>{
  <expr><block>{ <expr><name>SVN_XML_NAMESPACE</name></expr>, <expr>"update-report"</expr> }</block></expr>,
  <expr><block>{ <expr><name>SVN_XML_NAMESPACE</name></expr>, <expr>"log-report"</expr> }</block></expr>,
  <expr><block>{ <expr><name>SVN_XML_NAMESPACE</name></expr>, <expr>"dated-rev-report"</expr> }</block></expr>,
  <expr><block>{ <expr><name>SVN_XML_NAMESPACE</name></expr>, <expr>"get-locations"</expr> }</block></expr>,
  <expr><block>{ <expr><name>SVN_XML_NAMESPACE</name></expr>, <expr>"get-location-segments"</expr> }</block></expr>,
  <expr><block>{ <expr><name>SVN_XML_NAMESPACE</name></expr>, <expr>"file-revs-report"</expr> }</block></expr>,
  <expr><block>{ <expr><name>SVN_XML_NAMESPACE</name></expr>, <expr>"get-locks-report"</expr> }</block></expr>,
  <expr><block>{ <expr><name>SVN_XML_NAMESPACE</name></expr>, <expr>"replay-report"</expr> }</block></expr>,
  <expr><block>{ <expr><name>SVN_XML_NAMESPACE</name></expr>, <expr><name>SVN_DAV__MERGEINFO_REPORT</name></expr> }</block></expr>,
  <expr><block>{ <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr> }</block></expr>,
}</block></expr></init></decl>;</decl_stmt>


<comment type="block">/* The various report handlers, defined in reports/, and used by version.c.  */</comment>
<function_decl><type><name>dav_error</name> *</type>
<name>dav_svn__update_report</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl></param>,
                       <param><decl><type><specifier>const</specifier> <name>apr_xml_doc</name> *</type><name>doc</name></decl></param>,
                       <param><decl><type><name>ap_filter_t</name> *</type><name>output</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>dav_error</name> *</type>
<name>dav_svn__log_report</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>apr_xml_doc</name> *</type><name>doc</name></decl></param>,
                    <param><decl><type><name>ap_filter_t</name> *</type><name>output</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>dav_error</name> *</type>
<name>dav_svn__dated_rev_report</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>apr_xml_doc</name> *</type><name>doc</name></decl></param>,
                          <param><decl><type><name>ap_filter_t</name> *</type><name>output</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>dav_error</name> *</type>
<name>dav_svn__get_locations_report</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl></param>,
                              <param><decl><type><specifier>const</specifier> <name>apr_xml_doc</name> *</type><name>doc</name></decl></param>,
                              <param><decl><type><name>ap_filter_t</name> *</type><name>output</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>dav_error</name> *</type>
<name>dav_svn__get_location_segments_report</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl></param>,
                                      <param><decl><type><specifier>const</specifier> <name>apr_xml_doc</name> *</type><name>doc</name></decl></param>,
                                      <param><decl><type><name>ap_filter_t</name> *</type><name>output</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>dav_error</name> *</type>
<name>dav_svn__file_revs_report</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>apr_xml_doc</name> *</type><name>doc</name></decl></param>,
                          <param><decl><type><name>ap_filter_t</name> *</type><name>output</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>dav_error</name> *</type>
<name>dav_svn__replay_report</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl></param>,
                       <param><decl><type><specifier>const</specifier> <name>apr_xml_doc</name> *</type><name>doc</name></decl></param>,
                       <param><decl><type><name>ap_filter_t</name> *</type><name>output</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>dav_error</name> *</type>
<name>dav_svn__get_mergeinfo_report</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl></param>,
                              <param><decl><type><specifier>const</specifier> <name>apr_xml_doc</name> *</type><name>doc</name></decl></param>,
                              <param><decl><type><name>ap_filter_t</name> *</type><name>output</name></decl></param>)</parameter_list>;</function_decl>
<function_decl><type><name>dav_error</name> *</type>
<name>dav_svn__get_locks_report</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>apr_xml_doc</name> *</type><name>doc</name></decl></param>,
                          <param><decl><type><name>ap_filter_t</name> *</type><name>output</name></decl></param>)</parameter_list>;</function_decl>


<comment type="block">/*** authz.c ***/</comment>

<comment type="block">/* A baton needed by dav_svn__authz_read_func(). */</comment>
<typedef>typedef <type><struct>struct
<block>{
  <comment type="block">/* The original request, needed to generate a subrequest. */</comment>
  <decl_stmt><decl><type><name>request_rec</name> *</type><name>r</name></decl>;</decl_stmt>

  <comment type="block">/* We need this to construct a URI based on a repository abs path. */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>dav_svn_repos</name> *</type><name>repos</name></decl>;</decl_stmt>

}</block></struct></type> <name>dav_svn__authz_read_baton</name>;</typedef>


<comment type="block">/* Convert incoming RESOURCE and revision REV into a version-resource URI and
   perform a GET subrequest on it.  This will invoke any authz modules loaded
   into apache. Return TRUE if the subrequest succeeds, FALSE otherwise.

   If REV is SVN_INVALID_REVNUM, then we look at HEAD.
   Use POOL for any temporary allocation.
*/</comment>
<function_decl><type><name>svn_boolean_t</name></type>
<name>dav_svn__allow_read</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>resource</name></decl></param>,
                   <param><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl></param>,
                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/* If authz is enabled in the specified BATON, return a read authorization
   function. Otherwise, return NULL. */</comment>
<function_decl><type><name>svn_repos_authz_func_t</name></type>
<name>dav_svn__authz_read_func</name><parameter_list>(<param><decl><type><name>dav_svn__authz_read_baton</name> *</type><name>baton</name></decl></param>)</parameter_list>;</function_decl>


<comment type="block">/*** util.c ***/</comment>

<comment type="block">/* A wrapper around mod_dav's dav_new_error_tag, mod_dav_svn uses this
   instead of the mod_dav function to enable special mod_dav_svn specific
   processing.  See dav_new_error_tag for parameter documentation.
   Note that DESC may be null (it's hard to track this down from
   dav_new_error_tag()'s documentation, but see the dav_error type,
   which says that its desc field may be NULL). */</comment>
<function_decl><type><name>dav_error</name> *</type>
<name>dav_svn__new_error_tag</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                       <param><decl><type><name>int</name></type> <name>status</name></decl></param>,
                       <param><decl><type><name>int</name></type> <name>errno_id</name></decl></param>,
                       <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>desc</name></decl></param>,
                       <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>namespace</name></decl></param>,
                       <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>tagname</name></decl></param>)</parameter_list>;</function_decl>


<comment type="block">/* Convert an svn_error_t into a dav_error, pushing another error based on
   MESSAGE if MESSAGE is not NULL.  Use the provided HTTP status for the
   DAV errors.  Allocate new DAV errors from POOL.

   NOTE: this function destroys (cleanly, of course) SERR after it has
   copied/converted its data to the new DAV error.

   NOTE: MESSAGE needs to hang around for the lifetime of the error since
   the current implementation doesn't copy it!  Lots of callers pass static
   string constant. */</comment>
<function_decl><type><name>dav_error</name> *</type>
<name>dav_svn__convert_err</name><parameter_list>(<param><decl><type><name>svn_error_t</name> *</type><name>serr</name></decl></param>,
                    <param><decl><type><name>int</name></type> <name>status</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>message</name></decl></param>,
                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>


<comment type="block">/* Compare (PATH in ROOT) to (PATH in ROOT/PATH's created_rev).

   If these nodes are identical, then return the created_rev.

   If the nodes aren't identical, or if PATH simply doesn't exist in
   the created_rev, then return the revision represented by ROOT.

   (This is a helper to functions that want to build version-urls and
    use the CR if possible.) */</comment>
<function_decl><type><name>svn_revnum_t</name></type>
<name>dav_svn__get_safe_cr</name><parameter_list>(<param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>


<comment type="block">/* Construct various kinds of URIs.

   REPOS is always required, as all URIs will be built to refer to elements
   within that repository. WHAT specifies the type of URI to build. The
   ADD_HREF flag determines whether the URI is to be wrapped inside of
   &lt;D:href&gt;uri&lt;/D:href&gt; elements (for inclusion in a response).

   Different pieces of information are required for the various URI types:

   ACT_COLLECTION: no additional params required
   BASELINE:       REVISION should be specified
   BC:             REVISION should be specified
   PUBLIC:         PATH should be specified with a leading slash
   VERSION:        REVISION and PATH should be specified
   VCC:            no additional params required
*/</comment>
<enum>enum <name>dav_svn__build_what</name> <block>{
  <decl><name>DAV_SVN__BUILD_URI_ACT_COLLECTION</name></decl>, <comment type="block">/* the collection of activities */</comment>
  <decl><name>DAV_SVN__BUILD_URI_BASELINE</name></decl>,   <comment type="block">/* a Baseline */</comment>
  <decl><name>DAV_SVN__BUILD_URI_BC</name></decl>,         <comment type="block">/* a Baseline Collection */</comment>
  <decl><name>DAV_SVN__BUILD_URI_PUBLIC</name></decl>,     <comment type="block">/* the "public" VCR */</comment>
  <decl><name>DAV_SVN__BUILD_URI_VERSION</name></decl>,    <comment type="block">/* a Version Resource */</comment>
  <decl><name>DAV_SVN__BUILD_URI_VCC</name></decl>         <comment type="block">/* a Version Controlled Configuration */</comment>
}</block>;</enum>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type>
<name>dav_svn__build_uri</name><argument_list>(<argument><expr>const <name>dav_svn_repos</name> *<name>repos</name></expr></argument>,
                   <argument>enum <expr><name>dav_svn__build_what</name> <name>what</name></expr></argument>,
                   <argument><expr><name>svn_revnum_t</name> <name>revision</name></expr></argument>,
                   <argument><expr>const <name>char</name> *<name>path</name></expr></argument>,
                   <argument><expr><name>int</name> <name>add_href</name></expr></argument>,
                   <argument><expr><name>apr_pool_t</name> *<name>pool</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<comment type="block">/* Simple parsing of a URI. This is used for URIs which appear within a
   request body. It enables us to verify and break out the necessary pieces
   to figure out what is being referred to.

   ### this is horribly duplicative with the parsing functions in repos.c
   ### for now, this implements only a minor subset of the full range of
   ### URIs which we may need to parse. it also ignores any scheme, host,
   ### and port in the URI and simply assumes it refers to the same server.
*/</comment>
<typedef>typedef <type><struct>struct <block>{
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>repos_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>activity_id</name></decl>;</decl_stmt>
}</block></struct></type> <name>dav_svn__uri_info</name>;</typedef>

<function_decl><type><name>svn_error_t</name> *</type>
<name>dav_svn__simple_parse_uri</name><parameter_list>(<param><decl><type><name>dav_svn__uri_info</name> *</type><name>info</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>dav_resource</name> *</type><name>relative</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>uri</name></decl></param>,
                          <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>


<function_decl><type><name>int</name></type> <name>dav_svn__find_ns</name><parameter_list>(<param><decl><type><name>apr_array_header_t</name> *</type><name>namespaces</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>uri</name></decl></param>)</parameter_list>;</function_decl>


<comment type="block">/* Output XML data to OUTPUT using BB.  Use FMT as format string for the
   output. */</comment>
<function_decl><type><name>svn_error_t</name> *</type>
<name>dav_svn__send_xml</name><parameter_list>(<param><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl></param>,
                  <param><decl><type><name>ap_filter_t</name> *</type><name>output</name></decl></param>,
                  <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fmt</name></decl></param>,
                  <param><decl><type>...</type></decl></param>)</parameter_list>
       __attribute__<parameter_list>(<param/></parameter_list>(format<parameter_list>(<param><decl><type><name>printf</name></type></decl></param>, <param/></parameter_list>3, 4</function_decl>)</block></extern>))<empty_stmt>;</empty_stmt>


<comment type="block">/* Test PATH for canonicalness (defined as "what won't make the
   svn_path_* functions immediately explode"), returning an
   HTTP_BAD_REQUEST error tag if the test fails. */</comment>
<function_decl><type><name>dav_error</name> *</type><name>dav_svn__test_canonical</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>


<comment type="block">/* Convert @a serr into a dav_error.  If @a new_msg is non-NULL, use
   @a new_msg in the returned error, and write the original
   @a serr-&gt;message to httpd's log.  Destroy the passed-in @a serr,
   similarly to dav_svn__convert_err().

   @a new_msg is usually a "sanitized" version of @a serr-&gt;message.
   That is, if @a serr-&gt;message contains security-sensitive data,
   @a new_msg does not.

   The purpose of sanitization is to prevent security-sensitive data
   from being transmitted over the network to the client.  The error
   messages produced by various APIs (e.g., svn_fs, svn_repos) may
   contain security-sensitive data such as the actual server file
   system's path to the repository.  We don't want to send that to the
   client, but we do want to log the real error on the server side.
 */</comment>
<function_decl><type><name>dav_error</name> *</type>
<name>dav_svn__sanitize_error</name><parameter_list>(<param><decl><type><name>svn_error_t</name> *</type><name>serr</name></decl></param>,
                        <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>new_msg</name></decl></param>,
                        <param><decl><type><name>int</name></type> <name>http_status</name></decl></param>,
                        <param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>;</function_decl>


<comment type="block">/* Return a writable generic stream that will encode its output to base64
   and send it to the Apache filter OUTPUT using BB.  Allocate the stream in
   POOL. */</comment>
<function_decl><type><name>svn_stream_t</name> *</type>
<name>dav_svn__make_base64_output_stream</name><parameter_list>(<param><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl></param>,
                                   <param><decl><type><name>ap_filter_t</name> *</type><name>output</name></decl></param>,
                                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/* In INFO-&gt;r-&gt;subprocess_env set "SVN-ACTION" to LINE, "SVN-REPOS" to
 * INFO-&gt;repos-&gt;fs_path, and "SVN-REPOS-NAME" to INFO-&gt;repos-&gt;repo_basename. */</comment>
<function_decl><type><name>void</name></type>
<name>dav_svn__operational_log</name><parameter_list>(<param><decl><type>struct <name>dav_resource_private</name> *</type><name>info</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>line</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/*** mirror.c ***/</comment>

<comment type="block">/* Perform the fixup hook for the R request.  */</comment>
<function_decl><type><name>int</name></type> <name>dav_svn__proxy_merge_fixup</name><parameter_list>(<param><decl><type><name>request_rec</name> *</type><name>r</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/* An Apache input filter which rewrites the locations in headers and
   request body.  It reads from filter F using BB data, MODE mode, BLOCK
   blocking strategy, and READBYTES. */</comment>
<function_decl><type><name>apr_status_t</name></type> <name>dav_svn__location_in_filter</name><parameter_list>(<param><decl><type><name>ap_filter_t</name> *</type><name>f</name></decl></param>,
                                         <param><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl></param>,
                                         <param><decl><type><name>ap_input_mode_t</name></type> <name>mode</name></decl></param>,
                                         <param><decl><type><name>apr_read_type_e</name></type> <name>block</name></decl></param>,
                                         <param><decl><type><name>apr_off_t</name></type> <name>readbytes</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/* An Apache output filter F which rewrites the response headers for
 * location headers.  It will modify the stream in BB. */</comment>
<function_decl><type><name>apr_status_t</name></type> <name>dav_svn__location_header_filter</name><parameter_list>(<param><decl><type><name>ap_filter_t</name> *</type><name>f</name></decl></param>,
                                             <param><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/* An Apache output filter F which rewrites the response body for
 * location headers.  It will modify the stream in BB. */</comment>
<function_decl><type><name>apr_status_t</name></type> <name>dav_svn__location_body_filter</name><parameter_list>(<param><decl><type><name>ap_filter_t</name> *</type><name>f</name></decl></param>,
                                           <param><decl><type><name>apr_bucket_brigade</name> *</type><name>bb</name></decl></param>)</parameter_list>;</function_decl>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* __cplusplus */</comment>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* DAV_SVN_H */</comment>
</unit>
