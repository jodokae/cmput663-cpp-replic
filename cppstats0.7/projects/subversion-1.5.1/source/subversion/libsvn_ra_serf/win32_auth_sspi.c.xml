<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/subversion-1.5.1/source/subversion/libsvn_ra_serf/win32_auth_sspi.c"><comment type="block">/*
 * win32_auth_sspi.c : authn implementation through SSPI
 *
 * ====================================================================
 * Copyright (c) 2007 CollabNet.  All rights reserved.
 *
 * This software is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at http://subversion.tigris.org/license-1.html.
 * If newer versions of this license are posted there, you may use a
 * newer version instead, at your option.
 *
 * This software consists of voluntary contributions made by many
 * individuals.  For exact contribution history, see the revision
 * history and logs, available at http://subversion.tigris.org/.
 * ====================================================================
 */</comment>

<comment type="block">/* TODO: 
   - remove NTLM dependency so we can reuse SSPI for Kerberos later. */</comment>

<comment type="block">/*
 * NTLM authentication for HTTP
 *
 * 1. C  --&gt; S:    GET
 *
 *    C &lt;--  S:    401 Authentication Required
 *                 WWW-Authenticate: NTLM
 *
 * -&gt; Initialize the NTLM authentication handler.
 *
 * 2. C  --&gt; S:    GET
 *                 Authorization: NTLM &lt;Base64 encoded Type 1 message&gt;
 *                 sspi_ctx-&gt;state = sspi_auth_in_progress;
 *
 *    C &lt;--  S:    401 Authentication Required
 *                 WWW-Authenticate: NTLM &lt;Base64 encoded Type 2 message&gt;
 *
 * 3. C  --&gt; S:    GET
 *                 Authorization: NTLM &lt;Base64 encoded Type 3 message&gt;
 *                 sspi_ctx-&gt;state = sspi_auth_completed;
 *
 *    C &lt;--  S:    200 Ok
 *
 * This handshake is required for every new connection. If the handshake is
 * completed successfully, all other requested on the same connection will
 * be authenticated without needing to pass the WWW-Authenticate header.
 *
 * Note: Step 1 of the handshake will only happen on the first connection, once
 * we know the server requires NTLM authentication, the initial requests on the
 * other connections will include the NTLM Type 1 message, so we start at 
 * step 2 in the handshake.
 */</comment>

<comment type="block">/*** Includes ***/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>APR_HAVE_IPV6</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;winsock2.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;Ws2tcpip.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;Wspiapi.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;windows.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_base64.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_error.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ra_serf.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"win32_auth_sspi.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SVN_RA_SERF_SSPI_ENABLED</name></cpp:ifdef>

<comment type="block">/*** Global variables ***/</comment>
<decl_stmt><decl><type><name>HANDLE</name></type> <name>security_dll</name> <init>= <expr><name>INVALID_HANDLE_VALUE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>INIT_SECURITY_INTERFACE</name></type> <name>InitSecurityInterface_</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>PSecurityFunctionTable</name></type> <name>sspi</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>ntlm_maxtokensize</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SECURITY_DLL</name></cpp:macro> <cpp:value>"security.dll"</cpp:value></cpp:define>

<comment type="block">/* Loads security.dll in memory on the first call. Afterwards the 
   function table SSPI is loaded which we can use it to call SSPI's 
   public functions. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>load_security_dll</name><parameter_list>()</parameter_list>
<block>{
  <if>if <condition>(<expr><name>security_dll</name> != <name>INVALID_HANDLE_VALUE</name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <expr_stmt><expr><name>security_dll</name> = <call><name>LoadLibrary</name><argument_list>(<argument><expr><name>SECURITY_DLL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>security_dll</name> != <name>INVALID_HANDLE_VALUE</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* Load the function(s) */</comment>
      <expr_stmt><expr><name>InitSecurityInterface_</name> = 
        (<name>INIT_SECURITY_INTERFACE</name>)<call><name>GetProcAddress</name><argument_list>(<argument><expr><name>security_dll</name></expr></argument>, 
                                                <argument><expr>"InitSecurityInterfaceA"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>sspi</name> = <call><name>InitSecurityInterface_</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr><name>sspi</name></expr>)</condition><then>
        <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>
    }</block></then></if>

  <comment type="block">/* Initialization failed, clean up and raise error */</comment>
  <if>if <condition>(<expr><name>security_dll</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>FreeLibrary</name><argument_list>(<argument><expr><name>security_dll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <return>return <expr><call><name>svn_error_createf</name>
          <argument_list>(<argument><expr><name>SVN_ERR_RA_SERF_SSPI_INITIALISATION_FAILED</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
           <argument><expr>"SSPI Initialization failed."</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Calculates the maximum token size based on the authentication protocol. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>sspi_maxtokensize</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>auth_pkg</name></decl></param>, <param><decl><type><name>unsigned</name> <name>int</name> *</type><name>maxtokensize</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>SECURITY_STATUS</name></type> <name>status</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SecPkgInfo</name> *</type><name>sec_pkg_info</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>status</name> = <call><name><name>sspi</name>-&gt;<name>QuerySecurityPackageInfo</name></name><argument_list>(<argument><expr><name>auth_pkg</name></expr></argument>, 
                                          <argument><expr>&amp;<name>sec_pkg_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>status</name> == <name>SEC_E_OK</name></expr>)</condition><then> 
    <block>{
      <expr_stmt><expr>*<name>maxtokensize</name> = <name><name>sec_pkg_info</name>-&gt;<name>cbMaxToken</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name><name>sspi</name>-&gt;<name>FreeContextBuffer</name></name><argument_list>(<argument><expr><name>sec_pkg_info</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <return>return <expr><call><name>svn_error_createf</name>
      <argument_list>(<argument><expr><name>SVN_ERR_RA_SERF_SSPI_INITIALISATION_FAILED</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr>"SSPI Initialization failed."</expr></argument>)</argument_list></call></expr>;</return></else></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>init_sspi_connection</name><parameter_list>(<param><decl><type><name>svn_ra_serf__session_t</name> *</type><name>session</name></decl></param>,
                     <param><decl><type><name>svn_ra_serf__connection_t</name> *</type><name>conn</name></decl></param>,
                     <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>tmp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>tmp_len</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>load_security_dll</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>conn</name>-&gt;<name>sspi_context</name></name> = (<name>serf_sspi_context_t</name>*)
    <call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>serf_sspi_context_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>conn</name>-&gt;<name>sspi_context</name>-&gt;<name>ctx</name>.<name>dwLower</name></name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>conn</name>-&gt;<name>sspi_context</name>-&gt;<name>ctx</name>.<name>dwUpper</name></name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>conn</name>-&gt;<name>sspi_context</name>-&gt;<name>state</name></name> = <name>sspi_auth_not_started</name></expr>;</expr_stmt>

  <comment type="block">/* Setup the initial request to the server with an SSPI header */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>sspi_get_credentials</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>tmp</name></expr></argument>, <argument><expr>&amp;<name>tmp_len</name></expr></argument>,
                               <argument><expr><name><name>conn</name>-&gt;<name>sspi_context</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_ra_serf__encode_auth_header</name><argument_list>(<argument><expr>"NTLM"</expr></argument>, <argument><expr>&amp;<name><name>conn</name>-&gt;<name>auth_value</name></name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>tmp_len</name></expr></argument>,
                                  <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>conn</name>-&gt;<name>auth_header</name></name> = "Authorization"</expr>;</expr_stmt>

  <comment type="block">/* Make serf send the initial requests one by one */</comment>
  <expr_stmt><expr><call><name>serf_connection_set_max_outstanding_requests</name><argument_list>(<argument><expr><name><name>conn</name>-&gt;<name>conn</name></name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>handle_sspi_auth</name><parameter_list>(<param><decl><type><name>svn_ra_serf__session_t</name> *</type><name>session</name></decl></param>,
                 <param><decl><type><name>svn_ra_serf__connection_t</name> *</type><name>conn</name></decl></param>,
                 <param><decl><type><name>serf_request_t</name> *</type><name>request</name></decl></param>,
                 <param><decl><type><name>serf_bucket_t</name> *</type><name>response</name></decl></param>,
                 <param><decl><type><name>char</name> *</type><name>auth_hdr</name></decl></param>,
                 <param><decl><type><name>char</name> *</type><name>auth_attr</name></decl></param>,
                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>tmp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>base64_token</name></decl>, *<decl><type ref="prev"/><name>token</name> <init>= <expr><name>NULL</name></expr></init>, *<name>last</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>tmp_len</name></decl>, <decl><type ref="prev"/><name>token_len</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>base64_token</name> = <call><name>apr_strtok</name><argument_list>(<argument><expr><name>auth_attr</name></expr></argument>, <argument><expr>" "</expr></argument>, <argument><expr>&amp;<name>last</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>base64_token</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>token_len</name> = <call><name>apr_base64_decode_len</name><argument_list>(<argument><expr><name>base64_token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>token</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>token_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>apr_base64_decode</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>base64_token</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* We can get a whole batch of 401 responses from the server, but we should
     only start the authentication phase once, so if we started authentication
     ignore all responses with initial NTLM authentication header. */</comment>
  <if>if <condition>(<expr>!<name>token</name> &amp;&amp; <name><name>conn</name>-&gt;<name>sspi_context</name>-&gt;<name>state</name></name> != <name>sspi_auth_not_started</name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>sspi_get_credentials</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name>token_len</name></expr></argument>, <argument><expr>&amp;<name>tmp</name></expr></argument>, <argument><expr>&amp;<name>tmp_len</name></expr></argument>,
                               <argument><expr><name><name>conn</name>-&gt;<name>sspi_context</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>svn_ra_serf__encode_auth_header</name><argument_list>(<argument><expr><name><name>session</name>-&gt;<name>auth_protocol</name>-&gt;<name>auth_name</name></name></expr></argument>,
                                  <argument><expr>&amp;<name><name>conn</name>-&gt;<name>auth_value</name></name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>tmp_len</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>conn</name>-&gt;<name>auth_header</name></name> = "Authorization"</expr>;</expr_stmt>

  <comment type="block">/* If the handshake is finished tell serf it can send as much requests as it
     likes. */</comment>
  <if>if <condition>(<expr><name><name>conn</name>-&gt;<name>sspi_context</name>-&gt;<name>state</name></name> == <name>sspi_auth_completed</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>serf_connection_set_max_outstanding_requests</name><argument_list>(<argument><expr><name><name>conn</name>-&gt;<name>conn</name></name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>setup_request_sspi_auth</name><parameter_list>(<param><decl><type><name>svn_ra_serf__connection_t</name> *</type><name>conn</name></decl></param>,
                        <param><decl><type><name>serf_bucket_t</name> *</type><name>hdrs_bkt</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* Take the default authentication header for this connection, if any. */</comment>
  <if>if <condition>(<expr><name><name>conn</name>-&gt;<name>auth_header</name></name> &amp;&amp; <name><name>conn</name>-&gt;<name>auth_value</name></name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>serf_bucket_headers_setn</name><argument_list>(<argument><expr><name>hdrs_bkt</name></expr></argument>, <argument><expr><name><name>conn</name>-&gt;<name>auth_header</name></name></expr></argument>, <argument><expr><name><name>conn</name>-&gt;<name>auth_value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>conn</name>-&gt;<name>auth_header</name></name> = <name>NULL</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>conn</name>-&gt;<name>auth_value</name></name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>sspi_get_credentials</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>token</name></decl></param>, <param><decl><type><name>apr_size_t</name></type> <name>token_len</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>buf</name></decl></param>, 
                     <param><decl><type><name>apr_size_t</name> *</type><name>buf_len</name></decl></param>, <param><decl><type><name>serf_sspi_context_t</name> *</type><name>sspi_ctx</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>SecBuffer</name></type> <name>in_buf</name></decl>, <decl><type ref="prev"/><name>out_buf</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SecBufferDesc</name></type> <name>in_buf_desc</name></decl>, <decl><type ref="prev"/><name>out_buf_desc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>SECURITY_STATUS</name></type> <name>status</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DWORD</name></type> <name>ctx_attr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>TimeStamp</name></type> <name>expires</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CredHandle</name></type> <name>creds</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>target</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>CtxtHandle</name> *</type><name>ctx</name> <init>= <expr>&amp;(<name><name>sspi_ctx</name>-&gt;<name>ctx</name></name>)</expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>ntlm_maxtokensize</name> == 0</expr>)</condition><then>
    <expr_stmt><expr><call><name>sspi_maxtokensize</name><argument_list>(<argument><expr>"NTLM"</expr></argument>, <argument><expr>&amp;<name>ntlm_maxtokensize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <comment type="block">/* Prepare inbound buffer. */</comment>
  <expr_stmt><expr><name><name>in_buf</name>.<name>BufferType</name></name> = <name>SECBUFFER_TOKEN</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>in_buf</name>.<name>cbBuffer</name></name>   = <name>token_len</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>in_buf</name>.<name>pvBuffer</name></name>   = <name>token</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>in_buf_desc</name>.<name>cBuffers</name></name>  = 1</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>in_buf_desc</name>.<name>ulVersion</name></name> = <name>SECBUFFER_VERSION</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>in_buf_desc</name>.<name>pBuffers</name></name>  = &amp;<name>in_buf</name></expr>;</expr_stmt>

  <comment type="block">/* Prepare outbound buffer. */</comment>
  <expr_stmt><expr><name><name>out_buf</name>.<name>BufferType</name></name> = <name>SECBUFFER_TOKEN</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>out_buf</name>.<name>cbBuffer</name></name>   = <name>ntlm_maxtokensize</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>out_buf</name>.<name>pvBuffer</name></name>   = (<name>char</name>*)<call><name>malloc</name><argument_list>(<argument><expr><name>ntlm_maxtokensize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>out_buf_desc</name>.<name>cBuffers</name></name>  = 1</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>out_buf_desc</name>.<name>ulVersion</name></name> = <name>SECBUFFER_VERSION</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>out_buf_desc</name>.<name>pBuffers</name></name>  = &amp;<name>out_buf</name></expr>;</expr_stmt>

  <comment type="block">/* Try to accept the server token. */</comment>
  <expr_stmt><expr><name>status</name> = <call><name><name>sspi</name>-&gt;<name>AcquireCredentialsHandle</name></name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <comment type="block">/* current user */</comment>
                                          <argument><expr>"NTLM"</expr></argument>,
                                          <argument><expr><name>SECPKG_CRED_OUTBOUND</name></expr></argument>,
                                          <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                          <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                          <argument><expr>&amp;<name>creds</name></expr></argument>,
                                          <argument><expr>&amp;<name>expires</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>status</name> != <name>SEC_E_OK</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name>
            <argument_list>(<argument><expr><name>SVN_ERR_RA_SERF_SSPI_INITIALISATION_FAILED</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
             <argument><expr>"SSPI Initialization failed."</expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><name>status</name> = <call><name><name>sspi</name>-&gt;<name>InitializeSecurityContext</name></name><argument_list>(<argument><expr>&amp;<name>creds</name></expr></argument>,
                                           <argument><expr><name>ctx</name> != <name>NULL</name> &amp;&amp; <name><name>ctx</name>-&gt;<name>dwLower</name></name> != 0 
                                             ? <name>ctx</name> 
                                             : <name>NULL</name></expr></argument>,
                                           <argument><expr><name>target</name></expr></argument>,
                                           <argument><expr><name>ISC_REQ_REPLAY_DETECT</name> |
                                           <name>ISC_REQ_SEQUENCE_DETECT</name> |
                                           <name>ISC_REQ_CONFIDENTIALITY</name> |
                                           <name>ISC_REQ_DELEGATE</name></expr></argument>,
                                           <argument><expr>0</expr></argument>,
                                           <argument><expr><name>SECURITY_NATIVE_DREP</name></expr></argument>,
                                           <argument><expr>&amp;<name>in_buf_desc</name></expr></argument>,
                                           <argument><expr>0</expr></argument>,
                                           <argument><expr><name>ctx</name></expr></argument>,
                                           <argument><expr>&amp;<name>out_buf_desc</name></expr></argument>,
                                           <argument><expr>&amp;<name>ctx_attr</name></expr></argument>,
                                           <argument><expr>&amp;<name>expires</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Finish authentication if SSPI requires so. */</comment>
  <if>if <condition>(<expr><name>status</name> == <name>SEC_I_COMPLETE_NEEDED</name>
      || <name>status</name> == <name>SEC_I_COMPLETE_AND_CONTINUE</name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr><name><name>sspi</name>-&gt;<name>CompleteAuthToken</name></name> != <name>NULL</name></expr>)</condition><then>
        <expr_stmt><expr><call><name><name>sspi</name>-&gt;<name>CompleteAuthToken</name></name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr>&amp;<name>out_buf_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then></if>

  <expr_stmt><expr>*<name>buf</name> = <name><name>out_buf</name>.<name>pvBuffer</name></name></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>buf_len</name> = <name><name>out_buf</name>.<name>cbBuffer</name></name></expr>;</expr_stmt>

  <switch>switch <condition>(<expr><name>status</name></expr>)</condition>
    <block>{
      <case>case <expr><name>SEC_E_OK</name></expr>:
      </case><case>case <expr><name>SEC_I_COMPLETE_NEEDED</name></expr>:
          <expr_stmt><expr><name><name>sspi_ctx</name>-&gt;<name>state</name></name> = <name>sspi_auth_completed</name></expr>;</expr_stmt>
          <break>break;</break>

      </case><case>case <expr><name>SEC_I_CONTINUE_NEEDED</name></expr>:
      </case><case>case <expr><name>SEC_I_COMPLETE_AND_CONTINUE</name></expr>:
          <expr_stmt><expr><name><name>sspi_ctx</name>-&gt;<name>state</name></name> = <name>sspi_auth_in_progress</name></expr>;</expr_stmt>
          <break>break;</break>

      </case><default>default:
          <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_AUTHN_FAILED</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                <argument><expr>"Authentication failed with error 0x%x."</expr></argument>, <argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>;</return>
    </default>}</block></switch>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SVN_RA_SERF_SSPI_ENABLED */</comment>
</unit>
