<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/subversion-1.5.1/source/subversion/libsvn_repos/delta.c"><comment type="block">/*
 * delta.c:   an editor driver for expressing differences between two trees
 *
 * ====================================================================
 * Copyright (c) 2000-2006 CollabNet.  All rights reserved.
 *
 * This software is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at http://subversion.tigris.org/license-1.html.
 * If newer versions of this license are posted there, you may use a
 * newer version instead, at your option.
 *
 * This software consists of voluntary contributions made by many
 * individuals.  For exact contribution history, see the revision
 * history and logs, available at http://subversion.tigris.org/.
 * ====================================================================
 */</comment>

<escape char="0xc"/>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_hash.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_md5.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_types.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_delta.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_fs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_md5.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_path.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_repos.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_pools.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_props.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_private_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"repos.h"</cpp:file></cpp:include>


<escape char="0xc"/>
<comment type="block">/* THINGS TODO:  Currently the code herein gives only a slight nod to
   fully supporting directory deltas that involve renames, copies, and
   such.  */</comment>

<escape char="0xc"/>
<comment type="block">/* Some datatypes and declarations used throughout the file.  */</comment>


<comment type="block">/* Parameters which remain constant throughout a delta traversal.
   At the top of the recursion, we initialize one of these structures.
   Then we pass it down to every call.  This way, functions invoked
   deep in the recursion can get access to this traversal's global
   parameters, without using global variables.  */</comment>
<struct>struct <name>context</name> <block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_delta_editor_t</name> *</type><name>editor</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>edit_base_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>source_root</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>target_root</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_repos_authz_func_t</name></type> <name>authz_read_func</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> *</type><name>authz_read_baton</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>text_deltas</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>entry_props</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>ignore_ancestry</name></decl>;</decl_stmt>
}</block>;</struct>


<comment type="block">/* The type of a function that accepts changes to an object's property
   list.  OBJECT is the object whose properties are being changed.
   NAME is the name of the property to change.  VALUE is the new value
   for the property, or zero if the property should be deleted.  */</comment>
<typedef>typedef <function_decl><type><name>svn_error_t</name> *</type><name>proplist_change_fn_t</name><parameter_list>(<param><decl><type>struct <name>context</name> *</type><name>c</name></decl></param>,
                                          <param><decl><type><name>void</name> *</type><name>object</name></decl></param>,
                                          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>,
                                          <param><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>value</name></decl></param>,
                                          <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl></typedef>


<escape char="0xc"/>
<comment type="block">/* Some prototypes for functions used throughout.  See each individual
   function for information about what it does.  */</comment>


<comment type="block">/* Retrieving the base revision from the path/revision hash.  */</comment>
<function_decl><type><specifier>static</specifier> <name>svn_revnum_t</name></type> <name>get_path_revision</name><parameter_list>(<param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
                                      <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                                      <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>


<comment type="block">/* proplist_change_fn_t property changing functions.  */</comment>
<function_decl><type><specifier>static</specifier> <name>svn_error_t</name> *</type><name>change_dir_prop</name><parameter_list>(<param><decl><type>struct <name>context</name> *</type><name>c</name></decl></param>,
                                    <param><decl><type><name>void</name> *</type><name>object</name></decl></param>,
                                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                                    <param><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>value</name></decl></param>,
                                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>svn_error_t</name> *</type><name>change_file_prop</name><parameter_list>(<param><decl><type>struct <name>context</name> *</type><name>c</name></decl></param>,
                                     <param><decl><type><name>void</name> *</type><name>object</name></decl></param>,
                                     <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                                     <param><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>value</name></decl></param>,
                                     <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>


<comment type="block">/* Constructing deltas for properties of files and directories.  */</comment>
<function_decl><type><specifier>static</specifier> <name>svn_error_t</name> *</type><name>delta_proplists</name><parameter_list>(<param><decl><type>struct <name>context</name> *</type><name>c</name></decl></param>,
                                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>source_path</name></decl></param>,
                                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>target_path</name></decl></param>,
                                    <param><decl><type><name>proplist_change_fn_t</name> *</type><name>change_fn</name></decl></param>,
                                    <param><decl><type><name>void</name> *</type><name>object</name></decl></param>,
                                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>


<comment type="block">/* Constructing deltas for file constents.  */</comment>
<function_decl><type><specifier>static</specifier> <name>svn_error_t</name> *</type><name>send_text_delta</name><parameter_list>(<param><decl><type>struct <name>context</name> *</type><name>c</name></decl></param>,
                                    <param><decl><type><name>void</name> *</type><name>file_baton</name></decl></param>,
                                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>base_checksum</name></decl></param>,
                                    <param><decl><type><name>svn_txdelta_stream_t</name> *</type><name>delta_stream</name></decl></param>,
                                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>svn_error_t</name> *</type><name>delta_files</name><parameter_list>(<param><decl><type>struct <name>context</name> *</type><name>c</name></decl></param>,
                                <param><decl><type><name>void</name> *</type><name>file_baton</name></decl></param>,
                                <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>source_path</name></decl></param>,
                                <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>target_path</name></decl></param>,
                                <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>


<comment type="block">/* Generic directory deltafication routines.  */</comment>
<function_decl><type><specifier>static</specifier> <name>svn_error_t</name> *</type><name>delete</name><parameter_list>(<param><decl><type>struct <name>context</name> *</type><name>c</name></decl></param>,
                           <param><decl><type><name>void</name> *</type><name>dir_baton</name></decl></param>,
                           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>edit_path</name></decl></param>,
                           <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>svn_error_t</name> *</type><name>add_file_or_dir</name><parameter_list>(<param><decl><type>struct <name>context</name> *</type><name>c</name></decl></param>,
                                    <param><decl><type><name>void</name> *</type><name>dir_baton</name></decl></param>,
                                    <param><decl><type><name>svn_depth_t</name></type> <name>depth</name></decl></param>,
                                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>target_path</name></decl></param>,
                                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>edit_path</name></decl></param>,
                                    <param><decl><type><name>svn_node_kind_t</name></type> <name>tgt_kind</name></decl></param>,
                                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>svn_error_t</name> *</type><name>replace_file_or_dir</name><parameter_list>(<param><decl><type>struct <name>context</name> *</type><name>c</name></decl></param>,
                                        <param><decl><type><name>void</name> *</type><name>dir_baton</name></decl></param>,
                                        <param><decl><type><name>svn_depth_t</name></type> <name>depth</name></decl></param>,
                                        <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>source_path</name></decl></param>,
                                        <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>target_path</name></decl></param>,
                                        <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>edit_path</name></decl></param>,
                                        <param><decl><type><name>svn_node_kind_t</name></type> <name>tgt_kind</name></decl></param>,
                                        <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>svn_error_t</name> *</type><name>absent_file_or_dir</name><parameter_list>(<param><decl><type>struct <name>context</name> *</type><name>c</name></decl></param>,
                                       <param><decl><type><name>void</name> *</type><name>dir_baton</name></decl></param>,
                                       <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>edit_path</name></decl></param>,
                                       <param><decl><type><name>svn_node_kind_t</name></type> <name>tgt_kind</name></decl></param>,
                                       <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>svn_error_t</name> *</type><name>delta_dirs</name><parameter_list>(<param><decl><type>struct <name>context</name> *</type><name>c</name></decl></param>,
                               <param><decl><type><name>void</name> *</type><name>dir_baton</name></decl></param>,
                               <param><decl><type><name>svn_depth_t</name></type> <name>depth</name></decl></param>,
                               <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>source_path</name></decl></param>,
                               <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>target_path</name></decl></param>,
                               <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>edit_path</name></decl></param>,
                               <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>



<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAYBE_DEMOTE_DEPTH</name><parameter_list>(<param><type><name>depth</name></type></param>)</parameter_list></cpp:macro>                                  \
  <cpp:value>(((depth) == svn_depth_immediates || (depth) == svn_depth_files) \
   ? svn_depth_empty                                               \
   : (depth))</cpp:value></cpp:define>

<escape char="0xc"/>
<comment type="block">/* Return the error 'SVN_ERR_AUTHZ_ROOT_UNREADABLE' if PATH in ROOT is
 * unreadable according to AUTHZ_READ_FUNC with AUTHZ_READ_BATON.
 *
 * PATH should be the implicit root path of an editor drive, that is,
 * the path used by editor-&gt;open_root().
 */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>authz_root_check</name><parameter_list>(<param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                 <param><decl><type><name>svn_repos_authz_func_t</name></type> <name>authz_read_func</name></decl></param>,
                 <param><decl><type><name>void</name> *</type><name>authz_read_baton</name></decl></param>,
                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>allowed</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>authz_read_func</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>authz_read_func</name><argument_list>(<argument><expr>&amp;<name>allowed</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>authz_read_baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr>! <name>allowed</name></expr>)</condition><then>
        <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_AUTHZ_ROOT_UNREADABLE</name></expr></argument>, <argument><expr>0</expr></argument>,
                                <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Unable to open root of edit"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
    }</block></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>not_a_dir_error</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>role</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>svn_error_createf</name>
    <argument_list>(<argument><expr><name>SVN_ERR_FS_NOT_DIRECTORY</name></expr></argument>, <argument><expr>0</expr></argument>,
     <argument><expr>"Invalid %s directory '%s'"</expr></argument>,
     <argument><expr><name>role</name></expr></argument>, <argument><expr><name>path</name> ? <name>path</name> : "(null)"</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<comment type="block">/* Public interface to computing directory deltas.  */</comment>
<function><type><name>svn_error_t</name> *</type>
<name>svn_repos_dir_delta2</name><parameter_list>(<param><decl><type><name>svn_fs_root_t</name> *</type><name>src_root</name></decl></param>,
                     <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>src_parent_dir</name></decl></param>,
                     <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>src_entry</name></decl></param>,
                     <param><decl><type><name>svn_fs_root_t</name> *</type><name>tgt_root</name></decl></param>,
                     <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>tgt_fullpath</name></decl></param>,
                     <param><decl><type><specifier>const</specifier> <name>svn_delta_editor_t</name> *</type><name>editor</name></decl></param>,
                     <param><decl><type><name>void</name> *</type><name>edit_baton</name></decl></param>,
                     <param><decl><type><name>svn_repos_authz_func_t</name></type> <name>authz_read_func</name></decl></param>,
                     <param><decl><type><name>void</name> *</type><name>authz_read_baton</name></decl></param>,
                     <param><decl><type><name>svn_boolean_t</name></type> <name>text_deltas</name></decl></param>,
                     <param><decl><type><name>svn_depth_t</name></type> <name>depth</name></decl></param>,
                     <param><decl><type><name>svn_boolean_t</name></type> <name>entry_props</name></decl></param>,
                     <param><decl><type><name>svn_boolean_t</name></type> <name>ignore_ancestry</name></decl></param>,
                     <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>void</name> *</type><name>root_baton</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>context</name></type> <name>c</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>src_fullpath</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>src_id</name></decl>, *<decl><type ref="prev"/><name>tgt_id</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>src_kind</name></decl>, <decl><type ref="prev"/><name>tgt_kind</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>rootrev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>distance</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>authz_root_path</name></decl>;</decl_stmt>

  <comment type="block">/* SRC_PARENT_DIR must be valid. */</comment>
  <if>if <condition>(<expr>! <name>src_parent_dir</name></expr>)</condition><then>
    <return>return <expr><call><name>not_a_dir_error</name><argument_list>(<argument><expr>"source parent"</expr></argument>, <argument><expr><name>src_parent_dir</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* TGT_FULLPATH must be valid. */</comment>
  <if>if <condition>(<expr>! <name>tgt_fullpath</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_FS_PATH_SYNTAX</name></expr></argument>, <argument><expr>0</expr></argument>,
                            <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Invalid target path"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <if>if <condition>(<expr><name>depth</name> == <name>svn_depth_exclude</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_REPOS_BAD_ARGS</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                            <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Delta depth 'exclude' not supported"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Calculate the fs path implicitly used for editor-&gt;open_root, so
     we can do an authz check on that path first. */</comment>
  <if>if <condition>(<expr>*<name>src_entry</name></expr>)</condition><then>
    <expr_stmt><expr><name>authz_root_path</name> = <call><name>svn_path_dirname</name><argument_list>(<argument><expr><name>tgt_fullpath</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name>authz_root_path</name> = <name>tgt_fullpath</name></expr>;</expr_stmt></else></if>

  <comment type="block">/* Construct the full path of the source item. */</comment>
  <expr_stmt><expr><name>src_fullpath</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>src_parent_dir</name></expr></argument>, <argument><expr><name>src_entry</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Get the node kinds for the source and target paths.  */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_check_path</name><argument_list>(<argument><expr>&amp;<name>tgt_kind</name></expr></argument>, <argument><expr><name>tgt_root</name></expr></argument>, <argument><expr><name>tgt_fullpath</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_check_path</name><argument_list>(<argument><expr>&amp;<name>src_kind</name></expr></argument>, <argument><expr><name>src_root</name></expr></argument>, <argument><expr><name>src_fullpath</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If neither of our paths exists, we don't really have anything to do. */</comment>
  <if>if <condition>(<expr>(<name>tgt_kind</name> == <name>svn_node_none</name>) &amp;&amp; (<name>src_kind</name> == <name>svn_node_none</name>)</expr>)</condition><then>
    <goto>goto <name>cleanup</name>;</goto></then></if>

  <comment type="block">/* If either the source or the target is a non-directory, we
     require that a SRC_ENTRY be supplied. */</comment>
  <if>if <condition>(<expr>(! *<name>src_entry</name>) &amp;&amp; ((<name>src_kind</name> != <name>svn_node_dir</name>)
                         || <name>tgt_kind</name> != <name>svn_node_dir</name>)</expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name>
      <argument_list>(<argument><expr><name>SVN_ERR_FS_PATH_SYNTAX</name></expr></argument>, <argument><expr>0</expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Invalid editor anchoring; at least one of the "
         "input paths is not a directory and there was no source entry"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Set the global target revision if one can be determined. */</comment>
  <if>if <condition>(<expr><call><name>svn_fs_is_revision_root</name><argument_list>(<argument><expr><name>tgt_root</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>editor</name>-&gt;<name>set_target_revision</name></name>
              <argument_list>(<argument><expr><name>edit_baton</name></expr></argument>, <argument><expr><call><name>svn_fs_revision_root_revision</name><argument_list>(<argument><expr><name>tgt_root</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else <if>if <condition>(<expr><call><name>svn_fs_is_txn_root</name><argument_list>(<argument><expr><name>tgt_root</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>editor</name>-&gt;<name>set_target_revision</name></name>
              <argument_list>(<argument><expr><name>edit_baton</name></expr></argument>, <argument><expr><call><name>svn_fs_txn_root_base_revision</name><argument_list>(<argument><expr><name>tgt_root</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if></else></if>

  <comment type="block">/* Setup our pseudo-global structure here.  We need these variables
     throughout the deltafication process, so pass them around by
     reference to all the helper functions. */</comment>
  <expr_stmt><expr><name><name>c</name>.<name>editor</name></name> = <name>editor</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>c</name>.<name>source_root</name></name> = <name>src_root</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>c</name>.<name>target_root</name></name> = <name>tgt_root</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>c</name>.<name>authz_read_func</name></name> = <name>authz_read_func</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>c</name>.<name>authz_read_baton</name></name> = <name>authz_read_baton</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>c</name>.<name>text_deltas</name></name> = <name>text_deltas</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>c</name>.<name>entry_props</name></name> = <name>entry_props</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>c</name>.<name>ignore_ancestry</name></name> = <name>ignore_ancestry</name></expr>;</expr_stmt>

  <comment type="block">/* Get our editor root's revision. */</comment>
  <expr_stmt><expr><name>rootrev</name> = <call><name>get_path_revision</name><argument_list>(<argument><expr><name>src_root</name></expr></argument>, <argument><expr><name>src_parent_dir</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If one or the other of our paths doesn't exist, we have to handle
     those cases specially. */</comment>
  <if>if <condition>(<expr><name>tgt_kind</name> == <name>svn_node_none</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* Caller thinks that target still exists, but it doesn't.
         So transform their source path to "nothing" by deleting it. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>authz_root_check</name><argument_list>(<argument><expr><name>tgt_root</name></expr></argument>, <argument><expr><name>authz_root_path</name></expr></argument>,
                               <argument><expr><name>authz_read_func</name></expr></argument>, <argument><expr><name>authz_read_baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>editor</name>-&gt;<name>open_root</name></name><argument_list>(<argument><expr><name>edit_baton</name></expr></argument>, <argument><expr><name>rootrev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>&amp;<name>root_baton</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>delete</name><argument_list>(<argument><expr>&amp;<name>c</name></expr></argument>, <argument><expr><name>root_baton</name></expr></argument>, <argument><expr><name>src_entry</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <goto>goto <name>cleanup</name>;</goto>
    }</block></then></if>
  <if>if <condition>(<expr><name>src_kind</name> == <name>svn_node_none</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* The source path no longer exists, but the target does.
         So transform "nothing" into "something" by adding. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>authz_root_check</name><argument_list>(<argument><expr><name>tgt_root</name></expr></argument>, <argument><expr><name>authz_root_path</name></expr></argument>,
                               <argument><expr><name>authz_read_func</name></expr></argument>, <argument><expr><name>authz_read_baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>editor</name>-&gt;<name>open_root</name></name><argument_list>(<argument><expr><name>edit_baton</name></expr></argument>, <argument><expr><name>rootrev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>&amp;<name>root_baton</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>add_file_or_dir</name><argument_list>(<argument><expr>&amp;<name>c</name></expr></argument>, <argument><expr><name>root_baton</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>tgt_fullpath</name></expr></argument>,
                              <argument><expr><name>src_entry</name></expr></argument>, <argument><expr><name>tgt_kind</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <goto>goto <name>cleanup</name>;</goto>
    }</block></then></if>

  <comment type="block">/* Get and compare the node IDs for the source and target. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_node_id</name><argument_list>(<argument><expr>&amp;<name>tgt_id</name></expr></argument>, <argument><expr><name>tgt_root</name></expr></argument>, <argument><expr><name>tgt_fullpath</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_node_id</name><argument_list>(<argument><expr>&amp;<name>src_id</name></expr></argument>, <argument><expr><name>src_root</name></expr></argument>, <argument><expr><name>src_fullpath</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>distance</name> = <call><name>svn_fs_compare_ids</name><argument_list>(<argument><expr><name>src_id</name></expr></argument>, <argument><expr><name>tgt_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>distance</name> == 0</expr>)</condition><then>
    <block>{
      <comment type="block">/* They are the same node!  No-op (you gotta love those). */</comment>
      <goto>goto <name>cleanup</name>;</goto>
    }</block></then>
  <else>else <if>if <condition>(<expr>*<name>src_entry</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* If the nodes have different kinds, we must delete the one and
         add the other.  Also, if they are completely unrelated and
         our caller is interested in relatedness, we do the same thing. */</comment>
      <if>if <condition>(<expr>(<name>src_kind</name> != <name>tgt_kind</name>)
          || ((<name>distance</name> == -1) &amp;&amp; (! <name>ignore_ancestry</name>))</expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>authz_root_check</name><argument_list>(<argument><expr><name>tgt_root</name></expr></argument>, <argument><expr><name>authz_root_path</name></expr></argument>,
                                   <argument><expr><name>authz_read_func</name></expr></argument>, <argument><expr><name>authz_read_baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>editor</name>-&gt;<name>open_root</name></name><argument_list>(<argument><expr><name>edit_baton</name></expr></argument>, <argument><expr><name>rootrev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>&amp;<name>root_baton</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>delete</name><argument_list>(<argument><expr>&amp;<name>c</name></expr></argument>, <argument><expr><name>root_baton</name></expr></argument>, <argument><expr><name>src_entry</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>add_file_or_dir</name><argument_list>(<argument><expr>&amp;<name>c</name></expr></argument>, <argument><expr><name>root_baton</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>tgt_fullpath</name></expr></argument>,
                                  <argument><expr><name>src_entry</name></expr></argument>, <argument><expr><name>tgt_kind</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
      <comment type="block">/* Otherwise, we just replace the one with the other. */</comment>
      <else>else
        <block>{
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>authz_root_check</name><argument_list>(<argument><expr><name>tgt_root</name></expr></argument>, <argument><expr><name>authz_root_path</name></expr></argument>,
                                   <argument><expr><name>authz_read_func</name></expr></argument>, <argument><expr><name>authz_read_baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>editor</name>-&gt;<name>open_root</name></name><argument_list>(<argument><expr><name>edit_baton</name></expr></argument>, <argument><expr><name>rootrev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>&amp;<name>root_baton</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>replace_file_or_dir</name><argument_list>(<argument><expr>&amp;<name>c</name></expr></argument>, <argument><expr><name>root_baton</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>src_fullpath</name></expr></argument>,
                                      <argument><expr><name>tgt_fullpath</name></expr></argument>, <argument><expr><name>src_entry</name></expr></argument>,
                                      <argument><expr><name>tgt_kind</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></then>
  <else>else
    <block>{
      <comment type="block">/* There is no entry given, so delta the whole parent directory. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>authz_root_check</name><argument_list>(<argument><expr><name>tgt_root</name></expr></argument>, <argument><expr><name>authz_root_path</name></expr></argument>,
                               <argument><expr><name>authz_read_func</name></expr></argument>, <argument><expr><name>authz_read_baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>editor</name>-&gt;<name>open_root</name></name><argument_list>(<argument><expr><name>edit_baton</name></expr></argument>, <argument><expr><name>rootrev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>&amp;<name>root_baton</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>delta_dirs</name><argument_list>(<argument><expr>&amp;<name>c</name></expr></argument>, <argument><expr><name>root_baton</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>src_fullpath</name></expr></argument>,
                         <argument><expr><name>tgt_fullpath</name></expr></argument>, <argument><expr>""</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if></else></if>

 <label><name>cleanup</name>:</label>

  <comment type="block">/* Make sure we close the root directory if we opened one above. */</comment>
  <if>if <condition>(<expr><name>root_baton</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>editor</name>-&gt;<name>close_directory</name></name><argument_list>(<argument><expr><name>root_baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* Close the edit. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>editor</name>-&gt;<name>close_edit</name></name><argument_list>(<argument><expr><name>edit_baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* All's well that ends well. */</comment>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_repos_dir_delta</name><parameter_list>(<param><decl><type><name>svn_fs_root_t</name> *</type><name>src_root</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>src_parent_dir</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>src_entry</name></decl></param>,
                    <param><decl><type><name>svn_fs_root_t</name> *</type><name>tgt_root</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>tgt_fullpath</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>svn_delta_editor_t</name> *</type><name>editor</name></decl></param>,
                    <param><decl><type><name>void</name> *</type><name>edit_baton</name></decl></param>,
                    <param><decl><type><name>svn_repos_authz_func_t</name></type> <name>authz_read_func</name></decl></param>,
                    <param><decl><type><name>void</name> *</type><name>authz_read_baton</name></decl></param>,
                    <param><decl><type><name>svn_boolean_t</name></type> <name>text_deltas</name></decl></param>,
                    <param><decl><type><name>svn_boolean_t</name></type> <name>recurse</name></decl></param>,
                    <param><decl><type><name>svn_boolean_t</name></type> <name>entry_props</name></decl></param>,
                    <param><decl><type><name>svn_boolean_t</name></type> <name>ignore_ancestry</name></decl></param>,
                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>svn_repos_dir_delta2</name><argument_list>(<argument><expr><name>src_root</name></expr></argument>,
                              <argument><expr><name>src_parent_dir</name></expr></argument>,
                              <argument><expr><name>src_entry</name></expr></argument>,
                              <argument><expr><name>tgt_root</name></expr></argument>,
                              <argument><expr><name>tgt_fullpath</name></expr></argument>,
                              <argument><expr><name>editor</name></expr></argument>,
                              <argument><expr><name>edit_baton</name></expr></argument>,
                              <argument><expr><name>authz_read_func</name></expr></argument>,
                              <argument><expr><name>authz_read_baton</name></expr></argument>,
                              <argument><expr><name>text_deltas</name></expr></argument>,
                              <argument><expr><call><name>SVN_DEPTH_INFINITY_OR_FILES</name><argument_list>(<argument><expr><name>recurse</name></expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><name>entry_props</name></expr></argument>,
                              <argument><expr><name>ignore_ancestry</name></expr></argument>,
                              <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<escape char="0xc"/>
<comment type="block">/* Retrieving the base revision from the path/revision hash.  */</comment>


<function><type><specifier>static</specifier> <name>svn_revnum_t</name></type>
<name>get_path_revision</name><parameter_list>(<param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
                  <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                  <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>revision</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>

  <comment type="block">/* Easy out -- if ROOT is a revision root, we can use the revision
     that it's a root of. */</comment>
  <if>if <condition>(<expr><call><name>svn_fs_is_revision_root</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>svn_fs_revision_root_revision</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Else, this must be a transaction root, so ask the filesystem in
     what revision this path was created. */</comment>
  <if>if <condition>(<expr>(<name>err</name> = <call><name>svn_fs_node_created_rev</name><argument_list>(<argument><expr>&amp;<name>revision</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>revision</name> = <name>SVN_INVALID_REVNUM</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* If we don't get back a valid revision, this path is mutable in
     the transaction.  We should probably examine the node on which it
     is based, doable by querying for the node-id of the path, and
     then examining that node-id's predecessor.  ### This predecessor
     determination isn't exposed via the FS public API right now, so
     for now, we'll just return the SVN_INVALID_REVNUM. */</comment>
  <return>return <expr><name>revision</name></expr>;</return>
}</block></function>

<escape char="0xc"/>
<comment type="block">/* proplist_change_fn_t property changing functions.  */</comment>


<comment type="block">/* Call the directory property-setting function of C-&gt;editor to set
   the property NAME to given VALUE on the OBJECT passed to this
   function. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>change_dir_prop</name><parameter_list>(<param><decl><type>struct <name>context</name> *</type><name>c</name></decl></param>,
                <param><decl><type><name>void</name> *</type><name>object</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>value</name></decl></param>,
                <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name><name>c</name>-&gt;<name>editor</name>-&gt;<name>change_dir_prop</name></name><argument_list>(<argument><expr><name>object</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<comment type="block">/* Call the file property-setting function of C-&gt;editor to set the
   property NAME to given VALUE on the OBJECT passed to this
   function. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>change_file_prop</name><parameter_list>(<param><decl><type>struct <name>context</name> *</type><name>c</name></decl></param>,
                 <param><decl><type><name>void</name> *</type><name>object</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>value</name></decl></param>,
                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name><name>c</name>-&gt;<name>editor</name>-&gt;<name>change_file_prop</name></name><argument_list>(<argument><expr><name>object</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>



<escape char="0xc"/>
<comment type="block">/* Constructing deltas for properties of files and directories.  */</comment>


<comment type="block">/* Generate the appropriate property editing calls to turn the
   properties of SOURCE_PATH into those of TARGET_PATH.  If
   SOURCE_PATH is NULL, this is an add, so assume the target starts
   with no properties.  Pass OBJECT on to the editor function wrapper
   CHANGE_FN. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>delta_proplists</name><parameter_list>(<param><decl><type>struct <name>context</name> *</type><name>c</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>source_path</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>target_path</name></decl></param>,
                <param><decl><type><name>proplist_change_fn_t</name> *</type><name>change_fn</name></decl></param>,
                <param><decl><type><name>void</name> *</type><name>object</name></decl></param>,
                <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>s_props</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>t_props</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>prop_diffs</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <comment type="block">/* Sanity-check our input. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>target_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Make a subpool for local allocations. */</comment>
  <expr_stmt><expr><name>subpool</name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If we're supposed to send entry props for all non-deleted items,
     here we go! */</comment>
  <if>if <condition>(<expr><name><name>c</name>-&gt;<name>entry_props</name></name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>committed_rev</name> <init>= <expr><name>SVN_INVALID_REVNUM</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>cr_str</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>committed_date</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>last_author</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

      <comment type="block">/* Get the CR and two derivative props. ### check for error returns. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_node_created_rev</name><argument_list>(<argument><expr>&amp;<name>committed_rev</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>target_root</name></name></expr></argument>,
                                      <argument><expr><name>target_path</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name>committed_rev</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name> <init>= <expr><call><name>svn_fs_root_fs</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>target_root</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>r_props</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>uuid</name></decl>;</decl_stmt>

          <comment type="block">/* Transmit the committed-rev. */</comment>
          <expr_stmt><expr><name>cr_str</name> = <call><name>svn_string_createf</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>, <argument><expr>"%ld"</expr></argument>,
                                      <argument><expr><name>committed_rev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>change_fn</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>object</name></expr></argument>, <argument><expr><name>SVN_PROP_ENTRY_COMMITTED_REV</name></expr></argument>,
                            <argument><expr><name>cr_str</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_revision_proplist</name><argument_list>(<argument><expr>&amp;<name>r_props</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>committed_rev</name></expr></argument>,
                                           <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Transmit the committed-date. */</comment>
          <expr_stmt><expr><name>committed_date</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>r_props</name></expr></argument>, <argument><expr><name>SVN_PROP_REVISION_DATE</name></expr></argument>,
                                        <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>committed_date</name> || <name>source_path</name></expr>)</condition><then>
            <block>{
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>change_fn</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>object</name></expr></argument>, <argument><expr><name>SVN_PROP_ENTRY_COMMITTED_DATE</name></expr></argument>,
                                <argument><expr><name>committed_date</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>

          <comment type="block">/* Transmit the last-author. */</comment>
          <expr_stmt><expr><name>last_author</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>r_props</name></expr></argument>, <argument><expr><name>SVN_PROP_REVISION_AUTHOR</name></expr></argument>,
                                     <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>last_author</name> || <name>source_path</name></expr>)</condition><then>
            <block>{
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>change_fn</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>object</name></expr></argument>, <argument><expr><name>SVN_PROP_ENTRY_LAST_AUTHOR</name></expr></argument>,
                                <argument><expr><name>last_author</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>

          <comment type="block">/* Transmit the UUID. */</comment>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_get_uuid</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr>&amp;<name>uuid</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>change_fn</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>object</name></expr></argument>, <argument><expr><name>SVN_PROP_ENTRY_UUID</name></expr></argument>,
                            <argument><expr><call><name>svn_string_create</name><argument_list>(<argument><expr><name>uuid</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>

  <if>if <condition>(<expr><name>source_path</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>changed</name></decl>;</decl_stmt>

      <comment type="block">/* Is this deltification worth our time? */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_props_changed</name><argument_list>(<argument><expr>&amp;<name>changed</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>target_root</name></name></expr></argument>, <argument><expr><name>target_path</name></expr></argument>,
                                   <argument><expr><name><name>c</name>-&gt;<name>source_root</name></name></expr></argument>, <argument><expr><name>source_path</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr>! <name>changed</name></expr>)</condition><then>
        <goto>goto <name>cleanup</name>;</goto></then></if>

      <comment type="block">/* If so, go ahead and get the source path's properties. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_node_proplist</name><argument_list>(<argument><expr>&amp;<name>s_props</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>source_root</name></name></expr></argument>,
                                   <argument><expr><name>source_path</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <expr_stmt><expr><name>s_props</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

  <comment type="block">/* Get the target path's properties */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_node_proplist</name><argument_list>(<argument><expr>&amp;<name>t_props</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>target_root</name></name></expr></argument>,
                               <argument><expr><name>target_path</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Now transmit the differences. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_prop_diffs</name><argument_list>(<argument><expr>&amp;<name>prop_diffs</name></expr></argument>, <argument><expr><name>t_props</name></expr></argument>, <argument><expr><name>s_props</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>prop_diffs</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>svn_prop_t</name> *</type><name>pc</name> <init>= <expr>&amp;<call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>prop_diffs</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>svn_prop_t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>change_fn</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>object</name></expr></argument>, <argument><expr><name><name>pc</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name><name>pc</name>-&gt;<name>value</name></name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

 <label><name>cleanup</name>:</label>
  <comment type="block">/* Destroy local subpool. */</comment>
  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>



<escape char="0xc"/>
<comment type="block">/* Constructing deltas for file contents.  */</comment>


<comment type="block">/* Change the contents of FILE_BATON in C-&gt;editor, according to the
   text delta from DELTA_STREAM.  Pass BASE_CHECKSUM along to
   C-&gt;editor-&gt;apply_textdelta. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>send_text_delta</name><parameter_list>(<param><decl><type>struct <name>context</name> *</type><name>c</name></decl></param>,
                <param><decl><type><name>void</name> *</type><name>file_baton</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>base_checksum</name></decl></param>,
                <param><decl><type><name>svn_txdelta_stream_t</name> *</type><name>delta_stream</name></decl></param>,
                <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_txdelta_window_handler_t</name></type> <name>delta_handler</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> *</type><name>delta_handler_baton</name></decl>;</decl_stmt>

  <comment type="block">/* Get a handler that will apply the delta to the file.  */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>c</name>-&gt;<name>editor</name>-&gt;<name>apply_textdelta</name></name>
          <argument_list>(<argument><expr><name>file_baton</name></expr></argument>, <argument><expr><name>base_checksum</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>,
           <argument><expr>&amp;<name>delta_handler</name></expr></argument>, <argument><expr>&amp;<name>delta_handler_baton</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name><name>c</name>-&gt;<name>text_deltas</name></name> &amp;&amp; <name>delta_stream</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* Deliver the delta stream to the file.  */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_txdelta_send_txstream</name><argument_list>(<argument><expr><name>delta_stream</name></expr></argument>,
                                        <argument><expr><name>delta_handler</name></expr></argument>,
                                        <argument><expr><name>delta_handler_baton</name></expr></argument>,
                                        <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <comment type="block">/* The caller doesn't want text delta data.  Just send a single
         NULL window. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>delta_handler</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>delta_handler_baton</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_repos__compare_files</name><parameter_list>(<param><decl><type><name>svn_boolean_t</name> *</type><name>changed_p</name></decl></param>,
                         <param><decl><type><name>svn_fs_root_t</name> *</type><name>root1</name></decl></param>,
                         <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path1</name></decl></param>,
                         <param><decl><type><name>svn_fs_root_t</name> *</type><name>root2</name></decl></param>,
                         <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path2</name></decl></param>,
                         <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_filesize_t</name></type> <name>size1</name></decl>, <decl><type ref="prev"/><name>size2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>digest1</name><index>[<expr><name>APR_MD5_DIGESTSIZE</name></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>digest2</name><index>[<expr><name>APR_MD5_DIGESTSIZE</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>stream1</name></decl>, *<decl><type ref="prev"/><name>stream2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>buf1</name></decl>, *<decl><type ref="prev"/><name>buf2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len1</name></decl>, <decl><type ref="prev"/><name>len2</name></decl>;</decl_stmt>

  <comment type="block">/* If the filesystem claims the things haven't changed, then they
     haven't changed. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_contents_changed</name><argument_list>(<argument><expr><name>changed_p</name></expr></argument>, <argument><expr><name>root1</name></expr></argument>, <argument><expr><name>path1</name></expr></argument>,
                                  <argument><expr><name>root2</name></expr></argument>, <argument><expr><name>path2</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!*<name>changed_p</name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <comment type="block">/* From this point on, assume things haven't changed. */</comment>
  <expr_stmt><expr>*<name>changed_p</name> = <name>FALSE</name></expr>;</expr_stmt>

  <comment type="block">/* So, things have changed.  But we need to know if the two sets of
     file contents are actually different.  If they have differing
     sizes, then we know they differ. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_file_length</name><argument_list>(<argument><expr>&amp;<name>size1</name></expr></argument>, <argument><expr><name>root1</name></expr></argument>, <argument><expr><name>path1</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_file_length</name><argument_list>(<argument><expr>&amp;<name>size2</name></expr></argument>, <argument><expr><name>root2</name></expr></argument>, <argument><expr><name>path2</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>size1</name> != <name>size2</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr>*<name>changed_p</name> = <name>TRUE</name></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>

  <comment type="block">/* Same sizes, huh?  Well, if their checksums differ, we know they
     differ. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_file_md5_checksum</name><argument_list>(<argument><expr><name>digest1</name></expr></argument>, <argument><expr><name>root1</name></expr></argument>, <argument><expr><name>path1</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_file_md5_checksum</name><argument_list>(<argument><expr><name>digest2</name></expr></argument>, <argument><expr><name>root2</name></expr></argument>, <argument><expr><name>path2</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>! <call><name>svn_md5_digests_match</name><argument_list>(<argument><expr><name>digest1</name></expr></argument>, <argument><expr><name>digest2</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <expr_stmt><expr>*<name>changed_p</name> = <name>TRUE</name></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>

  <comment type="block">/* Same sizes, same checksums.  Chances are reallllly good that they
     don't differ, but to be absolute sure, we need to compare bytes. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_file_contents</name><argument_list>(<argument><expr>&amp;<name>stream1</name></expr></argument>, <argument><expr><name>root1</name></expr></argument>, <argument><expr><name>path1</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_file_contents</name><argument_list>(<argument><expr>&amp;<name>stream2</name></expr></argument>, <argument><expr><name>root2</name></expr></argument>, <argument><expr><name>path2</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>buf1</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>SVN__STREAM_CHUNK_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>buf2</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>SVN__STREAM_CHUNK_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <do>do
    <block>{
      <expr_stmt><expr><name>len1</name> = <name>len2</name> = <name>SVN__STREAM_CHUNK_SIZE</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_read</name><argument_list>(<argument><expr><name>stream1</name></expr></argument>, <argument><expr><name>buf1</name></expr></argument>, <argument><expr>&amp;<name>len1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_read</name><argument_list>(<argument><expr><name>stream2</name></expr></argument>, <argument><expr><name>buf2</name></expr></argument>, <argument><expr>&amp;<name>len2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr><name>len1</name> != <name>len2</name> || <call><name>memcmp</name><argument_list>(<argument><expr><name>buf1</name></expr></argument>, <argument><expr><name>buf2</name></expr></argument>, <argument><expr><name>len1</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <expr_stmt><expr>*<name>changed_p</name> = <name>TRUE</name></expr>;</expr_stmt>
          <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
        }</block></then></if>
    }</block>
  while <condition>(<expr><name>len1</name> &gt; 0</expr>)</condition>;</do>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Make the appropriate edits on FILE_BATON to change its contents and
   properties from those in SOURCE_PATH to those in TARGET_PATH. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>delta_files</name><parameter_list>(<param><decl><type>struct <name>context</name> *</type><name>c</name></decl></param>,
            <param><decl><type><name>void</name> *</type><name>file_baton</name></decl></param>,
            <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>source_path</name></decl></param>,
            <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>target_path</name></decl></param>,
            <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>changed</name> <init>= <expr><name>TRUE</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Sanity-check our input. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>target_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Make a subpool for local allocations. */</comment>
  <expr_stmt><expr><name>subpool</name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Compare the files' property lists.  */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>delta_proplists</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>source_path</name></expr></argument>, <argument><expr><name>target_path</name></expr></argument>,
                          <argument><expr><name>change_file_prop</name></expr></argument>, <argument><expr><name>file_baton</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>source_path</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* Is this delta calculation worth our time?  If we are ignoring
         ancestry, then our editor implementor isn't concerned by the
         theoretical differences between "has contents which have not
         changed with respect to" and "has the same actual contents
         as".  We'll do everything we can to avoid transmitting even
         an empty text-delta in that case.  */</comment>
      <if>if <condition>(<expr><name><name>c</name>-&gt;<name>ignore_ancestry</name></name></expr>)</condition><then>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_repos__compare_files</name><argument_list>(<argument><expr>&amp;<name>changed</name></expr></argument>,
                                         <argument><expr><name><name>c</name>-&gt;<name>target_root</name></name></expr></argument>, <argument><expr><name>target_path</name></expr></argument>,
                                         <argument><expr><name><name>c</name>-&gt;<name>source_root</name></name></expr></argument>, <argument><expr><name>source_path</name></expr></argument>,
                                         <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
      <else>else
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_contents_changed</name><argument_list>(<argument><expr>&amp;<name>changed</name></expr></argument>,
                                        <argument><expr><name><name>c</name>-&gt;<name>target_root</name></name></expr></argument>, <argument><expr><name>target_path</name></expr></argument>,
                                        <argument><expr><name><name>c</name>-&gt;<name>source_root</name></name></expr></argument>, <argument><expr><name>source_path</name></expr></argument>,
                                        <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
    }</block></then>
  <else>else
    <block>{
      <comment type="block">/* If there isn't a source path, this is an add, which
         necessarily has textual mods. */</comment>
    }</block></else></if>

  <comment type="block">/* If there is a change, and the context indicates that we should
     care about it, then hand it off to a delta stream.  */</comment>
  <if>if <condition>(<expr><name>changed</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_txdelta_stream_t</name> *</type><name>delta_stream</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>source_digest</name><index>[<expr><name>APR_MD5_DIGESTSIZE</name></expr>]</index></name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>source_hex_digest</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

      <if>if <condition>(<expr><name><name>c</name>-&gt;<name>text_deltas</name></name></expr>)</condition><then>
        <block>{
          <comment type="block">/* Get a delta stream turning an empty file into one having
             TARGET_PATH's contents.  */</comment>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_get_file_delta_stream</name>
                  <argument_list>(<argument><expr>&amp;<name>delta_stream</name></expr></argument>,
                   <argument><expr><name>source_path</name> ? <name><name>c</name>-&gt;<name>source_root</name></name> : <name>NULL</name></expr></argument>,
                   <argument><expr><name>source_path</name> ? <name>source_path</name> : <name>NULL</name></expr></argument>,
                   <argument><expr><name><name>c</name>-&gt;<name>target_root</name></name></expr></argument>, <argument><expr><name>target_path</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

      <if>if <condition>(<expr><name>source_path</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_file_md5_checksum</name>
                  <argument_list>(<argument><expr><name>source_digest</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>source_root</name></name></expr></argument>, <argument><expr><name>source_path</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <expr_stmt><expr><name>source_hex_digest</name> = <call><name>svn_md5_digest_to_cstring</name><argument_list>(<argument><expr><name>source_digest</name></expr></argument>,
                                                        <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>send_text_delta</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>file_baton</name></expr></argument>, <argument><expr><name>source_hex_digest</name></expr></argument>,
                              <argument><expr><name>delta_stream</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* Cleanup. */</comment>
  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>



<escape char="0xc"/>
<comment type="block">/* Generic directory deltafication routines.  */</comment>


<comment type="block">/* Emit a delta to delete the entry named TARGET_ENTRY from DIR_BATON.  */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>delete</name><parameter_list>(<param><decl><type>struct <name>context</name> *</type><name>c</name></decl></param>,
       <param><decl><type><name>void</name> *</type><name>dir_baton</name></decl></param>,
       <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>edit_path</name></decl></param>,
       <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name><name>c</name>-&gt;<name>editor</name>-&gt;<name>delete_entry</name></name><argument_list>(<argument><expr><name>edit_path</name></expr></argument>, <argument><expr><name>SVN_INVALID_REVNUM</name></expr></argument>,
                                 <argument><expr><name>dir_baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<comment type="block">/* If authorized, emit a delta to create the entry named TARGET_ENTRY
   at the location EDIT_PATH.  If not authorized, indicate that
   EDIT_PATH is absent.  Pass DIR_BATON through to editor functions
   that require it.  DEPTH is the depth from this point downward. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>add_file_or_dir</name><parameter_list>(<param><decl><type>struct <name>context</name> *</type><name>c</name></decl></param>, <param><decl><type><name>void</name> *</type><name>dir_baton</name></decl></param>,
                <param><decl><type><name>svn_depth_t</name></type> <name>depth</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>target_path</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>edit_path</name></decl></param>,
                <param><decl><type><name>svn_node_kind_t</name></type> <name>tgt_kind</name></decl></param>,
                <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>context</name> *</type><name>context</name> <init>= <expr><name>c</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>allowed</name></decl>;</decl_stmt>

  <comment type="block">/* Sanity-check our input. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>target_path</name> &amp;&amp; <name>edit_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name><name>c</name>-&gt;<name>authz_read_func</name></name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>c</name>-&gt;<name>authz_read_func</name></name><argument_list>(<argument><expr>&amp;<name>allowed</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>target_root</name></name></expr></argument>, <argument><expr><name>target_path</name></expr></argument>,
                                 <argument><expr><name><name>c</name>-&gt;<name>authz_read_baton</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr>!<name>allowed</name></expr>)</condition><then>
        <return>return <expr><call><name>absent_file_or_dir</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>dir_baton</name></expr></argument>, <argument><expr><name>edit_path</name></expr></argument>, <argument><expr><name>tgt_kind</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
    }</block></then></if>

  <if>if <condition>(<expr><name>tgt_kind</name> == <name>svn_node_dir</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>void</name> *</type><name>subdir_baton</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>context</name>-&gt;<name>editor</name>-&gt;<name>add_directory</name></name><argument_list>(<argument><expr><name>edit_path</name></expr></argument>, <argument><expr><name>dir_baton</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                             <argument><expr><name>SVN_INVALID_REVNUM</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>,
                                             <argument><expr>&amp;<name>subdir_baton</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>delta_dirs</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>subdir_baton</name></expr></argument>, <argument><expr><call><name>MAYBE_DEMOTE_DEPTH</name><argument_list>(<argument><expr><name>depth</name></expr></argument>)</argument_list></call></expr></argument>,
                         <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>target_path</name></expr></argument>, <argument><expr><name>edit_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>context</name>-&gt;<name>editor</name>-&gt;<name>close_directory</name></name><argument_list>(<argument><expr><name>subdir_baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <decl_stmt><decl><type><name>void</name> *</type><name>file_baton</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>digest</name><index>[<expr><name>APR_MD5_DIGESTSIZE</name></expr>]</index></name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>context</name>-&gt;<name>editor</name>-&gt;<name>add_file</name></name><argument_list>(<argument><expr><name>edit_path</name></expr></argument>, <argument><expr><name>dir_baton</name></expr></argument>,
                                        <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>SVN_INVALID_REVNUM</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>,
                                        <argument><expr>&amp;<name>file_baton</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>delta_files</name><argument_list>(<argument><expr><name>context</name></expr></argument>, <argument><expr><name>file_baton</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>target_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_file_md5_checksum</name><argument_list>(<argument><expr><name>digest</name></expr></argument>, <argument><expr><name><name>context</name>-&gt;<name>target_root</name></name></expr></argument>,
                                       <argument><expr><name>target_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>context</name>-&gt;<name>editor</name>-&gt;<name>close_file</name></name>
              <argument_list>(<argument><expr><name>file_baton</name></expr></argument>, <argument><expr><call><name>svn_md5_digest_to_cstring</name><argument_list>(<argument><expr><name>digest</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* If authorized, emit a delta to modify EDIT_PATH with the changes
   from SOURCE_PATH to TARGET_PATH.  If not authorized, indicate that
   EDIT_PATH is absent.  Pass DIR_BATON through to editor functions
   that require it.  DEPTH is the depth from this point downward. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>replace_file_or_dir</name><parameter_list>(<param><decl><type>struct <name>context</name> *</type><name>c</name></decl></param>,
                    <param><decl><type><name>void</name> *</type><name>dir_baton</name></decl></param>,
                    <param><decl><type><name>svn_depth_t</name></type> <name>depth</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>source_path</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>target_path</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>edit_path</name></decl></param>,
                    <param><decl><type><name>svn_node_kind_t</name></type> <name>tgt_kind</name></decl></param>,
                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>base_revision</name> <init>= <expr><name>SVN_INVALID_REVNUM</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>allowed</name></decl>;</decl_stmt>

  <comment type="block">/* Sanity-check our input. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>target_path</name> &amp;&amp; <name>source_path</name> &amp;&amp; <name>edit_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name><name>c</name>-&gt;<name>authz_read_func</name></name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>c</name>-&gt;<name>authz_read_func</name></name><argument_list>(<argument><expr>&amp;<name>allowed</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>target_root</name></name></expr></argument>, <argument><expr><name>target_path</name></expr></argument>,
                                 <argument><expr><name><name>c</name>-&gt;<name>authz_read_baton</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr>!<name>allowed</name></expr>)</condition><then>
        <return>return <expr><call><name>absent_file_or_dir</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>dir_baton</name></expr></argument>, <argument><expr><name>edit_path</name></expr></argument>, <argument><expr><name>tgt_kind</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
    }</block></then></if>

  <comment type="block">/* Get the base revision for the entry from the hash. */</comment>
  <expr_stmt><expr><name>base_revision</name> = <call><name>get_path_revision</name><argument_list>(<argument><expr><name><name>c</name>-&gt;<name>source_root</name></name></expr></argument>, <argument><expr><name>source_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>tgt_kind</name> == <name>svn_node_dir</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>void</name> *</type><name>subdir_baton</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>c</name>-&gt;<name>editor</name>-&gt;<name>open_directory</name></name><argument_list>(<argument><expr><name>edit_path</name></expr></argument>, <argument><expr><name>dir_baton</name></expr></argument>,
                                        <argument><expr><name>base_revision</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>,
                                        <argument><expr>&amp;<name>subdir_baton</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>delta_dirs</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>subdir_baton</name></expr></argument>, <argument><expr><call><name>MAYBE_DEMOTE_DEPTH</name><argument_list>(<argument><expr><name>depth</name></expr></argument>)</argument_list></call></expr></argument>,
                         <argument><expr><name>source_path</name></expr></argument>, <argument><expr><name>target_path</name></expr></argument>, <argument><expr><name>edit_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>c</name>-&gt;<name>editor</name>-&gt;<name>close_directory</name></name><argument_list>(<argument><expr><name>subdir_baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <decl_stmt><decl><type><name>void</name> *</type><name>file_baton</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>digest</name><index>[<expr><name>APR_MD5_DIGESTSIZE</name></expr>]</index></name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>c</name>-&gt;<name>editor</name>-&gt;<name>open_file</name></name><argument_list>(<argument><expr><name>edit_path</name></expr></argument>, <argument><expr><name>dir_baton</name></expr></argument>, <argument><expr><name>base_revision</name></expr></argument>,
                                   <argument><expr><name>pool</name></expr></argument>, <argument><expr>&amp;<name>file_baton</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>delta_files</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>file_baton</name></expr></argument>, <argument><expr><name>source_path</name></expr></argument>, <argument><expr><name>target_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_file_md5_checksum</name><argument_list>(<argument><expr><name>digest</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>target_root</name></name></expr></argument>,
                                       <argument><expr><name>target_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>c</name>-&gt;<name>editor</name>-&gt;<name>close_file</name></name>
              <argument_list>(<argument><expr><name>file_baton</name></expr></argument>, <argument><expr><call><name>svn_md5_digest_to_cstring</name><argument_list>(<argument><expr><name>digest</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* In directory DIR_BATON, indicate that EDIT_PATH  (relative to the
   edit root) is absent by invoking C-&gt;editor-&gt;absent_directory or
   C-&gt;editor-&gt;absent_file (depending on TGT_KIND). */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>absent_file_or_dir</name><parameter_list>(<param><decl><type>struct <name>context</name> *</type><name>c</name></decl></param>,
                   <param><decl><type><name>void</name> *</type><name>dir_baton</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>edit_path</name></decl></param>,
                   <param><decl><type><name>svn_node_kind_t</name></type> <name>tgt_kind</name></decl></param>,
                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>edit_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>tgt_kind</name> == <name>svn_node_dir</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>c</name>-&gt;<name>editor</name>-&gt;<name>absent_directory</name></name><argument_list>(<argument><expr><name>edit_path</name></expr></argument>, <argument><expr><name>dir_baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>c</name>-&gt;<name>editor</name>-&gt;<name>absent_file</name></name><argument_list>(<argument><expr><name>edit_path</name></expr></argument>, <argument><expr><name>dir_baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Emit deltas to turn SOURCE_PATH into TARGET_PATH.  Assume that
   DIR_BATON represents the directory we're constructing to the editor
   in the context C.  */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>delta_dirs</name><parameter_list>(<param><decl><type>struct <name>context</name> *</type><name>c</name></decl></param>,
           <param><decl><type><name>void</name> *</type><name>dir_baton</name></decl></param>,
           <param><decl><type><name>svn_depth_t</name></type> <name>depth</name></decl></param>,
           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>source_path</name></decl></param>,
           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>target_path</name></decl></param>,
           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>edit_path</name></decl></param>,
           <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>s_entries</name> <init>= <expr>0</expr></init>, *<name>t_entries</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>target_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Compare the property lists.  */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>delta_proplists</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>source_path</name></expr></argument>, <argument><expr><name>target_path</name></expr></argument>,
                          <argument><expr><name>change_dir_prop</name></expr></argument>, <argument><expr><name>dir_baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Get the list of entries in each of source and target.  */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_dir_entries</name><argument_list>(<argument><expr>&amp;<name>t_entries</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>target_root</name></name></expr></argument>,
                             <argument><expr><name>target_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>source_path</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_dir_entries</name><argument_list>(<argument><expr>&amp;<name>s_entries</name></expr></argument>, <argument><expr><name><name>c</name>-&gt;<name>source_root</name></name></expr></argument>,
                               <argument><expr><name>source_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* Make a subpool for local allocations. */</comment>
  <expr_stmt><expr><name>subpool</name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Loop over the hash of entries in the target, searching for its
     partner in the source.  If we find the matching partner entry,
     use editor calls to replace the one in target with a new version
     if necessary, then remove that entry from the source entries
     hash.  If we can't find a related node in the source, we use
     editor calls to add the entry as a new item in the target.
     Having handled all the entries that exist in target, any entries
     still remaining the source entries hash represent entries that no
     longer exist in target.  Use editor calls to delete those entries
     from the target tree. */</comment>
  <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>t_entries</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>hi</name></expr>;</condition> <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_dirent_t</name> *</type><name>s_entry</name></decl>, *<decl><type ref="prev"/><name>t_entry</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_ssize_t</name></type> <name>klen</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>t_fullpath</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>e_fullpath</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s_fullpath</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>tgt_kind</name></decl>;</decl_stmt>

      <comment type="block">/* Clear out our subpool for the next iteration... */</comment>
      <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* KEY is the entry name in target, VAL the dirent */</comment>
      <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr>&amp;<name>klen</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>t_entry</name> = <name>val</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>tgt_kind</name> = <name><name>t_entry</name>-&gt;<name>kind</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>t_fullpath</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>target_path</name></expr></argument>, <argument><expr><name><name>t_entry</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>e_fullpath</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>edit_path</name></expr></argument>, <argument><expr><name><name>t_entry</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Can we find something with the same name in the source
         entries hash? */</comment>
      <if>if <condition>(<expr><name>s_entries</name> &amp;&amp; ((<name>s_entry</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>s_entries</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>klen</name></expr></argument>)</argument_list></call>) != 0)</expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><name>int</name></type> <name>distance</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>src_kind</name></decl>;</decl_stmt>

          <expr_stmt><expr><name>s_fullpath</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>source_path</name></expr></argument>, <argument><expr><name><name>t_entry</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>src_kind</name> = <name><name>s_entry</name>-&gt;<name>kind</name></name></expr>;</expr_stmt>

          <if>if <condition>(<expr><name>depth</name> == <name>svn_depth_infinity</name>
              || <name>src_kind</name> != <name>svn_node_dir</name>
              || (<name>src_kind</name> == <name>svn_node_dir</name>
                  &amp;&amp; <name>depth</name> == <name>svn_depth_immediates</name>)</expr>)</condition><then>
            <block>{
              <comment type="block">/* Use svn_fs_compare_ids() to compare our current
                 source and target ids.

                    0: means they are the same id, and this is a noop.
                   -1: means they are unrelated, so we have to delete the
                       old one and add the new one.
                    1: means the nodes are related through ancestry, so go
                       ahead and do the replace directly.  */</comment>
              <expr_stmt><expr><name>distance</name> = <call><name>svn_fs_compare_ids</name><argument_list>(<argument><expr><name><name>s_entry</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name><name>t_entry</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <if>if <condition>(<expr><name>distance</name> == 0</expr>)</condition><then>
                <block>{
                  <comment type="block">/* no-op */</comment>
                }</block></then>
              <else>else <if>if <condition>(<expr>(<name>src_kind</name> != <name>tgt_kind</name>)
                       || ((<name>distance</name> == -1) &amp;&amp; (! <name><name>c</name>-&gt;<name>ignore_ancestry</name></name>))</expr>)</condition><then>
                <block>{
                  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>delete</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>dir_baton</name></expr></argument>, <argument><expr><name>e_fullpath</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>add_file_or_dir</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>dir_baton</name></expr></argument>,
                                          <argument><expr><call><name>MAYBE_DEMOTE_DEPTH</name><argument_list>(<argument><expr><name>depth</name></expr></argument>)</argument_list></call></expr></argument>,
                                          <argument><expr><name>t_fullpath</name></expr></argument>, <argument><expr><name>e_fullpath</name></expr></argument>, <argument><expr><name>tgt_kind</name></expr></argument>,
                                          <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then>
              <else>else
                <block>{
                  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>replace_file_or_dir</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>dir_baton</name></expr></argument>,
                                              <argument><expr><call><name>MAYBE_DEMOTE_DEPTH</name><argument_list>(<argument><expr><name>depth</name></expr></argument>)</argument_list></call></expr></argument>,
                                              <argument><expr><name>s_fullpath</name></expr></argument>, <argument><expr><name>t_fullpath</name></expr></argument>,
                                              <argument><expr><name>e_fullpath</name></expr></argument>, <argument><expr><name>tgt_kind</name></expr></argument>,
                                              <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if></else></if>
            }</block></then></if>

          <comment type="block">/*  Remove the entry from the source_hash. */</comment>
          <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>s_entries</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
      <else>else
        <block>{
          <if>if <condition>(<expr><name>depth</name> == <name>svn_depth_infinity</name>
              || <name>tgt_kind</name> != <name>svn_node_dir</name>
              || (<name>tgt_kind</name> == <name>svn_node_dir</name>
                  &amp;&amp; <name>depth</name> == <name>svn_depth_immediates</name>)</expr>)</condition><then>
            <block>{
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>add_file_or_dir</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>dir_baton</name></expr></argument>,
                                      <argument><expr><call><name>MAYBE_DEMOTE_DEPTH</name><argument_list>(<argument><expr><name>depth</name></expr></argument>)</argument_list></call></expr></argument>,
                                      <argument><expr><name>t_fullpath</name></expr></argument>, <argument><expr><name>e_fullpath</name></expr></argument>, <argument><expr><name>tgt_kind</name></expr></argument>,
                                      <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></else></if>
    }</block></for>

  <comment type="block">/* All that is left in the source entries hash are things that need
     to be deleted.  Delete them.  */</comment>
  <if>if <condition>(<expr><name>s_entries</name></expr>)</condition><then>
    <block>{
      <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>s_entries</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>hi</name></expr>;</condition> <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
        <block>{
          <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_dirent_t</name> *</type><name>s_entry</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>e_fullpath</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>src_kind</name></decl>;</decl_stmt>

          <comment type="block">/* Clear out our subpool for the next iteration... */</comment>
          <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* KEY is the entry name in source, VAL the dirent */</comment>
          <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>s_entry</name> = <name>val</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>src_kind</name> = <name><name>s_entry</name>-&gt;<name>kind</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name>e_fullpath</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>edit_path</name></expr></argument>, <argument><expr><name><name>s_entry</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Do we actually want to delete the dir if we're non-recursive? */</comment>
          <if>if <condition>(<expr><name>depth</name> == <name>svn_depth_infinity</name>
              || <name>src_kind</name> != <name>svn_node_dir</name>
              || (<name>src_kind</name> == <name>svn_node_dir</name>
                  &amp;&amp; <name>depth</name> == <name>svn_depth_immediates</name>)</expr>)</condition><then>
            <block>{
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>delete</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>dir_baton</name></expr></argument>, <argument><expr><name>e_fullpath</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></for>
    }</block></then></if>

  <comment type="block">/* Destroy local allocation subpool. */</comment>
  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
</unit>
