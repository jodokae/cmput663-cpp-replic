<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/subversion-1.5.1/source/subversion/libsvn_repos/reporter.c"><comment type="block">/*
 * reporter.c : `reporter' vtable routines for updates.
 *
 * ====================================================================
 * Copyright (c) 2000-2006 CollabNet.  All rights reserved.
 *
 * This software is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at http://subversion.tigris.org/license-1.html.
 * If newer versions of this license are posted there, you may use a
 * newer version instead, at your option.
 *
 * This software consists of voluntary contributions made by many
 * individuals.  For exact contribution history, see the revision
 * history and logs, available at http://subversion.tigris.org/.
 * ====================================================================
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_path.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_types.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_error.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_error_codes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_fs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_repos.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_pools.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_md5.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_props.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"repos.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_private_config.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_CACHED_SOURCE_ROOTS</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>

<comment type="block">/* Theory of operation: we write report operations out to a temporary
   file as we receive them.  When the report is finished, we read the
   operations back out again, using them to guide the progression of
   the delta between the source and target revs.

   Temporary file format: we use a simple ad-hoc format to store the
   report operations.  Each report operation is the concatention of
   the following ("+/-" indicates the single character '+' or '-';
   &lt;length&gt; and &lt;revnum&gt; are written out as decimal strings):

     +/-                      '-' marks the end of the report
     If previous is +:
       &lt;length&gt;:&lt;bytes&gt;       Length-counted path string
       +/-                    '+' indicates the presence of link_path
       If previous is +:
         &lt;length&gt;:&lt;bytes&gt;     Length-counted link_path string
       +/-                    '+' indicates presence of revnum
       If previous is +:
         &lt;revnum&gt;:            Revnum of set_path or link_path
       +/-                    '+' indicates depth other than svn_depth_infinity
       If previous is +:
         &lt;depth&gt;:             "X","E","F","M" =&gt;
                                 svn_depth_{exclude,empty,files,immediates}
       +/-                    '+' indicates start_empty field set
       +/-                    '+' indicates presence of lock_token field.
       If previous is +:
         &lt;length&gt;:&lt;bytes&gt;     Length-counted lock_token string

   Terminology: for brevity, this file frequently uses the prefixes
   "s_" for source, "t_" for target, and "e_" for editor.  Also, to
   avoid overloading the word "target", we talk about the source
   "anchor and operand", rather than the usual "anchor and target". */</comment>

<comment type="block">/* Describes the state of a working copy subtree, as given by a
   report.  Because we keep a lookahead pathinfo, we need to allocate
   each one of these things in a subpool of the report baton and free
   it when done. */</comment>
<typedef>typedef <type><struct>struct <name>path_info_t</name>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>            <comment type="block">/* path, munged to be anchor-relative */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>link_path</name></decl>;</decl_stmt>       <comment type="block">/* NULL for set_path or delete_path */</comment>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl>;</decl_stmt>            <comment type="block">/* SVN_INVALID_REVNUM for delete_path */</comment>
  <decl_stmt><decl><type><name>svn_depth_t</name></type> <name>depth</name></decl>;</decl_stmt>           <comment type="block">/* Depth of this path, meaningless for files */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>start_empty</name></decl>;</decl_stmt>   <comment type="block">/* Meaningless for delete_path */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>lock_token</name></decl>;</decl_stmt>      <comment type="block">/* NULL if no token */</comment>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>            <comment type="block">/* Container pool */</comment>
}</block></struct></type> <name>path_info_t</name>;</typedef>

<comment type="block">/* A structure used by the routines within the `reporter' vtable,
   driven by the client as it describes its working copy revisions. */</comment>
<typedef>typedef <type><struct>struct <name>report_baton_t</name>
<block>{
  <comment type="block">/* Parameters remembered from svn_repos_begin_report2 */</comment>
  <decl_stmt><decl><type><name>svn_repos_t</name> *</type><name>repos</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fs_base</name></decl>;</decl_stmt>         <comment type="block">/* FS path corresponding to wc anchor */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s_operand</name></decl>;</decl_stmt>       <comment type="block">/* Anchor-relative wc target (may be empty) */</comment>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>t_rev</name></decl>;</decl_stmt>          <comment type="block">/* Revnum which the edit will bring the wc to */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>t_path</name></decl>;</decl_stmt>          <comment type="block">/* FS path the edit will bring the wc to */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>text_deltas</name></decl>;</decl_stmt>   <comment type="block">/* Whether to report text deltas */</comment>

  <comment type="block">/* If the client requested a specific depth, record it here; if the
     client did not, then this is svn_depth_unknown, and the depth of
     information transmitted from server to client will be governed
     strictly by the path-associated depths recorded in the report. */</comment>
  <decl_stmt><decl><type><name>svn_depth_t</name></type> <name>requested_depth</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>ignore_ancestry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>send_copyfrom_args</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>is_switch</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_delta_editor_t</name> *</type><name>editor</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> *</type><name>edit_baton</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_repos_authz_func_t</name></type> <name>authz_read_func</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> *</type><name>authz_read_baton</name></decl>;</decl_stmt>

  <comment type="block">/* The temporary file in which we are stashing the report. */</comment>
  <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>tempfile</name></decl>;</decl_stmt>

  <comment type="block">/* For the actual editor drive, we'll need a lookahead path info
     entry, a cache of FS roots, and a pool to store them. */</comment>
  <decl_stmt><decl><type><name>path_info_t</name> *</type><name>lookahead</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>t_root</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name><name>s_roots</name><index>[<expr><name>NUM_CACHED_SOURCE_ROOTS</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>
}</block></struct></type> <name>report_baton_t</name>;</typedef>

<comment type="block">/* The type of a function that accepts changes to an object's property
   list.  OBJECT is the object whose properties are being changed.
   NAME is the name of the property to change.  VALUE is the new value
   for the property, or zero if the property should be deleted. */</comment>
<typedef>typedef <function_decl><type><name>svn_error_t</name> *</type><name>proplist_change_fn_t</name><parameter_list>(<param><decl><type><name>report_baton_t</name> *</type><name>b</name></decl></param>, <param><decl><type><name>void</name> *</type><name>object</name></decl></param>,
                                          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>,
                                          <param><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>value</name></decl></param>,
                                          <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl></typedef>

<function_decl><type><specifier>static</specifier> <name>svn_error_t</name> *</type><name>delta_dirs</name><parameter_list>(<param><decl><type><name>report_baton_t</name> *</type><name>b</name></decl></param>, <param><decl><type><name>svn_revnum_t</name></type> <name>s_rev</name></decl></param>,
                               <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s_path</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>t_path</name></decl></param>,
                               <param><decl><type><name>void</name> *</type><name>dir_baton</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>e_path</name></decl></param>,
                               <param><decl><type><name>svn_boolean_t</name></type> <name>start_empty</name></decl></param>,
                               <param><decl><type><name>svn_depth_t</name></type> <name>wc_depth</name></decl></param>,
                               <param><decl><type><name>svn_depth_t</name></type> <name>requested_depth</name></decl></param>,
                               <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/* --- READING PREVIOUSLY STORED REPORT INFORMATION --- */</comment>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>read_number</name><parameter_list>(<param><decl><type><name>apr_uint64_t</name> *</type><name>num</name></decl></param>, <param><decl><type><name>apr_file_t</name> *</type><name>temp</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>

  <expr_stmt><expr>*<name>num</name> = 0</expr>;</expr_stmt>
  <while>while <condition>(<expr>1</expr>)</condition>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_getc</name><argument_list>(<argument><expr>&amp;<name>c</name></expr></argument>, <argument><expr><name>temp</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>c</name> == ':'</expr>)</condition><then>
        <break>break;</break></then></if>
      <expr_stmt><expr>*<name>num</name> = *<name>num</name> * 10 + (<name>c</name> - '0')</expr>;</expr_stmt>
    }</block></while>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>read_string</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>str</name></decl></param>, <param><decl><type><name>apr_file_t</name> *</type><name>temp</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_uint64_t</name></type> <name>len</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>buf</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>read_number</name><argument_list>(<argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr><name>temp</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Len can never be less than zero.  But could len be so large that
     len + 1 wraps around and we end up passing 0 to apr_palloc(),
     thus getting a pointer to no storage?  Probably not (16 exabyte
     string, anyone?) but let's be future-proof anyway. */</comment>
  <if>if <condition>(<expr><name>len</name> + 1 &lt; <name>len</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* xgettext doesn't expand preprocessor definitions, so we must
         pass translatable string to apr_psprintf() function to create
         intermediate string with appropriate format specifier. */</comment>
      <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_REPOS_BAD_REVISION_REPORT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                               <argument><expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>,
                                            <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Invalid length (%%%s) when "
                                              "about to read a string"</expr></argument>)</argument_list></call></expr></argument>,
                                            <argument><expr><name>APR_UINT64_T_FMT</name></expr></argument>)</argument_list></call></expr></argument>,
                               <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

  <expr_stmt><expr><name>buf</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>len</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_read_full</name><argument_list>(<argument><expr><name>temp</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>buf</name><index>[<expr><name>len</name></expr>]</index></name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr>*<name>str</name> = <name>buf</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>read_rev</name><parameter_list>(<param><decl><type><name>svn_revnum_t</name> *</type><name>rev</name></decl></param>, <param><decl><type><name>apr_file_t</name> *</type><name>temp</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_uint64_t</name></type> <name>num</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_getc</name><argument_list>(<argument><expr>&amp;<name>c</name></expr></argument>, <argument><expr><name>temp</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>c</name> == '+'</expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>read_number</name><argument_list>(<argument><expr>&amp;<name>num</name></expr></argument>, <argument><expr><name>temp</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>rev</name> = (<name>svn_revnum_t</name>) <name>num</name></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <expr_stmt><expr>*<name>rev</name> = <name>SVN_INVALID_REVNUM</name></expr>;</expr_stmt></else></if>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Read a single character to set *DEPTH (having already read '+')
   from TEMP.  PATH is the path to which the depth applies, and is
   used for error reporting only. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>read_depth</name><parameter_list>(<param><decl><type><name>svn_depth_t</name> *</type><name>depth</name></decl></param>, <param><decl><type><name>apr_file_t</name> *</type><name>temp</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
           <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_getc</name><argument_list>(<argument><expr>&amp;<name>c</name></expr></argument>, <argument><expr><name>temp</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <switch>switch <condition>(<expr><name>c</name></expr>)</condition>
    <block>{
    <case>case <expr>'X'</expr>:
      <expr_stmt><expr>*<name>depth</name> = <name>svn_depth_exclude</name></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr>'E'</expr>:
      <expr_stmt><expr>*<name>depth</name> = <name>svn_depth_empty</name></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr>'F'</expr>:
      <expr_stmt><expr>*<name>depth</name> = <name>svn_depth_files</name></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr>'M'</expr>:
      <expr_stmt><expr>*<name>depth</name> = <name>svn_depth_immediates</name></expr>;</expr_stmt>
      <break>break;</break>

      <comment type="block">/* Note that we do not tolerate explicit representation of
         svn_depth_infinity here, because that's not how
         write_path_info() writes it. */</comment>
    </case><default>default:
      <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_REPOS_BAD_REVISION_REPORT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                               <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Invalid depth (%c) for path '%s'"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return>
    </default>}</block></switch>
  
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Read a report operation *PI out of TEMP.  Set *PI to NULL if we
   have reached the end of the report. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>read_path_info</name><parameter_list>(<param><decl><type><name>path_info_t</name> **</type><name>pi</name></decl></param>, <param><decl><type><name>apr_file_t</name> *</type><name>temp</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_getc</name><argument_list>(<argument><expr>&amp;<name>c</name></expr></argument>, <argument><expr><name>temp</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>c</name> == '-'</expr>)</condition><then>
    <block>{
      <expr_stmt><expr>*<name>pi</name> = <name>NULL</name></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>

  <expr_stmt><expr>*<name>pi</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>**<name>pi</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>read_string</name><argument_list>(<argument><expr>&amp;<name>(*<name>pi</name>)-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>temp</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_getc</name><argument_list>(<argument><expr>&amp;<name>c</name></expr></argument>, <argument><expr><name>temp</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>c</name> == '+'</expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>read_string</name><argument_list>(<argument><expr>&amp;<name>(*<name>pi</name>)-&gt;<name>link_path</name></name></expr></argument>, <argument><expr><name>temp</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name>(*<name>pi</name>)-&gt;<name>link_path</name></name> = <name>NULL</name></expr>;</expr_stmt></else></if>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>read_rev</name><argument_list>(<argument><expr>&amp;<name>(*<name>pi</name>)-&gt;<name>rev</name></name></expr></argument>, <argument><expr><name>temp</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_getc</name><argument_list>(<argument><expr>&amp;<name>c</name></expr></argument>, <argument><expr><name>temp</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>c</name> == '+'</expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>read_depth</name><argument_list>(<argument><expr>&amp;(<name>(*<name>pi</name>)-&gt;<name>depth</name></name>)</expr></argument>, <argument><expr><name>temp</name></expr></argument>, <argument><expr><name>(*<name>pi</name>)-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name>(*<name>pi</name>)-&gt;<name>depth</name></name> = <name>svn_depth_infinity</name></expr>;</expr_stmt></else></if>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_getc</name><argument_list>(<argument><expr>&amp;<name>c</name></expr></argument>, <argument><expr><name>temp</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>(*<name>pi</name>)-&gt;<name>start_empty</name></name> = (<name>c</name> == '+')</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_getc</name><argument_list>(<argument><expr>&amp;<name>c</name></expr></argument>, <argument><expr><name>temp</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>c</name> == '+'</expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>read_string</name><argument_list>(<argument><expr>&amp;<name>(*<name>pi</name>)-&gt;<name>lock_token</name></name></expr></argument>, <argument><expr><name>temp</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name>(*<name>pi</name>)-&gt;<name>lock_token</name></name> = <name>NULL</name></expr>;</expr_stmt></else></if>
  <expr_stmt><expr><name>(*<name>pi</name>)-&gt;<name>pool</name></name> = <name>pool</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Return true if PI's path is a child of PREFIX (which has length PLEN). */</comment>
<function><type><specifier>static</specifier> <name>svn_boolean_t</name></type>
<name>relevant</name><parameter_list>(<param><decl><type><name>path_info_t</name> *</type><name>pi</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>prefix</name></decl></param>, <param><decl><type><name>apr_size_t</name></type> <name>plen</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr>(<name>pi</name> &amp;&amp; <call><name>strncmp</name><argument_list>(<argument><expr><name><name>pi</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>)</argument_list></call> == 0 &amp;&amp;
          (!*<name>prefix</name> || <name><name>pi</name>-&gt;<name>path</name><index>[<expr><name>plen</name></expr>]</index></name> == '/'))</expr>;</return>
}</block></function>

<comment type="block">/* Fetch the next pathinfo from B-&gt;tempfile for a descendant of
   PREFIX.  If the next pathinfo is for an immediate child of PREFIX,
   set *ENTRY to the path component of the report information and
   *INFO to the path information for that entry.  If the next pathinfo
   is for a grandchild or other more remote descendant of PREFIX, set
   *ENTRY to the immediate child corresponding to that descendant and
   set *INFO to NULL.  If the next pathinfo is not for a descendant of
   PREFIX, or if we reach the end of the report, set both *ENTRY and
   *INFO to NULL.

   At all times, B-&gt;lookahead is presumed to be the next pathinfo not
   yet returned as an immediate child, or NULL if we have reached the
   end of the report.  Because we use a lookahead element, we can't
   rely on the usual nested pool lifetimes, so allocate each pathinfo
   in a subpool of the report baton's pool.  The caller should delete
   (*INFO)-&gt;pool when it is done with the information. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>fetch_path_info</name><parameter_list>(<param><decl><type><name>report_baton_t</name> *</type><name>b</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>entry</name></decl></param>, <param><decl><type><name>path_info_t</name> **</type><name>info</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>prefix</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>plen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>relpath</name></decl>, *<decl><type ref="prev"/><name>sep</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name></decl>;</decl_stmt>

  <if>if <condition>(<expr>!<call><name>relevant</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>lookahead</name></name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <comment type="block">/* No more entries relevant to prefix. */</comment>
      <expr_stmt><expr>*<name>entry</name> = <name>NULL</name></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>info</name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <comment type="block">/* Take a look at the prefix-relative part of the path. */</comment>
      <expr_stmt><expr><name>relpath</name> = <name><name>b</name>-&gt;<name>lookahead</name>-&gt;<name>path</name></name> + (*<name>prefix</name> ? <name>plen</name> + 1 : 0)</expr>;</expr_stmt>
      <expr_stmt><expr><name>sep</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>relpath</name></expr></argument>, <argument><expr>'/'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>sep</name></expr>)</condition><then>
        <block>{
          <comment type="block">/* Return the immediate child part; do not advance. */</comment>
          <expr_stmt><expr>*<name>entry</name> = <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>relpath</name></expr></argument>, <argument><expr><name>sep</name> - <name>relpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr>*<name>info</name> = <name>NULL</name></expr>;</expr_stmt>
        }</block></then>
      <else>else
        <block>{
          <comment type="block">/* This is an immediate child; return it and advance. */</comment>
          <expr_stmt><expr>*<name>entry</name> = <name>relpath</name></expr>;</expr_stmt>
          <expr_stmt><expr>*<name>info</name> = <name><name>b</name>-&gt;<name>lookahead</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name>subpool</name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>read_path_info</name><argument_list>(<argument><expr>&amp;<name><name>b</name>-&gt;<name>lookahead</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>tempfile</name></name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></else></if>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Skip all path info entries relevant to *PREFIX.  Call this when the
   editor drive skips a directory. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>skip_path_info</name><parameter_list>(<param><decl><type><name>report_baton_t</name> *</type><name>b</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>prefix</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>plen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name></decl>;</decl_stmt>

  <while>while <condition>(<expr><call><name>relevant</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>lookahead</name></name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>plen</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{
      <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>lookahead</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>subpool</name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>read_path_info</name><argument_list>(<argument><expr>&amp;<name><name>b</name>-&gt;<name>lookahead</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>tempfile</name></name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></while>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Return true if there is at least one path info entry relevant to *PREFIX. */</comment>
<function><type><specifier>static</specifier> <name>svn_boolean_t</name></type>
<name>any_path_info</name><parameter_list>(<param><decl><type><name>report_baton_t</name> *</type><name>b</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>prefix</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>relevant</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>lookahead</name></name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* --- DRIVING THE EDITOR ONCE THE REPORT IS FINISHED --- */</comment>

<comment type="block">/* While driving the editor, the target root will remain constant, but
   we may have to jump around between source roots depending on the
   state of the working copy.  If we were to open a root each time we
   revisit a rev, we would get no benefit from node-id caching; on the
   other hand, if we hold open all the roots we ever visit, we'll use
   an unbounded amount of memory.  As a compromise, we maintain a
   fixed-size LRU cache of source roots.  get_source_root retrieves a
   root from the cache, using POOL to allocate the new root if
   necessary.  Be careful not to hold onto the root for too long,
   particularly after recursing, since another call to get_source_root
   can close it. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>get_source_root</name><parameter_list>(<param><decl><type><name>report_baton_t</name> *</type><name>b</name></decl></param>, <param><decl><type><name>svn_fs_root_t</name> **</type><name>s_root</name></decl></param>, <param><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl>, *<decl><type ref="prev"/><name>prev</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Look for the desired root in the cache, sliding all the unmatched
     entries backwards a slot to make room for the right one. */</comment>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>NUM_CACHED_SOURCE_ROOTS</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <expr_stmt><expr><name>root</name> = <name><name>b</name>-&gt;<name>s_roots</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>b</name>-&gt;<name>s_roots</name><index>[<expr><name>i</name></expr>]</index></name> = <name>prev</name></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>root</name> &amp;&amp; <call><name>svn_fs_revision_root_revision</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call> == <name>rev</name></expr>)</condition><then>
        <break>break;</break></then></if>
      <expr_stmt><expr><name>prev</name> = <name>root</name></expr>;</expr_stmt>
    }</block></for>

  <comment type="block">/* If we didn't find it, throw out the oldest root and open a new one. */</comment>
  <if>if <condition>(<expr><name>i</name> == <name>NUM_CACHED_SOURCE_ROOTS</name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr><name>prev</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>svn_fs_close_root</name><argument_list>(<argument><expr><name>prev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_revision_root</name><argument_list>(<argument><expr>&amp;<name>root</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>repos</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* Assign the desired root to the first cache slot and hand it back. */</comment>
  <expr_stmt><expr><name><name>b</name>-&gt;<name>s_roots</name><index>[<expr>0</expr>]</index></name> = <name>root</name></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>s_root</name> = <name>root</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Call the directory property-setting function of B-&gt;editor to set
   the property NAME to VALUE on DIR_BATON. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>change_dir_prop</name><parameter_list>(<param><decl><type><name>report_baton_t</name> *</type><name>b</name></decl></param>, <param><decl><type><name>void</name> *</type><name>dir_baton</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>value</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name><name>b</name>-&gt;<name>editor</name>-&gt;<name>change_dir_prop</name></name><argument_list>(<argument><expr><name>dir_baton</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Call the file property-setting function of B-&gt;editor to set the
   property NAME to VALUE on FILE_BATON. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>change_file_prop</name><parameter_list>(<param><decl><type><name>report_baton_t</name> *</type><name>b</name></decl></param>, <param><decl><type><name>void</name> *</type><name>file_baton</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>value</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name><name>b</name>-&gt;<name>editor</name>-&gt;<name>change_file_prop</name></name><argument_list>(<argument><expr><name>file_baton</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Generate the appropriate property editing calls to turn the
   properties of S_REV/S_PATH into those of B-&gt;t_root/T_PATH.  If
   S_PATH is NULL, this is an add, so assume the target starts with no
   properties.  Pass OBJECT on to the editor function wrapper
   CHANGE_FN. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>delta_proplists</name><parameter_list>(<param><decl><type><name>report_baton_t</name> *</type><name>b</name></decl></param>, <param><decl><type><name>svn_revnum_t</name></type> <name>s_rev</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s_path</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>t_path</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>lock_token</name></decl></param>,
                <param><decl><type><name>proplist_change_fn_t</name> *</type><name>change_fn</name></decl></param>,
                <param><decl><type><name>void</name> *</type><name>object</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>s_root</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>s_props</name></decl>, *<decl><type ref="prev"/><name>t_props</name></decl>, *<decl><type ref="prev"/><name>r_props</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>prop_diffs</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>crev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>uuid</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>cr_str</name></decl>, *<decl><type ref="prev"/><name>cdate</name></decl>, *<decl><type ref="prev"/><name>last_author</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>changed</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_prop_t</name> *</type><name>pc</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_lock_t</name> *</type><name>lock</name></decl>;</decl_stmt>

  <comment type="block">/* Fetch the created-rev and send entry props. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_node_created_rev</name><argument_list>(<argument><expr>&amp;<name>crev</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>t_root</name></name></expr></argument>, <argument><expr><name>t_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name>crev</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <comment type="block">/* Transmit the committed-rev. */</comment>
      <expr_stmt><expr><name>cr_str</name> = <call><name>svn_string_createf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%ld"</expr></argument>, <argument><expr><name>crev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>change_fn</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>object</name></expr></argument>,
                        <argument><expr><name>SVN_PROP_ENTRY_COMMITTED_REV</name></expr></argument>, <argument><expr><name>cr_str</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_revision_proplist</name><argument_list>(<argument><expr>&amp;<name>r_props</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>repos</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>crev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Transmit the committed-date. */</comment>
      <expr_stmt><expr><name>cdate</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>r_props</name></expr></argument>, <argument><expr><name>SVN_PROP_REVISION_DATE</name></expr></argument>,
                           <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>cdate</name> || <name>s_path</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>change_fn</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>object</name></expr></argument>, <argument><expr><name>SVN_PROP_ENTRY_COMMITTED_DATE</name></expr></argument>,
                          <argument><expr><name>cdate</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

      <comment type="block">/* Transmit the last-author. */</comment>
      <expr_stmt><expr><name>last_author</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>r_props</name></expr></argument>, <argument><expr><name>SVN_PROP_REVISION_AUTHOR</name></expr></argument>,
                                 <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>last_author</name> || <name>s_path</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>change_fn</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>object</name></expr></argument>, <argument><expr><name>SVN_PROP_ENTRY_LAST_AUTHOR</name></expr></argument>,
                          <argument><expr><name>last_author</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

      <comment type="block">/* Transmit the UUID. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_get_uuid</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>repos</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr>&amp;<name>uuid</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>change_fn</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>object</name></expr></argument>, <argument><expr><name>SVN_PROP_ENTRY_UUID</name></expr></argument>,
                        <argument><expr><call><name>svn_string_create</name><argument_list>(<argument><expr><name>uuid</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* Update lock properties. */</comment>
  <if>if <condition>(<expr><name>lock_token</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_get_lock</name><argument_list>(<argument><expr>&amp;<name>lock</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>repos</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>t_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Delete a defunct lock. */</comment>
      <if>if <condition>(<expr>! <name>lock</name> || <call><name>strcmp</name><argument_list>(<argument><expr><name>lock_token</name></expr></argument>, <argument><expr><name><name>lock</name>-&gt;<name>token</name></name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>change_fn</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>object</name></expr></argument>, <argument><expr><name>SVN_PROP_ENTRY_LOCK_TOKEN</name></expr></argument>,
                          <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then></if>

  <if>if <condition>(<expr><name>s_path</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_source_root</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr>&amp;<name>s_root</name></expr></argument>, <argument><expr><name>s_rev</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Is this deltification worth our time? */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_props_changed</name><argument_list>(<argument><expr>&amp;<name>changed</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>t_root</name></name></expr></argument>, <argument><expr><name>t_path</name></expr></argument>, <argument><expr><name>s_root</name></expr></argument>,
                                   <argument><expr><name>s_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr>! <name>changed</name></expr>)</condition><then>
        <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

      <comment type="block">/* If so, go ahead and get the source path's properties. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_node_proplist</name><argument_list>(<argument><expr>&amp;<name>s_props</name></expr></argument>, <argument><expr><name>s_root</name></expr></argument>, <argument><expr><name>s_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <expr_stmt><expr><name>s_props</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

  <comment type="block">/* Get the target path's properties */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_node_proplist</name><argument_list>(<argument><expr>&amp;<name>t_props</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>t_root</name></name></expr></argument>, <argument><expr><name>t_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Now transmit the differences. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_prop_diffs</name><argument_list>(<argument><expr>&amp;<name>prop_diffs</name></expr></argument>, <argument><expr><name>t_props</name></expr></argument>, <argument><expr><name>s_props</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>prop_diffs</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <expr_stmt><expr><name>pc</name> = &amp;<call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>prop_diffs</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>svn_prop_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>change_fn</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>object</name></expr></argument>, <argument><expr><name><name>pc</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name><name>pc</name>-&gt;<name>value</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Make the appropriate edits on FILE_BATON to change its contents and
   properties from those in S_REV/S_PATH to those in B-&gt;t_root/T_PATH,
   possibly using LOCK_TOKEN to determine if the client's lock on the file
   is defunct. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>delta_files</name><parameter_list>(<param><decl><type><name>report_baton_t</name> *</type><name>b</name></decl></param>, <param><decl><type><name>void</name> *</type><name>file_baton</name></decl></param>, <param><decl><type><name>svn_revnum_t</name></type> <name>s_rev</name></decl></param>,
            <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s_path</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>t_path</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>lock_token</name></decl></param>,
            <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>changed</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>s_root</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_txdelta_stream_t</name> *</type><name>dstream</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>s_digest</name><index>[<expr><name>APR_MD5_DIGESTSIZE</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s_hex_digest</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_txdelta_window_handler_t</name></type> <name>dhandler</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> *</type><name>dbaton</name></decl>;</decl_stmt>

  <comment type="block">/* Compare the files' property lists.  */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>delta_proplists</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>s_rev</name></expr></argument>, <argument><expr><name>s_path</name></expr></argument>, <argument><expr><name>t_path</name></expr></argument>, <argument><expr><name>lock_token</name></expr></argument>,
                          <argument><expr><name>change_file_prop</name></expr></argument>, <argument><expr><name>file_baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>s_path</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_source_root</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr>&amp;<name>s_root</name></expr></argument>, <argument><expr><name>s_rev</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Is this delta calculation worth our time?  If we are ignoring
         ancestry, then our editor implementor isn't concerned by the
         theoretical differences between "has contents which have not
         changed with respect to" and "has the same actual contents
         as".  We'll do everything we can to avoid transmitting even
         an empty text-delta in that case.  */</comment>
      <if>if <condition>(<expr><name><name>b</name>-&gt;<name>ignore_ancestry</name></name></expr>)</condition><then>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_repos__compare_files</name><argument_list>(<argument><expr>&amp;<name>changed</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>t_root</name></name></expr></argument>, <argument><expr><name>t_path</name></expr></argument>,
                                         <argument><expr><name>s_root</name></expr></argument>, <argument><expr><name>s_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
      <else>else
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_contents_changed</name><argument_list>(<argument><expr>&amp;<name>changed</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>t_root</name></name></expr></argument>, <argument><expr><name>t_path</name></expr></argument>, <argument><expr><name>s_root</name></expr></argument>,
                                        <argument><expr><name>s_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
      <if>if <condition>(<expr>!<name>changed</name></expr>)</condition><then>
        <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_file_md5_checksum</name><argument_list>(<argument><expr><name>s_digest</name></expr></argument>, <argument><expr><name>s_root</name></expr></argument>, <argument><expr><name>s_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>s_hex_digest</name> = <call><name>svn_md5_digest_to_cstring</name><argument_list>(<argument><expr><name>s_digest</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* Send the delta stream if desired, or just a NULL window if not. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>b</name>-&gt;<name>editor</name>-&gt;<name>apply_textdelta</name></name><argument_list>(<argument><expr><name>file_baton</name></expr></argument>, <argument><expr><name>s_hex_digest</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>,
                                     <argument><expr>&amp;<name>dhandler</name></expr></argument>, <argument><expr>&amp;<name>dbaton</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name><name>b</name>-&gt;<name>text_deltas</name></name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_get_file_delta_stream</name><argument_list>(<argument><expr>&amp;<name>dstream</name></expr></argument>, <argument><expr><name>s_root</name></expr></argument>, <argument><expr><name>s_path</name></expr></argument>,
                                           <argument><expr><name><name>b</name>-&gt;<name>t_root</name></name></expr></argument>, <argument><expr><name>t_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><call><name>svn_txdelta_send_txstream</name><argument_list>(<argument><expr><name>dstream</name></expr></argument>, <argument><expr><name>dhandler</name></expr></argument>, <argument><expr><name>dbaton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then>
  <else>else
    <return>return <expr><call><name>dhandler</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>dbaton</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>

<comment type="block">/* Determine if the user is authorized to view B-&gt;t_root/PATH. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>check_auth</name><parameter_list>(<param><decl><type><name>report_baton_t</name> *</type><name>b</name></decl></param>, <param><decl><type><name>svn_boolean_t</name> *</type><name>allowed</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
           <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name><name>b</name>-&gt;<name>authz_read_func</name></name></expr>)</condition><then>
    <return>return <expr><call><name><name>b</name>-&gt;<name>authz_read_func</name></name><argument_list>(<argument><expr><name>allowed</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>t_root</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
                              <argument><expr><name><name>b</name>-&gt;<name>authz_read_baton</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
  <expr_stmt><expr>*<name>allowed</name> = <name>TRUE</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Create a dirent in *ENTRY for the given ROOT and PATH.  We use this to
   replace the source or target dirent when a report pathinfo tells us to
   change paths or revisions. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>fake_dirent</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>svn_fs_dirent_t</name> **</type><name>entry</name></decl></param>, <param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
            <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_dirent_t</name> *</type><name>ent</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_check_path</name><argument_list>(<argument><expr>&amp;<name>kind</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>kind</name> == <name>svn_node_none</name></expr>)</condition><then>
    <expr_stmt><expr>*<name>entry</name> = <name>NULL</name></expr>;</expr_stmt></then>
  <else>else
    <block>{
      <expr_stmt><expr><name>ent</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>**<name>entry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>ent</name>-&gt;<name>name</name></name> = <call><name>svn_path_basename</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_node_id</name><argument_list>(<argument><expr>&amp;<name><name>ent</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>ent</name>-&gt;<name>kind</name></name> = <name>kind</name></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>entry</name> = <name>ent</name></expr>;</expr_stmt>
    }</block></else></if>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Given REQUESTED_DEPTH, WC_DEPTH and the current entry's KIND,
   determine whether we need to send the whole entry, not just deltas.
   Please refer to delta_dirs' docstring for an explanation of the
   conditionals below. */</comment>
<function><type><specifier>static</specifier> <name>svn_boolean_t</name></type>
<name>is_depth_upgrade</name><parameter_list>(<param><decl><type><name>svn_depth_t</name></type> <name>wc_depth</name></decl></param>,
                 <param><decl><type><name>svn_depth_t</name></type> <name>requested_depth</name></decl></param>,
                 <param><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>requested_depth</name> == <name>svn_depth_unknown</name>
      || <name>requested_depth</name> &lt;= <name>wc_depth</name>
      || <name>wc_depth</name> == <name>svn_depth_immediates</name></expr>)</condition><then>
    <return>return <expr><name>FALSE</name></expr>;</return></then></if>

  <if>if <condition>(<expr><name>kind</name> == <name>svn_node_file</name>
      &amp;&amp; <name>wc_depth</name> == <name>svn_depth_files</name></expr>)</condition><then>
    <return>return <expr><name>FALSE</name></expr>;</return></then></if>

  <if>if <condition>(<expr><name>kind</name> == <name>svn_node_dir</name>
      &amp;&amp; <name>wc_depth</name> == <name>svn_depth_empty</name>
      &amp;&amp; <name>requested_depth</name> == <name>svn_depth_files</name></expr>)</condition><then>
    <return>return <expr><name>FALSE</name></expr>;</return></then></if>

  <return>return <expr><name>TRUE</name></expr>;</return>
}</block></function>


<comment type="block">/* Call the B-&gt;editor's add_file() function to create PATH as a child
   of PARENT_BATON, returning a new baton in *NEW_FILE_BATON.
   However, make an attempt to send 'copyfrom' arguments if they're
   available, by examining the closest copy of the original file
   O_PATH within B-&gt;t_root.  If any copyfrom args are discovered,
   return those in *COPYFROM_PATH and *COPYFROM_REV;  otherwise leave
   those return args untouched. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>add_file_smartly</name><parameter_list>(<param><decl><type><name>report_baton_t</name> *</type><name>b</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                 <param><decl><type><name>void</name> *</type><name>parent_baton</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>o_path</name></decl></param>,
                 <param><decl><type><name>void</name> **</type><name>new_file_baton</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>copyfrom_path</name></decl></param>,
                 <param><decl><type><name>svn_revnum_t</name> *</type><name>copyfrom_rev</name></decl></param>,
                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* ### TODO:  use a subpool to do this work, clear it at the end? */</comment>
  <decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name> <init>= <expr><call><name>svn_repos_fs</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>repos</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>closest_copy_root</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>closest_copy_path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Pre-emptively assume no copyfrom args exist. */</comment>
  <expr_stmt><expr>*<name>copyfrom_path</name> = <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>copyfrom_rev</name> = <name>SVN_INVALID_REVNUM</name></expr>;</expr_stmt>

  <if>if <condition>(<expr><name><name>b</name>-&gt;<name>send_copyfrom_args</name></name></expr>)</condition><then>
    <block>{
      <comment type="block">/* Find the destination of the nearest 'copy event' which may have
         caused o_path@t_root to exist. svn_fs_closest_copy only returns paths
         starting with '/', so make sure o_path always starts with a '/'
         too. */</comment>
      <if>if <condition>(<expr>*<name>o_path</name> != '/'</expr>)</condition><then>
        <expr_stmt><expr><name>o_path</name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"/"</expr></argument>, <argument><expr><name>o_path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_closest_copy</name><argument_list>(<argument><expr>&amp;<name>closest_copy_root</name></expr></argument>, <argument><expr>&amp;<name>closest_copy_path</name></expr></argument>,
                                  <argument><expr><name><name>b</name>-&gt;<name>t_root</name></name></expr></argument>, <argument><expr><name>o_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>closest_copy_root</name> != <name>NULL</name></expr>)</condition><then>
        <block>{
          <comment type="block">/* If the destination of the copy event is the same path as
             o_path, then we've found something interesting that should
             have 'copyfrom' history. */</comment>
          <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>closest_copy_path</name></expr></argument>, <argument><expr><name>o_path</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
            <block>{
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_copied_from</name><argument_list>(<argument><expr><name>copyfrom_rev</name></expr></argument>, <argument><expr><name>copyfrom_path</name></expr></argument>,
                                         <argument><expr><name>closest_copy_root</name></expr></argument>, <argument><expr><name>closest_copy_path</name></expr></argument>,
                                         <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <if>if <condition>(<expr><name><name>b</name>-&gt;<name>authz_read_func</name></name></expr>)</condition><then>
                <block>{
                  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>allowed</name></decl>;</decl_stmt>
                  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>copyfrom_root</name></decl>;</decl_stmt>
                  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_revision_root</name><argument_list>(<argument><expr>&amp;<name>copyfrom_root</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>,
                                               <argument><expr>*<name>copyfrom_rev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>b</name>-&gt;<name>authz_read_func</name></name><argument_list>(<argument><expr>&amp;<name>allowed</name></expr></argument>, <argument><expr><name>copyfrom_root</name></expr></argument>,
                                             <argument><expr>*<name>copyfrom_path</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>authz_read_baton</name></name></expr></argument>,
                                             <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <if>if <condition>(<expr>! <name>allowed</name></expr>)</condition><then>
                    <block>{
                      <expr_stmt><expr>*<name>copyfrom_path</name> = <name>NULL</name></expr>;</expr_stmt>
                      <expr_stmt><expr>*<name>copyfrom_rev</name> = <name>SVN_INVALID_REVNUM</name></expr>;</expr_stmt>
                    }</block></then></if>
                }</block></then></if>
            }</block></then></if>
        }</block></then></if>
    }</block></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>b</name>-&gt;<name>editor</name>-&gt;<name>add_file</name></name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>parent_baton</name></expr></argument>,
                              <argument><expr>*<name>copyfrom_path</name></expr></argument>, <argument><expr>*<name>copyfrom_rev</name></expr></argument>,
                              <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>new_file_baton</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Emit a series of editing operations to transform a source entry to
   a target entry.

   S_REV and S_PATH specify the source entry.  S_ENTRY contains the
   already-looked-up information about the node-revision existing at
   that location.  S_PATH and S_ENTRY may be NULL if the entry does
   not exist in the source.  S_PATH may be non-NULL and S_ENTRY may be
   NULL if the caller expects INFO to modify the source to an existing
   location.

   B-&gt;t_root and T_PATH specify the target entry.  T_ENTRY contains
   the already-looked-up information about the node-revision existing
   at that location.  T_PATH and T_ENTRY may be NULL if the entry does
   not exist in the target.

   DIR_BATON and E_PATH contain the parameters which should be passed
   to the editor calls--DIR_BATON for the parent directory baton and
   E_PATH for the pathname.  (E_PATH is the anchor-relative working
   copy pathname, which may differ from the source and target
   pathnames if the report contains a link_path.)

   INFO contains the report information for this working copy path, or
   NULL if there is none.  This function will internally modify the
   source and target entries as appropriate based on the report
   information.

   WC_DEPTH and REQUESTED_DEPTH are propagated to delta_dirs() if
   necessary.  Refer to delta_dirs' docstring to find out what
   should happen for various combinations of WC_DEPTH/REQUESTED_DEPTH. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>update_entry</name><parameter_list>(<param><decl><type><name>report_baton_t</name> *</type><name>b</name></decl></param>, <param><decl><type><name>svn_revnum_t</name></type> <name>s_rev</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s_path</name></decl></param>,
             <param><decl><type><specifier>const</specifier> <name>svn_fs_dirent_t</name> *</type><name>s_entry</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>t_path</name></decl></param>,
             <param><decl><type><specifier>const</specifier> <name>svn_fs_dirent_t</name> *</type><name>t_entry</name></decl></param>, <param><decl><type><name>void</name> *</type><name>dir_baton</name></decl></param>,
             <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>e_path</name></decl></param>, <param><decl><type><name>path_info_t</name> *</type><name>info</name></decl></param>, <param><decl><type><name>svn_depth_t</name></type> <name>wc_depth</name></decl></param>,
             <param><decl><type><name>svn_depth_t</name></type> <name>requested_depth</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>s_root</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>allowed</name></decl>, <decl><type ref="prev"/><name>related</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> *</type><name>new_baton</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>digest</name><index>[<expr><name>APR_MD5_DIGESTSIZE</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>hex_digest</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>distance</name></decl>;</decl_stmt>

  <comment type="block">/* For non-switch operations, follow link_path in the target. */</comment>
  <if>if <condition>(<expr><name>info</name> &amp;&amp; <name><name>info</name>-&gt;<name>link_path</name></name> &amp;&amp; !<name><name>b</name>-&gt;<name>is_switch</name></name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>t_path</name> = <name><name>info</name>-&gt;<name>link_path</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>fake_dirent</name><argument_list>(<argument><expr>&amp;<name>t_entry</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>t_root</name></name></expr></argument>, <argument><expr><name>t_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <if>if <condition>(<expr><name>info</name> &amp;&amp; !<call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name><name>info</name>-&gt;<name>rev</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <comment type="block">/* Delete this entry in the source. */</comment>
      <expr_stmt><expr><name>s_path</name> = <name>NULL</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>s_entry</name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></then>
  <else>else <if>if <condition>(<expr><name>info</name> &amp;&amp; <name>s_path</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* Follow the rev and possibly path in this entry. */</comment>
      <expr_stmt><expr><name>s_path</name> = (<name><name>info</name>-&gt;<name>link_path</name></name>) ? <name><name>info</name>-&gt;<name>link_path</name></name> : <name>s_path</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>s_rev</name> = <name><name>info</name>-&gt;<name>rev</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_source_root</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr>&amp;<name>s_root</name></expr></argument>, <argument><expr><name>s_rev</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>fake_dirent</name><argument_list>(<argument><expr>&amp;<name>s_entry</name></expr></argument>, <argument><expr><name>s_root</name></expr></argument>, <argument><expr><name>s_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if></else></if>

  <comment type="block">/* Don't let the report carry us somewhere nonexistent. */</comment>
  <if>if <condition>(<expr><name>s_path</name> &amp;&amp; !<name>s_entry</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_FS_NOT_FOUND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Working copy path '%s' does not exist in "
                               "repository"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>e_path</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* If the source and target both exist and are of the same kind,
     then find out whether they're related.  If they're exactly the
     same, then we don't have to do anything (unless the report has
     changes to the source).  If we're ignoring ancestry, then any two
     nodes of the same type are related enough for us. */</comment>
  <expr_stmt><expr><name>related</name> = <name>FALSE</name></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>s_entry</name> &amp;&amp; <name>t_entry</name> &amp;&amp; <name><name>s_entry</name>-&gt;<name>kind</name></name> == <name><name>t_entry</name>-&gt;<name>kind</name></name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>distance</name> = <call><name>svn_fs_compare_ids</name><argument_list>(<argument><expr><name><name>s_entry</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name><name>t_entry</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>distance</name> == 0 &amp;&amp; !<call><name>any_path_info</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>e_path</name></expr></argument>)</argument_list></call>
          &amp;&amp; (!<name>info</name> || (!<name><name>info</name>-&gt;<name>start_empty</name></name> &amp;&amp; !<name><name>info</name>-&gt;<name>lock_token</name></name>))
          &amp;&amp; (<name>requested_depth</name> &lt;= <name>wc_depth</name> || <name><name>t_entry</name>-&gt;<name>kind</name></name> == <name>svn_node_file</name>)</expr>)</condition><then>
        <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then>
      <else>else <if>if <condition>(<expr><name>distance</name> != -1 || <name><name>b</name>-&gt;<name>ignore_ancestry</name></name></expr>)</condition><then>
        <expr_stmt><expr><name>related</name> = <name>TRUE</name></expr>;</expr_stmt></then></if></else></if>
    }</block></then></if>

  <comment type="block">/* If there's a source and it's not related to the target, nuke it. */</comment>
  <if>if <condition>(<expr><name>s_entry</name> &amp;&amp; !<name>related</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>deleted_rev</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_repos_deleted_rev</name><argument_list>(<argument><expr><call><name>svn_fs_root_fs</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>t_root</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>t_path</name></expr></argument>,
                                    <argument><expr><name>s_rev</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>t_rev</name></name></expr></argument>, <argument><expr>&amp;<name>deleted_rev</name></expr></argument>,
                                    <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>b</name>-&gt;<name>editor</name>-&gt;<name>delete_entry</name></name><argument_list>(<argument><expr><name>e_path</name></expr></argument>, <argument><expr><name>deleted_rev</name></expr></argument>, <argument><expr><name>dir_baton</name></expr></argument>,
                                      <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>s_path</name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* If there's no target, we have nothing more to do. */</comment>
  <if>if <condition>(<expr>!<name>t_entry</name></expr>)</condition><then>
    <return>return <expr><call><name>skip_path_info</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>e_path</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Check if the user is authorized to find out about the target. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>check_auth</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr>&amp;<name>allowed</name></expr></argument>, <argument><expr><name>t_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<name>allowed</name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr><name><name>t_entry</name>-&gt;<name>kind</name></name> == <name>svn_node_dir</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>b</name>-&gt;<name>editor</name>-&gt;<name>absent_directory</name></name><argument_list>(<argument><expr><name>e_path</name></expr></argument>, <argument><expr><name>dir_baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
      <else>else
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>b</name>-&gt;<name>editor</name>-&gt;<name>absent_file</name></name><argument_list>(<argument><expr><name>e_path</name></expr></argument>, <argument><expr><name>dir_baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
      <return>return <expr><call><name>skip_path_info</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>e_path</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

  <if>if <condition>(<expr><name><name>t_entry</name>-&gt;<name>kind</name></name> == <name>svn_node_dir</name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr><name>related</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>b</name>-&gt;<name>editor</name>-&gt;<name>open_directory</name></name><argument_list>(<argument><expr><name>e_path</name></expr></argument>, <argument><expr><name>dir_baton</name></expr></argument>, <argument><expr><name>s_rev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>,
                                          <argument><expr>&amp;<name>new_baton</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
      <else>else
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>b</name>-&gt;<name>editor</name>-&gt;<name>add_directory</name></name><argument_list>(<argument><expr><name>e_path</name></expr></argument>, <argument><expr><name>dir_baton</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                         <argument><expr><name>SVN_INVALID_REVNUM</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>,
                                         <argument><expr>&amp;<name>new_baton</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>delta_dirs</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>s_rev</name></expr></argument>, <argument><expr><name>s_path</name></expr></argument>, <argument><expr><name>t_path</name></expr></argument>, <argument><expr><name>new_baton</name></expr></argument>, <argument><expr><name>e_path</name></expr></argument>,
                         <argument><expr><name>info</name> ? <name><name>info</name>-&gt;<name>start_empty</name></name> : <name>FALSE</name></expr></argument>,
                         <argument><expr><name>wc_depth</name></expr></argument>, <argument><expr><name>requested_depth</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><call><name><name>b</name>-&gt;<name>editor</name>-&gt;<name>close_directory</name></name><argument_list>(<argument><expr><name>new_baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then>
  <else>else
    <block>{
      <if>if <condition>(<expr><name>related</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>b</name>-&gt;<name>editor</name>-&gt;<name>open_file</name></name><argument_list>(<argument><expr><name>e_path</name></expr></argument>, <argument><expr><name>dir_baton</name></expr></argument>, <argument><expr><name>s_rev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>,
                                       <argument><expr>&amp;<name>new_baton</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>delta_files</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>new_baton</name></expr></argument>, <argument><expr><name>s_rev</name></expr></argument>, <argument><expr><name>s_path</name></expr></argument>, <argument><expr><name>t_path</name></expr></argument>,
                              <argument><expr><name>info</name> ? <name><name>info</name>-&gt;<name>lock_token</name></name> : <name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
      <else>else
        <block>{
          <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>copyfrom_rev</name> <init>= <expr><name>SVN_INVALID_REVNUM</name></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copyfrom_path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>add_file_smartly</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>e_path</name></expr></argument>, <argument><expr><name>dir_baton</name></expr></argument>, <argument><expr><name>t_path</name></expr></argument>, <argument><expr>&amp;<name>new_baton</name></expr></argument>,
                                   <argument><expr>&amp;<name>copyfrom_path</name></expr></argument>, <argument><expr>&amp;<name>copyfrom_rev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr>! <name>copyfrom_path</name></expr>)</condition><then>
            <comment type="block">/* Send txdelta between empty file (s_path@s_rev doesn't
               exist) and added file (t_path@t_root). */</comment>
            <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>delta_files</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>new_baton</name></expr></argument>, <argument><expr><name>s_rev</name></expr></argument>, <argument><expr><name>s_path</name></expr></argument>, <argument><expr><name>t_path</name></expr></argument>,
                                <argument><expr><name>info</name> ? <name><name>info</name>-&gt;<name>lock_token</name></name> : <name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
          <else>else
            <comment type="block">/* Send txdelta between copied file (copyfrom_path@copyfrom_rev)
               and added file (tpath@t_root). */</comment>
            <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>delta_files</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>new_baton</name></expr></argument>, <argument><expr><name>copyfrom_rev</name></expr></argument>, <argument><expr><name>copyfrom_path</name></expr></argument>,
                                <argument><expr><name>t_path</name></expr></argument>, <argument><expr><name>info</name> ? <name><name>info</name>-&gt;<name>lock_token</name></name> : <name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
        }</block></else></if>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_file_md5_checksum</name><argument_list>(<argument><expr><name>digest</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>t_root</name></name></expr></argument>, <argument><expr><name>t_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>hex_digest</name> = <call><name>svn_md5_digest_to_cstring</name><argument_list>(<argument><expr><name>digest</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><call><name><name>b</name>-&gt;<name>editor</name>-&gt;<name>close_file</name></name><argument_list>(<argument><expr><name>new_baton</name></expr></argument>, <argument><expr><name>hex_digest</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></else></if>
}</block></function>

<comment type="block">/* A helper macro for when we have to recurse into subdirectories. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEPTH_BELOW_HERE</name><parameter_list>(<param><type><name>depth</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((depth) == svn_depth_immediates) ? \
                                 svn_depth_empty : (depth)</cpp:value></cpp:define>

<comment type="block">/* Emit edits within directory DIR_BATON (with corresponding path
   E_PATH) with the changes from the directory S_REV/S_PATH to the
   directory B-&gt;t_rev/T_PATH.  S_PATH may be NULL if the entry does
   not exist in the source.

   WC_DEPTH is this path's depth as reported by set_path/link_path.
   REQUESTED_DEPTH is derived from the depth set by
   svn_repos_begin_report().

   When iterating over this directory's entries, the following tables
   describe what happens for all possible combinations
   of WC_DEPTH/REQUESTED_DEPTH (rows represent WC_DEPTH, columns
   represent REQUESTED_DEPTH):

   Legend:
     X: ignore this entry (it's either below the requested depth, or
        if the requested depth is svn_depth_unknown, below the working
        copy depth)
     o: handle this entry normally
     U: handle the entry as if it were a newly added repository path
        (the client is upgrading to a deeper wc and doesn't currently
        have this entry, but it should be there after the upgrade, so we
        need to send the whole thing, not just deltas)

                              For files:
   ______________________________________________________________
   | req. depth| unknown | empty | files | immediates | infinity |
   |wc. depth  |         |       |       |            |          |
   |___________|_________|_______|_______|____________|__________|
   |empty      |    X    |   X   |   U   |     U      |    U     |
   |___________|_________|_______|_______|____________|__________|
   |files      |    o    |   X   |   o   |     o      |    o     |
   |___________|_________|_______|_______|____________|__________|
   |immediates |    o    |   X   |   o   |     o      |    o     |
   |___________|_________|_______|_______|____________|__________|
   |infinity   |    o    |   X   |   o   |     o      |    o     |
   |___________|_________|_______|_______|____________|__________|

                            For directories:
   ______________________________________________________________
   | req. depth| unknown | empty | files | immediates | infinity |
   |wc. depth  |         |       |       |            |          |
   |___________|_________|_______|_______|____________|__________|
   |empty      |    X    |   X   |   X   |     U      |    U     |
   |___________|_________|_______|_______|____________|__________|
   |files      |    X    |   X   |   X   |     U      |    U     |
   |___________|_________|_______|_______|____________|__________|
   |immediates |    o    |   X   |   X   |     o      |    o     |
   |___________|_________|_______|_______|____________|__________|
   |infinity   |    o    |   X   |   X   |     o      |    o     |
   |___________|_________|_______|_______|____________|__________|

   These rules are enforced by the is_depth_upgrade() function and by
   various other checks below.
*/</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>delta_dirs</name><parameter_list>(<param><decl><type><name>report_baton_t</name> *</type><name>b</name></decl></param>, <param><decl><type><name>svn_revnum_t</name></type> <name>s_rev</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s_path</name></decl></param>,
           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>t_path</name></decl></param>, <param><decl><type><name>void</name> *</type><name>dir_baton</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>e_path</name></decl></param>,
           <param><decl><type><name>svn_boolean_t</name></type> <name>start_empty</name></decl></param>, <param><decl><type><name>svn_depth_t</name></type> <name>wc_depth</name></decl></param>,
           <param><decl><type><name>svn_depth_t</name></type> <name>requested_depth</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>s_root</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>s_entries</name> <init>= <expr><name>NULL</name></expr></init>, *<name>t_entries</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_dirent_t</name> *</type><name>s_entry</name></decl>, *<decl><type ref="prev"/><name>t_entry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl>, *<decl><type ref="prev"/><name>s_fullpath</name></decl>, *<decl><type ref="prev"/><name>t_fullpath</name></decl>, *<decl><type ref="prev"/><name>e_fullpath</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>path_info_t</name> *</type><name>info</name></decl>;</decl_stmt>

  <comment type="block">/* Compare the property lists.  If we're starting empty, pass a NULL
     source path so that we add all the properties.

     When we support directory locks, we must pass the lock token here. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>delta_proplists</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>s_rev</name></expr></argument>, <argument><expr><name>start_empty</name> ? <name>NULL</name> : <name>s_path</name></expr></argument>, <argument><expr><name>t_path</name></expr></argument>,
                          <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>change_dir_prop</name></expr></argument>, <argument><expr><name>dir_baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>requested_depth</name> &gt; <name>svn_depth_empty</name>
      || <name>requested_depth</name> == <name>svn_depth_unknown</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* Get the list of entries in each of source and target. */</comment>
      <if>if <condition>(<expr><name>s_path</name> &amp;&amp; !<name>start_empty</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_source_root</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr>&amp;<name>s_root</name></expr></argument>, <argument><expr><name>s_rev</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_dir_entries</name><argument_list>(<argument><expr>&amp;<name>s_entries</name></expr></argument>, <argument><expr><name>s_root</name></expr></argument>, <argument><expr><name>s_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_dir_entries</name><argument_list>(<argument><expr>&amp;<name>t_entries</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>t_root</name></name></expr></argument>, <argument><expr><name>t_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Iterate over the report information for this directory. */</comment>
      <expr_stmt><expr><name>subpool</name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <while>while <condition>(<expr>1</expr>)</condition>
        <block>{
          <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>fetch_path_info</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>, <argument><expr>&amp;<name>info</name></expr></argument>, <argument><expr><name>e_path</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr>!<name>name</name></expr>)</condition><then>
            <break>break;</break></then></if>

          <comment type="block">/* Invalid revnum means we should delete, unless this is
             just an excluded subpath. */</comment>
          <if>if <condition>(<expr><name>info</name> 
              &amp;&amp; !<call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name><name>info</name>-&gt;<name>rev</name></name></expr></argument>)</argument_list></call>
              &amp;&amp; <name><name>info</name>-&gt;<name>depth</name></name> != <name>svn_depth_exclude</name></expr>)</condition><then>
            <block>{
              <comment type="block">/* We want to perform deletes before non-replacement adds,
                 for graceful handling of case-only renames on
                 case-insensitive client filesystems.  So, if the report
                 item is a delete, remove the entry from the source hash,
                 but don't update the entry yet. */</comment>
              <if>if <condition>(<expr><name>s_entries</name></expr>)</condition><then>
                <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>s_entries</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
              <continue>continue;</continue>
            }</block></then></if>

          <expr_stmt><expr><name>e_fullpath</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>e_path</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>t_fullpath</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>t_path</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>t_entry</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>t_entries</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>s_fullpath</name> = <name>s_path</name> ? <call><name>svn_path_join</name><argument_list>(<argument><expr><name>s_path</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call> : <name>NULL</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>s_entry</name> = <name>s_entries</name> ?
            <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>s_entries</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call> : <name>NULL</name></expr>;</expr_stmt>

          <comment type="block">/* The only special cases here are

             - When requested_depth is files but the reported path is
             a directory.  This is technically a client error, but we
             handle it anyway, by skipping the entry.

             - When the reported depth is svn_depth_exclude.
          */</comment>
          <if>if <condition>(<expr>(! <name>info</name> || <name><name>info</name>-&gt;<name>depth</name></name> != <name>svn_depth_exclude</name>)
              &amp;&amp; (<name>requested_depth</name> != <name>svn_depth_files</name>
                  || ((! <name>t_entry</name> || <name><name>t_entry</name>-&gt;<name>kind</name></name> != <name>svn_node_dir</name>)
                      &amp;&amp; (! <name>s_entry</name> || <name><name>s_entry</name>-&gt;<name>kind</name></name> != <name>svn_node_dir</name>)))</expr>)</condition><then>
            <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>update_entry</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>s_rev</name></expr></argument>, <argument><expr><name>s_fullpath</name></expr></argument>, <argument><expr><name>s_entry</name></expr></argument>, <argument><expr><name>t_fullpath</name></expr></argument>,
                                 <argument><expr><name>t_entry</name></expr></argument>, <argument><expr><name>dir_baton</name></expr></argument>, <argument><expr><name>e_fullpath</name></expr></argument>, <argument><expr><name>info</name></expr></argument>,
                                 <argument><expr><name>info</name> ? <name><name>info</name>-&gt;<name>depth</name></name>
                                      : <call><name>DEPTH_BELOW_HERE</name><argument_list>(<argument><expr><name>wc_depth</name></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><call><name>DEPTH_BELOW_HERE</name><argument_list>(<argument><expr><name>requested_depth</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

          <comment type="block">/* Don't revisit this name in the target or source entries. */</comment>
          <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>t_entries</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>s_entries</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>s_entries</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

          <comment type="block">/* pathinfo entries live in their own subpools due to lookahead,
             so we need to clear each one out as we finish with it. */</comment>
          <if>if <condition>(<expr><name>info</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name><name>info</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        }</block></while>

      <comment type="block">/* Remove any deleted entries.  Do this before processing the
         target, for graceful handling of case-only renames. */</comment>
      <if>if <condition>(<expr><name>s_entries</name></expr>)</condition><then>
        <block>{
          <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>s_entries</name></expr></argument>)</argument_list></call></expr>;</init>
               <condition><expr><name>hi</name></expr>;</condition>
               <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
            <block>{
              <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>s_entry</name> = <name>val</name></expr>;</expr_stmt>

              <if>if <condition>(<expr><call><name>apr_hash_get</name><argument_list>(<argument><expr><name>t_entries</name></expr></argument>, <argument><expr><name><name>s_entry</name>-&gt;<name>name</name></name></expr></argument>,
                               <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call> == <name>NULL</name></expr>)</condition><then>
                <block>{
                  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>deleted_rev</name></decl>;</decl_stmt>

                  <if>if <condition>(<expr><name><name>s_entry</name>-&gt;<name>kind</name></name> == <name>svn_node_file</name>
                      &amp;&amp; <name>wc_depth</name> &lt; <name>svn_depth_files</name></expr>)</condition><then>
                    <continue>continue;</continue></then></if>

                  <if>if <condition>(<expr><name><name>s_entry</name>-&gt;<name>kind</name></name> == <name>svn_node_dir</name>
                      &amp;&amp; (<name>wc_depth</name> &lt; <name>svn_depth_immediates</name>
                          || <name>requested_depth</name> == <name>svn_depth_files</name>)</expr>)</condition><then>
                    <continue>continue;</continue></then></if>

                  <comment type="block">/* There is no corresponding target entry, so delete. */</comment>
                  <expr_stmt><expr><name>e_fullpath</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>e_path</name></expr></argument>, <argument><expr><name><name>s_entry</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_repos_deleted_rev</name><argument_list>(<argument><expr><call><name>svn_fs_root_fs</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>t_root</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                                <argument><expr><call><name>svn_path_join</name><argument_list>(<argument><expr><name>t_path</name></expr></argument>,
                                                              <argument><expr><name><name>s_entry</name>-&gt;<name>name</name></name></expr></argument>,
                                                              <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>,
                                                <argument><expr><name>s_rev</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>t_rev</name></name></expr></argument>,
                                                <argument><expr>&amp;<name>deleted_rev</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>b</name>-&gt;<name>editor</name>-&gt;<name>delete_entry</name></name><argument_list>(<argument><expr><name>e_fullpath</name></expr></argument>,
                                                  <argument><expr><name>deleted_rev</name></expr></argument>,
                                                  <argument><expr><name>dir_baton</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
            }</block></for>
        }</block></then></if>

      <comment type="block">/* Loop over the dirents in the target. */</comment>
      <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>t_entries</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>hi</name></expr>;</condition> <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
        <block>{
          <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>t_entry</name> = <name>val</name></expr>;</expr_stmt>

          <if>if <condition>(<expr><call><name>is_depth_upgrade</name><argument_list>(<argument><expr><name>wc_depth</name></expr></argument>, <argument><expr><name>requested_depth</name></expr></argument>, <argument><expr><name><name>t_entry</name>-&gt;<name>kind</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <block>{
              <comment type="block">/* We're making the working copy deeper, pretend the source
                 doesn't exist. */</comment>
              <expr_stmt><expr><name>s_entry</name> = <name>NULL</name></expr>;</expr_stmt>
              <expr_stmt><expr><name>s_fullpath</name> = <name>NULL</name></expr>;</expr_stmt>
            }</block></then>
          <else>else
            <block>{
              <if>if <condition>(<expr><name><name>t_entry</name>-&gt;<name>kind</name></name> == <name>svn_node_file</name>
                  &amp;&amp; <name>requested_depth</name> == <name>svn_depth_unknown</name>
                  &amp;&amp; <name>wc_depth</name> &lt; <name>svn_depth_files</name></expr>)</condition><then>
                <continue>continue;</continue></then></if>

              <if>if <condition>(<expr><name><name>t_entry</name>-&gt;<name>kind</name></name> == <name>svn_node_dir</name>
                  &amp;&amp; (<name>wc_depth</name> &lt; <name>svn_depth_immediates</name>
                      || <name>requested_depth</name> == <name>svn_depth_files</name>)</expr>)</condition><then>
                <continue>continue;</continue></then></if>

              <comment type="block">/* Look for an entry with the same name
                 in the source dirents. */</comment>
              <expr_stmt><expr><name>s_entry</name> = <name>s_entries</name> ?
                  <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>s_entries</name></expr></argument>, <argument><expr><name><name>t_entry</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call>
                  : <name>NULL</name></expr>;</expr_stmt>
              <expr_stmt><expr><name>s_fullpath</name> = <name>s_entry</name> ?
                  <call><name>svn_path_join</name><argument_list>(<argument><expr><name>s_path</name></expr></argument>, <argument><expr><name><name>t_entry</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call> : <name>NULL</name></expr>;</expr_stmt>
            }</block></else></if>

          <comment type="block">/* Compose the report, editor, and target paths for this entry. */</comment>
          <expr_stmt><expr><name>e_fullpath</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>e_path</name></expr></argument>, <argument><expr><name><name>t_entry</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>t_fullpath</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>t_path</name></expr></argument>, <argument><expr><name><name>t_entry</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>update_entry</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>s_rev</name></expr></argument>, <argument><expr><name>s_fullpath</name></expr></argument>, <argument><expr><name>s_entry</name></expr></argument>, <argument><expr><name>t_fullpath</name></expr></argument>,
                               <argument><expr><name>t_entry</name></expr></argument>, <argument><expr><name>dir_baton</name></expr></argument>, <argument><expr><name>e_fullpath</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                               <argument><expr><call><name>DEPTH_BELOW_HERE</name><argument_list>(<argument><expr><name>wc_depth</name></expr></argument>)</argument_list></call></expr></argument>,
                               <argument><expr><call><name>DEPTH_BELOW_HERE</name><argument_list>(<argument><expr><name>requested_depth</name></expr></argument>)</argument_list></call></expr></argument>,
                               <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>


      <comment type="block">/* Destroy iteration subpool. */</comment>
      <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>drive</name><parameter_list>(<param><decl><type><name>report_baton_t</name> *</type><name>b</name></decl></param>, <param><decl><type><name>svn_revnum_t</name></type> <name>s_rev</name></decl></param>, <param><decl><type><name>path_info_t</name> *</type><name>info</name></decl></param>,
      <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>t_anchor</name></decl>, *<decl><type ref="prev"/><name>s_fullpath</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>allowed</name></decl>, <decl><type ref="prev"/><name>info_is_set_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>s_root</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_dirent_t</name> *</type><name>s_entry</name></decl>, *<decl><type ref="prev"/><name>t_entry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> *</type><name>root_baton</name></decl>;</decl_stmt>

  <comment type="block">/* Compute the target path corresponding to the working copy anchor,
     and check its authorization. */</comment>
  <expr_stmt><expr><name>t_anchor</name> = *<name><name>b</name>-&gt;<name>s_operand</name></name> ? <call><name>svn_path_dirname</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>t_path</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call> : <name><name>b</name>-&gt;<name>t_path</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>check_auth</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr>&amp;<name>allowed</name></expr></argument>, <argument><expr><name>t_anchor</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<name>allowed</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name>
      <argument_list>(<argument><expr><name>SVN_ERR_AUTHZ_ROOT_UNREADABLE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Not authorized to open root of edit operation"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>b</name>-&gt;<name>editor</name>-&gt;<name>set_target_revision</name></name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>edit_baton</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>t_rev</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Collect information about the source and target nodes. */</comment>
  <expr_stmt><expr><name>s_fullpath</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>fs_base</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>s_operand</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_source_root</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr>&amp;<name>s_root</name></expr></argument>, <argument><expr><name>s_rev</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>fake_dirent</name><argument_list>(<argument><expr>&amp;<name>s_entry</name></expr></argument>, <argument><expr><name>s_root</name></expr></argument>, <argument><expr><name>s_fullpath</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>fake_dirent</name><argument_list>(<argument><expr>&amp;<name>t_entry</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>t_root</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>t_path</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If the operand is a locally added file or directory, it won't
     exist in the source, so accept that. */</comment>
  <expr_stmt><expr><name>info_is_set_path</name> = (<call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name><name>info</name>-&gt;<name>rev</name></name></expr></argument>)</argument_list></call> &amp;&amp; !<name><name>info</name>-&gt;<name>link_path</name></name>)</expr>;</expr_stmt>
  <if>if <condition>(<expr><name>info_is_set_path</name> &amp;&amp; !<name>s_entry</name></expr>)</condition><then>
    <expr_stmt><expr><name>s_fullpath</name> = <name>NULL</name></expr>;</expr_stmt></then></if>

  <comment type="block">/* Check if the target path exists first.  */</comment>
  <if>if <condition>(<expr>!*<name><name>b</name>-&gt;<name>s_operand</name></name> &amp;&amp; !(<name>t_entry</name>)</expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_FS_PATH_SYNTAX</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                            <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Target path does not exist"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then>

  <comment type="block">/* If the anchor is the operand, the source and target must be dirs.
     Check this before opening the root to avoid modifying the wc. */</comment>
  <else>else <if>if <condition>(<expr>!*<name><name>b</name>-&gt;<name>s_operand</name></name> &amp;&amp; (!<name>s_entry</name> || <name><name>s_entry</name>-&gt;<name>kind</name></name> != <name>svn_node_dir</name>
                              || <name><name>t_entry</name>-&gt;<name>kind</name></name> != <name>svn_node_dir</name>)</expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_FS_PATH_SYNTAX</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                            <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Cannot replace a directory from within"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if></else></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>b</name>-&gt;<name>editor</name>-&gt;<name>open_root</name></name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>edit_baton</name></name></expr></argument>, <argument><expr><name>s_rev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>&amp;<name>root_baton</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If the anchor is the operand, diff the two directories; otherwise
     update the operand within the anchor directory. */</comment>
  <if>if <condition>(<expr>!*<name><name>b</name>-&gt;<name>s_operand</name></name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>delta_dirs</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>s_rev</name></expr></argument>, <argument><expr><name>s_fullpath</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>t_path</name></name></expr></argument>, <argument><expr><name>root_baton</name></expr></argument>,
                       <argument><expr>""</expr></argument>, <argument><expr><name><name>info</name>-&gt;<name>start_empty</name></name></expr></argument>, <argument><expr><name><name>info</name>-&gt;<name>depth</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>requested_depth</name></name></expr></argument>,
                       <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>update_entry</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>s_rev</name></expr></argument>, <argument><expr><name>s_fullpath</name></expr></argument>, <argument><expr><name>s_entry</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>t_path</name></name></expr></argument>,
                         <argument><expr><name>t_entry</name></expr></argument>, <argument><expr><name>root_baton</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>s_operand</name></name></expr></argument>, <argument><expr><name>info</name></expr></argument>,
                         <argument><expr><name><name>info</name>-&gt;<name>depth</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>requested_depth</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>b</name>-&gt;<name>editor</name>-&gt;<name>close_directory</name></name><argument_list>(<argument><expr><name>root_baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>b</name>-&gt;<name>editor</name>-&gt;<name>close_edit</name></name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>edit_baton</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Initialize the baton fields for editor-driving, and drive the editor. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>finish_report</name><parameter_list>(<param><decl><type><name>report_baton_t</name> *</type><name>b</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_off_t</name></type> <name>offset</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>path_info_t</name> *</type><name>info</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>s_rev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <comment type="block">/* Save our pool to manage the lookahead and fs_root cache with. */</comment>
  <expr_stmt><expr><name><name>b</name>-&gt;<name>pool</name></name> = <name>pool</name></expr>;</expr_stmt>

  <comment type="block">/* Add an end marker and rewind the temporary file. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_write_full</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>tempfile</name></name></expr></argument>, <argument><expr>"-"</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>offset</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_seek</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>tempfile</name></name></expr></argument>, <argument><expr><name>APR_SET</name></expr></argument>, <argument><expr>&amp;<name>offset</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Read the first pathinfo from the report and verify that it is a top-level
     set_path entry. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>read_path_info</name><argument_list>(<argument><expr>&amp;<name>info</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>tempfile</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<name>info</name> || <call><name>strcmp</name><argument_list>(<argument><expr><name><name>info</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>s_operand</name></name></expr></argument>)</argument_list></call> != 0
      || <name><name>info</name>-&gt;<name>link_path</name></name> || !<call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name><name>info</name>-&gt;<name>rev</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_REPOS_BAD_REVISION_REPORT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                            <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Invalid report for top level of working copy"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
  <expr_stmt><expr><name>s_rev</name> = <name><name>info</name>-&gt;<name>rev</name></name></expr>;</expr_stmt>

  <comment type="block">/* Initialize the lookahead pathinfo. */</comment>
  <expr_stmt><expr><name>subpool</name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>read_path_info</name><argument_list>(<argument><expr>&amp;<name><name>b</name>-&gt;<name>lookahead</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>tempfile</name></name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name><name>b</name>-&gt;<name>lookahead</name></name> &amp;&amp; <call><name>strcmp</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>lookahead</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>s_operand</name></name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
    <block>{
      <comment type="block">/* If the operand of the wc operation is switched or deleted,
         then info above is just a place-holder, and the only thing we
         have to do is pass the revision it contains to open_root.
         The next pathinfo actually describes the target. */</comment>
      <if>if <condition>(<expr>!*<name><name>b</name>-&gt;<name>s_operand</name></name></expr>)</condition><then>
        <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_REPOS_BAD_REVISION_REPORT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Two top-level reports with no target"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
      <comment type="block">/* If the client issued a set-path followed by a delete-path, we need
         to respect the depth set by the initial set-path. */</comment>
      <if>if <condition>(<expr>! <call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>lookahead</name>-&gt;<name>rev</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name><name>b</name>-&gt;<name>lookahead</name>-&gt;<name>depth</name></name> = <name><name>info</name>-&gt;<name>depth</name></name></expr>;</expr_stmt>
        }</block></then></if>
      <expr_stmt><expr><name>info</name> = <name><name>b</name>-&gt;<name>lookahead</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>read_path_info</name><argument_list>(<argument><expr>&amp;<name><name>b</name>-&gt;<name>lookahead</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>tempfile</name></name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* Open the target root and initialize the source root cache. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_revision_root</name><argument_list>(<argument><expr>&amp;<name><name>b</name>-&gt;<name>t_root</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>repos</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>t_rev</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>NUM_CACHED_SOURCE_ROOTS</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <expr_stmt><expr><name><name>b</name>-&gt;<name>s_roots</name><index>[<expr><name>i</name></expr>]</index></name> = <name>NULL</name></expr>;</expr_stmt></for>

  <return>return <expr><call><name>drive</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>s_rev</name></expr></argument>, <argument><expr><name>info</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* --- COLLECTING THE REPORT INFORMATION --- */</comment>

<comment type="block">/* Record a report operation into the temporary file.  Return an error
   if DEPTH is svn_depth_unknown. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>write_path_info</name><parameter_list>(<param><decl><type><name>report_baton_t</name> *</type><name>b</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>lpath</name></decl></param>,
                <param><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl></param>, <param><decl><type><name>svn_depth_t</name></type> <name>depth</name></decl></param>,
                <param><decl><type><name>svn_boolean_t</name></type> <name>start_empty</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>lock_token</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>lrep</name></decl>, *<decl><type ref="prev"/><name>rrep</name></decl>, *<decl><type ref="prev"/><name>drep</name></decl>, *<decl><type ref="prev"/><name>ltrep</name></decl>, *<decl><type ref="prev"/><name>rep</name></decl>;</decl_stmt>

  <comment type="block">/* Munge the path to be anchor-relative, so that we can use edit paths
     as report paths. */</comment>
  <expr_stmt><expr><name>path</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>s_operand</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>lrep</name> = <name>lpath</name> ? <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"+%" <name>APR_SIZE_T_FMT</name> ":%s"</expr></argument>,
                              <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>lpath</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>lpath</name></expr></argument>)</argument_list></call> : "-"</expr>;</expr_stmt>
  <expr_stmt><expr><name>rrep</name> = (<call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name>rev</name></expr></argument>)</argument_list></call>) ?
    <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"+%ld:"</expr></argument>, <argument><expr><name>rev</name></expr></argument>)</argument_list></call> : "-"</expr>;</expr_stmt>

  <if>if <condition>(<expr><name>depth</name> == <name>svn_depth_exclude</name></expr>)</condition><then>
    <expr_stmt><expr><name>drep</name> = "+X"</expr>;</expr_stmt></then>
  <else>else <if>if <condition>(<expr><name>depth</name> == <name>svn_depth_empty</name></expr>)</condition><then>
    <expr_stmt><expr><name>drep</name> = "+E"</expr>;</expr_stmt></then>
  <else>else <if>if <condition>(<expr><name>depth</name> == <name>svn_depth_files</name></expr>)</condition><then>
    <expr_stmt><expr><name>drep</name> = "+F"</expr>;</expr_stmt></then>
  <else>else <if>if <condition>(<expr><name>depth</name> == <name>svn_depth_immediates</name></expr>)</condition><then>
    <expr_stmt><expr><name>drep</name> = "+M"</expr>;</expr_stmt></then>
  <else>else <if>if <condition>(<expr><name>depth</name> == <name>svn_depth_infinity</name></expr>)</condition><then>
    <expr_stmt><expr><name>drep</name> = "-"</expr>;</expr_stmt></then>
  <else>else
    <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_REPOS_BAD_ARGS</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Unsupported report depth '%s'"</expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><call><name>svn_depth_to_word</name><argument_list>(<argument><expr><name>depth</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></else></if></else></if></else></if></else></if></else></if>

  <expr_stmt><expr><name>ltrep</name> = <name>lock_token</name> ? <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"+%" <name>APR_SIZE_T_FMT</name> ":%s"</expr></argument>,
                                    <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>lock_token</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>lock_token</name></expr></argument>)</argument_list></call> : "-"</expr>;</expr_stmt>
  <expr_stmt><expr><name>rep</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"+%" <name>APR_SIZE_T_FMT</name> ":%s%s%s%s%c%s"</expr></argument>,
                     <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>lrep</name></expr></argument>, <argument><expr><name>rrep</name></expr></argument>, <argument><expr><name>drep</name></expr></argument>,
                     <argument><expr><name>start_empty</name> ? '+' : '-'</expr></argument>, <argument><expr><name>ltrep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>svn_io_file_write_full</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>tempfile</name></name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>rep</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_repos_set_path3</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl></param>,
                    <param><decl><type><name>svn_depth_t</name></type> <name>depth</name></decl></param>, <param><decl><type><name>svn_boolean_t</name></type> <name>start_empty</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>lock_token</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>write_path_info</name><argument_list>(<argument><expr><name>baton</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>start_empty</name></expr></argument>,
                         <argument><expr><name>lock_token</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_repos_set_path2</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl></param>,
                    <param><decl><type><name>svn_boolean_t</name></type> <name>start_empty</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>lock_token</name></decl></param>,
                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>svn_repos_set_path3</name><argument_list>(<argument><expr><name>baton</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name>svn_depth_infinity</name></expr></argument>,
                             <argument><expr><name>start_empty</name></expr></argument>, <argument><expr><name>lock_token</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_repos_set_path</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl></param>,
                   <param><decl><type><name>svn_boolean_t</name></type> <name>start_empty</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>svn_repos_set_path2</name><argument_list>(<argument><expr><name>baton</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name>start_empty</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_repos_link_path3</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>link_path</name></decl></param>,
                     <param><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl></param>, <param><decl><type><name>svn_depth_t</name></type> <name>depth</name></decl></param>,
                     <param><decl><type><name>svn_boolean_t</name></type> <name>start_empty</name></decl></param>,
                     <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>lock_token</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>depth</name> == <name>svn_depth_exclude</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_REPOS_BAD_ARGS</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                            <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Depth 'exclude' not supported for link"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <return>return <expr><call><name>write_path_info</name><argument_list>(<argument><expr><name>baton</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>link_path</name></expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>,
                         <argument><expr><name>start_empty</name></expr></argument>, <argument><expr><name>lock_token</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_repos_link_path2</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>link_path</name></decl></param>,
                     <param><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl></param>, <param><decl><type><name>svn_boolean_t</name></type> <name>start_empty</name></decl></param>,
                     <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>lock_token</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>svn_repos_link_path3</name><argument_list>(<argument><expr><name>baton</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>link_path</name></expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name>svn_depth_infinity</name></expr></argument>,
                              <argument><expr><name>start_empty</name></expr></argument>, <argument><expr><name>lock_token</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_repos_link_path</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>link_path</name></decl></param>,
                    <param><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl></param>, <param><decl><type><name>svn_boolean_t</name></type> <name>start_empty</name></decl></param>,
                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>svn_repos_link_path2</name><argument_list>(<argument><expr><name>baton</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>link_path</name></expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name>start_empty</name></expr></argument>,
                              <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_repos_delete_path</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* We pass svn_depth_infinity because deletion of a path always
     deletes everything underneath it. */</comment>
  <return>return <expr><call><name>write_path_info</name><argument_list>(<argument><expr><name>baton</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>SVN_INVALID_REVNUM</name></expr></argument>,
                         <argument><expr><name>svn_depth_infinity</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_repos_finish_report</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>report_baton_t</name> *</type><name>b</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>finish_err</name></decl>, *<decl><type ref="prev"/><name>close_err</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>finish_err</name> = <call><name>finish_report</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>close_err</name> = <call><name>svn_io_file_close</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>tempfile</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>finish_err</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>close_err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <return>return <expr><name>finish_err</name> ? <name>finish_err</name> : <name>close_err</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_repos_abort_report</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>report_baton_t</name> *</type><name>b</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>

  <return>return <expr><call><name>svn_io_file_close</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>tempfile</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* --- BEGINNING THE REPORT --- */</comment>


<function><type><name>svn_error_t</name> *</type>
<name>svn_repos_begin_report2</name><parameter_list>(<param><decl><type><name>void</name> **</type><name>report_baton</name></decl></param>,
                        <param><decl><type><name>svn_revnum_t</name></type> <name>revnum</name></decl></param>,
                        <param><decl><type><name>svn_repos_t</name> *</type><name>repos</name></decl></param>,
                        <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fs_base</name></decl></param>,
                        <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s_operand</name></decl></param>,
                        <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>switch_path</name></decl></param>,
                        <param><decl><type><name>svn_boolean_t</name></type> <name>text_deltas</name></decl></param>,
                        <param><decl><type><name>svn_depth_t</name></type> <name>depth</name></decl></param>,
                        <param><decl><type><name>svn_boolean_t</name></type> <name>ignore_ancestry</name></decl></param>,
                        <param><decl><type><name>svn_boolean_t</name></type> <name>send_copyfrom_args</name></decl></param>,
                        <param><decl><type><specifier>const</specifier> <name>svn_delta_editor_t</name> *</type><name>editor</name></decl></param>,
                        <param><decl><type><name>void</name> *</type><name>edit_baton</name></decl></param>,
                        <param><decl><type><name>svn_repos_authz_func_t</name></type> <name>authz_read_func</name></decl></param>,
                        <param><decl><type><name>void</name> *</type><name>authz_read_baton</name></decl></param>,
                        <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>report_baton_t</name> *</type><name>b</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>tempdir</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>depth</name> == <name>svn_depth_exclude</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_REPOS_BAD_ARGS</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                            <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Request depth 'exclude' not supported"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Build a reporter baton.  Copy strings in case the caller doesn't
     keep track of them. */</comment>
  <expr_stmt><expr><name>b</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>b</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>b</name>-&gt;<name>repos</name></name> = <name>repos</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>b</name>-&gt;<name>fs_base</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>fs_base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>b</name>-&gt;<name>s_operand</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>s_operand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>b</name>-&gt;<name>t_rev</name></name> = <name>revnum</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>b</name>-&gt;<name>t_path</name></name> = <name>switch_path</name> ? <name>switch_path</name>
    : <call><name>svn_path_join</name><argument_list>(<argument><expr><name>fs_base</name></expr></argument>, <argument><expr><name>s_operand</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>b</name>-&gt;<name>text_deltas</name></name> = <name>text_deltas</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>b</name>-&gt;<name>requested_depth</name></name> = <name>depth</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>b</name>-&gt;<name>ignore_ancestry</name></name> = <name>ignore_ancestry</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>b</name>-&gt;<name>send_copyfrom_args</name></name> = <name>send_copyfrom_args</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>b</name>-&gt;<name>is_switch</name></name> = (<name>switch_path</name> != <name>NULL</name>)</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>b</name>-&gt;<name>editor</name></name> = <name>editor</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>b</name>-&gt;<name>edit_baton</name></name> = <name>edit_baton</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>b</name>-&gt;<name>authz_read_func</name></name> = <name>authz_read_func</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>b</name>-&gt;<name>authz_read_baton</name></name> = <name>authz_read_baton</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_temp_dir</name><argument_list>(<argument><expr>&amp;<name>tempdir</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_open_unique_file2</name><argument_list>(<argument><expr>&amp;<name><name>b</name>-&gt;<name>tempfile</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                   <argument><expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%s/report"</expr></argument>, <argument><expr><name>tempdir</name></expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr>".tmp"</expr></argument>, <argument><expr><name>svn_io_file_del_on_close</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Hand reporter back to client. */</comment>
  <expr_stmt><expr>*<name>report_baton</name> = <name>b</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_repos_begin_report</name><parameter_list>(<param><decl><type><name>void</name> **</type><name>report_baton</name></decl></param>,
                       <param><decl><type><name>svn_revnum_t</name></type> <name>revnum</name></decl></param>,
                       <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>username</name></decl></param>,
                       <param><decl><type><name>svn_repos_t</name> *</type><name>repos</name></decl></param>,
                       <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fs_base</name></decl></param>,
                       <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s_operand</name></decl></param>,
                       <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>switch_path</name></decl></param>,
                       <param><decl><type><name>svn_boolean_t</name></type> <name>text_deltas</name></decl></param>,
                       <param><decl><type><name>svn_boolean_t</name></type> <name>recurse</name></decl></param>,
                       <param><decl><type><name>svn_boolean_t</name></type> <name>ignore_ancestry</name></decl></param>,
                       <param><decl><type><specifier>const</specifier> <name>svn_delta_editor_t</name> *</type><name>editor</name></decl></param>,
                       <param><decl><type><name>void</name> *</type><name>edit_baton</name></decl></param>,
                       <param><decl><type><name>svn_repos_authz_func_t</name></type> <name>authz_read_func</name></decl></param>,
                       <param><decl><type><name>void</name> *</type><name>authz_read_baton</name></decl></param>,
                       <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>svn_repos_begin_report2</name><argument_list>(<argument><expr><name>report_baton</name></expr></argument>,
                                 <argument><expr><name>revnum</name></expr></argument>,
                                 <argument><expr><name>repos</name></expr></argument>,
                                 <argument><expr><name>fs_base</name></expr></argument>,
                                 <argument><expr><name>s_operand</name></expr></argument>,
                                 <argument><expr><name>switch_path</name></expr></argument>,
                                 <argument><expr><name>text_deltas</name></expr></argument>,
                                 <argument><expr><call><name>SVN_DEPTH_INFINITY_OR_FILES</name><argument_list>(<argument><expr><name>recurse</name></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><name>ignore_ancestry</name></expr></argument>,
                                 <argument><expr><name>FALSE</name></expr></argument>, <comment type="block">/* don't send copyfrom args */</comment>
                                 <argument><expr><name>editor</name></expr></argument>,
                                 <argument><expr><name>edit_baton</name></expr></argument>,
                                 <argument><expr><name>authz_read_func</name></expr></argument>,
                                 <argument><expr><name>authz_read_baton</name></expr></argument>,
                                 <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
</unit>
