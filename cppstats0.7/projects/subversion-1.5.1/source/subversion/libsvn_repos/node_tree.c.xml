<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/subversion-1.5.1/source/subversion/libsvn_repos/node_tree.c"><comment type="block">/*
 * node_tree.c:  an editor for tracking repository deltas changes
 *
 * ====================================================================
 * Copyright (c) 2000-2004 CollabNet.  All rights reserved.
 *
 * This software is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at http://subversion.tigris.org/license-1.html.
 * If newer versions of this license are posted there, you may use a
 * newer version instead, at your option.
 *
 * This software consists of voluntary contributions made by many
 * individuals.  For exact contribution history, see the revision
 * history and logs, available at http://subversion.tigris.org/.
 * ====================================================================
 */</comment>

<comment type="block">/* ==================================================================== */</comment>



<escape char="0xc"/>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APR_WANT_STRFUNC</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_want.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_pools.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_types.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_error.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_path.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_delta.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_fs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_repos.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"repos.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_private_config.h"</cpp:file></cpp:include>

<comment type="block">/*** NOTE: This editor is unique in that it currently is hard-coded to
     be anchored at the root directory of the filesystem.  This
     affords us the ability to use the same paths for filesystem
     locations and editor paths.  ***/</comment>


<escape char="0xc"/>
<comment type="block">/*** Node creation and assembly structures and routines. ***/</comment>
<function><type><specifier>static</specifier> <name>svn_repos_node_t</name> *</type>
<name>create_node</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>,
            <param><decl><type><name>svn_repos_node_t</name> *</type><name>parent</name></decl></param>,
            <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_repos_node_t</name> *</type><name>node</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>node</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>node</name>-&gt;<name>action</name></name> = 'R'</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>node</name>-&gt;<name>kind</name></name> = <name>svn_node_unknown</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>node</name>-&gt;<name>name</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>node</name>-&gt;<name>parent</name></name> = <name>parent</name></expr>;</expr_stmt>
  <return>return <expr><name>node</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_repos_node_t</name> *</type>
<name>create_sibling_node</name><parameter_list>(<param><decl><type><name>svn_repos_node_t</name> *</type><name>elder</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>,
                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_repos_node_t</name> *</type><name>tmp_node</name></decl>;</decl_stmt>

  <comment type="block">/* No ELDER sibling?  That's just not gonna work out. */</comment>
  <if>if <condition>(<expr>! <name>elder</name></expr>)</condition><then>
    <return>return <expr><name>NULL</name></expr>;</return></then></if>

  <comment type="block">/* Run to the end of the list of siblings of ELDER. */</comment>
  <expr_stmt><expr><name>tmp_node</name> = <name>elder</name></expr>;</expr_stmt>
  <while>while <condition>(<expr><name><name>tmp_node</name>-&gt;<name>sibling</name></name></expr>)</condition>
    <expr_stmt><expr><name>tmp_node</name> = <name><name>tmp_node</name>-&gt;<name>sibling</name></name></expr>;</expr_stmt></while>

  <comment type="block">/* Create a new youngest sibling and return that. */</comment>
  <return>return <expr>(<name><name>tmp_node</name>-&gt;<name>sibling</name></name> = <call><name>create_node</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>elder</name>-&gt;<name>parent</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call>)</expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_repos_node_t</name> *</type>
<name>create_child_node</name><parameter_list>(<param><decl><type><name>svn_repos_node_t</name> *</type><name>parent</name></decl></param>,
                  <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>,
                  <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* No PARENT node?  That's just not gonna work out. */</comment>
  <if>if <condition>(<expr>! <name>parent</name></expr>)</condition><then>
    <return>return <expr><name>NULL</name></expr>;</return></then></if>

  <comment type="block">/* If PARENT has no children, create its first one and return that. */</comment>
  <if>if <condition>(<expr>! <name><name>parent</name>-&gt;<name>child</name></name></expr>)</condition><then>
    <return>return <expr>(<name><name>parent</name>-&gt;<name>child</name></name> = <call><name>create_node</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call>)</expr>;</return></then></if>

  <comment type="block">/* If PARENT already has a child, create a new sibling for its first
     child and return that. */</comment>
  <return>return <expr><call><name>create_sibling_node</name><argument_list>(<argument><expr><name><name>parent</name>-&gt;<name>child</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_repos_node_t</name> *</type>
<name>find_child_by_name</name><parameter_list>(<param><decl><type><name>svn_repos_node_t</name> *</type><name>parent</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_repos_node_t</name> *</type><name>tmp_node</name></decl>;</decl_stmt>

  <comment type="block">/* No PARENT node, or a barren PARENT?  Nothing to find. */</comment>
  <if>if <condition>(<expr>(! <name>parent</name>) || (! <name><name>parent</name>-&gt;<name>child</name></name>)</expr>)</condition><then>
    <return>return <expr><name>NULL</name></expr>;</return></then></if>

  <comment type="block">/* Look through the children for a node with a matching name. */</comment>
  <expr_stmt><expr><name>tmp_node</name> = <name><name>parent</name>-&gt;<name>child</name></name></expr>;</expr_stmt>
  <while>while <condition>(<expr>1</expr>)</condition>
    <block>{
      <if>if <condition>(<expr>! <call><name>strcmp</name><argument_list>(<argument><expr><name><name>tmp_node</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <return>return <expr><name>tmp_node</name></expr>;</return>
        }</block></then>
      <else>else
        <block>{
          <if>if <condition>(<expr><name><name>tmp_node</name>-&gt;<name>sibling</name></name></expr>)</condition><then>
            <expr_stmt><expr><name>tmp_node</name> = <name><name>tmp_node</name>-&gt;<name>sibling</name></name></expr>;</expr_stmt></then>
          <else>else
            <break>break;</break></else></if>
        }</block></else></if>
    }</block></while>

  <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>find_real_base_location</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>path_p</name></decl></param>,
                        <param><decl><type><name>svn_revnum_t</name> *</type><name>rev_p</name></decl></param>,
                        <param><decl><type><name>svn_repos_node_t</name> *</type><name>node</name></decl></param>,
                        <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* If NODE is an add-with-history, then its real base location is
     the copy source. */</comment>
  <if>if <condition>(<expr>(<name><name>node</name>-&gt;<name>action</name></name> == 'A')
      &amp;&amp; <name><name>node</name>-&gt;<name>copyfrom_path</name></name>
      &amp;&amp; <call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name><name>node</name>-&gt;<name>copyfrom_rev</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <expr_stmt><expr>*<name>path_p</name> = <name><name>node</name>-&gt;<name>copyfrom_path</name></name></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>rev_p</name> = <name><name>node</name>-&gt;<name>copyfrom_rev</name></name></expr>;</expr_stmt>
      <return>return;</return>
    }</block></then></if>

  <comment type="block">/* Otherwise, if NODE has a parent, we'll recurse, and add NODE's
     name to whatever the parent's real base path turns out to be (and
     pass the base revision on through). */</comment>
  <if>if <condition>(<expr><name><name>node</name>-&gt;<name>parent</name></name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>find_real_base_location</name><argument_list>(<argument><expr>&amp;<name>path</name></expr></argument>, <argument><expr>&amp;<name>rev</name></expr></argument>, <argument><expr><name><name>node</name>-&gt;<name>parent</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>path_p</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>node</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>rev_p</name> = <name>rev</name></expr>;</expr_stmt>
      <return>return;</return>
    }</block></then></if>

  <comment type="block">/* Finally, if the node has no parent, then its name is "/", and it
     has no interesting base revision.  */</comment>
  <expr_stmt><expr>*<name>path_p</name> = "/"</expr>;</expr_stmt>
  <expr_stmt><expr>*<name>rev_p</name> = <name>SVN_INVALID_REVNUM</name></expr>;</expr_stmt>
  <return>return;</return>
}</block></function>



<escape char="0xc"/>
<comment type="block">/*** Editor functions and batons. ***/</comment>

<struct>struct <name>edit_baton</name>
<block>{
  <decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>base_root</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>node_pool</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_repos_node_t</name> *</type><name>node</name></decl>;</decl_stmt>
}</block>;</struct>


<struct>struct <name>node_baton</name>
<block>{
  <decl_stmt><decl><type>struct <name>edit_baton</name> *</type><name>edit_baton</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>node_baton</name> *</type><name>parent_baton</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_repos_node_t</name> *</type><name>node</name></decl>;</decl_stmt>
}</block>;</struct>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>delete_entry</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
             <param><decl><type><name>svn_revnum_t</name></type> <name>revision</name></decl></param>,
             <param><decl><type><name>void</name> *</type><name>parent_baton</name></decl></param>,
             <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>node_baton</name> *</type><name>d</name> <init>= <expr><name>parent_baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>edit_baton</name> *</type><name>eb</name> <init>= <expr><name><name>d</name>-&gt;<name>edit_baton</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_repos_node_t</name> *</type><name>node</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>base_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>base_rev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>base_root</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>

  <comment type="block">/* Get (or create) the change node and update it. */</comment>
  <expr_stmt><expr><name>name</name> = <call><name>svn_path_basename</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>node</name> = <call><name>find_child_by_name</name><argument_list>(<argument><expr><name><name>d</name>-&gt;<name>node</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>! <name>node</name></expr>)</condition><then>
    <expr_stmt><expr><name>node</name> = <call><name>create_child_node</name><argument_list>(<argument><expr><name><name>d</name>-&gt;<name>node</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>eb</name>-&gt;<name>node_pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <expr_stmt><expr><name><name>node</name>-&gt;<name>action</name></name> = 'D'</expr>;</expr_stmt>

  <comment type="block">/* We need to look up this node's parents to see what its original
     path in the filesystem was.  Why?  Because if this deletion
     occurred underneath a copied path, the thing that was deleted
     probably lived at a different location (relative to the copy
     source). */</comment>
  <expr_stmt><expr><call><name>find_real_base_location</name><argument_list>(<argument><expr>&amp;<name>base_path</name></expr></argument>, <argument><expr>&amp;<name>base_rev</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>! <call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name>base_rev</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <comment type="block">/* No interesting base revision?  We'll just look for the path
         in our base root.  */</comment>
      <expr_stmt><expr><name>base_root</name> = <name><name>eb</name>-&gt;<name>base_root</name></name></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <comment type="block">/* Oh.  Perhaps some copy goodness happened somewhere? */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_revision_root</name><argument_list>(<argument><expr>&amp;<name>base_root</name></expr></argument>, <argument><expr><name><name>eb</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>base_rev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

  <comment type="block">/* Now figure out if this thing was a file or a dir. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_check_path</name><argument_list>(<argument><expr>&amp;<name>kind</name></expr></argument>, <argument><expr><name>base_root</name></expr></argument>, <argument><expr><name>base_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>kind</name> == <name>svn_node_none</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_FS_NOT_FOUND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><call><name>_</name><argument_list>(<argument><expr>"'%s' not found in filesystem"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
  <expr_stmt><expr><name><name>node</name>-&gt;<name>kind</name></name> = <name>kind</name></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>



<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>add_open_helper</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                <param><decl><type><name>char</name></type> <name>action</name></decl></param>,
                <param><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl></param>,
                <param><decl><type><name>void</name> *</type><name>parent_baton</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copyfrom_path</name></decl></param>,
                <param><decl><type><name>svn_revnum_t</name></type> <name>copyfrom_rev</name></decl></param>,
                <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                <param><decl><type><name>void</name> **</type><name>child_baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>node_baton</name> *</type><name>pb</name> <init>= <expr><name>parent_baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>edit_baton</name> *</type><name>eb</name> <init>= <expr><name><name>pb</name>-&gt;<name>edit_baton</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>node_baton</name> *</type><name>nb</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>nb</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>parent_baton</name> &amp;&amp; <name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>nb</name>-&gt;<name>edit_baton</name></name> = <name>eb</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>nb</name>-&gt;<name>parent_baton</name></name> = <name>pb</name></expr>;</expr_stmt>

  <comment type="block">/* Create and populate the node. */</comment>
  <expr_stmt><expr><name><name>nb</name>-&gt;<name>node</name></name> = <call><name>create_child_node</name><argument_list>(<argument><expr><name><name>pb</name>-&gt;<name>node</name></name></expr></argument>, <argument><expr><call><name>svn_path_basename</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                               <argument><expr><name><name>eb</name>-&gt;<name>node_pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>nb</name>-&gt;<name>node</name>-&gt;<name>kind</name></name> = <name>kind</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>nb</name>-&gt;<name>node</name>-&gt;<name>action</name></name> = <name>action</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>nb</name>-&gt;<name>node</name>-&gt;<name>copyfrom_rev</name></name> = <name>copyfrom_rev</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>nb</name>-&gt;<name>node</name>-&gt;<name>copyfrom_path</name></name> =
    <name>copyfrom_path</name> ? <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>eb</name>-&gt;<name>node_pool</name></name></expr></argument>, <argument><expr><name>copyfrom_path</name></expr></argument>)</argument_list></call> : <name>NULL</name></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>child_baton</name> = <name>nb</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>open_root</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>edit_baton</name></decl></param>,
          <param><decl><type><name>svn_revnum_t</name></type> <name>base_revision</name></decl></param>,
          <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
          <param><decl><type><name>void</name> **</type><name>root_baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>edit_baton</name> *</type><name>eb</name> <init>= <expr><name>edit_baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>node_baton</name> *</type><name>d</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>d</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>d</name>-&gt;<name>edit_baton</name></name> = <name>eb</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>d</name>-&gt;<name>parent_baton</name></name> = <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>d</name>-&gt;<name>node</name></name> = (<name><name>eb</name>-&gt;<name>node</name></name> = <call><name>create_node</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>eb</name>-&gt;<name>node_pool</name></name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>d</name>-&gt;<name>node</name>-&gt;<name>kind</name></name> = <name>svn_node_dir</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>d</name>-&gt;<name>node</name>-&gt;<name>action</name></name> = 'R'</expr>;</expr_stmt>
  <expr_stmt><expr>*<name>root_baton</name> = <name>d</name></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>open_directory</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
               <param><decl><type><name>void</name> *</type><name>parent_baton</name></decl></param>,
               <param><decl><type><name>svn_revnum_t</name></type> <name>base_revision</name></decl></param>,
               <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
               <param><decl><type><name>void</name> **</type><name>child_baton</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>add_open_helper</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>'R'</expr></argument>, <argument><expr><name>svn_node_dir</name></expr></argument>, <argument><expr><name>parent_baton</name></expr></argument>,
                          <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>SVN_INVALID_REVNUM</name></expr></argument>,
                          <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>child_baton</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>add_directory</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
              <param><decl><type><name>void</name> *</type><name>parent_baton</name></decl></param>,
              <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copyfrom_path</name></decl></param>,
              <param><decl><type><name>svn_revnum_t</name></type> <name>copyfrom_revision</name></decl></param>,
              <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
              <param><decl><type><name>void</name> **</type><name>child_baton</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>add_open_helper</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>'A'</expr></argument>, <argument><expr><name>svn_node_dir</name></expr></argument>, <argument><expr><name>parent_baton</name></expr></argument>,
                          <argument><expr><name>copyfrom_path</name></expr></argument>, <argument><expr><name>copyfrom_revision</name></expr></argument>,
                          <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>child_baton</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>open_file</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
          <param><decl><type><name>void</name> *</type><name>parent_baton</name></decl></param>,
          <param><decl><type><name>svn_revnum_t</name></type> <name>base_revision</name></decl></param>,
          <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
          <param><decl><type><name>void</name> **</type><name>file_baton</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>add_open_helper</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>'R'</expr></argument>, <argument><expr><name>svn_node_file</name></expr></argument>, <argument><expr><name>parent_baton</name></expr></argument>,
                          <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>SVN_INVALID_REVNUM</name></expr></argument>,
                          <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>file_baton</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>add_file</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
         <param><decl><type><name>void</name> *</type><name>parent_baton</name></decl></param>,
         <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copyfrom_path</name></decl></param>,
         <param><decl><type><name>svn_revnum_t</name></type> <name>copyfrom_revision</name></decl></param>,
         <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
         <param><decl><type><name>void</name> **</type><name>file_baton</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>add_open_helper</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>'A'</expr></argument>, <argument><expr><name>svn_node_file</name></expr></argument>, <argument><expr><name>parent_baton</name></expr></argument>,
                          <argument><expr><name>copyfrom_path</name></expr></argument>, <argument><expr><name>copyfrom_revision</name></expr></argument>,
                          <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>file_baton</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>apply_textdelta</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>file_baton</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>base_checksum</name></decl></param>,
                <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                <param><decl><type><name>svn_txdelta_window_handler_t</name> *</type><name>handler</name></decl></param>,
                <param><decl><type><name>void</name> **</type><name>handler_baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>node_baton</name> *</type><name>fb</name> <init>= <expr><name>file_baton</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>fb</name>-&gt;<name>node</name>-&gt;<name>text_mod</name></name> = <name>TRUE</name></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>handler</name> = <name>svn_delta_noop_window_handler</name></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>handler_baton</name> = <name>NULL</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>



<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>change_node_prop</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>node_baton</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>value</name></decl></param>,
                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>node_baton</name> *</type><name>nb</name> <init>= <expr><name>node_baton</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>nb</name>-&gt;<name>node</name>-&gt;<name>prop_mod</name></name> = <name>TRUE</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_repos_node_editor</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>svn_delta_editor_t</name> **</type><name>editor</name></decl></param>,
                      <param><decl><type><name>void</name> **</type><name>edit_baton</name></decl></param>,
                      <param><decl><type><name>svn_repos_t</name> *</type><name>repos</name></decl></param>,
                      <param><decl><type><name>svn_fs_root_t</name> *</type><name>base_root</name></decl></param>,
                      <param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
                      <param><decl><type><name>apr_pool_t</name> *</type><name>node_pool</name></decl></param>,
                      <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_delta_editor_t</name> *</type><name>my_editor</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>edit_baton</name> *</type><name>my_edit_baton</name></decl>;</decl_stmt>

  <comment type="block">/* Set up the editor. */</comment>
  <expr_stmt><expr><name>my_editor</name> = <call><name>svn_delta_default_editor</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>my_editor</name>-&gt;<name>open_root</name></name>           = <name>open_root</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>my_editor</name>-&gt;<name>delete_entry</name></name>        = <name>delete_entry</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>my_editor</name>-&gt;<name>add_directory</name></name>       = <name>add_directory</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>my_editor</name>-&gt;<name>open_directory</name></name>      = <name>open_directory</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>my_editor</name>-&gt;<name>add_file</name></name>            = <name>add_file</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>my_editor</name>-&gt;<name>open_file</name></name>           = <name>open_file</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>my_editor</name>-&gt;<name>apply_textdelta</name></name>     = <name>apply_textdelta</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>my_editor</name>-&gt;<name>change_file_prop</name></name>    = <name>change_node_prop</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>my_editor</name>-&gt;<name>change_dir_prop</name></name>     = <name>change_node_prop</name></expr>;</expr_stmt>

  <comment type="block">/* Set up the edit baton. */</comment>
  <expr_stmt><expr><name>my_edit_baton</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>my_edit_baton</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>my_edit_baton</name>-&gt;<name>node_pool</name></name> = <name>node_pool</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>my_edit_baton</name>-&gt;<name>fs</name></name> = <name><name>repos</name>-&gt;<name>fs</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>my_edit_baton</name>-&gt;<name>root</name></name> = <name>root</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>my_edit_baton</name>-&gt;<name>base_root</name></name> = <name>base_root</name></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>editor</name> = <name>my_editor</name></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>edit_baton</name> = <name>my_edit_baton</name></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>



<function><type><name>svn_repos_node_t</name> *</type>
<name>svn_repos_node_from_baton</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>edit_baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>edit_baton</name> *</type><name>eb</name> <init>= <expr><name>edit_baton</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><name><name>eb</name>-&gt;<name>node</name></name></expr>;</return>
}</block></function>
</unit>
