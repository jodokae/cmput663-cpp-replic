<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/subversion-1.5.1/source/subversion/libsvn_repos/authz.c"><comment type="block">/* authz.c : path-based access control
 *
 * ====================================================================
 * Copyright (c) 2000-2006 CollabNet.  All rights reserved.
 *
 * This software is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at http://subversion.tigris.org/license-1.html.
 * If newer versions of this license are posted there, you may use a
 * newer version instead, at your option.
 *
 * This software consists of voluntary contributions made by many
 * individuals.  For exact contribution history, see the revision
 * history and logs, available at http://subversion.tigris.org/.
 * ====================================================================
 */</comment>

<escape char="0xc"/>
<comment type="block">/*** Includes. ***/</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_pools.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_file_io.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_pools.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_error.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_path.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_repos.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_ctype.h"</cpp:file></cpp:include>

<escape char="0xc"/>
<comment type="block">/*** Structures. ***/</comment>

<comment type="block">/* Information for the config enumerators called during authz
   lookup. */</comment>
<struct>struct <name>authz_lookup_baton</name> <block>{
  <comment type="block">/* The authz configuration. */</comment>
  <decl_stmt><decl><type><name>svn_config_t</name> *</type><name>config</name></decl>;</decl_stmt>

  <comment type="block">/* The user to authorize. */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>user</name></decl>;</decl_stmt>

  <comment type="block">/* Explicitly granted rights. */</comment>
  <decl_stmt><decl><type><name>svn_repos_authz_access_t</name></type> <name>allow</name></decl>;</decl_stmt>
  <comment type="block">/* Explicitly denied rights. */</comment>
  <decl_stmt><decl><type><name>svn_repos_authz_access_t</name></type> <name>deny</name></decl>;</decl_stmt>

  <comment type="block">/* The rights required by the caller of the lookup. */</comment>
  <decl_stmt><decl><type><name>svn_repos_authz_access_t</name></type> <name>required_access</name></decl>;</decl_stmt>

  <comment type="block">/* The following are used exclusively in recursive lookups. */</comment>

  <comment type="block">/* The path in the repository to authorize. */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>repos_path</name></decl>;</decl_stmt>
  <comment type="block">/* repos_path prefixed by the repository name. */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>qualified_repos_path</name></decl>;</decl_stmt>

  <comment type="block">/* Whether, at the end of a recursive lookup, access is granted. */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>access</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/* Information for the config enumeration functions called during the
   validation process. */</comment>
<struct>struct <name>authz_validate_baton</name> <block>{
  <decl_stmt><decl><type><name>svn_config_t</name> *</type><name>config</name></decl>;</decl_stmt> <comment type="block">/* The configuration file being validated. */</comment>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>     <comment type="block">/* The error being thrown out of the
                           enumerator, if any. */</comment>
}</block>;</struct>

<comment type="block">/* Currently this structure is just a wrapper around a
   svn_config_t. */</comment>
<struct>struct <name>svn_authz_t</name>
<block>{
  <decl_stmt><decl><type><name>svn_config_t</name> *</type><name>cfg</name></decl>;</decl_stmt>
}</block>;</struct>


<escape char="0xc"/>
<comment type="block">/*** Checking access. ***/</comment>

<comment type="block">/* Determine whether the REQUIRED access is granted given what authz
 * to ALLOW or DENY.  Return TRUE if the REQUIRED access is
 * granted.
 *
 * Access is granted either when no required access is explicitly
 * denied (implicit grant), or when the required access is explicitly
 * granted, overriding any denials.
 */</comment>
<function><type><specifier>static</specifier> <name>svn_boolean_t</name></type>
<name>authz_access_is_granted</name><parameter_list>(<param><decl><type><name>svn_repos_authz_access_t</name></type> <name>allow</name></decl></param>,
                        <param><decl><type><name>svn_repos_authz_access_t</name></type> <name>deny</name></decl></param>,
                        <param><decl><type><name>svn_repos_authz_access_t</name></type> <name>required</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_repos_authz_access_t</name></type> <name>stripped_req</name> <init>=
    <expr><name>required</name> &amp; (<name>svn_authz_read</name> | <name>svn_authz_write</name>)</expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr>(<name>deny</name> &amp; <name>required</name>) == <name>svn_authz_none</name></expr>)</condition><then>
    <return>return <expr><name>TRUE</name></expr>;</return></then>
  <else>else <if>if <condition>(<expr>(<name>allow</name> &amp; <name>required</name>) == <name>stripped_req</name></expr>)</condition><then>
    <return>return <expr><name>TRUE</name></expr>;</return></then>
  <else>else
    <return>return <expr><name>FALSE</name></expr>;</return></else></if></else></if>
}</block></function>


<comment type="block">/* Decide whether the REQUIRED access has been conclusively
 * determined.  Return TRUE if the given ALLOW/DENY authz are
 * conclusive regarding the REQUIRED authz.
 *
 * Conclusive determination occurs when any of the REQUIRED authz are
 * granted or denied by ALLOW/DENY.
 */</comment>
<function><type><specifier>static</specifier> <name>svn_boolean_t</name></type>
<name>authz_access_is_determined</name><parameter_list>(<param><decl><type><name>svn_repos_authz_access_t</name></type> <name>allow</name></decl></param>,
                           <param><decl><type><name>svn_repos_authz_access_t</name></type> <name>deny</name></decl></param>,
                           <param><decl><type><name>svn_repos_authz_access_t</name></type> <name>required</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>(<name>deny</name> &amp; <name>required</name>) || (<name>allow</name> &amp; <name>required</name>)</expr>)</condition><then>
    <return>return <expr><name>TRUE</name></expr>;</return></then>
  <else>else
    <return>return <expr><name>FALSE</name></expr>;</return></else></if>
}</block></function>

<comment type="block">/* Return TRUE is USER equals ALIAS. The alias definitions are in the
   "aliases" sections of CFG. Use POOL for temporary allocations during
   the lookup. */</comment>
<function><type><specifier>static</specifier> <name>svn_boolean_t</name></type>
<name>authz_alias_is_user</name><parameter_list>(<param><decl><type><name>svn_config_t</name> *</type><name>cfg</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>alias</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>user</name></decl></param>,
                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>value</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>svn_config_get</name><argument_list>(<argument><expr><name>cfg</name></expr></argument>, <argument><expr>&amp;<name>value</name></expr></argument>, <argument><expr>"aliases"</expr></argument>, <argument><expr><name>alias</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<name>value</name></expr>)</condition><then>
    <return>return <expr><name>FALSE</name></expr>;</return></then></if>

  <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>user</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
    <return>return <expr><name>TRUE</name></expr>;</return></then></if>

  <return>return <expr><name>FALSE</name></expr>;</return>
}</block></function>


<comment type="block">/* Return TRUE if USER is in GROUP.  The group definitions are in the
   "groups" section of CFG.  Use POOL for temporary allocations during
   the lookup. */</comment>
<function><type><specifier>static</specifier> <name>svn_boolean_t</name></type>
<name>authz_group_contains_user</name><parameter_list>(<param><decl><type><name>svn_config_t</name> *</type><name>cfg</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>group</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>user</name></decl></param>,
                          <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>value</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>list</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>svn_config_get</name><argument_list>(<argument><expr><name>cfg</name></expr></argument>, <argument><expr>&amp;<name>value</name></expr></argument>, <argument><expr>"groups"</expr></argument>, <argument><expr><name>group</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>list</name> = <call><name>svn_cstring_split</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr>","</expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>list</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>group_user</name> <init>= <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>char</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <comment type="block">/* If the 'user' is a subgroup, recurse into it. */</comment>
      <if>if <condition>(<expr>*<name>group_user</name> == '@'</expr>)</condition><then>
        <block>{
          <if>if <condition>(<expr><call><name>authz_group_contains_user</name><argument_list>(<argument><expr><name>cfg</name></expr></argument>, <argument><expr>&amp;<name><name>group_user</name><index>[<expr>1</expr>]</index></name></expr></argument>,
                                        <argument><expr><name>user</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>TRUE</name></expr>;</return></then></if>
        }</block></then>

      <comment type="block">/* If the 'user' is an alias, verify it. */</comment>
      <else>else <if>if <condition>(<expr>*<name>group_user</name> == '&amp;'</expr>)</condition><then>
        <block>{
          <if>if <condition>(<expr><call><name>authz_alias_is_user</name><argument_list>(<argument><expr><name>cfg</name></expr></argument>, <argument><expr>&amp;<name><name>group_user</name><index>[<expr>1</expr>]</index></name></expr></argument>,
                                  <argument><expr><name>user</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><name>TRUE</name></expr>;</return></then></if>
        }</block></then>

      <comment type="block">/* If the user matches, stop. */</comment>
      <else>else <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>user</name></expr></argument>, <argument><expr><name>group_user</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
        <return>return <expr><name>TRUE</name></expr>;</return></then></if></else></if></else></if>
    }</block></for>

  <return>return <expr><name>FALSE</name></expr>;</return>
}</block></function>


<comment type="block">/* Determines whether an authz rule applies to the current
 * user, given the name part of the rule's name-value pair
 * in RULE_MATCH_STRING and the authz_lookup_baton object
 * B with the username in question.
 */</comment>
<function><type><specifier>static</specifier> <name>svn_boolean_t</name></type>
<name>authz_line_applies_to_user</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>rule_match_string</name></decl></param>,
                           <param><decl><type>struct <name>authz_lookup_baton</name> *</type><name>b</name></decl></param>,
                           <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* If the rule has an inversion, recurse and invert the result. */</comment>
  <if>if <condition>(<expr><name><name>rule_match_string</name><index>[<expr>0</expr>]</index></name> == '~'</expr>)</condition><then>
    <return>return <expr>!<call><name>authz_line_applies_to_user</name><argument_list>(<argument><expr>&amp;<name><name>rule_match_string</name><index>[<expr>1</expr>]</index></name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Check for special tokens. */</comment>
  <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>rule_match_string</name></expr></argument>, <argument><expr>"$anonymous"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
    <return>return <expr>(<name><name>b</name>-&gt;<name>user</name></name> == <name>NULL</name>)</expr>;</return></then></if>
  <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>rule_match_string</name></expr></argument>, <argument><expr>"$authenticated"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
    <return>return <expr>(<name><name>b</name>-&gt;<name>user</name></name> != <name>NULL</name>)</expr>;</return></then></if>

  <comment type="block">/* Check for a wildcard rule. */</comment>
  <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>rule_match_string</name></expr></argument>, <argument><expr>"*"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
    <return>return <expr><name>TRUE</name></expr>;</return></then></if>

  <comment type="block">/* If we get here, then the rule is:
   *  - Not an inversion rule.
   *  - Not an authz token rule.
   *  - Not a wildcard rule.
   *
   * All that's left over is regular user or group specifications.
   */</comment>

  <comment type="block">/* If the session is anonymous, then a user/group
   * rule definitely won't match.
   */</comment>
  <if>if <condition>(<expr><name><name>b</name>-&gt;<name>user</name></name> == <name>NULL</name></expr>)</condition><then>
    <return>return <expr><name>FALSE</name></expr>;</return></then></if>

  <comment type="block">/* Process the rule depending on whether it is
   * a user, alias or group rule.
   */</comment>
  <if>if <condition>(<expr><name><name>rule_match_string</name><index>[<expr>0</expr>]</index></name> == '@'</expr>)</condition><then>
    <return>return <expr><call><name>authz_group_contains_user</name><argument_list>(
      <argument><expr><name><name>b</name>-&gt;<name>config</name></name></expr></argument>, <argument><expr>&amp;<name><name>rule_match_string</name><index>[<expr>1</expr>]</index></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>user</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return></then>
  <else>else <if>if <condition>(<expr><name><name>rule_match_string</name><index>[<expr>0</expr>]</index></name> == '&amp;'</expr>)</condition><then>
    <return>return <expr><call><name>authz_alias_is_user</name><argument_list>(
      <argument><expr><name><name>b</name>-&gt;<name>config</name></name></expr></argument>, <argument><expr>&amp;<name><name>rule_match_string</name><index>[<expr>1</expr>]</index></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>user</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return></then>
  <else>else
    <return>return <expr>(<call><name>strcmp</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>user</name></name></expr></argument>, <argument><expr><name>rule_match_string</name></expr></argument>)</argument_list></call> == 0)</expr>;</return></else></if></else></if>
}</block></function>


<comment type="block">/* Callback to parse one line of an authz file and update the
 * authz_baton accordingly.
 */</comment>
<function><type><specifier>static</specifier> <name>svn_boolean_t</name></type>
<name>authz_parse_line</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>value</name></decl></param>,
                 <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>authz_lookup_baton</name> *</type><name>b</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Stop if the rule doesn't apply to this user. */</comment>
  <if>if <condition>(<expr>!<call><name>authz_line_applies_to_user</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>TRUE</name></expr>;</return></then></if>

  <comment type="block">/* Set the access grants for the rule. */</comment>
  <if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr>'r'</expr></argument>)</argument_list></call></expr>)</condition><then>
    <expr_stmt><expr><name><name>b</name>-&gt;<name>allow</name></name> |= <name>svn_authz_read</name></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name><name>b</name>-&gt;<name>deny</name></name> |= <name>svn_authz_read</name></expr>;</expr_stmt></else></if>

  <if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr>'w'</expr></argument>)</argument_list></call></expr>)</condition><then>
    <expr_stmt><expr><name><name>b</name>-&gt;<name>allow</name></name> |= <name>svn_authz_write</name></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name><name>b</name>-&gt;<name>deny</name></name> |= <name>svn_authz_write</name></expr>;</expr_stmt></else></if>

  <return>return <expr><name>TRUE</name></expr>;</return>
}</block></function>


<comment type="block">/* Callback to parse a section and update the authz_baton if the
 * section denies access to the subtree the baton describes.
 */</comment>
<function><type><specifier>static</specifier> <name>svn_boolean_t</name></type>
<name>authz_parse_section</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>section_name</name></decl></param>, <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>authz_lookup_baton</name> *</type><name>b</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>conclusive</name></decl>;</decl_stmt>

  <comment type="block">/* Does the section apply to us? */</comment>
  <if>if <condition>(<expr><call><name>svn_path_is_ancestor</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>qualified_repos_path</name></name></expr></argument>,
                           <argument><expr><name>section_name</name></expr></argument>)</argument_list></call> == <name>FALSE</name>
      &amp;&amp; <call><name>svn_path_is_ancestor</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>repos_path</name></name></expr></argument>,
                              <argument><expr><name>section_name</name></expr></argument>)</argument_list></call> == <name>FALSE</name></expr>)</condition><then>
    <return>return <expr><name>TRUE</name></expr>;</return></then></if>

  <comment type="block">/* Work out what this section grants. */</comment>
  <expr_stmt><expr><name><name>b</name>-&gt;<name>allow</name></name> = <name><name>b</name>-&gt;<name>deny</name></name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_config_enumerate2</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>config</name></name></expr></argument>, <argument><expr><name>section_name</name></expr></argument>,
                        <argument><expr><name>authz_parse_line</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Has the section explicitly determined an access? */</comment>
  <expr_stmt><expr><name>conclusive</name> = <call><name>authz_access_is_determined</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>allow</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>deny</name></name></expr></argument>,
                                          <argument><expr><name><name>b</name>-&gt;<name>required_access</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Is access granted OR inconclusive? */</comment>
  <expr_stmt><expr><name><name>b</name>-&gt;<name>access</name></name> = <call><name>authz_access_is_granted</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>allow</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>deny</name></name></expr></argument>,
                                      <argument><expr><name><name>b</name>-&gt;<name>required_access</name></name></expr></argument>)</argument_list></call>
    || !<name>conclusive</name></expr>;</expr_stmt>

  <comment type="block">/* As long as access isn't conclusively denied, carry on. */</comment>
  <return>return <expr><name><name>b</name>-&gt;<name>access</name></name></expr>;</return>
}</block></function>


<comment type="block">/* Validate access to the given user for the given path.  This
 * function checks rules for exactly the given path, and first tries
 * to access a section specific to the given repository before falling
 * back to pan-repository rules.
 *
 * Update *access_granted to inform the caller of the outcome of the
 * lookup.  Return a boolean indicating whether the access rights were
 * successfully determined.
 */</comment>
<function><type><specifier>static</specifier> <name>svn_boolean_t</name></type>
<name>authz_get_path_access</name><parameter_list>(<param><decl><type><name>svn_config_t</name> *</type><name>cfg</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>repos_name</name></decl></param>,
                      <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>user</name></decl></param>,
                      <param><decl><type><name>svn_repos_authz_access_t</name></type> <name>required_access</name></decl></param>,
                      <param><decl><type><name>svn_boolean_t</name> *</type><name>access_granted</name></decl></param>,
                      <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>qualified_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>authz_lookup_baton</name></type> <name>baton</name> <init>= <expr><block>{ <expr>0</expr> }</block></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>baton</name>.<name>config</name></name> = <name>cfg</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>baton</name>.<name>user</name></name> = <name>user</name></expr>;</expr_stmt>

  <comment type="block">/* Try to locate a repository-specific block first. */</comment>
  <expr_stmt><expr><name>qualified_path</name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>repos_name</name></expr></argument>, <argument><expr>":"</expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_config_enumerate2</name><argument_list>(<argument><expr><name>cfg</name></expr></argument>, <argument><expr><name>qualified_path</name></expr></argument>,
                        <argument><expr><name>authz_parse_line</name></expr></argument>, <argument><expr>&amp;<name>baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>access_granted</name> = <call><name>authz_access_is_granted</name><argument_list>(<argument><expr><name><name>baton</name>.<name>allow</name></name></expr></argument>, <argument><expr><name><name>baton</name>.<name>deny</name></name></expr></argument>,
                                            <argument><expr><name>required_access</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If the first test has determined access, stop now. */</comment>
  <if>if <condition>(<expr><call><name>authz_access_is_determined</name><argument_list>(<argument><expr><name><name>baton</name>.<name>allow</name></name></expr></argument>, <argument><expr><name><name>baton</name>.<name>deny</name></name></expr></argument>,
                                 <argument><expr><name>required_access</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>TRUE</name></expr>;</return></then></if>

  <comment type="block">/* No repository specific rule, try pan-repository rules. */</comment>
  <expr_stmt><expr><call><name>svn_config_enumerate2</name><argument_list>(<argument><expr><name>cfg</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>authz_parse_line</name></expr></argument>, <argument><expr>&amp;<name>baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>access_granted</name> = <call><name>authz_access_is_granted</name><argument_list>(<argument><expr><name><name>baton</name>.<name>allow</name></name></expr></argument>, <argument><expr><name><name>baton</name>.<name>deny</name></name></expr></argument>,
                                            <argument><expr><name>required_access</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>authz_access_is_determined</name><argument_list>(<argument><expr><name><name>baton</name>.<name>allow</name></name></expr></argument>, <argument><expr><name><name>baton</name>.<name>deny</name></name></expr></argument>,
                                    <argument><expr><name>required_access</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<comment type="block">/* Validate access to the given user for the subtree starting at the
 * given path.  This function walks the whole authz file in search of
 * rules applying to paths in the requested subtree which deny the
 * requested access.
 *
 * As soon as one is found, or else when the whole ACL file has been
 * searched, return the updated authorization status.
 */</comment>
<function><type><specifier>static</specifier> <name>svn_boolean_t</name></type>
<name>authz_get_tree_access</name><parameter_list>(<param><decl><type><name>svn_config_t</name> *</type><name>cfg</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>repos_name</name></decl></param>,
                      <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>user</name></decl></param>,
                      <param><decl><type><name>svn_repos_authz_access_t</name></type> <name>required_access</name></decl></param>,
                      <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>authz_lookup_baton</name></type> <name>baton</name> <init>= <expr><block>{ <expr>0</expr> }</block></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>baton</name>.<name>config</name></name> = <name>cfg</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>baton</name>.<name>user</name></name> = <name>user</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>baton</name>.<name>required_access</name></name> = <name>required_access</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>baton</name>.<name>repos_path</name></name> = <name>path</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>baton</name>.<name>qualified_repos_path</name></name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>repos_name</name></expr></argument>,
                                           <argument><expr>":"</expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* Default to access granted if no rules say otherwise. */</comment>
  <expr_stmt><expr><name><name>baton</name>.<name>access</name></name> = <name>TRUE</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>svn_config_enumerate_sections2</name><argument_list>(<argument><expr><name>cfg</name></expr></argument>, <argument><expr><name>authz_parse_section</name></expr></argument>,
                                 <argument><expr>&amp;<name>baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name><name>baton</name>.<name>access</name></name></expr>;</return>
}</block></function>


<comment type="block">/* Callback to parse sections of the configuration file, looking for
   any kind of granted access.  Implements the
   svn_config_section_enumerator2_t interface. */</comment>
<function><type><specifier>static</specifier> <name>svn_boolean_t</name></type>
<name>authz_global_parse_section</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>section_name</name></decl></param>, <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>,
                           <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>authz_lookup_baton</name> *</type><name>b</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Does the section apply to the query? */</comment>
  <if>if <condition>(<expr><name><name>section_name</name><index>[<expr>0</expr>]</index></name> == '/'
      || <call><name>strncmp</name><argument_list>(<argument><expr><name>section_name</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>repos_path</name></name></expr></argument>,
                 <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>repos_path</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name><name>b</name>-&gt;<name>allow</name></name> = <name><name>b</name>-&gt;<name>deny</name></name> = <name>svn_authz_none</name></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>svn_config_enumerate2</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>config</name></name></expr></argument>, <argument><expr><name>section_name</name></expr></argument>,
                            <argument><expr><name>authz_parse_line</name></expr></argument>, <argument><expr><name>baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>b</name>-&gt;<name>access</name></name> = <call><name>authz_access_is_granted</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>allow</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>deny</name></name></expr></argument>,
                                          <argument><expr><name><name>b</name>-&gt;<name>required_access</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Continue as long as we don't find a determined, granted access. */</comment>
      <return>return <expr>!(<name><name>b</name>-&gt;<name>access</name></name>
               &amp;&amp; <call><name>authz_access_is_determined</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>allow</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>deny</name></name></expr></argument>,
                                             <argument><expr><name><name>b</name>-&gt;<name>required_access</name></name></expr></argument>)</argument_list></call>)</expr>;</return>
    }</block></then></if>

  <return>return <expr><name>TRUE</name></expr>;</return>
}</block></function>


<comment type="block">/* Walk through the authz CFG to check if USER has the REQUIRED_ACCESS
 * to any path within the REPOSITORY.  Return TRUE if so.  Use POOL
 * for temporary allocations. */</comment>
<function><type><specifier>static</specifier> <name>svn_boolean_t</name></type>
<name>authz_get_global_access</name><parameter_list>(<param><decl><type><name>svn_config_t</name> *</type><name>cfg</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>repos_name</name></decl></param>,
                        <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>user</name></decl></param>,
                        <param><decl><type><name>svn_repos_authz_access_t</name></type> <name>required_access</name></decl></param>,
                        <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>authz_lookup_baton</name></type> <name>baton</name> <init>= <expr><block>{ <expr>0</expr> }</block></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>baton</name>.<name>config</name></name> = <name>cfg</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>baton</name>.<name>user</name></name> = <name>user</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>baton</name>.<name>required_access</name></name> = <name>required_access</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>baton</name>.<name>access</name></name> = <name>FALSE</name></expr>;</expr_stmt> <comment type="block">/* Deny access by default. */</comment>
  <expr_stmt><expr><name><name>baton</name>.<name>repos_path</name></name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>repos_name</name></expr></argument>, <argument><expr>":/"</expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>svn_config_enumerate_sections2</name><argument_list>(<argument><expr><name>cfg</name></expr></argument>, <argument><expr><name>authz_global_parse_section</name></expr></argument>,
                                 <argument><expr>&amp;<name>baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If walking the configuration was inconclusive, deny access. */</comment>
  <if>if <condition>(<expr>!<call><name>authz_access_is_determined</name><argument_list>(<argument><expr><name><name>baton</name>.<name>allow</name></name></expr></argument>,
                                  <argument><expr><name><name>baton</name>.<name>deny</name></name></expr></argument>, <argument><expr><name><name>baton</name>.<name>required_access</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>FALSE</name></expr>;</return></then></if>

  <return>return <expr><name><name>baton</name>.<name>access</name></name></expr>;</return>
}</block></function>


<escape char="0xc"/>
<comment type="block">/*** Validating the authz file. ***/</comment>

<comment type="block">/* Check for errors in GROUP's definition of CFG.  The errors
 * detected are references to non-existent groups and circular
 * dependencies between groups.  If an error is found, return
 * SVN_ERR_AUTHZ_INVALID_CONFIG.  Use POOL for temporary
 * allocations only.
 *
 * CHECKED_GROUPS should be an empty (it is used for recursive calls).
 */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>authz_group_walk</name><parameter_list>(<param><decl><type><name>svn_config_t</name> *</type><name>cfg</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>group</name></decl></param>,
                 <param><decl><type><name>apr_hash_t</name> *</type><name>checked_groups</name></decl></param>,
                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>value</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>list</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>svn_config_get</name><argument_list>(<argument><expr><name>cfg</name></expr></argument>, <argument><expr>&amp;<name>value</name></expr></argument>, <argument><expr>"groups"</expr></argument>, <argument><expr><name>group</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* Having a non-existent group in the ACL configuration might be the
     sign of a typo.  Refuse to perform authz on uncertain rules. */</comment>
  <if>if <condition>(<expr>!<name>value</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_AUTHZ_INVALID_CONFIG</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr>"An authz rule refers to group '%s', "
                             "which is undefined"</expr></argument>,
                             <argument><expr><name>group</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><name>list</name> = <call><name>svn_cstring_split</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr>","</expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>list</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>group_user</name> <init>= <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>char</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <comment type="block">/* If the 'user' is a subgroup, recurse into it. */</comment>
      <if>if <condition>(<expr>*<name>group_user</name> == '@'</expr>)</condition><then>
        <block>{
          <comment type="block">/* A circular dependency between groups is a Bad Thing.  We
             don't do authz with invalid ACL files. */</comment>
          <if>if <condition>(<expr><call><name>apr_hash_get</name><argument_list>(<argument><expr><name>checked_groups</name></expr></argument>, <argument><expr>&amp;<name><name>group_user</name><index>[<expr>1</expr>]</index></name></expr></argument>,
                           <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_AUTHZ_INVALID_CONFIG</name></expr></argument>,
                                     <argument><expr><name>NULL</name></expr></argument>,
                                     <argument><expr>"Circular dependency between "
                                     "groups '%s' and '%s'"</expr></argument>,
                                     <argument><expr>&amp;<name><name>group_user</name><index>[<expr>1</expr>]</index></name></expr></argument>, <argument><expr><name>group</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

          <comment type="block">/* Add group to hash of checked groups. */</comment>
          <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>checked_groups</name></expr></argument>, <argument><expr>&amp;<name><name>group_user</name><index>[<expr>1</expr>]</index></name></expr></argument>,
                       <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Recurse on that group. */</comment>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>authz_group_walk</name><argument_list>(<argument><expr><name>cfg</name></expr></argument>, <argument><expr>&amp;<name><name>group_user</name><index>[<expr>1</expr>]</index></name></expr></argument>,
                                   <argument><expr><name>checked_groups</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Remove group from hash of checked groups, so that we don't
             incorrectly report an error if we see it again as part of
             another group. */</comment>
          <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>checked_groups</name></expr></argument>, <argument><expr>&amp;<name><name>group_user</name><index>[<expr>1</expr>]</index></name></expr></argument>,
                       <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
      <else>else <if>if <condition>(<expr>*<name>group_user</name> == '&amp;'</expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>alias</name></decl>;</decl_stmt>

          <expr_stmt><expr><call><name>svn_config_get</name><argument_list>(<argument><expr><name>cfg</name></expr></argument>, <argument><expr>&amp;<name>alias</name></expr></argument>, <argument><expr>"aliases"</expr></argument>, <argument><expr>&amp;<name><name>group_user</name><index>[<expr>1</expr>]</index></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <comment type="block">/* Having a non-existent alias in the ACL configuration might be the
             sign of a typo.  Refuse to perform authz on uncertain rules. */</comment>
          <if>if <condition>(<expr>!<name>alias</name></expr>)</condition><then>
            <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_AUTHZ_INVALID_CONFIG</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                     <argument><expr>"An authz rule refers to alias '%s', "
                                     "which is undefined"</expr></argument>,
                                     <argument><expr>&amp;<name><name>group_user</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return></then></if>
        }</block></then></if></else></if>
    }</block></for>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Callback to perform some simple sanity checks on an authz rule.
 *
 * - If RULE_MATCH_STRING references a group or an alias, verify that
 *   the group or alias definition exists.
 * - If RULE_MATCH_STRING specifies a token (starts with $), verify
 *   that the token name is valid.
 * - If RULE_MATCH_STRING is using inversion, verify that it isn't
 *   doing it more than once within the one rule, and that it isn't
 *   "~*", as that would never match.
 * - Check that VALUE part of the rule specifies only allowed rule
 *   flag characters ('r' and 'w').
 *
 * Return TRUE if the rule has no errors. Use BATON for context and
 * error reporting.
 */</comment>
<function><type><specifier>static</specifier> <name>svn_boolean_t</name></type> <name>authz_validate_rule</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>rule_match_string</name></decl></param>,
                                         <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>value</name></decl></param>,
                                         <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>,
                                         <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>val</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>match</name> <init>= <expr><name>rule_match_string</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>authz_validate_baton</name> *</type><name>b</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Make sure the user isn't using double-negatives. */</comment>
  <if>if <condition>(<expr><name><name>match</name><index>[<expr>0</expr>]</index></name> == '~'</expr>)</condition><then>
    <block>{
      <comment type="block">/* Bump the pointer past the inversion for the other checks. */</comment>
      <expr_stmt><expr><name>match</name>++</expr>;</expr_stmt>

      <comment type="block">/* Another inversion is a double negative; we can't not stop. */</comment>
      <if>if <condition>(<expr><name><name>match</name><index>[<expr>0</expr>]</index></name> == '~'</expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name><name>b</name>-&gt;<name>err</name></name> = <call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_AUTHZ_INVALID_CONFIG</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                     <argument><expr>"Rule '%s' has more than one "
                                     "inversion; double negatives are "
                                     "not permitted."</expr></argument>,
                                     <argument><expr><name>rule_match_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>FALSE</name></expr>;</return>
        }</block></then></if>

      <comment type="block">/* Make sure that the rule isn't "~*", which won't ever match. */</comment>
      <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>match</name></expr></argument>, <argument><expr>"*"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name><name>b</name>-&gt;<name>err</name></name> = <call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_AUTHZ_INVALID_CONFIG</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                    <argument><expr>"Authz rules with match string '~*' "
                                    "are not allowed, because they never "
                                    "match anyone."</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>FALSE</name></expr>;</return>
        }</block></then></if>
    }</block></then></if>

  <comment type="block">/* If the rule applies to a group, check its existence. */</comment>
  <if>if <condition>(<expr><name><name>match</name><index>[<expr>0</expr>]</index></name> == '@'</expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>group</name> <init>= <expr>&amp;<name><name>match</name><index>[<expr>1</expr>]</index></name></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>svn_config_get</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>config</name></name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>, <argument><expr>"groups"</expr></argument>, <argument><expr><name>group</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Having a non-existent group in the ACL configuration might be
         the sign of a typo.  Refuse to perform authz on uncertain
         rules. */</comment>
      <if>if <condition>(<expr>!<name>val</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name><name>b</name>-&gt;<name>err</name></name> = <call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_AUTHZ_INVALID_CONFIG</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                     <argument><expr>"An authz rule refers to group "
                                     "'%s', which is undefined"</expr></argument>,
                                     <argument><expr><name>rule_match_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>FALSE</name></expr>;</return>
        }</block></then></if>
    }</block></then></if>

  <comment type="block">/* If the rule applies to an alias, check its existence. */</comment>
  <if>if <condition>(<expr><name><name>match</name><index>[<expr>0</expr>]</index></name> == '&amp;'</expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>alias</name> <init>= <expr>&amp;<name><name>match</name><index>[<expr>1</expr>]</index></name></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>svn_config_get</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>config</name></name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>, <argument><expr>"aliases"</expr></argument>, <argument><expr><name>alias</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr>!<name>val</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name><name>b</name>-&gt;<name>err</name></name> = <call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_AUTHZ_INVALID_CONFIG</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                     <argument><expr>"An authz rule refers to alias "
                                     "'%s', which is undefined"</expr></argument>,
                                     <argument><expr><name>rule_match_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>FALSE</name></expr>;</return>
        }</block></then></if>
     }</block></then></if>

  <comment type="block">/* If the rule specifies a token, check its validity. */</comment>
  <if>if <condition>(<expr><name><name>match</name><index>[<expr>0</expr>]</index></name> == '$'</expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>token_name</name> <init>= <expr>&amp;<name><name>match</name><index>[<expr>1</expr>]</index></name></expr></init></decl>;</decl_stmt>

      <if>if <condition>(<expr>(<call><name>strcmp</name><argument_list>(<argument><expr><name>token_name</name></expr></argument>, <argument><expr>"anonymous"</expr></argument>)</argument_list></call> != 0)
       &amp;&amp; (<call><name>strcmp</name><argument_list>(<argument><expr><name>token_name</name></expr></argument>, <argument><expr>"authenticated"</expr></argument>)</argument_list></call> != 0)</expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name><name>b</name>-&gt;<name>err</name></name> = <call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_AUTHZ_INVALID_CONFIG</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                     <argument><expr>"Unrecognized authz token '%s'."</expr></argument>,
                                     <argument><expr><name>rule_match_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>FALSE</name></expr>;</return>
        }</block></then></if>
    }</block></then></if>

  <expr_stmt><expr><name>val</name> = <name>value</name></expr>;</expr_stmt>

  <while>while <condition>(<expr>*<name>val</name></expr>)</condition>
    <block>{
      <if>if <condition>(<expr>*<name>val</name> != 'r' &amp;&amp; *<name>val</name> != 'w' &amp;&amp; ! <call><name>svn_ctype_isspace</name><argument_list>(<argument><expr>*<name>val</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name><name>b</name>-&gt;<name>err</name></name> = <call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_AUTHZ_INVALID_CONFIG</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                     <argument><expr>"The character '%c' in rule '%s' is not "
                                     "allowed in authz rules"</expr></argument>, <argument><expr>*<name>val</name></expr></argument>,
                                     <argument><expr><name>rule_match_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>FALSE</name></expr>;</return>
        }</block></then></if>

      <expr_stmt><expr>++<name>val</name></expr>;</expr_stmt>
    }</block></while>

  <return>return <expr><name>TRUE</name></expr>;</return>
}</block></function>

<comment type="block">/* Callback to check ALIAS's definition for validity.  Use
   BATON for context and error reporting. */</comment>
<function><type><specifier>static</specifier> <name>svn_boolean_t</name></type> <name>authz_validate_alias</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>alias</name></decl></param>,
                                          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>value</name></decl></param>,
                                          <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>,
                                          <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* No checking at the moment, every alias is valid */</comment>
  <return>return <expr><name>TRUE</name></expr>;</return>
}</block></function>


<comment type="block">/* Callback to check GROUP's definition for cyclic dependancies.  Use
   BATON for context and error reporting. */</comment>
<function><type><specifier>static</specifier> <name>svn_boolean_t</name></type> <name>authz_validate_group</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>group</name></decl></param>,
                                          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>value</name></decl></param>,
                                          <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>,
                                          <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>authz_validate_baton</name> *</type><name>b</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>b</name>-&gt;<name>err</name></name> = <call><name>authz_group_walk</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>config</name></name></expr></argument>, <argument><expr><name>group</name></expr></argument>, <argument><expr><call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name><name>b</name>-&gt;<name>err</name></name></expr>)</condition><then>
    <return>return <expr><name>FALSE</name></expr>;</return></then></if>

  <return>return <expr><name>TRUE</name></expr>;</return>
}</block></function>


<comment type="block">/* Callback to check the contents of the configuration section given
   by NAME.  Use BATON for context and error reporting. */</comment>
<function><type><specifier>static</specifier> <name>svn_boolean_t</name></type> <name>authz_validate_section</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>,
                                            <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>,
                                            <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>authz_validate_baton</name> *</type><name>b</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* If the section is the groups definition, use the group checking
     callback. Otherwise, use the rule checking callback. */</comment>
  <if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>"groups"</expr></argument>, <argument><expr>6</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
    <expr_stmt><expr><call><name>svn_config_enumerate2</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>config</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>authz_validate_group</name></expr></argument>,
                          <argument><expr><name>baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else <if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>"aliases"</expr></argument>, <argument><expr>7</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
    <expr_stmt><expr><call><name>svn_config_enumerate2</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>config</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>authz_validate_alias</name></expr></argument>,
                          <argument><expr><name>baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><call><name>svn_config_enumerate2</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>config</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>authz_validate_rule</name></expr></argument>,
                          <argument><expr><name>baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if>

  <if>if <condition>(<expr><name><name>b</name>-&gt;<name>err</name></name></expr>)</condition><then>
    <return>return <expr><name>FALSE</name></expr>;</return></then></if>

  <return>return <expr><name>TRUE</name></expr>;</return>
}</block></function>


<escape char="0xc"/>
<comment type="block">/*** Public functions. ***/</comment>

<function><type><name>svn_error_t</name> *</type>
<name>svn_repos_authz_read</name><parameter_list>(<param><decl><type><name>svn_authz_t</name> **</type><name>authz_p</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>file</name></decl></param>,
                     <param><decl><type><name>svn_boolean_t</name></type> <name>must_exist</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_authz_t</name> *</type><name>authz</name> <init>= <expr><call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>authz</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>authz_validate_baton</name></type> <name>baton</name> <init>= <expr><block>{ <expr>0</expr> }</block></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>baton</name>.<name>err</name></name> = <name>SVN_NO_ERROR</name></expr>;</expr_stmt>

  <comment type="block">/* Load the rule file. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_config_read</name><argument_list>(<argument><expr>&amp;<name><name>authz</name>-&gt;<name>cfg</name></name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>must_exist</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>baton</name>.<name>config</name></name> = <name><name>authz</name>-&gt;<name>cfg</name></name></expr>;</expr_stmt>

  <comment type="block">/* Step through the entire rule file, stopping on error. */</comment>
  <expr_stmt><expr><call><name>svn_config_enumerate_sections2</name><argument_list>(<argument><expr><name><name>authz</name>-&gt;<name>cfg</name></name></expr></argument>, <argument><expr><name>authz_validate_section</name></expr></argument>,
                                 <argument><expr>&amp;<name>baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><name><name>baton</name>.<name>err</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>authz_p</name> = <name>authz</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_repos_authz_check_access</name><parameter_list>(<param><decl><type><name>svn_authz_t</name> *</type><name>authz</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>repos_name</name></decl></param>,
                             <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>user</name></decl></param>,
                             <param><decl><type><name>svn_repos_authz_access_t</name></type> <name>required_access</name></decl></param>,
                             <param><decl><type><name>svn_boolean_t</name> *</type><name>access_granted</name></decl></param>,
                             <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>current_path</name> <init>= <expr><name>path</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* If PATH is NULL, do a global access lookup. */</comment>
  <if>if <condition>(<expr>!<name>path</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr>*<name>access_granted</name> = <call><name>authz_get_global_access</name><argument_list>(<argument><expr><name><name>authz</name>-&gt;<name>cfg</name></name></expr></argument>, <argument><expr><name>repos_name</name></expr></argument>,
                                                <argument><expr><name>user</name></expr></argument>, <argument><expr><name>required_access</name></expr></argument>,
                                                <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>

  <comment type="block">/* Determine the granted access for the requested path. */</comment>
  <while>while <condition>(<expr>!<call><name>authz_get_path_access</name><argument_list>(<argument><expr><name><name>authz</name>-&gt;<name>cfg</name></name></expr></argument>, <argument><expr><name>repos_name</name></expr></argument>,
                                <argument><expr><name>current_path</name></expr></argument>, <argument><expr><name>user</name></expr></argument>,
                                <argument><expr><name>required_access</name></expr></argument>,
                                <argument><expr><name>access_granted</name></expr></argument>,
                                <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>)</condition>
    <block>{
      <comment type="block">/* Stop if the loop hits the repository root with no
         results. */</comment>
      <if>if <condition>(<expr><name><name>current_path</name><index>[<expr>0</expr>]</index></name> == '/' &amp;&amp; <name><name>current_path</name><index>[<expr>1</expr>]</index></name> == '\0'</expr>)</condition><then>
        <block>{
          <comment type="block">/* Deny access by default. */</comment>
          <expr_stmt><expr>*<name>access_granted</name> = <name>FALSE</name></expr>;</expr_stmt>
          <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
        }</block></then></if>

      <comment type="block">/* Work back to the parent path. */</comment>
      <expr_stmt><expr><call><name>svn_path_split</name><argument_list>(<argument><expr><name>current_path</name></expr></argument>, <argument><expr>&amp;<name>current_path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></while>

  <comment type="block">/* If the caller requested recursive access, we need to walk through
     the entire authz config to see whether any child paths are denied
     to the requested user. */</comment>
  <if>if <condition>(<expr>*<name>access_granted</name> &amp;&amp; (<name>required_access</name> &amp; <name>svn_authz_recursive</name>)</expr>)</condition><then>
    <expr_stmt><expr>*<name>access_granted</name> = <call><name>authz_get_tree_access</name><argument_list>(<argument><expr><name><name>authz</name>-&gt;<name>cfg</name></name></expr></argument>, <argument><expr><name>repos_name</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
                                            <argument><expr><name>user</name></expr></argument>, <argument><expr><name>required_access</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
</unit>
