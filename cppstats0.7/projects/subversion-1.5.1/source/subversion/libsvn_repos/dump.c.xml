<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/subversion-1.5.1/source/subversion/libsvn_repos/dump.c"><comment type="block">/* dump.c --- writing filesystem contents into a portable 'dumpfile' format.
 *
 * ====================================================================
 * Copyright (c) 2000-2006 CollabNet.  All rights reserved.
 *
 * This software is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at http://subversion.tigris.org/license-1.html.
 * If newer versions of this license are posted there, you may use a
 * newer version instead, at your option.
 *
 * This software consists of voluntary contributions made by many
 * individuals.  For exact contribution history, see the revision
 * history and logs, available at http://subversion.tigris.org/.
 * ====================================================================
 */</comment>


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_private_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_pools.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_error.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_fs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_iter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_repos.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_string.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_path.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_time.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_md5.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_props.h"</cpp:file></cpp:include>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ARE_VALID_COPY_ARGS</name><parameter_list>(<param><type><name>p</name></type></param>,<param><type><name>r</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((p &amp;&amp; SVN_IS_VALID_REVNUM(r)) ? 1 : 0)</cpp:value></cpp:define>

<comment type="block">/*----------------------------------------------------------------------*/</comment>
<escape char="0xc"/>
<comment type="block">/** A variant of our hash-writing routine in libsvn_subr;  this one
    writes to a stringbuf instead of a file, and outputs PROPS-END
    instead of END.  If OLDHASH is not NULL, then only properties
    which vary from OLDHASH will be written, and properties which
    exist only in OLDHASH will be written out with "D" entries
    (like "K" entries but with no corresponding value). **/</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>write_hash_to_stringbuf</name><parameter_list>(<param><decl><type><name>apr_hash_t</name> *</type><name>hash</name></decl></param>,
                        <param><decl><type><name>apr_hash_t</name> *</type><name>oldhash</name></decl></param>,
                        <param><decl><type><name>svn_stringbuf_t</name> **</type><name>strbuf</name></decl></param>,
                        <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>this</name></decl>;</decl_stmt>      <comment type="block">/* current hash entry */</comment>

  <expr_stmt><expr>*<name>strbuf</name> = <call><name>svn_stringbuf_create</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <for>for (<init><expr><name>this</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>this</name></expr>;</condition> <incr><expr><name>this</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></incr>)
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_ssize_t</name></type> <name>keylen</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>value</name></decl>;</decl_stmt>

      <comment type="block">/* Get this key and val. */</comment>
      <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr>&amp;<name>keylen</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>value</name> = <name>val</name></expr>;</expr_stmt>

      <comment type="block">/* Don't output properties equal to the ones in oldhash, if present. */</comment>
      <if>if <condition>(<expr><name>oldhash</name></expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>oldvalue</name> <init>= <expr><call><name>apr_hash_get</name><argument_list>(<argument><expr><name>oldhash</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>keylen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

          <if>if <condition>(<expr><name>oldvalue</name> &amp;&amp; <call><name>svn_string_compare</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>oldvalue</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <continue>continue;</continue></then></if>
        }</block></then></if>

      <comment type="block">/* Output name length, then name. */</comment>

      <expr_stmt><expr><call><name>svn_stringbuf_appendcstr</name><argument_list>(<argument><expr>*<name>strbuf</name></expr></argument>,
                               <argument><expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"K %" <name>APR_SSIZE_T_FMT</name> "\n"</expr></argument>,
                                            <argument><expr><name>keylen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>svn_stringbuf_appendbytes</name><argument_list>(<argument><expr>*<name>strbuf</name></expr></argument>, <argument><expr>(const <name>char</name> *) <name>key</name></expr></argument>, <argument><expr><name>keylen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>svn_stringbuf_appendbytes</name><argument_list>(<argument><expr>*<name>strbuf</name></expr></argument>, <argument><expr>"\n"</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Output value length, then value. */</comment>

      <expr_stmt><expr><call><name>svn_stringbuf_appendcstr</name><argument_list>(<argument><expr>*<name>strbuf</name></expr></argument>,
                               <argument><expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"V %" <name>APR_SIZE_T_FMT</name> "\n"</expr></argument>,
                                            <argument><expr><name><name>value</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>svn_stringbuf_appendbytes</name><argument_list>(<argument><expr>*<name>strbuf</name></expr></argument>, <argument><expr><name><name>value</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>value</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>svn_stringbuf_appendbytes</name><argument_list>(<argument><expr>*<name>strbuf</name></expr></argument>, <argument><expr>"\n"</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

  <if>if <condition>(<expr><name>oldhash</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* Output a "D " entry for each property in oldhash but not hash. */</comment>
      <for>for (<init><expr><name>this</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>oldhash</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>this</name></expr>;</condition>
           <incr><expr><name>this</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>this</name></expr></argument>)</argument_list></call></expr></incr>)
        <block>{
          <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>apr_ssize_t</name></type> <name>keylen</name></decl>;</decl_stmt>

          <comment type="block">/* Get this key. */</comment>
          <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>this</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr>&amp;<name>keylen</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Only output values deleted in hash. */</comment>
          <if>if <condition>(<expr><call><name>apr_hash_get</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>keylen</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <continue>continue;</continue></then></if>

          <comment type="block">/* Output name length, then name. */</comment>

          <expr_stmt><expr><call><name>svn_stringbuf_appendcstr</name><argument_list>(<argument><expr>*<name>strbuf</name></expr></argument>,
                                   <argument><expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>,
                                                <argument><expr>"D %" <name>APR_SSIZE_T_FMT</name> "\n"</expr></argument>,
                                                <argument><expr><name>keylen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <expr_stmt><expr><call><name>svn_stringbuf_appendbytes</name><argument_list>(<argument><expr>*<name>strbuf</name></expr></argument>, <argument><expr>(const <name>char</name> *) <name>key</name></expr></argument>, <argument><expr><name>keylen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>svn_stringbuf_appendbytes</name><argument_list>(<argument><expr>*<name>strbuf</name></expr></argument>, <argument><expr>"\n"</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
    }</block></then></if>
  <expr_stmt><expr><call><name>svn_stringbuf_appendbytes</name><argument_list>(<argument><expr>*<name>strbuf</name></expr></argument>, <argument><expr>"PROPS-END\n"</expr></argument>, <argument><expr>10</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<comment type="block">/* Compute the delta between OLDROOT/OLDPATH and NEWROOT/NEWPATH and
   store it into a new temporary file *TEMPFILE.  OLDROOT may be NULL,
   in which case the delta will be computed against an empty file, as
   per the svn_fs_get_file_delta_stream docstring.  Record the length
   of the temporary file in *LEN, and rewind the file before
   returning. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>store_delta</name><parameter_list>(<param><decl><type><name>apr_file_t</name> **</type><name>tempfile</name></decl></param>, <param><decl><type><name>svn_filesize_t</name> *</type><name>len</name></decl></param>,
            <param><decl><type><name>svn_fs_root_t</name> *</type><name>oldroot</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>oldpath</name></decl></param>,
            <param><decl><type><name>svn_fs_root_t</name> *</type><name>newroot</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>newpath</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>tempdir</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>temp_stream</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_off_t</name></type> <name>offset</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_txdelta_stream_t</name> *</type><name>delta_stream</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_txdelta_window_handler_t</name></type> <name>wh</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> *</type><name>whb</name></decl>;</decl_stmt>

  <comment type="block">/* Create a temporary file and open a stream to it. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_temp_dir</name><argument_list>(<argument><expr>&amp;<name>tempdir</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_open_unique_file2</name><argument_list>(<argument><expr><name>tempfile</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                   <argument><expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%s/dump"</expr></argument>, <argument><expr><name>tempdir</name></expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr>".tmp"</expr></argument>, <argument><expr><name>svn_io_file_del_on_close</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>temp_stream</name> = <call><name>svn_stream_from_aprfile</name><argument_list>(<argument><expr>*<name>tempfile</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Compute the delta and send it to the temporary file. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_get_file_delta_stream</name><argument_list>(<argument><expr>&amp;<name>delta_stream</name></expr></argument>, <argument><expr><name>oldroot</name></expr></argument>, <argument><expr><name>oldpath</name></expr></argument>,
                                       <argument><expr><name>newroot</name></expr></argument>, <argument><expr><name>newpath</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_txdelta_to_svndiff2</name><argument_list>(<argument><expr>&amp;<name>wh</name></expr></argument>, <argument><expr>&amp;<name>whb</name></expr></argument>, <argument><expr><name>temp_stream</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_txdelta_send_txstream</name><argument_list>(<argument><expr><name>delta_stream</name></expr></argument>, <argument><expr><name>wh</name></expr></argument>, <argument><expr><name>whb</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Get the length of the temporary file and rewind it. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_seek</name><argument_list>(<argument><expr>*<name>tempfile</name></expr></argument>, <argument><expr><name>APR_CUR</name></expr></argument>, <argument><expr>&amp;<name>offset</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>len</name> = <name>offset</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>offset</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_seek</name><argument_list>(<argument><expr>*<name>tempfile</name></expr></argument>, <argument><expr><name>APR_SET</name></expr></argument>, <argument><expr>&amp;<name>offset</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/*----------------------------------------------------------------------*/</comment>
<escape char="0xc"/>
<comment type="block">/** An editor which dumps node-data in 'dumpfile format' to a file. **/</comment>

<comment type="block">/* Look, mom!  No file batons! */</comment>

<struct>struct <name>edit_baton</name>
<block>{
  <comment type="block">/* The path which implicitly prepends all full paths coming into
     this editor.  This will almost always be "" or "/".  */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>

  <comment type="block">/* The stream to dump to. */</comment>
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>stream</name></decl>;</decl_stmt>

  <comment type="block">/* Send feedback here, if non-NULL */</comment>
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>feedback_stream</name></decl>;</decl_stmt>

  <comment type="block">/* The fs revision root, so we can read the contents of paths. */</comment>
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>fs_root</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>current_rev</name></decl>;</decl_stmt>

  <comment type="block">/* True if dumped nodes should output deltas instead of full text. */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>use_deltas</name></decl>;</decl_stmt>

  <comment type="block">/* True if this "dump" is in fact a verify. */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>verify</name></decl>;</decl_stmt>

  <comment type="block">/* The first revision dumped in this dumpstream. */</comment>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>oldest_dumped_rev</name></decl>;</decl_stmt>

  <comment type="block">/* reusable buffer for writing file contents */</comment>
  <decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr><name>SVN__STREAM_CHUNK_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>bufsize</name></decl>;</decl_stmt>
}</block>;</struct>

<struct>struct <name>dir_baton</name>
<block>{
  <decl_stmt><decl><type>struct <name>edit_baton</name> *</type><name>edit_baton</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>dir_baton</name> *</type><name>parent_dir_baton</name></decl>;</decl_stmt>

  <comment type="block">/* is this directory a new addition to this revision? */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>added</name></decl>;</decl_stmt>

  <comment type="block">/* has this directory been written to the output stream? */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>written_out</name></decl>;</decl_stmt>

  <comment type="block">/* the absolute path to this directory */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>

  <comment type="block">/* the comparison path and revision of this directory.  if both of
     these are valid, use them as a source against which to compare
     the directory instead of the default comparison source of PATH in
     the previous revision. */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>cmp_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>cmp_rev</name></decl>;</decl_stmt>

  <comment type="block">/* hash of paths that need to be deleted, though some -might- be
     replaced.  maps const char * paths to this dir_baton.  (they're
     full paths, because that's what the editor driver gives us.  but
     really, they're all within this directory.) */</comment>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>deleted_entries</name></decl>;</decl_stmt>

  <comment type="block">/* pool to be used for deleting the hash items */</comment>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>
}</block>;</struct>


<comment type="block">/* Make a directory baton to represent the directory was path
   (relative to EDIT_BATON's path) is PATH.

   CMP_PATH/CMP_REV are the path/revision against which this directory
   should be compared for changes.  If either is omitted (NULL for the
   path, SVN_INVALID_REVNUM for the rev), just compare this directory
   PATH against itself in the previous revision.

   PARENT_DIR_BATON is the directory baton of this directory's parent,
   or NULL if this is the top-level directory of the edit.  ADDED
   indicated if this directory is newly added in this revision.
   Perform all allocations in POOL.  */</comment>
<function><type><specifier>static</specifier> struct <name>dir_baton</name> *</type>
<name>make_dir_baton</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
               <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>cmp_path</name></decl></param>,
               <param><decl><type><name>svn_revnum_t</name></type> <name>cmp_rev</name></decl></param>,
               <param><decl><type><name>void</name> *</type><name>edit_baton</name></decl></param>,
               <param><decl><type><name>void</name> *</type><name>parent_dir_baton</name></decl></param>,
               <param><decl><type><name>svn_boolean_t</name></type> <name>added</name></decl></param>,
               <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>edit_baton</name> *</type><name>eb</name> <init>= <expr><name>edit_baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>dir_baton</name> *</type><name>pb</name> <init>= <expr><name>parent_dir_baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>dir_baton</name> *</type><name>new_db</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>new_db</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>full_path</name></decl>;</decl_stmt>

  <comment type="block">/* A path relative to nothing?  I don't think so. */</comment>
  <if>if <condition>(<expr><name>path</name> &amp;&amp; (! <name>pb</name>)</expr>)</condition><then>
    <expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* Construct the full path of this node. */</comment>
  <if>if <condition>(<expr><name>pb</name></expr>)</condition><then>
    <expr_stmt><expr><name>full_path</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name><name>eb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name>full_path</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>eb</name>-&gt;<name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

  <comment type="block">/* Remove leading slashes from copyfrom paths. */</comment>
  <if>if <condition>(<expr><name>cmp_path</name></expr>)</condition><then>
    <expr_stmt><expr><name>cmp_path</name> = ((*<name>cmp_path</name> == '/') ? <name>cmp_path</name> + 1 : <name>cmp_path</name>)</expr>;</expr_stmt></then></if>

  <expr_stmt><expr><name><name>new_db</name>-&gt;<name>edit_baton</name></name> = <name>eb</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>new_db</name>-&gt;<name>parent_dir_baton</name></name> = <name>pb</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>new_db</name>-&gt;<name>path</name></name> = <name>full_path</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>new_db</name>-&gt;<name>cmp_path</name></name> = <name>cmp_path</name> ? <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>cmp_path</name></expr></argument>)</argument_list></call> : <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>new_db</name>-&gt;<name>cmp_rev</name></name> = <name>cmp_rev</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>new_db</name>-&gt;<name>added</name></name> = <name>added</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>new_db</name>-&gt;<name>written_out</name></name> = <name>FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>new_db</name>-&gt;<name>deleted_entries</name></name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>new_db</name>-&gt;<name>pool</name></name> = <name>pool</name></expr>;</expr_stmt>

  <return>return <expr><name>new_db</name></expr>;</return>
}</block></function>


<comment type="block">/* This helper is the main "meat" of the editor -- it does all the
   work of writing a node record.

   Write out a node record for PATH of type KIND under EB-&gt;FS_ROOT.
   ACTION describes what is happening to the node (see enum svn_node_action).
   Write record to writable EB-&gt;STREAM, using EB-&gt;BUFFER to write in chunks.

   If the node was itself copied, IS_COPY is TRUE and the
   path/revision of the copy source are in CMP_PATH/CMP_REV.  If
   IS_COPY is FALSE, yet CMP_PATH/CMP_REV are valid, this node is part
   of a copied subtree.
  */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>dump_node</name><argument_list>(<argument>struct <expr><name>edit_baton</name> *<name>eb</name></expr></argument>,
          <argument><expr>const <name>char</name> *<name>path</name></expr></argument>,    <comment type="block">/* an absolute path. */</comment>
          <argument><expr><name>svn_node_kind_t</name> <name>kind</name></expr></argument>,
          <argument>enum <expr><name>svn_node_action</name> <name>action</name></expr></argument>,
          <argument><expr><name>svn_boolean_t</name> <name>is_copy</name></expr></argument>,
          <argument><expr>const <name>char</name> *<name>cmp_path</name></expr></argument>,
          <argument><expr><name>svn_revnum_t</name> <name>cmp_rev</name></expr></argument>,
          <argument><expr><name>apr_pool_t</name> *<name>pool</name></expr></argument>)</argument_list>
<block>{
  <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>propstring</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_filesize_t</name></type> <name>content_length</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>must_dump_text</name> <init>= <expr><name>FALSE</name></expr></init>, <name>must_dump_props</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>compare_path</name> <init>= <expr><name>path</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>compare_rev</name> <init>= <expr><name><name>eb</name>-&gt;<name>current_rev</name></name> - 1</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>compare_root</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>delta_file</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Write out metadata headers for this file node. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_printf</name><argument_list>(<argument><expr><name><name>eb</name>-&gt;<name>stream</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>,
                            <argument><expr><name>SVN_REPOS_DUMPFILE_NODE_PATH</name> ": %s\n"</expr></argument>,
                            <argument><expr>(*<name>path</name> == '/') ? <name>path</name> + 1 : <name>path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>kind</name> == <name>svn_node_file</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_printf</name><argument_list>(<argument><expr><name><name>eb</name>-&gt;<name>stream</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>,
                              <argument><expr><name>SVN_REPOS_DUMPFILE_NODE_KIND</name> ": file\n"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else <if>if <condition>(<expr><name>kind</name> == <name>svn_node_dir</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_printf</name><argument_list>(<argument><expr><name><name>eb</name>-&gt;<name>stream</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>,
                              <argument><expr><name>SVN_REPOS_DUMPFILE_NODE_KIND</name> ": dir\n"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if>

  <comment type="block">/* Remove leading slashes from copyfrom paths. */</comment>
  <if>if <condition>(<expr><name>cmp_path</name></expr>)</condition><then>
    <expr_stmt><expr><name>cmp_path</name> = ((*<name>cmp_path</name> == '/') ? <name>cmp_path</name> + 1 : <name>cmp_path</name>)</expr>;</expr_stmt></then></if>

  <comment type="block">/* Validate the comparison path/rev. */</comment>
  <if>if <condition>(<expr><call><name>ARE_VALID_COPY_ARGS</name><argument_list>(<argument><expr><name>cmp_path</name></expr></argument>, <argument><expr><name>cmp_rev</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>compare_path</name> = <name>cmp_path</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>compare_rev</name> = <name>cmp_rev</name></expr>;</expr_stmt>
    }</block></then></if>

  <if>if <condition>(<expr><name>action</name> == <name>svn_node_action_change</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_printf</name><argument_list>(<argument><expr><name><name>eb</name>-&gt;<name>stream</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>,
                                <argument><expr><name>SVN_REPOS_DUMPFILE_NODE_ACTION</name>
                                ": change\n"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* either the text or props changed, or possibly both. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_revision_root</name><argument_list>(<argument><expr>&amp;<name>compare_root</name></expr></argument>,
                                   <argument><expr><call><name>svn_fs_root_fs</name><argument_list>(<argument><expr><name><name>eb</name>-&gt;<name>fs_root</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr><name>compare_rev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_props_changed</name><argument_list>(<argument><expr>&amp;<name>must_dump_props</name></expr></argument>,
                                   <argument><expr><name>compare_root</name></expr></argument>, <argument><expr><name>compare_path</name></expr></argument>,
                                   <argument><expr><name><name>eb</name>-&gt;<name>fs_root</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>kind</name> == <name>svn_node_file</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_contents_changed</name><argument_list>(<argument><expr>&amp;<name>must_dump_text</name></expr></argument>,
                                        <argument><expr><name>compare_root</name></expr></argument>, <argument><expr><name>compare_path</name></expr></argument>,
                                        <argument><expr><name><name>eb</name>-&gt;<name>fs_root</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then>
  <else>else <if>if <condition>(<expr><name>action</name> == <name>svn_node_action_replace</name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr>! <name>is_copy</name></expr>)</condition><then>
        <block>{
          <comment type="block">/* a simple delete+add, implied by a single 'replace' action. */</comment>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_printf</name><argument_list>(<argument><expr><name><name>eb</name>-&gt;<name>stream</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>,
                                    <argument><expr><name>SVN_REPOS_DUMPFILE_NODE_ACTION</name>
                                    ": replace\n"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* definitely need to dump all content for a replace. */</comment>
          <if>if <condition>(<expr><name>kind</name> == <name>svn_node_file</name></expr>)</condition><then>
            <expr_stmt><expr><name>must_dump_text</name> = <name>TRUE</name></expr>;</expr_stmt></then></if>
          <expr_stmt><expr><name>must_dump_props</name> = <name>TRUE</name></expr>;</expr_stmt>
        }</block></then>
      <else>else
        <block>{
          <comment type="block">/* more complex:  delete original, then add-with-history.  */</comment>

          <comment type="block">/* the path &amp; kind headers have already been printed;  just
             add a delete action, and end the current record.*/</comment>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_printf</name><argument_list>(<argument><expr><name><name>eb</name>-&gt;<name>stream</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>,
                                    <argument><expr><name>SVN_REPOS_DUMPFILE_NODE_ACTION</name>
                                    ": delete\n\n"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* recurse:  print an additional add-with-history record. */</comment>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>dump_node</name><argument_list>(<argument><expr><name>eb</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>kind</name></expr></argument>, <argument><expr><name>svn_node_action_add</name></expr></argument>,
                            <argument><expr><name>is_copy</name></expr></argument>, <argument><expr><name>compare_path</name></expr></argument>, <argument><expr><name>compare_rev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* we can leave this routine quietly now, don't need to dump
             any content;  that was already done in the second record. */</comment>
          <expr_stmt><expr><name>must_dump_text</name> = <name>FALSE</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>must_dump_props</name> = <name>FALSE</name></expr>;</expr_stmt>
        }</block></else></if>
    }</block></then>
  <else>else <if>if <condition>(<expr><name>action</name> == <name>svn_node_action_delete</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_printf</name><argument_list>(<argument><expr><name><name>eb</name>-&gt;<name>stream</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>,
                                <argument><expr><name>SVN_REPOS_DUMPFILE_NODE_ACTION</name>
                                ": delete\n"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* we can leave this routine quietly now, don't need to dump
         any content. */</comment>
      <expr_stmt><expr><name>must_dump_text</name> = <name>FALSE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>must_dump_props</name> = <name>FALSE</name></expr>;</expr_stmt>
    }</block></then>
  <else>else <if>if <condition>(<expr><name>action</name> == <name>svn_node_action_add</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_printf</name><argument_list>(<argument><expr><name><name>eb</name>-&gt;<name>stream</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>,
                                <argument><expr><name>SVN_REPOS_DUMPFILE_NODE_ACTION</name> ": add\n"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr>! <name>is_copy</name></expr>)</condition><then>
        <block>{
          <comment type="block">/* Dump all contents for a simple 'add'. */</comment>
          <if>if <condition>(<expr><name>kind</name> == <name>svn_node_file</name></expr>)</condition><then>
            <expr_stmt><expr><name>must_dump_text</name> = <name>TRUE</name></expr>;</expr_stmt></then></if>
          <expr_stmt><expr><name>must_dump_props</name> = <name>TRUE</name></expr>;</expr_stmt>
        }</block></then>
      <else>else
        <block>{
          <if>if <condition>(<expr>!<name><name>eb</name>-&gt;<name>verify</name></name> &amp;&amp; <name>cmp_rev</name> &lt; <name><name>eb</name>-&gt;<name>oldest_dumped_rev</name></name></expr>)</condition><then>
            <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_printf</name>
                    <argument_list>(<argument><expr><name><name>eb</name>-&gt;<name>feedback_stream</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>,
                     <argument><expr><call><name>_</name><argument_list>(<argument><expr>"WARNING: Referencing data in revision %ld"
                       ", which is older than the oldest\nWARNING: dumped revision "
                       "(%ld).  Loading this dump into an empty "
                       "repository\nWARNING: will fail.\n"</expr></argument>)</argument_list></call></expr></argument>,
                     <argument><expr><name>cmp_rev</name></expr></argument>, <argument><expr><name><name>eb</name>-&gt;<name>oldest_dumped_rev</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_printf</name><argument_list>(<argument><expr><name><name>eb</name>-&gt;<name>stream</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>,
                                    <argument><expr><name>SVN_REPOS_DUMPFILE_NODE_COPYFROM_REV</name>
                                    ": %ld\n"
                                    <name>SVN_REPOS_DUMPFILE_NODE_COPYFROM_PATH</name>
                                    ": %s\n"</expr></argument>,
                                    <argument><expr><name>cmp_rev</name></expr></argument>, <argument><expr><name>cmp_path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_revision_root</name><argument_list>(<argument><expr>&amp;<name>compare_root</name></expr></argument>,
                                       <argument><expr><call><name>svn_fs_root_fs</name><argument_list>(<argument><expr><name><name>eb</name>-&gt;<name>fs_root</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                       <argument><expr><name>compare_rev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Need to decide if the copied node had any extra textual or
             property mods as well.  */</comment>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_props_changed</name><argument_list>(<argument><expr>&amp;<name>must_dump_props</name></expr></argument>,
                                       <argument><expr><name>compare_root</name></expr></argument>, <argument><expr><name>compare_path</name></expr></argument>,
                                       <argument><expr><name><name>eb</name>-&gt;<name>fs_root</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>kind</name> == <name>svn_node_file</name></expr>)</condition><then>
            <block>{
              <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>md5_digest</name><index>[<expr><name>APR_MD5_DIGESTSIZE</name></expr>]</index></name></decl>;</decl_stmt>
              <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>hex_digest</name></decl>;</decl_stmt>
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_contents_changed</name><argument_list>(<argument><expr>&amp;<name>must_dump_text</name></expr></argument>,
                                              <argument><expr><name>compare_root</name></expr></argument>, <argument><expr><name>compare_path</name></expr></argument>,
                                              <argument><expr><name><name>eb</name>-&gt;<name>fs_root</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_file_md5_checksum</name><argument_list>(<argument><expr><name>md5_digest</name></expr></argument>, <argument><expr><name>compare_root</name></expr></argument>,
                                               <argument><expr><name>compare_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>hex_digest</name> = <call><name>svn_md5_digest_to_cstring</name><argument_list>(<argument><expr><name>md5_digest</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <if>if <condition>(<expr><name>hex_digest</name></expr>)</condition><then>
                <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_printf</name><argument_list>(<argument><expr><name><name>eb</name>-&gt;<name>stream</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>,
                                          <argument><expr><name>SVN_REPOS_DUMPFILE_TEXT_COPY_SOURCE_CHECKSUM</name>
                                          ": %s\n"</expr></argument>, <argument><expr><name>hex_digest</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            }</block></then></if>
        }</block></else></if>
    }</block></then></if></else></if></else></if></else></if>

  <if>if <condition>(<expr>(! <name>must_dump_text</name>) &amp;&amp; (! <name>must_dump_props</name>)</expr>)</condition><then>
    <block>{
      <comment type="block">/* If we're not supposed to dump text or props, so be it, we can
         just go home.  However, if either one needs to be dumped,
         then our dumpstream format demands that at a *minimum*, we
         see a lone "PROPS-END" as a divider between text and props
         content within the content-block. */</comment>
      <expr_stmt><expr><name>len</name> = 2</expr>;</expr_stmt>
      <return>return <expr><call><name>svn_stream_write</name><argument_list>(<argument><expr><name><name>eb</name>-&gt;<name>stream</name></name></expr></argument>, <argument><expr>"\n\n"</expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr>;</return> <comment type="block">/* ### needed? */</comment>
    }</block></then></if>

  <comment type="block">/*** Start prepping content to dump... ***/</comment>

  <comment type="block">/* If we are supposed to dump properties, write out a property
     length header and generate a stringbuf that contains those
     property values here. */</comment>
  <if>if <condition>(<expr><name>must_dump_props</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>prophash</name></decl>, *<decl><type ref="prev"/><name>oldhash</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_size_t</name></type> <name>proplen</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_node_proplist</name><argument_list>(<argument><expr>&amp;<name>prophash</name></expr></argument>, <argument><expr><name><name>eb</name>-&gt;<name>fs_root</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name><name>eb</name>-&gt;<name>use_deltas</name></name> &amp;&amp; <name>compare_root</name></expr>)</condition><then>
        <block>{
          <comment type="block">/* Fetch the old property hash to diff against and output a header
             saying that our property contents are a delta. */</comment>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_node_proplist</name><argument_list>(<argument><expr>&amp;<name>oldhash</name></expr></argument>, <argument><expr><name>compare_root</name></expr></argument>, <argument><expr><name>compare_path</name></expr></argument>,
                                       <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_printf</name><argument_list>(<argument><expr><name><name>eb</name>-&gt;<name>stream</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>,
                                    <argument><expr><name>SVN_REPOS_DUMPFILE_PROP_DELTA</name>
                                    ": true\n"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
      <expr_stmt><expr><call><name>write_hash_to_stringbuf</name><argument_list>(<argument><expr><name>prophash</name></expr></argument>, <argument><expr><name>oldhash</name></expr></argument>, <argument><expr>&amp;<name>propstring</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>proplen</name> = <name><name>propstring</name>-&gt;<name>len</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>content_length</name> += <name>proplen</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_printf</name><argument_list>(<argument><expr><name><name>eb</name>-&gt;<name>stream</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>,
                                <argument><expr><name>SVN_REPOS_DUMPFILE_PROP_CONTENT_LENGTH</name>
                                ": %" <name>APR_SIZE_T_FMT</name> "\n"</expr></argument>, <argument><expr><name>proplen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* If we are supposed to dump text, write out a text length header
     here, and an MD5 checksum (if available). */</comment>
  <if>if <condition>(<expr><name>must_dump_text</name> &amp;&amp; (<name>kind</name> == <name>svn_node_file</name>)</expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>md5_digest</name><index>[<expr><name>APR_MD5_DIGESTSIZE</name></expr>]</index></name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>hex_digest</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_filesize_t</name></type> <name>textlen</name></decl>;</decl_stmt>

      <if>if <condition>(<expr><name><name>eb</name>-&gt;<name>use_deltas</name></name></expr>)</condition><then>
        <block>{
          <comment type="block">/* Compute the text delta now and write it into a temporary
             file, so that we can find its length.  Output a header
             saying our text contents are a delta. */</comment>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>store_delta</name><argument_list>(<argument><expr>&amp;<name>delta_file</name></expr></argument>, <argument><expr>&amp;<name>textlen</name></expr></argument>, <argument><expr><name>compare_root</name></expr></argument>,
                              <argument><expr><name>compare_path</name></expr></argument>, <argument><expr><name><name>eb</name>-&gt;<name>fs_root</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_printf</name><argument_list>(<argument><expr><name><name>eb</name>-&gt;<name>stream</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>,
                                    <argument><expr><name>SVN_REPOS_DUMPFILE_TEXT_DELTA</name>
                                    ": true\n"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <if>if <condition>(<expr><name>compare_root</name></expr>)</condition><then>
            <block>{
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_file_md5_checksum</name><argument_list>(<argument><expr><name>md5_digest</name></expr></argument>, <argument><expr><name>compare_root</name></expr></argument>,
                                               <argument><expr><name>compare_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>hex_digest</name> = <call><name>svn_md5_digest_to_cstring</name><argument_list>(<argument><expr><name>md5_digest</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <if>if <condition>(<expr><name>hex_digest</name></expr>)</condition><then>
                <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_printf</name><argument_list>(<argument><expr><name><name>eb</name>-&gt;<name>stream</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>,
                                          <argument><expr><name>SVN_REPOS_DUMPFILE_TEXT_DELTA_BASE_CHECKSUM</name>
                                          ": %s\n"</expr></argument>, <argument><expr><name>hex_digest</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            }</block></then></if>
        }</block></then>
      <else>else
        <block>{
          <comment type="block">/* Just fetch the length of the file. */</comment>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_file_length</name><argument_list>(<argument><expr>&amp;<name>textlen</name></expr></argument>, <argument><expr><name><name>eb</name>-&gt;<name>fs_root</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>

      <expr_stmt><expr><name>content_length</name> += <name>textlen</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_printf</name><argument_list>(<argument><expr><name><name>eb</name>-&gt;<name>stream</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>,
                                <argument><expr><name>SVN_REPOS_DUMPFILE_TEXT_CONTENT_LENGTH</name>
                                ": %" <name>SVN_FILESIZE_T_FMT</name> "\n"</expr></argument>, <argument><expr><name>textlen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_file_md5_checksum</name><argument_list>(<argument><expr><name>md5_digest</name></expr></argument>, <argument><expr><name><name>eb</name>-&gt;<name>fs_root</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>hex_digest</name> = <call><name>svn_md5_digest_to_cstring</name><argument_list>(<argument><expr><name>md5_digest</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>hex_digest</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_printf</name><argument_list>(<argument><expr><name><name>eb</name>-&gt;<name>stream</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>,
                                  <argument><expr><name>SVN_REPOS_DUMPFILE_TEXT_CONTENT_CHECKSUM</name>
                                  ": %s\n"</expr></argument>, <argument><expr><name>hex_digest</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then></if>

  <comment type="block">/* 'Content-length:' is the last header before we dump the content,
     and is the sum of the text and prop contents lengths.  We write
     this only for the benefit of non-Subversion RFC-822 parsers. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_printf</name><argument_list>(<argument><expr><name><name>eb</name>-&gt;<name>stream</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>,
                            <argument><expr><name>SVN_REPOS_DUMPFILE_CONTENT_LENGTH</name>
                            ": %" <name>SVN_FILESIZE_T_FMT</name> "\n\n"</expr></argument>,
                            <argument><expr><name>content_length</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Dump property content if we're supposed to do so. */</comment>
  <if>if <condition>(<expr><name>must_dump_props</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>len</name> = <name><name>propstring</name>-&gt;<name>len</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_write</name><argument_list>(<argument><expr><name><name>eb</name>-&gt;<name>stream</name></name></expr></argument>, <argument><expr><name><name>propstring</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* Dump text content */</comment>
  <if>if <condition>(<expr><name>must_dump_text</name> &amp;&amp; (<name>kind</name> == <name>svn_node_file</name>)</expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>contents</name></decl>;</decl_stmt>

      <if>if <condition>(<expr><name>delta_file</name></expr>)</condition><then>
        <expr_stmt><expr><name>contents</name> = <call><name>svn_stream_from_aprfile</name><argument_list>(<argument><expr><name>delta_file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
      <else>else
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_file_contents</name><argument_list>(<argument><expr>&amp;<name>contents</name></expr></argument>, <argument><expr><name><name>eb</name>-&gt;<name>fs_root</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_copy</name><argument_list>(<argument><expr><name>contents</name></expr></argument>, <argument><expr><name><name>eb</name>-&gt;<name>stream</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <expr_stmt><expr><name>len</name> = 2</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_write</name><argument_list>(<argument><expr><name><name>eb</name>-&gt;<name>stream</name></name></expr></argument>, <argument><expr>"\n\n"</expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* ### needed? */</comment>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></decl></decl_stmt>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>open_root</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>edit_baton</name></decl></param>,
          <param><decl><type><name>svn_revnum_t</name></type> <name>base_revision</name></decl></param>,
          <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
          <param><decl><type><name>void</name> **</type><name>root_baton</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr>*<name>root_baton</name> = <call><name>make_dir_baton</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>SVN_INVALID_REVNUM</name></expr></argument>,
                               <argument><expr><name>edit_baton</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>delete_entry</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
             <param><decl><type><name>svn_revnum_t</name></type> <name>revision</name></decl></param>,
             <param><decl><type><name>void</name> *</type><name>parent_baton</name></decl></param>,
             <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>dir_baton</name> *</type><name>pb</name> <init>= <expr><name>parent_baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>mypath</name> <init>= <expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>pb</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="block">/* remember this path needs to be deleted. */</comment>
  <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name><name>pb</name>-&gt;<name>deleted_entries</name></name></expr></argument>, <argument><expr><name>mypath</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>pb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>add_directory</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
              <param><decl><type><name>void</name> *</type><name>parent_baton</name></decl></param>,
              <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copyfrom_path</name></decl></param>,
              <param><decl><type><name>svn_revnum_t</name></type> <name>copyfrom_rev</name></decl></param>,
              <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
              <param><decl><type><name>void</name> **</type><name>child_baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>dir_baton</name> *</type><name>pb</name> <init>= <expr><name>parent_baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>edit_baton</name> *</type><name>eb</name> <init>= <expr><name><name>pb</name>-&gt;<name>edit_baton</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>is_copy</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>dir_baton</name> *</type><name>new_db</name>
    <init>= <expr><call><name>make_dir_baton</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>copyfrom_path</name></expr></argument>, <argument><expr><name>copyfrom_rev</name></expr></argument>, <argument><expr><name>eb</name></expr></argument>, <argument><expr><name>pb</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="block">/* This might be a replacement -- is the path already deleted? */</comment>
  <expr_stmt><expr><name>val</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name><name>pb</name>-&gt;<name>deleted_entries</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Detect an add-with-history. */</comment>
  <expr_stmt><expr><name>is_copy</name> = <call><name>ARE_VALID_COPY_ARGS</name><argument_list>(<argument><expr><name>copyfrom_path</name></expr></argument>, <argument><expr><name>copyfrom_rev</name></expr></argument>)</argument_list></call> ? <name>TRUE</name> : <name>FALSE</name></expr>;</expr_stmt>

  <comment type="block">/* Dump the node. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>dump_node</name><argument_list>(<argument><expr><name>eb</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
                    <argument><expr><name>svn_node_dir</name></expr></argument>,
                    <argument><expr><name>val</name> ? <name>svn_node_action_replace</name> : <name>svn_node_action_add</name></expr></argument>,
                    <argument><expr><name>is_copy</name></expr></argument>,
                    <argument><expr><name>is_copy</name> ? <name>copyfrom_path</name> : <name>NULL</name></expr></argument>,
                    <argument><expr><name>is_copy</name> ? <name>copyfrom_rev</name> : <name>SVN_INVALID_REVNUM</name></expr></argument>,
                    <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>val</name></expr>)</condition><then>
    <comment type="block">/* Delete the path, it's now been dumped. */</comment>
    <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name><name>pb</name>-&gt;<name>deleted_entries</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <expr_stmt><expr><name><name>new_db</name>-&gt;<name>written_out</name></name> = <name>TRUE</name></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>child_baton</name> = <name>new_db</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>open_directory</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
               <param><decl><type><name>void</name> *</type><name>parent_baton</name></decl></param>,
               <param><decl><type><name>svn_revnum_t</name></type> <name>base_revision</name></decl></param>,
               <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
               <param><decl><type><name>void</name> **</type><name>child_baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>dir_baton</name> *</type><name>pb</name> <init>= <expr><name>parent_baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>edit_baton</name> *</type><name>eb</name> <init>= <expr><name><name>pb</name>-&gt;<name>edit_baton</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>dir_baton</name> *</type><name>new_db</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>cmp_path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>cmp_rev</name> <init>= <expr><name>SVN_INVALID_REVNUM</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* If the parent directory has explicit comparison path and rev,
     record the same for this one. */</comment>
  <if>if <condition>(<expr><name>pb</name> &amp;&amp; <call><name>ARE_VALID_COPY_ARGS</name><argument_list>(<argument><expr><name><name>pb</name>-&gt;<name>cmp_path</name></name></expr></argument>, <argument><expr><name><name>pb</name>-&gt;<name>cmp_rev</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>cmp_path</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name><name>pb</name>-&gt;<name>cmp_path</name></name></expr></argument>,
                               <argument><expr><call><name>svn_path_basename</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>cmp_rev</name> = <name><name>pb</name>-&gt;<name>cmp_rev</name></name></expr>;</expr_stmt>
    }</block></then></if>

  <expr_stmt><expr><name>new_db</name> = <call><name>make_dir_baton</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>cmp_path</name></expr></argument>, <argument><expr><name>cmp_rev</name></expr></argument>, <argument><expr><name>eb</name></expr></argument>, <argument><expr><name>pb</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>child_baton</name> = <name>new_db</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>close_directory</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>dir_baton</name></decl></param>,
                <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>dir_baton</name> *</type><name>db</name> <init>= <expr><name>dir_baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>edit_baton</name> *</type><name>eb</name> <init>= <expr><name><name>db</name>-&gt;<name>edit_baton</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>db</name>-&gt;<name>deleted_entries</name></name></expr></argument>)</argument_list></call></expr>;</init>
       <condition><expr><name>hi</name></expr>;</condition>
       <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>path</name> = <name>key</name></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* By sending 'svn_node_unknown', the Node-kind: header simply won't
         be written out.  No big deal at all, really.  The loader
         shouldn't care.  */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>dump_node</name><argument_list>(<argument><expr><name>eb</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
                        <argument><expr><name>svn_node_unknown</name></expr></argument>, <argument><expr><name>svn_node_action_delete</name></expr></argument>,
                        <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>SVN_INVALID_REVNUM</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>add_file</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
         <param><decl><type><name>void</name> *</type><name>parent_baton</name></decl></param>,
         <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copyfrom_path</name></decl></param>,
         <param><decl><type><name>svn_revnum_t</name></type> <name>copyfrom_rev</name></decl></param>,
         <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
         <param><decl><type><name>void</name> **</type><name>file_baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>dir_baton</name> *</type><name>pb</name> <init>= <expr><name>parent_baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>edit_baton</name> *</type><name>eb</name> <init>= <expr><name><name>pb</name>-&gt;<name>edit_baton</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>is_copy</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* This might be a replacement -- is the path already deleted? */</comment>
  <expr_stmt><expr><name>val</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name><name>pb</name>-&gt;<name>deleted_entries</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Detect add-with-history. */</comment>
  <expr_stmt><expr><name>is_copy</name> = <call><name>ARE_VALID_COPY_ARGS</name><argument_list>(<argument><expr><name>copyfrom_path</name></expr></argument>, <argument><expr><name>copyfrom_rev</name></expr></argument>)</argument_list></call> ? <name>TRUE</name> : <name>FALSE</name></expr>;</expr_stmt>

  <comment type="block">/* Dump the node. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>dump_node</name><argument_list>(<argument><expr><name>eb</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
                    <argument><expr><name>svn_node_file</name></expr></argument>,
                    <argument><expr><name>val</name> ? <name>svn_node_action_replace</name> : <name>svn_node_action_add</name></expr></argument>,
                    <argument><expr><name>is_copy</name></expr></argument>,
                    <argument><expr><name>is_copy</name> ? <name>copyfrom_path</name> : <name>NULL</name></expr></argument>,
                    <argument><expr><name>is_copy</name> ? <name>copyfrom_rev</name> : <name>SVN_INVALID_REVNUM</name></expr></argument>,
                    <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>val</name></expr>)</condition><then>
    <comment type="block">/* delete the path, it's now been dumped. */</comment>
    <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name><name>pb</name>-&gt;<name>deleted_entries</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <expr_stmt><expr>*<name>file_baton</name> = <name>NULL</name></expr>;</expr_stmt>  <comment type="block">/* muhahahaha */</comment>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>open_file</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
          <param><decl><type><name>void</name> *</type><name>parent_baton</name></decl></param>,
          <param><decl><type><name>svn_revnum_t</name></type> <name>ancestor_revision</name></decl></param>,
          <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
          <param><decl><type><name>void</name> **</type><name>file_baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>dir_baton</name> *</type><name>pb</name> <init>= <expr><name>parent_baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>edit_baton</name> *</type><name>eb</name> <init>= <expr><name><name>pb</name>-&gt;<name>edit_baton</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>cmp_path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>cmp_rev</name> <init>= <expr><name>SVN_INVALID_REVNUM</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* If the parent directory has explicit comparison path and rev,
     record the same for this one. */</comment>
  <if>if <condition>(<expr><name>pb</name> &amp;&amp; <call><name>ARE_VALID_COPY_ARGS</name><argument_list>(<argument><expr><name><name>pb</name>-&gt;<name>cmp_path</name></name></expr></argument>, <argument><expr><name><name>pb</name>-&gt;<name>cmp_rev</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>cmp_path</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name><name>pb</name>-&gt;<name>cmp_path</name></name></expr></argument>,
                               <argument><expr><call><name>svn_path_basename</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>cmp_rev</name> = <name><name>pb</name>-&gt;<name>cmp_rev</name></name></expr>;</expr_stmt>
    }</block></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>dump_node</name><argument_list>(<argument><expr><name>eb</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
                    <argument><expr><name>svn_node_file</name></expr></argument>, <argument><expr><name>svn_node_action_change</name></expr></argument>,
                    <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>cmp_path</name></expr></argument>, <argument><expr><name>cmp_rev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>file_baton</name> = <name>NULL</name></expr>;</expr_stmt>  <comment type="block">/* muhahahaha again */</comment>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>change_dir_prop</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>parent_baton</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>value</name></decl></param>,
                <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>dir_baton</name> *</type><name>db</name> <init>= <expr><name>parent_baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>edit_baton</name> *</type><name>eb</name> <init>= <expr><name><name>db</name>-&gt;<name>edit_baton</name></name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* This function is what distinguishes between a directory that is
     opened to merely get somewhere, vs. one that is opened because it
     *actually* changed by itself.  */</comment>
  <if>if <condition>(<expr>! <name><name>db</name>-&gt;<name>written_out</name></name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>dump_node</name><argument_list>(<argument><expr><name>eb</name></expr></argument>, <argument><expr><name><name>db</name>-&gt;<name>path</name></name></expr></argument>,
                        <argument><expr><name>svn_node_dir</name></expr></argument>, <argument><expr><name>svn_node_action_change</name></expr></argument>,
                        <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name><name>db</name>-&gt;<name>cmp_path</name></name></expr></argument>, <argument><expr><name><name>db</name>-&gt;<name>cmp_rev</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>db</name>-&gt;<name>written_out</name></name> = <name>TRUE</name></expr>;</expr_stmt>
    }</block></then></if>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>



<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>get_dump_editor</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>svn_delta_editor_t</name> **</type><name>editor</name></decl></param>,
                <param><decl><type><name>void</name> **</type><name>edit_baton</name></decl></param>,
                <param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                <param><decl><type><name>svn_revnum_t</name></type> <name>to_rev</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>root_path</name></decl></param>,
                <param><decl><type><name>svn_stream_t</name> *</type><name>stream</name></decl></param>,
                <param><decl><type><name>svn_stream_t</name> *</type><name>feedback_stream</name></decl></param>,
                <param><decl><type><name>svn_revnum_t</name></type> <name>oldest_dumped_rev</name></decl></param>,
                <param><decl><type><name>svn_boolean_t</name></type> <name>use_deltas</name></decl></param>,
                <param><decl><type><name>svn_boolean_t</name></type> <name>verify</name></decl></param>,
                <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* Allocate an edit baton to be stored in every directory baton.
     Set it up for the directory baton we create here, which is the
     root baton. */</comment>
  <decl_stmt><decl><type>struct <name>edit_baton</name> *</type><name>eb</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>eb</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_delta_editor_t</name> *</type><name>dump_editor</name> <init>= <expr><call><name>svn_delta_default_editor</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Set up the edit baton. */</comment>
  <expr_stmt><expr><name><name>eb</name>-&gt;<name>stream</name></name> = <name>stream</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>eb</name>-&gt;<name>feedback_stream</name></name> = <name>feedback_stream</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>eb</name>-&gt;<name>oldest_dumped_rev</name></name> = <name>oldest_dumped_rev</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>eb</name>-&gt;<name>bufsize</name></name> = <sizeof>sizeof<argument_list>(<argument><expr><name><name>eb</name>-&gt;<name>buffer</name></name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>eb</name>-&gt;<name>path</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>root_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_revision_root</name><argument_list>(<argument><expr>&amp;(<name><name>eb</name>-&gt;<name>fs_root</name></name>)</expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>to_rev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>eb</name>-&gt;<name>current_rev</name></name> = <name>to_rev</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>eb</name>-&gt;<name>use_deltas</name></name> = <name>use_deltas</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>eb</name>-&gt;<name>verify</name></name> = <name>verify</name></expr>;</expr_stmt>

  <comment type="block">/* Set up the editor. */</comment>
  <expr_stmt><expr><name><name>dump_editor</name>-&gt;<name>open_root</name></name> = <name>open_root</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>dump_editor</name>-&gt;<name>delete_entry</name></name> = <name>delete_entry</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>dump_editor</name>-&gt;<name>add_directory</name></name> = <name>add_directory</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>dump_editor</name>-&gt;<name>open_directory</name></name> = <name>open_directory</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>dump_editor</name>-&gt;<name>close_directory</name></name> = <name>close_directory</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>dump_editor</name>-&gt;<name>change_dir_prop</name></name> = <name>change_dir_prop</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>dump_editor</name>-&gt;<name>add_file</name></name> = <name>add_file</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>dump_editor</name>-&gt;<name>open_file</name></name> = <name>open_file</name></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>edit_baton</name> = <name>eb</name></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>editor</name> = <name>dump_editor</name></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/*----------------------------------------------------------------------*/</comment>
<escape char="0xc"/>
<comment type="block">/** The main dumping routine, svn_repos_dump_fs. **/</comment>


<comment type="block">/* Helper for svn_repos_dump_fs.

   Write a revision record of REV in FS to writable STREAM, using POOL.
 */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>write_revision_record</name><parameter_list>(<param><decl><type><name>svn_stream_t</name> *</type><name>stream</name></decl></param>,
                      <param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                      <param><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl></param>,
                      <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>props</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>encoded_prophash</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_time_t</name></type> <name>timetemp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>datevalue</name></decl>;</decl_stmt>

  <comment type="block">/* Read the revision props even if we're aren't going to dump
     them for verification purposes */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_revision_proplist</name><argument_list>(<argument><expr>&amp;<name>props</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Run revision date properties through the time conversion to
     canonicalize them. */</comment>
  <comment type="block">/* ### Remove this when it is no longer needed for sure. */</comment>
  <expr_stmt><expr><name>datevalue</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>props</name></expr></argument>, <argument><expr><name>SVN_PROP_REVISION_DATE</name></expr></argument>,
                           <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>datevalue</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_time_from_cstring</name><argument_list>(<argument><expr>&amp;<name>timetemp</name></expr></argument>, <argument><expr><name><name>datevalue</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>datevalue</name> = <call><name>svn_string_create</name><argument_list>(<argument><expr><call><name>svn_time_to_cstring</name><argument_list>(<argument><expr><name>timetemp</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                                    <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>props</name></expr></argument>, <argument><expr><name>SVN_PROP_REVISION_DATE</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>,
                   <argument><expr><name>datevalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <expr_stmt><expr><call><name>write_hash_to_stringbuf</name><argument_list>(<argument><expr><name>props</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>encoded_prophash</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* ### someday write a revision-content-checksum */</comment>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_printf</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>,
                            <argument><expr><name>SVN_REPOS_DUMPFILE_REVISION_NUMBER</name>
                            ": %ld\n"</expr></argument>, <argument><expr><name>rev</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_printf</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>,
                            <argument><expr><name>SVN_REPOS_DUMPFILE_PROP_CONTENT_LENGTH</name>
                            ": %" <name>APR_SIZE_T_FMT</name> "\n"</expr></argument>,
                            <argument><expr><name><name>encoded_prophash</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Write out a regular Content-length header for the benefit of
     non-Subversion RFC-822 parsers. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_printf</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>,
                            <argument><expr><name>SVN_REPOS_DUMPFILE_CONTENT_LENGTH</name>
                            ": %" <name>APR_SIZE_T_FMT</name> "\n\n"</expr></argument>,
                            <argument><expr><name><name>encoded_prophash</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>len</name> = <name><name>encoded_prophash</name>-&gt;<name>len</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_write</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><name><name>encoded_prophash</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>len</name> = 1</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_write</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr>"\n"</expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>



<comment type="block">/* The main dumper. */</comment>
<function><type><name>svn_error_t</name> *</type>
<name>svn_repos_dump_fs2</name><parameter_list>(<param><decl><type><name>svn_repos_t</name> *</type><name>repos</name></decl></param>,
                   <param><decl><type><name>svn_stream_t</name> *</type><name>stream</name></decl></param>,
                   <param><decl><type><name>svn_stream_t</name> *</type><name>feedback_stream</name></decl></param>,
                   <param><decl><type><name>svn_revnum_t</name></type> <name>start_rev</name></decl></param>,
                   <param><decl><type><name>svn_revnum_t</name></type> <name>end_rev</name></decl></param>,
                   <param><decl><type><name>svn_boolean_t</name></type> <name>incremental</name></decl></param>,
                   <param><decl><type><name>svn_boolean_t</name></type> <name>use_deltas</name></decl></param>,
                   <param><decl><type><name>svn_cancel_func_t</name></type> <name>cancel_func</name></decl></param>,
                   <param><decl><type><name>void</name> *</type><name>cancel_baton</name></decl></param>,
                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_delta_editor_t</name> *</type><name>dump_editor</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> *</type><name>dump_edit_baton</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name> <init>= <expr><call><name>svn_repos_fs</name><argument_list>(<argument><expr><name>repos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>youngest</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>uuid</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>version</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>dumping</name> <init>= <expr>(<name>stream</name> != <name>NULL</name>)</expr></init></decl>;</decl_stmt>

  <comment type="block">/* Determine the current youngest revision of the filesystem. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_youngest_rev</name><argument_list>(<argument><expr>&amp;<name>youngest</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Use default vals if necessary. */</comment>
  <if>if <condition>(<expr>! <call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name>start_rev</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <expr_stmt><expr><name>start_rev</name> = 0</expr>;</expr_stmt></then></if>
  <if>if <condition>(<expr>! <call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name>end_rev</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <expr_stmt><expr><name>end_rev</name> = <name>youngest</name></expr>;</expr_stmt></then></if>
  <if>if <condition>(<expr>! <name>stream</name></expr>)</condition><then>
    <expr_stmt><expr><name>stream</name> = <call><name>svn_stream_empty</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <if>if <condition>(<expr>! <name>feedback_stream</name></expr>)</condition><then>
    <expr_stmt><expr><name>feedback_stream</name> = <call><name>svn_stream_empty</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* Validate the revisions. */</comment>
  <if>if <condition>(<expr><name>start_rev</name> &gt; <name>end_rev</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_REPOS_BAD_ARGS</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Start revision %ld"
                               " is greater than end revision %ld"</expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><name>start_rev</name></expr></argument>, <argument><expr><name>end_rev</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
  <if>if <condition>(<expr><name>end_rev</name> &gt; <name>youngest</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_REPOS_BAD_ARGS</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><call><name>_</name><argument_list>(<argument><expr>"End revision %ld is invalid "
                               "(youngest revision is %ld)"</expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><name>end_rev</name></expr></argument>, <argument><expr><name>youngest</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
  <if>if <condition>(<expr>(<name>start_rev</name> == 0) &amp;&amp; <name>incremental</name></expr>)</condition><then>
    <expr_stmt><expr><name>incremental</name> = <name>FALSE</name></expr>;</expr_stmt></then></if> <comment type="block">/* revision 0 looks the same regardless of
                            whether or not this is an incremental
                            dump, so just simplify things. */</comment>

  <comment type="block">/* Write out the UUID. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_get_uuid</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr>&amp;<name>uuid</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If we're not using deltas, use the previous version, for
     compatibility with svn 1.0.x. */</comment>
  <expr_stmt><expr><name>version</name> = <name>SVN_REPOS_DUMPFILE_FORMAT_VERSION</name></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<name>use_deltas</name></expr>)</condition><then>
    <expr_stmt><expr><name>version</name>--</expr>;</expr_stmt></then></if>

  <comment type="block">/* Write out "general" metadata for the dumpfile.  In this case, a
     magic header followed by a dumpfile format version. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_printf</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>,
                            <argument><expr><name>SVN_REPOS_DUMPFILE_MAGIC_HEADER</name> ": %d\n\n"</expr></argument>,
                            <argument><expr><name>version</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_printf</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>SVN_REPOS_DUMPFILE_UUID</name>
                            ": %s\n\n"</expr></argument>, <argument><expr><name>uuid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Main loop:  we're going to dump revision i.  */</comment>
  <for>for (<init><expr><name>i</name> = <name>start_rev</name></expr>;</init> <condition><expr><name>i</name> &lt;= <name>end_rev</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>from_rev</name></decl>, <decl><type ref="prev"/><name>to_rev</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>to_root</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>use_deltas_for_rev</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Check for cancellation. */</comment>
      <if>if <condition>(<expr><name>cancel_func</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>cancel_func</name><argument_list>(<argument><expr><name>cancel_baton</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

      <comment type="block">/* Special-case the initial revision dump: it needs to contain
         *all* nodes, because it's the foundation of all future
         revisions in the dumpfile. */</comment>
      <if>if <condition>(<expr>(<name>i</name> == <name>start_rev</name>) &amp;&amp; (! <name>incremental</name>)</expr>)</condition><then>
        <block>{
          <comment type="block">/* Special-special-case a dump of revision 0. */</comment>
          <if>if <condition>(<expr><name>i</name> == 0</expr>)</condition><then>
            <block>{
              <comment type="block">/* Just write out the one revision 0 record and move on.
                 The parser might want to use its properties. */</comment>
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>write_revision_record</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>to_rev</name> = 0</expr>;</expr_stmt>
              <goto>goto <name>loop_end</name>;</goto>
            }</block></then></if>

          <comment type="block">/* Compare START_REV to revision 0, so that everything
             appears to be added.  */</comment>
          <expr_stmt><expr><name>from_rev</name> = 0</expr>;</expr_stmt>
          <expr_stmt><expr><name>to_rev</name> = <name>i</name></expr>;</expr_stmt>
        }</block></then>
      <else>else
        <block>{
          <comment type="block">/* In the normal case, we want to compare consecutive revs. */</comment>
          <expr_stmt><expr><name>from_rev</name> = <name>i</name> - 1</expr>;</expr_stmt>
          <expr_stmt><expr><name>to_rev</name> = <name>i</name></expr>;</expr_stmt>
        }</block></else></if>

      <comment type="block">/* Write the revision record. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>write_revision_record</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>to_rev</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Fetch the editor which dumps nodes to a file.  Regardless of
         what we've been told, don't use deltas for the first rev of a
         non-incremental dump. */</comment>
      <expr_stmt><expr><name>use_deltas_for_rev</name> = <name>use_deltas</name> &amp;&amp; (<name>incremental</name> || <name>i</name> != <name>start_rev</name>)</expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_dump_editor</name><argument_list>(<argument><expr>&amp;<name>dump_editor</name></expr></argument>, <argument><expr>&amp;<name>dump_edit_baton</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>to_rev</name></expr></argument>,
                              <argument><expr>"/"</expr></argument>, <argument><expr><name>stream</name></expr></argument>, <argument><expr><name>feedback_stream</name></expr></argument>, <argument><expr><name>start_rev</name></expr></argument>,
                              <argument><expr><name>use_deltas_for_rev</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Drive the editor in one way or another. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_revision_root</name><argument_list>(<argument><expr>&amp;<name>to_root</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>to_rev</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* If this is the first revision of a non-incremental dump,
         we're in for a full tree dump.  Otherwise, we want to simply
         replay the revision.  */</comment>
      <if>if <condition>(<expr>(<name>i</name> == <name>start_rev</name>) &amp;&amp; (! <name>incremental</name>)</expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>from_root</name></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_revision_root</name><argument_list>(<argument><expr>&amp;<name>from_root</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>from_rev</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_repos_dir_delta2</name><argument_list>(<argument><expr><name>from_root</name></expr></argument>, <argument><expr>"/"</expr></argument>, <argument><expr>""</expr></argument>,
                                       <argument><expr><name>to_root</name></expr></argument>, <argument><expr>"/"</expr></argument>,
                                       <argument><expr><name>dump_editor</name></expr></argument>, <argument><expr><name>dump_edit_baton</name></expr></argument>,
                                       <argument><expr><name>NULL</name></expr></argument>,
                                       <argument><expr><name>NULL</name></expr></argument>,
                                       <argument><expr><name>FALSE</name></expr></argument>, <comment type="block">/* don't send text-deltas */</comment>
                                       <argument><expr><name>svn_depth_infinity</name></expr></argument>,
                                       <argument><expr><name>FALSE</name></expr></argument>, <comment type="block">/* don't send entry props */</comment>
                                       <argument><expr><name>FALSE</name></expr></argument>, <comment type="block">/* don't ignore ancestry */</comment>
                                       <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
      <else>else
        <block>{
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_repos_replay2</name><argument_list>(<argument><expr><name>to_root</name></expr></argument>, <argument><expr>""</expr></argument>, <argument><expr><name>SVN_INVALID_REVNUM</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                                    <argument><expr><name>dump_editor</name></expr></argument>, <argument><expr><name>dump_edit_baton</name></expr></argument>,
                                    <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>

    <label><name>loop_end</name>:</label>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_printf</name><argument_list>(<argument><expr><name>feedback_stream</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>,
                                <argument><expr><name>dumping</name>
                                ? <call><name>_</name><argument_list>(<argument><expr>"* Dumped revision %ld.\n"</expr></argument>)</argument_list></call>
                                : <call><name>_</name><argument_list>(<argument><expr>"* Verified revision %ld.\n"</expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><name>to_rev</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_repos_dump_fs</name><parameter_list>(<param><decl><type><name>svn_repos_t</name> *</type><name>repos</name></decl></param>,
                  <param><decl><type><name>svn_stream_t</name> *</type><name>stream</name></decl></param>,
                  <param><decl><type><name>svn_stream_t</name> *</type><name>feedback_stream</name></decl></param>,
                  <param><decl><type><name>svn_revnum_t</name></type> <name>start_rev</name></decl></param>,
                  <param><decl><type><name>svn_revnum_t</name></type> <name>end_rev</name></decl></param>,
                  <param><decl><type><name>svn_boolean_t</name></type> <name>incremental</name></decl></param>,
                  <param><decl><type><name>svn_cancel_func_t</name></type> <name>cancel_func</name></decl></param>,
                  <param><decl><type><name>void</name> *</type><name>cancel_baton</name></decl></param>,
                  <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>svn_repos_dump_fs2</name><argument_list>(<argument><expr><name>repos</name></expr></argument>, <argument><expr><name>stream</name></expr></argument>, <argument><expr><name>feedback_stream</name></expr></argument>, <argument><expr><name>start_rev</name></expr></argument>,
                            <argument><expr><name>end_rev</name></expr></argument>, <argument><expr><name>incremental</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>cancel_func</name></expr></argument>,
                            <argument><expr><name>cancel_baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<comment type="block">/*----------------------------------------------------------------------*/</comment>
<escape char="0xc"/>
<comment type="block">/* verify, based on dump */</comment>


<comment type="block">/* Creating a new revision that changes /A/B/E/bravo means creating new
   directory listings for /, /A, /A/B, and /A/B/E in the new revision, with
   each entry not changed in the new revision a link back to the entry in a
   previous revision.  svn_repos_replay()ing a revision does not verify that
   those links are correct.

   For paths actually changed in the revision we verify, we get directory
   contents or file length twice: once in the dump editor, and once here.
   We could create a new verify baton, store in it the changed paths, and
   skip those here, but that means building an entire wrapper editor and
   managing two levels of batons.  The impact from checking these entries
   twice should be minimal, while the code to avoid it is not.
*/</comment>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>verify_directory_entry</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl></param>, <param><decl><type><name>apr_ssize_t</name></type> <name>klen</name></decl></param>,
                       <param><decl><type><name>void</name> *</type><name>val</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>dir_baton</name> *</type><name>db</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>path</name> <init>= <expr><call><name>svn_path_join</name><argument_list>(<argument><expr><name><name>db</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr>(const <name>char</name> *)<name>key</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>dirents</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_filesize_t</name></type> <name>len</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_check_path</name><argument_list>(<argument><expr>&amp;<name>kind</name></expr></argument>, <argument><expr><name><name>db</name>-&gt;<name>edit_baton</name>-&gt;<name>fs_root</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <switch>switch <condition>(<expr><name>kind</name></expr>)</condition> <block>{
  <case>case <expr><name>svn_node_dir</name></expr>:
    <comment type="block">/* Getting this directory's contents is enough to ensure that our
       link to it is correct. */</comment>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_dir_entries</name><argument_list>(<argument><expr>&amp;<name>dirents</name></expr></argument>, <argument><expr><name><name>db</name>-&gt;<name>edit_baton</name>-&gt;<name>fs_root</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
  </case><case>case <expr><name>svn_node_file</name></expr>:
    <comment type="block">/* Getting this file's size is enough to ensure that our link to it
       is correct. */</comment>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_file_length</name><argument_list>(<argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr><name><name>db</name>-&gt;<name>edit_baton</name>-&gt;<name>fs_root</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <break>break;</break>
  </case><default>default:
    <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_NODE_UNEXPECTED_KIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Unexpected node kind %d for '%s'"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>kind</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return>
  </default>}</block></switch>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>verify_close_directory</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>dir_baton</name></decl></param>,
                <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>dir_baton</name> *</type><name>db</name> <init>= <expr><name>dir_baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>dirents</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_dir_entries</name><argument_list>(<argument><expr>&amp;<name>dirents</name></expr></argument>, <argument><expr><name><name>db</name>-&gt;<name>edit_baton</name>-&gt;<name>fs_root</name></name></expr></argument>,
                             <argument><expr><name><name>db</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_iter_apr_hash</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>dirents</name></expr></argument>, <argument><expr><name>verify_directory_entry</name></expr></argument>,
                            <argument><expr><name>dir_baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>close_directory</name><argument_list>(<argument><expr><name>dir_baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_repos_verify_fs</name><parameter_list>(<param><decl><type><name>svn_repos_t</name> *</type><name>repos</name></decl></param>,
                    <param><decl><type><name>svn_stream_t</name> *</type><name>feedback_stream</name></decl></param>,
                    <param><decl><type><name>svn_revnum_t</name></type> <name>start_rev</name></decl></param>,
                    <param><decl><type><name>svn_revnum_t</name></type> <name>end_rev</name></decl></param>,
                    <param><decl><type><name>svn_cancel_func_t</name></type> <name>cancel_func</name></decl></param>,
                    <param><decl><type><name>void</name> *</type><name>cancel_baton</name></decl></param>,
                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name> <init>= <expr><call><name>svn_repos_fs</name><argument_list>(<argument><expr><name>repos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>youngest</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>iterpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Determine the current youngest revision of the filesystem. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_youngest_rev</name><argument_list>(<argument><expr>&amp;<name>youngest</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Use default vals if necessary. */</comment>
  <if>if <condition>(<expr>! <call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name>start_rev</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <expr_stmt><expr><name>start_rev</name> = 0</expr>;</expr_stmt></then></if>
  <if>if <condition>(<expr>! <call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name>end_rev</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <expr_stmt><expr><name>end_rev</name> = <name>youngest</name></expr>;</expr_stmt></then></if>
  <if>if <condition>(<expr>! <name>feedback_stream</name></expr>)</condition><then>
    <expr_stmt><expr><name>feedback_stream</name> = <call><name>svn_stream_empty</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* Validate the revisions. */</comment>
  <if>if <condition>(<expr><name>start_rev</name> &gt; <name>end_rev</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_REPOS_BAD_ARGS</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Start revision %ld"
                               " is greater than end revision %ld"</expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><name>start_rev</name></expr></argument>, <argument><expr><name>end_rev</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
  <if>if <condition>(<expr><name>end_rev</name> &gt; <name>youngest</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_REPOS_BAD_ARGS</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><call><name>_</name><argument_list>(<argument><expr>"End revision %ld is invalid "
                               "(youngest revision is %ld)"</expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><name>end_rev</name></expr></argument>, <argument><expr><name>youngest</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <for>for (<init><expr><name>rev</name> = <name>start_rev</name></expr>;</init> <condition><expr><name>rev</name> &lt;= <name>end_rev</name></expr>;</condition> <incr><expr><name>rev</name>++</expr></incr>)
    <block>{
      <decl_stmt><decl><type><name>svn_delta_editor_t</name> *</type><name>dump_editor</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>void</name> *</type><name>dump_edit_baton</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>svn_delta_editor_t</name> *</type><name>cancel_editor</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>void</name> *</type><name>cancel_edit_baton</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>to_root</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Get cancellable dump editor, but with our close_directory handler. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_dump_editor</name><argument_list>(<argument><expr>(const <name>svn_delta_editor_t</name> **)&amp;<name>dump_editor</name></expr></argument>,
                              <argument><expr>&amp;<name>dump_edit_baton</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr>""</expr></argument>,
                              <argument><expr><call><name>svn_stream_empty</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>feedback_stream</name></expr></argument>,
                              <argument><expr><name>start_rev</name></expr></argument>,
                              <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <comment type="block">/* use_deltas, verify */</comment>
                              <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>dump_editor</name>-&gt;<name>close_directory</name></name> = <name>verify_close_directory</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_delta_get_cancellation_editor</name><argument_list>(<argument><expr><name>cancel_func</name></expr></argument>, <argument><expr><name>cancel_baton</name></expr></argument>,
                                                <argument><expr><name>dump_editor</name></expr></argument>, <argument><expr><name>dump_edit_baton</name></expr></argument>,
                                                <argument><expr>&amp;<name>cancel_editor</name></expr></argument>,
                                                <argument><expr>&amp;<name>cancel_edit_baton</name></expr></argument>,
                                                <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_revision_root</name><argument_list>(<argument><expr>&amp;<name>to_root</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_repos_replay2</name><argument_list>(<argument><expr><name>to_root</name></expr></argument>, <argument><expr>""</expr></argument>, <argument><expr><name>SVN_INVALID_REVNUM</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                                <argument><expr><name>cancel_editor</name></expr></argument>, <argument><expr><name>cancel_edit_baton</name></expr></argument>,
                                <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_printf</name><argument_list>(<argument><expr><name>feedback_stream</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>,
                                <argument><expr><call><name>_</name><argument_list>(<argument><expr>"* Verified revision %ld.\n"</expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><name>rev</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
</unit>
