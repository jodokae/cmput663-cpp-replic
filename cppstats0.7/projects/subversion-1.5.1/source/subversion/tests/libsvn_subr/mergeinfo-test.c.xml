<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/subversion-1.5.1/source/subversion/tests/libsvn_subr/mergeinfo-test.c"><comment type="block">/*
 * mergeinfo-test.c -- test the mergeinfo functions
 *
 * ====================================================================
 * Copyright (c) 2006-2007 CollabNet.  All rights reserved.
 *
 * This software is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at http://subversion.tigris.org/license-1.html.
 * If newer versions of this license are posted there, you may use a
 * newer version instead, at your option.
 *
 * This software consists of voluntary contributions made by many
 * individuals.  For exact contribution history, see the revision
 * history and logs, available at http://subversion.tigris.org/.
 * ====================================================================
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_hash.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_tables.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_pools.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_types.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_mergeinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"private/svn_mergeinfo_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../svn_test.h"</cpp:file></cpp:include>

<comment type="block">/* A quick way to create error messages.  */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>fail</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fmt</name></decl></param>, <param><decl><type>...</type></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>msg</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>msg</name> = <call><name>apr_pvsprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_TEST_FAILED</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_NBR_RANGES</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>

<comment type="block">/* Verify that INPUT is parsed properly, and returns an error if
   parsing fails, or incorret parsing is detected.  Assumes that INPUT
   contains only one path -&gt; ranges mapping, and that EXPECTED_RANGES points
   to the first range in an array whose size is greater than or equal to
   the number of ranges in INPUTS path -&gt; ranges mapping but less than
   MAX_NBR_RANGES.  If fewer than MAX_NBR_RANGES ranges are present, then the
   trailing expected_ranges should be have their end revision set to 0. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>verify_mergeinfo_parse</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>input</name></decl></param>,
                       <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>expected_path</name></decl></param>,
                       <param><decl><type><specifier>const</specifier> <name>svn_merge_range_t</name> *</type><name>expected_ranges</name></decl></param>,
                       <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>path_to_merge_ranges</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>

  <comment type="block">/* Test valid input. */</comment>
  <expr_stmt><expr><name>err</name> = <call><name>svn_mergeinfo_parse</name><argument_list>(<argument><expr>&amp;<name>path_to_merge_ranges</name></expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>err</name> || <call><name>apr_hash_count</name><argument_list>(<argument><expr><name>path_to_merge_ranges</name></expr></argument>)</argument_list></call> != 1</expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_TEST_FAILED</name></expr></argument>, <argument><expr><name>err</name></expr></argument>,
                             <argument><expr>"svn_mergeinfo_parse (%s) failed unexpectedly"</expr></argument>,
                             <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
  <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>path_to_merge_ranges</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>hi</name></expr>;</condition>
       <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>path</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>ranges</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_merge_range_t</name> *</type><name>range</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>ranges</name> = <name>val</name></expr>;</expr_stmt>
      <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr>(const <name>char</name> *) <name>path</name></expr></argument>, <argument><expr><name>expected_path</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
        <return>return <expr><call><name>fail</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"svn_mergeinfo_parse (%s) failed to parse the "
                    "correct path (%s)"</expr></argument>, <argument><expr><name>input</name></expr></argument>, <argument><expr><name>expected_path</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

      <comment type="block">/* Test each parsed range. */</comment>
      <for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name><name>ranges</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>)
        <block>{
          <expr_stmt><expr><name>range</name> = <call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>ranges</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr><name>svn_merge_range_t</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name><name>range</name>-&gt;<name>start</name></name> != <name><name>expected_ranges</name><index>[<expr><name>j</name></expr>]</index></name>.<name>start</name>
              || <name><name>range</name>-&gt;<name>end</name></name> != <name><name>expected_ranges</name><index>[<expr><name>j</name></expr>]</index></name>.<name>end</name>
              || <name><name>range</name>-&gt;<name>inheritable</name></name> != <name><name>expected_ranges</name><index>[<expr><name>j</name></expr>]</index></name>.<name>inheritable</name></expr>)</condition><then>
            <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_TEST_FAILED</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                     <argument><expr>"svn_mergeinfo_parse (%s) failed to "
                                     "parse the correct range"</expr></argument>,
                                     <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
        }</block></for>

      <comment type="block">/* Were we expecting any more ranges? */</comment>
      <if>if <condition>(<expr><name>j</name> &lt; <name>MAX_NBR_RANGES</name> - 1
          &amp;&amp; !<name><name>expected_ranges</name><index>[<expr><name>j</name></expr>]</index></name>.<name>end</name> == 0</expr>)</condition><then>
        <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_TEST_FAILED</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                 <argument><expr>"svn_mergeinfo_parse (%s) failed to "
                                 "produce the expected number of ranges"</expr></argument>,
                                  <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
    }</block></for>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Some of our own global variables (for simplicity), which map paths
   -&gt; merge ranges. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>apr_hash_t</name> *</type><name>info1</name></decl>, *<decl><type ref="prev"/><name>info2</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NBR_MERGEINFO_VALS</name></cpp:macro> <cpp:value>5</cpp:value></cpp:define>
<comment type="block">/* Valid mergeinfo values. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> * <specifier>const</specifier></type> <name><name>mergeinfo_vals</name><index>[<expr><name>NBR_MERGEINFO_VALS</name></expr>]</index></name> <init>=
  <expr><block>{
    <expr>"/trunk:1"</expr>,
    <expr>"/trunk/foo:1-6"</expr>,
    <expr>"/trunk: 5,7-9,10,11,13,14"</expr>,
    <expr>"/trunk: 3-10,11*,13,14"</expr>,
    <expr>"/branch: 1,2-18*,33*"</expr>
  }</block></expr></init></decl>;</decl_stmt>
<comment type="block">/* Paths corresponding to mergeinfo_vals. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> * <specifier>const</specifier></type> <name><name>mergeinfo_paths</name><index>[<expr><name>NBR_MERGEINFO_VALS</name></expr>]</index></name> <init>=
  <expr><block>{
    <expr>"/trunk"</expr>,
    <expr>"/trunk/foo"</expr>,
    <expr>"/trunk"</expr>,
    <expr>"/trunk"</expr>,
    <expr>"/branch"</expr>
  }</block></expr></init></decl>;</decl_stmt>
<comment type="block">/* First ranges from the paths identified by mergeinfo_paths. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>svn_merge_range_t</name></type> <name><name>mergeinfo_ranges</name><index>[<expr><name>NBR_MERGEINFO_VALS</name></expr>]</index><index>[<expr><name>MAX_NBR_RANGES</name></expr>]</index></name> <init>=
  <expr><block>{
    <expr><block>{ <expr><block>{<expr>0</expr>, <expr>1</expr>,  <expr><name>TRUE</name></expr>}</block></expr> }</block></expr>,
    <expr><block>{ <expr><block>{<expr>0</expr>, <expr>6</expr>,  <expr><name>TRUE</name></expr>}</block></expr> }</block></expr>,
    <expr><block>{ <expr><block>{<expr>4</expr>, <expr>5</expr>,  <expr><name>TRUE</name></expr>}</block></expr>, <expr><block>{ <expr>6</expr>, <expr>11</expr>, <expr><name>TRUE</name></expr> }</block></expr>, <expr><block>{<expr>12</expr>, <expr>14</expr>, <expr><name>TRUE</name></expr> }</block></expr> }</block></expr>,
    <expr><block>{ <expr><block>{<expr>2</expr>, <expr>10</expr>, <expr><name>TRUE</name></expr>}</block></expr>, <expr><block>{<expr>10</expr>, <expr>11</expr>, <expr><name>FALSE</name></expr>}</block></expr>, <expr><block>{<expr>12</expr>, <expr>14</expr>, <expr><name>TRUE</name></expr> }</block></expr> }</block></expr>,
    <expr><block>{ <expr><block>{<expr>0</expr>, <expr>1</expr>,  <expr><name>TRUE</name></expr>}</block></expr>, <expr><block>{ <expr>1</expr>, <expr>18</expr>, <expr><name>FALSE</name></expr>}</block></expr>, <expr><block>{<expr>32</expr>, <expr>33</expr>, <expr><name>FALSE</name></expr>}</block></expr> }</block></expr>
  }</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>test_parse_single_line_mergeinfo</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>msg</name></decl></param>,
                                 <param><decl><type><name>svn_boolean_t</name></type> <name>msg_only</name></decl></param>,
                                 <param><decl><type><name>svn_test_opts_t</name> *</type><name>opts</name></decl></param>,
                                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <expr_stmt><expr>*<name>msg</name> = "parse single line mergeinfo"</expr>;</expr_stmt>

  <if>if <condition>(<expr><name>msg_only</name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>NBR_MERGEINFO_VALS</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>verify_mergeinfo_parse</name><argument_list>(<argument><expr><name><name>mergeinfo_vals</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>mergeinfo_paths</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
                                   <argument><expr><name><name>mergeinfo_ranges</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>single_mergeinfo</name> <init>= <expr>"/trunk: 5,7-9,10,11,13,14"</expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>test_mergeinfo_dup</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>msg</name></decl></param>,
                   <param><decl><type><name>svn_boolean_t</name></type> <name>msg_only</name></decl></param>,
                   <param><decl><type><name>svn_test_opts_t</name> *</type><name>opts</name></decl></param>,
                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>orig_mergeinfo</name></decl>, *<decl><type ref="prev"/><name>copied_mergeinfo</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>rangelist</name></decl>;</decl_stmt>

  <expr_stmt><expr>*<name>msg</name> = "copy a mergeinfo data structure"</expr>;</expr_stmt>

  <if>if <condition>(<expr><name>msg_only</name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <comment type="block">/* Assure that copies which should be empty turn out that way. */</comment>
  <expr_stmt><expr><name>subpool</name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>orig_mergeinfo</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>copied_mergeinfo</name> = <call><name>svn_mergeinfo_dup</name><argument_list>(<argument><expr><name>orig_mergeinfo</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><call><name>apr_hash_count</name><argument_list>(<argument><expr><name>copied_mergeinfo</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
    <return>return <expr><call><name>fail</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"Copied mergeinfo should be empty"</expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Create some mergeinfo, copy it using another pool, then destroy
     the pool with which the original mergeinfo was created. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo_parse</name><argument_list>(<argument><expr>&amp;<name>orig_mergeinfo</name></expr></argument>, <argument><expr><name>single_mergeinfo</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>copied_mergeinfo</name> = <call><name>svn_mergeinfo_dup</name><argument_list>(<argument><expr><name>orig_mergeinfo</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><call><name>apr_hash_count</name><argument_list>(<argument><expr><name>copied_mergeinfo</name></expr></argument>)</argument_list></call> != 1</expr>)</condition><then>
    <return>return <expr><call><name>fail</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"Copied mergeinfo should contain one merge source"</expr></argument>)</argument_list></call></expr>;</return></then></if>
  <expr_stmt><expr><name>rangelist</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>copied_mergeinfo</name></expr></argument>, <argument><expr>"/trunk"</expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>! <name>rangelist</name></expr>)</condition><then>
    <return>return <expr><call><name>fail</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"Expected copied mergeinfo; got nothing"</expr></argument>)</argument_list></call></expr>;</return></then></if>
  <if>if <condition>(<expr><name><name>rangelist</name>-&gt;<name>nelts</name></name> != 3</expr>)</condition><then>
    <return>return <expr><call><name>fail</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"Copied mergeinfo should contain 3 revision ranges, "
                "rather than the %d it contains"</expr></argument>, <argument><expr><name><name>rangelist</name>-&gt;<name>nelts</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>test_parse_combine_rangeinfo</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>msg</name></decl></param>,
                             <param><decl><type><name>svn_boolean_t</name></type> <name>msg_only</name></decl></param>,
                             <param><decl><type><name>svn_test_opts_t</name> *</type><name>opts</name></decl></param>,
                             <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>result</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_merge_range_t</name> *</type><name>resultrange</name></decl>;</decl_stmt>

  <expr_stmt><expr>*<name>msg</name> = "parse single line mergeinfo and combine ranges"</expr>;</expr_stmt>

  <if>if <condition>(<expr><name>msg_only</name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo_parse</name><argument_list>(<argument><expr>&amp;<name>info1</name></expr></argument>, <argument><expr><name>single_mergeinfo</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><call><name>apr_hash_count</name><argument_list>(<argument><expr><name>info1</name></expr></argument>)</argument_list></call> != 1</expr>)</condition><then>
    <return>return <expr><call><name>fail</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"Wrong number of paths in parsed mergeinfo"</expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><name>result</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>info1</name></expr></argument>, <argument><expr>"/trunk"</expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<name>result</name></expr>)</condition><then>
    <return>return <expr><call><name>fail</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"Missing path in parsed mergeinfo"</expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* /trunk should have three ranges, 5-5, 7-11, 13-14 */</comment>
  <if>if <condition>(<expr><name><name>result</name>-&gt;<name>nelts</name></name> != 3</expr>)</condition><then>
    <return>return <expr><call><name>fail</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"Parsing failed to combine ranges"</expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><name>resultrange</name> = <call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>svn_merge_range_t</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name><name>resultrange</name>-&gt;<name>start</name></name> != 4 || <name><name>resultrange</name>-&gt;<name>end</name></name> != 5</expr>)</condition><then>
    <return>return <expr><call><name>fail</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"Range combining produced wrong result"</expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><name>resultrange</name> = <call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>svn_merge_range_t</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name><name>resultrange</name>-&gt;<name>start</name></name> != 6 || <name><name>resultrange</name>-&gt;<name>end</name></name> != 11</expr>)</condition><then>
    <return>return <expr><call><name>fail</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"Range combining produced wrong result"</expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><name>resultrange</name> = <call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr>2</expr></argument>, <argument><expr><name>svn_merge_range_t</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name><name>resultrange</name>-&gt;<name>start</name></name> != 12 || <name><name>resultrange</name>-&gt;<name>end</name></name> != 14</expr>)</condition><then>
    <return>return <expr><call><name>fail</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"Range combining produced wrong result"</expr></argument>)</argument_list></call></expr>;</return></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NBR_BROKEN_MERGEINFO_VALS</name></cpp:macro> <cpp:value>38</cpp:value></cpp:define>
<comment type="block">/* Invalid mergeinfo values. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> * <specifier>const</specifier></type> <name><name>broken_mergeinfo_vals</name><index>[<expr><name>NBR_BROKEN_MERGEINFO_VALS</name></expr>]</index></name> <init>=
  <expr><block>{
    <comment type="block">/* Invalid grammar  */</comment>
    <expr>"/missing-revs"</expr>,
    <expr>"/trunk: 5,7-9,10,11,13,14,"</expr>,
    <expr>"/trunk 5,7-9,10,11,13,14"</expr>,
    <expr>"/trunk:5 7--9 10 11 13 14"</expr>,
    <comment type="block">/* Unordered revs   */</comment>
    <expr>"/trunk:3-6,15,18,9,22"</expr>,
    <expr>"/trunk:5,3"</expr>,
    <expr>"/trunk:3-6*,15*,18*,9,22*"</expr>,
    <expr>"/trunk:5,3*"</expr>,
    <comment type="block">/* Overlapping revs differing inheritability */</comment>
    <expr>"/trunk:5-9*,9"</expr>,
    <expr>"/trunk:5,5-9*"</expr>,
    <expr>"/trunk:5-9,9*"</expr>,
    <expr>"/trunk:5*,5-9"</expr>,
    <expr>"/trunk:4,4*"</expr>,
    <expr>"/trunk:4*,4"</expr>,
    <expr>"/trunk:3-7*,4-23"</expr>,
    <expr>"/trunk:3-7,4-23*"</expr>,
    <comment type="block">/* Overlapping revs same inheritability */</comment>
    <expr>"/trunk:5-9*,9*"</expr>,
    <expr>"/trunk:5*,5-9*"</expr>, 
    <expr>"/trunk:5-9,9"</expr>,
    <expr>"/trunk:5,5-9"</expr>,
    <expr>"/trunk:4,4"</expr>,
    <expr>"/trunk:4*,4*"</expr>,
    <expr>"/trunk:3-7,4-23"</expr>,
    <expr>"/trunk:3-7*,4-23*"</expr>,
    <comment type="block">/* Reversed revision ranges */</comment>
    <expr>"/trunk:22-20"</expr>,
    <expr>"/trunk:22-20*"</expr>,
    <expr>"/trunk:3,7-12,22-20,25"</expr>,
    <expr>"/trunk:3,7,22-20*,25-30"</expr>,
    <comment type="block">/* Range with same start and end revision */</comment>
    <expr>"/trunk:22-22"</expr>,
    <expr>"/trunk:22-22*"</expr>,
    <expr>"/trunk:3,7-12,20-20,25"</expr>,
    <expr>"/trunk:3,7,20-20*,25-30"</expr>,
    <comment type="block">/* path mapped to range with no revisions */</comment>
    <expr>"/trunk:"</expr>,
    <expr>"/trunk:2-9\n/branch:"</expr>,
    <comment type="block">/* No path */</comment>
    <expr>":1-3"</expr>,
    <comment type="block">/* Invalid revisions */</comment>
    <expr>"trunk:a-3"</expr>,
    <expr>"branch:3-four"</expr>,
    <expr>"trunk:yadayadayada"</expr>
  }</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>test_parse_broken_mergeinfo</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>msg</name></decl></param>,
                            <param><decl><type><name>svn_boolean_t</name></type> <name>msg_only</name></decl></param>,
                            <param><decl><type><name>svn_test_opts_t</name> *</type><name>opts</name></decl></param>,
                            <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>
  <expr_stmt><expr>*<name>msg</name> = "parse broken single line mergeinfo"</expr>;</expr_stmt>

  <if>if <condition>(<expr><name>msg_only</name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <comment type="block">/* Trigger some error(s) with mal-formed input. */</comment>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>NBR_BROKEN_MERGEINFO_VALS</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <expr_stmt><expr><name>err</name> = <call><name>svn_mergeinfo_parse</name><argument_list>(<argument><expr>&amp;<name>info1</name></expr></argument>, <argument><expr><name><name>broken_mergeinfo_vals</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>err</name> == <name>SVN_NO_ERROR</name></expr>)</condition><then>
        <block>{
          <return>return <expr><call><name>fail</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"svn_mergeinfo_parse (%s) failed to detect an error"</expr></argument>,
                      <argument><expr><name><name>broken_mergeinfo_vals</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then>
      <else>else <if>if <condition>(<expr><name><name>err</name>-&gt;<name>apr_err</name></name> != <name>SVN_ERR_MERGEINFO_PARSE_ERROR</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><call><name>fail</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"svn_mergeinfo_parse (%s) returned some error other"
                      " than SVN_ERR_MERGEINFO_PARSE_ERROR"</expr></argument>,
                      <argument><expr><name><name>broken_mergeinfo_vals</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then>
      <else>else
        <block>{
          <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if></else></if>
    }</block></for>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>mergeinfo1</name> <init>= <expr>"/trunk: 3,5,7-9,10,11,13,14\n/fred:8-10"</expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NBR_RANGELIST_DELTAS</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>


<comment type="block">/* Convert a single svn_merge_range_t * back into an svn_stringbuf_t *.  */</comment>
<function><type><specifier>static</specifier> <name>char</name> *</type>
<name>range_to_string</name><parameter_list>(<param><decl><type><name>svn_merge_range_t</name> *</type><name>range</name></decl></param>,
                <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name><name>range</name>-&gt;<name>start</name></name> == <name><name>range</name>-&gt;<name>end</name></name> - 1</expr>)</condition><then>
    <return>return <expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%ld%s"</expr></argument>, <argument><expr><name><name>range</name>-&gt;<name>end</name></name></expr></argument>,
                        <argument><expr><name><name>range</name>-&gt;<name>inheritable</name></name>
                        ? "" : <name>SVN_MERGEINFO_NONINHERITABLE_STR</name></expr></argument>)</argument_list></call></expr>;</return></then>
  <else>else
    <return>return <expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%ld-%ld%s"</expr></argument>, <argument><expr><name><name>range</name>-&gt;<name>start</name></name> + 1</expr></argument>,
                        <argument><expr><name><name>range</name>-&gt;<name>end</name></name></expr></argument>, <argument><expr><name><name>range</name>-&gt;<name>inheritable</name></name>
                        ? "" : <name>SVN_MERGEINFO_NONINHERITABLE_STR</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>


<comment type="block">/* Verify that ACTUAL_RANGELIST matches EXPECTED_RANGES (an array of
   NBR_EXPECTED length).  Return an error based careful examination if
   they do not match.  FUNC_VERIFIED is the name of the API being
   verified (e.g. "svn_rangelist_intersect"), while TYPE is a word
   describing what the ranges being examined represent. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>verify_ranges_match</name><parameter_list>(<param><decl><type><name>apr_array_header_t</name> *</type><name>actual_rangelist</name></decl></param>,
                    <param><decl><type><name>svn_merge_range_t</name> *</type><name>expected_ranges</name></decl></param>, <param><decl><type><name>int</name></type> <name>nbr_expected</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>func_verified</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>type</name></decl></param>,
                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><name><name>actual_rangelist</name>-&gt;<name>nelts</name></name> != <name>nbr_expected</name></expr>)</condition><then>
    <return>return <expr><call><name>fail</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%s should report %d range %ss, but found %d"</expr></argument>,
                <argument><expr><name>func_verified</name></expr></argument>, <argument><expr><name>nbr_expected</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name><name>actual_rangelist</name>-&gt;<name>nelts</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>actual_rangelist</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <decl_stmt><decl><type><name>svn_merge_range_t</name> *</type><name>range</name> <init>= <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>actual_rangelist</name></expr></argument>, <argument><expr><name>i</name></expr></argument>,
                                               <argument><expr><name>svn_merge_range_t</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><name><name>range</name>-&gt;<name>start</name></name> != <name><name>expected_ranges</name><index>[<expr><name>i</name></expr>]</index></name>.<name>start</name>
          || <name><name>range</name>-&gt;<name>end</name></name> != <name><name>expected_ranges</name><index>[<expr><name>i</name></expr>]</index></name>.<name>end</name>
          || <name><name>range</name>-&gt;<name>inheritable</name></name> != <name><name>expected_ranges</name><index>[<expr><name>i</name></expr>]</index></name>.<name>inheritable</name></expr>)</condition><then>
        <return>return <expr><call><name>fail</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%s should report range %s, but found %s"</expr></argument>,
                    <argument><expr><name>func_verified</name></expr></argument>,
                    <argument><expr><call><name>range_to_string</name><argument_list>(<argument><expr>&amp;<name><name>expected_ranges</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><call><name>range_to_string</name><argument_list>(<argument><expr><name>range</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
    }</block></for>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Verify that DELTAS matches EXPECTED_DELTAS (both expected to
   contain only a rangelist for "/trunk").  Return an error based
   careful examination if they do not match.  FUNC_VERIFIED is the
   name of the API being verified (e.g. "svn_mergeinfo_diff"), while
   TYPE is a word describing what the deltas being examined
   represent. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>verify_mergeinfo_deltas</name><parameter_list>(<param><decl><type><name>apr_hash_t</name> *</type><name>deltas</name></decl></param>, <param><decl><type><name>svn_merge_range_t</name> *</type><name>expected_deltas</name></decl></param>,
                        <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>func_verified</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>type</name></decl></param>,
                        <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>rangelist</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><call><name>apr_hash_count</name><argument_list>(<argument><expr><name>deltas</name></expr></argument>)</argument_list></call> != 1</expr>)</condition><then>
    <comment type="block">/* Deltas on "/trunk" expected. */</comment>
    <return>return <expr><call><name>fail</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%s should report 1 path %s, but found %d"</expr></argument>,
                <argument><expr><name>func_verified</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><call><name>apr_hash_count</name><argument_list>(<argument><expr><name>deltas</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><name>rangelist</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>deltas</name></expr></argument>, <argument><expr>"/trunk"</expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>rangelist</name> == <name>NULL</name></expr>)</condition><then>
    <return>return <expr><call><name>fail</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%s failed to produce a rangelist for /trunk"</expr></argument>,
                <argument><expr><name>func_verified</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <return>return <expr><call><name>verify_ranges_match</name><argument_list>(<argument><expr><name>rangelist</name></expr></argument>, <argument><expr><name>expected_deltas</name></expr></argument>, <argument><expr><name>NBR_RANGELIST_DELTAS</name></expr></argument>,
                             <argument><expr><name>func_verified</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>test_diff_mergeinfo</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>msg</name></decl></param>,
                    <param><decl><type><name>svn_boolean_t</name></type> <name>msg_only</name></decl></param>,
                    <param><decl><type><name>svn_test_opts_t</name> *</type><name>opts</name></decl></param>,
                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>deleted</name></decl>, *<decl><type ref="prev"/><name>added</name></decl>, *<decl><type ref="prev"/><name>from</name></decl>, *<decl><type ref="prev"/><name>to</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_merge_range_t</name></type> <name><name>expected_rangelist_deletions</name><index>[<expr><name>NBR_RANGELIST_DELTAS</name></expr>]</index></name> <init>=
    <expr><block>{ <expr><block>{<expr>6</expr>, <expr>7</expr>, <expr><name>TRUE</name></expr>}</block></expr>, <expr><block>{<expr>8</expr>, <expr>9</expr>, <expr><name>TRUE</name></expr>}</block></expr>, <expr><block>{<expr>10</expr>, <expr>11</expr>, <expr><name>TRUE</name></expr>}</block></expr>, <expr><block>{<expr>32</expr>, <expr>34</expr>, <expr><name>TRUE</name></expr>}</block></expr> }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_merge_range_t</name></type> <name><name>expected_rangelist_additions</name><index>[<expr><name>NBR_RANGELIST_DELTAS</name></expr>]</index></name> <init>=
    <expr><block>{ <expr><block>{<expr>1</expr>, <expr>2</expr>, <expr><name>TRUE</name></expr>}</block></expr>, <expr><block>{<expr>4</expr>, <expr>6</expr>, <expr><name>TRUE</name></expr>}</block></expr>, <expr><block>{<expr>12</expr>, <expr>16</expr>, <expr><name>TRUE</name></expr>}</block></expr>, <expr><block>{<expr>29</expr>, <expr>30</expr>, <expr><name>TRUE</name></expr>}</block></expr> }</block></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr>*<name>msg</name> = "diff of mergeinfo"</expr>;</expr_stmt>
  <if>if <condition>(<expr><name>msg_only</name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo_parse</name><argument_list>(<argument><expr>&amp;<name>from</name></expr></argument>, <argument><expr>"/trunk: 1,3-4,7,9,11-12,31-34"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo_parse</name><argument_list>(<argument><expr>&amp;<name>to</name></expr></argument>, <argument><expr>"/trunk: 1-6,12-16,30-32"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* On /trunk: deleted (7, 9, 11, 33-34) and added (2, 5-6, 13-16, 30) */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo_diff</name><argument_list>(<argument><expr>&amp;<name>deleted</name></expr></argument>, <argument><expr>&amp;<name>added</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>to</name></expr></argument>,
                             <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Verify calculation of range list deltas. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>verify_mergeinfo_deltas</name><argument_list>(<argument><expr><name>deleted</name></expr></argument>, <argument><expr><name>expected_rangelist_deletions</name></expr></argument>,
                                  <argument><expr>"svn_mergeinfo_diff"</expr></argument>, <argument><expr>"deletion"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>verify_mergeinfo_deltas</name><argument_list>(<argument><expr><name>added</name></expr></argument>, <argument><expr><name>expected_rangelist_additions</name></expr></argument>,
                                  <argument><expr>"svn_mergeinfo_diff"</expr></argument>, <argument><expr>"addition"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>test_rangelist_reverse</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>msg</name></decl></param>,
                       <param><decl><type><name>svn_boolean_t</name></type> <name>msg_only</name></decl></param>,
                       <param><decl><type><name>svn_test_opts_t</name> *</type><name>opts</name></decl></param>,
                       <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>rangelist</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_merge_range_t</name></type> <name><name>expected_rangelist</name><index>[<expr>3</expr>]</index></name> <init>=
    <expr><block>{ <expr><block>{<expr>10</expr>, <expr>9</expr>, <expr><name>TRUE</name></expr>}</block></expr>, <expr><block>{<expr>7</expr>, <expr>4</expr>, <expr><name>TRUE</name></expr>}</block></expr>, <expr><block>{<expr>3</expr>, <expr>2</expr>, <expr><name>TRUE</name></expr>}</block></expr> }</block></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr>*<name>msg</name> = "reversal of rangelist"</expr>;</expr_stmt>
  <if>if <condition>(<expr><name>msg_only</name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo_parse</name><argument_list>(<argument><expr>&amp;<name>info1</name></expr></argument>, <argument><expr>"/trunk: 3,5-7,10"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rangelist</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>info1</name></expr></argument>, <argument><expr>"/trunk"</expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_rangelist_reverse</name><argument_list>(<argument><expr><name>rangelist</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><call><name>verify_ranges_match</name><argument_list>(<argument><expr><name>rangelist</name></expr></argument>, <argument><expr><name>expected_rangelist</name></expr></argument>, <argument><expr>3</expr></argument>,
                             <argument><expr>"svn_rangelist_reverse"</expr></argument>, <argument><expr>"reversal"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>test_rangelist_intersect</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>msg</name></decl></param>,
                         <param><decl><type><name>svn_boolean_t</name></type> <name>msg_only</name></decl></param>,
                         <param><decl><type><name>svn_test_opts_t</name> *</type><name>opts</name></decl></param>,
                         <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>rangelist1</name></decl>, *<decl><type ref="prev"/><name>rangelist2</name></decl>, *<decl><type ref="prev"/><name>intersection</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_merge_range_t</name></type> <name><name>expected_intersection</name><index>[]</index></name> <init>=
    <expr><block>{ <expr><block>{<expr>0</expr>, <expr>1</expr>, <expr><name>TRUE</name></expr>}</block></expr>, <expr><block>{<expr>2</expr>, <expr>4</expr>, <expr><name>TRUE</name></expr>}</block></expr>, <expr><block>{<expr>11</expr>, <expr>12</expr>, <expr><name>TRUE</name></expr>}</block></expr>, <expr><block>{<expr>30</expr>, <expr>32</expr>, <expr><name>TRUE</name></expr>}</block></expr>,
      <expr><block>{<expr>39</expr>, <expr>42</expr>, <expr><name>TRUE</name></expr>}</block></expr> }</block></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr>*<name>msg</name> = "intersection of rangelists"</expr>;</expr_stmt>
  <if>if <condition>(<expr><name>msg_only</name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo_parse</name><argument_list>(<argument><expr>&amp;<name>info1</name></expr></argument>, <argument><expr>"/trunk: 1-6,12-16,30-32,40-42"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo_parse</name><argument_list>(<argument><expr>&amp;<name>info2</name></expr></argument>, <argument><expr>"/trunk: 1,3-4,7,9,11-12,31-34,38-44"</expr></argument>, 
                              <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rangelist1</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>info1</name></expr></argument>, <argument><expr>"/trunk"</expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rangelist2</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>info2</name></expr></argument>, <argument><expr>"/trunk"</expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_rangelist_intersect</name><argument_list>(<argument><expr>&amp;<name>intersection</name></expr></argument>, <argument><expr><name>rangelist1</name></expr></argument>, <argument><expr><name>rangelist2</name></expr></argument>,
                                  <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><call><name>verify_ranges_match</name><argument_list>(<argument><expr><name>intersection</name></expr></argument>, <argument><expr><name>expected_intersection</name></expr></argument>, <argument><expr>5</expr></argument>,
                             <argument><expr>"svn_rangelist_intersect"</expr></argument>, <argument><expr>"intersect"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>test_mergeinfo_intersect</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>msg</name></decl></param>,
                         <param><decl><type><name>svn_boolean_t</name></type> <name>msg_only</name></decl></param>,
                         <param><decl><type><name>svn_test_opts_t</name> *</type><name>opts</name></decl></param>,
                         <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_merge_range_t</name></type> <name><name>expected_intersection</name><index>[<expr>3</expr>]</index></name> <init>=
    <expr><block>{ <expr><block>{<expr>0</expr>, <expr>1</expr>, <expr><name>TRUE</name></expr>}</block></expr>, <expr><block>{<expr>2</expr>, <expr>4</expr>, <expr><name>TRUE</name></expr>}</block></expr>, <expr><block>{<expr>11</expr>, <expr>12</expr>, <expr><name>TRUE</name></expr>}</block></expr> }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>rangelist</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>intersection</name></decl>;</decl_stmt>

  <expr_stmt><expr>*<name>msg</name> = "intersection of mergeinfo"</expr>;</expr_stmt>
  <if>if <condition>(<expr><name>msg_only</name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo_parse</name><argument_list>(<argument><expr>&amp;<name>info1</name></expr></argument>, <argument><expr>"/trunk: 1-6,12-16\n/foo: 31"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo_parse</name><argument_list>(<argument><expr>&amp;<name>info2</name></expr></argument>, <argument><expr>"/trunk: 1,3-4,7,9,11-12"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo_intersect</name><argument_list>(<argument><expr>&amp;<name>intersection</name></expr></argument>, <argument><expr><name>info1</name></expr></argument>, <argument><expr><name>info2</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><call><name>apr_hash_count</name><argument_list>(<argument><expr><name>intersection</name></expr></argument>)</argument_list></call> != 1</expr>)</condition><then>
    <return>return <expr><call><name>fail</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"Unexpected number of rangelists in mergeinfo "
                "intersection: Expected %d, found %d"</expr></argument>, <argument><expr>1</expr></argument>,
                <argument><expr><call><name>apr_hash_count</name><argument_list>(<argument><expr><name>intersection</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><name>rangelist</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>intersection</name></expr></argument>, <argument><expr>"/trunk"</expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>verify_ranges_match</name><argument_list>(<argument><expr><name>rangelist</name></expr></argument>, <argument><expr><name>expected_intersection</name></expr></argument>, <argument><expr>3</expr></argument>,
                             <argument><expr>"svn_rangelist_intersect"</expr></argument>, <argument><expr>"intersect"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>test_merge_mergeinfo</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>msg</name></decl></param>,
                     <param><decl><type><name>svn_boolean_t</name></type> <name>msg_only</name></decl></param>,
                     <param><decl><type><name>svn_test_opts_t</name> *</type><name>opts</name></decl></param>,
                     <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <comment type="block">/* Structures and constants for test_merge_mergeinfo() */</comment>
  <comment type="block">/* Number of svn_mergeinfo_merge test sets */</comment>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NBR_MERGEINFO_MERGES</name></cpp:macro> <cpp:value>12</cpp:value></cpp:define>

  <comment type="block">/* Maximum number of expected paths in the results
     of the svn_mergeinfo_merge tests */</comment>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_NBR_MERGEINFO_PATHS</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>

  <comment type="block">/* Maximum number of expected ranges in the results
     of the svn_mergeinfo_merge tests */</comment>
  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_NBR_MERGEINFO_RANGES</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define>

  <comment type="block">/* Struct to store a path and it's expected ranges,
     i.e. the expected result of an svn_mergeinfo_merge
     test. */</comment>
  <struct>struct <name>mergeinfo_merge_path_range</name>
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_merge_range_t</name></type> <name><name>expected_rngs</name><index>[<expr><name>MAX_NBR_MERGEINFO_RANGES</name></expr>]</index></name></decl>;</decl_stmt>
    }</block>;</struct>

  <comment type="block">/* Struct for svn_mergeinfo_merge test data.
     If MERGEINFO1 and MERGEINFO2 are parsed to a hash with
     svn_mergeinfo_parse() and then merged with svn_mergeinfo_merge(),
     the resulting hash should have EXPECTED_PATHS number of paths
     mapped to rangelists and each mapping is described by PATH_RNGS
     where PATH_RNGS-&gt;PATH is not NULL. */</comment>
  <struct>struct <name>mergeinfo_merge_test_data</name>
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>mergeinfo1</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>mergeinfo2</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>expected_paths</name></decl>;</decl_stmt>
      <decl_stmt><decl><type>struct <name>mergeinfo_merge_path_range</name></type> <name><name>path_rngs</name><index>[<expr><name>MAX_NBR_MERGEINFO_PATHS</name></expr>]</index></name></decl>;</decl_stmt>
    }</block>;</struct>

  <decl_stmt><decl><type><specifier>static</specifier> struct <name>mergeinfo_merge_test_data</name></type> <name><name>mergeinfo</name><index>[<expr><name>NBR_MERGEINFO_MERGES</name></expr>]</index></name> <init>=
    <expr><block>{
      <comment type="block">/* One path, intersecting inheritable ranges */</comment>
      <expr><block>{ <expr>"/trunk: 5-10"</expr>,
        <expr>"/trunk: 6"</expr>, <expr>1</expr>,
        <expr><block>{ <expr><block>{<expr>"/trunk"</expr>, <expr><block>{ <expr><block>{<expr>4</expr>, <expr>10</expr>, <expr><name>TRUE</name></expr>}</block></expr> }</block></expr> }</block></expr> }</block></expr> }</block></expr>,

      <comment type="block">/* One path, intersecting non-inheritable ranges */</comment>
      <expr><block>{ <expr>"/trunk: 5-10*"</expr>,
        <expr>"/trunk: 6*"</expr>, <expr>1</expr>,
        <expr><block>{ <expr><block>{<expr>"/trunk"</expr>, <expr><block>{ <expr><block>{<expr>4</expr>, <expr>10</expr>, <expr><name>FALSE</name></expr>}</block></expr> }</block></expr> }</block></expr> }</block></expr> }</block></expr>,

      <comment type="block">/* One path, intersecting ranges with different inheritability */</comment>
      <expr><block>{ <expr>"/trunk: 5-10"</expr>,
        <expr>"/trunk: 6*"</expr>, <expr>1</expr>,
        <expr><block>{ <expr><block>{<expr>"/trunk"</expr>, <expr><block>{ <expr><block>{<expr>4</expr>, <expr>10</expr>, <expr><name>TRUE</name></expr>}</block></expr> }</block></expr> }</block></expr> }</block></expr> }</block></expr>,

      <comment type="block">/* One path, intersecting ranges with different inheritability */</comment>
      <expr><block>{ <expr>"/trunk: 5-10*"</expr>,
        <expr>"/trunk: 6"</expr>, <expr>1</expr>,
        <expr><block>{ <expr><block>{<expr>"/trunk"</expr>, <expr><block>{ <expr><block>{<expr>4</expr>, <expr>5</expr>, <expr><name>FALSE</name></expr>}</block></expr>, <expr><block>{<expr>5</expr>, <expr>6</expr>, <expr><name>TRUE</name></expr>}</block></expr>, <expr><block>{<expr>6</expr>, <expr>10</expr>, <expr><name>FALSE</name></expr>}</block></expr> }</block></expr> }</block></expr> }</block></expr> }</block></expr>,

      <comment type="block">/* Adjacent ranges all inheritable ranges */</comment>
      <expr><block>{ <expr>"/trunk: 1,3,5-11,13"</expr>,
        <expr>"/trunk: 2,4,12,14-22"</expr>, <expr>1</expr>,
         <expr><block>{ <expr><block>{<expr>"/trunk"</expr>, <expr><block>{ <expr><block>{<expr>0</expr>, <expr>22</expr>, <expr><name>TRUE</name></expr>}</block></expr> }</block></expr> }</block></expr> }</block></expr> }</block></expr>,

      <comment type="block">/* Adjacent ranges all non-inheritable ranges */</comment>
      <expr><block>{ <expr>"/trunk: 1*,3*,5-11*,13*"</expr>,
        <expr>"/trunk: 2*,4*,12*,14-22*"</expr>, <expr>1</expr>,
         <expr><block>{ <expr><block>{<expr>"/trunk"</expr>, <expr><block>{ <expr><block>{<expr>0</expr>, <expr>22</expr>, <expr><name>FALSE</name></expr>}</block></expr> }</block></expr> }</block></expr> }</block></expr> }</block></expr>,

      <comment type="block">/* Adjacent ranges differing inheritability */</comment>
      <expr><block>{ <expr>"/trunk: 1*,3*,5-11*,13*"</expr>,
        <expr>"/trunk: 2,4,12,14-22"</expr>, <expr>1</expr>,
         <expr><block>{ <expr><block>{<expr>"/trunk"</expr>, <expr><block>{ <expr><block>{ <expr>0</expr>,  <expr>1</expr>, <expr><name>FALSE</name></expr>}</block></expr>, <expr><block>{ <expr>1</expr>,  <expr>2</expr>, <expr><name>TRUE</name></expr>}</block></expr>,
                        <expr><block>{ <expr>2</expr>,  <expr>3</expr>, <expr><name>FALSE</name></expr>}</block></expr>, <expr><block>{ <expr>3</expr>,  <expr>4</expr>, <expr><name>TRUE</name></expr>}</block></expr>,
                        <expr><block>{ <expr>4</expr>, <expr>11</expr>, <expr><name>FALSE</name></expr>}</block></expr>, <expr><block>{<expr>11</expr>, <expr>12</expr>, <expr><name>TRUE</name></expr>}</block></expr>,
                        <expr><block>{<expr>12</expr>, <expr>13</expr>, <expr><name>FALSE</name></expr>}</block></expr>, <expr><block>{<expr>13</expr>, <expr>22</expr>, <expr><name>TRUE</name></expr>}</block></expr> }</block></expr> }</block></expr> }</block></expr> }</block></expr>,

      <comment type="block">/* Adjacent ranges differing inheritability */</comment>
      <expr><block>{ <expr>"/trunk: 1,3,5-11,13"</expr>,
        <expr>"/trunk: 2*,4*,12*,14-22*"</expr>, <expr>1</expr>,
         <expr><block>{ <expr><block>{<expr>"/trunk"</expr>, <expr><block>{ <expr><block>{ <expr>0</expr>,  <expr>1</expr>, <expr><name>TRUE</name></expr>}</block></expr>, <expr><block>{ <expr>1</expr>,  <expr>2</expr>, <expr><name>FALSE</name></expr>}</block></expr>,
                        <expr><block>{ <expr>2</expr>,  <expr>3</expr>, <expr><name>TRUE</name></expr>}</block></expr>, <expr><block>{ <expr>3</expr>,  <expr>4</expr>, <expr><name>FALSE</name></expr>}</block></expr>,
                        <expr><block>{ <expr>4</expr>, <expr>11</expr>, <expr><name>TRUE</name></expr>}</block></expr>, <expr><block>{<expr>11</expr>, <expr>12</expr>, <expr><name>FALSE</name></expr>}</block></expr>,
                        <expr><block>{<expr>12</expr>, <expr>13</expr>, <expr><name>TRUE</name></expr>}</block></expr>, <expr><block>{<expr>13</expr>, <expr>22</expr>, <expr><name>FALSE</name></expr>}</block></expr> }</block></expr> }</block></expr> }</block></expr> }</block></expr>,

      <comment type="block">/* Two paths all inheritable ranges */</comment>
      <expr><block>{ <expr>"/trunk: 3,5,7-9,10,11,13,14\n/fred:8-10"</expr>,
        <expr>"/trunk: 1-4,6\n/fred:9-12"</expr>, <expr>2</expr>,
        <expr><block>{ <expr><block>{<expr>"/trunk"</expr>, <expr><block>{ <expr><block>{<expr>0</expr>, <expr>11</expr>, <expr><name>TRUE</name></expr>}</block></expr>, <expr><block>{<expr>12</expr>, <expr>14</expr>, <expr><name>TRUE</name></expr>}</block></expr> }</block></expr> }</block></expr>,
          <expr><block>{<expr>"/fred"</expr>,  <expr><block>{ <expr><block>{<expr>7</expr>, <expr>12</expr>, <expr><name>TRUE</name></expr>}</block></expr> }</block></expr> }</block></expr> }</block></expr> }</block></expr>,

      <comment type="block">/* Two paths all non-inheritable ranges */</comment>
      <expr><block>{ <expr>"/trunk: 3*,5*,7-9*,10*,11*,13*,14*\n/fred:8-10*"</expr>,
        <expr>"/trunk: 1-4*,6*\n/fred:9-12*"</expr>, <expr>2</expr>,
        <expr><block>{ <expr><block>{<expr>"/trunk"</expr>, <expr><block>{ <expr><block>{<expr>0</expr>, <expr>11</expr>, <expr><name>FALSE</name></expr>}</block></expr>, <expr><block>{<expr>12</expr>, <expr>14</expr>, <expr><name>FALSE</name></expr>}</block></expr> }</block></expr> }</block></expr>,
          <expr><block>{<expr>"/fred"</expr>,  <expr><block>{ <expr><block>{<expr>7</expr>, <expr>12</expr>, <expr><name>FALSE</name></expr>}</block></expr> }</block></expr> }</block></expr> }</block></expr> }</block></expr>,

      <comment type="block">/* Two paths mixed inheritability */</comment>
      <expr><block>{ <expr>"/trunk: 3,5*,7-9,10,11*,13,14\n/fred:8-10"</expr>,
        <expr>"/trunk: 1-4,6\n/fred:9-12*"</expr>, <expr>2</expr>,
        <expr><block>{ <expr><block>{<expr>"/trunk"</expr>, <expr><block>{ <expr><block>{ <expr>0</expr>,  <expr>4</expr>, <expr><name>TRUE</name></expr> }</block></expr>, <expr><block>{ <expr>4</expr>,  <expr>5</expr>, <expr><name>FALSE</name></expr>}</block></expr>, <expr><block>{<expr>5</expr>, <expr>10</expr>, <expr><name>TRUE</name></expr>}</block></expr>,
                       <expr><block>{<expr>10</expr>, <expr>11</expr>, <expr><name>FALSE</name></expr>}</block></expr>, <expr><block>{<expr>12</expr>, <expr>14</expr>, <expr><name>TRUE</name></expr> }</block></expr> }</block></expr> }</block></expr>,
          <expr><block>{<expr>"/fred"</expr>,  <expr><block>{ <expr><block>{ <expr>7</expr>, <expr>10</expr>, <expr><name>TRUE</name></expr> }</block></expr>, <expr><block>{<expr>10</expr>, <expr>12</expr>, <expr><name>FALSE</name></expr>}</block></expr> }</block></expr> }</block></expr> }</block></expr> }</block></expr>,

      <comment type="block">/* A slew of different paths but no ranges to be merged */</comment>
      <expr><block>{ <expr>"/trunk: 3,5-9*\n/betty: 2-4"</expr>,
        <expr>"/fred: 1-18\n/barney: 1,3-43"</expr>, <expr>4</expr>,
        <expr><block>{ <expr><block>{<expr>"/trunk"</expr>,  <expr><block>{ <expr><block>{<expr>2</expr>,  <expr>3</expr>, <expr><name>TRUE</name></expr>}</block></expr>, <expr><block>{<expr>4</expr>,  <expr>9</expr>, <expr><name>FALSE</name></expr>}</block></expr> }</block></expr> }</block></expr>,
          <expr><block>{<expr>"/betty"</expr>,  <expr><block>{ <expr><block>{<expr>1</expr>,  <expr>4</expr>, <expr><name>TRUE</name></expr>}</block></expr> }</block></expr> }</block></expr>,
          <expr><block>{<expr>"/barney"</expr>, <expr><block>{ <expr><block>{<expr>0</expr>,  <expr>1</expr>, <expr><name>TRUE</name></expr>}</block></expr>, <expr><block>{<expr>2</expr>, <expr>43</expr>, <expr><name>TRUE</name></expr>}</block></expr> }</block></expr> }</block></expr>,
          <expr><block>{<expr>"/fred"</expr>,   <expr><block>{ <expr><block>{<expr>0</expr>, <expr>18</expr>, <expr><name>TRUE</name></expr>}</block></expr> }</block></expr> }</block></expr> }</block></expr> }</block></expr>
    }</block></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr>*<name>msg</name> = "merging of mergeinfo hashs"</expr>;</expr_stmt>
  <if>if <condition>(<expr><name>msg_only</name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>NBR_MERGEINFO_MERGES</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo_parse</name><argument_list>(<argument><expr>&amp;<name>info1</name></expr></argument>, <argument><expr><name><name>mergeinfo</name><index>[<expr><name>i</name></expr>]</index></name>.<name>mergeinfo1</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo_parse</name><argument_list>(<argument><expr>&amp;<name>info2</name></expr></argument>, <argument><expr><name><name>mergeinfo</name><index>[<expr><name>i</name></expr>]</index></name>.<name>mergeinfo2</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo_merge</name><argument_list>(<argument><expr><name>info1</name></expr></argument>, <argument><expr><name>info2</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name><name>mergeinfo</name><index>[<expr><name>i</name></expr>]</index></name>.<name>expected_paths</name> != <call><name>apr_hash_count</name><argument_list>(<argument><expr><name>info1</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><call><name>fail</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"Wrong number of paths in merged mergeinfo"</expr></argument>)</argument_list></call></expr>;</return></then></if>
      <for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name><name>mergeinfo</name><index>[<expr><name>i</name></expr>]</index></name>.<name>expected_paths</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>)
        <block>{
          <decl_stmt><decl><type><name>int</name></type> <name>k</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>rangelist</name> <init>=
            <expr><call><name>apr_hash_get</name><argument_list>(<argument><expr><name>info1</name></expr></argument>, <argument><expr><name><name>mergeinfo</name><index>[<expr><name>i</name></expr>]</index></name>.<name><name>path_rngs</name><index>[<expr><name>j</name></expr>]</index></name>.<name>path</name></expr></argument>,
                         <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if>if <condition>(<expr>!<name>rangelist</name></expr>)</condition><then>
            <return>return <expr><call><name>fail</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"Missing path '%s' in merged mergeinfo"</expr></argument>,
                        <argument><expr><name><name>mergeinfo</name><index>[<expr><name>i</name></expr>]</index></name>.<name><name>path_rngs</name>-&gt;<name>path</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>
          <for>for (<init><expr><name>k</name> = 0</expr>;</init> <condition><expr><name>k</name> &lt; <name><name>rangelist</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>k</name>++</expr></incr>)
            <block>{
              <decl_stmt><decl><type><name>svn_merge_range_t</name> *</type><name>ranges</name> <init>=
                <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>rangelist</name></expr></argument>, <argument><expr><name>k</name></expr></argument>, <argument><expr><name>svn_merge_range_t</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
              <if>if <condition>(<expr><name><name>ranges</name>-&gt;<name>start</name></name>
                    != <name><name>mergeinfo</name><index>[<expr><name>i</name></expr>]</index></name>.<name><name>path_rngs</name><index>[<expr><name>j</name></expr>]</index></name>.<name><name>expected_rngs</name><index>[<expr><name>k</name></expr>]</index></name>.<name>start</name>
                  || <name><name>ranges</name>-&gt;<name>end</name></name>
                    != <name><name>mergeinfo</name><index>[<expr><name>i</name></expr>]</index></name>.<name><name>path_rngs</name><index>[<expr><name>j</name></expr>]</index></name>.<name><name>expected_rngs</name><index>[<expr><name>k</name></expr>]</index></name>.<name>end</name>
                  || <name><name>ranges</name>-&gt;<name>inheritable</name></name>
                    != <name><name>mergeinfo</name><index>[<expr><name>i</name></expr>]</index></name>.<name><name>path_rngs</name><index>[<expr><name>j</name></expr>]</index></name>.<name><name>expected_rngs</name><index>[<expr><name>k</name></expr>]</index></name>.<name>inheritable</name></expr>)</condition><then>
                <return>return <expr><call><name>fail</name><argument_list>(
                  <argument><expr><name>pool</name></expr></argument>,
                  <argument><expr>"Range'%i-%i%s' not found in merged mergeinfo"</expr></argument>,
                  <argument><expr><name><name>mergeinfo</name><index>[<expr><name>i</name></expr>]</index></name>.<name><name>path_rngs</name>-&gt;<name>expected_rngs</name><index>[<expr><name>k</name></expr>]</index></name>.<name>start</name></expr></argument>,
                  <argument><expr><name><name>mergeinfo</name><index>[<expr><name>i</name></expr>]</index></name>.<name><name>path_rngs</name>-&gt;<name>expected_rngs</name><index>[<expr><name>k</name></expr>]</index></name>.<name>end</name></expr></argument>,
                  <argument><expr><name><name>mergeinfo</name><index>[<expr><name>i</name></expr>]</index></name>.<name><name>path_rngs</name>-&gt;<name>expected_rngs</name><index>[<expr><name>k</name></expr>]</index></name>.<name>inheritable</name>
                  ? "" : "*"</expr></argument>)</argument_list></call></expr>;</return></then></if>             
            }</block></for>
          <comment type="block">/* Were more ranges expected? */</comment>
          <if>if <condition>(<expr><name>k</name> &lt; <name>MAX_NBR_MERGEINFO_RANGES</name>
              &amp;&amp; <name><name>mergeinfo</name><index>[<expr><name>i</name></expr>]</index></name>.<name><name>path_rngs</name><index>[<expr><name>j</name></expr>]</index></name>.<name><name>expected_rngs</name><index>[<expr><name>k</name></expr>]</index></name>.<name>start</name> != 0</expr>)</condition><then>
            <return>return <expr><call><name>fail</name><argument_list>(<argument><expr><name>pool</name></expr></argument>,
                        <argument><expr>"Not all expected ranges found in merged mergeinfo"</expr></argument>)</argument_list></call></expr>;</return></then></if>
        }</block></for>
    }</block></for>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>test_remove_rangelist</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>msg</name></decl></param>,
                      <param><decl><type><name>svn_boolean_t</name></type> <name>msg_only</name></decl></param>,
                      <param><decl><type><name>svn_test_opts_t</name> *</type><name>opts</name></decl></param>,
                      <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>, *<decl><type ref="prev"/><name>child_err</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>output</name></decl>, *<decl><type ref="prev"/><name>eraser</name></decl>, *<decl><type ref="prev"/><name>whiteboard</name></decl>;</decl_stmt>

  <comment type="block">/* Struct for svn_rangelist_remove test data.
     Parse WHITEBOARD and ERASER to hashes and then get the rangelist for
     path 'A' from both.
     
     Remove ERASER's rangelist from WHITEBOARD's twice, once while
     considering inheritance and once while not.  In the first case the
     resulting rangelist should have EXPECTED_RANGES_CONSIDER_INHERITANCE
     number of ranges and these ranges should match the ranges in
     EXPECTED_REMOVED_CONSIDER_INHERITANCE.  In the second case there
     should be EXPECTED_RANGES_IGNORE_INHERITANCE number of ranges and
     these should match EXPECTED_REMOVED_IGNORE_INHERITANCE */</comment>
  <struct>struct <name>rangelist_remove_test_data</name>
  <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>whiteboard</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>eraser</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>expected_ranges_consider_inheritance</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>svn_merge_range_t</name></type> <name><name>expected_removed_consider_inheritance</name><index>[<expr>10</expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>expected_ranges_ignore_inheritance</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>svn_merge_range_t</name></type> <name><name>expected_removed_ignore_inheritance</name><index>[<expr>10</expr>]</index></name></decl>;</decl_stmt>
  }</block>;</struct>

  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIZE_OF_RANGE_REMOVE_TEST_ARRAY</name></cpp:macro> <cpp:value>15</cpp:value></cpp:define>

  <comment type="block">/* The actual test data */</comment>
  <decl_stmt><decl><type>struct <name>rangelist_remove_test_data</name></type> <name><name>test_data</name><index>[<expr><name>SIZE_OF_RANGE_REMOVE_TEST_ARRAY</name></expr>]</index></name> <init>=
    <expr><block>{
      <comment type="block">/* Eraser is a proper subset of whiteboard */</comment>
      <expr><block>{<expr>"/A: 1-44"</expr>,  <expr>"/A: 5"</expr>,  <expr>2</expr>, <expr><block>{ <expr><block>{<expr>0</expr>,  <expr>4</expr>, <expr><name>TRUE</name></expr> }</block></expr>, <expr><block>{<expr>5</expr>, <expr>44</expr>, <expr><name>TRUE</name></expr> }</block></expr>}</block></expr>,
                              <expr>2</expr>, <expr><block>{ <expr><block>{<expr>0</expr>,  <expr>4</expr>, <expr><name>TRUE</name></expr> }</block></expr>, <expr><block>{<expr>5</expr>, <expr>44</expr>, <expr><name>TRUE</name></expr> }</block></expr>}</block></expr>}</block></expr>,
      <expr><block>{<expr>"/A: 1-44*"</expr>, <expr>"/A: 5"</expr>,  <expr>1</expr>, <expr><block>{ <expr><block>{<expr>0</expr>, <expr>44</expr>, <expr><name>FALSE</name></expr>}</block></expr> }</block></expr>,
                              <expr>2</expr>, <expr><block>{ <expr><block>{<expr>0</expr>,  <expr>4</expr>, <expr><name>FALSE</name></expr>}</block></expr>, <expr><block>{<expr>5</expr>, <expr>44</expr>, <expr><name>FALSE</name></expr>}</block></expr>}</block></expr>}</block></expr>,
      <expr><block>{<expr>"/A: 1-44"</expr>,  <expr>"/A: 5*"</expr>, <expr>1</expr>, <expr><block>{ <expr><block>{<expr>0</expr>, <expr>44</expr>, <expr><name>TRUE</name></expr> }</block></expr> }</block></expr>,
                              <expr>2</expr>, <expr><block>{ <expr><block>{<expr>0</expr>,  <expr>4</expr>, <expr><name>TRUE</name></expr> }</block></expr>, <expr><block>{<expr>5</expr>, <expr>44</expr>, <expr><name>TRUE</name></expr> }</block></expr>}</block></expr>}</block></expr>,
      <expr><block>{<expr>"/A: 1-44*"</expr>, <expr>"/A: 5*"</expr>, <expr>2</expr>, <expr><block>{ <expr><block>{<expr>0</expr>,  <expr>4</expr>, <expr><name>FALSE</name></expr>}</block></expr>, <expr><block>{<expr>5</expr>, <expr>44</expr>, <expr><name>FALSE</name></expr>}</block></expr>}</block></expr>,
                              <expr>2</expr>, <expr><block>{ <expr><block>{<expr>0</expr>,  <expr>4</expr>, <expr><name>FALSE</name></expr>}</block></expr>, <expr><block>{<expr>5</expr>, <expr>44</expr>, <expr><name>FALSE</name></expr>}</block></expr>}</block></expr>}</block></expr>,
      <comment type="block">/* Non-intersecting ranges...nothing is removed */</comment>
      <expr><block>{<expr>"/A: 2-9,14-19"</expr>,   <expr>"/A: 12"</expr>,  <expr>2</expr>, <expr><block>{ <expr><block>{<expr>1</expr>, <expr>9</expr>, <expr><name>TRUE</name></expr> }</block></expr>, <expr><block>{<expr>13</expr>, <expr>19</expr>, <expr><name>TRUE</name></expr> }</block></expr>}</block></expr>,
                                     <expr>2</expr>, <expr><block>{ <expr><block>{<expr>1</expr>, <expr>9</expr>, <expr><name>TRUE</name></expr> }</block></expr>, <expr><block>{<expr>13</expr>, <expr>19</expr>, <expr><name>TRUE</name></expr> }</block></expr>}</block></expr>}</block></expr>,
      <expr><block>{<expr>"/A: 2-9*,14-19*"</expr>, <expr>"/A: 12"</expr>,  <expr>2</expr>, <expr><block>{ <expr><block>{<expr>1</expr>, <expr>9</expr>, <expr><name>FALSE</name></expr>}</block></expr>, <expr><block>{<expr>13</expr>, <expr>19</expr>, <expr><name>FALSE</name></expr>}</block></expr>}</block></expr>,
                                     <expr>2</expr>, <expr><block>{ <expr><block>{<expr>1</expr>, <expr>9</expr>, <expr><name>FALSE</name></expr>}</block></expr>, <expr><block>{<expr>13</expr>, <expr>19</expr>, <expr><name>FALSE</name></expr>}</block></expr>}</block></expr>}</block></expr>,
      <expr><block>{<expr>"/A: 2-9,14-19"</expr>,   <expr>"/A: 12*"</expr>, <expr>2</expr>, <expr><block>{ <expr><block>{<expr>1</expr>, <expr>9</expr>, <expr><name>TRUE</name></expr> }</block></expr>, <expr><block>{<expr>13</expr>, <expr>19</expr>, <expr><name>TRUE</name></expr> }</block></expr>}</block></expr>,
                                     <expr>2</expr>, <expr><block>{ <expr><block>{<expr>1</expr>, <expr>9</expr>, <expr><name>TRUE</name></expr> }</block></expr>, <expr><block>{<expr>13</expr>, <expr>19</expr>, <expr><name>TRUE</name></expr> }</block></expr>}</block></expr>}</block></expr>,
      <expr><block>{<expr>"/A: 2-9*,14-19*"</expr>, <expr>"/A: 12*"</expr>, <expr>2</expr>, <expr><block>{ <expr><block>{<expr>1</expr>, <expr>9</expr>, <expr><name>FALSE</name></expr>}</block></expr>, <expr><block>{<expr>13</expr>, <expr>19</expr>, <expr><name>FALSE</name></expr>}</block></expr>}</block></expr>,
                                     <expr>2</expr>, <expr><block>{ <expr><block>{<expr>1</expr>, <expr>9</expr>, <expr><name>FALSE</name></expr>}</block></expr>, <expr><block>{<expr>13</expr>, <expr>19</expr>, <expr><name>FALSE</name></expr>}</block></expr>}</block></expr>}</block></expr>,
      <comment type="block">/* Eraser overlaps whiteboard */</comment>
      <expr><block>{<expr>"/A: 1,9-17"</expr>,  <expr>"/A: 12-20"</expr>,  <expr>2</expr>, <expr><block>{ <expr><block>{<expr>0</expr>,  <expr>1</expr>, <expr><name>TRUE</name></expr> }</block></expr>, <expr><block>{<expr>8</expr>, <expr>11</expr>, <expr><name>TRUE</name></expr> }</block></expr>}</block></expr>,
                                    <expr>2</expr>, <expr><block>{ <expr><block>{<expr>0</expr>,  <expr>1</expr>, <expr><name>TRUE</name></expr> }</block></expr>, <expr><block>{<expr>8</expr>, <expr>11</expr>, <expr><name>TRUE</name></expr> }</block></expr>}</block></expr>}</block></expr>,
      <expr><block>{<expr>"/A: 1,9-17*"</expr>, <expr>"/A: 12-20"</expr>,  <expr>2</expr>, <expr><block>{ <expr><block>{<expr>0</expr>,  <expr>1</expr>, <expr><name>TRUE</name></expr> }</block></expr>, <expr><block>{<expr>8</expr>, <expr>17</expr>, <expr><name>FALSE</name></expr>}</block></expr>}</block></expr>,
                                    <expr>2</expr>, <expr><block>{ <expr><block>{<expr>0</expr>,  <expr>1</expr>, <expr><name>TRUE</name></expr> }</block></expr>, <expr><block>{<expr>8</expr>, <expr>11</expr>, <expr><name>FALSE</name></expr>}</block></expr>}</block></expr>}</block></expr>,
      <expr><block>{<expr>"/A: 1,9-17"</expr>,  <expr>"/A: 12-20*"</expr>, <expr>2</expr>, <expr><block>{ <expr><block>{<expr>0</expr>,  <expr>1</expr>, <expr><name>TRUE</name></expr> }</block></expr>, <expr><block>{<expr>8</expr>, <expr>17</expr>, <expr><name>TRUE</name></expr> }</block></expr>}</block></expr>,
                                    <expr>2</expr>, <expr><block>{ <expr><block>{<expr>0</expr>,  <expr>1</expr>, <expr><name>TRUE</name></expr> }</block></expr>, <expr><block>{<expr>8</expr>, <expr>11</expr>, <expr><name>TRUE</name></expr> }</block></expr>}</block></expr>}</block></expr>,
      <expr><block>{<expr>"/A: 1,9-17*"</expr>, <expr>"/A: 12-20*"</expr>, <expr>2</expr>, <expr><block>{ <expr><block>{<expr>0</expr>,  <expr>1</expr>, <expr><name>TRUE</name></expr> }</block></expr>, <expr><block>{<expr>8</expr>, <expr>11</expr>, <expr><name>FALSE</name></expr>}</block></expr>}</block></expr>,
                                    <expr>2</expr>, <expr><block>{ <expr><block>{<expr>0</expr>,  <expr>1</expr>, <expr><name>TRUE</name></expr> }</block></expr>, <expr><block>{<expr>8</expr>, <expr>11</expr>, <expr><name>FALSE</name></expr>}</block></expr>}</block></expr>}</block></expr>,
      <comment type="block">/* Empty mergeinfo (i.e. empty rangelist) */</comment>
      <expr><block>{<expr>""</expr>,  <expr>""</expr>,               <expr>0</expr>, <expr><block>{ <expr><block>{<expr>0</expr>, <expr>0</expr>, <expr><name>FALSE</name></expr>}</block></expr>}</block></expr>,
                              <expr>0</expr>, <expr><block>{ <expr><block>{<expr>0</expr>, <expr>0</expr>, <expr><name>FALSE</name></expr>}</block></expr>}</block></expr>}</block></expr>,
      <expr><block>{<expr>""</expr>,  <expr>"/A: 5-8,10-100"</expr>, <expr>0</expr>, <expr><block>{ <expr><block>{<expr>0</expr>, <expr>0</expr>, <expr><name>FALSE</name></expr>}</block></expr>}</block></expr>,
                              <expr>0</expr>, <expr><block>{ <expr><block>{<expr>0</expr>, <expr>0</expr>, <expr><name>FALSE</name></expr>}</block></expr>}</block></expr>}</block></expr>,
      <expr><block>{<expr>"/A: 5-8,10-100"</expr>,  <expr>""</expr>, <expr>2</expr>, <expr><block>{ <expr><block>{<expr>4</expr>, <expr>8</expr>, <expr><name>TRUE</name></expr> }</block></expr>, <expr><block>{<expr>9</expr>, <expr>100</expr>, <expr><name>TRUE</name></expr> }</block></expr>}</block></expr>,
                              <expr>2</expr>, <expr><block>{ <expr><block>{<expr>4</expr>, <expr>8</expr>, <expr><name>TRUE</name></expr> }</block></expr>, <expr><block>{<expr>9</expr>, <expr>100</expr>, <expr><name>TRUE</name></expr> }</block></expr>}</block></expr>}</block></expr>
    }</block></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr>*<name>msg</name> = "remove rangelists"</expr>;</expr_stmt>
  <expr_stmt><expr><name>err</name> = <name>child_err</name> = <name>SVN_NO_ERROR</name></expr>;</expr_stmt>
  <for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; 2</expr>;</condition> <incr><expr><name>j</name>++</expr></incr>)
    <block>{
      <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>SIZE_OF_RANGE_REMOVE_TEST_ARRAY</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
        <block>{
          <decl_stmt><decl><type><name>int</name></type> <name>expected_nbr_ranges</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>svn_merge_range_t</name> *</type><name>expected_ranges</name></decl>;</decl_stmt>
            
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo_parse</name><argument_list>(<argument><expr>&amp;<name>info1</name></expr></argument>, <argument><expr>(<name><name>test_data</name><index>[<expr><name>i</name></expr>]</index></name>).<name>eraser</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo_parse</name><argument_list>(<argument><expr>&amp;<name>info2</name></expr></argument>, <argument><expr>(<name><name>test_data</name><index>[<expr><name>i</name></expr>]</index></name>).<name>whiteboard</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>eraser</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>info1</name></expr></argument>, <argument><expr>"/A"</expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>whiteboard</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>info2</name></expr></argument>, <argument><expr>"/A"</expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Represent empty mergeinfo with an empty rangelist. */</comment>
          <if>if <condition>(<expr><name>eraser</name> == <name>NULL</name></expr>)</condition><then>
            <expr_stmt><expr><name>eraser</name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>eraser</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
          <if>if <condition>(<expr><name>whiteboard</name> == <name>NULL</name></expr>)</condition><then>
            <expr_stmt><expr><name>whiteboard</name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>whiteboard</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

          <comment type="block">/* First pass try removal considering inheritance, on the
             second pass ignore it. */</comment>
          <if>if <condition>(<expr><name>j</name> == 0</expr>)</condition><then>
            <block>{
              <expr_stmt><expr><name>expected_nbr_ranges</name> = (<name><name>test_data</name><index>[<expr><name>i</name></expr>]</index></name>).<name>expected_ranges_consider_inheritance</name></expr>;</expr_stmt>
              <expr_stmt><expr><name>expected_ranges</name> = (<name><name>test_data</name><index>[<expr><name>i</name></expr>]</index></name>).<name>expected_removed_consider_inheritance</name></expr>;</expr_stmt>
       
            }</block></then>
          <else>else
            <block>{
              <expr_stmt><expr><name>expected_nbr_ranges</name> = (<name><name>test_data</name><index>[<expr><name>i</name></expr>]</index></name>).<name>expected_ranges_ignore_inheritance</name></expr>;</expr_stmt>
              <expr_stmt><expr><name>expected_ranges</name> = (<name><name>test_data</name><index>[<expr><name>i</name></expr>]</index></name>).<name>expected_removed_ignore_inheritance</name></expr>;</expr_stmt>
          
            }</block></else></if>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_rangelist_remove</name><argument_list>(<argument><expr>&amp;<name>output</name></expr></argument>, <argument><expr><name>eraser</name></expr></argument>, <argument><expr><name>whiteboard</name></expr></argument>,
                                       <argument><expr><name>j</name> == 0 ? <name>TRUE</name> : <name>FALSE</name></expr></argument>,
                                       <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>child_err</name> = <call><name>verify_ranges_match</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name>expected_ranges</name></expr></argument>,
                                          <argument><expr><name>expected_nbr_ranges</name></expr></argument>,
                                          <argument><expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>,
                                                       <argument><expr>"svn_rangelist_remove "
                                                       "case %i"</expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>,
                                          <argument><expr>"remove"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Collect all the errors rather than returning on the first. */</comment>
          <if>if <condition>(<expr><name>child_err</name></expr>)</condition><then>
            <block>{
              <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
                <expr_stmt><expr><call><name>svn_error_compose</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>child_err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
              <else>else
                <expr_stmt><expr><name>err</name> = <name>child_err</name></expr>;</expr_stmt></else></if>
            }</block></then></if>
        }</block></for>
    }</block></for>
  <return>return <expr><name>err</name></expr>;</return>
}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RANDOM_REV_ARRAY_LENGTH</name></cpp:macro> <cpp:value>100</cpp:value></cpp:define>

<comment type="block">/* Random number seed. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>apr_uint32_t</name></type> <name>random_rev_array_seed</name></decl>;</decl_stmt>

<comment type="block">/* Fill 3/4 of the array with 1s. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>randomly_fill_rev_array</name><parameter_list>(<param><decl><type><name>svn_boolean_t</name> *</type><name>revs</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>RANDOM_REV_ARRAY_LENGTH</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <decl_stmt><decl><type><name>apr_uint32_t</name></type> <name>next</name> <init>= <expr><call><name>svn_test_rand</name><argument_list>(<argument><expr>&amp;<name>random_rev_array_seed</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>revs</name><index>[<expr><name>i</name></expr>]</index></name> = (<name>next</name> &lt; 0x40000000) ? 0 : 1</expr>;</expr_stmt>
    }</block></for>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>rev_array_to_rangelist</name><parameter_list>(<param><decl><type><name>apr_array_header_t</name> **</type><name>rangelist</name></decl></param>,
                       <param><decl><type><name>svn_boolean_t</name> *</type><name>revs</name></decl></param>,
                       <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>buf</name> <init>= <expr><call><name>svn_stringbuf_create</name><argument_list>(<argument><expr>"/trunk: "</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>first</name> <init>= <expr><name>TRUE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>mergeinfo</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>RANDOM_REV_ARRAY_LENGTH</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <if>if <condition>(<expr><name><name>revs</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then>
        <block>{
          <if>if <condition>(<expr><name>first</name></expr>)</condition><then>
            <expr_stmt><expr><name>first</name> = <name>FALSE</name></expr>;</expr_stmt></then>
          <else>else
            <expr_stmt><expr><call><name>svn_stringbuf_appendcstr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>","</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
          <expr_stmt><expr><call><name>svn_stringbuf_appendcstr</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%d"</expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></for>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo_parse</name><argument_list>(<argument><expr>&amp;<name>mergeinfo</name></expr></argument>, <argument><expr><name><name>buf</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>rangelist</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>mergeinfo</name></expr></argument>, <argument><expr>"/trunk"</expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>test_rangelist_remove_randomly</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>msg</name></decl></param>,
                               <param><decl><type><name>svn_boolean_t</name></type> <name>msg_only</name></decl></param>,
                               <param><decl><type><name>svn_test_opts_t</name> *</type><name>opts</name></decl></param>,
                               <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>iterpool</name></decl>;</decl_stmt>

  <expr_stmt><expr>*<name>msg</name> = "test rangelist remove with random data"</expr>;</expr_stmt>
  <if>if <condition>(<expr><name>msg_only</name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <expr_stmt><expr><name>random_rev_array_seed</name> = (<name>apr_uint32_t</name>) <call><name>apr_time_now</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>iterpool</name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; 20</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name><name>first_revs</name><index>[<expr><name>RANDOM_REV_ARRAY_LENGTH</name></expr>]</index></name></decl>,
        <decl><type ref="prev"/><name><name>second_revs</name><index>[<expr><name>RANDOM_REV_ARRAY_LENGTH</name></expr>]</index></name></decl>,
        <decl><type ref="prev"/><name><name>expected_revs</name><index>[<expr><name>RANDOM_REV_ARRAY_LENGTH</name></expr>]</index></name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>first_rangelist</name></decl>, *<decl><type ref="prev"/><name>second_rangelist</name></decl>,
        *<decl><type ref="prev"/><name>expected_rangelist</name></decl>, *<decl><type ref="prev"/><name>actual_rangelist</name></decl>;</decl_stmt>
      <comment type="block">/* There will be at most RANDOM_REV_ARRAY_LENGTH ranges in 
         expected_rangelist. */</comment>
      <decl_stmt><decl><type><name>svn_merge_range_t</name></type> <name><name>expected_range_array</name><index>[<expr><name>RANDOM_REV_ARRAY_LENGTH</name></expr>]</index></name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>randomly_fill_rev_array</name><argument_list>(<argument><expr><name>first_revs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>randomly_fill_rev_array</name><argument_list>(<argument><expr><name>second_revs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name>RANDOM_REV_ARRAY_LENGTH</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>)
        <expr_stmt><expr><name><name>expected_revs</name><index>[<expr><name>j</name></expr>]</index></name> = <name><name>second_revs</name><index>[<expr><name>j</name></expr>]</index></name> &amp;&amp; !<name><name>first_revs</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt></for>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>rev_array_to_rangelist</name><argument_list>(<argument><expr>&amp;<name>first_rangelist</name></expr></argument>, <argument><expr><name>first_revs</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>rev_array_to_rangelist</name><argument_list>(<argument><expr>&amp;<name>second_rangelist</name></expr></argument>, <argument><expr><name>second_revs</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>rev_array_to_rangelist</name><argument_list>(<argument><expr>&amp;<name>expected_rangelist</name></expr></argument>, <argument><expr><name>expected_revs</name></expr></argument>,
                                     <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name><name>expected_rangelist</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>)
        <block>{
          <expr_stmt><expr><name><name>expected_range_array</name><index>[<expr><name>j</name></expr>]</index></name> = *(<call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>expected_rangelist</name></expr></argument>, <argument><expr><name>j</name></expr></argument>,
                                                    <argument><expr><name>svn_merge_range_t</name> *</expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
        }</block></for>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_rangelist_remove</name><argument_list>(<argument><expr>&amp;<name>actual_rangelist</name></expr></argument>, <argument><expr><name>first_rangelist</name></expr></argument>,
                                   <argument><expr><name>second_rangelist</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>verify_ranges_match</name><argument_list>(<argument><expr><name>actual_rangelist</name></expr></argument>,
                                  <argument><expr><name>expected_range_array</name></expr></argument>,
                                  <argument><expr><name><name>expected_rangelist</name>-&gt;<name>nelts</name></name></expr></argument>,
                                  <argument><expr>"svn_rangelist_remove random call"</expr></argument>,
                                  <argument><expr>"remove"</expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>test_rangelist_intersect_randomly</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>msg</name></decl></param>,
                                  <param><decl><type><name>svn_boolean_t</name></type> <name>msg_only</name></decl></param>,
                                  <param><decl><type><name>svn_test_opts_t</name> *</type><name>opts</name></decl></param>,
                                  <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>iterpool</name></decl>;</decl_stmt>

  <expr_stmt><expr>*<name>msg</name> = "test rangelist intersect with random data"</expr>;</expr_stmt>
  <if>if <condition>(<expr><name>msg_only</name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <expr_stmt><expr><name>random_rev_array_seed</name> = (<name>apr_uint32_t</name>) <call><name>apr_time_now</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>iterpool</name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; 20</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name><name>first_revs</name><index>[<expr><name>RANDOM_REV_ARRAY_LENGTH</name></expr>]</index></name></decl>,
        <decl><type ref="prev"/><name><name>second_revs</name><index>[<expr><name>RANDOM_REV_ARRAY_LENGTH</name></expr>]</index></name></decl>,
        <decl><type ref="prev"/><name><name>expected_revs</name><index>[<expr><name>RANDOM_REV_ARRAY_LENGTH</name></expr>]</index></name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>first_rangelist</name></decl>, *<decl><type ref="prev"/><name>second_rangelist</name></decl>,
        *<decl><type ref="prev"/><name>expected_rangelist</name></decl>, *<decl><type ref="prev"/><name>actual_rangelist</name></decl>;</decl_stmt>
      <comment type="block">/* There will be at most RANDOM_REV_ARRAY_LENGTH ranges in 
         expected_rangelist. */</comment>
      <decl_stmt><decl><type><name>svn_merge_range_t</name></type> <name><name>expected_range_array</name><index>[<expr><name>RANDOM_REV_ARRAY_LENGTH</name></expr>]</index></name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>randomly_fill_rev_array</name><argument_list>(<argument><expr><name>first_revs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>randomly_fill_rev_array</name><argument_list>(<argument><expr><name>second_revs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name>RANDOM_REV_ARRAY_LENGTH</name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>)
        <expr_stmt><expr><name><name>expected_revs</name><index>[<expr><name>j</name></expr>]</index></name> = <name><name>second_revs</name><index>[<expr><name>j</name></expr>]</index></name> &amp;&amp; <name><name>first_revs</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt></for>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>rev_array_to_rangelist</name><argument_list>(<argument><expr>&amp;<name>first_rangelist</name></expr></argument>, <argument><expr><name>first_revs</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>rev_array_to_rangelist</name><argument_list>(<argument><expr>&amp;<name>second_rangelist</name></expr></argument>, <argument><expr><name>second_revs</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>rev_array_to_rangelist</name><argument_list>(<argument><expr>&amp;<name>expected_rangelist</name></expr></argument>, <argument><expr><name>expected_revs</name></expr></argument>,
                                     <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name><name>expected_rangelist</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>j</name>++</expr></incr>)
        <block>{
          <expr_stmt><expr><name><name>expected_range_array</name><index>[<expr><name>j</name></expr>]</index></name> = *(<call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>expected_rangelist</name></expr></argument>, <argument><expr><name>j</name></expr></argument>,
                                                    <argument><expr><name>svn_merge_range_t</name> *</expr></argument>)</argument_list></call>)</expr>;</expr_stmt>
        }</block></for>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_rangelist_intersect</name><argument_list>(<argument><expr>&amp;<name>actual_rangelist</name></expr></argument>, <argument><expr><name>first_rangelist</name></expr></argument>,
                                      <argument><expr><name>second_rangelist</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>verify_ranges_match</name><argument_list>(<argument><expr><name>actual_rangelist</name></expr></argument>,
                                  <argument><expr><name>expected_range_array</name></expr></argument>,
                                  <argument><expr><name><name>expected_rangelist</name>-&gt;<name>nelts</name></name></expr></argument>,
                                  <argument><expr>"svn_rangelist_intersect random call"</expr></argument>,
                                  <argument><expr>"intersect"</expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* ### Share code with test_diff_mergeinfo() and test_remove_rangelist(). */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>test_remove_mergeinfo</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>msg</name></decl></param>,
                      <param><decl><type><name>svn_boolean_t</name></type> <name>msg_only</name></decl></param>,
                      <param><decl><type><name>svn_test_opts_t</name> *</type><name>opts</name></decl></param>,
                      <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>output</name></decl>, *<decl><type ref="prev"/><name>whiteboard</name></decl>, *<decl><type ref="prev"/><name>eraser</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_merge_range_t</name></type> <name><name>expected_rangelist_remainder</name><index>[<expr><name>NBR_RANGELIST_DELTAS</name></expr>]</index></name> <init>=
    <expr><block>{ <expr><block>{<expr>6</expr>, <expr>7</expr>, <expr><name>TRUE</name></expr>}</block></expr>, <expr><block>{<expr>8</expr>, <expr>9</expr>, <expr><name>TRUE</name></expr>}</block></expr>, <expr><block>{<expr>10</expr>, <expr>11</expr>, <expr><name>TRUE</name></expr>}</block></expr>, <expr><block>{<expr>32</expr>, <expr>34</expr>, <expr><name>TRUE</name></expr>}</block></expr> }</block></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr>*<name>msg</name> = "remove of mergeinfo"</expr>;</expr_stmt>
  <if>if <condition>(<expr><name>msg_only</name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo_parse</name><argument_list>(<argument><expr>&amp;<name>whiteboard</name></expr></argument>,
                              <argument><expr>"/trunk: 1,3-4,7,9,11-12,31-34"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo_parse</name><argument_list>(<argument><expr>&amp;<name>eraser</name></expr></argument>, <argument><expr>"/trunk: 1-6,12-16,30-32"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Leftover on /trunk should be the set (7, 9, 11, 33-34) */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo_remove</name><argument_list>(<argument><expr>&amp;<name>output</name></expr></argument>, <argument><expr><name>eraser</name></expr></argument>, <argument><expr><name>whiteboard</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Verify calculation of range list remainder. */</comment>
  <return>return <expr><call><name>verify_mergeinfo_deltas</name><argument_list>(<argument><expr><name>output</name></expr></argument>, <argument><expr><name>expected_rangelist_remainder</name></expr></argument>,
                                 <argument><expr>"svn_mergeinfo_remove"</expr></argument>, <argument><expr>"leftover"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>NBR_RANGELIST_DELTAS</name></cpp:undef>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>test_rangelist_to_string</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>msg</name></decl></param>,
                         <param><decl><type><name>svn_boolean_t</name></type> <name>msg_only</name></decl></param>,
                         <param><decl><type><name>svn_test_opts_t</name> *</type><name>opts</name></decl></param>,
                         <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>result</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>output</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>expected</name> <init>= <expr><call><name>svn_string_create</name><argument_list>(<argument><expr>"3,5,7-11,13-14"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr>*<name>msg</name> = "turning rangelist back into a string"</expr>;</expr_stmt>

  <if>if <condition>(<expr><name>msg_only</name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo_parse</name><argument_list>(<argument><expr>&amp;<name>info1</name></expr></argument>, <argument><expr><name>mergeinfo1</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>result</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>info1</name></expr></argument>, <argument><expr>"/trunk"</expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<name>result</name></expr>)</condition><then>
    <return>return <expr><call><name>fail</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"Missing path in parsed mergeinfo"</expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_rangelist_to_string</name><argument_list>(<argument><expr>&amp;<name>output</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><call><name>svn_string_compare</name><argument_list>(<argument><expr><name>expected</name></expr></argument>, <argument><expr><name>output</name></expr></argument>)</argument_list></call> != <name>TRUE</name></expr>)</condition><then>
    <return>return <expr><call><name>fail</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"Rangelist string not what we expected"</expr></argument>)</argument_list></call></expr>;</return></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>test_mergeinfo_to_string</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>msg</name></decl></param>,
                         <param><decl><type><name>svn_boolean_t</name></type> <name>msg_only</name></decl></param>,
                         <param><decl><type><name>svn_test_opts_t</name> *</type><name>opts</name></decl></param>,
                         <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>output</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>expected</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>expected</name> = <call><name>svn_string_create</name><argument_list>(<argument><expr>"/fred:8-10\n/trunk:3,5,7-11,13-14"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>msg</name> = "turning mergeinfo back into a string"</expr>;</expr_stmt>

  <if>if <condition>(<expr><name>msg_only</name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo_parse</name><argument_list>(<argument><expr>&amp;<name>info1</name></expr></argument>, <argument><expr><name>mergeinfo1</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo_to_string</name><argument_list>(<argument><expr>&amp;<name>output</name></expr></argument>, <argument><expr><name>info1</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><call><name>svn_string_compare</name><argument_list>(<argument><expr><name>expected</name></expr></argument>, <argument><expr><name>output</name></expr></argument>)</argument_list></call> != <name>TRUE</name></expr>)</condition><then>
    <return>return <expr><call><name>fail</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"Mergeinfo string not what we expected"</expr></argument>)</argument_list></call></expr>;</return></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>test_rangelist_merge</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>msg</name></decl></param>,
                     <param><decl><type><name>svn_boolean_t</name></type> <name>msg_only</name></decl></param>,
                     <param><decl><type><name>svn_test_opts_t</name> *</type><name>opts</name></decl></param>,
                     <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>, *<decl><type ref="prev"/><name>child_err</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>rangelist1</name></decl>, *<decl><type ref="prev"/><name>rangelist2</name></decl>;</decl_stmt>
  
  <comment type="block">/* Struct for svn_rangelist_merge test data.  Similar to
     mergeinfo_merge_test_data struct in svn_mergeinfo_merge() test. */</comment>
  <struct>struct <name>rangelist_merge_test_data</name>
  <block>{
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>mergeinfo1</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>mergeinfo2</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>expected_ranges</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>svn_merge_range_t</name></type> <name><name>expected_merge</name><index>[<expr>6</expr>]</index></name></decl>;</decl_stmt>
  }</block>;</struct>

  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIZE_OF_RANGE_MERGE_TEST_ARRAY</name></cpp:macro> <cpp:value>59</cpp:value></cpp:define>
  <comment type="block">/* The actual test data. */</comment>
  <decl_stmt><decl><type>struct <name>rangelist_merge_test_data</name></type> <name><name>test_data</name><index>[<expr><name>SIZE_OF_RANGE_MERGE_TEST_ARRAY</name></expr>]</index></name> <init>=
    <expr><block>{
      <comment type="block">/* Non-intersecting ranges */</comment>
      <expr><block>{<expr>"/A: 1-44"</expr>,    <expr>"/A: 70-101"</expr>,  <expr>2</expr>, <expr><block>{<expr><block>{ <expr>0</expr>, <expr>44</expr>, <expr><name>TRUE</name></expr> }</block></expr>, <expr><block>{<expr>69</expr>, <expr>101</expr>, <expr><name>TRUE</name></expr> }</block></expr>}</block></expr>}</block></expr>,
      <expr><block>{<expr>"/A: 1-44*"</expr>,   <expr>"/A: 70-101"</expr>,  <expr>2</expr>, <expr><block>{<expr><block>{ <expr>0</expr>, <expr>44</expr>, <expr><name>FALSE</name></expr>}</block></expr>, <expr><block>{<expr>69</expr>, <expr>101</expr>, <expr><name>TRUE</name></expr> }</block></expr>}</block></expr>}</block></expr>,
      <expr><block>{<expr>"/A: 1-44"</expr>,    <expr>"/A: 70-101*"</expr>, <expr>2</expr>, <expr><block>{<expr><block>{ <expr>0</expr>, <expr>44</expr>, <expr><name>TRUE</name></expr> }</block></expr>, <expr><block>{<expr>69</expr>, <expr>101</expr>, <expr><name>FALSE</name></expr>}</block></expr>}</block></expr>}</block></expr>,
      <expr><block>{<expr>"/A: 1-44*"</expr>,   <expr>"/A: 70-101*"</expr>, <expr>2</expr>, <expr><block>{<expr><block>{ <expr>0</expr>, <expr>44</expr>, <expr><name>FALSE</name></expr>}</block></expr>, <expr><block>{<expr>69</expr>, <expr>101</expr>, <expr><name>FALSE</name></expr>}</block></expr>}</block></expr>}</block></expr>,
      <expr><block>{<expr>"/A: 70-101"</expr>,  <expr>"/A: 1-44"</expr>,    <expr>2</expr>, <expr><block>{<expr><block>{ <expr>0</expr>, <expr>44</expr>, <expr><name>TRUE</name></expr> }</block></expr>, <expr><block>{<expr>69</expr>, <expr>101</expr>, <expr><name>TRUE</name></expr> }</block></expr>}</block></expr>}</block></expr>,
      <expr><block>{<expr>"/A: 70-101*"</expr>, <expr>"/A: 1-44"</expr>,    <expr>2</expr>, <expr><block>{<expr><block>{ <expr>0</expr>, <expr>44</expr>, <expr><name>TRUE</name></expr> }</block></expr>, <expr><block>{<expr>69</expr>, <expr>101</expr>, <expr><name>FALSE</name></expr>}</block></expr>}</block></expr>}</block></expr>,
      <expr><block>{<expr>"/A: 70-101"</expr>,  <expr>"/A: 1-44*"</expr>,   <expr>2</expr>, <expr><block>{<expr><block>{ <expr>0</expr>, <expr>44</expr>, <expr><name>FALSE</name></expr>}</block></expr>, <expr><block>{<expr>69</expr>, <expr>101</expr>, <expr><name>TRUE</name></expr> }</block></expr>}</block></expr>}</block></expr>,
      <expr><block>{<expr>"/A: 70-101*"</expr>, <expr>"/A: 1-44*"</expr>,   <expr>2</expr>, <expr><block>{<expr><block>{ <expr>0</expr>, <expr>44</expr>, <expr><name>FALSE</name></expr>}</block></expr>, <expr><block>{<expr>69</expr>, <expr>101</expr>, <expr><name>FALSE</name></expr>}</block></expr>}</block></expr>}</block></expr>,

      <comment type="block">/* Intersecting ranges with same starting and ending revisions */</comment>
      <expr><block>{<expr>"/A: 4-20"</expr>,  <expr>"/A: 4-20"</expr>,  <expr>1</expr>, <expr><block>{<expr><block>{<expr>3</expr>, <expr>20</expr>, <expr><name>TRUE</name></expr> }</block></expr>}</block></expr>}</block></expr>,
      <expr><block>{<expr>"/A: 4-20*"</expr>, <expr>"/A: 4-20"</expr>,  <expr>1</expr>, <expr><block>{<expr><block>{<expr>3</expr>, <expr>20</expr>, <expr><name>TRUE</name></expr> }</block></expr>}</block></expr>}</block></expr>,
      <expr><block>{<expr>"/A: 4-20"</expr>,  <expr>"/A: 4-20*"</expr>, <expr>1</expr>, <expr><block>{<expr><block>{<expr>3</expr>, <expr>20</expr>, <expr><name>TRUE</name></expr> }</block></expr>}</block></expr>}</block></expr>,
      <expr><block>{<expr>"/A: 4-20*"</expr>, <expr>"/A: 4-20*"</expr>, <expr>1</expr>, <expr><block>{<expr><block>{<expr>3</expr>, <expr>20</expr>, <expr><name>FALSE</name></expr>}</block></expr>}</block></expr>}</block></expr>,

      <comment type="block">/* Intersecting ranges with same starting revision */</comment>
      <expr><block>{<expr>"/A: 6-17"</expr>,  <expr>"/A: 6-12"</expr>,  <expr>1</expr>, <expr><block>{<expr><block>{<expr>5</expr>, <expr>17</expr>, <expr><name>TRUE</name></expr>}</block></expr>}</block></expr>}</block></expr>,
      <expr><block>{<expr>"/A: 6-17*"</expr>, <expr>"/A: 6-12"</expr>,  <expr>2</expr>, <expr><block>{<expr><block>{<expr>5</expr>, <expr>12</expr>, <expr><name>TRUE</name></expr> }</block></expr>, <expr><block>{<expr>12</expr>, <expr>17</expr>, <expr><name>FALSE</name></expr>}</block></expr>}</block></expr>}</block></expr>,
      <expr><block>{<expr>"/A: 6-17"</expr>,  <expr>"/A: 6-12*"</expr>, <expr>1</expr>, <expr><block>{<expr><block>{<expr>5</expr>, <expr>17</expr>, <expr><name>TRUE</name></expr> }</block></expr>}</block></expr>}</block></expr>,
      <expr><block>{<expr>"/A: 6-17*"</expr>, <expr>"/A: 6-12*"</expr>, <expr>1</expr>, <expr><block>{<expr><block>{<expr>5</expr>, <expr>17</expr>, <expr><name>FALSE</name></expr>}</block></expr>}</block></expr>}</block></expr>,
      <expr><block>{<expr>"/A: 6-12"</expr>,  <expr>"/A: 6-17"</expr>,  <expr>1</expr>, <expr><block>{<expr><block>{<expr>5</expr>, <expr>17</expr>, <expr><name>TRUE</name></expr> }</block></expr>}</block></expr>}</block></expr>,
      <expr><block>{<expr>"/A: 6-12*"</expr>, <expr>"/A: 6-17"</expr>,  <expr>1</expr>, <expr><block>{<expr><block>{<expr>5</expr>, <expr>17</expr>, <expr><name>TRUE</name></expr> }</block></expr>}</block></expr>}</block></expr>,
      <expr><block>{<expr>"/A: 6-12"</expr>,  <expr>"/A: 6-17*"</expr>, <expr>2</expr>, <expr><block>{<expr><block>{<expr>5</expr>, <expr>12</expr>, <expr><name>TRUE</name></expr> }</block></expr>, <expr><block>{<expr>12</expr>, <expr>17</expr>, <expr><name>FALSE</name></expr>}</block></expr>}</block></expr>}</block></expr>,
      <expr><block>{<expr>"/A: 6-12*"</expr>, <expr>"/A: 6-17*"</expr>, <expr>1</expr>, <expr><block>{<expr><block>{<expr>5</expr>, <expr>17</expr>, <expr><name>FALSE</name></expr>}</block></expr>}</block></expr>}</block></expr>,

      <comment type="block">/* Intersecting ranges with same ending revision */</comment>
      <expr><block>{<expr>"/A: 5-77"</expr>,   <expr>"/A: 44-77"</expr>,  <expr>1</expr>, <expr><block>{<expr><block>{<expr>4</expr>, <expr>77</expr>, <expr><name>TRUE</name></expr> }</block></expr>}</block></expr>}</block></expr>,
      <expr><block>{<expr>"/A: 5-77*"</expr>,  <expr>"/A: 44-77"</expr>,  <expr>2</expr>, <expr><block>{<expr><block>{<expr>4</expr>, <expr>43</expr>, <expr><name>FALSE</name></expr>}</block></expr>, <expr><block>{<expr>43</expr>, <expr>77</expr>, <expr><name>TRUE</name></expr>}</block></expr>}</block></expr>}</block></expr>,
      <expr><block>{<expr>"/A: 5-77"</expr>,   <expr>"/A: 44-77*"</expr>, <expr>1</expr>, <expr><block>{<expr><block>{<expr>4</expr>, <expr>77</expr>, <expr><name>TRUE</name></expr> }</block></expr>}</block></expr>}</block></expr>,
      <expr><block>{<expr>"/A: 5-77*"</expr>,  <expr>"/A: 44-77*"</expr>, <expr>1</expr>, <expr><block>{<expr><block>{<expr>4</expr>, <expr>77</expr>, <expr><name>FALSE</name></expr>}</block></expr>}</block></expr>}</block></expr>,
      <expr><block>{<expr>"/A: 44-77"</expr>,  <expr>"/A: 5-77"</expr>,   <expr>1</expr>, <expr><block>{<expr><block>{<expr>4</expr>, <expr>77</expr>, <expr><name>TRUE</name></expr> }</block></expr>}</block></expr>}</block></expr>,
      <expr><block>{<expr>"/A: 44-77*"</expr>, <expr>"/A: 5-77"</expr>,   <expr>1</expr>, <expr><block>{<expr><block>{<expr>4</expr>, <expr>77</expr>, <expr><name>TRUE</name></expr> }</block></expr>}</block></expr>}</block></expr>,
      <expr><block>{<expr>"/A: 44-77"</expr>,  <expr>"/A: 5-77*"</expr>,  <expr>2</expr>, <expr><block>{<expr><block>{<expr>4</expr>, <expr>43</expr>, <expr><name>FALSE</name></expr>}</block></expr>, <expr><block>{<expr>43</expr>, <expr>77</expr>, <expr><name>TRUE</name></expr>}</block></expr>}</block></expr>}</block></expr>,
      <expr><block>{<expr>"/A: 44-77*"</expr>, <expr>"/A: 5-77*"</expr>,  <expr>1</expr>, <expr><block>{<expr><block>{<expr>4</expr>, <expr>77</expr>, <expr><name>FALSE</name></expr>}</block></expr>}</block></expr>}</block></expr>,

      <comment type="block">/* Intersecting ranges with different starting and ending revision
         where one range is a proper subset of the other. */</comment>
      <expr><block>{<expr>"/A: 12-24"</expr>,  <expr>"/A: 20-23"</expr>,  <expr>1</expr>, <expr><block>{<expr><block>{<expr>11</expr>, <expr>24</expr>, <expr><name>TRUE</name></expr> }</block></expr>}</block></expr>}</block></expr>,
      <expr><block>{<expr>"/A: 12-24*"</expr>, <expr>"/A: 20-23"</expr>,  <expr>3</expr>, <expr><block>{<expr><block>{<expr>11</expr>, <expr>19</expr>, <expr><name>FALSE</name></expr>}</block></expr>, <expr><block>{<expr>19</expr>, <expr>23</expr>, <expr><name>TRUE</name></expr> }</block></expr>,
                                       <expr><block>{<expr>23</expr>, <expr>24</expr>, <expr><name>FALSE</name></expr>}</block></expr>}</block></expr>}</block></expr>,
      <expr><block>{<expr>"/A: 12-24"</expr>,  <expr>"/A: 20-23*"</expr>, <expr>1</expr>, <expr><block>{<expr><block>{<expr>11</expr>, <expr>24</expr>, <expr><name>TRUE</name></expr> }</block></expr>}</block></expr>}</block></expr>,
      <expr><block>{<expr>"/A: 12-24*"</expr>, <expr>"/A: 20-23*"</expr>, <expr>1</expr>, <expr><block>{<expr><block>{<expr>11</expr>, <expr>24</expr>, <expr><name>FALSE</name></expr>}</block></expr>}</block></expr>}</block></expr>,
      <expr><block>{<expr>"/A: 20-23"</expr>,  <expr>"/A: 12-24"</expr>,  <expr>1</expr>, <expr><block>{<expr><block>{<expr>11</expr>, <expr>24</expr>, <expr><name>TRUE</name></expr> }</block></expr>}</block></expr>}</block></expr>,
      <expr><block>{<expr>"/A: 20-23*"</expr>, <expr>"/A: 12-24"</expr>,  <expr>1</expr>, <expr><block>{<expr><block>{<expr>11</expr>, <expr>24</expr>, <expr><name>TRUE</name></expr> }</block></expr>}</block></expr>}</block></expr>,
      <expr><block>{<expr>"/A: 20-23"</expr>,  <expr>"/A: 12-24*"</expr>, <expr>3</expr>, <expr><block>{<expr><block>{<expr>11</expr>, <expr>19</expr>, <expr><name>FALSE</name></expr>}</block></expr>, <expr><block>{<expr>19</expr>, <expr>23</expr>, <expr><name>TRUE</name></expr> }</block></expr>,
                                       <expr><block>{<expr>23</expr>, <expr>24</expr>, <expr><name>FALSE</name></expr>}</block></expr>}</block></expr>}</block></expr>,
      <expr><block>{<expr>"/A: 20-23*"</expr>, <expr>"/A: 12-24*"</expr>, <expr>1</expr>, <expr><block>{<expr><block>{<expr>11</expr>, <expr>24</expr>, <expr><name>FALSE</name></expr>}</block></expr>}</block></expr>}</block></expr>,

      <comment type="block">/* Intersecting ranges with different starting and ending revision
         where neither range is a proper subset of the other. */</comment>
      <expr><block>{<expr>"/A: 50-73"</expr>,  <expr>"/A: 60-99"</expr>,  <expr>1</expr>, <expr><block>{<expr><block>{<expr>49</expr>, <expr>99</expr>, <expr><name>TRUE</name></expr> }</block></expr>}</block></expr>}</block></expr>,
      <expr><block>{<expr>"/A: 50-73*"</expr>, <expr>"/A: 60-99"</expr>,  <expr>2</expr>, <expr><block>{<expr><block>{<expr>49</expr>, <expr>59</expr>, <expr><name>FALSE</name></expr>}</block></expr>, <expr><block>{<expr>59</expr>, <expr>99</expr>, <expr><name>TRUE</name></expr> }</block></expr>}</block></expr>}</block></expr>,
      <expr><block>{<expr>"/A: 50-73"</expr>,  <expr>"/A: 60-99*"</expr>, <expr>2</expr>, <expr><block>{<expr><block>{<expr>49</expr>, <expr>73</expr>, <expr><name>TRUE</name></expr> }</block></expr>, <expr><block>{<expr>73</expr>, <expr>99</expr>, <expr><name>FALSE</name></expr>}</block></expr>}</block></expr>}</block></expr>,
      <expr><block>{<expr>"/A: 50-73*"</expr>, <expr>"/A: 60-99*"</expr>, <expr>1</expr>, <expr><block>{<expr><block>{<expr>49</expr>, <expr>99</expr>, <expr><name>FALSE</name></expr>}</block></expr>}</block></expr>}</block></expr>,
      <expr><block>{<expr>"/A: 60-99"</expr>,  <expr>"/A: 50-73"</expr>,  <expr>1</expr>, <expr><block>{<expr><block>{<expr>49</expr>, <expr>99</expr>, <expr><name>TRUE</name></expr> }</block></expr>}</block></expr>}</block></expr>,
      <expr><block>{<expr>"/A: 60-99*"</expr>, <expr>"/A: 50-73"</expr>,  <expr>2</expr>, <expr><block>{<expr><block>{<expr>49</expr>, <expr>73</expr>, <expr><name>TRUE</name></expr> }</block></expr>, <expr><block>{<expr>73</expr>, <expr>99</expr>, <expr><name>FALSE</name></expr>}</block></expr>}</block></expr>}</block></expr>,
      <expr><block>{<expr>"/A: 60-99"</expr>,  <expr>"/A: 50-73*"</expr>, <expr>2</expr>, <expr><block>{<expr><block>{<expr>49</expr>, <expr>59</expr>, <expr><name>FALSE</name></expr>}</block></expr>, <expr><block>{<expr>59</expr>, <expr>99</expr>, <expr><name>TRUE</name></expr> }</block></expr>}</block></expr>}</block></expr>,
      <expr><block>{<expr>"/A: 60-99*"</expr>, <expr>"/A: 50-73*"</expr>, <expr>1</expr>, <expr><block>{<expr><block>{<expr>49</expr>, <expr>99</expr>, <expr><name>FALSE</name></expr>}</block></expr>}</block></expr>}</block></expr>,

      <comment type="block">/* Multiple ranges. */</comment>
      <expr><block>{<expr>"/A: 1-5,7,12-13"</expr>,    <expr>"/A: 2-17"</expr>,  <expr>1</expr>, <expr><block>{<expr><block>{<expr>0</expr>,  <expr>17</expr>, <expr><name>TRUE</name></expr> }</block></expr>}</block></expr>}</block></expr>,
      <expr><block>{<expr>"/A: 1-5*,7*,12-13*"</expr>, <expr>"/A: 2-17*"</expr>, <expr>1</expr>, <expr><block>{<expr><block>{<expr>0</expr>,  <expr>17</expr>, <expr><name>FALSE</name></expr>}</block></expr>}</block></expr>}</block></expr>,

      <expr><block>{<expr>"/A: 1-5,7,12-13"</expr>,    <expr>"/A: 2-17*"</expr>, <expr>6</expr>,
       <expr><block>{<expr><block>{<expr>0</expr>,  <expr>5</expr>, <expr><name>TRUE</name></expr> }</block></expr>, <expr><block>{ <expr>5</expr>,  <expr>6</expr>, <expr><name>FALSE</name></expr>}</block></expr>, <expr><block>{ <expr>6</expr>,  <expr>7</expr>, <expr><name>TRUE</name></expr> }</block></expr>,
        <expr><block>{<expr>7</expr>, <expr>11</expr>, <expr><name>FALSE</name></expr>}</block></expr>, <expr><block>{<expr>11</expr>, <expr>13</expr>, <expr><name>TRUE</name></expr> }</block></expr>, <expr><block>{<expr>13</expr>, <expr>17</expr>, <expr><name>FALSE</name></expr>}</block></expr>}</block></expr>}</block></expr>,

      <expr><block>{<expr>"/A: 1-5*,7*,12-13*"</expr>, <expr>"/A: 2-17"</expr>, <expr>2</expr>,
       <expr><block>{<expr><block>{<expr>0</expr>, <expr>1</expr>, <expr><name>FALSE</name></expr>}</block></expr>, <expr><block>{<expr>1</expr>, <expr>17</expr>, <expr><name>TRUE</name></expr> }</block></expr>}</block></expr>}</block></expr>,

      <expr><block>{<expr>"/A: 2-17"</expr>,  <expr>"/A: 1-5,7,12-13"</expr>,    <expr>1</expr>, <expr><block>{<expr><block>{<expr>0</expr>,  <expr>17</expr>, <expr><name>TRUE</name></expr> }</block></expr>}</block></expr>}</block></expr>,
      <expr><block>{<expr>"/A: 2-17*"</expr>, <expr>"/A: 1-5*,7*,12-13*"</expr>, <expr>1</expr>, <expr><block>{<expr><block>{<expr>0</expr>,  <expr>17</expr>, <expr><name>FALSE</name></expr>}</block></expr>}</block></expr>}</block></expr>,

      <expr><block>{<expr>"/A: 2-17*"</expr>, <expr>"/A: 1-5,7,12-13"</expr>, <expr>6</expr>,
       <expr><block>{<expr><block>{<expr>0</expr>,  <expr>5</expr>, <expr><name>TRUE</name></expr> }</block></expr>, <expr><block>{ <expr>5</expr>,  <expr>6</expr>, <expr><name>FALSE</name></expr>}</block></expr>, <expr><block>{ <expr>6</expr>,  <expr>7</expr>, <expr><name>TRUE</name></expr> }</block></expr>,
        <expr><block>{<expr>7</expr>, <expr>11</expr>, <expr><name>FALSE</name></expr>}</block></expr>, <expr><block>{<expr>11</expr>, <expr>13</expr>, <expr><name>TRUE</name></expr> }</block></expr>, <expr><block>{<expr>13</expr>, <expr>17</expr>, <expr><name>FALSE</name></expr>}</block></expr>}</block></expr>}</block></expr>,

      <expr><block>{<expr>"/A: 2-17"</expr>, <expr>"/A: 1-5*,7*,12-13*"</expr>, <expr>2</expr>,
       <expr><block>{<expr><block>{<expr>0</expr>, <expr>1</expr>, <expr><name>FALSE</name></expr>}</block></expr>, <expr><block>{<expr>1</expr>, <expr>17</expr>, <expr><name>TRUE</name></expr>}</block></expr>}</block></expr>}</block></expr>,

      <comment type="block">/* A rangelist merged with an empty rangelist should equal the
         non-empty rangelist but in compacted form. */</comment>
      <expr><block>{<expr>"/A: 1-44,45,46,47-50"</expr>,       <expr>""</expr>,  <expr>1</expr>, <expr><block>{<expr><block>{ <expr>0</expr>, <expr>50</expr>, <expr><name>TRUE</name></expr> }</block></expr>}</block></expr>}</block></expr>,
      <expr><block>{<expr>"/A: 1,2,3,4,5,6,7,8"</expr>,        <expr>""</expr>,  <expr>1</expr>, <expr><block>{<expr><block>{ <expr>0</expr>, <expr>8</expr>,  <expr><name>TRUE</name></expr> }</block></expr>}</block></expr>}</block></expr>,
      <expr><block>{<expr>"/A: 6-10,12-13,14,15,16-22"</expr>, <expr>""</expr>,  <expr>2</expr>,
       <expr><block>{<expr><block>{ <expr>5</expr>, <expr>10</expr>, <expr><name>TRUE</name></expr> }</block></expr>, <expr><block>{ <expr>11</expr>, <expr>22</expr>, <expr><name>TRUE</name></expr> }</block></expr>}</block></expr>}</block></expr>,
      <expr><block>{<expr>""</expr>, <expr>"/A: 1-44,45,46,47-50"</expr>,        <expr>1</expr>, <expr><block>{<expr><block>{ <expr>0</expr>, <expr>50</expr>, <expr><name>TRUE</name></expr> }</block></expr>}</block></expr>}</block></expr>,
      <expr><block>{<expr>""</expr>, <expr>"/A: 1,2,3,4,5,6,7,8"</expr>,         <expr>1</expr>, <expr><block>{<expr><block>{ <expr>0</expr>, <expr>8</expr>,  <expr><name>TRUE</name></expr> }</block></expr>}</block></expr>}</block></expr>,
      <expr><block>{<expr>""</expr>, <expr>"/A: 6-10,12-13,14,15,16-22"</expr>,  <expr>2</expr>,
       <expr><block>{<expr><block>{ <expr>5</expr>, <expr>10</expr>, <expr><name>TRUE</name></expr> }</block></expr>, <expr><block>{ <expr>11</expr>, <expr>22</expr>, <expr><name>TRUE</name></expr> }</block></expr>}</block></expr>}</block></expr>,

      <comment type="block">/* An empty rangelist merged with an empty rangelist is, drum-roll
         please, an empty rangelist. */</comment>
      <expr><block>{<expr>""</expr>, <expr>""</expr>, <expr>0</expr>, <expr><block>{<expr><block>{<expr>0</expr>, <expr>0</expr>, <expr><name>FALSE</name></expr>}</block></expr>}</block></expr>}</block></expr>
    }</block></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr>*<name>msg</name> = "merge of rangelists"</expr>;</expr_stmt>
  <if>if <condition>(<expr><name>msg_only</name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <expr_stmt><expr><name>err</name> = <name>child_err</name> = <name>SVN_NO_ERROR</name></expr>;</expr_stmt>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>SIZE_OF_RANGE_MERGE_TEST_ARRAY</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo_parse</name><argument_list>(<argument><expr>&amp;<name>info1</name></expr></argument>, <argument><expr>(<name><name>test_data</name><index>[<expr><name>i</name></expr>]</index></name>).<name>mergeinfo1</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo_parse</name><argument_list>(<argument><expr>&amp;<name>info2</name></expr></argument>, <argument><expr>(<name><name>test_data</name><index>[<expr><name>i</name></expr>]</index></name>).<name>mergeinfo2</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rangelist1</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>info1</name></expr></argument>, <argument><expr>"/A"</expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>rangelist2</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>info2</name></expr></argument>, <argument><expr>"/A"</expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Create empty rangelists if necessary. */</comment>
      <if>if <condition>(<expr><name>rangelist1</name> == <name>NULL</name></expr>)</condition><then>
        <expr_stmt><expr><name>rangelist1</name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>svn_merge_range_t</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
      <if>if <condition>(<expr><name>rangelist2</name> == <name>NULL</name></expr>)</condition><then>
        <expr_stmt><expr><name>rangelist2</name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>svn_merge_range_t</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_rangelist_merge</name><argument_list>(<argument><expr>&amp;<name>rangelist1</name></expr></argument>, <argument><expr><name>rangelist2</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>child_err</name> = <call><name>verify_ranges_match</name><argument_list>(<argument><expr><name>rangelist1</name></expr></argument>,
                                     <argument><expr>(<name><name>test_data</name><index>[<expr><name>i</name></expr>]</index></name>).<name>expected_merge</name></expr></argument>,
                                     <argument><expr>(<name><name>test_data</name><index>[<expr><name>i</name></expr>]</index></name>).<name>expected_ranges</name></expr></argument>,
                                     <argument><expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>,
                                                  <argument><expr>"svn_rangelist_merge "
                                                  "case %i"</expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>,
                                     <argument><expr>"merge"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Collect all the errors rather than returning on the first. */</comment>
      <if>if <condition>(<expr><name>child_err</name></expr>)</condition><then>
        <block>{
          <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>svn_error_compose</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>child_err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
          <else>else
            <expr_stmt><expr><name>err</name> = <name>child_err</name></expr>;</expr_stmt></else></if>
        }</block></then></if>
    }</block></for>
  <return>return <expr><name>err</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>test_rangelist_diff</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>msg</name></decl></param>,
                    <param><decl><type><name>svn_boolean_t</name></type> <name>msg_only</name></decl></param>,
                    <param><decl><type><name>svn_test_opts_t</name> *</type><name>opts</name></decl></param>,
                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>, *<decl><type ref="prev"/><name>child_err</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>from</name></decl>, *<decl><type ref="prev"/><name>to</name></decl>, *<decl><type ref="prev"/><name>added</name></decl>, *<decl><type ref="prev"/><name>deleted</name></decl>;</decl_stmt>

  <comment type="block">/* Structure containing two ranges to diff and the expected output of the
     diff both when considering and ignoring range inheritance. */</comment>
  <struct>struct <name>rangelist_diff_test_data</name>
  <block>{
    <comment type="block">/* svn:mergeinfo string representations */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>from</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>to</name></decl>;</decl_stmt>
    
    <comment type="block">/* Expected results for performing svn_rangelist_diff
       while considering differences in inheritability to be real
       differences. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>expected_add_ranges</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>svn_merge_range_t</name></type> <name><name>expected_adds</name><index>[<expr>10</expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>expected_del_ranges</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>svn_merge_range_t</name></type> <name><name>expected_dels</name><index>[<expr>10</expr>]</index></name></decl>;</decl_stmt>

    <comment type="block">/* Expected results for performing svn_rangelist_diff
       while ignoring differences in inheritability. */</comment>
    <decl_stmt><decl><type><name>int</name></type> <name>expected_add_ranges_ignore_inheritance</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>svn_merge_range_t</name></type> <name><name>expected_adds_ignore_inheritance</name><index>[<expr>10</expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>expected_del_ranges_ignore_inheritance</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>svn_merge_range_t</name></type> <name><name>expected_dels_ignore_inheritance</name><index>[<expr>10</expr>]</index></name></decl>;</decl_stmt>
  }</block>;</struct>

  <cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SIZE_OF_RANGE_DIFF_TEST_ARRAY</name></cpp:macro> <cpp:value>16</cpp:value></cpp:define>
  <comment type="block">/* The actual test data array.

                    'from' --&gt; {"/A: 1,5-8",  "/A: 1,6,10-12", &lt;-- 'to' 
      Number of adds when  --&gt;  1, { { 9, 12, TRUE } },
      considering inheritance

      Number of dels when  --&gt;  2, { { 4,  5, TRUE }, { 6, 8, TRUE } },
      considering inheritance

      Number of adds when  --&gt;  1, { { 9, 12, TRUE } },
      ignoring inheritance

      Number of dels when  --&gt;  2, { { 4,  5, TRUE }, { 6, 8, TRUE } } },
      ignoring inheritance
                                            ^               ^
                                    The expected svn_merge_range_t's
  */</comment>
  <decl_stmt><decl><type>struct <name>rangelist_diff_test_data</name></type> <name><name>test_data</name><index>[<expr><name>SIZE_OF_RANGE_DIFF_TEST_ARRAY</name></expr>]</index></name> <init>=
    <expr><block>{
      <comment type="block">/* Add and Delete */</comment>
      <expr><block>{<expr>"/A: 1"</expr>,  <expr>"/A: 3"</expr>,
       <expr>1</expr>, <expr><block>{ <expr><block>{ <expr>2</expr>, <expr>3</expr>, <expr><name>TRUE</name></expr> }</block></expr> }</block></expr>,
       <expr>1</expr>, <expr><block>{ <expr><block>{ <expr>0</expr>, <expr>1</expr>, <expr><name>TRUE</name></expr> }</block></expr> }</block></expr>,
       <expr>1</expr>, <expr><block>{ <expr><block>{ <expr>2</expr>, <expr>3</expr>, <expr><name>TRUE</name></expr> }</block></expr> }</block></expr>,
       <expr>1</expr>, <expr><block>{ <expr><block>{ <expr>0</expr>, <expr>1</expr>, <expr><name>TRUE</name></expr> }</block></expr> }</block></expr> }</block></expr>,

      <comment type="block">/* Add only */</comment>
      <expr><block>{<expr>"/A: 1"</expr>,  <expr>"/A: 1,3"</expr>,
       <expr>1</expr>, <expr><block>{ <expr><block>{ <expr>2</expr>, <expr>3</expr>, <expr><name>TRUE</name></expr> }</block></expr> }</block></expr>,
       <expr>0</expr>, <expr><block>{ <expr><block>{ <expr>0</expr>, <expr>0</expr>, <expr><name>FALSE</name></expr> }</block></expr> }</block></expr>,
       <expr>1</expr>, <expr><block>{ <expr><block>{ <expr>2</expr>, <expr>3</expr>, <expr><name>TRUE</name></expr> }</block></expr> }</block></expr>,
       <expr>0</expr>, <expr><block>{ <expr><block>{ <expr>0</expr>, <expr>0</expr>, <expr><name>FALSE</name></expr> }</block></expr> }</block></expr> }</block></expr>,

      <comment type="block">/* Delete only */</comment>
      <expr><block>{<expr>"/A: 1,3"</expr>,  <expr>"/A: 1"</expr>,
       <expr>0</expr>, <expr><block>{ <expr><block>{ <expr>0</expr>, <expr>0</expr>, <expr><name>FALSE</name></expr> }</block></expr> }</block></expr>,
       <expr>1</expr>, <expr><block>{ <expr><block>{ <expr>2</expr>, <expr>3</expr>, <expr><name>TRUE</name></expr>  }</block></expr> }</block></expr>,
       <expr>0</expr>, <expr><block>{ <expr><block>{ <expr>0</expr>, <expr>0</expr>, <expr><name>FALSE</name></expr> }</block></expr> }</block></expr>,
       <expr>1</expr>, <expr><block>{ <expr><block>{ <expr>2</expr>, <expr>3</expr>, <expr><name>TRUE</name></expr>  }</block></expr> }</block></expr> }</block></expr>,

      <comment type="block">/* No diff */</comment>
      <expr><block>{<expr>"/A: 1,3"</expr>,  <expr>"/A: 1,3"</expr>,
       <expr>0</expr>, <expr><block>{ <expr><block>{ <expr>0</expr>, <expr>0</expr>, <expr><name>FALSE</name></expr> }</block></expr> }</block></expr>,
       <expr>0</expr>, <expr><block>{ <expr><block>{ <expr>0</expr>, <expr>0</expr>, <expr><name>FALSE</name></expr> }</block></expr> }</block></expr>,
       <expr>0</expr>, <expr><block>{ <expr><block>{ <expr>0</expr>, <expr>0</expr>, <expr><name>FALSE</name></expr> }</block></expr> }</block></expr>,
       <expr>0</expr>, <expr><block>{ <expr><block>{ <expr>0</expr>, <expr>0</expr>, <expr><name>FALSE</name></expr> }</block></expr> }</block></expr> }</block></expr>,

      <expr><block>{<expr>"/A: 1,3*"</expr>,  <expr>"/A: 1,3*"</expr>,
       <expr>0</expr>, <expr><block>{ <expr><block>{ <expr>0</expr>, <expr>0</expr>, <expr><name>FALSE</name></expr> }</block></expr> }</block></expr>,
       <expr>0</expr>, <expr><block>{ <expr><block>{ <expr>0</expr>, <expr>0</expr>, <expr><name>FALSE</name></expr> }</block></expr> }</block></expr>,
       <expr>0</expr>, <expr><block>{ <expr><block>{ <expr>0</expr>, <expr>0</expr>, <expr><name>FALSE</name></expr> }</block></expr> }</block></expr>,
       <expr>0</expr>, <expr><block>{ <expr><block>{ <expr>0</expr>, <expr>0</expr>, <expr><name>FALSE</name></expr> }</block></expr> }</block></expr> }</block></expr>,

      <comment type="block">/* Adds and Deletes */</comment>
      <expr><block>{<expr>"/A: 1,5-8"</expr>,  <expr>"/A: 1,6,10-12"</expr>,
       <expr>1</expr>, <expr><block>{ <expr><block>{ <expr>9</expr>, <expr>12</expr>, <expr><name>TRUE</name></expr> }</block></expr> }</block></expr>,
       <expr>2</expr>, <expr><block>{ <expr><block>{ <expr>4</expr>, <expr>5</expr>, <expr><name>TRUE</name></expr> }</block></expr>, <expr><block>{ <expr>6</expr>, <expr>8</expr>, <expr><name>TRUE</name></expr> }</block></expr> }</block></expr>,
       <expr>1</expr>, <expr><block>{ <expr><block>{ <expr>9</expr>, <expr>12</expr>, <expr><name>TRUE</name></expr> }</block></expr> }</block></expr>,
       <expr>2</expr>, <expr><block>{ <expr><block>{ <expr>4</expr>, <expr>5</expr>, <expr><name>TRUE</name></expr> }</block></expr>, <expr><block>{ <expr>6</expr>, <expr>8</expr>, <expr><name>TRUE</name></expr> }</block></expr> }</block></expr> }</block></expr>,

      <expr><block>{<expr>"/A: 6*"</expr>,  <expr>"/A: 6"</expr>,
       <expr>1</expr>, <expr><block>{ <expr><block>{ <expr>5</expr>, <expr>6</expr>, <expr><name>TRUE</name></expr>  }</block></expr> }</block></expr>,
       <expr>1</expr>, <expr><block>{ <expr><block>{ <expr>5</expr>, <expr>6</expr>, <expr><name>FALSE</name></expr> }</block></expr> }</block></expr>,
       <expr>0</expr>, <expr><block>{ <expr><block>{ <expr>0</expr>, <expr>0</expr>, <expr><name>FALSE</name></expr> }</block></expr> }</block></expr>,
       <expr>0</expr>, <expr><block>{ <expr><block>{ <expr>0</expr>, <expr>0</expr>, <expr><name>FALSE</name></expr> }</block></expr> }</block></expr> }</block></expr>,

      <comment type="block">/* Intersecting range with different inheritability */</comment>
      <expr><block>{<expr>"/A: 6"</expr>,  <expr>"/A: 6*"</expr>,
       <expr>1</expr>, <expr><block>{ <expr><block>{ <expr>5</expr>, <expr>6</expr>, <expr><name>FALSE</name></expr> }</block></expr> }</block></expr>,
       <expr>1</expr>, <expr><block>{ <expr><block>{ <expr>5</expr>, <expr>6</expr>, <expr><name>TRUE</name></expr>  }</block></expr> }</block></expr>,
       <expr>0</expr>, <expr><block>{ <expr><block>{ <expr>0</expr>, <expr>0</expr>, <expr><name>FALSE</name></expr> }</block></expr> }</block></expr>,
       <expr>0</expr>, <expr><block>{ <expr><block>{ <expr>0</expr>, <expr>0</expr>, <expr><name>FALSE</name></expr> }</block></expr> }</block></expr> }</block></expr>,

      <expr><block>{<expr>"/A: 6*"</expr>,  <expr>"/A: 6"</expr>,
       <expr>1</expr>, <expr><block>{ <expr><block>{ <expr>5</expr>, <expr>6</expr>, <expr><name>TRUE</name></expr>  }</block></expr> }</block></expr>,
       <expr>1</expr>, <expr><block>{ <expr><block>{ <expr>5</expr>, <expr>6</expr>, <expr><name>FALSE</name></expr> }</block></expr> }</block></expr>,
       <expr>0</expr>, <expr><block>{ <expr><block>{ <expr>0</expr>, <expr>0</expr>, <expr><name>FALSE</name></expr> }</block></expr> }</block></expr>,
       <expr>0</expr>, <expr><block>{ <expr><block>{ <expr>0</expr>, <expr>0</expr>, <expr><name>FALSE</name></expr> }</block></expr> }</block></expr> }</block></expr>,

      <expr><block>{<expr>"/A: 1,5-8"</expr>,  <expr>"/A: 1,6*,10-12"</expr>,
       <expr>2</expr>, <expr><block>{ <expr><block>{ <expr>5</expr>,  <expr>6</expr>, <expr><name>FALSE</name></expr> }</block></expr>, <expr><block>{ <expr>9</expr>, <expr>12</expr>, <expr><name>TRUE</name></expr> }</block></expr> }</block></expr>,
       <expr>1</expr>, <expr><block>{ <expr><block>{ <expr>4</expr>,  <expr>8</expr>, <expr><name>TRUE</name></expr>  }</block></expr> }</block></expr>,
       <expr>1</expr>, <expr><block>{ <expr><block>{ <expr>9</expr>, <expr>12</expr>, <expr><name>TRUE</name></expr>  }</block></expr> }</block></expr>,
       <expr>2</expr>, <expr><block>{ <expr><block>{ <expr>4</expr>,  <expr>5</expr>, <expr><name>TRUE</name></expr>  }</block></expr>, <expr><block>{ <expr>6</expr>,  <expr>8</expr>, <expr><name>TRUE</name></expr> }</block></expr> }</block></expr> }</block></expr>,

     <expr><block>{<expr>"/A: 1,5-8*"</expr>,  <expr>"/A: 1,6,10-12"</expr>,
       <expr>2</expr>, <expr><block>{ <expr><block>{ <expr>5</expr>,  <expr>6</expr>, <expr><name>TRUE</name></expr>  }</block></expr>, <expr><block>{ <expr>9</expr>, <expr>12</expr>, <expr><name>TRUE</name></expr>  }</block></expr> }</block></expr>,
       <expr>1</expr>, <expr><block>{ <expr><block>{ <expr>4</expr>,  <expr>8</expr>, <expr><name>FALSE</name></expr> }</block></expr> }</block></expr>,
       <expr>1</expr>, <expr><block>{ <expr><block>{ <expr>9</expr>, <expr>12</expr>, <expr><name>TRUE</name></expr>  }</block></expr> }</block></expr>,
       <expr>2</expr>, <expr><block>{ <expr><block>{ <expr>4</expr>,  <expr>5</expr>, <expr><name>FALSE</name></expr> }</block></expr>, <expr><block>{ <expr>6</expr>,  <expr>8</expr>, <expr><name>FALSE</name></expr> }</block></expr> }</block></expr> }</block></expr>,

      <comment type="block">/* Empty range diffs */</comment>
      <expr><block>{<expr>"/A: 3-9"</expr>,  <expr>""</expr>,
       <expr>0</expr>, <expr><block>{ <expr><block>{ <expr>0</expr>, <expr>0</expr>, <expr><name>FALSE</name></expr> }</block></expr> }</block></expr>,
       <expr>1</expr>, <expr><block>{ <expr><block>{ <expr>2</expr>, <expr>9</expr>, <expr><name>TRUE</name></expr>  }</block></expr> }</block></expr>,
       <expr>0</expr>, <expr><block>{ <expr><block>{ <expr>0</expr>, <expr>0</expr>, <expr><name>FALSE</name></expr> }</block></expr> }</block></expr>,
       <expr>1</expr>, <expr><block>{ <expr><block>{ <expr>2</expr>, <expr>9</expr>, <expr><name>TRUE</name></expr>  }</block></expr> }</block></expr> }</block></expr>,

      <expr><block>{<expr>"/A: 3-9*"</expr>,  <expr>""</expr>,
       <expr>0</expr>, <expr><block>{ <expr><block>{ <expr>0</expr>, <expr>0</expr>, <expr><name>FALSE</name></expr> }</block></expr> }</block></expr>,
       <expr>1</expr>, <expr><block>{ <expr><block>{ <expr>2</expr>, <expr>9</expr>, <expr><name>FALSE</name></expr> }</block></expr> }</block></expr>,
       <expr>0</expr>, <expr><block>{ <expr><block>{ <expr>0</expr>, <expr>0</expr>, <expr><name>FALSE</name></expr> }</block></expr> }</block></expr>,
       <expr>1</expr>, <expr><block>{ <expr><block>{ <expr>2</expr>, <expr>9</expr>, <expr><name>FALSE</name></expr> }</block></expr> }</block></expr> }</block></expr>,

      <expr><block>{<expr>""</expr>,  <expr>"/A: 3-9"</expr>,
       <expr>1</expr>, <expr><block>{ <expr><block>{ <expr>2</expr>, <expr>9</expr>, <expr><name>TRUE</name></expr>  }</block></expr> }</block></expr>,
       <expr>0</expr>, <expr><block>{ <expr><block>{ <expr>0</expr>, <expr>0</expr>, <expr><name>FALSE</name></expr> }</block></expr> }</block></expr>,
       <expr>1</expr>, <expr><block>{ <expr><block>{ <expr>2</expr>, <expr>9</expr>, <expr><name>TRUE</name></expr>  }</block></expr> }</block></expr>,
       <expr>0</expr>, <expr><block>{ <expr><block>{ <expr>0</expr>, <expr>0</expr>, <expr><name>FALSE</name></expr> }</block></expr> }</block></expr> }</block></expr>,

      <expr><block>{<expr>""</expr>,  <expr>"/A: 3-9*"</expr>,
       <expr>1</expr>, <expr><block>{ <expr><block>{ <expr>2</expr>, <expr>9</expr>, <expr><name>FALSE</name></expr> }</block></expr> }</block></expr>,
       <expr>0</expr>, <expr><block>{ <expr><block>{ <expr>0</expr>, <expr>0</expr>, <expr><name>FALSE</name></expr> }</block></expr> }</block></expr>,
       <expr>1</expr>, <expr><block>{ <expr><block>{ <expr>2</expr>, <expr>9</expr>, <expr><name>FALSE</name></expr> }</block></expr> }</block></expr>,
       <expr>0</expr>, <expr><block>{ <expr><block>{ <expr>0</expr>, <expr>0</expr>, <expr><name>FALSE</name></expr> }</block></expr> }</block></expr> }</block></expr>,

       <comment type="block">/* Empty range no diff */</comment>
      <expr><block>{<expr>""</expr>,  <expr>""</expr>,
       <expr>0</expr>, <expr><block>{ <expr><block>{ <expr>0</expr>, <expr>0</expr>, <expr><name>FALSE</name></expr> }</block></expr> }</block></expr>,
       <expr>0</expr>, <expr><block>{ <expr><block>{ <expr>0</expr>, <expr>0</expr>, <expr><name>FALSE</name></expr> }</block></expr> }</block></expr>,
       <expr>0</expr>, <expr><block>{ <expr><block>{ <expr>0</expr>, <expr>0</expr>, <expr><name>FALSE</name></expr> }</block></expr> }</block></expr>,
       <expr>0</expr>, <expr><block>{ <expr><block>{ <expr>0</expr>, <expr>0</expr>, <expr><name>FALSE</name></expr> }</block></expr> }</block></expr> }</block></expr>,
    }</block></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr>*<name>msg</name> = "diff of rangelists"</expr>;</expr_stmt>
  <if>if <condition>(<expr><name>msg_only</name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <expr_stmt><expr><name>err</name> = <name>child_err</name> = <name>SVN_NO_ERROR</name></expr>;</expr_stmt>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>SIZE_OF_RANGE_DIFF_TEST_ARRAY</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo_parse</name><argument_list>(<argument><expr>&amp;<name>info1</name></expr></argument>, <argument><expr>(<name><name>test_data</name><index>[<expr><name>i</name></expr>]</index></name>).<name>to</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo_parse</name><argument_list>(<argument><expr>&amp;<name>info2</name></expr></argument>, <argument><expr>(<name><name>test_data</name><index>[<expr><name>i</name></expr>]</index></name>).<name>from</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>to</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>info1</name></expr></argument>, <argument><expr>"/A"</expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>from</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>info2</name></expr></argument>, <argument><expr>"/A"</expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Represent empty mergeinfo with an empty rangelist. */</comment>
      <if>if <condition>(<expr><name>to</name> == <name>NULL</name></expr>)</condition><then>
        <expr_stmt><expr><name>to</name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>to</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
      <if>if <condition>(<expr><name>from</name> == <name>NULL</name></expr>)</condition><then>
        <expr_stmt><expr><name>from</name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>from</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

      <comment type="block">/* First diff the ranges while considering
         differences in inheritance. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_rangelist_diff</name><argument_list>(<argument><expr>&amp;<name>deleted</name></expr></argument>, <argument><expr>&amp;<name>added</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>to</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>child_err</name> = <call><name>verify_ranges_match</name><argument_list>(<argument><expr><name>added</name></expr></argument>,
                                     <argument><expr>(<name><name>test_data</name><index>[<expr><name>i</name></expr>]</index></name>).<name>expected_adds</name></expr></argument>,
                                     <argument><expr>(<name><name>test_data</name><index>[<expr><name>i</name></expr>]</index></name>).<name>expected_add_ranges</name></expr></argument>,
                                     <argument><expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>,
                                                  <argument><expr>"svn_rangelist_diff"
                                                  "case %i"</expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>,
                                     <argument><expr>"diff"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr>!<name>child_err</name></expr>)</condition><then>
        <expr_stmt><expr><name>child_err</name> = <call><name>verify_ranges_match</name><argument_list>(<argument><expr><name>deleted</name></expr></argument>,
                                        <argument><expr>(<name><name>test_data</name><index>[<expr><name>i</name></expr>]</index></name>).<name>expected_dels</name></expr></argument>,
                                        <argument><expr>(<name><name>test_data</name><index>[<expr><name>i</name></expr>]</index></name>).<name>expected_del_ranges</name></expr></argument>,
                                        <argument><expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>,
                                                     <argument><expr>"svn_rangelist_diff"
                                                     "case %i"</expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>,
                                                     <argument><expr>"diff"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
      <if>if <condition>(<expr>!<name>child_err</name></expr>)</condition><then>
        <block>{
          <comment type="block">/* Now do the diff while ignoring differences in inheritance. */</comment>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_rangelist_diff</name><argument_list>(<argument><expr>&amp;<name>deleted</name></expr></argument>, <argument><expr>&amp;<name>added</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>to</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                                     <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>child_err</name> = <call><name>verify_ranges_match</name><argument_list>(
            <argument><expr><name>added</name></expr></argument>,
            <argument><expr>(<name><name>test_data</name><index>[<expr><name>i</name></expr>]</index></name>).<name>expected_adds_ignore_inheritance</name></expr></argument>,
            <argument><expr>(<name><name>test_data</name><index>[<expr><name>i</name></expr>]</index></name>).<name>expected_add_ranges_ignore_inheritance</name></expr></argument>,
            <argument><expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"svn_rangelist_diff case %i"</expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr>"diff"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <if>if <condition>(<expr>!<name>child_err</name></expr>)</condition><then>
            <expr_stmt><expr><name>child_err</name> = <call><name>verify_ranges_match</name><argument_list>(
              <argument><expr><name>deleted</name></expr></argument>,
              <argument><expr>(<name><name>test_data</name><index>[<expr><name>i</name></expr>]</index></name>).<name>expected_dels_ignore_inheritance</name></expr></argument>,
              <argument><expr>(<name><name>test_data</name><index>[<expr><name>i</name></expr>]</index></name>).<name>expected_del_ranges_ignore_inheritance</name></expr></argument>,
              <argument><expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"svn_rangelist_diff case %i"</expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>,
              <argument><expr>"diff"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        }</block></then></if>

      <comment type="block">/* Collect all the errors rather than returning on the first. */</comment>
      <if>if <condition>(<expr><name>child_err</name></expr>)</condition><then>
        <block>{
          <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>svn_error_compose</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>child_err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
          <else>else
            <expr_stmt><expr><name>err</name> = <name>child_err</name></expr>;</expr_stmt></else></if>
        }</block></then></if>
    }</block></for>
  <return>return <expr><name>err</name></expr>;</return>
}</block></function>
<escape char="0xc"/>
<comment type="block">/* The test table.  */</comment>

<decl_stmt><decl><type>struct <name>svn_test_descriptor_t</name></type> <name><name>test_funcs</name><index>[]</index></name> <init>=
  <expr><block>{
    <expr><name>SVN_TEST_NULL</name></expr>,
    <expr><call><name>SVN_TEST_PASS</name><argument_list>(<argument><expr><name>test_parse_single_line_mergeinfo</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>SVN_TEST_PASS</name><argument_list>(<argument><expr><name>test_mergeinfo_dup</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>SVN_TEST_PASS</name><argument_list>(<argument><expr><name>test_parse_combine_rangeinfo</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>SVN_TEST_PASS</name><argument_list>(<argument><expr><name>test_parse_broken_mergeinfo</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>SVN_TEST_PASS</name><argument_list>(<argument><expr><name>test_remove_rangelist</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>SVN_TEST_PASS</name><argument_list>(<argument><expr><name>test_rangelist_remove_randomly</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>SVN_TEST_PASS</name><argument_list>(<argument><expr><name>test_remove_mergeinfo</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>SVN_TEST_PASS</name><argument_list>(<argument><expr><name>test_rangelist_reverse</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>SVN_TEST_PASS</name><argument_list>(<argument><expr><name>test_rangelist_intersect</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>SVN_TEST_PASS</name><argument_list>(<argument><expr><name>test_rangelist_intersect_randomly</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>SVN_TEST_PASS</name><argument_list>(<argument><expr><name>test_diff_mergeinfo</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>SVN_TEST_PASS</name><argument_list>(<argument><expr><name>test_merge_mergeinfo</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>SVN_TEST_PASS</name><argument_list>(<argument><expr><name>test_mergeinfo_intersect</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>SVN_TEST_PASS</name><argument_list>(<argument><expr><name>test_rangelist_to_string</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>SVN_TEST_PASS</name><argument_list>(<argument><expr><name>test_mergeinfo_to_string</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>SVN_TEST_PASS</name><argument_list>(<argument><expr><name>test_rangelist_merge</name></expr></argument>)</argument_list></call></expr>,
    <expr><call><name>SVN_TEST_PASS</name><argument_list>(<argument><expr><name>test_rangelist_diff</name></expr></argument>)</argument_list></call></expr>,
    <expr><name>SVN_TEST_NULL</name></expr>
  }</block></expr></init></decl>;</decl_stmt>
</unit>
