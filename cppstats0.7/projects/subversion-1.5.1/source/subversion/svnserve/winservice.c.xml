<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/subversion-1.5.1/source/subversion/svnserve/winservice.c"><comment type="block">/*
 * winservice.c : Implementation of Windows Service support
 *
 * ====================================================================
 * Copyright (c) 2000-2006 CollabNet.  All rights reserved.
 *
 * This software is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at http://subversion.tigris.org/license-1.html.
 * If newer versions of this license are posted there, you may use a
 * newer version instead, at your option.
 *
 * This software consists of voluntary contributions made by many
 * individuals.  For exact contribution history, see the revision
 * history and logs, available at http://subversion.tigris.org/.
 * ====================================================================
 */</comment>


<escape char="0xc"/>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APR_WANT_STRFUNC</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_want.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_errno.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_error.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_private_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"winservice.h"</cpp:file></cpp:include>

<comment type="block">/*
Design Notes
------------

The code in this file allows svnserve to run as a Windows service.
Windows Services are only supported on operating systems derived
from Windows NT, which is basically all modern versions of Windows
(2000, XP, Server, Vista, etc.) and excludes the Windows 9x line.

Windows Services are processes that are started and controlled by
the Service Control Manager.  When the SCM wants to start a service,
it creates the process, then waits for the process to connect to
the SCM, so that the SCM and service process can communicate.
This is done using the StartServiceCtrlDispatcher function.

In order to minimize changes to the svnserve startup logic, this
implementation differs slightly from most service implementations.
In most services, main() immediately calls StartServiceCtrlDispatcher,
which does not return control to main() until the SCM sends the
"stop" request to the service, and the service stops.


Installing the Service
----------------------

Installation is beyond the scope of source code comments.  There
is a separate document that describes how to install and uninstall
the service.  Basically, you create a Windows Service, give it a
binary path that points to svnserve.exe, and make sure that you
specify --service on the command line.


Starting the Service
--------------------

First, the SCM decides that it wants to start a service.  It creates
the process for the service, passing it the command-line that is
stored in the service configuration (stored in the registry).

Next, main() runs.  The command-line should contain the --service
argument, which is the hint that svnserve is running under the SCM,
not as a standalone process.  main() calls winservice_start().

winservice_start() creates an event object (winservice_start_event),
and creates and starts a separate thread, the "dispatcher" thread.
winservice_start() then waits for either winservice_start_event
to fire (meaning: "the dispatcher thread successfully connected
to the SCM, and now the service is starting") or for the dispatcher
thread to exit (meaning: "failed to connect to SCM").

If the dispatcher thread quit, then winservice_start returns an error.
If the start event fired, then winservice_start returns a success code
(SVN_NO_ERROR).  At this point, the service is now in the "starting"
state, from the perspective of the SCM.  winservice_start also registers
an atexit handler, which handles cleaning up some of the service logic,
as explained below in "Stopping the Service".

Next, control returns to main(), which performs the usual startup
logic for svnserve.  Mostly, it creates the listener socket.  If
main() was able to start the service, then it calls the function
winservice_running().

winservice_running() informs the SCM that the service has finished
starting, and is now in the "running" state.  main() then does its
work, accepting client sockets and processing SVN requests.

Stopping the Service
--------------------

At some point, the SCM will decide to stop the service, either because
an administrator chose to stop the service, or the system is shutting
down.  To do this, the SCM calls winservice_handler() with the
SERVICE_CONTROL_STOP control code.  When this happens,
winservice_handler() will inform the SCM that the service is now
in the "stopping" state, and will call winservice_notify_stop().

winservice_notify_stop() is responsible for cleanly shutting down the
svnserve logic (waiting for client requests to finish, stopping database
access, etc.).  Right now, all it does is close the listener socket,
which causes the apr_socket_accept() call in main() to fail.  main()
then calls exit(), which processes all atexit() handlers, which
results in winservice_stop() being called.

winservice_stop() notifies the SCM that the service is now stopped,
and then waits for the dispatcher thread to exit.  Because all services
in the process have now stopped, the call to StartServiceCtrlDispatcher
(in the dispatcher thread) finally returns, and winservice_stop() returns,
and the process finally exits.
*/</comment>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;winsvc.h&gt;</cpp:file></cpp:include>

<comment type="block">/* This is just a placeholder, and doesn't actually constrain the
  service name.  You have to provide *some* service name to the SCM
  API, but for services that are marked SERVICE_WIN32_OWN_PROCESS (as
  is the case for svnserve), the service name is ignored.  It *is*
  relevant for service binaries that run more than one service in a
  single process. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WINSERVICE_SERVICE_NAME</name></cpp:macro> <cpp:value>"svnserve"</cpp:value></cpp:define>


<comment type="block">/* Win32 handle to the dispatcher thread. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>HANDLE</name></type> <name>winservice_dispatcher_thread</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Win32 event handle, used to notify winservice_start() that we have
   successfully connected to the SCM. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>HANDLE</name></type> <name>winservice_start_event</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* RPC handle that allows us to notify the SCM of changes in our
   service status. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>SERVICE_STATUS_HANDLE</name></type> <name>winservice_status_handle</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Our current idea of the service status (stopped, running, controls
   accepted, exit code, etc.) */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>SERVICE_STATUS</name></type> <name>winservice_status</name></decl>;</decl_stmt>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SVN_DEBUG</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>void</name></type> <name>dbg_print</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>text</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>OutputDebugStringA</name><argument_list>(<argument><expr><name>text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<comment type="block">/* Make sure dbg_print compiles to nothing in release builds. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>dbg_print</name><parameter_list>(<param><type><name>text</name></type></param>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>winservice_atexit</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/* Notifies the Service Control Manager of the current state of the
   service. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>winservice_update_state</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>winservice_status_handle</name> != <name>NULL</name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr>!<call><name>SetServiceStatus</name><argument_list>(<argument><expr><name>winservice_status_handle</name></expr></argument>, <argument><expr>&amp;<name>winservice_status</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>dbg_print</name><argument_list>(<argument><expr>"SetServiceStatus - FAILED\r\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>
}</block></function>


<comment type="block">/* This function cleans up state associated with the service support.
   If the dispatcher thread handle is non-NULL, then this function
   will wait for the dispatcher thread to exit. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>winservice_cleanup</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>winservice_start_event</name> != <name>NULL</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>winservice_start_event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>winservice_start_event</name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></then></if>

  <if>if <condition>(<expr><name>winservice_dispatcher_thread</name> != <name>NULL</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>dbg_print</name><argument_list>(<argument><expr>"winservice_cleanup:"
                " waiting for dispatcher thread to exit\r\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>WaitForSingleObject</name><argument_list>(<argument><expr><name>winservice_dispatcher_thread</name></expr></argument>, <argument><expr><name>INFINITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>winservice_dispatcher_thread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>winservice_dispatcher_thread</name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>


<comment type="block">/* The SCM invokes this function to cause state changes in the
   service. */</comment>
<function><type><specifier>static</specifier> <name>void</name> <name>WINAPI</name></type>
<name>winservice_handler</name><parameter_list>(<param><decl><type><name>DWORD</name></type> <name>control</name></decl></param>)</parameter_list>
<block>{
  <switch>switch <condition>(<expr><name>control</name></expr>)</condition>
    <block>{
    <case>case <expr><name>SERVICE_CONTROL_INTERROGATE</name></expr>:
      <comment type="block">/* The SCM just wants to check our state.  We are required to
         call SetServiceStatus, but we don't need to make any state
         changes. */</comment>
      <expr_stmt><expr><call><name>dbg_print</name><argument_list>(<argument><expr>"SERVICE_CONTROL_INTERROGATE\r\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>winservice_update_state</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>

    </case><case>case <expr><name>SERVICE_CONTROL_STOP</name></expr>:
      <expr_stmt><expr><call><name>dbg_print</name><argument_list>(<argument><expr>"SERVICE_CONTROL_STOP\r\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>winservice_status</name>.<name>dwCurrentState</name></name> = <name>SERVICE_STOP_PENDING</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>winservice_update_state</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>winservice_notify_stop</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <break>break;</break>
    </case>}</block></switch>
}</block></function>


<comment type="block">/* This is the "service main" routine (in the Win32 terminology).

   Normally, this function (thread) implements the "main" loop of a
   service.  However, in order to minimize changes to the svnserve
   main() function, this function is running in a different thread,
   and main() is blocked in winservice_start(), waiting for
   winservice_start_event.  So this function (thread) only needs to
   signal that event to "start" the service.

   If this function succeeds, it signals winservice_start_event, which
   wakes up the winservice_start() frame that is blocked. */</comment>
<function><type><specifier>static</specifier> <name>void</name> <name>WINAPI</name></type>
<name>winservice_service_main</name><parameter_list>(<param><decl><type><name>DWORD</name></type> <name>argc</name></decl></param>, <param><decl><type><name>LPTSTR</name> *</type><name>argv</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>DWORD</name></type> <name>error</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>winservice_start_event</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>winservice_status_handle</name> =
    <call><name>RegisterServiceCtrlHandler</name><argument_list>(<argument><expr><name>WINSERVICE_SERVICE_NAME</name></expr></argument>, <argument><expr><name>winservice_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>winservice_status_handle</name> == <name>NULL</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* Ok, that's not fair.  We received a request to start a service,
         and now we cannot bind to the SCM in order to update status?
         Bring down the app. */</comment>
      <expr_stmt><expr><name>error</name> = <call><name>GetLastError</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>dbg_print</name><argument_list>(<argument><expr>"RegisterServiceCtrlHandler FAILED\r\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* Put the error code somewhere where winservice_start can find it. */</comment>
      <expr_stmt><expr><name><name>winservice_status</name>.<name>dwWin32ExitCode</name></name> = <name>error</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SetEvent</name><argument_list>(<argument><expr><name>winservice_start_event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    }</block></then></if>

  <expr_stmt><expr><name><name>winservice_status</name>.<name>dwCurrentState</name></name> = <name>SERVICE_START_PENDING</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>winservice_status</name>.<name>dwWin32ExitCode</name></name> = <name>ERROR_SUCCESS</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>winservice_update_state</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>dbg_print</name><argument_list>(<argument><expr>"winservice_service_main: service is starting\r\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SetEvent</name><argument_list>(<argument><expr><name>winservice_start_event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>SERVICE_TABLE_ENTRY</name></type> <name><name>winservice_service_table</name><index>[]</index></name> <init>=
  <expr><block>{
    <expr><block>{ <expr><name>WINSERVICE_SERVICE_NAME</name></expr>, <expr><name>winservice_service_main</name></expr> }</block></expr>,
    <expr><block>{ <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr> }</block></expr>
  }</block></expr></init></decl>;</decl_stmt>


<comment type="block">/* This is the thread routine for the "dispatcher" thread.  The
   purpose of this thread is to connect this process with the Service
   Control Manager, which allows this process to receive control
   requests from the SCM, and allows this process to update the SCM
   with status information.

   The StartServiceCtrlDispatcher connects this process to the SCM.
   If it succeeds, then it will not return until all of the services
   running in this process have stopped.  (In our case, there is only
   one service per process.) */</comment>
<function><type><specifier>static</specifier> <name>DWORD</name> <name>WINAPI</name></type>
<name>winservice_dispatcher_thread_routine</name><parameter_list>(<param><decl><type><name>PVOID</name></type> <name>arg</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>dbg_print</name><argument_list>(<argument><expr>"winservice_dispatcher_thread_routine: starting\r\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr>!<call><name>StartServiceCtrlDispatcher</name><argument_list>(<argument><expr><name>winservice_service_table</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <comment type="block">/* This is a common error.  Usually, it means the user has
         invoked the service with the --service flag directly.  This
         is incorrect.  The only time the --service flag is passed is
         when the process is being started by the SCM. */</comment>
      <decl_stmt><decl><type><name>DWORD</name></type> <name>error</name> <init>= <expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>dbg_print</name><argument_list>(<argument><expr>"dispatcher: FAILED to connect to SCM\r\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>error</name></expr>;</return>
    }</block></then></if>

  <expr_stmt><expr><call><name>dbg_print</name><argument_list>(<argument><expr>"dispatcher: SCM is done using this process -- exiting\r\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>ERROR_SUCCESS</name></expr>;</return>
}</block></function>


<comment type="block">/* If svnserve needs to run as a Win32 service, then we need to
   coordinate with the Service Control Manager (SCM) before
   continuing.  This function call registers the svnserve.exe process
   with the SCM, waits for the "start" command from the SCM (which
   will come very quickly), and confirms that those steps succeeded.

   After this call succeeds, the service should perform whatever work
   it needs to start the service, and then the service should call
   winservice_running() (if no errors occurred) or winservice_stop()
   (if something failed during startup). */</comment>
<function><type><name>svn_error_t</name> *</type>
<name>winservice_start</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>HANDLE</name></type> <name><name>handles</name><index>[<expr>2</expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DWORD</name></type> <name>thread_id</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DWORD</name></type> <name>error_code</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_status_t</name></type> <name>apr_status</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>DWORD</name></type> <name>wait_status</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>dbg_print</name><argument_list>(<argument><expr>"winservice_start: starting svnserve as a service...\r\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>ZeroMemory</name><argument_list>(<argument><expr>&amp;<name>winservice_status</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>winservice_status</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>winservice_status</name>.<name>dwServiceType</name></name> = <name>SERVICE_WIN32_OWN_PROCESS</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>winservice_status</name>.<name>dwControlsAccepted</name></name> = <name>SERVICE_ACCEPT_STOP</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>winservice_status</name>.<name>dwCurrentState</name></name> = <name>SERVICE_STOPPED</name></expr>;</expr_stmt>

  <comment type="block">/* Create the event that will wake up this thread when the SCM
     creates the ServiceMain thread. */</comment>
  <expr_stmt><expr><name>winservice_start_event</name> = <call><name>CreateEvent</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>winservice_start_event</name> == <name>NULL</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>apr_status</name> = <call><name>apr_get_os_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><call><name>svn_error_wrap_apr</name><argument_list>(<argument><expr><name>apr_status</name></expr></argument>,
                                <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Failed to create winservice_start_event"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

  <expr_stmt><expr><name>winservice_dispatcher_thread</name> =
    (<name>HANDLE</name>)<call><name>_beginthreadex</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>winservice_dispatcher_thread_routine</name></expr></argument>,
                           <argument><expr><name>NULL</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>&amp;<name>thread_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>winservice_dispatcher_thread</name> == <name>NULL</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>apr_status</name> = <call><name>apr_get_os_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>winservice_cleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><call><name>svn_error_wrap_apr</name><argument_list>(<argument><expr><name>apr_status</name></expr></argument>,
                                <argument><expr><call><name>_</name><argument_list>(<argument><expr>"The service failed to start"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

  <comment type="block">/* Next, we wait for the "start" event to fire (meaning the service
     logic has successfully started), or for the dispatch thread to
     exit (meaning the service logic could not start). */</comment>

  <expr_stmt><expr><name><name>handles</name><index>[<expr>0</expr>]</index></name> = <name>winservice_start_event</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>handles</name><index>[<expr>1</expr>]</index></name> = <name>winservice_dispatcher_thread</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>wait_status</name> = <call><name>WaitForMultipleObjects</name><argument_list>(<argument><expr>2</expr></argument>, <argument><expr><name>handles</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>INFINITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <switch>switch <condition>(<expr><name>wait_status</name></expr>)</condition>
    <block>{
    <case>case <expr><name>WAIT_OBJECT_0</name></expr>:
      <expr_stmt><expr><call><name>dbg_print</name><argument_list>(<argument><expr>"winservice_start: service is now starting\r\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* We no longer need the start event. */</comment>
      <expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>winservice_start_event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>winservice_start_event</name> = <name>NULL</name></expr>;</expr_stmt>

      <comment type="block">/* Register our cleanup logic. */</comment>
      <expr_stmt><expr><call><name>atexit</name><argument_list>(<argument><expr><name>winservice_atexit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>

    </case><case>case <expr><name>WAIT_OBJECT_0</name>+1</expr>:
      <comment type="block">/* The dispatcher thread exited without starting the service.
         This happens when the dispatcher fails to connect to the SCM. */</comment>
      <expr_stmt><expr><call><name>dbg_print</name><argument_list>(<argument><expr>"winservice_start: dispatcher thread has failed\r\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr><call><name>GetExitCodeThread</name><argument_list>(<argument><expr><name>winservice_dispatcher_thread</name></expr></argument>, <argument><expr>&amp;<name>error_code</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>dbg_print</name><argument_list>(<argument><expr>"winservice_start: dispatcher thread failed\r\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <if>if <condition>(<expr><name>error_code</name> == <name>ERROR_SUCCESS</name></expr>)</condition><then>
            <expr_stmt><expr><name>error_code</name> = <name>ERROR_INTERNAL_ERROR</name></expr>;</expr_stmt></then></if>

        }</block></then>
      <else>else
        <block>{
          <expr_stmt><expr><name>error_code</name> = <name>ERROR_INTERNAL_ERROR</name></expr>;</expr_stmt>
        }</block></else></if>

      <expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>winservice_dispatcher_thread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>winservice_dispatcher_thread</name> = <name>NULL</name></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>winservice_cleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

      <return>return <expr><call><name>svn_error_wrap_apr</name>
        <argument_list>(<argument><expr><call><name>APR_FROM_OS_ERROR</name><argument_list>(<argument><expr><name>error_code</name></expr></argument>)</argument_list></call></expr></argument>,
         <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Failed to connect to Service Control Manager"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

    </case><default>default:
      <comment type="block">/* This should never happen! This indicates that our handles are
         broken, or some other highly unusual error.  There is nothing
         rational that we can do to recover. */</comment>
      <expr_stmt><expr><name>apr_status</name> = <call><name>apr_get_os_error</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>dbg_print</name><argument_list>(<argument><expr>"winservice_start: WaitForMultipleObjects failed!\r\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>winservice_cleanup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><call><name>svn_error_wrap_apr</name>
        <argument_list>(<argument><expr><name>apr_status</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"The service failed to start; an internal error"
                       " occurred while starting the service"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    </default>}</block></switch>
}</block></function>


<comment type="block">/* main() calls this function in order to inform the SCM that the
   service has successfully started.  This is required; otherwise, the
   SCM will believe that the service is stuck in the "starting" state,
   and management tools will also believe that the service is stuck. */</comment>
<function><type><name>void</name></type>
<name>winservice_running</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><name><name>winservice_status</name>.<name>dwCurrentState</name></name> = <name>SERVICE_RUNNING</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>winservice_update_state</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>dbg_print</name><argument_list>(<argument><expr>"winservice_notify_running: service is now running\r\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<comment type="block">/* main() calls this function in order to notify the SCM that the
   service has stopped.  This function also handles cleaning up the
   dispatcher thread (the one that we created above in
   winservice_start. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>winservice_stop</name><parameter_list>(<param><decl><type><name>DWORD</name></type> <name>exit_code</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>dbg_print</name><argument_list>(<argument><expr>"winservice_stop - notifying SCM that service has stopped\r\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>winservice_status</name>.<name>dwCurrentState</name></name> = <name>SERVICE_STOPPED</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>winservice_status</name>.<name>dwWin32ExitCode</name></name> = <name>exit_code</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>winservice_update_state</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>winservice_dispatcher_thread</name> != <name>NULL</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>dbg_print</name><argument_list>(<argument><expr>"waiting for dispatcher thread to exit...\r\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>WaitForSingleObject</name><argument_list>(<argument><expr><name>winservice_dispatcher_thread</name></expr></argument>, <argument><expr><name>INFINITE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>dbg_print</name><argument_list>(<argument><expr>"dispatcher thread has exited.\r\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>winservice_dispatcher_thread</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>winservice_dispatcher_thread</name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <comment type="block">/* There was no dispatcher thread.  So we never started in
         the first place. */</comment>
      <expr_stmt><expr><name>exit_code</name> = <name><name>winservice_status</name>.<name>dwWin32ExitCode</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>dbg_print</name><argument_list>(<argument><expr>"dispatcher thread was not running\r\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

  <if>if <condition>(<expr><name>winservice_start_event</name> != <name>NULL</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name>winservice_start_event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>winservice_start_event</name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></then></if>

  <expr_stmt><expr><call><name>dbg_print</name><argument_list>(<argument><expr>"winservice_stop - service has stopped\r\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<comment type="block">/* This function is installed as an atexit-handler.  This is done so
  that we don't need to alter every exit() call in main(). */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>winservice_atexit</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>dbg_print</name><argument_list>(<argument><expr>"winservice_atexit - stopping\r\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>winservice_stop</name><argument_list>(<argument><expr><name>ERROR_SUCCESS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<function><type><name>svn_boolean_t</name></type>
<name>winservice_is_stopping</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
  <return>return <expr>(<name><name>winservice_status</name>.<name>dwCurrentState</name></name> == <name>SERVICE_STOP_PENDING</name>)</expr>;</return>
}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* WIN32 */</comment>
</unit>
