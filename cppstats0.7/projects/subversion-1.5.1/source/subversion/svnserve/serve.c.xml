<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/subversion-1.5.1/source/subversion/svnserve/serve.c"><comment type="block">/*
 * serve.c :  Functions for serving the Subversion protocol
 *
 * ====================================================================
 * Copyright (c) 2000-2007 CollabNet.  All rights reserved.
 *
 * This software is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at http://subversion.tigris.org/license-1.html.
 * If newer versions of this license are posted there, you may use a
 * newer version instead, at your option.
 *
 * This software consists of voluntary contributions made by many
 * individuals.  For exact contribution history, see the revision
 * history and logs, available at http://subversion.tigris.org/.
 * ====================================================================
 */</comment>



<escape char="0xc"/>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include> <comment type="block">/* for UINT_MAX */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APR_WANT_STRFUNC</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_want.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_general.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_strings.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_md5.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_compat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_private_config.h"</cpp:file></cpp:include>  <comment type="block">/* For SVN_PATH_LOCAL_SEPARATOR */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_types.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_string.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_pools.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_error.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_ra.h"</cpp:file></cpp:include>              <comment type="block">/* for SVN_RA_CAPABILITY_* */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_ra_svn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_repos.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_path.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_time.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_md5.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_props.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_mergeinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_user.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"private/svn_mergeinfo_private.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"server.h"</cpp:file></cpp:include>

<typedef>typedef <type><struct>struct <block>{
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name> *</type><name>new_rev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> **</type><name>date</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> **</type><name>author</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> **</type><name>post_commit_err</name></decl>;</decl_stmt>
}</block></struct></type> <name>commit_callback_baton_t</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
  <decl_stmt><decl><type><name>server_baton_t</name> *</type><name>sb</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>repos_url</name></decl>;</decl_stmt>  <comment type="block">/* Decoded repository URL. */</comment>
  <decl_stmt><decl><type><name>void</name> *</type><name>report_baton</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>
}</block></struct></type> <name>report_driver_baton_t</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fs_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>stack_depth</name></decl>;</decl_stmt>
}</block></struct></type> <name>log_baton_t</name>;</typedef>

<typedef>typedef <type><struct>struct <block>{
  <decl_stmt><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>  <comment type="block">/* Pool provided in the handler call. */</comment>
}</block></struct></type> <name>file_revs_baton_t</name>;</typedef>

<function><type><name>svn_error_t</name> *</type><name>load_configs</name><parameter_list>(<param><decl><type><name>svn_config_t</name> **</type><name>cfg</name></decl></param>,
                          <param><decl><type><name>svn_config_t</name> **</type><name>pwdb</name></decl></param>,
                          <param><decl><type><name>svn_authz_t</name> **</type><name>authzdb</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>filename</name></decl></param>,
                          <param><decl><type><name>svn_boolean_t</name></type> <name>must_exist</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>base</name></decl></param>,
                          <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>pwdb_path</name></decl>, *<decl><type ref="prev"/><name>authzdb_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_config_read</name><argument_list>(<argument><expr><name>cfg</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>must_exist</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>svn_config_get</name><argument_list>(<argument><expr>*<name>cfg</name></expr></argument>, <argument><expr>&amp;<name>pwdb_path</name></expr></argument>, <argument><expr><name>SVN_CONFIG_SECTION_GENERAL</name></expr></argument>,
                 <argument><expr><name>SVN_CONFIG_OPTION_PASSWORD_DB</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>pwdb</name> = <name>NULL</name></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>pwdb_path</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>pwdb_path</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>pwdb_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Because it may be possible to read the pwdb file with some
       * access methods and not others, ignore errors reading the pwdb
       * file and just don't present password authentication as an
       * option.  Also, some authentications (e.g. --tunnel) can
       * proceed without it anyway.
       *
       * ### Not entirely sure why SVN_ERR_BAD_FILENAME is checked
       * ### for here.  That seems to have been introduced in r16840,
       * ### and only in r30868 was the APR_EACCES check introduced.
       *
       * TODO: Log a warning in this case, when we have a way of doing logging.
       */</comment>
      <expr_stmt><expr><name>err</name> = <call><name>svn_config_read</name><argument_list>(<argument><expr><name>pwdb</name></expr></argument>, <argument><expr><name>pwdb_path</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>err</name>
          &amp;&amp; (<name><name>err</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_BAD_FILENAME</name>
              || <call><name>APR_STATUS_IS_EACCES</name><argument_list>(<argument><expr><name><name>err</name>-&gt;<name>apr_err</name></name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
      <else>else <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
        <return>return <expr><name>err</name></expr>;</return></then></if></else></if>
    }</block></then></if>

  <comment type="block">/* Read authz configuration. */</comment>
  <expr_stmt><expr><call><name>svn_config_get</name><argument_list>(<argument><expr>*<name>cfg</name></expr></argument>, <argument><expr>&amp;<name>authzdb_path</name></expr></argument>, <argument><expr><name>SVN_CONFIG_SECTION_GENERAL</name></expr></argument>,
                 <argument><expr><name>SVN_CONFIG_OPTION_AUTHZ_DB</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>authzdb_path</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>authzdb_path</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>authzdb_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_repos_authz_read</name><argument_list>(<argument><expr><name>authzdb</name></expr></argument>, <argument><expr><name>authzdb_path</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <expr_stmt><expr>*<name>authzdb</name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></else></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Set *FS_PATH to the portion of URL that is the path within the
   repository, if URL is inside REPOS_URL (if URL is not inside
   REPOS_URL, then error, with the effect on *FS_PATH undefined).

   If the resultant fs path would be the empty string (i.e., URL and
   REPOS_URL are the same), then set *FS_PATH to "/".

   Assume that REPOS_URL and URL are already URI-decoded. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type><name>get_fs_path</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>repos_url</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>url</name></decl></param>,
                                <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>fs_path</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>repos_url</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>url</name></expr></argument>, <argument><expr><name>repos_url</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_RA_ILLEGAL_URL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr>"'%s' is not the same repository as '%s'"</expr></argument>,
                             <argument><expr><name>url</name></expr></argument>, <argument><expr><name>repos_url</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
  <expr_stmt><expr>*<name>fs_path</name> = <name>url</name> + <name>len</name></expr>;</expr_stmt>
  <if>if <condition>(<expr>! **<name>fs_path</name></expr>)</condition><then>
    <expr_stmt><expr>*<name>fs_path</name> = "/"</expr>;</expr_stmt></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* --- AUTHENTICATION AND AUTHORIZATION FUNCTIONS --- */</comment>

<comment type="block">/* Set *ALLOWED to TRUE if PATH is accessible in the REQUIRED mode to
   the user described in BATON according to the authz rules in BATON.
   Use POOL for temporary allocations only.  If no authz rules are
   present in BATON, grant access by default. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type><name>authz_check_access</name><parameter_list>(<param><decl><type><name>svn_boolean_t</name> *</type><name>allowed</name></decl></param>,
                                       <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                                       <param><decl><type><name>svn_repos_authz_access_t</name></type> <name>required</name></decl></param>,
                                       <param><decl><type><name>server_baton_t</name> *</type><name>b</name></decl></param>,
                                       <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* If authz cannot be performed, grant access.  This is NOT the same
     as the default policy when authz is performed on a path with no
     rules.  In the latter case, the default is to deny access, and is
     set by svn_repos_authz_check_access. */</comment>
  <if>if <condition>(<expr>!<name><name>b</name>-&gt;<name>authzdb</name></name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr>*<name>allowed</name> = <name>TRUE</name></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>

  <comment type="block">/* If the authz request is for the empty path (ie. ""), replace it
     with the root path.  This happens because of stripping done at
     various levels in svnserve that remove the leading / on an
     absolute path. Passing such a malformed path to the authz
     routines throws them into an infinite loop and makes them miss
     ACLs. */</comment>
  <if>if <condition>(<expr><name>path</name> &amp;&amp; *<name>path</name> != '/'</expr>)</condition><then>
    <expr_stmt><expr><name>path</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr>"/"</expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <return>return <expr><call><name>svn_repos_authz_check_access</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>authzdb</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>authz_repos_name</name></name></expr></argument>,
                                      <argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>user</name></name></expr></argument>, <argument><expr><name>required</name></expr></argument>,
                                      <argument><expr><name>allowed</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Set *ALLOWED to TRUE if PATH is readable by the user described in
 * BATON.  Use POOL for temporary allocations only.  ROOT is not used.
 * Implements the svn_repos_authz_func_t interface.
 */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type><name>authz_check_access_cb</name><parameter_list>(<param><decl><type><name>svn_boolean_t</name> *</type><name>allowed</name></decl></param>,
                                          <param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
                                          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                                          <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>,
                                          <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>server_baton_t</name> *</type><name>sb</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>

  <return>return <expr><call><name>authz_check_access</name><argument_list>(<argument><expr><name>allowed</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>svn_authz_read</name></expr></argument>, <argument><expr><name>sb</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* If authz is enabled in the specified BATON, return a read authorization
   function. Otherwise, return NULL. */</comment>
<function><type><specifier>static</specifier> <name>svn_repos_authz_func_t</name></type> <name>authz_check_access_cb_func</name><parameter_list>(<param><decl><type><name>server_baton_t</name> *</type><name>baton</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name><name>baton</name>-&gt;<name>authzdb</name></name></expr>)</condition><then>
     <return>return <expr><name>authz_check_access_cb</name></expr>;</return></then></if>
  <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<comment type="block">/* Set *ALLOWED to TRUE if the REQUIRED access to PATH is granted,
 * according to the state in BATON.  Use POOL for temporary
 * allocations only.  ROOT is not used.  Implements the
 * svn_repos_authz_callback_t interface.
 */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type><name>authz_commit_cb</name><parameter_list>(<param><decl><type><name>svn_repos_authz_access_t</name></type> <name>required</name></decl></param>,
                                    <param><decl><type><name>svn_boolean_t</name> *</type><name>allowed</name></decl></param>,
                                    <param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
                                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                                    <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>,
                                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>server_baton_t</name> *</type><name>sb</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>

  <return>return <expr><call><name>authz_check_access</name><argument_list>(<argument><expr><name>allowed</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>required</name></expr></argument>, <argument><expr><name>sb</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<enum>enum <name>access_type</name> <name>get_access</name><expr_stmt><expr>(<name>server_baton_t</name> *<name>b</name>, enum <name>authn_type</name> <name>auth</name>)
<block>{
  <expr>const <name>char</name> *<name>var</name> = (<name>auth</name> == <name>AUTHENTICATED</name>) ? <name>SVN_CONFIG_OPTION_AUTH_ACCESS</name> :
    <name>SVN_CONFIG_OPTION_ANON_ACCESS</name></expr>;
  <expr>const <name>char</name> *<name>val</name></expr>, <expr>*<name>def</name> = (<name>auth</name> == <name>AUTHENTICATED</name>) ? "write" : "read"</expr>;
  enum <expr><name>access_type</name> <name>result</name></expr>;

  <expr><call><name>svn_config_get</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>cfg</name></name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>, <argument><expr><name>SVN_CONFIG_SECTION_GENERAL</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><name>def</name></expr></argument>)</argument_list></call></expr>;
  <expr><name>result</name> = (<call><name>strcmp</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr>"write"</expr></argument>)</argument_list></call> == 0 ? <name>WRITE_ACCESS</name> :
            <call><name>strcmp</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr>"read"</expr></argument>)</argument_list></call> == 0 ? <name>READ_ACCESS</name> : <name>NO_ACCESS</name>)</expr>;
  <return>return <expr>(<name>result</name> == <name>WRITE_ACCESS</name> &amp;&amp; <name><name>b</name>-&gt;<name>read_only</name></name>) ? <name>READ_ACCESS</name> : <name>result</name></expr>;</return>
}</block></expr></expr_stmt>

<decl>static enum <name>access_type</name> <name>current_access</name><argument_list>(<argument><expr><name>server_baton_t</name> *<name>b</name></expr></argument>)</argument_list>
<block>{
  <return>return <expr><call><name>get_access</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr>(<name><name>b</name>-&gt;<name>user</name></name>) ? <name>AUTHENTICATED</name> : <name>UNAUTHENTICATED</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></decl>

<comment type="block">/* Send authentication mechs for ACCESS_TYPE to the client.  If NEEDS_USERNAME
   is true, don't send anonymous mech even if that would give the desired
   access. */</comment>
<decl>static <name>svn_error_t</name> *<name>send_mechs</name><argument_list>(<argument><expr><name>svn_ra_svn_conn_t</name> *<name>conn</name></expr></argument>, <argument><expr><name>apr_pool_t</name> *<name>pool</name></expr></argument>,
                               <argument><expr><name>server_baton_t</name> *<name>b</name></expr></argument>, <argument>enum <expr><name>access_type</name> <name>required</name></expr></argument>,
                               <argument><expr><name>svn_boolean_t</name> <name>needs_username</name></expr></argument>)</argument_list>
<block>{
  <if>if <condition>(<expr>!<name>needs_username</name> &amp;&amp; <call><name>get_access</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>UNAUTHENTICATED</name></expr></argument>)</argument_list></call> &gt;= <name>required</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_write_word</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"ANONYMOUS"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <if>if <condition>(<expr><name><name>b</name>-&gt;<name>tunnel_user</name></name> &amp;&amp; <call><name>get_access</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>AUTHENTICATED</name></expr></argument>)</argument_list></call> &gt;= <name>required</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_write_word</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"EXTERNAL"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <if>if <condition>(<expr><name><name>b</name>-&gt;<name>pwdb</name></name> &amp;&amp; <call><name>get_access</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>AUTHENTICATED</name></expr></argument>)</argument_list></call> &gt;= <name>required</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_write_word</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"CRAM-MD5"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></decl>

<comment type="block">/* Context for cleanup handler. */</comment>
<decl>struct <name>cleanup_fs_access_baton</name>
<block>{
  <decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>
}</block></decl>;</enum>

<comment type="block">/* Pool cleanup handler.  Make sure fs's access_t points to NULL when
   the command pool is destroyed. */</comment>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type> <name>cleanup_fs_access</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>data</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>serr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>cleanup_fs_access_baton</name> *</type><name>baton</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>serr</name> = <call><name>svn_fs_set_access</name><argument_list>(<argument><expr><name><name>baton</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>serr</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>apr_status_t</name></type> <name>apr_err</name> <init>= <expr><name><name>serr</name>-&gt;<name>apr_err</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>serr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>apr_err</name></expr>;</return>
    }</block></then></if>

  <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>


<comment type="block">/* Create an svn_fs_access_t in POOL for USER and associate it with
   B's filesystem.  Also, register a cleanup handler with POOL which
   de-associates the svn_fs_access_t from B's filesystem. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>create_fs_access</name><parameter_list>(<param><decl><type><name>server_baton_t</name> *</type><name>b</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_fs_access_t</name> *</type><name>fs_access</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>cleanup_fs_access_baton</name> *</type><name>cleanup_baton</name></decl>;</decl_stmt>

  <if>if <condition>(<expr>!<name><name>b</name>-&gt;<name>user</name></name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_create_access</name><argument_list>(<argument><expr>&amp;<name>fs_access</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>user</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_set_access</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>fs_access</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>cleanup_baton</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>cleanup_baton</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cleanup_baton</name>-&gt;<name>pool</name></name> = <name>pool</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cleanup_baton</name>-&gt;<name>fs</name></name> = <name><name>b</name>-&gt;<name>fs</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>apr_pool_cleanup_register</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>cleanup_baton</name></expr></argument>, <argument><expr><name>cleanup_fs_access</name></expr></argument>,
                            <argument><expr><name>apr_pool_cleanup_null</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Authenticate, once the client has chosen a mechanism and possibly
 * sent an initial mechanism token.  On success, set *success to true
 * and b-&gt;user to the authenticated username (or NULL for anonymous).
 * On authentication failure, report failure to the client and set
 * *success to FALSE.  On communications failure, return an error.
 * If NEEDS_USERNAME is TRUE, don't allow anonymous authentication. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>svn_error_t</name> *</type><name>auth</name><argument_list>(<argument><expr><name>svn_ra_svn_conn_t</name> *<name>conn</name></expr></argument>, <argument><expr><name>apr_pool_t</name> *<name>pool</name></expr></argument>,
                         <argument><expr>const <name>char</name> *<name>mech</name></expr></argument>, <argument><expr>const <name>char</name> *<name>mecharg</name></expr></argument>,
                         <argument><expr><name>server_baton_t</name> *<name>b</name></expr></argument>, <argument>enum <expr><name>access_type</name> <name>required</name></expr></argument>,
                         <argument><expr><name>svn_boolean_t</name> <name>needs_username</name></expr></argument>,
                         <argument><expr><name>svn_boolean_t</name> *<name>success</name></expr></argument>)</argument_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>user</name></decl>;</decl_stmt>
  <expr_stmt><expr>*<name>success</name> = <name>FALSE</name></expr>;</expr_stmt>

  <if>if <condition>(<expr><call><name>get_access</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>AUTHENTICATED</name></expr></argument>)</argument_list></call> &gt;= <name>required</name>
      &amp;&amp; <name><name>b</name>-&gt;<name>tunnel_user</name></name> &amp;&amp; <call><name>strcmp</name><argument_list>(<argument><expr><name>mech</name></expr></argument>, <argument><expr>"EXTERNAL"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr>*<name>mecharg</name> &amp;&amp; <call><name>strcmp</name><argument_list>(<argument><expr><name>mecharg</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>tunnel_user</name></name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
        <return>return <expr><call><name>svn_ra_svn_write_tuple</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"w(c)"</expr></argument>, <argument><expr>"failure"</expr></argument>,
                                      <argument><expr>"Requested username does not match"</expr></argument>)</argument_list></call></expr>;</return></then></if>
      <expr_stmt><expr><name><name>b</name>-&gt;<name>user</name></name> = <name><name>b</name>-&gt;<name>tunnel_user</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_write_tuple</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"w()"</expr></argument>, <argument><expr>"success"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>success</name> = <name>TRUE</name></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>

  <if>if <condition>(<expr><call><name>get_access</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>UNAUTHENTICATED</name></expr></argument>)</argument_list></call> &gt;= <name>required</name>
      &amp;&amp; <call><name>strcmp</name><argument_list>(<argument><expr><name>mech</name></expr></argument>, <argument><expr>"ANONYMOUS"</expr></argument>)</argument_list></call> == 0 &amp;&amp; ! <name>needs_username</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_write_tuple</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"w()"</expr></argument>, <argument><expr>"success"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>success</name> = <name>TRUE</name></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>

  <if>if <condition>(<expr><call><name>get_access</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>AUTHENTICATED</name></expr></argument>)</argument_list></call> &gt;= <name>required</name>
      &amp;&amp; <name><name>b</name>-&gt;<name>pwdb</name></name> &amp;&amp; <call><name>strcmp</name><argument_list>(<argument><expr><name>mech</name></expr></argument>, <argument><expr>"CRAM-MD5"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_cram_server</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>pwdb</name></name></expr></argument>, <argument><expr>&amp;<name>user</name></expr></argument>, <argument><expr><name>success</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>b</name>-&gt;<name>user</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>user</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>

  <return>return <expr><call><name>svn_ra_svn_write_tuple</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"w(c)"</expr></argument>, <argument><expr>"failure"</expr></argument>,
                                <argument><expr>"Must authenticate with listed mechanism"</expr></argument>)</argument_list></call></expr>;</return>
}</block></decl></decl_stmt>

<comment type="block">/* Perform an authentication request using the built-in SASL implementation. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>internal_auth_request</name><argument_list>(<argument><expr><name>svn_ra_svn_conn_t</name> *<name>conn</name></expr></argument>, <argument><expr><name>apr_pool_t</name> *<name>pool</name></expr></argument>,
                      <argument><expr><name>server_baton_t</name> *<name>b</name></expr></argument>, <argument>enum <expr><name>access_type</name> <name>required</name></expr></argument>,
                      <argument><expr><name>svn_boolean_t</name> <name>needs_username</name></expr></argument>)</argument_list>
<block>{
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>success</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>mech</name></decl>, *<decl><type ref="prev"/><name>mecharg</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_write_tuple</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"w((!"</expr></argument>, <argument><expr>"success"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>send_mechs</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>required</name></expr></argument>, <argument><expr><name>needs_username</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_write_tuple</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"!)c)"</expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>realm</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <do>do
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_read_tuple</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"w(?c)"</expr></argument>, <argument><expr>&amp;<name>mech</name></expr></argument>, <argument><expr>&amp;<name>mecharg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr>!*<name>mech</name></expr>)</condition><then>
        <break>break;</break></then></if>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>auth</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>mech</name></expr></argument>, <argument><expr><name>mecharg</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>required</name></expr></argument>, <argument><expr><name>needs_username</name></expr></argument>,
                   <argument><expr>&amp;<name>success</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block>
  while <condition>(<expr>!<name>success</name></expr>)</condition>;</do>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></decl></decl_stmt>

<comment type="block">/* Perform an authentication request in order to get an access level of
 * REQUIRED or higher.  Since the client may escape the authentication
 * exchange, the caller should check current_access(b) to see if
 * authentication succeeded. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>svn_error_t</name> *</type><name>auth_request</name><argument_list>(<argument><expr><name>svn_ra_svn_conn_t</name> *<name>conn</name></expr></argument>, <argument><expr><name>apr_pool_t</name> *<name>pool</name></expr></argument>,
                                 <argument><expr><name>server_baton_t</name> *<name>b</name></expr></argument>, <argument>enum <expr><name>access_type</name> <name>required</name></expr></argument>,
                                 <argument><expr><name>svn_boolean_t</name> <name>needs_username</name></expr></argument>)</argument_list>
<block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SVN_HAVE_SASL</name></cpp:ifdef>
  <if>if <condition>(<expr><name><name>b</name>-&gt;<name>use_sasl</name></name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>cyrus_auth_request</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>required</name></expr></argument>, <argument><expr><name>needs_username</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>internal_auth_request</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>required</name></expr></argument>, <argument><expr><name>needs_username</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></decl></decl_stmt>

<comment type="block">/* Send a trivial auth notification on CONN which lists no mechanisms,
 * indicating that authentication is unnecessary.  Usually called in
 * response to invocation of a svnserve command.
 */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type><name>trivial_auth_request</name><parameter_list>(<param><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name></decl></param>,
                                         <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>, <param><decl><type><name>server_baton_t</name> *</type><name>b</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>svn_ra_svn_write_cmd_response</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"()c"</expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Ensure that the client has the REQUIRED access by checking the
 * access directives (both blanket and per-directory) in BATON.  If
 * PATH is NULL, then only the blanket access configuration will
 * impact the result.
 *
 * If NEEDS_USERNAME is TRUE, then a lookup is only successful if the
 * user described in BATON is authenticated and, well, has a username
 * assigned to him.
 *
 * Use POOL for temporary allocations only.
 */</comment>
<function><type><specifier>static</specifier> <name>svn_boolean_t</name></type> <name>lookup_access</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                                   <param><decl><type><name>server_baton_t</name> *</type><name>baton</name></decl></param>,
                                   <param><decl><type><name>svn_repos_authz_access_t</name></type> <name>required</name></decl></param>,
                                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                                   <param><decl><type><name>svn_boolean_t</name></type> <name>needs_username</name></decl></param>)</parameter_list>
<block>{
  <enum>enum <name>access_type</name> <name>req</name> <expr_stmt><expr>= (<name>required</name> &amp; <name>svn_authz_write</name>) ?
    <name>WRITE_ACCESS</name> : <name>READ_ACCESS</name></expr>;</expr_stmt></enum>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>authorized</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>

  <comment type="block">/* Get authz's opinion on the access. */</comment>
  <expr_stmt><expr><name>err</name> = <call><name>authz_check_access</name><argument_list>(<argument><expr>&amp;<name>authorized</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>required</name></expr></argument>, <argument><expr><name>baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If an error made lookup fail, deny access.  ### TODO: Once
     logging is implemented, this is a perfect place to log the
     problem. */</comment>
  <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>FALSE</name></expr>;</return>
    }</block></then></if>

  <comment type="block">/* If the required access is blanket-granted AND granted by authz
     AND we already have a username if one is required, then the
     lookup has succeeded. */</comment>
  <if>if <condition>(<expr><call><name>current_access</name><argument_list>(<argument><expr><name>baton</name></expr></argument>)</argument_list></call> &gt;= <name>req</name>
      &amp;&amp; <name>authorized</name>
      &amp;&amp; (! <name>needs_username</name> || <name><name>baton</name>-&gt;<name>user</name></name>)</expr>)</condition><then>
    <return>return <expr><name>TRUE</name></expr>;</return></then></if>

  <return>return <expr><name>FALSE</name></expr>;</return>
}</block></function>

<comment type="block">/* Check that the client has the REQUIRED access by consulting the
 * authentication and authorization states stored in BATON.  If the
 * client does not have the required access credentials, attempt to
 * authenticate the client to get that access, using CONN for
 * communication.
 *
 * This function is supposed to be called to handle the authentication
 * half of a standard svn protocol reply.  If an error is returned, it
 * probably means that the server can terminate the client connection
 * with an apologetic error, as it implies an authentication failure.
 *
 * PATH and NEEDS_USERNAME are passed along to lookup_access, their
 * behaviour is documented there.
 */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type><name>must_have_access</name><parameter_list>(<param><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name></decl></param>,
                                     <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                                     <param><decl><type><name>server_baton_t</name> *</type><name>b</name></decl></param>,
                                     <param><decl><type><name>svn_repos_authz_access_t</name></type> <name>required</name></decl></param>,
                                     <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                                     <param><decl><type><name>svn_boolean_t</name></type> <name>needs_username</name></decl></param>)</parameter_list>
<block>{
  <enum>enum <name>access_type</name> <name>req</name> <expr_stmt><expr>= (<name>required</name> &amp; <name>svn_authz_write</name>) ?
    <name>WRITE_ACCESS</name> : <name>READ_ACCESS</name></expr>;</expr_stmt></enum>

  <comment type="block">/* See whether the user already has the required access.  If so,
     nothing needs to be done.  Create the FS access and send a
     trivial auth request. */</comment>
  <if>if <condition>(<expr><call><name>lookup_access</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>required</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>needs_username</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>create_fs_access</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><call><name>trivial_auth_request</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

  <comment type="block">/* If the required blanket access can be obtained by authenticating,
     try that.  Unfortunately, we can't tell until after
     authentication whether authz will work or not.  We force
     requiring a username because we need one to be able to check
     authz configuration again with a different user credentials than
     the first time round. */</comment>
  <if>if <condition>(<expr><name><name>b</name>-&gt;<name>user</name></name> == <name>NULL</name>
      &amp;&amp; <call><name>get_access</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>AUTHENTICATED</name></expr></argument>)</argument_list></call> &gt;= <name>req</name>
      &amp;&amp; (<name><name>b</name>-&gt;<name>tunnel_user</name></name> || <name><name>b</name>-&gt;<name>pwdb</name></name>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SVN_HAVE_SASL</name></cpp:ifdef>
          || <name><name>b</name>-&gt;<name>use_sasl</name></name>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
      )</expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>auth_request</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>req</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* Now that an authentication has been done get the new take of
     authz on the request. */</comment>
  <if>if <condition>(<expr>! <call><name>lookup_access</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>required</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>needs_username</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_RA_SVN_CMD_ERR</name></expr></argument>,
                            <argument><expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_RA_NOT_AUTHORIZED</name></expr></argument>,
                                             <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Else, access is granted, and there is much rejoicing. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>create_fs_access</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* --- REPORTER COMMAND SET --- */</comment>

<comment type="block">/* To allow for pipelining, reporter commands have no reponses.  If we
 * get an error, we ignore all subsequent reporter commands and return
 * the error finish_report, to be handled by the calling command.
 */</comment>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type><name>set_path</name><parameter_list>(<param><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                             <param><decl><type><name>apr_array_header_t</name> *</type><name>params</name></decl></param>, <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>report_driver_baton_t</name> *</type><name>b</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>, *<decl><type ref="prev"/><name>lock_token</name></decl>, *<decl><type ref="prev"/><name>depth_word</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl>;</decl_stmt>
  <comment type="block">/* Default to infinity, for old clients that don't send depth. */</comment>
  <decl_stmt><decl><type><name>svn_depth_t</name></type> <name>depth</name> <init>= <expr><name>svn_depth_infinity</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>start_empty</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_parse_tuple</name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"crb?(?c)?w"</expr></argument>,
                                 <argument><expr>&amp;<name>path</name></expr></argument>, <argument><expr>&amp;<name>rev</name></expr></argument>, <argument><expr>&amp;<name>start_empty</name></expr></argument>, <argument><expr>&amp;<name>lock_token</name></expr></argument>,
                                 <argument><expr>&amp;<name>depth_word</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>depth_word</name></expr>)</condition><then>
    <expr_stmt><expr><name>depth</name> = <call><name>svn_depth_from_word</name><argument_list>(<argument><expr><name>depth_word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <expr_stmt><expr><name>path</name> = <call><name>svn_path_canonicalize</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<name><name>b</name>-&gt;<name>err</name></name></expr>)</condition><then>
    <expr_stmt><expr><name><name>b</name>-&gt;<name>err</name></name> = <call><name>svn_repos_set_path3</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>report_baton</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>,
                                 <argument><expr><name>start_empty</name></expr></argument>, <argument><expr><name>lock_token</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type><name>delete_path</name><parameter_list>(<param><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                                <param><decl><type><name>apr_array_header_t</name> *</type><name>params</name></decl></param>, <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>report_driver_baton_t</name> *</type><name>b</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_parse_tuple</name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"c"</expr></argument>, <argument><expr>&amp;<name>path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>path</name> = <call><name>svn_path_canonicalize</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<name><name>b</name>-&gt;<name>err</name></name></expr>)</condition><then>
    <expr_stmt><expr><name><name>b</name>-&gt;<name>err</name></name> = <call><name>svn_repos_delete_path</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>report_baton</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type><name>link_path</name><parameter_list>(<param><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                              <param><decl><type><name>apr_array_header_t</name> *</type><name>params</name></decl></param>, <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>report_driver_baton_t</name> *</type><name>b</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>, *<decl><type ref="prev"/><name>url</name></decl>, *<decl><type ref="prev"/><name>lock_token</name></decl>, *<decl><type ref="prev"/><name>fs_path</name></decl>, *<decl><type ref="prev"/><name>depth_word</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>start_empty</name></decl>;</decl_stmt>
  <comment type="block">/* Default to infinity, for old clients that don't send depth. */</comment>
  <decl_stmt><decl><type><name>svn_depth_t</name></type> <name>depth</name> <init>= <expr><name>svn_depth_infinity</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_parse_tuple</name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"ccrb?(?c)?w"</expr></argument>,
                                 <argument><expr>&amp;<name>path</name></expr></argument>, <argument><expr>&amp;<name>url</name></expr></argument>, <argument><expr>&amp;<name>rev</name></expr></argument>, <argument><expr>&amp;<name>start_empty</name></expr></argument>,
                                 <argument><expr>&amp;<name>lock_token</name></expr></argument>, <argument><expr>&amp;<name>depth_word</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>path</name> = <call><name>svn_path_canonicalize</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>url</name> = <call><name>svn_path_uri_decode</name><argument_list>(<argument><expr><call><name>svn_path_canonicalize</name><argument_list>(<argument><expr><name>url</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>depth_word</name></expr>)</condition><then>
    <expr_stmt><expr><name>depth</name> = <call><name>svn_depth_from_word</name><argument_list>(<argument><expr><name>depth_word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <if>if <condition>(<expr>!<name><name>b</name>-&gt;<name>err</name></name></expr>)</condition><then>
    <expr_stmt><expr><name><name>b</name>-&gt;<name>err</name></name> = <call><name>get_fs_path</name><argument_list>(<argument><expr><call><name>svn_path_uri_decode</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>repos_url</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                         <argument><expr><name>url</name></expr></argument>, <argument><expr>&amp;<name>fs_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <if>if <condition>(<expr>!<name><name>b</name>-&gt;<name>err</name></name></expr>)</condition><then>
    <expr_stmt><expr><name><name>b</name>-&gt;<name>err</name></name> = <call><name>svn_repos_link_path3</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>report_baton</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>fs_path</name></expr></argument>, <argument><expr><name>rev</name></expr></argument>,
                                  <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>start_empty</name></expr></argument>, <argument><expr><name>lock_token</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type><name>finish_report</name><parameter_list>(<param><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                                  <param><decl><type><name>apr_array_header_t</name> *</type><name>params</name></decl></param>, <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>report_driver_baton_t</name> *</type><name>b</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* No arguments to parse. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>trivial_auth_request</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>sb</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<name><name>b</name>-&gt;<name>err</name></name></expr>)</condition><then>
    <expr_stmt><expr><name><name>b</name>-&gt;<name>err</name></name> = <call><name>svn_repos_finish_report</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>report_baton</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type><name>abort_report</name><parameter_list>(<param><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                                   <param><decl><type><name>apr_array_header_t</name> *</type><name>params</name></decl></param>, <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>report_driver_baton_t</name> *</type><name>b</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* No arguments to parse. */</comment>
  <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><call><name>svn_repos_abort_report</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>report_baton</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>svn_ra_svn_cmd_entry_t</name></type> <name><name>report_commands</name><index>[]</index></name> <init>= <expr><block>{
  <expr><block>{ <expr>"set-path"</expr>,      <expr><name>set_path</name></expr> }</block></expr>,
  <expr><block>{ <expr>"delete-path"</expr>,   <expr><name>delete_path</name></expr> }</block></expr>,
  <expr><block>{ <expr>"link-path"</expr>,     <expr><name>link_path</name></expr> }</block></expr>,
  <expr><block>{ <expr>"finish-report"</expr>, <expr><name>finish_report</name></expr>, <expr><name>TRUE</name></expr> }</block></expr>,
  <expr><block>{ <expr>"abort-report"</expr>,  <expr><name>abort_report</name></expr>,  <expr><name>TRUE</name></expr> }</block></expr>,
  <expr><block>{ <expr><name>NULL</name></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Accept a report from the client, drive the network editor with the
 * result, and then write an empty command response.  If there is a
 * non-protocol failure, accept_report will abort the edit and return
 * a command error to be reported by handle_commands(). */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type><name>accept_report</name><parameter_list>(<param><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                                  <param><decl><type><name>server_baton_t</name> *</type><name>b</name></decl></param>, <param><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl></param>,
                                  <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>target</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>tgt_path</name></decl></param>,
                                  <param><decl><type><name>svn_boolean_t</name></type> <name>text_deltas</name></decl></param>,
                                  <param><decl><type><name>svn_depth_t</name></type> <name>depth</name></decl></param>,
                                  <param><decl><type><name>svn_boolean_t</name></type> <name>send_copyfrom_args</name></decl></param>,
                                  <param><decl><type><name>svn_boolean_t</name></type> <name>ignore_ancestry</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_delta_editor_t</name> *</type><name>editor</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> *</type><name>edit_baton</name></decl>, *<decl><type ref="prev"/><name>report_baton</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>report_driver_baton_t</name></type> <name>rb</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>

  <comment type="block">/* Make an svn_repos report baton.  Tell it to drive the network editor
   * when the report is complete. */</comment>
  <expr_stmt><expr><call><name>svn_ra_svn_get_editor</name><argument_list>(<argument><expr>&amp;<name>editor</name></expr></argument>, <argument><expr>&amp;<name>edit_baton</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_CMD_ERR</name><argument_list>(<argument><expr><call><name>svn_repos_begin_report2</name><argument_list>(<argument><expr>&amp;<name>report_baton</name></expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>repos</name></name></expr></argument>,
                                      <argument><expr><name><name>b</name>-&gt;<name>fs_path</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>tgt_path</name></expr></argument>,
                                      <argument><expr><name>text_deltas</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>ignore_ancestry</name></expr></argument>,
                                      <argument><expr><name>send_copyfrom_args</name></expr></argument>,
                                      <argument><expr><name>editor</name></expr></argument>, <argument><expr><name>edit_baton</name></expr></argument>,
                                      <argument><expr><call><name>authz_check_access_cb_func</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>,
                                      <argument><expr><name>b</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>rb</name>.<name>sb</name></name> = <name>b</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>rb</name>.<name>repos_url</name></name> = <call><name>svn_path_uri_decode</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>repos_url</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>rb</name>.<name>report_baton</name></name> = <name>report_baton</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>rb</name>.<name>err</name></name> = <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>err</name> = <call><name>svn_ra_svn_handle_commands</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>report_commands</name></expr></argument>, <argument><expr>&amp;<name>rb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* Network or protocol error while handling commands. */</comment>
      <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name><name>rb</name>.<name>err</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>err</name></expr>;</return>
    }</block></then>
  <else>else <if>if <condition>(<expr><name><name>rb</name>.<name>err</name></name></expr>)</condition><then>
    <block>{
      <comment type="block">/* Some failure during the reporting or editing operations. */</comment>
      <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><call><name><name>editor</name>-&gt;<name>abort_edit</name></name><argument_list>(<argument><expr><name>edit_baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_CMD_ERR</name><argument_list>(<argument><expr><name><name>rb</name>.<name>err</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if></else></if>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_write_cmd_response</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* --- MAIN COMMAND SET --- */</comment>

<comment type="block">/* Write out a list of property diffs.  PROPDIFFS is an array of svn_prop_t
 * values. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type><name>write_prop_diffs</name><parameter_list>(<param><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name></decl></param>,
                                     <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                                     <param><decl><type><name>apr_array_header_t</name> *</type><name>propdiffs</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>propdiffs</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>)
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>svn_prop_t</name> *</type><name>prop</name> <init>= <expr>&amp;<call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>propdiffs</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>svn_prop_t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_write_tuple</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"c(?s)"</expr></argument>,
                                     <argument><expr><name><name>prop</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name><name>prop</name>-&gt;<name>value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Write out a lock to the client. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type><name>write_lock</name><parameter_list>(<param><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name></decl></param>,
                               <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                               <param><decl><type><name>svn_lock_t</name> *</type><name>lock</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>cdate</name></decl>, *<decl><type ref="prev"/><name>edate</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>cdate</name> = <call><name>svn_time_to_cstring</name><argument_list>(<argument><expr><name><name>lock</name>-&gt;<name>creation_date</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>edate</name> = <name><name>lock</name>-&gt;<name>expiration_date</name></name>
    ? <call><name>svn_time_to_cstring</name><argument_list>(<argument><expr><name><name>lock</name>-&gt;<name>expiration_date</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call> : <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_write_tuple</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"ccc(?c)c(?c)"</expr></argument>, <argument><expr><name><name>lock</name>-&gt;<name>path</name></name></expr></argument>,
                                 <argument><expr><name><name>lock</name>-&gt;<name>token</name></name></expr></argument>, <argument><expr><name><name>lock</name>-&gt;<name>owner</name></name></expr></argument>, <argument><expr><name><name>lock</name>-&gt;<name>comment</name></name></expr></argument>,
                                 <argument><expr><name>cdate</name></expr></argument>, <argument><expr><name>edate</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>kind_word</name><parameter_list>(<param><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl></param>)</parameter_list>
<block>{
  <switch>switch <condition>(<expr><name>kind</name></expr>)</condition>
    <block>{
    <case>case <expr><name>svn_node_none</name></expr>:
      <return>return <expr>"none"</expr>;</return>
    </case><case>case <expr><name>svn_node_file</name></expr>:
      <return>return <expr>"file"</expr>;</return>
    </case><case>case <expr><name>svn_node_dir</name></expr>:
      <return>return <expr>"dir"</expr>;</return>
    </case><case>case <expr><name>svn_node_unknown</name></expr>:
      <return>return <expr>"unknown"</expr>;</return>
    </case><default>default:
      <expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    </default>}</block></switch>

  <comment type="block">/* Make the compiler happy */</comment>
  <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<comment type="block">/* ### This really belongs in libsvn_repos. */</comment>
<comment type="block">/* Get the properties for a path, with hardcoded committed-info values. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type><name>get_props</name><parameter_list>(<param><decl><type><name>apr_hash_t</name> **</type><name>props</name></decl></param>, <param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
                              <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>str</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>crev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>cdate</name></decl>, *<decl><type ref="prev"/><name>cauthor</name></decl>, *<decl><type ref="prev"/><name>uuid</name></decl>;</decl_stmt>

  <comment type="block">/* Get the properties. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_node_proplist</name><argument_list>(<argument><expr><name>props</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Hardcode the values for the committed revision, date, and author. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_repos_get_committed_info</name><argument_list>(<argument><expr>&amp;<name>crev</name></expr></argument>, <argument><expr>&amp;<name>cdate</name></expr></argument>, <argument><expr>&amp;<name>cauthor</name></expr></argument>, <argument><expr><name>root</name></expr></argument>,
                                       <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>str</name> = <call><name>svn_string_create</name><argument_list>(<argument><expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%ld"</expr></argument>, <argument><expr><name>crev</name></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr>*<name>props</name></expr></argument>, <argument><expr><name>SVN_PROP_ENTRY_COMMITTED_REV</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>str</name> = (<name>cdate</name>) ? <call><name>svn_string_create</name><argument_list>(<argument><expr><name>cdate</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call> : <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr>*<name>props</name></expr></argument>, <argument><expr><name>SVN_PROP_ENTRY_COMMITTED_DATE</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>,
               <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>str</name> = (<name>cauthor</name>) ? <call><name>svn_string_create</name><argument_list>(<argument><expr><name>cauthor</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call> : <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr>*<name>props</name></expr></argument>, <argument><expr><name>SVN_PROP_ENTRY_LAST_AUTHOR</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Hardcode the values for the UUID. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_get_uuid</name><argument_list>(<argument><expr><call><name>svn_fs_root_fs</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>uuid</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>str</name> = (<name>uuid</name>) ? <call><name>svn_string_create</name><argument_list>(<argument><expr><name>uuid</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call> : <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr>*<name>props</name></expr></argument>, <argument><expr><name>SVN_PROP_ENTRY_UUID</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Set BATON-&gt;FS_PATH for the repository URL found in PARAMS. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type><name>reparent</name><parameter_list>(<param><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                             <param><decl><type><name>apr_array_header_t</name> *</type><name>params</name></decl></param>, <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>server_baton_t</name> *</type><name>b</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>url</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fs_path</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_parse_tuple</name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"c"</expr></argument>, <argument><expr>&amp;<name>url</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>url</name> = <call><name>svn_path_uri_decode</name><argument_list>(<argument><expr><call><name>svn_path_canonicalize</name><argument_list>(<argument><expr><name>url</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>trivial_auth_request</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_CMD_ERR</name><argument_list>(<argument><expr><call><name>get_fs_path</name><argument_list>(<argument><expr><call><name>svn_path_uri_decode</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>repos_url</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><name>url</name></expr></argument>, <argument><expr>&amp;<name>fs_path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_stringbuf_set</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>fs_path</name></name></expr></argument>, <argument><expr><name>fs_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_write_cmd_response</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type><name>get_latest_rev</name><parameter_list>(<param><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                                   <param><decl><type><name>apr_array_header_t</name> *</type><name>params</name></decl></param>, <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>server_baton_t</name> *</type><name>b</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>trivial_auth_request</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_CMD_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_youngest_rev</name><argument_list>(<argument><expr>&amp;<name>rev</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_write_cmd_response</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"r"</expr></argument>, <argument><expr><name>rev</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type><name>get_dated_rev</name><parameter_list>(<param><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                                  <param><decl><type><name>apr_array_header_t</name> *</type><name>params</name></decl></param>, <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>server_baton_t</name> *</type><name>b</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_time_t</name></type> <name>tm</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>timestr</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_parse_tuple</name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"c"</expr></argument>, <argument><expr>&amp;<name>timestr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>trivial_auth_request</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_CMD_ERR</name><argument_list>(<argument><expr><call><name>svn_time_from_cstring</name><argument_list>(<argument><expr>&amp;<name>tm</name></expr></argument>, <argument><expr><name>timestr</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_CMD_ERR</name><argument_list>(<argument><expr><call><name>svn_repos_dated_revision</name><argument_list>(<argument><expr>&amp;<name>rev</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>repos</name></name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_write_cmd_response</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"r"</expr></argument>, <argument><expr><name>rev</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type><name>change_rev_prop</name><parameter_list>(<param><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                                    <param><decl><type><name>apr_array_header_t</name> *</type><name>params</name></decl></param>, <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>server_baton_t</name> *</type><name>b</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>value</name></decl>;</decl_stmt>

  <comment type="block">/* Because the revprop value was at one time mandatory, the usual
     optional element pattern "(?s)" isn't used. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_parse_tuple</name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"rc?s"</expr></argument>, <argument><expr>&amp;<name>rev</name></expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>, <argument><expr>&amp;<name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>must_have_access</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>svn_authz_write</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_CMD_ERR</name><argument_list>(<argument><expr><call><name>svn_repos_fs_change_rev_prop3</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>repos</name></name></expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>user</name></name></expr></argument>,
                                            <argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>,
                                            <argument><expr><call><name>authz_check_access_cb_func</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>b</name></expr></argument>,
                                            <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_write_cmd_response</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type><name>rev_proplist</name><parameter_list>(<param><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                                 <param><decl><type><name>apr_array_header_t</name> *</type><name>params</name></decl></param>, <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>server_baton_t</name> *</type><name>b</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>props</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_parse_tuple</name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"r"</expr></argument>, <argument><expr>&amp;<name>rev</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>trivial_auth_request</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_CMD_ERR</name><argument_list>(<argument><expr><call><name>svn_repos_fs_revision_proplist</name><argument_list>(<argument><expr>&amp;<name>props</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>repos</name></name></expr></argument>, <argument><expr><name>rev</name></expr></argument>,
                                             <argument><expr><call><name>authz_check_access_cb_func</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>b</name></expr></argument>,
                                             <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_write_tuple</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"w((!"</expr></argument>, <argument><expr>"success"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_write_proplist</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>props</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_write_tuple</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"!))"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type><name>rev_prop</name><parameter_list>(<param><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                             <param><decl><type><name>apr_array_header_t</name> *</type><name>params</name></decl></param>, <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>server_baton_t</name> *</type><name>b</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>value</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_parse_tuple</name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"rc"</expr></argument>, <argument><expr>&amp;<name>rev</name></expr></argument>, <argument><expr>&amp;<name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>trivial_auth_request</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_CMD_ERR</name><argument_list>(<argument><expr><call><name>svn_repos_fs_revision_prop</name><argument_list>(<argument><expr>&amp;<name>value</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>repos</name></name></expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name>name</name></expr></argument>,
                                         <argument><expr><call><name>authz_check_access_cb_func</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>b</name></expr></argument>,
                                         <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_write_cmd_response</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"(?s)"</expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type><name>commit_done</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>svn_commit_info_t</name> *</type><name>commit_info</name></decl></param>,
                                <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>commit_callback_baton_t</name> *</type><name>ccb</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr>*<name><name>ccb</name>-&gt;<name>new_rev</name></name> = <name><name>commit_info</name>-&gt;<name>revision</name></name></expr>;</expr_stmt>
  <expr_stmt><expr>*<name><name>ccb</name>-&gt;<name>date</name></name> = <name><name>commit_info</name>-&gt;<name>date</name></name>
    ? <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>ccb</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>commit_info</name>-&gt;<name>date</name></name></expr></argument>)</argument_list></call>: <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr>*<name><name>ccb</name>-&gt;<name>author</name></name> = <name><name>commit_info</name>-&gt;<name>author</name></name>
    ? <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>ccb</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>commit_info</name>-&gt;<name>author</name></name></expr></argument>)</argument_list></call> : <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr>*<name><name>ccb</name>-&gt;<name>post_commit_err</name></name> = <name><name>commit_info</name>-&gt;<name>post_commit_err</name></name>
    ? <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>ccb</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>commit_info</name>-&gt;<name>post_commit_err</name></name></expr></argument>)</argument_list></call> : <name>NULL</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Add the LOCK_TOKENS (if any) to the filesystem access context,
 * checking path authorizations using the state in SB as we go.
 * LOCK_TOKENS is an array of svn_ra_svn_item_t structs.  Return a
 * client error if LOCK_TOKENS is not a list of lists.  If a lock
 * violates the authz configuration, return SVN_ERR_RA_NOT_AUTHORIZED
 * to the client.  Use POOL for temporary allocations only.
 */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type><name>add_lock_tokens</name><parameter_list>(<param><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name></decl></param>,
                                    <param><decl><type><name>apr_array_header_t</name> *</type><name>lock_tokens</name></decl></param>,
                                    <param><decl><type><name>server_baton_t</name> *</type><name>sb</name></decl></param>,
                                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_access_t</name> *</type><name>fs_access</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_get_access</name><argument_list>(<argument><expr>&amp;<name>fs_access</name></expr></argument>, <argument><expr><name><name>sb</name>-&gt;<name>fs</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If there is no access context, nowhere to add the tokens. */</comment>
  <if>if <condition>(<expr>! <name>fs_access</name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>lock_tokens</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>)
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>, *<decl><type ref="prev"/><name>token</name></decl>, *<decl><type ref="prev"/><name>full_path</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_ra_svn_item_t</name> *</type><name>path_item</name></decl>, *<decl><type ref="prev"/><name>token_item</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_ra_svn_item_t</name> *</type><name>item</name> <init>= <expr>&amp;<call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>lock_tokens</name></expr></argument>, <argument><expr><name>i</name></expr></argument>,
                                               <argument><expr><name>svn_ra_svn_item_t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><name><name>item</name>-&gt;<name>kind</name></name> != <name>SVN_RA_SVN_LIST</name></expr>)</condition><then>
        <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_RA_SVN_MALFORMED_DATA</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                <argument><expr>"Lock tokens aren't a list of lists"</expr></argument>)</argument_list></call></expr>;</return></then></if>

      <expr_stmt><expr><name>path_item</name> = &amp;<call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name><name>item</name>-&gt;<name>u</name>.<name>list</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>svn_ra_svn_item_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name><name>path_item</name>-&gt;<name>kind</name></name> != <name>SVN_RA_SVN_STRING</name></expr>)</condition><then>
        <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_RA_SVN_MALFORMED_DATA</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                <argument><expr>"Lock path isn't a string"</expr></argument>)</argument_list></call></expr>;</return></then></if>

      <expr_stmt><expr><name>token_item</name> = &amp;<call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name><name>item</name>-&gt;<name>u</name>.<name>list</name></name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>svn_ra_svn_item_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name><name>token_item</name>-&gt;<name>kind</name></name> != <name>SVN_RA_SVN_STRING</name></expr>)</condition><then>
        <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_RA_SVN_MALFORMED_DATA</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                <argument><expr>"Lock token isn't a string"</expr></argument>)</argument_list></call></expr>;</return></then></if>

      <expr_stmt><expr><name>path</name> = <name><name>path_item</name>-&gt;<name>u</name>.<name>string</name>-&gt;<name>data</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>full_path</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name><name>sb</name>-&gt;<name>fs_path</name>-&gt;<name>data</name></name></expr></argument>,
                                <argument><expr><call><name>svn_path_canonicalize</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr>! <call><name>lookup_access</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>sb</name></expr></argument>, <argument><expr><name>svn_authz_write</name></expr></argument>,
                          <argument><expr><name>full_path</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_RA_NOT_AUTHORIZED</name></expr></argument>,
                                <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

      <expr_stmt><expr><name>token</name> = <name><name>token_item</name>-&gt;<name>u</name>.<name>string</name>-&gt;<name>data</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_access_add_lock_token</name><argument_list>(<argument><expr><name>fs_access</name></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Unlock the paths with lock tokens in LOCK_TOKENS, ignoring any errors.
   LOCK_TOKENS contains svn_ra_svn_item_t elements, assumed to be lists. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type><name>unlock_paths</name><parameter_list>(<param><decl><type><name>apr_array_header_t</name> *</type><name>lock_tokens</name></decl></param>,
                                 <param><decl><type><name>server_baton_t</name> *</type><name>sb</name></decl></param>,
                                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>iterpool</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>iterpool</name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>lock_tokens</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>)
    <block>{
      <decl_stmt><decl><type><name>svn_ra_svn_item_t</name> *</type><name>item</name></decl>, *<decl><type ref="prev"/><name>path_item</name></decl>, *<decl><type ref="prev"/><name>token_item</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>, *<decl><type ref="prev"/><name>token</name></decl>, *<decl><type ref="prev"/><name>full_path</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>item</name> = &amp;<call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>lock_tokens</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>svn_ra_svn_item_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>path_item</name> = &amp;<call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name><name>item</name>-&gt;<name>u</name>.<name>list</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>svn_ra_svn_item_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>token_item</name> = &amp;<call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name><name>item</name>-&gt;<name>u</name>.<name>list</name></name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>svn_ra_svn_item_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>path</name> = <name><name>path_item</name>-&gt;<name>u</name>.<name>string</name>-&gt;<name>data</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>token</name> = <name><name>token_item</name>-&gt;<name>u</name>.<name>string</name>-&gt;<name>data</name></name></expr>;</expr_stmt>

      <expr_stmt><expr><name>full_path</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name><name>sb</name>-&gt;<name>fs_path</name>-&gt;<name>data</name></name></expr></argument>,
                                <argument><expr><call><name>svn_path_canonicalize</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* The lock may have become defunct after the commit, so ignore such
         errors.

         ### If we ever write a logging facility for svnserve, this
             would be a good place to log an error before clearing
             it. */</comment>
      <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><call><name>svn_repos_fs_unlock</name><argument_list>(<argument><expr><name><name>sb</name>-&gt;<name>repos</name></name></expr></argument>, <argument><expr><name>full_path</name></expr></argument>, <argument><expr><name>token</name></expr></argument>,
                                          <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type><name>commit</name><parameter_list>(<param><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                           <param><decl><type><name>apr_array_header_t</name> *</type><name>params</name></decl></param>, <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>server_baton_t</name> *</type><name>b</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>log_msg</name> <init>= <expr><name>NULL</name></expr></init>,
             *<name>date</name> <init>= <expr><name>NULL</name></expr></init>,
             *<name>author</name> <init>= <expr><name>NULL</name></expr></init>,
             *<name>post_commit_err</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>lock_tokens</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>keep_locks</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>revprop_list</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>revprop_table</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_delta_editor_t</name> *</type><name>editor</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> *</type><name>edit_baton</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>aborted</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>commit_callback_baton_t</name></type> <name>ccb</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>new_rev</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><name><name>params</name>-&gt;<name>nelts</name></name> == 1</expr>)</condition><then>
    <block>{
      <comment type="block">/* Clients before 1.2 don't send lock-tokens, keep-locks,
         and rev-props fields. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_parse_tuple</name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"c"</expr></argument>, <argument><expr>&amp;<name>log_msg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>lock_tokens</name> = <name>NULL</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>keep_locks</name> = <name>TRUE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>revprop_list</name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <comment type="block">/* Clients before 1.5 don't send the rev-props field. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_parse_tuple</name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"clb?l"</expr></argument>, <argument><expr>&amp;<name>log_msg</name></expr></argument>,
                                     <argument><expr>&amp;<name>lock_tokens</name></expr></argument>, <argument><expr>&amp;<name>keep_locks</name></expr></argument>,
                                     <argument><expr>&amp;<name>revprop_list</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

  <comment type="block">/* The handling for locks is a little problematic, because the
     protocol won't let us send several auth requests once one has
     succeeded.  So we request write access and a username before
     adding tokens (if we have any), and subsequently fail if a lock
     violates authz. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>must_have_access</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>svn_authz_write</name></expr></argument>,
                           <argument><expr><name>NULL</name></expr></argument>,
                           <argument><expr>(<name>lock_tokens</name> &amp;&amp; <name><name>lock_tokens</name>-&gt;<name>nelts</name></name>) ? <name>TRUE</name> : <name>FALSE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Authorize the lock tokens and give them to the FS if we got
     any. */</comment>
  <if>if <condition>(<expr><name>lock_tokens</name> &amp;&amp; <name><name>lock_tokens</name>-&gt;<name>nelts</name></name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_CMD_ERR</name><argument_list>(<argument><expr><call><name>add_lock_tokens</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>lock_tokens</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <if>if <condition>(<expr><name>revprop_list</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_parse_proplist</name><argument_list>(<argument><expr><name>revprop_list</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>&amp;<name>revprop_table</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <block>{
      <expr_stmt><expr><name>revprop_table</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>revprop_table</name></expr></argument>, <argument><expr><name>SVN_PROP_REVISION_LOG</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>,
                   <argument><expr><call><name>svn_string_create</name><argument_list>(<argument><expr><name>log_msg</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

  <comment type="block">/* Get author from the baton, making sure clients can't circumvent
     the authentication via the revision props. */</comment>
  <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>revprop_table</name></expr></argument>, <argument><expr><name>SVN_PROP_REVISION_AUTHOR</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>,
               <argument><expr><name><name>b</name>-&gt;<name>user</name></name> ? <call><name>svn_string_create</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>user</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call> : <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>ccb</name>.<name>pool</name></name> = <name>pool</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ccb</name>.<name>new_rev</name></name> = &amp;<name>new_rev</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ccb</name>.<name>date</name></name> = &amp;<name>date</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ccb</name>.<name>author</name></name> = &amp;<name>author</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ccb</name>.<name>post_commit_err</name></name> = &amp;<name>post_commit_err</name></expr>;</expr_stmt>
  <comment type="block">/* ### Note that svn_repos_get_commit_editor5 actually wants a decoded URL. */</comment>
  <expr_stmt><expr><call><name>SVN_CMD_ERR</name><argument_list>(<argument><expr><call><name>svn_repos_get_commit_editor5</name>
              <argument_list>(<argument><expr>&amp;<name>editor</name></expr></argument>, <argument><expr>&amp;<name>edit_baton</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>repos</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
               <argument><expr><call><name>svn_path_uri_decode</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>repos_url</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
               <argument><expr><name><name>b</name>-&gt;<name>fs_path</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name>revprop_table</name></expr></argument>,
               <argument><expr><name>commit_done</name></expr></argument>, <argument><expr>&amp;<name>ccb</name></expr></argument>,
               <argument><expr><name>authz_commit_cb</name></expr></argument>, <argument><expr><name>baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_write_cmd_response</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_drive_editor</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>editor</name></expr></argument>, <argument><expr><name>edit_baton</name></expr></argument>, <argument><expr>&amp;<name>aborted</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<name>aborted</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>trivial_auth_request</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* In tunnel mode, deltify before answering the client, because
         answering may cause the client to terminate the connection
         and thus kill the server.  But otherwise, deltify after
         answering the client, to avoid user-visible delay. */</comment>

      <if>if <condition>(<expr><name><name>b</name>-&gt;<name>tunnel</name></name></expr>)</condition><then>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_deltify_revision</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>new_rev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

      <comment type="block">/* Unlock the paths. */</comment>
      <if>if <condition>(<expr>! <name>keep_locks</name> &amp;&amp; <name>lock_tokens</name> &amp;&amp; <name><name>lock_tokens</name>-&gt;<name>nelts</name></name></expr>)</condition><then>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>unlock_paths</name><argument_list>(<argument><expr><name>lock_tokens</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_write_tuple</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"r(?c)(?c)(?c)"</expr></argument>,
                                     <argument><expr><name>new_rev</name></expr></argument>, <argument><expr><name>date</name></expr></argument>, <argument><expr><name>author</name></expr></argument>, <argument><expr><name>post_commit_err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr>! <name><name>b</name>-&gt;<name>tunnel</name></name></expr>)</condition><then>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_deltify_revision</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>new_rev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then></if>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type><name>get_file</name><parameter_list>(<param><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                             <param><decl><type><name>apr_array_header_t</name> *</type><name>params</name></decl></param>, <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>server_baton_t</name> *</type><name>b</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>, *<decl><type ref="prev"/><name>full_path</name></decl>, *<decl><type ref="prev"/><name>hex_digest</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>contents</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>props</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_string_t</name></type> <name>write_str</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>4096</expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>want_props</name></decl>, <decl><type ref="prev"/><name>want_contents</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>digest</name><index>[<expr><name>APR_MD5_DIGESTSIZE</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>, *<decl><type ref="prev"/><name>write_err</name></decl>;</decl_stmt>

  <comment type="block">/* Parse arguments. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_parse_tuple</name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"c(?r)bb"</expr></argument>, <argument><expr>&amp;<name>path</name></expr></argument>, <argument><expr>&amp;<name>rev</name></expr></argument>,
                                 <argument><expr>&amp;<name>want_props</name></expr></argument>, <argument><expr>&amp;<name>want_contents</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>full_path</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>fs_path</name>-&gt;<name>data</name></name></expr></argument>,
                            <argument><expr><call><name>svn_path_canonicalize</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check authorizations */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>must_have_access</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>svn_authz_read</name></expr></argument>,
                           <argument><expr><name>full_path</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr>!<call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name>rev</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_CMD_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_youngest_rev</name><argument_list>(<argument><expr>&amp;<name>rev</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* Fetch the properties and a stream for the contents. */</comment>
  <expr_stmt><expr><call><name>SVN_CMD_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_revision_root</name><argument_list>(<argument><expr>&amp;<name>root</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_CMD_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_file_md5_checksum</name><argument_list>(<argument><expr><name>digest</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>full_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>hex_digest</name> = <call><name>svn_md5_digest_to_cstring_display</name><argument_list>(<argument><expr><name>digest</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>want_props</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_CMD_ERR</name><argument_list>(<argument><expr><call><name>get_props</name><argument_list>(<argument><expr>&amp;<name>props</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>full_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <if>if <condition>(<expr><name>want_contents</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_CMD_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_file_contents</name><argument_list>(<argument><expr>&amp;<name>contents</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>full_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* Send successful command response with revision and props. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_write_tuple</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"w((?c)r(!"</expr></argument>, <argument><expr>"success"</expr></argument>,
                                 <argument><expr><name>hex_digest</name></expr></argument>, <argument><expr><name>rev</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_write_proplist</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>props</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_write_tuple</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"!))"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Now send the file's contents. */</comment>
  <if>if <condition>(<expr><name>want_contents</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>err</name> = <name>SVN_NO_ERROR</name></expr>;</expr_stmt>
      <while>while <condition>(<expr>1</expr>)</condition>
        <block>{
          <expr_stmt><expr><name>len</name> = <sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
          <expr_stmt><expr><name>err</name> = <call><name>svn_stream_read</name><argument_list>(<argument><expr><name>contents</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
            <break>break;</break></then></if>
          <if>if <condition>(<expr><name>len</name> &gt; 0</expr>)</condition><then>
            <block>{
              <expr_stmt><expr><name><name>write_str</name>.<name>data</name></name> = <name>buf</name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>write_str</name>.<name>len</name></name> = <name>len</name></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_write_string</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>&amp;<name>write_str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
          <if>if <condition>(<expr><name>len</name> &lt; <sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr>)</condition><then>
            <block>{
              <expr_stmt><expr><name>err</name> = <call><name>svn_stream_close</name><argument_list>(<argument><expr><name>contents</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <break>break;</break>
            }</block></then></if>
        }</block></while>
      <expr_stmt><expr><name>write_err</name> = <call><name>svn_ra_svn_write_cstring</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>write_err</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>write_err</name></expr>;</return>
        }</block></then></if>
      <expr_stmt><expr><call><name>SVN_CMD_ERR</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_write_cmd_response</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type><name>get_dir</name><parameter_list>(<param><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                            <param><decl><type><name>apr_array_header_t</name> *</type><name>params</name></decl></param>, <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>server_baton_t</name> *</type><name>b</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>, *<decl><type ref="prev"/><name>full_path</name></decl>, *<decl><type ref="prev"/><name>file_path</name></decl>, *<decl><type ref="prev"/><name>name</name></decl>, *<decl><type ref="prev"/><name>cauthor</name></decl>, *<decl><type ref="prev"/><name>cdate</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>entries</name></decl>, *<decl><type ref="prev"/><name>props</name> <init>= <expr><name>NULL</name></expr></init>, *<name>file_props</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_dirent_t</name> *</type><name>fsent</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_dirent_t</name> *</type><name>entry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>want_props</name></decl>, <decl><type ref="prev"/><name>want_contents</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_uint64_t</name></type> <name>dirent_fields</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>dirent_fields_list</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_ra_svn_item_t</name> *</type><name>elt</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_parse_tuple</name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"c(?r)bb?l"</expr></argument>, <argument><expr>&amp;<name>path</name></expr></argument>, <argument><expr>&amp;<name>rev</name></expr></argument>,
                                 <argument><expr>&amp;<name>want_props</name></expr></argument>, <argument><expr>&amp;<name>want_contents</name></expr></argument>,
                                 <argument><expr>&amp;<name>dirent_fields_list</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr>! <name>dirent_fields_list</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>dirent_fields</name> = <name>SVN_DIRENT_ALL</name></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <expr_stmt><expr><name>dirent_fields</name> = 0</expr>;</expr_stmt>

      <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>dirent_fields_list</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>)
        <block>{
          <expr_stmt><expr><name>elt</name> = &amp;<call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>dirent_fields_list</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>svn_ra_svn_item_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <if>if <condition>(<expr><name><name>elt</name>-&gt;<name>kind</name></name> != <name>SVN_RA_SVN_WORD</name></expr>)</condition><then>
            <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_RA_SVN_MALFORMED_DATA</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                    <argument><expr>"Dirent field not a string"</expr></argument>)</argument_list></call></expr>;</return></then></if>

          <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>SVN_RA_SVN_DIRENT_KIND</name></expr></argument>, <argument><expr><name><name>elt</name>-&gt;<name>u</name>.<name>word</name></name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
            <expr_stmt><expr><name>dirent_fields</name> |= <name>SVN_DIRENT_KIND</name></expr>;</expr_stmt></then>
          <else>else <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>SVN_RA_SVN_DIRENT_SIZE</name></expr></argument>, <argument><expr><name><name>elt</name>-&gt;<name>u</name>.<name>word</name></name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
            <expr_stmt><expr><name>dirent_fields</name> |= <name>SVN_DIRENT_SIZE</name></expr>;</expr_stmt></then>
          <else>else <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>SVN_RA_SVN_DIRENT_HAS_PROPS</name></expr></argument>, <argument><expr><name><name>elt</name>-&gt;<name>u</name>.<name>word</name></name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
            <expr_stmt><expr><name>dirent_fields</name> |= <name>SVN_DIRENT_HAS_PROPS</name></expr>;</expr_stmt></then>
          <else>else <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>SVN_RA_SVN_DIRENT_CREATED_REV</name></expr></argument>, <argument><expr><name><name>elt</name>-&gt;<name>u</name>.<name>word</name></name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
            <expr_stmt><expr><name>dirent_fields</name> |= <name>SVN_DIRENT_CREATED_REV</name></expr>;</expr_stmt></then>
          <else>else <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>SVN_RA_SVN_DIRENT_TIME</name></expr></argument>, <argument><expr><name><name>elt</name>-&gt;<name>u</name>.<name>word</name></name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
            <expr_stmt><expr><name>dirent_fields</name> |= <name>SVN_DIRENT_TIME</name></expr>;</expr_stmt></then>
          <else>else <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>SVN_RA_SVN_DIRENT_LAST_AUTHOR</name></expr></argument>, <argument><expr><name><name>elt</name>-&gt;<name>u</name>.<name>word</name></name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
            <expr_stmt><expr><name>dirent_fields</name> |= <name>SVN_DIRENT_LAST_AUTHOR</name></expr>;</expr_stmt></then></if></else></if></else></if></else></if></else></if></else></if>
        }</block></for>
    }</block></else></if>

  <expr_stmt><expr><name>full_path</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>fs_path</name>-&gt;<name>data</name></name></expr></argument>,
                            <argument><expr><call><name>svn_path_canonicalize</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check authorizations */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>must_have_access</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>svn_authz_read</name></expr></argument>,
                           <argument><expr><name>full_path</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr>!<call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name>rev</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_CMD_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_youngest_rev</name><argument_list>(<argument><expr>&amp;<name>rev</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* Fetch the root of the appropriate revision. */</comment>
  <expr_stmt><expr><call><name>SVN_CMD_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_revision_root</name><argument_list>(<argument><expr>&amp;<name>root</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Fetch the directory properties if requested. */</comment>
  <if>if <condition>(<expr><name>want_props</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_CMD_ERR</name><argument_list>(<argument><expr><call><name>get_props</name><argument_list>(<argument><expr>&amp;<name>props</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>full_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* Fetch the directory entries if requested. */</comment>
  <if>if <condition>(<expr><name>want_contents</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_CMD_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_dir_entries</name><argument_list>(<argument><expr>&amp;<name>entries</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>full_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Transform the hash table's FS entries into dirents.  This probably
       * belongs in libsvn_repos. */</comment>
      <expr_stmt><expr><name>subpool</name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>entries</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>hi</name></expr>;</condition> <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
        <block>{
          <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>name</name> = <name>key</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>fsent</name> = <name>val</name></expr>;</expr_stmt>

          <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <expr_stmt><expr><name>file_path</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>full_path</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>entry</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>entry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <if>if <condition>(<expr><name>dirent_fields</name> &amp; <name>SVN_DIRENT_KIND</name></expr>)</condition><then>
            <block>{
              <comment type="block">/* kind */</comment>
              <expr_stmt><expr><name><name>entry</name>-&gt;<name>kind</name></name> = <name><name>fsent</name>-&gt;<name>kind</name></name></expr>;</expr_stmt>
            }</block></then></if>

          <if>if <condition>(<expr><name>dirent_fields</name> &amp; <name>SVN_DIRENT_SIZE</name></expr>)</condition><then>
            <block>{
              <comment type="block">/* size */</comment>
              <if>if <condition>(<expr><name><name>entry</name>-&gt;<name>kind</name></name> == <name>svn_node_dir</name></expr>)</condition><then>
                <expr_stmt><expr><name><name>entry</name>-&gt;<name>size</name></name> = 0</expr>;</expr_stmt></then>
              <else>else
                <expr_stmt><expr><call><name>SVN_CMD_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_file_length</name><argument_list>(<argument><expr>&amp;<name><name>entry</name>-&gt;<name>size</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>file_path</name></expr></argument>,
                                               <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
            }</block></then></if>

          <if>if <condition>(<expr><name>dirent_fields</name> &amp; <name>SVN_DIRENT_HAS_PROPS</name></expr>)</condition><then>
            <block>{
              <comment type="block">/* has_props */</comment>
              <expr_stmt><expr><call><name>SVN_CMD_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_node_proplist</name><argument_list>(<argument><expr>&amp;<name>file_props</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>file_path</name></expr></argument>,
                                               <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>entry</name>-&gt;<name>has_props</name></name> = (<call><name>apr_hash_count</name><argument_list>(<argument><expr><name>file_props</name></expr></argument>)</argument_list></call> &gt; 0) ? <name>TRUE</name>
                                                                  : <name>FALSE</name></expr>;</expr_stmt>
            }</block></then></if>

          <if>if <condition>(<expr>(<name>dirent_fields</name> &amp; <name>SVN_DIRENT_LAST_AUTHOR</name>)
              || (<name>dirent_fields</name> &amp; <name>SVN_DIRENT_TIME</name>)
              || (<name>dirent_fields</name> &amp; <name>SVN_DIRENT_CREATED_REV</name>)</expr>)</condition><then>
            <block>{
              <comment type="block">/* created_rev, last_author, time */</comment>
              <expr_stmt><expr><call><name>SVN_CMD_ERR</name><argument_list>(<argument><expr><call><name>svn_repos_get_committed_info</name><argument_list>(<argument><expr>&amp;<name><name>entry</name>-&gt;<name>created_rev</name></name></expr></argument>,
                                                       <argument><expr>&amp;<name>cdate</name></expr></argument>,
                                                       <argument><expr>&amp;<name>cauthor</name></expr></argument>, <argument><expr><name>root</name></expr></argument>,
                                                       <argument><expr><name>file_path</name></expr></argument>,
                                                       <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>entry</name>-&gt;<name>last_author</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>cauthor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <if>if <condition>(<expr><name>cdate</name></expr>)</condition><then>
                <expr_stmt><expr><call><name>SVN_CMD_ERR</name><argument_list>(<argument><expr><call><name>svn_time_from_cstring</name><argument_list>(<argument><expr>&amp;<name><name>entry</name>-&gt;<name>time</name></name></expr></argument>, <argument><expr><name>cdate</name></expr></argument>,
                                                  <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
              <else>else
                <expr_stmt><expr><name><name>entry</name>-&gt;<name>time</name></name> = (<name>time_t</name>) -1</expr>;</expr_stmt></else></if>
            }</block></then></if>

          <comment type="block">/* Store the entry. */</comment>
          <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>entries</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
      <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* Write out response. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_write_tuple</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"w(r(!"</expr></argument>, <argument><expr>"success"</expr></argument>, <argument><expr><name>rev</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_write_proplist</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>props</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_write_tuple</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"!)(!"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>want_contents</name></expr>)</condition><then>
    <block>{
      <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>entries</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>hi</name></expr>;</condition> <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
        <block>{
          <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>name</name> = <name>key</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>entry</name> = <name>val</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>cdate</name> = (<name><name>entry</name>-&gt;<name>time</name></name> == (<name>time_t</name>) -1) ? <name>NULL</name>
            : <call><name>svn_time_to_cstring</name><argument_list>(<argument><expr><name><name>entry</name>-&gt;<name>time</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_write_tuple</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"cwnbr(?c)(?c)"</expr></argument>, <argument><expr><name>name</name></expr></argument>,
                                         <argument><expr><call><name>kind_word</name><argument_list>(<argument><expr><name><name>entry</name>-&gt;<name>kind</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                         <argument><expr>(<name>apr_uint64_t</name>) <name><name>entry</name>-&gt;<name>size</name></name></expr></argument>,
                                         <argument><expr><name><name>entry</name>-&gt;<name>has_props</name></name></expr></argument>, <argument><expr><name><name>entry</name>-&gt;<name>created_rev</name></name></expr></argument>,
                                         <argument><expr><name>cdate</name></expr></argument>, <argument><expr><name><name>entry</name>-&gt;<name>last_author</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
    }</block></then></if>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_write_tuple</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"!))"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type><name>update</name><parameter_list>(<param><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                           <param><decl><type><name>apr_array_header_t</name> *</type><name>params</name></decl></param>, <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>server_baton_t</name> *</type><name>b</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>target</name></decl>, *<decl><type ref="prev"/><name>full_path</name></decl>, *<decl><type ref="prev"/><name>depth_word</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>recurse</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>send_copyfrom_args</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_uint64_t</name></type> <name>send_copyfrom_param</name></decl>;</decl_stmt>
  <comment type="block">/* Default to unknown.  Old clients won't send depth, but we'll
     handle that by converting recurse if necessary. */</comment>
  <decl_stmt><decl><type><name>svn_depth_t</name></type> <name>depth</name> <init>= <expr><name>svn_depth_unknown</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Parse the arguments. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_parse_tuple</name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"(?r)cb?wB"</expr></argument>, <argument><expr>&amp;<name>rev</name></expr></argument>, <argument><expr>&amp;<name>target</name></expr></argument>,
                                 <argument><expr>&amp;<name>recurse</name></expr></argument>, <argument><expr>&amp;<name>depth_word</name></expr></argument>, <argument><expr>&amp;<name>send_copyfrom_param</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>target</name> = <call><name>svn_path_canonicalize</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>depth_word</name></expr>)</condition><then>
    <expr_stmt><expr><name>depth</name> = <call><name>svn_depth_from_word</name><argument_list>(<argument><expr><name>depth_word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name>depth</name> = <call><name>SVN_DEPTH_INFINITY_OR_FILES</name><argument_list>(<argument><expr><name>recurse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

  <expr_stmt><expr><name>send_copyfrom_args</name> = (<name>send_copyfrom_param</name> == <name>SVN_RA_SVN_UNSPECIFIED_NUMBER</name>) ?
      <name>FALSE</name> : (<name>svn_boolean_t</name>) <name>send_copyfrom_param</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>full_path</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>fs_path</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* Check authorization and authenticate the user if necessary. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>must_have_access</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>svn_authz_read</name></expr></argument>, <argument><expr><name>full_path</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr>!<call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name>rev</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_CMD_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_youngest_rev</name><argument_list>(<argument><expr>&amp;<name>rev</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <return>return <expr><call><name>accept_report</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>,
                       <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>send_copyfrom_args</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type><name>switch_cmd</name><parameter_list>(<param><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                               <param><decl><type><name>apr_array_header_t</name> *</type><name>params</name></decl></param>, <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>server_baton_t</name> *</type><name>b</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>target</name></decl>, *<decl><type ref="prev"/><name>depth_word</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>switch_url</name></decl>, *<decl><type ref="prev"/><name>switch_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>recurse</name></decl>;</decl_stmt>
  <comment type="block">/* Default to unknown.  Old clients won't send depth, but we'll
     handle that by converting recurse if necessary. */</comment>
  <decl_stmt><decl><type><name>svn_depth_t</name></type> <name>depth</name> <init>= <expr><name>svn_depth_unknown</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Parse the arguments. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_parse_tuple</name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"(?r)cbc?w"</expr></argument>, <argument><expr>&amp;<name>rev</name></expr></argument>, <argument><expr>&amp;<name>target</name></expr></argument>,
                                 <argument><expr>&amp;<name>recurse</name></expr></argument>, <argument><expr>&amp;<name>switch_url</name></expr></argument>, <argument><expr>&amp;<name>depth_word</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>target</name> = <call><name>svn_path_canonicalize</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>switch_url</name> = <call><name>svn_path_canonicalize</name><argument_list>(<argument><expr><name>switch_url</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>depth_word</name></expr>)</condition><then>
    <expr_stmt><expr><name>depth</name> = <call><name>svn_depth_from_word</name><argument_list>(<argument><expr><name>depth_word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name>depth</name> = <call><name>SVN_DEPTH_INFINITY_OR_FILES</name><argument_list>(<argument><expr><name>recurse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>trivial_auth_request</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name>rev</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_CMD_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_youngest_rev</name><argument_list>(<argument><expr>&amp;<name>rev</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <expr_stmt><expr><call><name>SVN_CMD_ERR</name><argument_list>(<argument><expr><call><name>get_fs_path</name><argument_list>(<argument><expr><call><name>svn_path_uri_decode</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>repos_url</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><call><name>svn_path_uri_decode</name><argument_list>(<argument><expr><name>switch_url</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr>&amp;<name>switch_path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><call><name>accept_report</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>switch_path</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>,
                       <argument><expr><name>depth</name></expr></argument>,
                       <argument><expr><name>FALSE</name></expr></argument> <comment type="block">/* TODO(sussman): no copyfrom args for now */</comment>,
                       <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type><name>status</name><parameter_list>(<param><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                           <param><decl><type><name>apr_array_header_t</name> *</type><name>params</name></decl></param>, <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>server_baton_t</name> *</type><name>b</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>target</name></decl>, *<decl><type ref="prev"/><name>depth_word</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>recurse</name></decl>;</decl_stmt>
  <comment type="block">/* Default to unknown.  Old clients won't send depth, but we'll
     handle that by converting recurse if necessary. */</comment>
  <decl_stmt><decl><type><name>svn_depth_t</name></type> <name>depth</name> <init>= <expr><name>svn_depth_unknown</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Parse the arguments. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_parse_tuple</name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"cb?(?r)?w"</expr></argument>,
                                 <argument><expr>&amp;<name>target</name></expr></argument>, <argument><expr>&amp;<name>recurse</name></expr></argument>, <argument><expr>&amp;<name>rev</name></expr></argument>, <argument><expr>&amp;<name>depth_word</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>target</name> = <call><name>svn_path_canonicalize</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>depth_word</name></expr>)</condition><then>
    <expr_stmt><expr><name>depth</name> = <call><name>svn_depth_from_word</name><argument_list>(<argument><expr><name>depth_word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name>depth</name> = <name>recurse</name> ? <name>svn_depth_infinity</name> : <name>svn_depth_empty</name></expr>;</expr_stmt></else></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>trivial_auth_request</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name>rev</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_CMD_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_youngest_rev</name><argument_list>(<argument><expr>&amp;<name>rev</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <return>return <expr><call><name>accept_report</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                       <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type><name>diff</name><parameter_list>(<param><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                         <param><decl><type><name>apr_array_header_t</name> *</type><name>params</name></decl></param>, <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>server_baton_t</name> *</type><name>b</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>target</name></decl>, *<decl><type ref="prev"/><name>versus_url</name></decl>, *<decl><type ref="prev"/><name>versus_path</name></decl>, *<decl><type ref="prev"/><name>depth_word</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>recurse</name></decl>, <decl><type ref="prev"/><name>ignore_ancestry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>text_deltas</name></decl>;</decl_stmt>
  <comment type="block">/* Default to unknown.  Old clients won't send depth, but we'll
     handle that by converting recurse if necessary. */</comment>
  <decl_stmt><decl><type><name>svn_depth_t</name></type> <name>depth</name> <init>= <expr><name>svn_depth_unknown</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Parse the arguments. */</comment>
  <if>if <condition>(<expr><name><name>params</name>-&gt;<name>nelts</name></name> == 5</expr>)</condition><then>
    <block>{
      <comment type="block">/* Clients before 1.4 don't send the text_deltas boolean or depth. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_parse_tuple</name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"(?r)cbbc"</expr></argument>, <argument><expr>&amp;<name>rev</name></expr></argument>, <argument><expr>&amp;<name>target</name></expr></argument>,
                                     <argument><expr>&amp;<name>recurse</name></expr></argument>, <argument><expr>&amp;<name>ignore_ancestry</name></expr></argument>, <argument><expr>&amp;<name>versus_url</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>text_deltas</name> = <name>TRUE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>depth_word</name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_parse_tuple</name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"(?r)cbbcb?w"</expr></argument>,
                                     <argument><expr>&amp;<name>rev</name></expr></argument>, <argument><expr>&amp;<name>target</name></expr></argument>, <argument><expr>&amp;<name>recurse</name></expr></argument>,
                                     <argument><expr>&amp;<name>ignore_ancestry</name></expr></argument>, <argument><expr>&amp;<name>versus_url</name></expr></argument>,
                                     <argument><expr>&amp;<name>text_deltas</name></expr></argument>, <argument><expr>&amp;<name>depth_word</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
  <expr_stmt><expr><name>target</name> = <call><name>svn_path_canonicalize</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>versus_url</name> = <call><name>svn_path_canonicalize</name><argument_list>(<argument><expr><name>versus_url</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>depth_word</name></expr>)</condition><then>
    <expr_stmt><expr><name>depth</name> = <call><name>svn_depth_from_word</name><argument_list>(<argument><expr><name>depth_word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name>depth</name> = <call><name>SVN_DEPTH_INFINITY_OR_FILES</name><argument_list>(<argument><expr><name>recurse</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>trivial_auth_request</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr>!<call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name>rev</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_CMD_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_youngest_rev</name><argument_list>(<argument><expr>&amp;<name>rev</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <expr_stmt><expr><call><name>SVN_CMD_ERR</name><argument_list>(<argument><expr><call><name>get_fs_path</name><argument_list>(<argument><expr><call><name>svn_path_uri_decode</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>repos_url</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><call><name>svn_path_uri_decode</name><argument_list>(<argument><expr><name>versus_url</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr>&amp;<name>versus_path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><call><name>accept_report</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>versus_path</name></expr></argument>,
                       <argument><expr><name>text_deltas</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>ignore_ancestry</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Regardless of whether a client's capabilities indicate an
   understanding of this command (by way of SVN_RA_SVN_CAP_MERGEINFO),
   we provide a response.

   ASSUMPTION: When performing a 'merge' with two URLs at different
   revisions, the client will call this command more than once. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type><name>get_mergeinfo</name><parameter_list>(<param><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                                  <param><decl><type><name>apr_array_header_t</name> *</type><name>params</name></decl></param>, <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>server_baton_t</name> *</type><name>b</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>paths</name></decl>, *<decl><type ref="prev"/><name>canonical_paths</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_mergeinfo_catalog_t</name></type> <name>mergeinfo</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>inherit_word</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_mergeinfo_inheritance_t</name></type> <name>inherit</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>include_descendants</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>iterpool</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_parse_tuple</name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"l(?r)wb"</expr></argument>, <argument><expr>&amp;<name>paths</name></expr></argument>, <argument><expr>&amp;<name>rev</name></expr></argument>,
                                 <argument><expr>&amp;<name>inherit_word</name></expr></argument>, <argument><expr>&amp;<name>include_descendants</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>inherit</name> = <call><name>svn_inheritance_from_word</name><argument_list>(<argument><expr><name>inherit_word</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Canonicalize the paths which mergeinfo has been requested for. */</comment>
  <expr_stmt><expr><name>canonical_paths</name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>paths</name>-&gt;<name>nelts</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>const <name>char</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>paths</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
     <block>{
        <decl_stmt><decl><type><name>svn_ra_svn_item_t</name> *</type><name>item</name> <init>= <expr>&amp;<call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>paths</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>svn_ra_svn_item_t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>full_path</name></decl>;</decl_stmt>

        <if>if <condition>(<expr><name><name>item</name>-&gt;<name>kind</name></name> != <name>SVN_RA_SVN_STRING</name></expr>)</condition><then>
          <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_RA_SVN_MALFORMED_DATA</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                  <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Path is not a string"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
        <expr_stmt><expr><name>full_path</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>fs_path</name>-&gt;<name>data</name></name></expr></argument>,
                                  <argument><expr><call><name>svn_path_canonicalize</name><argument_list>(<argument><expr><name><name>item</name>-&gt;<name>u</name>.<name>string</name>-&gt;<name>data</name></name></expr></argument>,
                                                        <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                                  <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>canonical_paths</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call> = <name>full_path</name></expr>;</expr_stmt>
     }</block></for>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>trivial_auth_request</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_CMD_ERR</name><argument_list>(<argument><expr><call><name>svn_repos_fs_get_mergeinfo</name><argument_list>(<argument><expr>&amp;<name>mergeinfo</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>repos</name></name></expr></argument>,
                                         <argument><expr><name>canonical_paths</name></expr></argument>, <argument><expr><name>rev</name></expr></argument>,
                                         <argument><expr><name>inherit</name></expr></argument>,
                                         <argument><expr><name>include_descendants</name></expr></argument>,
                                         <argument><expr><call><name>authz_check_access_cb_func</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>b</name></expr></argument>,
                                         <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo__remove_prefix_from_catalog</name><argument_list>(<argument><expr>&amp;<name>mergeinfo</name></expr></argument>, <argument><expr><name>mergeinfo</name></expr></argument>,
                                                    <argument><expr><name><name>b</name>-&gt;<name>fs_path</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_write_tuple</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"w((!"</expr></argument>, <argument><expr>"success"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>iterpool</name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>mergeinfo</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>hi</name></expr>;</condition> <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>void</name> *</type><name>value</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>mergeinfo_string</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo_to_string</name><argument_list>(<argument><expr>&amp;<name>mergeinfo_string</name></expr></argument>,
                                      <argument><expr>(<name>svn_mergeinfo_t</name>) <name>value</name></expr></argument>,
                                      <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_write_tuple</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>, <argument><expr>"cs"</expr></argument>, <argument><expr>(const <name>char</name> *) <name>key</name></expr></argument>,
                                     <argument><expr><name>mergeinfo_string</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_write_tuple</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"!))"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Send a log entry to the client. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type><name>log_receiver</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>,
                                 <param><decl><type><name>svn_log_entry_t</name> *</type><name>log_entry</name></decl></param>,
                                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>log_baton_t</name> *</type><name>b</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name> <init>= <expr><name><name>b</name>-&gt;<name>conn</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>h</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_log_changed_path_t</name> *</type><name>change</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>invalid_revnum</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>action</name><index>[<expr>2</expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>author</name></decl>, *<decl><type ref="prev"/><name>date</name></decl>, *<decl><type ref="prev"/><name>message</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_uint64_t</name></type> <name>revprop_count</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><name><name>log_entry</name>-&gt;<name>revision</name></name> == <name>SVN_INVALID_REVNUM</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* If the stack depth is zero, we've seen the last revision, so don't
         send it, just return. */</comment>
      <if>if <condition>(<expr><name><name>b</name>-&gt;<name>stack_depth</name></name> == 0</expr>)</condition><then>
        <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

      <comment type="block">/* Because the svn protocol won't let us send an invalid revnum, we have
         to fudge here and send an additional flag. */</comment>
      <expr_stmt><expr><name><name>log_entry</name>-&gt;<name>revision</name></name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name>invalid_revnum</name> = <name>TRUE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>b</name>-&gt;<name>stack_depth</name></name>--</expr>;</expr_stmt>
    }</block></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_write_tuple</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"(!"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name><name>log_entry</name>-&gt;<name>changed_paths</name></name></expr>)</condition><then>
    <block>{
      <for>for (<init><expr><name>h</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>log_entry</name>-&gt;<name>changed_paths</name></name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>h</name></expr>;</condition>
                                                        <incr><expr><name>h</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>h</name></expr></argument>)</argument_list></call></expr></incr>)
        <block>{
          <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>h</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>path</name> = <name>key</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>change</name> = <name>val</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>action</name><index>[<expr>0</expr>]</index></name> = <name><name>change</name>-&gt;<name>action</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>action</name><index>[<expr>1</expr>]</index></name> = '\0'</expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_write_tuple</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"cw(?cr)"</expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>action</name></expr></argument>,
                                         <argument><expr><name><name>change</name>-&gt;<name>copyfrom_path</name></name></expr></argument>,
                                         <argument><expr><name><name>change</name>-&gt;<name>copyfrom_rev</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
    }</block></then></if>
  <expr_stmt><expr><call><name>svn_compat_log_revprops_out</name><argument_list>(<argument><expr>&amp;<name>author</name></expr></argument>, <argument><expr>&amp;<name>date</name></expr></argument>, <argument><expr>&amp;<name>message</name></expr></argument>, <argument><expr><name><name>log_entry</name>-&gt;<name>revprops</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_compat_log_revprops_clear</name><argument_list>(<argument><expr><name><name>log_entry</name>-&gt;<name>revprops</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name><name>log_entry</name>-&gt;<name>revprops</name></name></expr>)</condition><then>
    <expr_stmt><expr><name>revprop_count</name> = <call><name>apr_hash_count</name><argument_list>(<argument><expr><name><name>log_entry</name>-&gt;<name>revprops</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name>revprop_count</name> = 0</expr>;</expr_stmt></else></if>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_write_tuple</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"!)r(?c)(?c)(?c)bbn(!"</expr></argument>,
                                 <argument><expr><name><name>log_entry</name>-&gt;<name>revision</name></name></expr></argument>,
                                 <argument><expr><name>author</name></expr></argument>, <argument><expr><name>date</name></expr></argument>, <argument><expr><name>message</name></expr></argument>,
                                 <argument><expr><name><name>log_entry</name>-&gt;<name>has_children</name></name></expr></argument>,
                                 <argument><expr><name>invalid_revnum</name></expr></argument>, <argument><expr><name>revprop_count</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_write_proplist</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>log_entry</name>-&gt;<name>revprops</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_write_tuple</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"!)"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name><name>log_entry</name>-&gt;<name>has_children</name></name></expr>)</condition><then>
    <expr_stmt><expr><name><name>b</name>-&gt;<name>stack_depth</name></name>++</expr>;</expr_stmt></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type><name>log_cmd</name><parameter_list>(<param><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                            <param><decl><type><name>apr_array_header_t</name> *</type><name>params</name></decl></param>, <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>, *<decl><type ref="prev"/><name>write_err</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>server_baton_t</name> *</type><name>b</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>start_rev</name></decl>, <decl><type ref="prev"/><name>end_rev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>full_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>changed_paths</name></decl>, <decl><type ref="prev"/><name>strict_node</name></decl>, <decl><type ref="prev"/><name>include_merged_revisions</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>paths</name></decl>, *<decl><type ref="prev"/><name>full_paths</name></decl>, *<decl><type ref="prev"/><name>revprop_items</name></decl>, *<decl><type ref="prev"/><name>revprops</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>revprop_word</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_ra_svn_item_t</name> *</type><name>elt</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_uint64_t</name></type> <name>limit</name></decl>, <decl><type ref="prev"/><name>include_merged_revs_param</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>log_baton_t</name></type> <name>lb</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_parse_tuple</name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"l(?r)(?r)bb?n?Bwl"</expr></argument>, <argument><expr>&amp;<name>paths</name></expr></argument>,
                                 <argument><expr>&amp;<name>start_rev</name></expr></argument>, <argument><expr>&amp;<name>end_rev</name></expr></argument>, <argument><expr>&amp;<name>changed_paths</name></expr></argument>,
                                 <argument><expr>&amp;<name>strict_node</name></expr></argument>, <argument><expr>&amp;<name>limit</name></expr></argument>,
                                 <argument><expr>&amp;<name>include_merged_revs_param</name></expr></argument>,
                                 <argument><expr>&amp;<name>revprop_word</name></expr></argument>, <argument><expr>&amp;<name>revprop_items</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>include_merged_revs_param</name> == <name>SVN_RA_SVN_UNSPECIFIED_NUMBER</name></expr>)</condition><then>
    <expr_stmt><expr><name>include_merged_revisions</name> = <name>FALSE</name></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name>include_merged_revisions</name> = (<name>svn_boolean_t</name>) <name>include_merged_revs_param</name></expr>;</expr_stmt></else></if>

  <if>if <condition>(<expr><name>revprop_word</name> == <name>NULL</name></expr>)</condition><then>
    <comment type="block">/* pre-1.5 client */</comment>
    <expr_stmt><expr><name>revprops</name> = <call><name>svn_compat_log_revprops_in</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>revprop_word</name></expr></argument>, <argument><expr>"all-revprops"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
    <expr_stmt><expr><name>revprops</name> = <name>NULL</name></expr>;</expr_stmt></then>
  <else>else <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>revprop_word</name></expr></argument>, <argument><expr>"revprops"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>revprops</name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>revprop_items</name>-&gt;<name>nelts</name></name></expr></argument>,
                                <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>char</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>revprop_items</name></expr>)</condition><then>
        <block>{
          <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>revprop_items</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
            <block>{
              <expr_stmt><expr><name>elt</name> = &amp;<call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>revprop_items</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>svn_ra_svn_item_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <if>if <condition>(<expr><name><name>elt</name>-&gt;<name>kind</name></name> != <name>SVN_RA_SVN_STRING</name></expr>)</condition><then>
                <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_RA_SVN_MALFORMED_DATA</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                        <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Log revprop entry not a string"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
              <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>revprops</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call> = <name><name>elt</name>-&gt;<name>u</name>.<name>string</name>-&gt;<name>data</name></name></expr>;</expr_stmt>
            }</block></for>
        }</block></then></if>
    }</block></then>
  <else>else
    <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_RA_SVN_MALFORMED_DATA</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Unknown revprop word '%s' in log command"</expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><name>revprop_word</name></expr></argument>)</argument_list></call></expr>;</return></else></if></else></if></else></if>

  <comment type="block">/* If we got an unspecified number then the user didn't send us anything,
     so we assume no limit.  If it's larger than INT_MAX then someone is
     messing with us, since we know the svn client libraries will never send
     us anything that big, so play it safe and default to no limit. */</comment>
  <if>if <condition>(<expr><name>limit</name> == <name>SVN_RA_SVN_UNSPECIFIED_NUMBER</name> || <name>limit</name> &gt; <name>INT_MAX</name></expr>)</condition><then>
    <expr_stmt><expr><name>limit</name> = 0</expr>;</expr_stmt></then></if>

  <expr_stmt><expr><name>full_paths</name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>paths</name>-&gt;<name>nelts</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>const <name>char</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>paths</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <expr_stmt><expr><name>elt</name> = &amp;<call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>paths</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>svn_ra_svn_item_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name><name>elt</name>-&gt;<name>kind</name></name> != <name>SVN_RA_SVN_STRING</name></expr>)</condition><then>
        <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_RA_SVN_MALFORMED_DATA</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Log path entry not a string"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
      <expr_stmt><expr><name>full_path</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>fs_path</name>-&gt;<name>data</name></name></expr></argument>,
                                <argument><expr><call><name>svn_path_canonicalize</name><argument_list>(<argument><expr><name><name>elt</name>-&gt;<name>u</name>.<name>string</name>-&gt;<name>data</name></name></expr></argument>,
                                                      <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>full_paths</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call> = <name>full_path</name></expr>;</expr_stmt>
    }</block></for>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>trivial_auth_request</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Get logs.  (Can't report errors back to the client at this point.) */</comment>
  <expr_stmt><expr><name><name>lb</name>.<name>fs_path</name></name> = <name><name>b</name>-&gt;<name>fs_path</name>-&gt;<name>data</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>lb</name>.<name>conn</name></name> = <name>conn</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>lb</name>.<name>stack_depth</name></name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>err</name> = <call><name>svn_repos_get_logs4</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>repos</name></name></expr></argument>, <argument><expr><name>full_paths</name></expr></argument>, <argument><expr><name>start_rev</name></expr></argument>, <argument><expr><name>end_rev</name></expr></argument>,
                            <argument><expr>(<name>int</name>) <name>limit</name></expr></argument>, <argument><expr><name>changed_paths</name></expr></argument>, <argument><expr><name>strict_node</name></expr></argument>,
                            <argument><expr><name>include_merged_revisions</name></expr></argument>, <argument><expr><name>revprops</name></expr></argument>,
                            <argument><expr><call><name>authz_check_access_cb_func</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>log_receiver</name></expr></argument>,
                            <argument><expr>&amp;<name>lb</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>write_err</name> = <call><name>svn_ra_svn_write_word</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"done"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>write_err</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>write_err</name></expr>;</return>
    }</block></then></if>
  <expr_stmt><expr><call><name>SVN_CMD_ERR</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_write_cmd_response</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type><name>check_path</name><parameter_list>(<param><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                               <param><decl><type><name>apr_array_header_t</name> *</type><name>params</name></decl></param>, <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>server_baton_t</name> *</type><name>b</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>, *<decl><type ref="prev"/><name>full_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_parse_tuple</name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"c(?r)"</expr></argument>, <argument><expr>&amp;<name>path</name></expr></argument>, <argument><expr>&amp;<name>rev</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>full_path</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>fs_path</name>-&gt;<name>data</name></name></expr></argument>,
                            <argument><expr><call><name>svn_path_canonicalize</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check authorizations */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>must_have_access</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>svn_authz_read</name></expr></argument>,
                           <argument><expr><name>full_path</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr>!<call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name>rev</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_CMD_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_youngest_rev</name><argument_list>(<argument><expr>&amp;<name>rev</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <expr_stmt><expr><call><name>SVN_CMD_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_revision_root</name><argument_list>(<argument><expr>&amp;<name>root</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_CMD_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_check_path</name><argument_list>(<argument><expr>&amp;<name>kind</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>full_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_write_cmd_response</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"w"</expr></argument>, <argument><expr><call><name>kind_word</name><argument_list>(<argument><expr><name>kind</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type><name>stat</name><parameter_list>(<param><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                         <param><decl><type><name>apr_array_header_t</name> *</type><name>params</name></decl></param>, <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>server_baton_t</name> *</type><name>b</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>, *<decl><type ref="prev"/><name>full_path</name></decl>, *<decl><type ref="prev"/><name>cdate</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_dirent_t</name> *</type><name>dirent</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_parse_tuple</name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"c(?r)"</expr></argument>, <argument><expr>&amp;<name>path</name></expr></argument>, <argument><expr>&amp;<name>rev</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>full_path</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>fs_path</name>-&gt;<name>data</name></name></expr></argument>,
                            <argument><expr><call><name>svn_path_canonicalize</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check authorizations */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>must_have_access</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>svn_authz_read</name></expr></argument>,
                           <argument><expr><name>full_path</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr>!<call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name>rev</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_CMD_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_youngest_rev</name><argument_list>(<argument><expr>&amp;<name>rev</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <expr_stmt><expr><call><name>SVN_CMD_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_revision_root</name><argument_list>(<argument><expr>&amp;<name>root</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_CMD_ERR</name><argument_list>(<argument><expr><call><name>svn_repos_stat</name><argument_list>(<argument><expr>&amp;<name>dirent</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>full_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Need to return the equivalent of "(?l)", since that's what the
     client is reading.  */</comment>

  <if>if <condition>(<expr><name>dirent</name> == <name>NULL</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_write_cmd_response</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"()"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>

  <expr_stmt><expr><name>cdate</name> = (<name><name>dirent</name>-&gt;<name>time</name></name> == (<name>time_t</name>) -1) ? <name>NULL</name>
    : <call><name>svn_time_to_cstring</name><argument_list>(<argument><expr><name><name>dirent</name>-&gt;<name>time</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_write_cmd_response</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"((wnbr(?c)(?c)))"</expr></argument>,
                                        <argument><expr><call><name>kind_word</name><argument_list>(<argument><expr><name><name>dirent</name>-&gt;<name>kind</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                        <argument><expr>(<name>apr_uint64_t</name>) <name><name>dirent</name>-&gt;<name>size</name></name></expr></argument>,
                                        <argument><expr><name><name>dirent</name>-&gt;<name>has_props</name></name></expr></argument>, <argument><expr><name><name>dirent</name>-&gt;<name>created_rev</name></name></expr></argument>,
                                        <argument><expr><name>cdate</name></expr></argument>, <argument><expr><name><name>dirent</name>-&gt;<name>last_author</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type><name>get_locations</name><parameter_list>(<param><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                                  <param><decl><type><name>apr_array_header_t</name> *</type><name>params</name></decl></param>, <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>, *<decl><type ref="prev"/><name>write_err</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>server_baton_t</name> *</type><name>b</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>revision</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>location_revisions</name></decl>, *<decl><type ref="prev"/><name>loc_revs_proto</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_ra_svn_item_t</name> *</type><name>elt</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>relative_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>peg_revision</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>fs_locations</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>iter</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>abs_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>iter_key</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> *</type><name>iter_value</name></decl>;</decl_stmt>

  <comment type="block">/* Parse the arguments. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_parse_tuple</name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"crl"</expr></argument>, <argument><expr>&amp;<name>relative_path</name></expr></argument>,
                                 <argument><expr>&amp;<name>peg_revision</name></expr></argument>,
                                 <argument><expr>&amp;<name>loc_revs_proto</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>relative_path</name> = <call><name>svn_path_canonicalize</name><argument_list>(<argument><expr><name>relative_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>abs_path</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>fs_path</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name>relative_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>location_revisions</name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>loc_revs_proto</name>-&gt;<name>nelts</name></name></expr></argument>,
                                      <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>svn_revnum_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>loc_revs_proto</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <expr_stmt><expr><name>elt</name> = &amp;<call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>loc_revs_proto</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>svn_ra_svn_item_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name><name>elt</name>-&gt;<name>kind</name></name> != <name>SVN_RA_SVN_NUMBER</name></expr>)</condition><then>
        <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_RA_SVN_MALFORMED_DATA</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                <argument><expr>"Get-locations location revisions entry "
                                "not a revision number"</expr></argument>)</argument_list></call></expr>;</return></then></if>
      <expr_stmt><expr><name>revision</name> = <call>(<name>svn_revnum_t</name>)<argument_list>(<argument><expr><name><name>elt</name>-&gt;<name>u</name>.<name>number</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>location_revisions</name></expr></argument>, <argument><expr><name>svn_revnum_t</name></expr></argument>)</argument_list></call> = <name>revision</name></expr>;</expr_stmt>
    }</block></for>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>trivial_auth_request</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* All the parameters are fine - let's perform the query against the
   * repository. */</comment>

  <comment type="block">/* We store both err and write_err here, so the client will get
   * the "done" even if there was an error in fetching the results. */</comment>

  <expr_stmt><expr><name>err</name> = <call><name>svn_repos_trace_node_locations</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr>&amp;<name>fs_locations</name></expr></argument>, <argument><expr><name>abs_path</name></expr></argument>,
                                       <argument><expr><name>peg_revision</name></expr></argument>, <argument><expr><name>location_revisions</name></expr></argument>,
                                       <argument><expr><call><name>authz_check_access_cb_func</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Now, write the results to the connection. */</comment>
  <if>if <condition>(<expr>!<name>err</name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr><name>fs_locations</name></expr>)</condition><then>
        <block>{
          <for>for (<init><expr><name>iter</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>fs_locations</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>iter</name></expr>;</condition>
              <incr><expr><name>iter</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr></incr>)
            <block>{
              <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>iter</name></expr></argument>, <argument><expr>&amp;<name>iter_key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>iter_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_write_tuple</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"rc"</expr></argument>,
                                             <argument><expr>*(const <name>svn_revnum_t</name> *)<name>iter_key</name></expr></argument>,
                                             <argument><expr>(const <name>char</name> *)<name>iter_value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
        }</block></then></if>
    }</block></then></if>

  <expr_stmt><expr><name>write_err</name> = <call><name>svn_ra_svn_write_word</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"done"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>write_err</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>write_err</name></expr>;</return>
    }</block></then></if>
  <expr_stmt><expr><call><name>SVN_CMD_ERR</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_write_cmd_response</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type><name>gls_receiver</name><parameter_list>(<param><decl><type><name>svn_location_segment_t</name> *</type><name>segment</name></decl></param>,
                                 <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>,
                                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name>svn_ra_svn_write_tuple</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"rr(?c)"</expr></argument>,
                                <argument><expr><name><name>segment</name>-&gt;<name>range_start</name></name></expr></argument>,
                                <argument><expr><name><name>segment</name>-&gt;<name>range_end</name></name></expr></argument>,
                                <argument><expr><name><name>segment</name>-&gt;<name>path</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type><name>get_location_segments</name><parameter_list>(<param><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name></decl></param>,
                                          <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                                          <param><decl><type><name>apr_array_header_t</name> *</type><name>params</name></decl></param>,
                                          <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>, *<decl><type ref="prev"/><name>write_err</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>server_baton_t</name> *</type><name>b</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>peg_revision</name></decl>, <decl><type ref="prev"/><name>start_rev</name></decl>, <decl><type ref="prev"/><name>end_rev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>relative_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>abs_path</name></decl>;</decl_stmt>

  <comment type="block">/* Parse the arguments. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_parse_tuple</name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"c(?r)(?r)(?r)"</expr></argument>,
                                 <argument><expr>&amp;<name>relative_path</name></expr></argument>, <argument><expr>&amp;<name>peg_revision</name></expr></argument>,
                                 <argument><expr>&amp;<name>start_rev</name></expr></argument>, <argument><expr>&amp;<name>end_rev</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>relative_path</name> = <call><name>svn_path_canonicalize</name><argument_list>(<argument><expr><name>relative_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>abs_path</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>fs_path</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name>relative_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name>start_rev</name></expr></argument>)</argument_list></call>
      &amp;&amp; <call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name>end_rev</name></expr></argument>)</argument_list></call>
      &amp;&amp; (<name>end_rev</name> &gt; <name>start_rev</name>)</expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_INCORRECT_PARAMS</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr>"Get-location-segments end revision must not be "
                             "younger than start revision"</expr></argument>)</argument_list></call></expr>;</return></then></if>

  <if>if <condition>(<expr><call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name>peg_revision</name></expr></argument>)</argument_list></call>
      &amp;&amp; <call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name>start_rev</name></expr></argument>)</argument_list></call>
      &amp;&amp; (<name>start_rev</name> &gt; <name>peg_revision</name>)</expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_INCORRECT_PARAMS</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr>"Get-location-segments start revision must not "
                             "be younger than peg revision"</expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>trivial_auth_request</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* All the parameters are fine - let's perform the query against the
   * repository. */</comment>

  <comment type="block">/* We store both err and write_err here, so the client will get
   * the "done" even if there was an error in fetching the results. */</comment>

  <expr_stmt><expr><name>err</name> = <call><name>svn_repos_node_location_segments</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>repos</name></name></expr></argument>, <argument><expr><name>abs_path</name></expr></argument>,
                                         <argument><expr><name>peg_revision</name></expr></argument>, <argument><expr><name>start_rev</name></expr></argument>, <argument><expr><name>end_rev</name></expr></argument>,
                                         <argument><expr><name>gls_receiver</name></expr></argument>, <argument><expr>(<name>void</name> *)<name>conn</name></expr></argument>,
                                         <argument><expr><call><name>authz_check_access_cb_func</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>b</name></expr></argument>,
                                         <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>write_err</name> = <call><name>svn_ra_svn_write_word</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"done"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>write_err</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>write_err</name></expr>;</return>
    }</block></then></if>
  <expr_stmt><expr><call><name>SVN_CMD_ERR</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_write_cmd_response</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* This implements svn_write_fn_t.  Write LEN bytes starting at DATA to the
   client as a string. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type><name>svndiff_handler</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name></decl></param>,
                                    <param><decl><type><name>apr_size_t</name> *</type><name>len</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>file_revs_baton_t</name> *</type><name>b</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_string_t</name></type> <name>str</name></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>str</name>.<name>data</name></name> = <name>data</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>str</name>.<name>len</name></name> = *<name>len</name></expr>;</expr_stmt>
  <return>return <expr><call><name>svn_ra_svn_write_string</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>conn</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>&amp;<name>str</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* This implements svn_close_fn_t.  Mark the end of the data by writing an
   empty string to the client. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type><name>svndiff_close_handler</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>file_revs_baton_t</name> *</type><name>b</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_write_cstring</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>conn</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* This implements the svn_repos_file_rev_handler_t interface. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type><name>file_rev_handler</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                                     <param><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl></param>, <param><decl><type><name>apr_hash_t</name> *</type><name>rev_props</name></decl></param>,
                                     <param><decl><type><name>svn_boolean_t</name></type> <name>merged_revision</name></decl></param>,
                                     <param><decl><type><name>svn_txdelta_window_handler_t</name> *</type><name>d_handler</name></decl></param>,
                                     <param><decl><type><name>void</name> **</type><name>d_baton</name></decl></param>,
                                     <param><decl><type><name>apr_array_header_t</name> *</type><name>prop_diffs</name></decl></param>,
                                     <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>file_revs_baton_t</name> *</type><name>frb</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>stream</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_write_tuple</name><argument_list>(<argument><expr><name><name>frb</name>-&gt;<name>conn</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"cr(!"</expr></argument>,
                                 <argument><expr><name>path</name></expr></argument>, <argument><expr><name>rev</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_write_proplist</name><argument_list>(<argument><expr><name><name>frb</name>-&gt;<name>conn</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>rev_props</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_write_tuple</name><argument_list>(<argument><expr><name><name>frb</name>-&gt;<name>conn</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"!)(!"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>write_prop_diffs</name><argument_list>(<argument><expr><name><name>frb</name>-&gt;<name>conn</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>prop_diffs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_write_tuple</name><argument_list>(<argument><expr><name><name>frb</name>-&gt;<name>conn</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"!)b"</expr></argument>, <argument><expr><name>merged_revision</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Store the pool for the delta stream. */</comment>
  <expr_stmt><expr><name><name>frb</name>-&gt;<name>pool</name></name> = <name>pool</name></expr>;</expr_stmt>

  <comment type="block">/* Prepare for the delta or just write an empty string. */</comment>
  <if>if <condition>(<expr><name>d_handler</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>stream</name> = <call><name>svn_stream_create</name><argument_list>(<argument><expr><name>baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>svn_stream_set_write</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><name>svndiff_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>svn_stream_set_close</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><name>svndiff_close_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr><call><name>svn_ra_svn_has_capability</name><argument_list>(<argument><expr><name><name>frb</name>-&gt;<name>conn</name></name></expr></argument>, <argument><expr><name>SVN_RA_SVN_CAP_SVNDIFF1</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>svn_txdelta_to_svndiff2</name><argument_list>(<argument><expr><name>d_handler</name></expr></argument>, <argument><expr><name>d_baton</name></expr></argument>, <argument><expr><name>stream</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
      <else>else
        <expr_stmt><expr><call><name>svn_txdelta_to_svndiff2</name><argument_list>(<argument><expr><name>d_handler</name></expr></argument>, <argument><expr><name>d_baton</name></expr></argument>, <argument><expr><name>stream</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
    }</block></then>
  <else>else
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_write_cstring</name><argument_list>(<argument><expr><name><name>frb</name>-&gt;<name>conn</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type><name>get_file_revs</name><parameter_list>(<param><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                                  <param><decl><type><name>apr_array_header_t</name> *</type><name>params</name></decl></param>, <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>server_baton_t</name> *</type><name>b</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>, *<decl><type ref="prev"/><name>write_err</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>file_revs_baton_t</name></type> <name>frb</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>start_rev</name></decl>, <decl><type ref="prev"/><name>end_rev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>full_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_uint64_t</name></type> <name>include_merged_revs_param</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>include_merged_revisions</name></decl>;</decl_stmt>

  <comment type="block">/* Parse arguments. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_parse_tuple</name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"c(?r)(?r)?B"</expr></argument>,
                                 <argument><expr>&amp;<name>path</name></expr></argument>, <argument><expr>&amp;<name>start_rev</name></expr></argument>, <argument><expr>&amp;<name>end_rev</name></expr></argument>,
                                 <argument><expr>&amp;<name>include_merged_revs_param</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>path</name> = <call><name>svn_path_canonicalize</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>trivial_auth_request</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>full_path</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>fs_path</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>include_merged_revs_param</name> == <name>SVN_RA_SVN_UNSPECIFIED_NUMBER</name></expr>)</condition><then>
    <expr_stmt><expr><name>include_merged_revisions</name> = <name>FALSE</name></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name>include_merged_revisions</name> = (<name>svn_boolean_t</name>) <name>include_merged_revs_param</name></expr>;</expr_stmt></else></if>

  <expr_stmt><expr><name><name>frb</name>.<name>conn</name></name> = <name>conn</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>frb</name>.<name>pool</name></name> = <name>NULL</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>err</name> = <call><name>svn_repos_get_file_revs2</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>repos</name></name></expr></argument>, <argument><expr><name>full_path</name></expr></argument>, <argument><expr><name>start_rev</name></expr></argument>, <argument><expr><name>end_rev</name></expr></argument>,
                                 <argument><expr><name>include_merged_revisions</name></expr></argument>,
                                 <argument><expr><call><name>authz_check_access_cb_func</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>b</name></expr></argument>,
                                 <argument><expr><name>file_rev_handler</name></expr></argument>, <argument><expr>&amp;<name>frb</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>write_err</name> = <call><name>svn_ra_svn_write_word</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"done"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>write_err</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>write_err</name></expr>;</return>
    }</block></then></if>
  <expr_stmt><expr><call><name>SVN_CMD_ERR</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_write_cmd_response</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type><name>lock</name><parameter_list>(<param><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                         <param><decl><type><name>apr_array_header_t</name> *</type><name>params</name></decl></param>, <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>server_baton_t</name> *</type><name>b</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>comment</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>full_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>steal_lock</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>current_rev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_lock_t</name> *</type><name>l</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_parse_tuple</name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"c(?c)b(?r)"</expr></argument>, <argument><expr>&amp;<name>path</name></expr></argument>, <argument><expr>&amp;<name>comment</name></expr></argument>,
                                 <argument><expr>&amp;<name>steal_lock</name></expr></argument>, <argument><expr>&amp;<name>current_rev</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>full_path</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>fs_path</name>-&gt;<name>data</name></name></expr></argument>,
                            <argument><expr><call><name>svn_path_canonicalize</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>must_have_access</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>svn_authz_write</name></expr></argument>,
                           <argument><expr><name>full_path</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_CMD_ERR</name><argument_list>(<argument><expr><call><name>svn_repos_fs_lock</name><argument_list>(<argument><expr>&amp;<name>l</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>repos</name></name></expr></argument>, <argument><expr><name>full_path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>comment</name></expr></argument>, <argument><expr>0</expr></argument>,
                                <argument><expr>0</expr></argument>, <comment type="block">/* No expiration time. */</comment>
                                <argument><expr><name>current_rev</name></expr></argument>, <argument><expr><name>steal_lock</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_write_tuple</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"w(!"</expr></argument>, <argument><expr>"success"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>write_lock</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_write_tuple</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"!)"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type><name>lock_many</name><parameter_list>(<param><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                              <param><decl><type><name>apr_array_header_t</name> *</type><name>params</name></decl></param>, <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>server_baton_t</name> *</type><name>b</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>path_revs</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>comment</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>steal_lock</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>full_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>current_rev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_lock_t</name> *</type><name>l</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name> <init>= <expr><name>SVN_NO_ERROR</name></expr></init>, *<name>write_err</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_parse_tuple</name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"(?c)bl"</expr></argument>, <argument><expr>&amp;<name>comment</name></expr></argument>, <argument><expr>&amp;<name>steal_lock</name></expr></argument>,
                                 <argument><expr>&amp;<name>path_revs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>subpool</name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Because we can only send a single auth reply per request, we send
     a reply before parsing the lock commands.  This means an authz
     access denial will abort the processing of the locks and return
     an error. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>must_have_access</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>svn_authz_write</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Loop through the lock requests. */</comment>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>path_revs</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>)
    <block>{
      <decl_stmt><decl><type><name>svn_ra_svn_item_t</name> *</type><name>item</name> <init>= <expr>&amp;<call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>path_revs</name></expr></argument>, <argument><expr><name>i</name></expr></argument>,
                                               <argument><expr><name>svn_ra_svn_item_t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr><name><name>item</name>-&gt;<name>kind</name></name> != <name>SVN_RA_SVN_LIST</name></expr>)</condition><then>
        <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_RA_SVN_MALFORMED_DATA</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                <argument><expr>"Lock requests should be list of lists"</expr></argument>)</argument_list></call></expr>;</return></then></if>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_parse_tuple</name><argument_list>(<argument><expr><name><name>item</name>-&gt;<name>u</name>.<name>list</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"c(?r)"</expr></argument>, <argument><expr>&amp;<name>path</name></expr></argument>,
                                     <argument><expr>&amp;<name>current_rev</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>full_path</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>fs_path</name>-&gt;<name>data</name></name></expr></argument>,
                                <argument><expr><call><name>svn_path_canonicalize</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr>! <call><name>lookup_access</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>svn_authz_write</name></expr></argument>, <argument><expr><name>full_path</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>err</name> = <call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_RA_NOT_AUTHORIZED</name></expr></argument>,
                                 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>
        }</block></then></if>

      <expr_stmt><expr><name>err</name> = <call><name>svn_repos_fs_lock</name><argument_list>(<argument><expr>&amp;<name>l</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>repos</name></name></expr></argument>, <argument><expr><name>full_path</name></expr></argument>,
                              <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>comment</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                              <argument><expr>0</expr></argument>, <comment type="block">/* No expiration time. */</comment>
                              <argument><expr><name>current_rev</name></expr></argument>,
                              <argument><expr><name>steal_lock</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
        <block>{
          <if>if <condition>(<expr><call><name>SVN_ERR_IS_LOCK_ERROR</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <block>{
              <expr_stmt><expr><name>write_err</name> = <call><name>svn_ra_svn_write_cmd_failure</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>err</name> = <name>NULL</name></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><name>write_err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
          <else>else
            <break>break;</break></else></if>
        }</block></then>
      <else>else
        <block>{
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_write_tuple</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>, <argument><expr>"w!"</expr></argument>, <argument><expr>"success"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>write_lock</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_write_tuple</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>, <argument><expr>"!"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></for>

  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE: err might contain a fatal locking error from the loop above. */</comment>
  <expr_stmt><expr><name>write_err</name> = <call><name>svn_ra_svn_write_word</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"done"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<name>write_err</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_CMD_ERR</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><name>write_err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_write_cmd_response</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type><name>unlock</name><parameter_list>(<param><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                           <param><decl><type><name>apr_array_header_t</name> *</type><name>params</name></decl></param>, <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>server_baton_t</name> *</type><name>b</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>, *<decl><type ref="prev"/><name>token</name></decl>, *<decl><type ref="prev"/><name>full_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>break_lock</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_parse_tuple</name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"c(?c)b"</expr></argument>, <argument><expr>&amp;<name>path</name></expr></argument>, <argument><expr>&amp;<name>token</name></expr></argument>,
                                 <argument><expr>&amp;<name>break_lock</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>full_path</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>fs_path</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><call><name>svn_path_canonicalize</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Username required unless break_lock was specified. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>must_have_access</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>svn_authz_write</name></expr></argument>,
                           <argument><expr><name>full_path</name></expr></argument>, <argument><expr>! <name>break_lock</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_CMD_ERR</name><argument_list>(<argument><expr><call><name>svn_repos_fs_unlock</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>repos</name></name></expr></argument>, <argument><expr><name>full_path</name></expr></argument>, <argument><expr><name>token</name></expr></argument>, <argument><expr><name>break_lock</name></expr></argument>,
                                  <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_write_cmd_response</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type><name>unlock_many</name><parameter_list>(<param><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                                <param><decl><type><name>apr_array_header_t</name> *</type><name>params</name></decl></param>, <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>server_baton_t</name> *</type><name>b</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>break_lock</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>unlock_tokens</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>full_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>token</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name> <init>= <expr><name>SVN_NO_ERROR</name></expr></init>, *<name>write_err</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_parse_tuple</name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"bl"</expr></argument>, <argument><expr>&amp;<name>break_lock</name></expr></argument>,
                                 <argument><expr>&amp;<name>unlock_tokens</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Username required unless break_lock was specified. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>must_have_access</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>svn_authz_write</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>! <name>break_lock</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>subpool</name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Loop through the unlock requests. */</comment>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>unlock_tokens</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <decl_stmt><decl><type><name>svn_ra_svn_item_t</name> *</type><name>item</name> <init>= <expr>&amp;<call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>unlock_tokens</name></expr></argument>, <argument><expr><name>i</name></expr></argument>,
                                               <argument><expr><name>svn_ra_svn_item_t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr><name><name>item</name>-&gt;<name>kind</name></name> != <name>SVN_RA_SVN_LIST</name></expr>)</condition><then>
        <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_RA_SVN_MALFORMED_DATA</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                <argument><expr>"Unlock request should be a list of lists"</expr></argument>)</argument_list></call></expr>;</return></then></if>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_parse_tuple</name><argument_list>(<argument><expr><name><name>item</name>-&gt;<name>u</name>.<name>list</name></name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>, <argument><expr>"c(?c)"</expr></argument>, <argument><expr>&amp;<name>path</name></expr></argument>,
                                     <argument><expr>&amp;<name>token</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>full_path</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>fs_path</name>-&gt;<name>data</name></name></expr></argument>,
                                <argument><expr><call><name>svn_path_canonicalize</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr>! <call><name>lookup_access</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>svn_authz_write</name></expr></argument>, <argument><expr><name>full_path</name></expr></argument>,
                          <argument><expr>! <name>break_lock</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_RA_SVN_CMD_ERR</name></expr></argument>,
                                <argument><expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_RA_NOT_AUTHORIZED</name></expr></argument>,
                                                 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

      <expr_stmt><expr><name>err</name> = <call><name>svn_repos_fs_unlock</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>repos</name></name></expr></argument>, <argument><expr><name>full_path</name></expr></argument>, <argument><expr><name>token</name></expr></argument>, <argument><expr><name>break_lock</name></expr></argument>,
                                <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
        <block>{
          <if>if <condition>(<expr><call><name>SVN_ERR_IS_UNLOCK_ERROR</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <block>{
              <expr_stmt><expr><name>write_err</name> = <call><name>svn_ra_svn_write_cmd_failure</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>err</name> = <name>NULL</name></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><name>write_err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
          <else>else
            <break>break;</break></else></if>
        }</block></then>
      <else>else
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_write_tuple</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>, <argument><expr>"w(c)"</expr></argument>, <argument><expr>"success"</expr></argument>,
                                       <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
    }</block></for>

  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* NOTE: err might contain a fatal unlocking error from the loop above. */</comment>
  <expr_stmt><expr><name>write_err</name> = <call><name>svn_ra_svn_write_word</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"done"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>! <name>write_err</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_CMD_ERR</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_write_cmd_response</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type><name>get_lock</name><parameter_list>(<param><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                             <param><decl><type><name>apr_array_header_t</name> *</type><name>params</name></decl></param>, <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>server_baton_t</name> *</type><name>b</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>full_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_lock_t</name> *</type><name>l</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_parse_tuple</name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"c"</expr></argument>, <argument><expr>&amp;<name>path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>full_path</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>fs_path</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><call><name>svn_path_canonicalize</name><argument_list>(<argument><expr><name>path</name></expr></argument>,
                                                                    <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>must_have_access</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>svn_authz_read</name></expr></argument>,
                           <argument><expr><name>full_path</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_CMD_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_get_lock</name><argument_list>(<argument><expr>&amp;<name>l</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>full_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_write_tuple</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"w((!"</expr></argument>, <argument><expr>"success"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>l</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>write_lock</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_write_tuple</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"!))"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type><name>get_locks</name><parameter_list>(<param><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                              <param><decl><type><name>apr_array_header_t</name> *</type><name>params</name></decl></param>, <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>server_baton_t</name> *</type><name>b</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>full_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>locks</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_lock_t</name> *</type><name>l</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_parse_tuple</name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"c"</expr></argument>, <argument><expr>&amp;<name>path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>full_path</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>fs_path</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><call><name>svn_path_canonicalize</name><argument_list>(<argument><expr><name>path</name></expr></argument>,
                                                                    <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>trivial_auth_request</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_CMD_ERR</name><argument_list>(<argument><expr><call><name>svn_repos_fs_get_locks</name><argument_list>(<argument><expr>&amp;<name>locks</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>repos</name></name></expr></argument>, <argument><expr><name>full_path</name></expr></argument>,
                                     <argument><expr><call><name>authz_check_access_cb_func</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_write_tuple</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"w((!"</expr></argument>, <argument><expr>"success"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>locks</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>hi</name></expr>;</condition> <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
    <block>{
      <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>l</name> = <name>val</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>write_lock</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_write_tuple</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"!))"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type><name>replay_one_revision</name><parameter_list>(<param><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name></decl></param>,
                                        <param><decl><type><name>server_baton_t</name> *</type><name>b</name></decl></param>,
                                        <param><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl></param>,
                                        <param><decl><type><name>svn_revnum_t</name></type> <name>low_water_mark</name></decl></param>, 
                                        <param><decl><type><name>svn_boolean_t</name></type> <name>send_deltas</name></decl></param>,
                                        <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_delta_editor_t</name> *</type><name>editor</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> *</type><name>edit_baton</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>svn_ra_svn_get_editor</name><argument_list>(<argument><expr>&amp;<name>editor</name></expr></argument>, <argument><expr>&amp;<name>edit_baton</name></expr></argument>, <argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>err</name> = <call><name>svn_fs_revision_root</name><argument_list>(<argument><expr>&amp;<name>root</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr>! <name>err</name></expr>)</condition><then>
    <expr_stmt><expr><name>err</name> = <call><name>svn_repos_replay2</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>fs_path</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name>low_water_mark</name></expr></argument>,
                            <argument><expr><name>send_deltas</name></expr></argument>, <argument><expr><name>editor</name></expr></argument>, <argument><expr><name>edit_baton</name></expr></argument>,
                            <argument><expr><call><name>authz_check_access_cb_func</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><call><name><name>editor</name>-&gt;<name>abort_edit</name></name><argument_list>(<argument><expr><name>edit_baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <expr_stmt><expr><call><name>SVN_CMD_ERR</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><call><name>svn_ra_svn_write_cmd</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"finish-replay"</expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type><name>replay</name><parameter_list>(<param><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                           <param><decl><type><name>apr_array_header_t</name> *</type><name>params</name></decl></param>, <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl>, <decl><type ref="prev"/><name>low_water_mark</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>send_deltas</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>server_baton_t</name> *</type><name>b</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_parse_tuple</name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"rrb"</expr></argument>, <argument><expr>&amp;<name>rev</name></expr></argument>, <argument><expr>&amp;<name>low_water_mark</name></expr></argument>,
                                 <argument><expr>&amp;<name>send_deltas</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>trivial_auth_request</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>replay_one_revision</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name>low_water_mark</name></expr></argument>,
                              <argument><expr><name>send_deltas</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_write_cmd_response</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type><name>replay_range</name><parameter_list>(<param><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                                 <param><decl><type><name>apr_array_header_t</name> *</type><name>params</name></decl></param>, <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>start_rev</name></decl>, <decl><type ref="prev"/><name>end_rev</name></decl>, <decl><type ref="prev"/><name>rev</name></decl>, <decl><type ref="prev"/><name>low_water_mark</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>send_deltas</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>server_baton_t</name> *</type><name>b</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>iterpool</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_parse_tuple</name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"rrrb"</expr></argument>, <argument><expr>&amp;<name>start_rev</name></expr></argument>,
                                 <argument><expr>&amp;<name>end_rev</name></expr></argument>, <argument><expr>&amp;<name>low_water_mark</name></expr></argument>,
                                 <argument><expr>&amp;<name>send_deltas</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>trivial_auth_request</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>iterpool</name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for (<init><expr><name>rev</name> = <name>start_rev</name></expr>;</init> <condition><expr><name>rev</name> &lt;= <name>end_rev</name></expr>;</condition> <incr><expr><name>rev</name>++</expr></incr>)
    <block>{
      <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>props</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>SVN_CMD_ERR</name><argument_list>(<argument><expr><call><name>svn_repos_fs_revision_proplist</name><argument_list>(<argument><expr>&amp;<name>props</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>repos</name></name></expr></argument>, <argument><expr><name>rev</name></expr></argument>,
                                                 <argument><expr><call><name>authz_check_access_cb_func</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>,
                                                 <argument><expr><name>b</name></expr></argument>,
                                                 <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_write_tuple</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>, <argument><expr>"w(!"</expr></argument>, <argument><expr>"revprops"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_write_proplist</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>, <argument><expr><name>props</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_write_tuple</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>, <argument><expr>"!)"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>replay_one_revision</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name>low_water_mark</name></expr></argument>,
                                  <argument><expr><name>send_deltas</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    }</block></for>
  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_write_cmd_response</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>svn_ra_svn_cmd_entry_t</name></type> <name><name>main_commands</name><index>[]</index></name> <init>= <expr><block>{
  <expr><block>{ <expr>"reparent"</expr>,        <expr><name>reparent</name></expr> }</block></expr>,
  <expr><block>{ <expr>"get-latest-rev"</expr>,  <expr><name>get_latest_rev</name></expr> }</block></expr>,
  <expr><block>{ <expr>"get-dated-rev"</expr>,   <expr><name>get_dated_rev</name></expr> }</block></expr>,
  <expr><block>{ <expr>"change-rev-prop"</expr>, <expr><name>change_rev_prop</name></expr> }</block></expr>,
  <expr><block>{ <expr>"rev-proplist"</expr>,    <expr><name>rev_proplist</name></expr> }</block></expr>,
  <expr><block>{ <expr>"rev-prop"</expr>,        <expr><name>rev_prop</name></expr> }</block></expr>,
  <expr><block>{ <expr>"commit"</expr>,          <expr><name>commit</name></expr> }</block></expr>,
  <expr><block>{ <expr>"get-file"</expr>,        <expr><name>get_file</name></expr> }</block></expr>,
  <expr><block>{ <expr>"get-dir"</expr>,         <expr><name>get_dir</name></expr> }</block></expr>,
  <expr><block>{ <expr>"update"</expr>,          <expr><name>update</name></expr> }</block></expr>,
  <expr><block>{ <expr>"switch"</expr>,          <expr><name>switch_cmd</name></expr> }</block></expr>,
  <expr><block>{ <expr>"status"</expr>,          <expr><name>status</name></expr> }</block></expr>,
  <expr><block>{ <expr>"diff"</expr>,            <expr><name>diff</name></expr> }</block></expr>,
  <expr><block>{ <expr>"get-mergeinfo"</expr>,   <expr><name>get_mergeinfo</name></expr> }</block></expr>,
  <expr><block>{ <expr>"log"</expr>,             <expr><name>log_cmd</name></expr> }</block></expr>,
  <expr><block>{ <expr>"check-path"</expr>,      <expr><name>check_path</name></expr> }</block></expr>,
  <expr><block>{ <expr>"stat"</expr>,            <expr><name>stat</name></expr> }</block></expr>,
  <expr><block>{ <expr>"get-locations"</expr>,   <expr><name>get_locations</name></expr> }</block></expr>,
  <expr><block>{ <expr>"get-location-segments"</expr>,   <expr><name>get_location_segments</name></expr> }</block></expr>,
  <expr><block>{ <expr>"get-file-revs"</expr>,   <expr><name>get_file_revs</name></expr> }</block></expr>,
  <expr><block>{ <expr>"lock"</expr>,            <expr><name>lock</name></expr> }</block></expr>,
  <expr><block>{ <expr>"lock-many"</expr>,       <expr><name>lock_many</name></expr> }</block></expr>,
  <expr><block>{ <expr>"unlock"</expr>,          <expr><name>unlock</name></expr> }</block></expr>,
  <expr><block>{ <expr>"unlock-many"</expr>,     <expr><name>unlock_many</name></expr> }</block></expr>,
  <expr><block>{ <expr>"get-lock"</expr>,        <expr><name>get_lock</name></expr> }</block></expr>,
  <expr><block>{ <expr>"get-locks"</expr>,       <expr><name>get_locks</name></expr> }</block></expr>,
  <expr><block>{ <expr>"replay"</expr>,          <expr><name>replay</name></expr> }</block></expr>,
  <expr><block>{ <expr>"replay-range"</expr>,    <expr><name>replay_range</name></expr> }</block></expr>,
  <expr><block>{ <expr><name>NULL</name></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Skip past the scheme part of a URL, including the tunnel specification
 * if present.  Return NULL if the scheme part is invalid for ra_svn. */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>skip_scheme_part</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>url</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>url</name></expr></argument>, <argument><expr>"svn"</expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
    <return>return <expr><name>NULL</name></expr>;</return></then></if>
  <expr_stmt><expr><name>url</name> += 3</expr>;</expr_stmt>
  <if>if <condition>(<expr>*<name>url</name> == '+'</expr>)</condition><then>
    <expr_stmt><expr><name>url</name> += <call><name>strcspn</name><argument_list>(<argument><expr><name>url</name></expr></argument>, <argument><expr>":"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>url</name></expr></argument>, <argument><expr>"://"</expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
    <return>return <expr><name>NULL</name></expr>;</return></then></if>
  <return>return <expr><name>url</name> + 3</expr>;</return>
}</block></function>

<comment type="block">/* Check that PATH is a valid repository path, meaning it doesn't contain any
   '..' path segments.
   NOTE: This is similar to svn_path_is_backpath_present, but that function
   assumes the path separator is '/'.  This function also checks for
   segments delimited by the local path separator. */</comment>
<function><type><specifier>static</specifier> <name>svn_boolean_t</name></type>
<name>repos_path_valid</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name> <init>= <expr><name>path</name></expr></init></decl>;</decl_stmt>

  <while>while <condition>(<expr>*<name>s</name></expr>)</condition>
    <block>{
      <comment type="block">/* Scan for the end of the segment. */</comment>
      <while>while <condition>(<expr>*<name>path</name> &amp;&amp; *<name>path</name> != '/' &amp;&amp; *<name>path</name> != <name>SVN_PATH_LOCAL_SEPARATOR</name></expr>)</condition>
        <expr_stmt><expr>++<name>path</name></expr>;</expr_stmt></while>

      <comment type="block">/* Check for '..'. */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
      <comment type="block">/* On Windows, don't allow sequences of more than one character
         consisting of just dots and spaces.  Win32 functions treat
         paths such as ".. " and "......." inconsistently.  Make sure
         no one can escape out of the root. */</comment>
      <if>if <condition>(<expr><name>path</name> - <name>s</name> &gt;= 2 &amp;&amp; <call><name>strspn</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr>". "</expr></argument>)</argument_list></call> == <name>path</name> - <name>s</name></expr>)</condition><then>
        <return>return <expr><name>FALSE</name></expr>;</return></then></if>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>  <comment type="block">/* ! WIN32 */</comment>
      <if>if <condition>(<expr><name>path</name> - <name>s</name> == 2 &amp;&amp; <name><name>s</name><index>[<expr>0</expr>]</index></name> == '.' &amp;&amp; <name><name>s</name><index>[<expr>1</expr>]</index></name> == '.'</expr>)</condition><then>
        <return>return <expr><name>FALSE</name></expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

      <comment type="block">/* Skip all separators. */</comment>
      <while>while <condition>(<expr>*<name>path</name> &amp;&amp; (*<name>path</name> == '/' || *<name>path</name> == <name>SVN_PATH_LOCAL_SEPARATOR</name>)</expr>)</condition>
        <expr_stmt><expr>++<name>path</name></expr>;</expr_stmt></while>
      <expr_stmt><expr><name>s</name> = <name>path</name></expr>;</expr_stmt>
    }</block></while>

  <return>return <expr><name>TRUE</name></expr>;</return>
}</block></function>

<comment type="block">/* Look for the repository given by URL, using ROOT as the virtual
 * repository root.  If we find one, fill in the repos, fs, cfg,
 * repos_url, and fs_path fields of B.  Set B-&gt;repos's client
 * capabilities to CAPABILITIES, which must be at least as long-lived
 * as POOL, and whose elements are SVN_RA_CAPABILITY_*.
 */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type><name>find_repos</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>url</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>root</name></decl></param>,
                               <param><decl><type><name>server_baton_t</name> *</type><name>b</name></decl></param>,
                               <param><decl><type><name>apr_array_header_t</name> *</type><name>capabilities</name></decl></param>,
                               <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>, *<decl><type ref="prev"/><name>full_path</name></decl>, *<decl><type ref="prev"/><name>repos_root</name></decl>, *<decl><type ref="prev"/><name>fs_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>url_buf</name></decl>;</decl_stmt>

  <comment type="block">/* Skip past the scheme and authority part. */</comment>
  <expr_stmt><expr><name>path</name> = <call><name>skip_scheme_part</name><argument_list>(<argument><expr><name>url</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>path</name> == <name>NULL</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_BAD_URL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr>"Non-svn URL passed to svn server: '%s'"</expr></argument>, <argument><expr><name>url</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
  <expr_stmt><expr><name>path</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>'/'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>path</name> = (<name>path</name> == <name>NULL</name>) ? "" : <name>path</name> + 1</expr>;</expr_stmt>

  <comment type="block">/* Decode URI escapes from the path. */</comment>
  <expr_stmt><expr><name>path</name> = <call><name>svn_path_uri_decode</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Ensure that it isn't possible to escape the root by skipping leading
     slashes and not allowing '..' segments. */</comment>
  <while>while <condition>(<expr>*<name>path</name> == '/'</expr>)</condition>
    <expr_stmt><expr>++<name>path</name></expr>;</expr_stmt></while>
  <if>if <condition>(<expr>!<call><name>repos_path_valid</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_BAD_FILENAME</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                            <argument><expr>"Couldn't determine repository path"</expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Join the server-configured root with the client path. */</comment>
  <expr_stmt><expr><name>full_path</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><call><name>svn_path_canonicalize</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><call><name>svn_path_canonicalize</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Search for a repository in the full path. */</comment>
  <expr_stmt><expr><name>repos_root</name> = <call><name>svn_repos_find_root_path</name><argument_list>(<argument><expr><name>full_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<name>repos_root</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_RA_SVN_REPOS_NOT_FOUND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr>"No repository found in '%s'"</expr></argument>, <argument><expr><name>url</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Open the repository and fill in b with the resulting information. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_repos_open</name><argument_list>(<argument><expr>&amp;<name><name>b</name>-&gt;<name>repos</name></name></expr></argument>, <argument><expr><name>repos_root</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_repos_remember_client_capabilities</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>repos</name></name></expr></argument>, <argument><expr><name>capabilities</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>b</name>-&gt;<name>fs</name></name> = <call><name>svn_repos_fs</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>repos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>fs_path</name> = <name>full_path</name> + <call><name>strlen</name><argument_list>(<argument><expr><name>repos_root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>b</name>-&gt;<name>fs_path</name></name> = <call><name>svn_stringbuf_create</name><argument_list>(<argument><expr>*<name>fs_path</name> ? <name>fs_path</name> : "/"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>url_buf</name> = <call><name>svn_stringbuf_create</name><argument_list>(<argument><expr><name>url</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_path_remove_components</name><argument_list>(<argument><expr><name>url_buf</name></expr></argument>,
                             <argument><expr><call><name>svn_path_component_count</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>fs_path</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>b</name>-&gt;<name>repos_url</name></name> = <name><name>url_buf</name>-&gt;<name>data</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>b</name>-&gt;<name>authz_repos_name</name></name> = <call><name>svn_path_is_child</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>repos_root</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If the svnserve configuration files have not been loaded then
     load them from the repository. */</comment>
  <if>if <condition>(<expr><name>NULL</name> == <name><name>b</name>-&gt;<name>cfg</name></name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>load_configs</name><argument_list>(<argument><expr>&amp;<name><name>b</name>-&gt;<name>cfg</name></name></expr></argument>, <argument><expr>&amp;<name><name>b</name>-&gt;<name>pwdb</name></name></expr></argument>, <argument><expr>&amp;<name><name>b</name>-&gt;<name>authzdb</name></name></expr></argument>,
                         <argument><expr><call><name>svn_repos_svnserve_conf</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>repos</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                         <argument><expr><call><name>svn_repos_conf_dir</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>repos</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                         <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SVN_HAVE_SASL</name></cpp:ifdef>
  <comment type="block">/* Should we use Cyrus SASL? */</comment>
  <expr_stmt><expr><call><name>svn_config_get_bool</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>cfg</name></name></expr></argument>, <argument><expr>&amp;<name><name>b</name>-&gt;<name>use_sasl</name></name></expr></argument>, <argument><expr><name>SVN_CONFIG_SECTION_SASL</name></expr></argument>,
                      <argument><expr><name>SVN_CONFIG_OPTION_USE_SASL</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Use the repository UUID as the default realm. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_get_uuid</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr>&amp;<name><name>b</name>-&gt;<name>realm</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_config_get</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>cfg</name></name></expr></argument>, <argument><expr>&amp;<name><name>b</name>-&gt;<name>realm</name></name></expr></argument>, <argument><expr><name>SVN_CONFIG_SECTION_GENERAL</name></expr></argument>,
                 <argument><expr><name>SVN_CONFIG_OPTION_REALM</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>realm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Make sure it's possible for the client to authenticate.  Note
     that this doesn't take into account any authz configuration read
     above, because we can't know about access it grants until paths
     are given by the client. */</comment>
  <if>if <condition>(<expr><call><name>get_access</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>UNAUTHENTICATED</name></expr></argument>)</argument_list></call> == <name>NO_ACCESS</name>
      &amp;&amp; (<call><name>get_access</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><name>AUTHENTICATED</name></expr></argument>)</argument_list></call> == <name>NO_ACCESS</name>
          || (!<name><name>b</name>-&gt;<name>tunnel_user</name></name> &amp;&amp; !<name><name>b</name>-&gt;<name>pwdb</name></name>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SVN_HAVE_SASL</name></cpp:ifdef>
              &amp;&amp; !<name><name>b</name>-&gt;<name>use_sasl</name></name>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
              ))</expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_RA_NOT_AUTHORIZED</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                            <argument><expr>"No access allowed to this repository"</expr></argument>)</argument_list></call></expr>;</return></then></if>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Compute the authentication name EXTERNAL should be able to get, if any. */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type><name>get_tunnel_user</name><parameter_list>(<param><decl><type><name>serve_params_t</name> *</type><name>params</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* Only offer EXTERNAL for connections tunneled over a login agent. */</comment>
  <if>if <condition>(<expr>!<name><name>params</name>-&gt;<name>tunnel</name></name></expr>)</condition><then>
    <return>return <expr><name>NULL</name></expr>;</return></then></if>

  <comment type="block">/* If a tunnel user was provided on the command line, use that. */</comment>
  <if>if <condition>(<expr><name><name>params</name>-&gt;<name>tunnel_user</name></name></expr>)</condition><then>
    <return>return <expr><name><name>params</name>-&gt;<name>tunnel_user</name></name></expr>;</return></then></if>

  <return>return <expr><call><name>svn_user_get_name</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type><name>serve</name><parameter_list>(<param><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name></decl></param>, <param><decl><type><name>serve_params_t</name> *</type><name>params</name></decl></param>,
                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>, *<decl><type ref="prev"/><name>io_err</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_uint64_t</name></type> <name>ver</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>uuid</name></decl>, *<decl><type ref="prev"/><name>client_url</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>caplist</name></decl>, *<decl><type ref="prev"/><name>cap_words</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>server_baton_t</name></type> <name>b</name></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>b</name>.<name>tunnel</name></name> = <name><name>params</name>-&gt;<name>tunnel</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>b</name>.<name>tunnel_user</name></name> = <call><name>get_tunnel_user</name><argument_list>(<argument><expr><name>params</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>b</name>.<name>read_only</name></name> = <name><name>params</name>-&gt;<name>read_only</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>b</name>.<name>user</name></name> = <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>b</name>.<name>cfg</name></name> = <name><name>params</name>-&gt;<name>cfg</name></name></expr>;</expr_stmt>   <comment type="block">/* Ugly; can drop when we remove v1 support. */</comment>
  <expr_stmt><expr><name><name>b</name>.<name>pwdb</name></name> = <name><name>params</name>-&gt;<name>pwdb</name></name></expr>;</expr_stmt> <comment type="block">/* Likewise. */</comment>
  <expr_stmt><expr><name><name>b</name>.<name>authzdb</name></name> = <name><name>params</name>-&gt;<name>authzdb</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>b</name>.<name>realm</name></name> = <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>b</name>.<name>pool</name></name> = <name>pool</name></expr>;</expr_stmt>

  <comment type="block">/* Send greeting.  We don't support version 1 any more, so we can
   * send an empty mechlist. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_write_cmd_response</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"nn()(wwwwwww)"</expr></argument>,
                                        <argument><expr>(<name>apr_uint64_t</name>) 2</expr></argument>, <argument><expr>(<name>apr_uint64_t</name>) 2</expr></argument>,
                                        <argument><expr><name>SVN_RA_SVN_CAP_EDIT_PIPELINE</name></expr></argument>,
                                        <argument><expr><name>SVN_RA_SVN_CAP_SVNDIFF1</name></expr></argument>,
                                        <argument><expr><name>SVN_RA_SVN_CAP_ABSENT_ENTRIES</name></expr></argument>,
                                        <argument><expr><name>SVN_RA_SVN_CAP_COMMIT_REVPROPS</name></expr></argument>,
                                        <argument><expr><name>SVN_RA_SVN_CAP_DEPTH</name></expr></argument>,
                                        <argument><expr><name>SVN_RA_SVN_CAP_LOG_REVPROPS</name></expr></argument>,
                                        <argument><expr><name>SVN_RA_SVN_CAP_PARTIAL_REPLAY</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Read client response, which we assume to be in version 2 format:
   * version, capability list, and client URL; then we do an auth
   * request. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_read_tuple</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"nlc"</expr></argument>,
                                <argument><expr>&amp;<name>ver</name></expr></argument>, <argument><expr>&amp;<name>caplist</name></expr></argument>, <argument><expr>&amp;<name>client_url</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>ver</name> != 2</expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <expr_stmt><expr><name>client_url</name> = <call><name>svn_path_canonicalize</name><argument_list>(<argument><expr><name>client_url</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_set_capabilities</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>caplist</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* All released versions of Subversion support edit-pipeline,
   * so we do not accept connections from clients that do not. */</comment>
  <if>if <condition>(<expr>! <call><name>svn_ra_svn_has_capability</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>SVN_RA_SVN_CAP_EDIT_PIPELINE</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <comment type="block">/* find_repos needs the capabilities as a list of words (eventually
     they get handed to the start-commit hook).  While we could add a
     new interface to re-retrieve them from conn and convert the
     result to a list, it's simpler to just convert caplist by hand
     here, since we already have it and turning 'svn_ra_svn_item_t's
     into 'const char *'s is pretty easy. 

     We only record capabilities we care about.  The client may report
     more (because it doesn't know what the server cares about). */</comment>
  <block>{
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>svn_ra_svn_item_t</name> *</type><name>item</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>cap_words</name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>const <name>char</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>caplist</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
      <block>{
        <expr_stmt><expr><name>item</name> = &amp;<call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>caplist</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>svn_ra_svn_item_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* ra_svn_set_capabilities() already type-checked for us */</comment>
        <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>item</name>-&gt;<name>u</name>.<name>word</name></name></expr></argument>, <argument><expr><name>SVN_RA_SVN_CAP_MERGEINFO</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
          <block>{
            <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>cap_words</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call>
              = <name>SVN_RA_CAPABILITY_MERGEINFO</name></expr>;</expr_stmt>
          }</block></then></if>
      }</block></for>
  }</block>

  <expr_stmt><expr><name>err</name> = <call><name>find_repos</name><argument_list>(<argument><expr><name>client_url</name></expr></argument>, <argument><expr><name><name>params</name>-&gt;<name>root</name></name></expr></argument>, <argument><expr>&amp;<name>b</name></expr></argument>, <argument><expr><name>cap_words</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<name>err</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>auth_request</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>&amp;<name>b</name></expr></argument>, <argument><expr><name>READ_ACCESS</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><call><name>current_access</name><argument_list>(<argument><expr>&amp;<name>b</name></expr></argument>)</argument_list></call> == <name>NO_ACCESS</name></expr>)</condition><then>
        <expr_stmt><expr><name>err</name> = <call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_RA_NOT_AUTHORIZED</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                               <argument><expr>"Not authorized for access"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then></if>
  <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>io_err</name> = <call><name>svn_ra_svn_write_cmd_failure</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><name>io_err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><call><name>svn_ra_svn_flush</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_get_uuid</name><argument_list>(<argument><expr><name><name>b</name>.<name>fs</name></name></expr></argument>, <argument><expr>&amp;<name>uuid</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* We can't claim mergeinfo capability until we know whether the
     repository supports mergeinfo (i.e., is not a 1.4 repository),
     but we don't get the repository url from the client until after
     we've already sent the initial list of server capabilities.  So
     we list repository capabilities here, in our first response after
     the client has sent the url. */</comment>  
  <block>{
    <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>supports_mergeinfo</name></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_repos_has_capability</name><argument_list>(<argument><expr><name><name>b</name>.<name>repos</name></name></expr></argument>, <argument><expr>&amp;<name>supports_mergeinfo</name></expr></argument>,
                                     <argument><expr><name>SVN_REPOS_CAPABILITY_MERGEINFO</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_write_tuple</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"w(cc(!"</expr></argument>,
                                   <argument><expr>"success"</expr></argument>, <argument><expr><name>uuid</name></expr></argument>, <argument><expr><name><name>b</name>.<name>repos_url</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>supports_mergeinfo</name></expr>)</condition><then>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_write_word</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>SVN_RA_SVN_CAP_MERGEINFO</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_svn_write_tuple</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"!))"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block>
                      
  <return>return <expr><call><name>svn_ra_svn_handle_commands</name><argument_list>(<argument><expr><name>conn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>main_commands</name></expr></argument>, <argument><expr>&amp;<name>b</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
</unit>
