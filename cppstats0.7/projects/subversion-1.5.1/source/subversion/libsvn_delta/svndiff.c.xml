<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/subversion-1.5.1/source/subversion/libsvn_delta/svndiff.c"><comment type="block">/*
 * svndiff.c -- Encoding and decoding svndiff-format deltas.
 *
 * ====================================================================
 * Copyright (c) 2000-2006 CollabNet.  All rights reserved.
 *
 * This software is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at http://subversion.tigris.org/license-1.html.
 * If newer versions of this license are posted there, you may use a
 * newer version instead, at your option.
 *
 * This software consists of voluntary contributions made by many
 * individuals.  For exact contribution history, see the revision
 * history and logs, available at http://subversion.tigris.org/.
 * ====================================================================
 */</comment>


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_delta.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_io.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"delta.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_pools.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_private_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;zlib.h&gt;</cpp:file></cpp:include>

<comment type="block">/* This macro is taken from zlib, and was originally the function
   compressBound.  It shouldn't ever change, but once every millenium,
   it may be useful for someone to make sure. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>svnCompressBound</name><parameter_list>(<param><type><name>LEN</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((LEN) + ((LEN) &gt;&gt; 12) + ((LEN) &gt;&gt; 14) + 11)</cpp:value></cpp:define>

<comment type="block">/* For svndiff1, address/instruction/new data under this size will not
   be compressed using zlib as a secondary compressor.  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIN_COMPRESS_SIZE</name></cpp:macro> <cpp:value>512</cpp:value></cpp:define>

<comment type="block">/* For svndiff, this is the compression level we pass to zlib.  It
   should be between 0 and 9, with higher numbers being greater
   compression.  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVNDIFF1_COMPRESS_LEVEL</name></cpp:macro> <cpp:value>5</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NORMAL_BITS</name></cpp:macro> <cpp:value>7</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LENGTH_BITS</name></cpp:macro> <cpp:value>5</cpp:value></cpp:define>

<escape char="0xc"/>
<comment type="block">/* ----- Text delta to svndiff ----- */</comment>

<comment type="block">/* We make one of these and get it passed back to us in calls to the
   window handler.  We only use it to record the write function and
   baton passed to svn_txdelta_to_svndiff ().  */</comment>
<struct>struct <name>encoder_baton</name> <block>{
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>output</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>header_done</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>version</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>
}</block>;</struct>


<comment type="block">/* Encode VAL into the buffer P using the variable-length svndiff
   integer format.  Return the incremented value of P after the
   encoded bytes have been written.

   This encoding uses the high bit of each byte as a continuation bit
   and the other seven bits as data bits.  High-order data bits are
   encoded first, followed by lower-order bits, so the value can be
   reconstructed by concatenating the data bits from left to right and
   interpreting the result as a binary number.  Examples (brackets
   denote byte boundaries, spaces are for clarity only):

           1 encodes as [0 0000001]
          33 encodes as [0 0100001]
         129 encodes as [1 0000001] [0 0000001]
        2000 encodes as [1 0001111] [0 1010000]
*/</comment>

<function><type><specifier>static</specifier> <name>char</name> *</type>
<name>encode_int</name><parameter_list>(<param><decl><type><name>char</name> *</type><name>p</name></decl></param>, <param><decl><type><name>svn_filesize_t</name></type> <name>val</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>n</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_filesize_t</name></type> <name>v</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>cont</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>val</name> &gt;= 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Figure out how many bytes we'll need.  */</comment>
  <expr_stmt><expr><name>v</name> = <name>val</name> &gt;&gt; 7</expr>;</expr_stmt>
  <expr_stmt><expr><name>n</name> = 1</expr>;</expr_stmt>
  <while>while <condition>(<expr><name>v</name> &gt; 0</expr>)</condition>
    <block>{
      <expr_stmt><expr><name>v</name> = <name>v</name> &gt;&gt; 7</expr>;</expr_stmt>
      <expr_stmt><expr><name>n</name>++</expr>;</expr_stmt>
    }</block></while>

  <comment type="block">/* Encode the remaining bytes; n is always the number of bytes
     coming after the one we're encoding.  */</comment>
  <while>while <condition>(<expr>--<name>n</name> &gt;= 0</expr>)</condition>
    <block>{
      <expr_stmt><expr><name>cont</name> = ((<name>n</name> &gt; 0) ? 0x1 : 0x0) &lt;&lt; 7</expr>;</expr_stmt>
      <expr_stmt><expr>*<name>p</name>++ = <call>(<name>char</name>)<argument_list>(<argument><expr>((<name>val</name> &gt;&gt; (<name>n</name> * 7)) &amp; 0x7f) | <name>cont</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></while>

  <return>return <expr><name>p</name></expr>;</return>
}</block></function>


<comment type="block">/* Append an encoded integer to a string.  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>append_encoded_int</name><parameter_list>(<param><decl><type><name>svn_stringbuf_t</name> *</type><name>header</name></decl></param>, <param><decl><type><name>svn_filesize_t</name></type> <name>val</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>128</expr>]</index></name></decl>, *<decl><type ref="prev"/><name>p</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>p</name> = <call><name>encode_int</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_stringbuf_appendbytes</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>p</name> - <name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* If IN is a string that is &gt;= MIN_COMPRESS_SIZE, zlib compress it and
   place the result in OUT, with an integer prepended specifying the
   original size.  If IN is &lt; MIN_COMPRESS_SIZE, or if the compressed
   version of IN was no smaller than the original IN, OUT will be a copy
   of IN with the size prepended as an integer. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>zlib_encode</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name></decl></param>, <param><decl><type><name>apr_size_t</name></type> <name>len</name></decl></param>, <param><decl><type><name>svn_stringbuf_t</name> *</type><name>out</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>endlen</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>intlen</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>append_encoded_int</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>intlen</name> = <name><name>out</name>-&gt;<name>len</name></name></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>len</name> &lt; <name>MIN_COMPRESS_SIZE</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>svn_stringbuf_appendbytes</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <expr_stmt><expr><call><name>svn_stringbuf_ensure</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><call><name>svnCompressBound</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call> + <name>intlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>endlen</name> = <name><name>out</name>-&gt;<name>blocksize</name></name></expr>;</expr_stmt>

      <if>if <condition>(<expr><call><name>compress2</name><argument_list>(<argument><expr>(<name>unsigned</name> <name>char</name> *)<name><name>out</name>-&gt;<name>data</name></name> + <name>intlen</name></expr></argument>, <argument><expr>&amp;<name>endlen</name></expr></argument>,
                    <argument><expr>(const <name>unsigned</name> <name>char</name> *)<name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>,
                    <argument><expr><name>SVNDIFF1_COMPRESS_LEVEL</name></expr></argument>)</argument_list></call> != <name>Z_OK</name></expr>)</condition><then>
        <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_SVNDIFF_INVALID_COMPRESSED_DATA</name></expr></argument>,
                                <argument><expr><name>NULL</name></expr></argument>,
                                <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Compression of svndiff data failed"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

      <comment type="block">/* Compression didn't help :(, just append the original text */</comment>
      <if>if <condition>(<expr><name>endlen</name> &gt;= <name>len</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>svn_stringbuf_appendbytes</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
        }</block></then></if>
      <expr_stmt><expr><name><name>out</name>-&gt;<name>len</name></name> = <name>endlen</name> + <name>intlen</name></expr>;</expr_stmt>
    }</block></else></if>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>window_handler</name><parameter_list>(<param><decl><type><name>svn_txdelta_window_t</name> *</type><name>window</name></decl></param>, <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>encoder_baton</name> *</type><name>eb</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name><name>eb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>instructions</name> <init>= <expr><call><name>svn_stringbuf_create</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>i1</name> <init>= <expr><call><name>svn_stringbuf_create</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>header</name> <init>= <expr><call><name>svn_stringbuf_create</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>newdata</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>ibuf</name><index>[<expr>128</expr>]</index></name></decl>, *<decl><type ref="prev"/><name>ip</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_txdelta_op_t</name> *</type><name>op</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name></decl>;</decl_stmt>

  <comment type="block">/* Make sure we write the header.  */</comment>
  <if>if <condition>(<expr><name><name>eb</name>-&gt;<name>header_done</name></name> == <name>FALSE</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>char</name></type> <name><name>svnver</name><index>[<expr>4</expr>]</index></name> <init>= <expr>"SVN\0"</expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>len</name> = 4</expr>;</expr_stmt>
      <expr_stmt><expr><name><name>svnver</name><index>[<expr>3</expr>]</index></name> = <name><name>eb</name>-&gt;<name>version</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_write</name><argument_list>(<argument><expr><name><name>eb</name>-&gt;<name>output</name></name></expr></argument>, <argument><expr><name>svnver</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>eb</name>-&gt;<name>header_done</name></name> = <name>TRUE</name></expr>;</expr_stmt>
    }</block></then></if>

  <if>if <condition>(<expr><name>window</name> == <name>NULL</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>output</name> <init>= <expr><name><name>eb</name>-&gt;<name>output</name></name></expr></init></decl>;</decl_stmt>

      <comment type="block">/* We're done; clean up.

         We clean our pool first. Given that the output stream was passed
         TO us, we'll assume it has a longer lifetime, and that it will not
         be affected by our pool destruction.

         The contrary point of view (close the stream first): that could
         tell our user that everything related to the output stream is done,
         and a cleanup of the user pool should occur. However, that user
         pool could include the subpool we created for our work (eb-&gt;pool),
         which would then make our call to svn_pool_destroy() puke.
       */</comment>
      <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name><name>eb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <return>return <expr><call><name>svn_stream_close</name><argument_list>(<argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

  <comment type="block">/* Encode the instructions.  */</comment>
  <for>for (<init><expr><name>op</name> = <name><name>window</name>-&gt;<name>ops</name></name></expr>;</init> <condition><expr><name>op</name> &lt; <name><name>window</name>-&gt;<name>ops</name></name> + <name><name>window</name>-&gt;<name>num_ops</name></name></expr>;</condition> <incr><expr><name>op</name>++</expr></incr>)
    <block>{
      <comment type="block">/* Encode the action code and length.  */</comment>
      <expr_stmt><expr><name>ip</name> = <name>ibuf</name></expr>;</expr_stmt>
      <switch>switch <condition>(<expr><name><name>op</name>-&gt;<name>action_code</name></name></expr>)</condition>
        <block>{
        <case>case <expr><name>svn_txdelta_source</name></expr>: <expr_stmt><expr>*<name>ip</name> = (<name>char</name>)0</expr>;</expr_stmt> <break>break;</break>
        </case><case>case <expr><name>svn_txdelta_target</name></expr>: <expr_stmt><expr>*<name>ip</name> = <call>(<name>char</name>)<argument_list>(<argument><expr>0x1 &lt;&lt; 6</expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
        </case><case>case <expr><name>svn_txdelta_new</name></expr>:    <expr_stmt><expr>*<name>ip</name> = <call>(<name>char</name>)<argument_list>(<argument><expr>0x2 &lt;&lt; 6</expr></argument>)</argument_list></call></expr>;</expr_stmt> <break>break;</break>
        </case>}</block></switch>
      <if>if <condition>(<expr><name><name>op</name>-&gt;<name>length</name></name> &gt;&gt; 6 == 0</expr>)</condition><then>
        <expr_stmt><expr>*<name>ip</name>++ |= <name><name>op</name>-&gt;<name>length</name></name></expr>;</expr_stmt></then>
      <else>else
        <expr_stmt><expr><name>ip</name> = <call><name>encode_int</name><argument_list>(<argument><expr><name>ip</name> + 1</expr></argument>, <argument><expr><name><name>op</name>-&gt;<name>length</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
      <if>if <condition>(<expr><name><name>op</name>-&gt;<name>action_code</name></name> != <name>svn_txdelta_new</name></expr>)</condition><then>
        <expr_stmt><expr><name>ip</name> = <call><name>encode_int</name><argument_list>(<argument><expr><name>ip</name></expr></argument>, <argument><expr><name><name>op</name>-&gt;<name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
      <expr_stmt><expr><call><name>svn_stringbuf_appendbytes</name><argument_list>(<argument><expr><name>instructions</name></expr></argument>, <argument><expr><name>ibuf</name></expr></argument>, <argument><expr><name>ip</name> - <name>ibuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

  <comment type="block">/* Encode the header.  */</comment>
  <expr_stmt><expr><call><name>append_encoded_int</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name><name>window</name>-&gt;<name>sview_offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>append_encoded_int</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name><name>window</name>-&gt;<name>sview_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>append_encoded_int</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name><name>window</name>-&gt;<name>tview_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name><name>eb</name>-&gt;<name>version</name></name> == 1</expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>zlib_encode</name><argument_list>(<argument><expr><name><name>instructions</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>instructions</name>-&gt;<name>len</name></name></expr></argument>, <argument><expr><name>i1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>instructions</name> = <name>i1</name></expr>;</expr_stmt>
    }</block></then></if>
  <expr_stmt><expr><call><name>append_encoded_int</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name><name>instructions</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name><name>eb</name>-&gt;<name>version</name></name> == 1</expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>temp</name> <init>= <expr><call><name>svn_stringbuf_create</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>tempstr</name> <init>= <expr><call><name>svn_string_create</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>zlib_encode</name><argument_list>(<argument><expr><name><name>window</name>-&gt;<name>new_data</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>window</name>-&gt;<name>new_data</name>-&gt;<name>len</name></name></expr></argument>,
                          <argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>tempstr</name>-&gt;<name>data</name></name> = <name><name>temp</name>-&gt;<name>data</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>tempstr</name>-&gt;<name>len</name></name> = <name><name>temp</name>-&gt;<name>len</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>newdata</name> = <name>tempstr</name></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <expr_stmt><expr><name>newdata</name> = <name><name>window</name>-&gt;<name>new_data</name></name></expr>;</expr_stmt></else></if>

  <expr_stmt><expr><call><name>append_encoded_int</name><argument_list>(<argument><expr><name>header</name></expr></argument>, <argument><expr><name><name>newdata</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Write out the window.  */</comment>
  <expr_stmt><expr><name>len</name> = <name><name>header</name>-&gt;<name>len</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_write</name><argument_list>(<argument><expr><name><name>eb</name>-&gt;<name>output</name></name></expr></argument>, <argument><expr><name><name>header</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name><name>instructions</name>-&gt;<name>len</name></name> &gt; 0</expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>len</name> = <name><name>instructions</name>-&gt;<name>len</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_write</name><argument_list>(<argument><expr><name><name>eb</name>-&gt;<name>output</name></name></expr></argument>, <argument><expr><name><name>instructions</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  <if>if <condition>(<expr><name><name>newdata</name>-&gt;<name>len</name></name> &gt; 0</expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>len</name> = <name><name>newdata</name>-&gt;<name>len</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_write</name><argument_list>(<argument><expr><name><name>eb</name>-&gt;<name>output</name></name></expr></argument>, <argument><expr><name><name>newdata</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name>svn_txdelta_to_svndiff2</name><parameter_list>(<param><decl><type><name>svn_txdelta_window_handler_t</name> *</type><name>handler</name></decl></param>,
                        <param><decl><type><name>void</name> **</type><name>handler_baton</name></decl></param>,
                        <param><decl><type><name>svn_stream_t</name> *</type><name>output</name></decl></param>,
                        <param><decl><type><name>int</name></type> <name>svndiff_version</name></decl></param>,
                        <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>encoder_baton</name> *</type><name>eb</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>eb</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>eb</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>eb</name>-&gt;<name>output</name></name> = <name>output</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>eb</name>-&gt;<name>header_done</name></name> = <name>FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>eb</name>-&gt;<name>pool</name></name> = <name>subpool</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>eb</name>-&gt;<name>version</name></name> = <name>svndiff_version</name></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>handler</name> = <name>window_handler</name></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>handler_baton</name> = <name>eb</name></expr>;</expr_stmt>
}</block></function>

<function><type><name>void</name></type>
<name>svn_txdelta_to_svndiff</name><parameter_list>(<param><decl><type><name>svn_stream_t</name> *</type><name>output</name></decl></param>,
                       <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                       <param><decl><type><name>svn_txdelta_window_handler_t</name> *</type><name>handler</name></decl></param>,
                       <param><decl><type><name>void</name> **</type><name>handler_baton</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>svn_txdelta_to_svndiff2</name><argument_list>(<argument><expr><name>handler</name></expr></argument>, <argument><expr><name>handler_baton</name></expr></argument>, <argument><expr><name>output</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<escape char="0xc"/>
<comment type="block">/* ----- svndiff to text delta ----- */</comment>

<comment type="block">/* An svndiff parser object.  */</comment>
<struct>struct <name>decode_baton</name>
<block>{
  <comment type="block">/* Once the svndiff parser has enough data buffered to create a
     "window", it passes this window to the caller's consumer routine.  */</comment>
  <decl_stmt><decl><type><name>svn_txdelta_window_handler_t</name></type> <name>consumer_func</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> *</type><name>consumer_baton</name></decl>;</decl_stmt>

  <comment type="block">/* Pool to create subpools from; each developing window will be a
     subpool.  */</comment>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>

  <comment type="block">/* The current subpool which contains our current window-buffer.  */</comment>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name></decl>;</decl_stmt>

  <comment type="block">/* The actual svndiff data buffer, living within subpool.  */</comment>
  <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>buffer</name></decl>;</decl_stmt>

  <comment type="block">/* The offset and size of the last source view, so that we can check
     to make sure the next one isn't sliding backwards.  */</comment>
  <decl_stmt><decl><type><name>svn_filesize_t</name></type> <name>last_sview_offset</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>last_sview_len</name></decl>;</decl_stmt>

  <comment type="block">/* We have to discard four bytes at the beginning for the header.
     This field keeps track of how many of those bytes we have read.  */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>header_bytes</name></decl>;</decl_stmt>

  <comment type="block">/* Do we want an error to occur when we close the stream that
     indicates we didn't send the whole svndiff data?  If you plan to
     not transmit the whole svndiff data stream, you will want this to
     be FALSE. */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>error_on_early_close</name></decl>;</decl_stmt>

  <comment type="block">/* svndiff version in use by delta.  */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>version</name></decl>;</decl_stmt>
}</block>;</struct>


<comment type="block">/* Decode an svndiff-encoded integer into VAL and return a pointer to
   the byte after the integer.  The bytes to be decoded live in the
   range [P..END-1].  See the comment for encode_int earlier in this
   file for more detail on the encoding format.  */</comment>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type>
<name>decode_file_offset</name><parameter_list>(<param><decl><type><name>svn_filesize_t</name> *</type><name>val</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>p</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>end</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* Decode bytes until we're done.  */</comment>
  <expr_stmt><expr>*<name>val</name> = 0</expr>;</expr_stmt>
  <while>while <condition>(<expr><name>p</name> &lt; <name>end</name></expr>)</condition>
    <block>{
      <expr_stmt><expr>*<name>val</name> = (*<name>val</name> &lt;&lt; 7) | (*<name>p</name> &amp; 0x7f)</expr>;</expr_stmt>
      <if>if <condition>(<expr>((*<name>p</name>++ &gt;&gt; 7) &amp; 0x1) == 0</expr>)</condition><then>
        <return>return <expr><name>p</name></expr>;</return></then></if>
    }</block></while>
  <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>


<comment type="block">/* Same as above, only decide into a size variable. */</comment>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type>
<name>decode_size</name><parameter_list>(<param><decl><type><name>apr_size_t</name> *</type><name>val</name></decl></param>,
            <param><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>p</name></decl></param>,
            <param><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>end</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* Decode bytes until we're done.  */</comment>
  <expr_stmt><expr>*<name>val</name> = 0</expr>;</expr_stmt>
  <while>while <condition>(<expr><name>p</name> &lt; <name>end</name></expr>)</condition>
    <block>{
      <expr_stmt><expr>*<name>val</name> = (*<name>val</name> &lt;&lt; 7) | (*<name>p</name> &amp; 0x7f)</expr>;</expr_stmt>
      <if>if <condition>(<expr>((*<name>p</name>++ &gt;&gt; 7) &amp; 0x1) == 0</expr>)</condition><then>
        <return>return <expr><name>p</name></expr>;</return></then></if>
    }</block></while>
  <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<comment type="block">/* Decode the possibly-zlib compressed string that is in IN, into OUT.
   We expect an integer is prepended to IN that specifies the original
   size, and that if encoded size == original size, that the remaining
   data is not compressed.  */</comment>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>zlib_decode</name><parameter_list>(<param><decl><type><name>svn_stringbuf_t</name> *</type><name>in</name></decl></param>, <param><decl><type><name>svn_stringbuf_t</name> *</type><name>out</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>oldplace</name> <init>= <expr><name><name>in</name>-&gt;<name>data</name></name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* First thing in the string is the original length.  */</comment>
  <expr_stmt><expr><name><name>in</name>-&gt;<name>data</name></name> = (<name>char</name> *)<call><name>decode_size</name><argument_list>(<argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr>(<name>unsigned</name> <name>char</name> *)<name><name>in</name>-&gt;<name>data</name></name></expr></argument>,
                                 <argument><expr>(<name>unsigned</name> <name>char</name> *)<name><name>in</name>-&gt;<name>data</name></name>+<name><name>in</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* We need to subtract the size of the encoded original length off the
   *      still remaining input length.  */</comment>
  <expr_stmt><expr><name><name>in</name>-&gt;<name>len</name></name> -= (<name><name>in</name>-&gt;<name>data</name></name> - <name>oldplace</name>)</expr>;</expr_stmt>
  <if>if <condition>(<expr><name><name>in</name>-&gt;<name>len</name></name> == <name>len</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>svn_stringbuf_appendstr</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then>
  <else>else
    <block>{
      <decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>zliblen</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>svn_stringbuf_ensure</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>zliblen</name> = <name>len</name></expr>;</expr_stmt>
      <if>if <condition>(<expr><call><name>uncompress</name>  <argument_list>(<argument><expr>(<name>unsigned</name> <name>char</name> *)<name><name>out</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr>&amp;<name>zliblen</name></expr></argument>,
                       <argument><expr>(const <name>unsigned</name> <name>char</name> *)<name><name>in</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>in</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call> != <name>Z_OK</name></expr>)</condition><then>
        <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_SVNDIFF_INVALID_COMPRESSED_DATA</name></expr></argument>,
                                <argument><expr><name>NULL</name></expr></argument>,
                                <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Decompression of svndiff data failed"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

      <comment type="block">/* Zlib should not produce something that has a different size than the
         original length we stored. */</comment>
      <if>if <condition>(<expr><name>zliblen</name> != <name>len</name></expr>)</condition><then>
        <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_SVNDIFF_INVALID_COMPRESSED_DATA</name></expr></argument>,
                                <argument><expr><name>NULL</name></expr></argument>,
                                <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Size of uncompressed data "
                                  "does not match stored original length"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
      <expr_stmt><expr><name><name>out</name>-&gt;<name>len</name></name> = <name>zliblen</name></expr>;</expr_stmt>
    }</block></else></if>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Decode an instruction into OP, returning a pointer to the text
   after the instruction.  Note that if the action code is
   svn_txdelta_new, the offset field of *OP will not be set.  */</comment>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type>
<name>decode_instruction</name><parameter_list>(<param><decl><type><name>svn_txdelta_op_t</name> *</type><name>op</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>p</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>end</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>p</name> == <name>end</name></expr>)</condition><then>
    <return>return <expr><name>NULL</name></expr>;</return></then></if>

  <comment type="block">/* Decode the instruction selector.  */</comment>
  <switch>switch <condition>(<expr>(*<name>p</name> &gt;&gt; 6) &amp; 0x3</expr>)</condition>
    <block>{
    <case>case <expr>0x0</expr>: <expr_stmt><expr><name><name>op</name>-&gt;<name>action_code</name></name> = <name>svn_txdelta_source</name></expr>;</expr_stmt> <break>break;</break>
    </case><case>case <expr>0x1</expr>: <expr_stmt><expr><name><name>op</name>-&gt;<name>action_code</name></name> = <name>svn_txdelta_target</name></expr>;</expr_stmt> <break>break;</break>
    </case><case>case <expr>0x2</expr>: <expr_stmt><expr><name><name>op</name>-&gt;<name>action_code</name></name> = <name>svn_txdelta_new</name></expr>;</expr_stmt> <break>break;</break>
    </case><case>case <expr>0x3</expr>: <return>return <expr><name>NULL</name></expr>;</return>
    </case>}</block></switch>

  <comment type="block">/* Decode the length and offset.  */</comment>
  <expr_stmt><expr><name><name>op</name>-&gt;<name>length</name></name> = *<name>p</name>++ &amp; 0x3f</expr>;</expr_stmt>
  <if>if <condition>(<expr><name><name>op</name>-&gt;<name>length</name></name> == 0</expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>p</name> = <call><name>decode_size</name><argument_list>(<argument><expr>&amp;<name><name>op</name>-&gt;<name>length</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>p</name> == <name>NULL</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    }</block></then></if>
  <if>if <condition>(<expr><name><name>op</name>-&gt;<name>action_code</name></name> != <name>svn_txdelta_new</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>p</name> = <call><name>decode_size</name><argument_list>(<argument><expr>&amp;<name><name>op</name>-&gt;<name>offset</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>p</name> == <name>NULL</name></expr>)</condition><then>
        <return>return <expr><name>NULL</name></expr>;</return></then></if>
    }</block></then></if>

  <return>return <expr><name>p</name></expr>;</return>
}</block></function>

<comment type="block">/* Count the instructions in the range [P..END-1] and make sure they
   are valid for the given window lengths.  Return an error if the
   instructions are invalid; otherwise set *NINST to the number of
   instructions.  */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>count_and_verify_instructions</name><parameter_list>(<param><decl><type><name>int</name> *</type><name>ninst</name></decl></param>,
                              <param><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>p</name></decl></param>,
                              <param><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>end</name></decl></param>,
                              <param><decl><type><name>apr_size_t</name></type> <name>sview_len</name></decl></param>,
                              <param><decl><type><name>apr_size_t</name></type> <name>tview_len</name></decl></param>,
                              <param><decl><type><name>apr_size_t</name></type> <name>new_len</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_txdelta_op_t</name></type> <name>op</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>tpos</name> <init>= <expr>0</expr></init>, <name>npos</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

  <while>while <condition>(<expr><name>p</name> &lt; <name>end</name></expr>)</condition>
    <block>{
      <expr_stmt><expr><name>p</name> = <call><name>decode_instruction</name><argument_list>(<argument><expr>&amp;<name>op</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Detect any malformed operations from the instruction stream. */</comment>
      <if>if <condition>(<expr><name>p</name> == <name>NULL</name></expr>)</condition><then>
        <return>return <expr><call><name>svn_error_createf</name>
          <argument_list>(<argument><expr><name>SVN_ERR_SVNDIFF_INVALID_OPS</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
           <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Invalid diff stream: insn %d cannot be decoded"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return></then>
      <else>else <if>if <condition>(<expr><name><name>op</name>.<name>length</name></name> &lt;= 0</expr>)</condition><then>
        <return>return <expr><call><name>svn_error_createf</name>
          <argument_list>(<argument><expr><name>SVN_ERR_SVNDIFF_INVALID_OPS</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
           <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Invalid diff stream: insn %d has non-positive length"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return></then>
      <else>else <if>if <condition>(<expr><name><name>op</name>.<name>length</name></name> &gt; <name>tview_len</name> - <name>tpos</name></expr>)</condition><then>
        <return>return <expr><call><name>svn_error_createf</name>
          <argument_list>(<argument><expr><name>SVN_ERR_SVNDIFF_INVALID_OPS</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
           <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Invalid diff stream: insn %d overflows the target view"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return></then></if></else></if></else></if>

      <switch>switch <condition>(<expr><name><name>op</name>.<name>action_code</name></name></expr>)</condition>
        <block>{
        <case>case <expr><name>svn_txdelta_source</name></expr>:
          <if>if <condition>(<expr><name><name>op</name>.<name>length</name></name> &gt; <name>sview_len</name> - <name><name>op</name>.<name>offset</name></name></expr>)</condition><then>
            <return>return <expr><call><name>svn_error_createf</name>
              <argument_list>(<argument><expr><name>SVN_ERR_SVNDIFF_INVALID_OPS</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
               <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Invalid diff stream: "
                 "[src] insn %d overflows the source view"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
          <break>break;</break>
        </case><case>case <expr><name>svn_txdelta_target</name></expr>:
          <if>if <condition>(<expr><name><name>op</name>.<name>offset</name></name> &gt;= <name>tpos</name></expr>)</condition><then>
            <return>return <expr><call><name>svn_error_createf</name>
              <argument_list>(<argument><expr><name>SVN_ERR_SVNDIFF_INVALID_OPS</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
               <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Invalid diff stream: "
                 "[tgt] insn %d starts beyond the target view position"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
          <break>break;</break>
        </case><case>case <expr><name>svn_txdelta_new</name></expr>:
          <if>if <condition>(<expr><name><name>op</name>.<name>length</name></name> &gt; <name>new_len</name> - <name>npos</name></expr>)</condition><then>
            <return>return <expr><call><name>svn_error_createf</name>
              <argument_list>(<argument><expr><name>SVN_ERR_SVNDIFF_INVALID_OPS</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
               <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Invalid diff stream: "
                 "[new] insn %d overflows the new data section"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
          <expr_stmt><expr><name>npos</name> += <name><name>op</name>.<name>length</name></name></expr>;</expr_stmt>
          <break>break;</break>
        </case>}</block></switch>
      <expr_stmt><expr><name>tpos</name> += <name><name>op</name>.<name>length</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>n</name>++</expr>;</expr_stmt>
    }</block></while>
  <if>if <condition>(<expr><name>tpos</name> != <name>tview_len</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_SVNDIFF_INVALID_OPS</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                            <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Delta does not fill the target window"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
  <if>if <condition>(<expr><name>npos</name> != <name>new_len</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_SVNDIFF_INVALID_OPS</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                            <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Delta does not contain enough new data"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr>*<name>ninst</name> = <name>n</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Given the five integer fields of a window header and a pointer to
   the remainder of the window contents, fill in a delta window
   structure *WINDOW.  New allocations will be performed in POOL;
   the new_data field of *WINDOW will refer directly to memory pointed
   to by DATA. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>decode_window</name><parameter_list>(<param><decl><type><name>svn_txdelta_window_t</name> *</type><name>window</name></decl></param>, <param><decl><type><name>svn_filesize_t</name></type> <name>sview_offset</name></decl></param>,
              <param><decl><type><name>apr_size_t</name></type> <name>sview_len</name></decl></param>, <param><decl><type><name>apr_size_t</name></type> <name>tview_len</name></decl></param>, <param><decl><type><name>apr_size_t</name></type> <name>inslen</name></decl></param>,
              <param><decl><type><name>apr_size_t</name></type> <name>newlen</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>data</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
              <param><decl><type><name>unsigned</name> <name>int</name></type> <name>version</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>insend</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>ninst</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>npos</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_txdelta_op_t</name> *</type><name>ops</name></decl>, *<decl><type ref="prev"/><name>op</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>new_data</name> <init>= <expr><call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>new_data</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>window</name>-&gt;<name>sview_offset</name></name> = <name>sview_offset</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>window</name>-&gt;<name>sview_len</name></name> = <name>sview_len</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>window</name>-&gt;<name>tview_len</name></name> = <name>tview_len</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>insend</name> = <name>data</name> + <name>inslen</name></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>version</name> == 1</expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>instin</name></decl>, *<decl><type ref="prev"/><name>ndin</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>instout</name></decl>, *<decl><type ref="prev"/><name>ndout</name></decl>;</decl_stmt>

      <expr_stmt><expr><name>instin</name> = <call><name>svn_stringbuf_ncreate</name><argument_list>(<argument><expr>(const <name>char</name> *)<name>data</name></expr></argument>, <argument><expr><name>insend</name> - <name>data</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>instout</name> = <call><name>svn_stringbuf_create</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>zlib_decode</name><argument_list>(<argument><expr><name>instin</name></expr></argument>, <argument><expr><name>instout</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>ndin</name> = <call><name>svn_stringbuf_ncreate</name><argument_list>(<argument><expr>(const <name>char</name> *)<name>insend</name></expr></argument>, <argument><expr><name>newlen</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>ndout</name> = <call><name>svn_stringbuf_create</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>zlib_decode</name><argument_list>(<argument><expr><name>ndin</name></expr></argument>, <argument><expr><name>ndout</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>newlen</name> = <name><name>ndout</name>-&gt;<name>len</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>data</name> = (<name>unsigned</name> <name>char</name> *)<name><name>instout</name>-&gt;<name>data</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>insend</name> = (<name>unsigned</name> <name>char</name> *)<name><name>instout</name>-&gt;<name>data</name></name> + <name><name>instout</name>-&gt;<name>len</name></name></expr>;</expr_stmt>

      <expr_stmt><expr><name><name>new_data</name>-&gt;<name>data</name></name> = (const <name>char</name> *) <name><name>ndout</name>-&gt;<name>data</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>new_data</name>-&gt;<name>len</name></name> = <name>newlen</name></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <expr_stmt><expr><name><name>new_data</name>-&gt;<name>data</name></name> = (const <name>char</name> *) <name>insend</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>new_data</name>-&gt;<name>len</name></name> = <name>newlen</name></expr>;</expr_stmt>
    }</block></else></if>

  <comment type="block">/* Count the instructions and make sure they are all valid.  */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>count_and_verify_instructions</name><argument_list>(<argument><expr>&amp;<name>ninst</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>insend</name></expr></argument>,
                                        <argument><expr><name>sview_len</name></expr></argument>, <argument><expr><name>tview_len</name></expr></argument>, <argument><expr><name>newlen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Allocate a buffer for the instructions and decode them. */</comment>
  <expr_stmt><expr><name>ops</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>ninst</name> * <sizeof>sizeof<argument_list>(<argument><expr>*<name>ops</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>npos</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>window</name>-&gt;<name>src_ops</name></name> = 0</expr>;</expr_stmt>
  <for>for (<init><expr><name>op</name> = <name>ops</name></expr>;</init> <condition><expr><name>op</name> &lt; <name>ops</name> + <name>ninst</name></expr>;</condition> <incr><expr><name>op</name>++</expr></incr>)
    <block>{
      <expr_stmt><expr><name>data</name> = <call><name>decode_instruction</name><argument_list>(<argument><expr><name>op</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>insend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name><name>op</name>-&gt;<name>action_code</name></name> == <name>svn_txdelta_source</name></expr>)</condition><then>
        <expr_stmt><expr>++<name><name>window</name>-&gt;<name>src_ops</name></name></expr>;</expr_stmt></then>
      <else>else <if>if <condition>(<expr><name><name>op</name>-&gt;<name>action_code</name></name> == <name>svn_txdelta_new</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name><name>op</name>-&gt;<name>offset</name></name> = <name>npos</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>npos</name> += <name><name>op</name>-&gt;<name>length</name></name></expr>;</expr_stmt>
        }</block></then></if></else></if>
    }</block></for>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>data</name> == <name>insend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>window</name>-&gt;<name>ops</name></name> = <name>ops</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>window</name>-&gt;<name>num_ops</name></name> = <name>ninst</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>window</name>-&gt;<name>new_data</name></name> = <name>new_data</name></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>write_handler</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>,
              <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>buffer</name></decl></param>,
              <param><decl><type><name>apr_size_t</name> *</type><name>len</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>decode_baton</name> *</type><name>db</name> <init>= <expr>(struct <name>decode_baton</name> *) <name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>p</name></decl>, *<decl><type ref="prev"/><name>end</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_filesize_t</name></type> <name>sview_offset</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>sview_len</name></decl>, <decl><type ref="prev"/><name>tview_len</name></decl>, <decl><type ref="prev"/><name>inslen</name></decl>, <decl><type ref="prev"/><name>newlen</name></decl>, <decl><type ref="prev"/><name>remaining</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>buflen</name> <init>= <expr>*<name>len</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Chew up four bytes at the beginning for the header.  */</comment>
  <if>if <condition>(<expr><name><name>db</name>-&gt;<name>header_bytes</name></name> &lt; 4</expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>apr_size_t</name></type> <name>nheader</name> <init>= <expr>4 - <name><name>db</name>-&gt;<name>header_bytes</name></name></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>nheader</name> &gt; <name>buflen</name></expr>)</condition><then>
        <expr_stmt><expr><name>nheader</name> = <name>buflen</name></expr>;</expr_stmt></then></if>
      <if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr>"SVN\0" + <name><name>db</name>-&gt;<name>header_bytes</name></name></expr></argument>, <argument><expr><name>nheader</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
        <expr_stmt><expr><name><name>db</name>-&gt;<name>version</name></name> = 0</expr>;</expr_stmt></then>
      <else>else <if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr>"SVN\1" + <name><name>db</name>-&gt;<name>header_bytes</name></name></expr></argument>, <argument><expr><name>nheader</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
        <expr_stmt><expr><name><name>db</name>-&gt;<name>version</name></name> = 1</expr>;</expr_stmt></then>
      <else>else
        <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_SVNDIFF_INVALID_HEADER</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Svndiff has invalid header"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></else></if></else></if>
      <expr_stmt><expr><name>buflen</name> -= <name>nheader</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>buffer</name> += <name>nheader</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>db</name>-&gt;<name>header_bytes</name></name> += <name>nheader</name></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* Concatenate the old with the new.  */</comment>
  <expr_stmt><expr><call><name>svn_stringbuf_appendbytes</name><argument_list>(<argument><expr><name><name>db</name>-&gt;<name>buffer</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* We have a buffer of svndiff data that might be good for:

     a) an integral number of windows' worth of data - this is a
        trivial case.  Make windows from our data and ship them off.

     b) a non-integral number of windows' worth of data - we shall
        consume the integral portion of the window data, and then
        somewhere in the following loop the decoding of the svndiff
        data will run out of stuff to decode, and will simply return
        SVN_NO_ERROR, anxiously awaiting more data.
  */</comment>

  <while>while <condition>(<expr>1</expr>)</condition>
    <block>{
      <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>newpool</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_txdelta_window_t</name></type> <name>window</name></decl>;</decl_stmt>

      <comment type="block">/* Read the header, if we have enough bytes for that.  */</comment>
      <expr_stmt><expr><name>p</name> = (const <name>unsigned</name> <name>char</name> *) <name><name>db</name>-&gt;<name>buffer</name>-&gt;<name>data</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>end</name> = (const <name>unsigned</name> <name>char</name> *) <name><name>db</name>-&gt;<name>buffer</name>-&gt;<name>data</name></name> + <name><name>db</name>-&gt;<name>buffer</name>-&gt;<name>len</name></name></expr>;</expr_stmt>

      <expr_stmt><expr><name>p</name> = <call><name>decode_file_offset</name><argument_list>(<argument><expr>&amp;<name>sview_offset</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>p</name> == <name>NULL</name></expr>)</condition><then>
        <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

      <expr_stmt><expr><name>p</name> = <call><name>decode_size</name><argument_list>(<argument><expr>&amp;<name>sview_len</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>p</name> == <name>NULL</name></expr>)</condition><then>
        <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

      <expr_stmt><expr><name>p</name> = <call><name>decode_size</name><argument_list>(<argument><expr>&amp;<name>tview_len</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>p</name> == <name>NULL</name></expr>)</condition><then>
        <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

      <expr_stmt><expr><name>p</name> = <call><name>decode_size</name><argument_list>(<argument><expr>&amp;<name>inslen</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>p</name> == <name>NULL</name></expr>)</condition><then>
        <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

      <expr_stmt><expr><name>p</name> = <call><name>decode_size</name><argument_list>(<argument><expr>&amp;<name>newlen</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>p</name> == <name>NULL</name></expr>)</condition><then>
        <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

      <comment type="block">/* Check for integer overflow.  */</comment>
      <if>if <condition>(<expr><name>sview_offset</name> &lt; 0 || <name>inslen</name> + <name>newlen</name> &lt; <name>inslen</name>
          || <name>sview_len</name> + <name>tview_len</name> &lt; <name>sview_len</name>
          || <name>sview_offset</name> + <name>sview_len</name> &lt; <name>sview_offset</name></expr>)</condition><then>
        <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_SVNDIFF_CORRUPT_WINDOW</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Svndiff contains corrupt window header"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

      <comment type="block">/* Check for source windows which slide backwards.  */</comment>
      <if>if <condition>(<expr><name>sview_len</name> &gt; 0
          &amp;&amp; (<name>sview_offset</name> &lt; <name><name>db</name>-&gt;<name>last_sview_offset</name></name>
              || (<name>sview_offset</name> + <name>sview_len</name>
                  &lt; <name><name>db</name>-&gt;<name>last_sview_offset</name></name> + <name><name>db</name>-&gt;<name>last_sview_len</name></name>))</expr>)</condition><then>
        <return>return <expr><call><name>svn_error_create</name>
          <argument_list>(<argument><expr><name>SVN_ERR_SVNDIFF_BACKWARD_VIEW</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
           <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Svndiff has backwards-sliding source views"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

      <comment type="block">/* Wait for more data if we don't have enough bytes for the
         whole window.  */</comment>
      <if>if <condition>(<expr><call>(<name>apr_size_t</name>) <argument_list>(<argument><expr><name>end</name> - <name>p</name></expr></argument>)</argument_list></call> &lt; <name>inslen</name> + <name>newlen</name></expr>)</condition><then>
        <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

      <comment type="block">/* Decode the window and send it off. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>decode_window</name><argument_list>(<argument><expr>&amp;<name>window</name></expr></argument>, <argument><expr><name>sview_offset</name></expr></argument>, <argument><expr><name>sview_len</name></expr></argument>, <argument><expr><name>tview_len</name></expr></argument>,
                            <argument><expr><name>inslen</name></expr></argument>, <argument><expr><name>newlen</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>db</name>-&gt;<name>subpool</name></name></expr></argument>,
                            <argument><expr><name><name>db</name>-&gt;<name>version</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>db</name>-&gt;<name>consumer_func</name></name><argument_list>(<argument><expr>&amp;<name>window</name></expr></argument>, <argument><expr><name><name>db</name>-&gt;<name>consumer_baton</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Make a new subpool and buffer, saving aside the remaining
         data in the old buffer.  */</comment>
      <expr_stmt><expr><name>newpool</name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name><name>db</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name> += <name>inslen</name> + <name>newlen</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>remaining</name> = <name><name>db</name>-&gt;<name>buffer</name>-&gt;<name>data</name></name> + <name><name>db</name>-&gt;<name>buffer</name>-&gt;<name>len</name></name> - (const <name>char</name> *) <name>p</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>db</name>-&gt;<name>buffer</name></name> =
        <call><name>svn_stringbuf_ncreate</name><argument_list>(<argument><expr>(const <name>char</name> *) <name>p</name></expr></argument>, <argument><expr><name>remaining</name></expr></argument>, <argument><expr><name>newpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Remember the offset and length of the source view for next time.  */</comment>
      <expr_stmt><expr><name><name>db</name>-&gt;<name>last_sview_offset</name></name> = <name>sview_offset</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>db</name>-&gt;<name>last_sview_len</name></name> = <name>sview_len</name></expr>;</expr_stmt>

      <comment type="block">/* We've copied stuff out of the old pool. Toss that pool and use
         our new pool.
         ### might be nice to avoid the copy and just use svn_pool_clear
         ### to get rid of whatever the "other stuff" is. future project...
      */</comment>
      <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name><name>db</name>-&gt;<name>subpool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>db</name>-&gt;<name>subpool</name></name> = <name>newpool</name></expr>;</expr_stmt>
    }</block></while>

  <comment type="block">/* NOTREACHED */</comment>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>close_handler</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>decode_baton</name> *</type><name>db</name> <init>= <expr>(struct <name>decode_baton</name> *) <name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>

  <comment type="block">/* Make sure that we're at a plausible end of stream, returning an
     error if we are expected to do so.  */</comment>
  <if>if <condition>(<expr>(<name><name>db</name>-&gt;<name>error_on_early_close</name></name>)
      &amp;&amp; (<name><name>db</name>-&gt;<name>header_bytes</name></name> &lt; 4 || <name><name>db</name>-&gt;<name>buffer</name>-&gt;<name>len</name></name> != 0)</expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_SVNDIFF_UNEXPECTED_END</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                            <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Unexpected end of svndiff input"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Tell the window consumer that we're done, and clean up.  */</comment>
  <expr_stmt><expr><name>err</name> = <call><name><name>db</name>-&gt;<name>consumer_func</name></name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>db</name>-&gt;<name>consumer_baton</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name><name>db</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>err</name></expr>;</return>
}</block></function>


<function><type><name>svn_stream_t</name> *</type>
<name>svn_txdelta_parse_svndiff</name><parameter_list>(<param><decl><type><name>svn_txdelta_window_handler_t</name></type> <name>handler</name></decl></param>,
                          <param><decl><type><name>void</name> *</type><name>handler_baton</name></decl></param>,
                          <param><decl><type><name>svn_boolean_t</name></type> <name>error_on_early_close</name></decl></param>,
                          <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>decode_baton</name> *</type><name>db</name> <init>= <expr><call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>db</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>stream</name></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>db</name>-&gt;<name>consumer_func</name></name> = <name>handler</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name>-&gt;<name>consumer_baton</name></name> = <name>handler_baton</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name>-&gt;<name>pool</name></name> = <name>subpool</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name>-&gt;<name>subpool</name></name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name>-&gt;<name>buffer</name></name> = <call><name>svn_stringbuf_create</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr><name><name>db</name>-&gt;<name>subpool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name>-&gt;<name>last_sview_offset</name></name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name>-&gt;<name>last_sview_len</name></name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name>-&gt;<name>header_bytes</name></name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name>-&gt;<name>error_on_early_close</name></name> = <name>error_on_early_close</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>stream</name> = <call><name>svn_stream_create</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_stream_set_write</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><name>write_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_stream_set_close</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><name>close_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>stream</name></expr>;</return>
}</block></function>


<comment type="block">/* Routines for reading one svndiff window at a time. */</comment>

<comment type="block">/* Read one byte from STREAM into *BYTE. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>read_one_byte</name><parameter_list>(<param><decl><type><name>unsigned</name> <name>char</name> *</type><name>byte</name></decl></param>, <param><decl><type><name>svn_stream_t</name> *</type><name>stream</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_read</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr>&amp;<name>c</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>len</name> == 0</expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_SVNDIFF_UNEXPECTED_END</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                            <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Unexpected end of svndiff input"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
  <expr_stmt><expr>*<name>byte</name> = (<name>unsigned</name> <name>char</name>) <name>c</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Read and decode one integer from STREAM into *SIZE. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>read_one_size</name><parameter_list>(<param><decl><type><name>apr_size_t</name> *</type><name>size</name></decl></param>, <param><decl><type><name>svn_stream_t</name> *</type><name>stream</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>c</name></decl>;</decl_stmt>

  <expr_stmt><expr>*<name>size</name> = 0</expr>;</expr_stmt>
  <while>while <condition>(<expr>1</expr>)</condition>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>read_one_byte</name><argument_list>(<argument><expr>&amp;<name>c</name></expr></argument>, <argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>size</name> = (*<name>size</name> &lt;&lt; 7) | (<name>c</name> &amp; 0x7f)</expr>;</expr_stmt>
      <if>if <condition>(<expr>!(<name>c</name> &amp; 0x80)</expr>)</condition><then>
        <break>break;</break></then></if>
    }</block></while>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Read a window header from STREAM and check it for integer overflow. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>read_window_header</name><parameter_list>(<param><decl><type><name>svn_stream_t</name> *</type><name>stream</name></decl></param>, <param><decl><type><name>svn_filesize_t</name> *</type><name>sview_offset</name></decl></param>,
                   <param><decl><type><name>apr_size_t</name> *</type><name>sview_len</name></decl></param>, <param><decl><type><name>apr_size_t</name> *</type><name>tview_len</name></decl></param>,
                   <param><decl><type><name>apr_size_t</name> *</type><name>inslen</name></decl></param>, <param><decl><type><name>apr_size_t</name> *</type><name>newlen</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>c</name></decl>;</decl_stmt>

  <comment type="block">/* Read the source view offset by hand, since it's not an apr_size_t. */</comment>
  <expr_stmt><expr>*<name>sview_offset</name> = 0</expr>;</expr_stmt>
  <while>while <condition>(<expr>1</expr>)</condition>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>read_one_byte</name><argument_list>(<argument><expr>&amp;<name>c</name></expr></argument>, <argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>sview_offset</name> = (*<name>sview_offset</name> &lt;&lt; 7) | (<name>c</name> &amp; 0x7f)</expr>;</expr_stmt>
      <if>if <condition>(<expr>!(<name>c</name> &amp; 0x80)</expr>)</condition><then>
        <break>break;</break></then></if>
    }</block></while>

  <comment type="block">/* Read the four size fields. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>read_one_size</name><argument_list>(<argument><expr><name>sview_len</name></expr></argument>, <argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>read_one_size</name><argument_list>(<argument><expr><name>tview_len</name></expr></argument>, <argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>read_one_size</name><argument_list>(<argument><expr><name>inslen</name></expr></argument>, <argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>read_one_size</name><argument_list>(<argument><expr><name>newlen</name></expr></argument>, <argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check for integer overflow.  */</comment>
  <if>if <condition>(<expr>*<name>sview_offset</name> &lt; 0 || *<name>inslen</name> + *<name>newlen</name> &lt; *<name>inslen</name>
      || *<name>sview_len</name> + *<name>tview_len</name> &lt; *<name>sview_len</name>
      || *<name>sview_offset</name> + *<name>sview_len</name> &lt; *<name>sview_offset</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_SVNDIFF_CORRUPT_WINDOW</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                            <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Svndiff contains corrupt window header"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_txdelta_read_svndiff_window</name><parameter_list>(<param><decl><type><name>svn_txdelta_window_t</name> **</type><name>window</name></decl></param>,
                                <param><decl><type><name>svn_stream_t</name> *</type><name>stream</name></decl></param>,
                                <param><decl><type><name>int</name></type> <name>svndiff_version</name></decl></param>,
                                <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_filesize_t</name></type> <name>sview_offset</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>sview_len</name></decl>, <decl><type ref="prev"/><name>tview_len</name></decl>, <decl><type ref="prev"/><name>inslen</name></decl>, <decl><type ref="prev"/><name>newlen</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name> *</type><name>buf</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>read_window_header</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr>&amp;<name>sview_offset</name></expr></argument>, <argument><expr>&amp;<name>sview_len</name></expr></argument>, <argument><expr>&amp;<name>tview_len</name></expr></argument>,
                             <argument><expr>&amp;<name>inslen</name></expr></argument>, <argument><expr>&amp;<name>newlen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>len</name> = <name>inslen</name> + <name>newlen</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>buf</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_read</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr>(<name>char</name>*)<name>buf</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>len</name> &lt; <name>inslen</name> + <name>newlen</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_SVNDIFF_UNEXPECTED_END</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                            <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Unexpected end of svndiff input"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
  <expr_stmt><expr>*<name>window</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>**<name>window</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>decode_window</name><argument_list>(<argument><expr>*<name>window</name></expr></argument>, <argument><expr><name>sview_offset</name></expr></argument>, <argument><expr><name>sview_len</name></expr></argument>, <argument><expr><name>tview_len</name></expr></argument>, <argument><expr><name>inslen</name></expr></argument>,
                        <argument><expr><name>newlen</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>svndiff_version</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_txdelta_skip_svndiff_window</name><parameter_list>(<param><decl><type><name>apr_file_t</name> *</type><name>file</name></decl></param>,
                                <param><decl><type><name>int</name></type> <name>svndiff_version</name></decl></param>,
                                <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>stream</name> <init>= <expr><call><name>svn_stream_from_aprfile</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_filesize_t</name></type> <name>sview_offset</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>sview_len</name></decl>, <decl><type ref="prev"/><name>tview_len</name></decl>, <decl><type ref="prev"/><name>inslen</name></decl>, <decl><type ref="prev"/><name>newlen</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_off_t</name></type> <name>offset</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>read_window_header</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr>&amp;<name>sview_offset</name></expr></argument>, <argument><expr>&amp;<name>sview_len</name></expr></argument>, <argument><expr>&amp;<name>tview_len</name></expr></argument>,
                             <argument><expr>&amp;<name>inslen</name></expr></argument>, <argument><expr>&amp;<name>newlen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>offset</name> = <name>inslen</name> + <name>newlen</name></expr>;</expr_stmt>
  <return>return <expr><call><name>svn_io_file_seek</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>APR_CUR</name></expr></argument>, <argument><expr>&amp;<name>offset</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
</unit>
