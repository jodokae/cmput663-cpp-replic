<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/subversion-1.5.1/source/subversion/libsvn_delta/vdelta.c"><comment type="block">/*
 * vdelta.c:  vdelta generator.
 *
 * ====================================================================
 * Copyright (c) 2000-2004 CollabNet.  All rights reserved.
 *
 * This software is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at http://subversion.tigris.org/license-1.html.
 * If newer versions of this license are posted there, you may use a
 * newer version instead, at your option.
 *
 * This software consists of voluntary contributions made by many
 * individuals.  For exact contribution history, see the revision
 * history and logs, available at http://subversion.tigris.org/.
 * ====================================================================
 */</comment>


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_general.h&gt;</cpp:file></cpp:include>        <comment type="block">/* for APR_INLINE */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_delta.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"delta.h"</cpp:file></cpp:include>

<escape char="0xc"/>
<comment type="block">/* ==================================================================== */</comment>
<comment type="block">/* Hash table for vdelta hashing.

   Each hash bucket is a chain of slots. The index of the slot in
   the slots array is also the index of the key string in the
   current window's data stream. The hash table implements a multimap
   (i.e., hash and key collisions are allowed).

   To store a key-&gt;index mapping, just add slot[index] to the slot
   chain tn key's bucket (see store_mapping).

   For a given key, you can traverse the list of match candidates (some
   of which may be hash collisions) like this:

   for (slot = buckets[get_bucket(key)]; slot != NULL; slot = slot-&gt;next)
     {
       index = slot - slots;
       ...
     }
*/</comment>


<comment type="block">/* Size of a vdelta hash key. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VD_KEY_SIZE</name></cpp:macro> <cpp:value>4</cpp:value></cpp:define>


<comment type="block">/* Hash slot. */</comment>
<typedef>typedef <type><struct>struct <name>hash_slot_t</name> <block>{
  <decl_stmt><decl><type>struct <name>hash_slot_t</name> *</type><name>next</name></decl>;</decl_stmt>
}</block></struct></type> <name>hash_slot_t</name>;</typedef>

<comment type="block">/* Hash table. */</comment>
<typedef>typedef <type><struct>struct <name>hash_table_t</name> <block>{
  <decl_stmt><decl><type><name>int</name></type> <name>num_buckets</name></decl>;</decl_stmt>              <comment type="block">/* Number of buckets in the table. */</comment>
  <decl_stmt><decl><type><name>hash_slot_t</name> **</type><name>buckets</name></decl>;</decl_stmt>        <comment type="block">/* Bucket array. */</comment>
  <decl_stmt><decl><type><name>hash_slot_t</name> *</type><name>slots</name></decl>;</decl_stmt>           <comment type="block">/* Slots array. */</comment>
}</block></struct></type> <name>hash_table_t</name>;</typedef>


<comment type="block">/* Create a hash table with NUM_SLOTS slots. NUM_SLOTS should be the sum
   of the size of the source and target parts of the delta window.
   Allocate from POOL. */</comment>
<function><type><specifier>static</specifier> <name>hash_table_t</name> *</type>
<name>create_hash_table</name><parameter_list>(<param><decl><type><name>apr_size_t</name></type> <name>num_slots</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>j</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>hash_table_t</name>*</type> <name>table</name> <init>= <expr><call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>table</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="block">/* This should be a reasonable number of buckets ... */</comment>
  <expr_stmt><expr><name><name>table</name>-&gt;<name>num_buckets</name></name> = (<name>num_slots</name> / 3) | 1</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>table</name>-&gt;<name>buckets</name></name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>(<name><name>table</name>-&gt;<name>num_buckets</name></name>
                                     * <sizeof>sizeof<argument_list>(<argument><expr>*<name><name>table</name>-&gt;<name>buckets</name></name></expr></argument>)</argument_list></sizeof>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>table</name>-&gt;<name>num_buckets</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>)
    <expr_stmt><expr><name><name>table</name>-&gt;<name>buckets</name><index>[<expr><name>i</name></expr>]</index></name> = <name>NULL</name></expr>;</expr_stmt></for>

  <expr_stmt><expr><name><name>table</name>-&gt;<name>slots</name></name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>num_slots</name> * <sizeof>sizeof<argument_list>(<argument><expr>*<name><name>table</name>-&gt;<name>slots</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name>num_slots</name></expr>;</condition> <incr><expr>++<name>j</name></expr></incr>)
    <expr_stmt><expr><name><name>table</name>-&gt;<name>slots</name><index>[<expr><name>j</name></expr>]</index></name>.<name>next</name> = <name>NULL</name></expr>;</expr_stmt></for>

  <return>return <expr><name>table</name></expr>;</return>
}</block></function>


<comment type="block">/* Convert a key to a pointer to the key's hash bucket.
   We use a 2-universal multiplicative hash function. If you're
   wondering about the selected multiplier, take a look at the
   comments in apr/tables/apr_hash.c:find_entry for a discussion
   on fast string hashes; it's very illuminating.

   [ We use 127 instead of 33 here because I happen to like
     interesting prime numbers, so there. --xbc ] */</comment>
<function><type><specifier>static</specifier> <name>APR_INLINE</name> <name>apr_uint32_t</name></type>
<name>get_bucket</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>hash_table_t</name> *</type><name>table</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>key</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_uint32_t</name></type> <name>hash</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>VD_KEY_SIZE</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>)
    <expr_stmt><expr><name>hash</name> = <name>hash</name> * 127 + *<name>key</name>++</expr>;</expr_stmt></for>
  <return>return <expr><name>hash</name> % <name><name>table</name>-&gt;<name>num_buckets</name></name></expr>;</return>
}</block></function>


<comment type="block">/* Store a key-&gt;index mapping into the hash table. */</comment>
<function><type><specifier>static</specifier> <name>APR_INLINE</name> <name>void</name></type>
<name>store_mapping</name><parameter_list>(<param><decl><type><name>hash_table_t</name> *</type><name>table</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>key</name></decl></param>, <param><decl><type><name>apr_size_t</name></type> <name>idx</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_uint32_t</name></type> <name>bucket</name> <init>= <expr><call><name>get_bucket</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>table</name>-&gt;<name>slots</name><index>[<expr><name>idx</name></expr>]</index></name>.<name>next</name> == <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>table</name>-&gt;<name>slots</name><index>[<expr><name>idx</name></expr>]</index></name>.<name>next</name> = <name><name>table</name>-&gt;<name>buckets</name><index>[<expr><name>bucket</name></expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>table</name>-&gt;<name>buckets</name><index>[<expr><name>bucket</name></expr>]</index></name> = &amp;<name><name>table</name>-&gt;<name>slots</name><index>[<expr><name>idx</name></expr>]</index></name></expr>;</expr_stmt>
}</block></function>


<escape char="0xc"/>
<comment type="block">/* ==================================================================== */</comment>
<comment type="block">/* Vdelta generator.

   The article "Delta Algorithms: An Empirical Analysis" by Hunt,
   Vo and Tichy contains a description of the vdelta algorithm,
   but it's incomplete. Here's a detailed description:

     1. Look up the four bytes starting at the current position
        pointer.  If there are no matches for those four bytes,
        output an insert, move the position pointer forward by one,
        and go back to step 1.

     2. Determine which of the candidates yields the longest
        extension.  This will be called the "current match".

     3. Look up the last three bytes of the current match plus one
        unmatched byte.  If there is no match for those four bytes,
        the current match is the best match; go to step 6.

     4. For each candidate, check backwards to see if it matches
        the entire match so far.  If no candidates satisfy that
        constraint, the current match is the best match; go to step 6.

     5. Among the candidates which do satisfy the constraint,
        determine which one yields the longest extension.  This
        will be the new "current match."  Go back to step 3.

     6. Output a block copy instruction, add indexes for the last
        three positions of the matched data, advance the position
        pointer by the length of the match, and go back to step 1.

   Inserts and copies are generated only when the current position
   is within the target data.

   Note that the vdelta algorithm allows copies that cross the
   source/target data boundary. Because our internal delta
   representation has different opcodes for source and target copies,
   we split them in two. This means that the opcode stream in the
   delta window can contain copies shorter than VD_KEY_SIZE. These
   could be represented by insert ops instead, but we'll leave them
   in, so that we can merge them again when we convert the delta
   window to an external format like vcdiff that supports cross
   -boundary copies. */</comment>


<comment type="block">/* Find the length of a match within the data window.
   Note that (match &lt; from &amp;&amp; from &lt;= end) must always be true here. */</comment>

<function><type><specifier>static</specifier> <name>APR_INLINE</name> <name>int</name></type>
<name>find_match_len</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>match</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>from</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>end</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>here</name> <init>= <expr><name>from</name></expr></init></decl>;</decl_stmt>
  <while>while <condition>(<expr><name>here</name> &lt; <name>end</name> &amp;&amp; *<name>match</name> == *<name>here</name></expr>)</condition>
    <block>{
      <expr_stmt><expr>++<name>match</name></expr>;</expr_stmt>
      <expr_stmt><expr>++<name>here</name></expr>;</expr_stmt>
    }</block></while>
  <return>return <expr><name>here</name> - <name>from</name></expr>;</return>
}</block></function>


<comment type="block">/* This is the main vdelta generator. */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>vdelta</name><parameter_list>(<param><decl><type><name>svn_txdelta__ops_baton_t</name> *</type><name>build_baton</name></decl></param>,
       <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name></decl></param>,
       <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>start</name></decl></param>,
       <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>end</name></decl></param>,
       <param><decl><type><name>svn_boolean_t</name></type> <name>outputflag</name></decl></param>,
       <param><decl><type><name>hash_table_t</name> *</type><name>table</name></decl></param>,
       <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>here</name> <init>= <expr><name>start</name></expr></init></decl>;</decl_stmt>     <comment type="block">/* Current position in the buffer. */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>insert_from</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt> <comment type="block">/* Start of byte range for insertion. */</comment>

  <for>for (<init>;</init><condition>;</condition><incr/>)
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>current_match</name></decl>, *<decl><type ref="prev"/><name>key</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_size_t</name></type> <name>current_match_len</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>hash_slot_t</name> *</type><name>slot</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>progress</name></decl>;</decl_stmt>

      <comment type="block">/* If we're near the end, just insert the last few bytes. */</comment>
      <if>if <condition>(<expr><name>end</name> - <name>here</name> &lt; <name>VD_KEY_SIZE</name></expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>from</name> <init>= <expr>((<name>insert_from</name> != <name>NULL</name>) ? <name>insert_from</name> : <name>here</name>)</expr></init></decl>;</decl_stmt>

          <if>if <condition>(<expr><name>outputflag</name> &amp;&amp; <name>from</name> &lt; <name>end</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>svn_txdelta__insert_op</name><argument_list>(<argument><expr><name>build_baton</name></expr></argument>, <argument><expr><name>svn_txdelta_new</name></expr></argument>, <argument><expr>0</expr></argument>,
                                   <argument><expr><name>end</name> - <name>from</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
          <return>return;</return>
        }</block></then></if>

      <comment type="block">/* Search for the longest match.  */</comment>
      <expr_stmt><expr><name>current_match</name> = <name>NULL</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>current_match_len</name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name>key</name> = <name>here</name></expr>;</expr_stmt>
      <do>do
        <block>{
          <comment type="block">/* Try to extend the current match.  Our key is the last
             three matched bytes plus one unmatched byte if we already
             have a current match, or just the four bytes where we are
             if we don't have a current match yet.  See which mapping
             yields the longest extension.  */</comment>
          <expr_stmt><expr><name>progress</name> = <name>FALSE</name></expr>;</expr_stmt>
          <for>for (<init><expr><name>slot</name> = <name><name>table</name>-&gt;<name>buckets</name><index>[<expr><call><name>get_bucket</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</init>
               <condition><expr><name>slot</name> != <name>NULL</name></expr>;</condition>
               <incr><expr><name>slot</name> = <name><name>slot</name>-&gt;<name>next</name></name></expr></incr>)
            <block>{
              <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>match</name></decl>;</decl_stmt>
              <decl_stmt><decl><type><name>apr_size_t</name></type> <name>match_len</name></decl>;</decl_stmt>

              <if>if <condition>(<expr><name>slot</name> - <name><name>table</name>-&gt;<name>slots</name></name> &lt; <name>key</name> - <name>here</name></expr>)</condition><then> <comment type="block">/* Too close to start */</comment>
                <continue>continue;</continue></then></if>
              <expr_stmt><expr><name>match</name> = <name>data</name> + (<name>slot</name> - <name><name>table</name>-&gt;<name>slots</name></name>) - (<name>key</name> - <name>here</name>)</expr>;</expr_stmt>
              <expr_stmt><expr><name>match_len</name> = <call><name>find_match_len</name><argument_list>(<argument><expr><name>match</name></expr></argument>, <argument><expr><name>here</name></expr></argument>, <argument><expr><name>end</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

              <comment type="block">/* We can only copy from the source or from the target, so
                 don't let the match cross START.  */</comment>
              <if>if <condition>(<expr><name>match</name> &lt; <name>start</name> &amp;&amp; <name>match</name> + <name>match_len</name> &gt; <name>start</name></expr>)</condition><then>
                <expr_stmt><expr><name>match_len</name> = <name>start</name> - <name>match</name></expr>;</expr_stmt></then></if>

              <if>if <condition>(<expr><name>match_len</name> &gt;= <name>VD_KEY_SIZE</name> &amp;&amp; <name>match_len</name> &gt; <name>current_match_len</name></expr>)</condition><then>
                <block>{
                  <comment type="block">/* We have a longer match; record it.  */</comment>
                  <expr_stmt><expr><name>current_match</name> = <name>match</name></expr>;</expr_stmt>
                  <expr_stmt><expr><name>current_match_len</name> = <name>match_len</name></expr>;</expr_stmt>
                  <expr_stmt><expr><name>progress</name> = <name>TRUE</name></expr>;</expr_stmt>
                }</block></then></if>
            }</block></for>
          <if>if <condition>(<expr><name>progress</name></expr>)</condition><then>
            <expr_stmt><expr><name>key</name> = <name>here</name> + <name>current_match_len</name> - (<name>VD_KEY_SIZE</name> - 1)</expr>;</expr_stmt></then></if>
        }</block>
      while <condition>(<expr><name>progress</name> &amp;&amp; <name>end</name> - <name>key</name> &gt;= <name>VD_KEY_SIZE</name></expr>)</condition>;</do>

      <if>if <condition>(<expr><name>current_match_len</name> &lt; <name>VD_KEY_SIZE</name></expr>)</condition><then>
        <block>{
          <comment type="block">/* There is no match here; store a mapping and insert this byte. */</comment>
          <expr_stmt><expr><call><name>store_mapping</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>here</name></expr></argument>, <argument><expr><name>here</name> - <name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>insert_from</name> == <name>NULL</name></expr>)</condition><then>
            <expr_stmt><expr><name>insert_from</name> = <name>here</name></expr>;</expr_stmt></then></if>
          <expr_stmt><expr><name>here</name>++</expr>;</expr_stmt>
          <continue>continue;</continue>
        }</block></then>
      <else>else <if>if <condition>(<expr><name>outputflag</name></expr>)</condition><then>
        <block>{
          <if>if <condition>(<expr><name>insert_from</name> != <name>NULL</name></expr>)</condition><then>
            <block>{
              <comment type="block">/* Commit the pending insert. */</comment>
              <expr_stmt><expr><call><name>svn_txdelta__insert_op</name><argument_list>(<argument><expr><name>build_baton</name></expr></argument>, <argument><expr><name>svn_txdelta_new</name></expr></argument>,
                                     <argument><expr>0</expr></argument>, <argument><expr><name>here</name> - <name>insert_from</name></expr></argument>,
                                     <argument><expr><name>insert_from</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>insert_from</name> = <name>NULL</name></expr>;</expr_stmt>
            }</block></then></if>
          <if>if <condition>(<expr><name>current_match</name> &lt; <name>start</name></expr>)</condition><then> <comment type="block">/* Copy from source. */</comment>
            <expr_stmt><expr><call><name>svn_txdelta__insert_op</name><argument_list>(<argument><expr><name>build_baton</name></expr></argument>, <argument><expr><name>svn_txdelta_source</name></expr></argument>,
                                   <argument><expr><name>current_match</name> - <name>data</name></expr></argument>,
                                   <argument><expr><name>current_match_len</name></expr></argument>,
                                   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
          <else>else                       <comment type="block">/* Copy from target */</comment>
            <expr_stmt><expr><call><name>svn_txdelta__insert_op</name><argument_list>(<argument><expr><name>build_baton</name></expr></argument>, <argument><expr><name>svn_txdelta_target</name></expr></argument>,
                                   <argument><expr><name>current_match</name> - <name>start</name></expr></argument>,
                                   <argument><expr><name>current_match_len</name></expr></argument>,
                                   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
        }</block></then></if></else></if>

      <comment type="block">/* Adjust the current position and insert mappings for the
         last three bytes of the match. */</comment>
      <expr_stmt><expr><name>here</name> += <name>current_match_len</name></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>end</name> - <name>here</name> &gt;= <name>VD_KEY_SIZE</name></expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><name>char</name> <specifier>const</specifier> *</type><name>last</name> <init>= <expr><name>here</name> - (<name>VD_KEY_SIZE</name> - 1)</expr></init></decl>;</decl_stmt>
          <for>for (<init>;</init> <condition><expr><name>last</name> &lt; <name>here</name></expr>;</condition> <incr><expr>++<name>last</name></expr></incr>)
            <expr_stmt><expr><call><name>store_mapping</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>last</name></expr></argument>, <argument><expr><name>last</name> - <name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
        }</block></then></if>
    }</block></for>
}</block></function>


<function><type><name>void</name></type>
<name>svn_txdelta__vdelta</name><parameter_list>(<param><decl><type><name>svn_txdelta__ops_baton_t</name> *</type><name>build_baton</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name></decl></param>,
                    <param><decl><type><name>apr_size_t</name></type> <name>source_len</name></decl></param>,
                    <param><decl><type><name>apr_size_t</name></type> <name>target_len</name></decl></param>,
                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>hash_table_t</name> *</type><name>table</name> <init>= <expr><call><name>create_hash_table</name><argument_list>(<argument><expr><name>source_len</name> + <name>target_len</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>vdelta</name><argument_list>(<argument><expr><name>build_baton</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>data</name> + <name>source_len</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>table</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>vdelta</name><argument_list>(<argument><expr><name>build_baton</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>data</name> + <name>source_len</name></expr></argument>, <argument><expr><name>data</name> + <name>source_len</name> + <name>target_len</name></expr></argument>,
         <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>table</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
  <comment type="block">/* This bit of code calculates the hash load and the
     number of collisions. Please note that a the number
     of collisions per bucket is one less than the length
     of the chain. :-)  --xbc */</comment>
  {
    int i;
    int empty = 0;
    int collisions = 0;
    for (i = 0; i &lt; table-&gt;num_buckets; ++i)
    {
      hash_slot_t *slot = table-&gt;buckets[i];
      if (!slot)
        ++empty;
      else
      {
        slot = slot-&gt;next;
        while (slot != NULL)
        {
          ++collisions;
          slot = slot-&gt;next;
        }
      }
    }
    fprintf(stderr, "Hash stats: load %d, collisions %d\n",
            100 - 100 * empty / table-&gt;num_buckets, collisions);
  }
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
}</block></function>
</unit>
