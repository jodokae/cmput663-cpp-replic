<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/subversion-1.5.1/source/subversion/libsvn_delta/xdelta.c"><comment type="block">/*
 * xdelta.c:  xdelta generator.
 *
 * ====================================================================
 * Copyright (c) 2000-2006 CollabNet.  All rights reserved.
 *
 * This software is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at http://subversion.tigris.org/license-1.html.
 * If newer versions of this license are posted there, you may use a
 * newer version instead, at your option.
 *
 * This software consists of voluntary contributions made by many
 * individuals.  For exact contribution history, see the revision
 * history and logs, available at http://subversion.tigris.org/.
 * ====================================================================
 */</comment>


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_general.h&gt;</cpp:file></cpp:include>        <comment type="block">/* for APR_INLINE */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_hash.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_delta.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"delta.h"</cpp:file></cpp:include>
<escape char="0xc"/>
<comment type="block">/* This is pseudo-adler32. It is adler32 without the prime modulus.
   The idea is borrowed from monotone, and is a translation of the C++
   code.  Graydon Hoare, the author of the original code, gave his
   explicit permission to use it under these terms at 8:02pm on
   Friday, February 11th, 2005.  */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADLER32_MASK</name></cpp:macro>      <cpp:value>0x0000ffff</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADLER32_CHAR_MASK</name></cpp:macro> <cpp:value>0x000000ff</cpp:value></cpp:define>

<comment type="block">/* Structure to store the state of our adler32 checksum.  */</comment>
<struct>struct <name>adler32</name>
<block>{
  <decl_stmt><decl><type><name>apr_uint32_t</name></type> <name>s1</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_uint32_t</name></type> <name>s2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_uint32_t</name></type> <name>len</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/* Feed C into the adler32 checksum.  */</comment>

<function><type><specifier>static</specifier> <name>APR_INLINE</name> <name>void</name></type>
<name>adler32_in</name><parameter_list>(<param><decl><type>struct <name>adler32</name> *</type><name>ad</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name></type> <name>c</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><name><name>ad</name>-&gt;<name>s1</name></name> += (<call>(<name>apr_uint32_t</name>) <argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call>) &amp; <name>ADLER32_CHAR_MASK</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ad</name>-&gt;<name>s1</name></name> &amp;= <name>ADLER32_MASK</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ad</name>-&gt;<name>s2</name></name> += <name><name>ad</name>-&gt;<name>s1</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ad</name>-&gt;<name>s2</name></name> &amp;= <name>ADLER32_MASK</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ad</name>-&gt;<name>len</name></name>++</expr>;</expr_stmt>
}</block></function>

<comment type="block">/* Remove the result of byte C from the adler32 checksum.  */</comment>

<function><type><specifier>static</specifier> <name>APR_INLINE</name> <name>void</name></type>
<name>adler32_out</name><parameter_list>(<param><decl><type>struct <name>adler32</name> *</type><name>ad</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name></type> <name>c</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><name><name>ad</name>-&gt;<name>s1</name></name> -= (<call>(<name>apr_uint32_t</name>) <argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call>) &amp; <name>ADLER32_CHAR_MASK</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ad</name>-&gt;<name>s1</name></name> &amp;= <name>ADLER32_MASK</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ad</name>-&gt;<name>s2</name></name> -= (<name><name>ad</name>-&gt;<name>len</name></name> * (((<name>apr_uint32_t</name>) <name>c</name>) &amp; <name>ADLER32_CHAR_MASK</name>)) + 1</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ad</name>-&gt;<name>s2</name></name> &amp;= <name>ADLER32_MASK</name></expr>;</expr_stmt>
  <expr_stmt><expr>--<name><name>ad</name>-&gt;<name>len</name></name></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* Return the current adler32 checksum in the adler32 structure.  */</comment>

<function><type><specifier>static</specifier> <name>APR_INLINE</name> <name>apr_uint32_t</name></type>
<name>adler32_sum</name><parameter_list>(<param><decl><type><specifier>const</specifier> struct <name>adler32</name> *</type><name>ad</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr>(<name><name>ad</name>-&gt;<name>s2</name></name> &lt;&lt; 16) | (<name><name>ad</name>-&gt;<name>s1</name></name>)</expr>;</return>
}</block></function>

<comment type="block">/* Initialize an adler32 checksum structure with DATA, which has length
   DATALEN.  Return the initialized structure.  */</comment>

<expr_stmt><expr>static <name>APR_INLINE</name> struct <name>adler32</name> *
<macro><name>init_adler32</name><argument_list>(<argument>struct adler32 *ad</argument>, <argument>const char *data</argument>, <argument>apr_uint32_t datalen</argument>)</argument_list></macro>
<block>{
  <expr><name><name>ad</name>-&gt;<name>s1</name></name> = 1</expr>;
  <expr><name><name>ad</name>-&gt;<name>s2</name></name> = 0</expr>;
  <expr><name><name>ad</name>-&gt;<name>len</name></name> = 0</expr>;
  <while>while <condition>(<expr><name>datalen</name>--</expr>)</condition>
    <expr_stmt><expr><call><name>adler32_in</name><argument_list>(<argument><expr><name>ad</name></expr></argument>, <argument><expr>*(<name>data</name>++)</expr></argument>)</argument_list></call></expr>;</expr_stmt></while></block></expr></expr_stmt>
  <return>return <expr><name>ad</name></expr>;</return>
}

<comment type="block">/* Size of the blocks we compute checksums for. This was chosen out of
   thin air.  Monotone used 64, xdelta1 used 64, rsync uses 128.  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MATCH_BLOCKSIZE</name></cpp:macro> <cpp:value>64</cpp:value></cpp:define>

<comment type="block">/* Information for a block of the delta source.  The length of the
   block is the smaller of MATCH_BLOCKSIZE and the difference between
   the size of the source data and the position of this block. */</comment>
struct <macro><name>block</name></macro>
<block>{
  <decl_stmt><decl><type><name>apr_uint32_t</name></type> <name>adlersum</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>pos</name></decl>;</decl_stmt>
}</block><empty_stmt>;</empty_stmt>

<comment type="block">/* A hash table, using open addressing, of the blocks of the source. */</comment>
<struct>struct <name>blocks</name>
<block>{
  <comment type="block">/* The largest valid index of slots. */</comment>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>max</name></decl>;</decl_stmt>
  <comment type="block">/* The vector of blocks.  A pos value of (apr_size_t)-1 represents an unused
     slot. */</comment>
  <decl_stmt><decl><type>struct <name>block</name> *</type><name>slots</name></decl>;</decl_stmt>
}</block>;</struct>


<comment type="block">/* Return a hash value calculated from the adler32 SUM, suitable for use with
   our hash table. */</comment>
<function><type><specifier>static</specifier> <name>apr_size_t</name></type> <name>hash_func</name><parameter_list>(<param><decl><type><name>apr_uint32_t</name></type> <name>sum</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* Since the adl32 checksum have a bad distribution for the 11th to 16th
     bits when used for our small block size, we add some bits from the
     other half of the checksum. */</comment>
  <return>return <expr><name>sum</name> ^ (<name>sum</name> &gt;&gt; 12)</expr>;</return>
}</block></function>

<comment type="block">/* Insert a block with the checksum ADLERSUM at position POS in the source data
   into the table BLOCKS.  Ignore duplicates. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_block</name><parameter_list>(<param><decl><type>struct <name>blocks</name> *</type><name>blocks</name></decl></param>, <param><decl><type><name>apr_uint32_t</name></type> <name>adlersum</name></decl></param>, <param><decl><type><name>apr_size_t</name></type> <name>pos</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>h</name> <init>= <expr><call><name>hash_func</name><argument_list>(<argument><expr><name>adlersum</name></expr></argument>)</argument_list></call> &amp; <name><name>blocks</name>-&gt;<name>max</name></name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* This will terminate, since we know that we will not fill the table. */</comment>
  <while>while <condition>(<expr><name><name>blocks</name>-&gt;<name>slots</name><index>[<expr><name>h</name></expr>]</index></name>.<name>pos</name> != (<name>apr_size_t</name>)-1</expr>)</condition>
    <block>{
      <comment type="block">/* No duplicates! */</comment>
      <if>if <condition>(<expr><name><name>blocks</name>-&gt;<name>slots</name><index>[<expr><name>h</name></expr>]</index></name>.<name>adlersum</name> == <name>adlersum</name></expr>)</condition><then>
        <return>return;</return></then></if>
      <expr_stmt><expr><name>h</name> = (<name>h</name> + 1) &amp; <name><name>blocks</name>-&gt;<name>max</name></name></expr>;</expr_stmt>
    }</block></while>
  <expr_stmt><expr><name><name>blocks</name>-&gt;<name>slots</name><index>[<expr><name>h</name></expr>]</index></name>.<name>adlersum</name> = <name>adlersum</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>blocks</name>-&gt;<name>slots</name><index>[<expr><name>h</name></expr>]</index></name>.<name>pos</name> = <name>pos</name></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* Find a block in BLOCKS with the checksum ADLERSUM, returning its position
   in the source data.  If there is no such block, return (apr_size_t)-1. */</comment>
<function><type><specifier>static</specifier> <name>apr_size_t</name></type>
<name>find_block</name><parameter_list>(<param><decl><type><specifier>const</specifier> struct <name>blocks</name> *</type><name>blocks</name></decl></param>, <param><decl><type><name>apr_uint32_t</name></type> <name>adlersum</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>h</name> <init>= <expr><call><name>hash_func</name><argument_list>(<argument><expr><name>adlersum</name></expr></argument>)</argument_list></call> &amp; <name><name>blocks</name>-&gt;<name>max</name></name></expr></init></decl>;</decl_stmt>

  <while>while <condition>(<expr><name><name>blocks</name>-&gt;<name>slots</name><index>[<expr><name>h</name></expr>]</index></name>.<name>adlersum</name> != <name>adlersum</name>
         &amp;&amp; <name><name>blocks</name>-&gt;<name>slots</name><index>[<expr><name>h</name></expr>]</index></name>.<name>pos</name> != (<name>apr_size_t</name>)-1</expr>)</condition>
    <expr_stmt><expr><name>h</name> = (<name>h</name> + 1) &amp; <name><name>blocks</name>-&gt;<name>max</name></name></expr>;</expr_stmt></while>

  <return>return <expr><name><name>blocks</name>-&gt;<name>slots</name><index>[<expr><name>h</name></expr>]</index></name>.<name>pos</name></expr>;</return>
}</block></function>

<comment type="block">/* Initialize the matches table from DATA of size DATALEN.  This goes
   through every block of MATCH_BLOCKSIZE bytes in the source and
   checksums it, inserting the result into the BLOCKS table.  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>init_blocks_table</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name></decl></param>,
                   <param><decl><type><name>apr_size_t</name></type> <name>datalen</name></decl></param>,
                  <param><decl><type>struct <name>blocks</name> *</type><name>blocks</name></decl></param>,
                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>adler32</name></type> <name>adler</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>nblocks</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>nslots</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>

  <comment type="block">/* Be pesimistic about the block count. */</comment>
  <expr_stmt><expr><name>nblocks</name> = <name>datalen</name> / <name>MATCH_BLOCKSIZE</name> + 1</expr>;</expr_stmt>
  <comment type="block">/* Find nearest larger power of two. */</comment>
  <while>while <condition>(<expr><name>nslots</name> &lt;= <name>nblocks</name></expr>)</condition>
    <expr_stmt><expr><name>nslots</name> *= 2</expr>;</expr_stmt></while>
  <comment type="block">/* Double the number of slots to avoid a too high load. */</comment>
  <expr_stmt><expr><name>nslots</name> *= 2</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>blocks</name>-&gt;<name>max</name></name> = <name>nslots</name> - 1</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>blocks</name>-&gt;<name>slots</name></name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>nslots</name> * <sizeof>sizeof<argument_list>(<argument><expr>*(<name><name>blocks</name>-&gt;<name>slots</name></name>)</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>nslots</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>)
    <block>{
      <comment type="block">/* Avoid using an indeterminate value in the lookup. */</comment>
      <expr_stmt><expr><name><name>blocks</name>-&gt;<name>slots</name><index>[<expr><name>i</name></expr>]</index></name>.<name>adlersum</name> = 0</expr>;</expr_stmt>
      <expr_stmt><expr><name><name>blocks</name>-&gt;<name>slots</name><index>[<expr><name>i</name></expr>]</index></name>.<name>pos</name> = (<name>apr_size_t</name>)-1</expr>;</expr_stmt>
    }</block></for>

  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>datalen</name></expr>;</condition> <incr><expr><name>i</name> += <name>MATCH_BLOCKSIZE</name></expr></incr>)
    <block>{
      <comment type="block">/* If this is the last piece, it may be blocksize large */</comment>
      <decl_stmt><decl><type><name>apr_uint32_t</name></type> <name>step</name> <init>=
        <expr>((<name>i</name> + <name>MATCH_BLOCKSIZE</name>) &gt;= <name>datalen</name>) ? (<name>datalen</name> - <name>i</name>) : <name>MATCH_BLOCKSIZE</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_uint32_t</name></type> <name>adlersum</name> <init>=
        <expr><call><name>adler32_sum</name><argument_list>(<argument><expr><call><name>init_adler32</name><argument_list>(<argument><expr>&amp;<name>adler</name></expr></argument>, <argument><expr><name>data</name> + <name>i</name></expr></argument>, <argument><expr><name>step</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>add_block</name><argument_list>(<argument><expr><name>blocks</name></expr></argument>, <argument><expr><name>adlersum</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
}</block></function>

<comment type="block">/* Try to find a match for the target data B in BLOCKS, and then
   extend the match as long as data in A and B at the match position
   continues to match.  We set the position in a we ended up in (in
   case we extended it backwards) in APOSP, the length of the match in
   ALENP, and the amount to advance B in BADVANCEP.
   *PENDING_INSERT_LENP is the length of the last insert operation that
   has not been committed yet to the delta stream, or 0 if there is no
   pending insert.  This is used when extending the match backwards,
   in which case *PENDING_INSERT_LENP is adjusted, possibly
   alleviating the need for the insert entirely.  Return TRUE if the
   lookup found a match, regardless of length.  Return FALSE
   otherwise.  */</comment>
<function><type><specifier>static</specifier> <name>svn_boolean_t</name></type>
<name>find_match</name><parameter_list>(<param><decl><type><specifier>const</specifier> struct <name>blocks</name> *</type><name>blocks</name></decl></param>,
           <param><decl><type><specifier>const</specifier> struct <name>adler32</name> *</type><name>rolling</name></decl></param>,
           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>a</name></decl></param>,
           <param><decl><type><name>apr_size_t</name></type> <name>asize</name></decl></param>,
           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>b</name></decl></param>,
           <param><decl><type><name>apr_size_t</name></type> <name>bsize</name></decl></param>,
           <param><decl><type><name>apr_size_t</name></type> <name>bpos</name></decl></param>,
           <param><decl><type><name>apr_size_t</name> *</type><name>aposp</name></decl></param>,
           <param><decl><type><name>apr_size_t</name> *</type><name>alenp</name></decl></param>,
           <param><decl><type><name>apr_size_t</name> *</type><name>badvancep</name></decl></param>,
           <param><decl><type><name>apr_size_t</name> *</type><name>pending_insert_lenp</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_uint32_t</name></type> <name>sum</name> <init>= <expr><call><name>adler32_sum</name><argument_list>(<argument><expr><name>rolling</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>alen</name></decl>, <decl><type ref="prev"/><name>badvance</name></decl>, <decl><type ref="prev"/><name>apos</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>tpos</name></decl>, <decl><type ref="prev"/><name>tlen</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>tpos</name> = <call><name>find_block</name><argument_list>(<argument><expr><name>blocks</name></expr></argument>, <argument><expr><name>sum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* See if we have a match.  */</comment>
  <if>if <condition>(<expr><name>tpos</name> == (<name>apr_size_t</name>)-1</expr>)</condition><then>
    <return>return <expr><name>FALSE</name></expr>;</return></then></if>

  <expr_stmt><expr><name>tlen</name> = ((<name>tpos</name> + <name>MATCH_BLOCKSIZE</name>) &gt;= <name>asize</name>)
    ? (<name>asize</name> - <name>tpos</name>) : <name>MATCH_BLOCKSIZE</name></expr>;</expr_stmt>

  <comment type="block">/* Make sure it's not a false match.  */</comment>
  <if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>a</name> + <name>tpos</name></expr></argument>, <argument><expr><name>b</name> + <name>bpos</name></expr></argument>, <argument><expr><name>tlen</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
    <return>return <expr><name>FALSE</name></expr>;</return></then></if>

  <expr_stmt><expr><name>apos</name> = <name>tpos</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>alen</name> = <name>tlen</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>badvance</name> = <name>tlen</name></expr>;</expr_stmt>
  <comment type="block">/* Extend the match forward as far as possible */</comment>
  <while>while <condition>(<expr>(<name>apos</name> + <name>alen</name> &lt; <name>asize</name>)
         &amp;&amp; (<name>bpos</name> + <name>badvance</name> &lt; <name>bsize</name>)
         &amp;&amp; (<name><name>a</name><index>[<expr><name>apos</name> + <name>alen</name></expr>]</index></name> == <name><name>b</name><index>[<expr><name>bpos</name> + <name>badvance</name></expr>]</index></name>)</expr>)</condition>
    <block>{
      <expr_stmt><expr>++<name>alen</name></expr>;</expr_stmt>
      <expr_stmt><expr>++<name>badvance</name></expr>;</expr_stmt>
    }</block></while>

  <comment type="block">/* See if we can extend backwards into a previous insert hunk.  */</comment>
  <while>while <condition>(<expr><name>apos</name> &gt; 0
         &amp;&amp; <name>bpos</name> &gt; 0
         &amp;&amp; <name><name>a</name><index>[<expr><name>apos</name> - 1</expr>]</index></name> == <name><name>b</name><index>[<expr><name>bpos</name> - 1</expr>]</index></name>
         &amp;&amp; *<name>pending_insert_lenp</name> &gt; 0</expr>)</condition>
    <block>{
      <expr_stmt><expr>--(*<name>pending_insert_lenp</name>)</expr>;</expr_stmt>
      <expr_stmt><expr>--<name>apos</name></expr>;</expr_stmt>
      <expr_stmt><expr>--<name>bpos</name></expr>;</expr_stmt>
      <expr_stmt><expr>++<name>alen</name></expr>;</expr_stmt>
    }</block></while>

  <expr_stmt><expr>*<name>aposp</name> = <name>apos</name></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>alenp</name> = <name>alen</name></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>badvancep</name> = <name>badvance</name></expr>;</expr_stmt>
  <return>return <expr><name>TRUE</name></expr>;</return>
}</block></function>


<comment type="block">/* Compute a delta from A to B using xdelta.

   The basic xdelta algorithm is as follows:

   1. Go through the source data, checksumming every MATCH_BLOCKSIZE
      block of bytes using adler32, and inserting the checksum into a
      match table with the position of the match.
   2. Go through the target byte by byte, seeing if that byte starts a
      match that we have in the match table.
      2a. If so, try to extend the match as far as possible both
          forwards and backwards, and then insert a source copy
          operation into the delta ops builder for the match.
      2b. If not, insert the byte as new data using an insert delta op.

   Our implementation doesn't immediately insert "insert" operations,
   it waits until we have another copy, or we are done.  The reasoning
   is twofold:

   1. Otherwise, we would just be building a ton of 1 byte insert
      operations
   2. So that we can extend a source match backwards into a pending
     insert operation, and possibly remove the need for the insert
     entirely.  This can happen due to stream alignment.
*/</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>compute_delta</name><parameter_list>(<param><decl><type><name>svn_txdelta__ops_baton_t</name> *</type><name>build_baton</name></decl></param>,
              <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>a</name></decl></param>,
              <param><decl><type><name>apr_uint32_t</name></type> <name>asize</name></decl></param>,
              <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>b</name></decl></param>,
              <param><decl><type><name>apr_uint32_t</name></type> <name>bsize</name></decl></param>,
              <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>blocks</name></type> <name>blocks</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>adler32</name></type> <name>rolling</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>sz</name></decl>, <decl><type ref="prev"/><name>lo</name></decl>, <decl><type ref="prev"/><name>hi</name></decl>, <decl><type ref="prev"/><name>pending_insert_start</name> <init>= <expr>0</expr></init>, <name>pending_insert_len</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

  <comment type="block">/* If the size of the target is smaller than the match blocksize, just
     insert the entire target.  */</comment>
  <if>if <condition>(<expr><name>bsize</name> &lt; <name>MATCH_BLOCKSIZE</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>svn_txdelta__insert_op</name><argument_list>(<argument><expr><name>build_baton</name></expr></argument>, <argument><expr><name>svn_txdelta_new</name></expr></argument>,
                             <argument><expr>0</expr></argument>, <argument><expr><name>bsize</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return;</return>
    }</block></then></if>

  <comment type="block">/* Initialize the matches table.  */</comment>
  <expr_stmt><expr><call><name>init_blocks_table</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>asize</name></expr></argument>, <argument><expr>&amp;<name>blocks</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Initialize our rolling checksum.  */</comment>
  <expr_stmt><expr><call><name>init_adler32</name><argument_list>(<argument><expr>&amp;<name>rolling</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>MATCH_BLOCKSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for (<init><expr><name>sz</name> = <name>bsize</name></expr>, <expr><name>lo</name> = 0</expr>, <expr><name>hi</name> = <name>MATCH_BLOCKSIZE</name></expr>;</init> <condition><expr><name>lo</name> &lt; <name>sz</name></expr>;</condition><incr/>)
    <block>{
      <decl_stmt><decl><type><name>apr_size_t</name></type> <name>apos</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_size_t</name></type> <name>alen</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_size_t</name></type> <name>badvance</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_size_t</name></type> <name>next</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>match</name></decl>;</decl_stmt>

      <expr_stmt><expr><name>match</name> = <call><name>find_match</name><argument_list>(<argument><expr>&amp;<name>blocks</name></expr></argument>, <argument><expr>&amp;<name>rolling</name></expr></argument>, <argument><expr><name>a</name></expr></argument>, <argument><expr><name>asize</name></expr></argument>, <argument><expr><name>b</name></expr></argument>, <argument><expr><name>bsize</name></expr></argument>, <argument><expr><name>lo</name></expr></argument>, <argument><expr>&amp;<name>apos</name></expr></argument>,
                         <argument><expr>&amp;<name>alen</name></expr></argument>, <argument><expr>&amp;<name>badvance</name></expr></argument>, <argument><expr>&amp;<name>pending_insert_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* If we didn't find a real match, insert the byte at the target
         position into the pending insert.  */</comment>
      <if>if <condition>(<expr>! <name>match</name></expr>)</condition><then>
        <expr_stmt><expr>++<name>pending_insert_len</name></expr>;</expr_stmt></then>
      <else>else
        <block>{
          <if>if <condition>(<expr><name>pending_insert_len</name> &gt; 0</expr>)</condition><then>
            <block>{
              <expr_stmt><expr><call><name>svn_txdelta__insert_op</name><argument_list>(<argument><expr><name>build_baton</name></expr></argument>, <argument><expr><name>svn_txdelta_new</name></expr></argument>,
                                     <argument><expr>0</expr></argument>, <argument><expr><name>pending_insert_len</name></expr></argument>,
                                     <argument><expr><name>b</name> + <name>pending_insert_start</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>pending_insert_len</name> = 0</expr>;</expr_stmt>
            }</block></then></if>
          <comment type="block">/* Reset the pending insert start to immediately after the
             match. */</comment>
          <expr_stmt><expr><name>pending_insert_start</name> = <name>lo</name> + <name>badvance</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>svn_txdelta__insert_op</name><argument_list>(<argument><expr><name>build_baton</name></expr></argument>, <argument><expr><name>svn_txdelta_source</name></expr></argument>,
                                 <argument><expr><name>apos</name></expr></argument>, <argument><expr><name>alen</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
      <expr_stmt><expr><name>next</name> = <name>lo</name></expr>;</expr_stmt>
      <for>for (<init>;</init> <condition><expr><name>next</name> &lt; <name>lo</name> + <name>badvance</name></expr>;</condition> <incr><expr>++<name>next</name></expr></incr>)
        <block>{
          <expr_stmt><expr><call><name>adler32_out</name><argument_list>(<argument><expr>&amp;<name>rolling</name></expr></argument>, <argument><expr><name><name>b</name><index>[<expr><name>next</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>next</name> + <name>MATCH_BLOCKSIZE</name> &lt; <name>bsize</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>adler32_in</name><argument_list>(<argument><expr>&amp;<name>rolling</name></expr></argument>, <argument><expr><name><name>b</name><index>[<expr><name>next</name> + <name>MATCH_BLOCKSIZE</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        }</block></for>
      <expr_stmt><expr><name>lo</name> = <name>next</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>hi</name> = <name>lo</name> + <name>MATCH_BLOCKSIZE</name></expr>;</expr_stmt>
    }</block></for>

  <comment type="block">/* If we still have an insert pending at the end, throw it in.  */</comment>
  <if>if <condition>(<expr><name>pending_insert_len</name> &gt; 0</expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>svn_txdelta__insert_op</name><argument_list>(<argument><expr><name>build_baton</name></expr></argument>, <argument><expr><name>svn_txdelta_new</name></expr></argument>,
                             <argument><expr>0</expr></argument>, <argument><expr><name>pending_insert_len</name></expr></argument>,
                             <argument><expr><name>b</name> + <name>pending_insert_start</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
}</block></function>

<function><type><name>void</name></type>
<name>svn_txdelta__xdelta</name><parameter_list>(<param><decl><type><name>svn_txdelta__ops_baton_t</name> *</type><name>build_baton</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name></decl></param>,
                    <param><decl><type><name>apr_size_t</name></type> <name>source_len</name></decl></param>,
                    <param><decl><type><name>apr_size_t</name></type> <name>target_len</name></decl></param>,
                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/*  We should never be asked to compute something when the source_len is 0,
      because it should have asked vdelta or some other compressor.  */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>source_len</name> != 0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>compute_delta</name><argument_list>(<argument><expr><name>build_baton</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>source_len</name></expr></argument>,
                <argument><expr><name>data</name> + <name>source_len</name></expr></argument>, <argument><expr><name>target_len</name></expr></argument>,
                <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
</unit>
