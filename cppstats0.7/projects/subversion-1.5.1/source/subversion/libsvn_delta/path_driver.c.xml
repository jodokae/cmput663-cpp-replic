<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/subversion-1.5.1/source/subversion/libsvn_delta/path_driver.c"><comment type="block">/*
 * path_driver.c -- drive an editor across a set of paths
 *
 * ====================================================================
 * Copyright (c) 2000-2007 CollabNet.  All rights reserved.
 *
 * This software is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at http://subversion.tigris.org/license-1.html.
 * If newer versions of this license are posted there, you may use a
 * newer version instead, at your option.
 *
 * This software consists of voluntary contributions made by many
 * individuals.  For exact contribution history, see the revision
 * history and logs, available at http://subversion.tigris.org/.
 * ====================================================================
 */</comment>


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_pools.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_strings.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_types.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_delta.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_pools.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_path.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_sorts.h"</cpp:file></cpp:include>

<escape char="0xc"/>
<comment type="block">/*** Helper functions. ***/</comment>

<typedef>typedef <type><struct>struct <name>dir_stack_t</name>
<block>{
  <decl_stmt><decl><type><name>void</name> *</type><name>dir_baton</name></decl>;</decl_stmt>   <comment type="block">/* the dir baton. */</comment>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>  <comment type="block">/* the pool associated with the dir baton. */</comment>

}</block></struct></type> <name>dir_stack_t</name>;</typedef>


<comment type="block">/* Call EDITOR's open_directory() function with the PATH and REVISION
 * arguments, and then add the resulting dir baton to the dir baton
 * stack.
 */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>open_dir</name><parameter_list>(<param><decl><type><name>apr_array_header_t</name> *</type><name>db_stack</name></decl></param>,
         <param><decl><type><specifier>const</specifier> <name>svn_delta_editor_t</name> *</type><name>editor</name></decl></param>,
         <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
         <param><decl><type><name>svn_revnum_t</name></type> <name>revision</name></decl></param>,
         <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>void</name> *</type><name>parent_db</name></decl>, *<decl><type ref="prev"/><name>db</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dir_stack_t</name> *</type><name>item</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name></decl>;</decl_stmt>

  <comment type="block">/* Assert that we are in a stable state. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>db_stack</name> &amp;&amp; <name><name>db_stack</name>-&gt;<name>nelts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Get the parent dir baton. */</comment>
  <expr_stmt><expr><name>item</name> = <call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>db_stack</name></expr></argument>, <argument><expr><name><name>db_stack</name>-&gt;<name>nelts</name></name> - 1</expr></argument>, <argument><expr><name>void</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>parent_db</name> = <name><name>item</name>-&gt;<name>dir_baton</name></name></expr>;</expr_stmt>

  <comment type="block">/* Call the EDITOR's open_directory function to get a new directory
     baton. */</comment>
  <expr_stmt><expr><name>subpool</name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>editor</name>-&gt;<name>open_directory</name></name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>parent_db</name></expr></argument>, <argument><expr><name>revision</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>, <argument><expr>&amp;<name>db</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Now add the dir baton to the stack. */</comment>
  <expr_stmt><expr><name>item</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>item</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>item</name>-&gt;<name>dir_baton</name></name> = <name>db</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>item</name>-&gt;<name>pool</name></name> = <name>subpool</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>db_stack</name></expr></argument>, <argument><expr><name>dir_stack_t</name> *</expr></argument>)</argument_list></call> = <name>item</name></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Pop a directory from the dir baton stack and update the stack
 * pointer.
 *
 * This function calls the EDITOR's close_directory() function.
 */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>pop_stack</name><parameter_list>(<param><decl><type><name>apr_array_header_t</name> *</type><name>db_stack</name></decl></param>,
          <param><decl><type><specifier>const</specifier> <name>svn_delta_editor_t</name> *</type><name>editor</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>dir_stack_t</name> *</type><name>item</name></decl>;</decl_stmt>

  <comment type="block">/* Assert that we are in a stable state. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>db_stack</name> &amp;&amp; <name><name>db_stack</name>-&gt;<name>nelts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Close the most recent directory pushed to the stack. */</comment>
  <expr_stmt><expr><name>item</name> = <call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>db_stack</name></expr></argument>, <argument><expr><name><name>db_stack</name>-&gt;<name>nelts</name></name> - 1</expr></argument>, <argument><expr><name>dir_stack_t</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>(<name>void</name>) <call><name>apr_array_pop</name><argument_list>(<argument><expr><name>db_stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>editor</name>-&gt;<name>close_directory</name></name><argument_list>(<argument><expr><name><name>item</name>-&gt;<name>dir_baton</name></name></expr></argument>, <argument><expr><name><name>item</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name><name>item</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Count the number of path components in PATH. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>count_components</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>instance</name> <init>= <expr><name>path</name></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr>(<call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call> == 1) &amp;&amp; (<name><name>path</name><index>[<expr>0</expr>]</index></name> == '/')</expr>)</condition><then>
    <return>return <expr>0</expr>;</return></then></if>

  <do>do
    <block>{
      <expr_stmt><expr><name>instance</name>++</expr>;</expr_stmt>
      <expr_stmt><expr><name>instance</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>instance</name></expr></argument>, <argument><expr>'/'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>instance</name></expr>)</condition><then>
        <expr_stmt><expr><name>count</name>++</expr>;</expr_stmt></then></if>
    }</block>
  while <condition>(<expr><name>instance</name></expr>)</condition>;</do>

  <return>return <expr><name>count</name></expr>;</return>
}</block></function>


<escape char="0xc"/>
<comment type="block">/*** Public interfaces ***/</comment>
<function><type><name>svn_error_t</name> *</type>
<name>svn_delta_path_driver</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>svn_delta_editor_t</name> *</type><name>editor</name></decl></param>,
                      <param><decl><type><name>void</name> *</type><name>edit_baton</name></decl></param>,
                      <param><decl><type><name>svn_revnum_t</name></type> <name>revision</name></decl></param>,
                      <param><decl><type><name>apr_array_header_t</name> *</type><name>paths</name></decl></param>,
                      <param><decl><type><name>svn_delta_path_driver_cb_func_t</name></type> <name>callback_func</name></decl></param>,
                      <param><decl><type><name>void</name> *</type><name>callback_baton</name></decl></param>,
                      <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>db_stack</name> <init>= <expr><call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>4</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>void</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>last_path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> *</type><name>parent_db</name> <init>= <expr><name>NULL</name></expr></init>, *<name>db</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name></decl>, *<decl><type ref="prev"/><name>iterpool</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dir_stack_t</name> *</type><name>item</name></decl>;</decl_stmt>

  <comment type="block">/* Do nothing if there are no paths. */</comment>
  <if>if <condition>(<expr>! <name><name>paths</name>-&gt;<name>nelts</name></name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <expr_stmt><expr><name>subpool</name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>iterpool</name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>item</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>item</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Sort the paths in a depth-first directory-ish order. */</comment>
  <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name><name>paths</name>-&gt;<name>elts</name></name></expr></argument>, <argument><expr><name><name>paths</name>-&gt;<name>nelts</name></name></expr></argument>, <argument><expr><name><name>paths</name>-&gt;<name>elt_size</name></name></expr></argument>, <argument><expr><name>svn_sort_compare_paths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If the root of the edit is also a target path, we want to call
     the callback function to let the user open the root directory and
     do what needs to be done.  Otherwise, we'll do the open_root()
     ourselves. */</comment>
  <expr_stmt><expr><name>path</name> = <call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>paths</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><call><name>svn_path_is_empty</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>callback_func</name><argument_list>(<argument><expr>&amp;<name>db</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>callback_baton</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>last_path</name> = <name>path</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>editor</name>-&gt;<name>open_root</name></name><argument_list>(<argument><expr><name>edit_baton</name></expr></argument>, <argument><expr><name>revision</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>, <argument><expr>&amp;<name>db</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
  <expr_stmt><expr><name><name>item</name>-&gt;<name>pool</name></name> = <name>subpool</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>item</name>-&gt;<name>dir_baton</name></name> = <name>db</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>db_stack</name></expr></argument>, <argument><expr><name>void</name> *</expr></argument>)</argument_list></call> = <name>item</name></expr>;</expr_stmt>

  <comment type="block">/* Now, loop over the commit items, traversing the URL tree and
     driving the editor. */</comment>
  <for>for (<init>;</init> <condition><expr><name>i</name> &lt; <name><name>paths</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>pdir</name></decl>, *<decl><type ref="prev"/><name>bname</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>common</name> <init>= <expr>""</expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>size_t</name></type> <name>common_len</name></decl>;</decl_stmt>

      <comment type="block">/* Clear the iteration pool. */</comment>
      <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Get the next path. */</comment>
      <expr_stmt><expr><name>path</name> = <call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>paths</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/*** Step A - Find the common ancestor of the last path and the
           current one.  For the first iteration, this is just the
           empty string. ***/</comment>
      <if>if <condition>(<expr><name>i</name> &gt; 0</expr>)</condition><then>
        <expr_stmt><expr><name>common</name> = <call><name>svn_path_get_longest_ancestor</name><argument_list>(<argument><expr><name>last_path</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
      <expr_stmt><expr><name>common_len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>common</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/*** Step B - Close any directories between the last path and
           the new common ancestor, if any need to be closed.
           Sometimes there is nothing to do here (like, for the first
           iteration, or when the last path was an ancestor of the
           current one). ***/</comment>
      <if>if <condition>(<expr>(<name>i</name> &gt; 0) &amp;&amp; (<call><name>strlen</name><argument_list>(<argument><expr><name>last_path</name></expr></argument>)</argument_list></call> &gt; <name>common_len</name>)</expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>rel</name> <init>= <expr><name>last_path</name> + (<name>common_len</name> ? (<name>common_len</name> + 1) : 0)</expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><call><name>count_components</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <while>while <condition>(<expr><name>count</name>--</expr>)</condition>
            <block>{
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>pop_stack</name><argument_list>(<argument><expr><name>db_stack</name></expr></argument>, <argument><expr><name>editor</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></while>
        }</block></then></if>

      <comment type="block">/*** Step C - Open any directories between the common ancestor
           and the parent of the current path. ***/</comment>
      <expr_stmt><expr><call><name>svn_path_split</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>&amp;<name>pdir</name></expr></argument>, <argument><expr>&amp;<name>bname</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>pdir</name></expr></argument>)</argument_list></call> &gt; <name>common_len</name></expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>piece</name> <init>= <expr><name>pdir</name> + <name>common_len</name> + 1</expr></init></decl>;</decl_stmt>

          <while>while <condition>(<expr>1</expr>)</condition>
            <block>{
              <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>rel</name> <init>= <expr><name>pdir</name></expr></init></decl>;</decl_stmt>

              <comment type="block">/* Find the first separator. */</comment>
              <expr_stmt><expr><name>piece</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>piece</name></expr></argument>, <argument><expr>'/'</expr></argument>)</argument_list></call></expr>;</expr_stmt>

              <comment type="block">/* Calculate REL as the portion of PDIR up to (but not
                 including) the location to which PIECE is pointing. */</comment>
              <if>if <condition>(<expr><name>piece</name></expr>)</condition><then>
                <expr_stmt><expr><name>rel</name> = <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>, <argument><expr><name>pdir</name></expr></argument>, <argument><expr><name>piece</name> - <name>pdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

              <comment type="block">/* Open the subdirectory. */</comment>
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>open_dir</name><argument_list>(<argument><expr><name>db_stack</name></expr></argument>, <argument><expr><name>editor</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><name>revision</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

              <comment type="block">/* If we found a '/', advance our PIECE pointer to
                 character just after that '/'.  Otherwise, we're
                 done.  */</comment>
              <if>if <condition>(<expr><name>piece</name></expr>)</condition><then>
                <expr_stmt><expr><name>piece</name>++</expr>;</expr_stmt></then>
              <else>else
                <break>break;</break></else></if>
            }</block></while>
        }</block></then></if>

      <comment type="block">/*** Step D - Tell our caller to handle the current path. ***/</comment>
      <expr_stmt><expr><name>item</name> = <call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>db_stack</name></expr></argument>, <argument><expr><name><name>db_stack</name>-&gt;<name>nelts</name></name> - 1</expr></argument>, <argument><expr><name>void</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>parent_db</name> = <name><name>item</name>-&gt;<name>dir_baton</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>subpool</name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>callback_func</name><argument_list>(<argument><expr>&amp;<name>db</name></expr></argument>, <argument><expr><name>parent_db</name></expr></argument>, <argument><expr><name>callback_baton</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>db</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>item</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>item</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>item</name>-&gt;<name>dir_baton</name></name> = <name>db</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>item</name>-&gt;<name>pool</name></name> = <name>subpool</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>db_stack</name></expr></argument>, <argument><expr><name>void</name> *</expr></argument>)</argument_list></call> = <name>item</name></expr>;</expr_stmt>
        }</block></then>
      <else>else
        <block>{
          <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>

      <comment type="block">/*** Step E - Save our state for the next iteration.  If our
           caller opened or added PATH as a directory, that becomes
           our LAST_PATH.  Otherwise, we use PATH's parent
           directory. ***/</comment>

      <comment type="block">/* NOTE:  The variable LAST_PATH needs to outlive the loop. */</comment>
      <if>if <condition>(<expr><name>db</name></expr>)</condition><then>
        <expr_stmt><expr><name>last_path</name> = <name>path</name></expr>;</expr_stmt></then> <comment type="block">/* lives in a pool outside our control. */</comment>
      <else>else
        <expr_stmt><expr><name>last_path</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>pdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if> <comment type="block">/* duping into POOL. */</comment>
    }</block></for>

  <comment type="block">/* Destroy the iteration subpool. */</comment>
  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Close down any remaining open directory batons. */</comment>
  <while>while <condition>(<expr><name><name>db_stack</name>-&gt;<name>nelts</name></name></expr>)</condition>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>pop_stack</name><argument_list>(<argument><expr><name>db_stack</name></expr></argument>, <argument><expr><name>editor</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></while>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
</unit>
