<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/subversion-1.5.1/source/subversion/libsvn_diff/util.c"><comment type="block">/*
 * util.c :  routines for doing diffs
 *
 * ====================================================================
 * Copyright (c) 2000-2004 CollabNet.  All rights reserved.
 *
 * This software is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at http://subversion.tigris.org/license-1.html.
 * If newer versions of this license are posted there, you may use a
 * newer version instead, at your option.
 *
 * This software consists of voluntary contributions made by many
 * individuals.  For exact contribution history, see the revision
 * history and logs, available at http://subversion.tigris.org/.
 * ====================================================================
 */</comment>


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_general.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_error.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_diff.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_types.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_ctype.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"diff.h"</cpp:file></cpp:include>

<comment type="block">/**
 * An Adler-32 implementation per RFC1950.
 *
 * "The Adler-32 algorithm is much faster than the CRC32 algorithm yet
 * still provides an extremely low probability of undetected errors"
 */</comment>

<comment type="block">/*
 * 65521 is the largest prime less than 65536.
 * "That 65521 is prime is important to avoid a possible large class of
 *  two-byte errors that leave the check unchanged."
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADLER_MOD_BASE</name></cpp:macro> <cpp:value>65521</cpp:value></cpp:define>

<comment type="block">/*
 * "The modulo on unsigned long accumulators can be delayed for 5552 bytes,
 *  so the modulo operation time is negligible."
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADLER_MOD_BLOCK_SIZE</name></cpp:macro> <cpp:value>5552</cpp:value></cpp:define>


<comment type="block">/*
 * Start with CHECKSUM and update the checksum by processing a chunk
 * of DATA sized LEN.
 */</comment>
<function><type><name>apr_uint32_t</name></type>
<name>svn_diff__adler32</name><parameter_list>(<param><decl><type><name>apr_uint32_t</name></type> <name>checksum</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name></decl></param>, <param><decl><type><name>apr_size_t</name></type> <name>len</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>input</name> <init>= <expr>(const <name>unsigned</name> <name>char</name> *)<name>data</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_uint32_t</name></type> <name>s1</name> <init>= <expr><name>checksum</name> &amp; 0xFFFF</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_uint32_t</name></type> <name>s2</name> <init>= <expr><name>checksum</name> &gt;&gt; 16</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_uint32_t</name></type> <name>b</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>blocks</name> <init>= <expr><name>len</name> / <name>ADLER_MOD_BLOCK_SIZE</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>len</name> %= <name>ADLER_MOD_BLOCK_SIZE</name></expr>;</expr_stmt>

  <while>while <condition>(<expr><name>blocks</name>--</expr>)</condition>
    <block>{
      <decl_stmt><decl><type><name>int</name></type> <name>count</name> <init>= <expr><name>ADLER_MOD_BLOCK_SIZE</name></expr></init></decl>;</decl_stmt>
      <while>while <condition>(<expr><name>count</name>--</expr>)</condition>
        <block>{
          <expr_stmt><expr><name>b</name> = *<name>input</name>++</expr>;</expr_stmt>
          <expr_stmt><expr><name>s1</name> += <name>b</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>s2</name> += <name>s1</name></expr>;</expr_stmt>
        }</block></while>

      <expr_stmt><expr><name>s1</name> %= <name>ADLER_MOD_BASE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>s2</name> %= <name>ADLER_MOD_BASE</name></expr>;</expr_stmt>
    }</block></while>

  <while>while <condition>(<expr><name>len</name>--</expr>)</condition>
    <block>{
      <expr_stmt><expr><name>b</name> = *<name>input</name>++</expr>;</expr_stmt>
      <expr_stmt><expr><name>s1</name> += <name>b</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>s2</name> += <name>s1</name></expr>;</expr_stmt>
    }</block></while>

  <return>return <expr>((<name>s2</name> % <name>ADLER_MOD_BASE</name>) &lt;&lt; 16) | (<name>s1</name> % <name>ADLER_MOD_BASE</name>)</expr>;</return>
}</block></function>


<function><type><name>svn_boolean_t</name></type>
<name>svn_diff_contains_conflicts</name><parameter_list>(<param><decl><type><name>svn_diff_t</name> *</type><name>diff</name></decl></param>)</parameter_list>
<block>{
  <while>while <condition>(<expr><name>diff</name> != <name>NULL</name></expr>)</condition>
    <block>{
      <if>if <condition>(<expr><name><name>diff</name>-&gt;<name>type</name></name> == <name>svn_diff__type_conflict</name></expr>)</condition><then>
        <block>{
          <return>return <expr><name>TRUE</name></expr>;</return>
        }</block></then></if>

      <expr_stmt><expr><name>diff</name> = <name><name>diff</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
    }</block></while>

  <return>return <expr><name>FALSE</name></expr>;</return>
}</block></function>

<function><type><name>svn_boolean_t</name></type>
<name>svn_diff_contains_diffs</name><parameter_list>(<param><decl><type><name>svn_diff_t</name> *</type><name>diff</name></decl></param>)</parameter_list>
<block>{
  <while>while <condition>(<expr><name>diff</name> != <name>NULL</name></expr>)</condition>
    <block>{
      <if>if <condition>(<expr><name><name>diff</name>-&gt;<name>type</name></name> != <name>svn_diff__type_common</name></expr>)</condition><then>
        <block>{
          <return>return <expr><name>TRUE</name></expr>;</return>
        }</block></then></if>

      <expr_stmt><expr><name>diff</name> = <name><name>diff</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
    }</block></while>

  <return>return <expr><name>FALSE</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_diff_output</name><parameter_list>(<param><decl><type><name>svn_diff_t</name> *</type><name>diff</name></decl></param>,
                <param><decl><type><name>void</name> *</type><name>output_baton</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>svn_diff_output_fns_t</name> *</type><name>vtable</name></decl></param>)</parameter_list>
<block>{
  <function_decl><type><name>svn_error_t</name> *</type>(*<name>output_fn</name>)<parameter_list>(<param><decl><type><name>void</name> *</type></decl></param>,
                            <param><decl><type><name>apr_off_t</name></type></decl></param>, <param><decl><type><name>apr_off_t</name></type></decl></param>,
                            <param><decl><type><name>apr_off_t</name></type></decl></param>, <param><decl><type><name>apr_off_t</name></type></decl></param>,
                            <param><decl><type><name>apr_off_t</name></type></decl></param>, <param><decl><type><name>apr_off_t</name></type></decl></param>)</parameter_list>;</function_decl>

  <while>while <condition>(<expr><name>diff</name> != <name>NULL</name></expr>)</condition>
    <block>{
      <switch>switch <condition>(<expr><name><name>diff</name>-&gt;<name>type</name></name></expr>)</condition>
        <block>{
        <case>case <expr><name>svn_diff__type_common</name></expr>:
          <expr_stmt><expr><name>output_fn</name> = <name><name>vtable</name>-&gt;<name>output_common</name></name></expr>;</expr_stmt>
          <break>break;</break>

        </case><case>case <expr><name>svn_diff__type_diff_common</name></expr>:
          <expr_stmt><expr><name>output_fn</name> = <name><name>vtable</name>-&gt;<name>output_diff_common</name></name></expr>;</expr_stmt>
          <break>break;</break>

        </case><case>case <expr><name>svn_diff__type_diff_modified</name></expr>:
          <expr_stmt><expr><name>output_fn</name> = <name><name>vtable</name>-&gt;<name>output_diff_modified</name></name></expr>;</expr_stmt>
          <break>break;</break>

        </case><case>case <expr><name>svn_diff__type_diff_latest</name></expr>:
          <expr_stmt><expr><name>output_fn</name> = <name><name>vtable</name>-&gt;<name>output_diff_latest</name></name></expr>;</expr_stmt>
          <break>break;</break>

        </case><case>case <expr><name>svn_diff__type_conflict</name></expr>:
          <expr_stmt><expr><name>output_fn</name> = <name>NULL</name></expr>;</expr_stmt>
          <if>if <condition>(<expr><name><name>vtable</name>-&gt;<name>output_conflict</name></name> != <name>NULL</name></expr>)</condition><then>
            <block>{
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>vtable</name>-&gt;<name>output_conflict</name></name><argument_list>(<argument><expr><name>output_baton</name></expr></argument>,
                               <argument><expr><name><name>diff</name>-&gt;<name>original_start</name></name></expr></argument>, <argument><expr><name><name>diff</name>-&gt;<name>original_length</name></name></expr></argument>,
                               <argument><expr><name><name>diff</name>-&gt;<name>modified_start</name></name></expr></argument>, <argument><expr><name><name>diff</name>-&gt;<name>modified_length</name></name></expr></argument>,
                               <argument><expr><name><name>diff</name>-&gt;<name>latest_start</name></name></expr></argument>, <argument><expr><name><name>diff</name>-&gt;<name>latest_length</name></name></expr></argument>,
                               <argument><expr><name><name>diff</name>-&gt;<name>resolved_diff</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
          <break>break;</break>

        </case><default>default:
          <expr_stmt><expr><name>output_fn</name> = <name>NULL</name></expr>;</expr_stmt>
          <break>break;</break>
        </default>}</block></switch>

      <if>if <condition>(<expr><name>output_fn</name> != <name>NULL</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>output_fn</name><argument_list>(<argument><expr><name>output_baton</name></expr></argument>,
                            <argument><expr><name><name>diff</name>-&gt;<name>original_start</name></name></expr></argument>, <argument><expr><name><name>diff</name>-&gt;<name>original_length</name></name></expr></argument>,
                            <argument><expr><name><name>diff</name>-&gt;<name>modified_start</name></name></expr></argument>, <argument><expr><name><name>diff</name>-&gt;<name>modified_length</name></name></expr></argument>,
                            <argument><expr><name><name>diff</name>-&gt;<name>latest_start</name></name></expr></argument>, <argument><expr><name><name>diff</name>-&gt;<name>latest_length</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

      <expr_stmt><expr><name>diff</name> = <name><name>diff</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
    }</block></while>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>void</name></type>
<name>svn_diff__normalize_buffer</name><parameter_list>(<param><decl><type><name>char</name> **</type><name>tgt</name></decl></param>,
                           <param><decl><type><name>apr_off_t</name> *</type><name>lengthp</name></decl></param>,
                           <param><decl><type><name>svn_diff__normalize_state_t</name> *</type><name>statep</name></decl></param>,
                           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>buf</name></decl></param>,
                           <param><decl><type><specifier>const</specifier> <name>svn_diff_file_options_t</name> *</type><name>opts</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* Variables for looping through BUF */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>curp</name></decl>, *<decl><type ref="prev"/><name>endp</name></decl>;</decl_stmt>

  <comment type="block">/* Variable to record normalizing state */</comment>
  <decl_stmt><decl><type><name>svn_diff__normalize_state_t</name></type> <name>state</name> <init>= <expr>*<name>statep</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Variables to track what needs copying into the target buffer */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>start</name> <init>= <expr><name>buf</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>include_len</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>last_skipped</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt> <comment type="block">/* makes sure we set 'start' */</comment>

  <comment type="block">/* Variable to record the state of the target buffer */</comment>
  <decl_stmt><decl><type><name>char</name> *</type><name>tgt_newend</name> <init>= <expr>*<name>tgt</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* If this is a noop, then just get out of here. */</comment>
  <if>if <condition>(<expr>! <name><name>opts</name>-&gt;<name>ignore_space</name></name> &amp;&amp; ! <name><name>opts</name>-&gt;<name>ignore_eol_style</name></name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr>*<name>tgt</name> = (<name>char</name> *)<name>buf</name></expr>;</expr_stmt>
      <return>return;</return>
    }</block></then></if>


  <comment type="block">/* It only took me forever to get this routine right,
     so here my thoughts go:

    Below, we loop through the data, doing 2 things:

     - Normalizing
     - Copying other data

     The routine tries its hardest *not* to copy data, but instead
     returning a pointer into already normalized existing data.

     To this end, a block 'other data' shouldn't be copied when found,
     but only as soon as it can't be returned in-place.

     On a character level, there are 3 possible operations:

     - Skip the character (don't include in the normalized data)
     - Include the character (do include in the normalizad data)
     - Include as another character
       This is essentially the same as skipping the current character
       and inserting a given character in the output data.

    The macros below (SKIP, INCLUDE and INCLUDE_AS) are defined to
    handle the character based operations.  The macros themselves
    collect character level data into blocks.

    At all times designate the START, INCLUDED_LEN and CURP pointers
    an included and and skipped block like this:

      [ start, start + included_len ) [ start + included_len, curp )
             INCLUDED                        EXCLUDED

    When the routine flips from skipping to including, the last
    included block has to be flushed to the output buffer.
  */</comment>

  <comment type="block">/* Going from including to skipping; only schedules the current
     included section for flushing.
     Also, simply chop off the character if it's the first in the buffer,
     so we can possibly just return the remainder of the buffer */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SKIP</name></cpp:macro>             \
  <cpp:value>do {                   \
    if (start == curp)   \
       ++start;          \
    last_skipped = TRUE; \
  } while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INCLUDE</name></cpp:macro>                \
  <cpp:value>do {                         \
    if (last_skipped)          \
      COPY_INCLUDED_SECTION;   \
    ++include_len;             \
    last_skipped = FALSE;      \
  } while (0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COPY_INCLUDED_SECTION</name></cpp:macro>                     \
  <cpp:value>do {                                            \
    if (include_len &gt; 0)                          \
      {                                           \
         memmove(tgt_newend, start, include_len); \
         tgt_newend += include_len;               \
         include_len = 0;                         \
      }                                           \
    start = curp;                                 \
  } while (0)</cpp:value></cpp:define>

  <comment type="block">/* Include the current character as character X.
     If the current character already *is* X, add it to the
     currently included region, increasing chances for consecutive
     fully normalized blocks. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INCLUDE_AS</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro>          \
  <cpp:value>do {                         \
    if (*curp == (x))          \
      INCLUDE;                 \
    else                       \
      {                        \
        INSERT((x));           \
        SKIP;                  \
      }                        \
  } while (0)</cpp:value></cpp:define>

  <comment type="block">/* Insert character X in the output buffer */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INSERT</name><parameter_list>(<param><type><name>x</name></type></param>)</parameter_list></cpp:macro>              \
  <cpp:value>do {                         \
    COPY_INCLUDED_SECTION;     \
    *tgt_newend++ = (x);       \
  } while (0)</cpp:value></cpp:define>

  <for>for (<init><expr><name>curp</name> = <name>buf</name></expr>, <expr><name>endp</name> = <name>buf</name> + *<name>lengthp</name></expr>;</init> <condition><expr><name>curp</name> != <name>endp</name></expr>;</condition> <incr><expr>++<name>curp</name></expr></incr>)
    <block>{
      <switch>switch <condition>(<expr>*<name>curp</name></expr>)</condition>
        <block>{
        <case>case <expr>'\r'</expr>:
          <if>if <condition>(<expr><name><name>opts</name>-&gt;<name>ignore_eol_style</name></name></expr>)</condition><then>
            <expr_stmt><expr><call><name>INCLUDE_AS</name><argument_list>(<argument><expr>'\n'</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
          <else>else
            <expr_stmt><expr><name>INCLUDE</name></expr>;</expr_stmt></else></if>
          <expr_stmt><expr><name>state</name> = <name>svn_diff__normalize_state_cr</name></expr>;</expr_stmt>
          <break>break;</break>

        </case><case>case <expr>'\n'</expr>:
          <if>if <condition>(<expr><name>state</name> == <name>svn_diff__normalize_state_cr</name>
              &amp;&amp; <name><name>opts</name>-&gt;<name>ignore_eol_style</name></name></expr>)</condition><then>
            <expr_stmt><expr><name>SKIP</name></expr>;</expr_stmt></then>
          <else>else
            <expr_stmt><expr><name>INCLUDE</name></expr>;</expr_stmt></else></if>
          <expr_stmt><expr><name>state</name> = <name>svn_diff__normalize_state_normal</name></expr>;</expr_stmt>
          <break>break;</break>

        </case><default>default:
          <if>if <condition>(<expr><call><name>svn_ctype_isspace</name><argument_list>(<argument><expr>*<name>curp</name></expr></argument>)</argument_list></call>
              &amp;&amp; <name><name>opts</name>-&gt;<name>ignore_space</name></name> != <name>svn_diff_file_ignore_space_none</name></expr>)</condition><then>
            <block>{
              <comment type="block">/* Whitespace but not '\r' or '\n' */</comment>
              <if>if <condition>(<expr><name>state</name> != <name>svn_diff__normalize_state_whitespace</name>
                  &amp;&amp; <name><name>opts</name>-&gt;<name>ignore_space</name></name>
                     == <name>svn_diff_file_ignore_space_change</name></expr>)</condition><then>
                <comment type="block">/*### If we can postpone insertion of the space
                  until the next non-whitespace character,
                  we have a potential of reducing the number of copies:
                  If this space is followed by more spaces,
                  this will cause a block-copy.
                  If the next non-space block is considered normalized
                  *and* preceded by a space, we can take advantage of that. */</comment>
                <comment type="block">/* Note, the above optimization applies to 90% of the source
                   lines in our own code, since it (generally) doesn't use
                   more than one space per blank section, except for the
                   beginning of a line. */</comment>
                <expr_stmt><expr><call><name>INCLUDE_AS</name><argument_list>(<argument><expr>' '</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
              <else>else
                <expr_stmt><expr><name>SKIP</name></expr>;</expr_stmt></else></if>
              <expr_stmt><expr><name>state</name> = <name>svn_diff__normalize_state_whitespace</name></expr>;</expr_stmt>
            }</block></then>
          <else>else
            <block>{
              <comment type="block">/* Non-whitespace character, or whitespace character in
                 svn_diff_file_ignore_space_none mode. */</comment>
              <expr_stmt><expr><name>INCLUDE</name></expr>;</expr_stmt>
              <expr_stmt><expr><name>state</name> = <name>svn_diff__normalize_state_normal</name></expr>;</expr_stmt>
            }</block></else></if>
        </default>}</block></switch>
    }</block></for>

  <comment type="block">/* If we're not in whitespace, flush the last chunk of data.
   * Note that this will work correctly when this is the last chunk of the
   * file:
   * * If there is an eol, it will either have been output when we entered
   *   the state_cr, or it will be output now.
   * * If there is no eol and we're not in whitespace, then we just output
   *   everything below.
   * * If there's no eol and we are in whitespace, we want to ignore
   *   whitespace unconditionally. */</comment>

  <if>if <condition>(<expr>*<name>tgt</name> == <name>tgt_newend</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* we haven't copied any data in to *tgt and our chunk consists
         only of one block of (already normalized) data.
         Just return the block. */</comment>
      <expr_stmt><expr>*<name>tgt</name> = (<name>char</name> *)<name>start</name></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>lengthp</name> = <name>include_len</name></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <expr_stmt><expr><name>COPY_INCLUDED_SECTION</name></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>lengthp</name> = <name>tgt_newend</name> - *<name>tgt</name></expr>;</expr_stmt>
    }</block></else></if>

  <expr_stmt><expr>*<name>statep</name> = <name>state</name></expr>;</expr_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>SKIP</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>INCLUDE</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>INCLUDE_AS</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>INSERT</name></cpp:undef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>COPY_INCLUDED_SECTION</name></cpp:undef>
}</block></function>


<comment type="block">/* Return the library version number. */</comment>
<function><type><specifier>const</specifier> <name>svn_version_t</name> *</type>
<name>svn_diff_version</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><name>SVN_VERSION_BODY</name></expr>;</expr_stmt>
}</block></function>
</unit>
