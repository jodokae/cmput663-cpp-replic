<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/subversion-1.5.1/source/subversion/libsvn_ra_svn/ra_svn.h"><comment type="block">/*
 * ra_svn.h :  private declarations for the ra_svn module
 *
 * ====================================================================
 * Copyright (c) 2000-2007 CollabNet.  All rights reserved.
 *
 * This software is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at http://subversion.tigris.org/license-1.html.
 * If newer versions of this license are posted there, you may use a
 * newer version instead, at your option.
 *
 * This software consists of voluntary contributions made by many
 * individuals.  For exact contribution history, see the revision
 * history and logs, available at http://subversion.tigris.org/.
 * ====================================================================
 */</comment>


<escape char="0xc"/>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>RA_SVN_H</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RA_SVN_H</name></cpp:macro></cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
<extern>extern "C" <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* __cplusplus */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_network_io.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_file_io.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_thread_proc.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_ra.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_ra_svn.h"</cpp:file></cpp:include>

<comment type="block">/* Callback function that indicates if a svn_ra_svn__stream_t has pending
 * data.
 */</comment>
<typedef>typedef <function_decl><type><name>svn_boolean_t</name></type> (*<name>ra_svn_pending_fn_t</name>)<parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list>;</function_decl></typedef>

<comment type="block">/* Callback function that sets the timeout value for a svn_ra_svn__stream_t. */</comment>
<typedef>typedef <function_decl><type><name>void</name></type> (*<name>ra_svn_timeout_fn_t</name>)<parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>apr_interval_time_t</name></type> <name>timeout</name></decl></param>)</parameter_list>;</function_decl></typedef>

<comment type="block">/* A stream abstraction for ra_svn.
 *
 * This is different from svn_stream_t in that it provides timeouts and
 * the ability to check for pending data.
 */</comment>
<typedef>typedef <type>struct <name>svn_ra_svn__stream_st</name></type> <name>svn_ra_svn__stream_t</name>;</typedef>

<comment type="block">/* Handler for blocked writes. */</comment>
<typedef>typedef <function_decl><type><name>svn_error_t</name> *</type>(*<name>ra_svn_block_handler_t</name>)<parameter_list>(<param><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name></decl></param>,
                                               <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                                               <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list>;</function_decl></typedef>

<comment type="block">/* The size of our per-connection read and write buffers. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_RA_SVN__READBUF_SIZE</name></cpp:macro> <cpp:value>4096</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_RA_SVN__WRITEBUF_SIZE</name></cpp:macro> <cpp:value>4096</cpp:value></cpp:define>

<comment type="block">/* Create forward reference */</comment>
<typedef>typedef <type>struct <name>svn_ra_svn__session_baton_t</name></type> <name>svn_ra_svn__session_baton_t</name>;</typedef>

<comment type="block">/* This structure is opaque to the server.  The client pokes at the
 * first few fields during setup and cleanup. */</comment>
<struct>struct <name>svn_ra_svn_conn_st</name> <block>{
  <decl_stmt><decl><type><name>svn_ra_svn__stream_t</name> *</type><name>stream</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_ra_svn__session_baton_t</name> *</type><name>session</name></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SVN_HAVE_SASL</name></cpp:ifdef>
  <comment type="block">/* Although all reads and writes go through the svn_ra_svn__stream_t
     interface, SASL still needs direct access to the underlying socket
     for stuff like IP addresses and port numbers. */</comment>
  <decl_stmt><decl><type><name>apr_socket_t</name> *</type><name>sock</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>encrypted</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <decl_stmt><decl><type><name>char</name></type> <name><name>read_buf</name><index>[<expr><name>SVN_RA_SVN__READBUF_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>read_ptr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>read_end</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>write_buf</name><index>[<expr><name>SVN_RA_SVN__WRITEBUF_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>write_pos</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>uuid</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>repos_root</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>ra_svn_block_handler_t</name></type> <name>block_handler</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> *</type><name>block_baton</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>capabilities</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>
}</block>;</struct>

<struct>struct <name>svn_ra_svn__session_baton_t</name> <block>{
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>is_tunneled</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>url</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>user</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>hostname</name></decl>;</decl_stmt> <comment type="block">/* The remote hostname. */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>realm_prefix</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> **</type><name>tunnel_argv</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_ra_callbacks2_t</name> *</type><name>callbacks</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> *</type><name>callbacks_baton</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_off_t</name></type> <name>bytes_read</name></decl>, <decl><type ref="prev"/><name>bytes_written</name></decl>;</decl_stmt> <comment type="block">/* apr_off_t's because that's what
                                          the callback interface uses */</comment>
}</block>;</struct>

<comment type="block">/* Set a callback for blocked writes on conn.  This handler may
 * perform reads on the connection in order to prevent deadlock due to
 * pipelining.  If callback is NULL, the connection goes back to
 * normal blocking I/O for writes.
 */</comment>
<function_decl><type><name>void</name></type> <name>svn_ra_svn__set_block_handler</name><parameter_list>(<param><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name></decl></param>,
                                   <param><decl><type><name>ra_svn_block_handler_t</name></type> <name>callback</name></decl></param>,
                                   <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/* Return true if there is input waiting on conn. */</comment>
<function_decl><type><name>svn_boolean_t</name></type> <name>svn_ra_svn__input_waiting</name><parameter_list>(<param><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name></decl></param>,
                                        <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/* CRAM-MD5 client implementation. */</comment>
<function_decl><type><name>svn_error_t</name> *</type><name>svn_ra_svn__cram_client</name><parameter_list>(<param><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                                     <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>user</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>password</name></decl></param>,
                                     <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>message</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/* Return an error chain based on @a params (which contains a
 * command response indicating failure).  The error chain will be
 * in the same order as the errors indicated in @a params.  Use
 * @a pool for temporary allocations. */</comment>
<function_decl><type><name>svn_error_t</name> *</type><name>svn_ra_svn__handle_failure_status</name><parameter_list>(<param><decl><type><name>apr_array_header_t</name> *</type><name>params</name></decl></param>,
                                               <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/* Returns a stream that reads/writes from/to SOCK. */</comment>
<function_decl><type><name>svn_ra_svn__stream_t</name> *</type><name>svn_ra_svn__stream_from_sock</name><parameter_list>(<param><decl><type><name>apr_socket_t</name> *</type><name>sock</name></decl></param>,
                                                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/* Returns a stream that reads from IN_FILE and writes to OUT_FILE.  */</comment>
<function_decl><type><name>svn_ra_svn__stream_t</name> *</type><name>svn_ra_svn__stream_from_files</name><parameter_list>(<param><decl><type><name>apr_file_t</name> *</type><name>in_file</name></decl></param>,
                                                    <param><decl><type><name>apr_file_t</name> *</type><name>out_file</name></decl></param>,
                                                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/* Create an svn_ra_svn__stream_t using READ_CB, WRITE_CB, TIMEOUT_CB,
 * PENDING_CB, and BATON.
 */</comment>
<function_decl><type><name>svn_ra_svn__stream_t</name> *</type><name>svn_ra_svn__stream_create</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>,
                                                <param><decl><type><name>svn_read_fn_t</name></type> <name>read_cb</name></decl></param>,
                                                <param><decl><type><name>svn_write_fn_t</name></type> <name>write_cb</name></decl></param>,
                                                <param><decl><type><name>ra_svn_timeout_fn_t</name></type> <name>timeout_cb</name></decl></param>,
                                                <param><decl><type><name>ra_svn_pending_fn_t</name></type> <name>pending_cb</name></decl></param>,
                                                <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/* Write *LEN bytes from DATA to STREAM, returning the number of bytes
 * written in *LEN.
 */</comment>
<function_decl><type><name>svn_error_t</name> *</type><name>svn_ra_svn__stream_write</name><parameter_list>(<param><decl><type><name>svn_ra_svn__stream_t</name> *</type><name>stream</name></decl></param>,
                                      <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name></decl></param>, <param><decl><type><name>apr_size_t</name> *</type><name>len</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/* Read *LEN bytes from STREAM into DATA, returning the number of bytes
 * read in *LEN.
 */</comment>
<function_decl><type><name>svn_error_t</name> *</type><name>svn_ra_svn__stream_read</name><parameter_list>(<param><decl><type><name>svn_ra_svn__stream_t</name> *</type><name>stream</name></decl></param>,
                                     <param><decl><type><name>char</name> *</type><name>data</name></decl></param>, <param><decl><type><name>apr_size_t</name> *</type><name>len</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/* Set the timeout for operations on STREAM to INTERVAL. */</comment>
<function_decl><type><name>void</name></type> <name>svn_ra_svn__stream_timeout</name><parameter_list>(<param><decl><type><name>svn_ra_svn__stream_t</name> *</type><name>stream</name></decl></param>,
                                <param><decl><type><name>apr_interval_time_t</name></type> <name>interval</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/* Return whether or not there is data pending on STREAM. */</comment>
<function_decl><type><name>svn_boolean_t</name></type> <name>svn_ra_svn__stream_pending</name><parameter_list>(<param><decl><type><name>svn_ra_svn__stream_t</name> *</type><name>stream</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/* Respond to an auth request and perform authentication.  Use the Cyrus
 * SASL library for mechanism negotiation and for creating authentication
 * tokens. */</comment>
<function_decl><type><name>svn_error_t</name> *</type>
<name>svn_ra_svn__do_cyrus_auth</name><parameter_list>(<param><decl><type><name>svn_ra_svn__session_baton_t</name> *</type><name>sess</name></decl></param>,
                          <param><decl><type><name>apr_array_header_t</name> *</type><name>mechlist</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>realm</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/* Same as svn_ra_svn__do_cyrus_auth, but uses the built-in implementation of
 * the CRAM-MD5, ANONYMOUS and EXTERNAL mechanisms.  Return the error
 * SVN_ERR_RA_SVN_NO_MECHANSIMS if we cannot negotiate an authentication
 * mechanism with the server. */</comment>
<function_decl><type><name>svn_error_t</name> *</type>
<name>svn_ra_svn__do_internal_auth</name><parameter_list>(<param><decl><type><name>svn_ra_svn__session_baton_t</name> *</type><name>sess</name></decl></param>,
                             <param><decl><type><name>apr_array_header_t</name> *</type><name>mechlist</name></decl></param>,
                             <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>realm</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/* Having picked a mechanism, start authentication by writing out an
 * auth response.  MECH_ARG may be NULL for mechanisms with no
 * initial client response. */</comment>
<function_decl><type><name>svn_error_t</name> *</type><name>svn_ra_svn__auth_response</name><parameter_list>(<param><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name></decl></param>,
                                       <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                                       <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>mech</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>mech_arg</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/* Initialize the SASL library. */</comment>
<function_decl><type><name>svn_error_t</name> *</type><name>svn_ra_svn__sasl_init</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>;</function_decl>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
}</block></extern>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* __cplusplus */</comment>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* RA_SVN_H */</comment>
</unit>
