<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/subversion-1.5.1/source/subversion/libsvn_wc/adm_ops.c"><comment type="block">/*
 * adm_ops.c: routines for affecting working copy administrative
 *            information.  NOTE: this code doesn't know where the adm
 *            info is actually stored.  Instead, generic handles to
 *            adm data are requested via a reference to some PATH
 *            (PATH being a regular, non-administrative directory or
 *            file in the working copy).
 *
 * ====================================================================
 * Copyright (c) 2000-2007 CollabNet.  All rights reserved.
 *
 * This software is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at http://subversion.tigris.org/license-1.html.
 * If newer versions of this license are posted there, you may use a
 * newer version instead, at your option.
 *
 * This software consists of voluntary contributions made by many
 * individuals.  For exact contribution history, see the revision
 * history and logs, available at http://subversion.tigris.org/.
 * ====================================================================
 */</comment>


<escape char="0xc"/>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_pools.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_tables.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_hash.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_md5.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_file_io.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_errno.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_types.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_pools.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_string.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_error.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_path.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_wc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_io.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_md5.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_xml.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_time.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"wc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"log.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"adm_files.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"adm_ops.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"entries.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"props.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"translate.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_private_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"private/svn_wc_private.h"</cpp:file></cpp:include>

<escape char="0xc"/>
<comment type="block">/*** Finishing updates and commits. ***/</comment>


<comment type="block">/* The main body of svn_wc__do_update_cleanup. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>tweak_entries</name><parameter_list>(<param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>dirpath</name></decl></param>,
              <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>base_url</name></decl></param>,
              <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>repos</name></decl></param>,
              <param><decl><type><name>svn_revnum_t</name></type> <name>new_rev</name></decl></param>,
              <param><decl><type><name>svn_wc_notify_func2_t</name></type> <name>notify_func</name></decl></param>,
              <param><decl><type><name>void</name> *</type><name>notify_baton</name></decl></param>,
              <param><decl><type><name>svn_boolean_t</name></type> <name>remove_missing_dirs</name></decl></param>,
              <param><decl><type><name>svn_depth_t</name></type> <name>depth</name></decl></param>,
              <param><decl><type><name>apr_hash_t</name> *</type><name>exclude_paths</name></decl></param>,
              <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>entries</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>write_required</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_wc_notify_t</name> *</type><name>notify</name></decl>;</decl_stmt>

  <comment type="block">/* Read DIRPATH's entries. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_entries_read</name><argument_list>(<argument><expr>&amp;<name>entries</name></expr></argument>, <argument><expr><name>dirpath</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Tweak "this_dir" */</comment>
  <if>if <condition>(<expr>! <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>exclude_paths</name></expr></argument>, <argument><expr><call><name>svn_wc_adm_access_path</name><argument_list>(<argument><expr><name>dirpath</name></expr></argument>)</argument_list></call></expr></argument>,
                     <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__tweak_entry</name><argument_list>(<argument><expr><name>entries</name></expr></argument>, <argument><expr><name>SVN_WC_ENTRY_THIS_DIR</name></expr></argument>,
                                <argument><expr><name>base_url</name></expr></argument>, <argument><expr><name>repos</name></expr></argument>, <argument><expr><name>new_rev</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                                <argument><expr>&amp;<name>write_required</name></expr></argument>,
                                <argument><expr><call><name>svn_wc_adm_access_pool</name><argument_list>(<argument><expr><name>dirpath</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <if>if <condition>(<expr><name>depth</name> == <name>svn_depth_unknown</name></expr>)</condition><then>
    <expr_stmt><expr><name>depth</name> = <name>svn_depth_infinity</name></expr>;</expr_stmt></then></if>

  <if>if <condition>(<expr><name>depth</name> &gt; <name>svn_depth_empty</name></expr>)</condition><then>
    <block>{
      <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>entries</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>hi</name></expr>;</condition> <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
        <block>{
          <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>svn_wc_entry_t</name> *</type><name>current_entry</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>child_path</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>child_url</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>excluded</name></decl>;</decl_stmt>

          <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>name</name> = <name>key</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>current_entry</name> = <name>val</name></expr>;</expr_stmt>

          <comment type="block">/* Ignore the "this dir" entry. */</comment>
          <if>if <condition>(<expr>! <call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>SVN_WC_ENTRY_THIS_DIR</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <continue>continue;</continue></then></if>

          <comment type="block">/* Derive the new URL for the current (child) entry */</comment>
          <if>if <condition>(<expr><name>base_url</name></expr>)</condition><then>
            <expr_stmt><expr><name>child_url</name> = <call><name>svn_path_url_add_component</name><argument_list>(<argument><expr><name>base_url</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

          <expr_stmt><expr><name>child_path</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><call><name>svn_wc_adm_access_path</name><argument_list>(<argument><expr><name>dirpath</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>,
                                     <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>excluded</name> = (<call><name>apr_hash_get</name><argument_list>(<argument><expr><name>exclude_paths</name></expr></argument>, <argument><expr><name>child_path</name></expr></argument>,
                                   <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call> != <name>NULL</name>)</expr>;</expr_stmt>

          <comment type="block">/* If a file, or deleted or absent dir, then tweak the entry
             but don't recurse. */</comment>
          <if>if <condition>(<expr>(<name><name>current_entry</name>-&gt;<name>kind</name></name> == <name>svn_node_file</name>)
              || (<name><name>current_entry</name>-&gt;<name>deleted</name></name> || <name><name>current_entry</name>-&gt;<name>absent</name></name>)</expr>)</condition><then>
            <block>{
              <if>if <condition>(<expr>! <name>excluded</name></expr>)</condition><then>
                <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__tweak_entry</name><argument_list>(<argument><expr><name>entries</name></expr></argument>, <argument><expr><name>name</name></expr></argument>,
                                            <argument><expr><name>child_url</name></expr></argument>, <argument><expr><name>repos</name></expr></argument>, <argument><expr><name>new_rev</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>,
                                            <argument><expr>&amp;<name>write_required</name></expr></argument>,
                                            <argument><expr><call><name>svn_wc_adm_access_pool</name><argument_list>(<argument><expr><name>dirpath</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            }</block></then>

          <comment type="block">/* If a directory and recursive... */</comment>
          <else>else <if>if <condition>(<expr>(<name>depth</name> == <name>svn_depth_infinity</name>
                    || <name>depth</name> == <name>svn_depth_immediates</name>)
                   &amp;&amp; (<name><name>current_entry</name>-&gt;<name>kind</name></name> == <name>svn_node_dir</name>)</expr>)</condition><then>
            <block>{
              <decl_stmt><decl><type><name>svn_depth_t</name></type> <name>depth_below_here</name> <init>= <expr><name>depth</name></expr></init></decl>;</decl_stmt>

              <if>if <condition>(<expr><name>depth</name> == <name>svn_depth_immediates</name></expr>)</condition><then>
                <expr_stmt><expr><name>depth_below_here</name> = <name>svn_depth_empty</name></expr>;</expr_stmt></then></if>

              <comment type="block">/* If the directory is 'missing', remove it.  This is safe as
                 long as this function is only called as a helper to
                 svn_wc__do_update_cleanup, since the update will already have
                 restored any missing items that it didn't want to delete. */</comment>
              <if>if <condition>(<expr><name>remove_missing_dirs</name>
                  &amp;&amp; <call><name>svn_wc__adm_missing</name><argument_list>(<argument><expr><name>dirpath</name></expr></argument>, <argument><expr><name>child_path</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <block>{
                  <if>if <condition>(<expr><name><name>current_entry</name>-&gt;<name>schedule</name></name> != <name>svn_wc_schedule_add</name>
                      &amp;&amp; !<name>excluded</name></expr>)</condition><then>
                    <block>{
                      <expr_stmt><expr><call><name>svn_wc__entry_remove</name><argument_list>(<argument><expr><name>entries</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                      <if>if <condition>(<expr><name>notify_func</name></expr>)</condition><then>
                        <block>{
                          <expr_stmt><expr><name>notify</name> = <call><name>svn_wc_create_notify</name><argument_list>(<argument><expr><name>child_path</name></expr></argument>,
                                                        <argument><expr><name>svn_wc_notify_delete</name></expr></argument>,
                                                        <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                          <expr_stmt><expr><name><name>notify</name>-&gt;<name>kind</name></name> = <name><name>current_entry</name>-&gt;<name>kind</name></name></expr>;</expr_stmt>
                          <expr_stmt><expr><call>(* <name>notify_func</name>)<argument_list>(<argument><expr><name>notify_baton</name></expr></argument>, <argument><expr><name>notify</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                        }</block></then></if>
                    }</block></then></if>
                  <comment type="block">/* Else if missing item is schedule-add, do nothing. */</comment>
                }</block></then>

              <comment type="block">/* Not missing, deleted, or absent, so recurse. */</comment>
              <else>else
                <block>{
                  <decl_stmt><decl><type><name>svn_wc_adm_access_t</name> *</type><name>child_access</name></decl>;</decl_stmt>
                  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_adm_retrieve</name><argument_list>(<argument><expr>&amp;<name>child_access</name></expr></argument>, <argument><expr><name>dirpath</name></expr></argument>,
                                              <argument><expr><name>child_path</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>tweak_entries</name>
                          <argument_list>(<argument><expr><name>child_access</name></expr></argument>, <argument><expr><name>child_url</name></expr></argument>, <argument><expr><name>repos</name></expr></argument>, <argument><expr><name>new_rev</name></expr></argument>,
                           <argument><expr><name>notify_func</name></expr></argument>, <argument><expr><name>notify_baton</name></expr></argument>, <argument><expr><name>remove_missing_dirs</name></expr></argument>,
                           <argument><expr><name>depth_below_here</name></expr></argument>, <argument><expr><name>exclude_paths</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></else></if>
            }</block></then></if></else></if>
        }</block></for>
    }</block></then></if>

  <comment type="block">/* Write a shiny new entries file to disk. */</comment>
  <if>if <condition>(<expr><name>write_required</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__entries_write</name><argument_list>(<argument><expr><name>entries</name></expr></argument>, <argument><expr><name>dirpath</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* Cleanup */</comment>
  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Helper for svn_wc_process_committed2. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>remove_revert_file</name><parameter_list>(<param><decl><type><name>svn_stringbuf_t</name> **</type><name>logtags</name></decl></param>,
                   <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                   <param><decl><type><name>svn_boolean_t</name></type> <name>is_prop</name></decl></param>,
                   <param><decl><type><name>apr_pool_t</name> *</type> <name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>revert_file</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>is_prop</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_props_delete</name><argument_list>(<argument><expr><name>logtags</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>svn_wc__props_revert</name></expr></argument>,
                                       <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <block>{
      <expr_stmt><expr><name>revert_file</name> = <call><name>svn_wc__text_revert_path</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_check_path</name><argument_list>(<argument><expr><name>revert_file</name></expr></argument>, <argument><expr>&amp;<name>kind</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr><name>kind</name> == <name>svn_node_file</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_remove</name><argument_list>(<argument><expr><name>logtags</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>revert_file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></else></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_wc__do_update_cleanup</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                          <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                          <param><decl><type><name>svn_depth_t</name></type> <name>depth</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>base_url</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>repos</name></decl></param>,
                          <param><decl><type><name>svn_revnum_t</name></type> <name>new_revision</name></decl></param>,
                          <param><decl><type><name>svn_wc_notify_func2_t</name></type> <name>notify_func</name></decl></param>,
                          <param><decl><type><name>void</name> *</type><name>notify_baton</name></decl></param>,
                          <param><decl><type><name>svn_boolean_t</name></type> <name>remove_missing_dirs</name></decl></param>,
                          <param><decl><type><name>apr_hash_t</name> *</type><name>exclude_paths</name></decl></param>,
                          <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>entries</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>entry</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_entry</name><argument_list>(<argument><expr>&amp;<name>entry</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>entry</name> == <name>NULL</name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <if>if <condition>(<expr><name><name>entry</name>-&gt;<name>kind</name></name> == <name>svn_node_file</name>
      || (<name><name>entry</name>-&gt;<name>kind</name></name> == <name>svn_node_dir</name> &amp;&amp; (<name><name>entry</name>-&gt;<name>deleted</name></name> || <name><name>entry</name>-&gt;<name>absent</name></name>))</expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>parent</name></decl>, *<decl><type ref="prev"/><name>base_name</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_wc_adm_access_t</name> *</type><name>dir_access</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>write_required</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><call><name>apr_hash_get</name><argument_list>(<argument><expr><name>exclude_paths</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>
      <expr_stmt><expr><call><name>svn_path_split</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>&amp;<name>parent</name></expr></argument>, <argument><expr>&amp;<name>base_name</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_adm_retrieve</name><argument_list>(<argument><expr>&amp;<name>dir_access</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_entries_read</name><argument_list>(<argument><expr>&amp;<name>entries</name></expr></argument>, <argument><expr><name>dir_access</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__tweak_entry</name><argument_list>(<argument><expr><name>entries</name></expr></argument>, <argument><expr><name>base_name</name></expr></argument>,
                                  <argument><expr><name>base_url</name></expr></argument>, <argument><expr><name>repos</name></expr></argument>, <argument><expr><name>new_revision</name></expr></argument>,
                                  <argument><expr><name>FALSE</name></expr></argument>, <comment type="block">/* Parent not updated so don't
                                            remove PATH entry */</comment>
                                  <argument><expr>&amp;<name>write_required</name></expr></argument>,
                                  <argument><expr><call><name>svn_wc_adm_access_pool</name><argument_list>(<argument><expr><name>dir_access</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>write_required</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__entries_write</name><argument_list>(<argument><expr><name>entries</name></expr></argument>, <argument><expr><name>dir_access</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then>

  <else>else <if>if <condition>(<expr><name><name>entry</name>-&gt;<name>kind</name></name> == <name>svn_node_dir</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_wc_adm_access_t</name> *</type><name>dir_access</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_adm_retrieve</name><argument_list>(<argument><expr>&amp;<name>dir_access</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>tweak_entries</name><argument_list>(<argument><expr><name>dir_access</name></expr></argument>, <argument><expr><name>base_url</name></expr></argument>, <argument><expr><name>repos</name></expr></argument>, <argument><expr><name>new_revision</name></expr></argument>,
                            <argument><expr><name>notify_func</name></expr></argument>, <argument><expr><name>notify_baton</name></expr></argument>, <argument><expr><name>remove_missing_dirs</name></expr></argument>,
                            <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>exclude_paths</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>

  <else>else
    <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_NODE_UNKNOWN_KIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Unrecognized node kind: '%s'"</expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></else></if></else></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_wc_maybe_set_repos_root</name><parameter_list>(<param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                            <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                            <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>repos</name></decl></param>,
                            <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>entries</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>write_required</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>entry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>base_name</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_wc_adm_access_t</name> *</type><name>dir_access</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_entry</name><argument_list>(<argument><expr>&amp;<name>entry</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>! <name>entry</name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <if>if <condition>(<expr><name><name>entry</name>-&gt;<name>kind</name></name> == <name>svn_node_file</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>parent</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>svn_path_split</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>&amp;<name>parent</name></expr></argument>, <argument><expr>&amp;<name>base_name</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__adm_retrieve_internal</name><argument_list>(<argument><expr>&amp;<name>dir_access</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                                            <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <expr_stmt><expr><name>base_name</name> = <name>SVN_WC_ENTRY_THIS_DIR</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__adm_retrieve_internal</name><argument_list>(<argument><expr>&amp;<name>dir_access</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                                            <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

  <if>if <condition>(<expr>! <name>dir_access</name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_entries_read</name><argument_list>(<argument><expr>&amp;<name>entries</name></expr></argument>, <argument><expr><name>dir_access</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__tweak_entry</name><argument_list>(<argument><expr><name>entries</name></expr></argument>, <argument><expr><name>base_name</name></expr></argument>,
                              <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>repos</name></expr></argument>, <argument><expr><name>SVN_INVALID_REVNUM</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                              <argument><expr>&amp;<name>write_required</name></expr></argument>,
                              <argument><expr><call><name>svn_wc_adm_access_pool</name><argument_list>(<argument><expr><name>dir_access</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>write_required</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__entries_write</name><argument_list>(<argument><expr><name>entries</name></expr></argument>, <argument><expr><name>dir_access</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>process_committed_leaf</name><parameter_list>(<param><decl><type><name>int</name></type> <name>log_number</name></decl></param>,
                       <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                       <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                       <param><decl><type><name>svn_boolean_t</name> *</type><name>recurse</name></decl></param>,
                       <param><decl><type><name>svn_revnum_t</name></type> <name>new_revnum</name></decl></param>,
                       <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>rev_date</name></decl></param>,
                       <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>rev_author</name></decl></param>,
                       <param><decl><type><name>apr_array_header_t</name> *</type><name>wcprop_changes</name></decl></param>,
                       <param><decl><type><name>svn_boolean_t</name></type> <name>remove_lock</name></decl></param>,
                       <param><decl><type><name>svn_boolean_t</name></type> <name>remove_changelist</name></decl></param>,
                       <param><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>digest</name></decl></param>,
                       <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>base_name</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>hex_digest</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_wc_entry_t</name></type> <name>tmp_entry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_uint64_t</name></type> <name>modify_flags</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>logtags</name> <init>= <expr><call><name>svn_stringbuf_create</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__adm_write_check</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Set PATH's working revision to NEW_REVNUM; if REV_DATE and
     REV_AUTHOR are both non-NULL, then set the 'committed-rev',
     'committed-date', and 'last-author' entry values; and set the
     checksum if a file. */</comment>

  <expr_stmt><expr><name>base_name</name> = <call><name>svn_path_is_child</name><argument_list>(<argument><expr><call><name>svn_wc_adm_access_path</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>path</name></expr></argument>,
                                <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>base_name</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* If the props or text revert file exists it needs to be deleted when
       * the file is committed. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>remove_revert_file</name><argument_list>(<argument><expr>&amp;<name>logtags</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>remove_revert_file</name><argument_list>(<argument><expr>&amp;<name>logtags</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr><name>digest</name></expr>)</condition><then>
        <expr_stmt><expr><name>hex_digest</name> = <call><name>svn_md5_digest_to_cstring</name><argument_list>(<argument><expr><name>digest</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
      <else>else
        <block>{
          <comment type="block">/* There may be a new text base sitting in the adm tmp area
             by now, because the commit succeeded.  A file that is
             copied, but not otherwise modified, doesn't have a new
             text base, so we use the unmodified text base.

             ### Does this mean that a file committed with only prop mods
             ### will still get its text base checksum recomputed?  Yes it
             ### does, sadly.  But it's not enough to just check for that
             ### condition, because in the case of an added file, there
             ### may not be a pre-existing checksum in the entry.
             ### Probably the best solution is to compute (or copy) the
             ### checksum at 'svn add' (or 'svn cp') time, instead of
             ### waiting until commit time.
          */</comment>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>latest_base</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>local_digest</name><index>[<expr><name>APR_MD5_DIGESTSIZE</name></expr>]</index></name></decl>;</decl_stmt>

          <expr_stmt><expr><name>latest_base</name> = <call><name>svn_wc__text_base_path</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>err</name> = <call><name>svn_io_file_checksum</name><argument_list>(<argument><expr><name>local_digest</name></expr></argument>, <argument><expr><name>latest_base</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <if>if <condition>(<expr><name>err</name> &amp;&amp; <call><name>APR_STATUS_IS_ENOENT</name><argument_list>(<argument><expr><name><name>err</name>-&gt;<name>apr_err</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <block>{
              <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>latest_base</name> = <call><name>svn_wc__text_base_path</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>err</name> = <call><name>svn_io_file_checksum</name><argument_list>(<argument><expr><name>local_digest</name></expr></argument>, <argument><expr><name>latest_base</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>

          <if>if <condition>(<expr>! <name>err</name></expr>)</condition><then>
            <expr_stmt><expr><name>hex_digest</name> = <call><name>svn_md5_digest_to_cstring</name><argument_list>(<argument><expr><name>local_digest</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
          <else>else <if>if <condition>(<expr><call><name>APR_STATUS_IS_ENOENT</name><argument_list>(<argument><expr><name><name>err</name>-&gt;<name>apr_err</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
          <else>else
            <return>return <expr><name>err</name></expr>;</return></else></if></else></if>
        }</block></else></if>

      <comment type="block">/* Oh, and recursing at this point isn't really sensible. */</comment>
      <if>if <condition>(<expr><name>recurse</name></expr>)</condition><then>
        <expr_stmt><expr>*<name>recurse</name> = <name>FALSE</name></expr>;</expr_stmt></then></if>
    }</block></then>
  <else>else
    <block>{
      <comment type="block">/* PATH must be a dir */</comment>
      <expr_stmt><expr><name>base_name</name> = <name>SVN_WC_ENTRY_THIS_DIR</name></expr>;</expr_stmt>
    }</block></else></if>


  <comment type="block">/* Append a log command to set (overwrite) the 'committed-rev',
     'committed-date', 'last-author', and possibly 'checksum'
     attributes in the entry.

     Note: it's important that this log command come *before* the
     LOG_COMMITTED command, because log_do_committed() might actually
     remove the entry! */</comment>
  <if>if <condition>(<expr><name>rev_date</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name><name>tmp_entry</name>.<name>cmt_rev</name></name> = <name>new_revnum</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_time_from_cstring</name><argument_list>(<argument><expr>&amp;<name><name>tmp_entry</name>.<name>cmt_date</name></name></expr></argument>, <argument><expr><name>rev_date</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>modify_flags</name> |= <name>SVN_WC__ENTRY_MODIFY_CMT_REV</name>
        | <name>SVN_WC__ENTRY_MODIFY_CMT_DATE</name></expr>;</expr_stmt>
    }</block></then></if>

  <if>if <condition>(<expr><name>rev_author</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name><name>tmp_entry</name>.<name>cmt_rev</name></name> = <name>new_revnum</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>tmp_entry</name>.<name>cmt_author</name></name> = <name>rev_author</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>modify_flags</name> |= <name>SVN_WC__ENTRY_MODIFY_CMT_REV</name>
        | <name>SVN_WC__ENTRY_MODIFY_CMT_AUTHOR</name></expr>;</expr_stmt>
    }</block></then></if>

  <if>if <condition>(<expr><name>hex_digest</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name><name>tmp_entry</name>.<name>checksum</name></name> = <name>hex_digest</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>modify_flags</name> |= <name>SVN_WC__ENTRY_MODIFY_CHECKSUM</name></expr>;</expr_stmt>
    }</block></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_entry_modify</name><argument_list>(<argument><expr>&amp;<name>logtags</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                                     <argument><expr><name>path</name></expr></argument>, <argument><expr>&amp;<name>tmp_entry</name></expr></argument>, <argument><expr><name>modify_flags</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>remove_lock</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_delete_lock</name><argument_list>(<argument><expr>&amp;<name>logtags</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <if>if <condition>(<expr><name>remove_changelist</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_delete_changelist</name><argument_list>(<argument><expr>&amp;<name>logtags</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* Regardless of whether it's a file or dir, the "main" logfile
     contains a command to bump the revision attribute (and
     timestamp). */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_committed</name><argument_list>(<argument><expr>&amp;<name>logtags</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                                  <argument><expr><name>path</name></expr></argument>, <argument><expr><name>new_revnum</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


  <comment type="block">/* Do wcprops in the same log txn as revision, etc. */</comment>
  <if>if <condition>(<expr><name>wcprop_changes</name> &amp;&amp; (<name><name>wcprop_changes</name>-&gt;<name>nelts</name></name> &gt; 0)</expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

      <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>wcprop_changes</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
        <block>{
          <decl_stmt><decl><type><name>svn_prop_t</name> *</type><name>prop</name> <init>= <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>wcprop_changes</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>svn_prop_t</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_modify_wcprop</name>
                  <argument_list>(<argument><expr>&amp;<name>logtags</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                   <argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>prop</name>-&gt;<name>name</name></name></expr></argument>,
                   <argument><expr><name><name>prop</name>-&gt;<name>value</name></name> ? <name><name>prop</name>-&gt;<name>value</name>-&gt;<name>data</name></name> : <name>NULL</name></expr></argument>,
                   <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
    }</block></then></if>

  <comment type="block">/* Write our accumulation of log entries into a log file */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__write_log</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>log_number</name></expr></argument>, <argument><expr><name>logtags</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>process_committed_internal</name><parameter_list>(<param><decl><type><name>int</name> *</type><name>log_number</name></decl></param>,
                           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                           <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                           <param><decl><type><name>svn_boolean_t</name></type> <name>recurse</name></decl></param>,
                           <param><decl><type><name>svn_revnum_t</name></type> <name>new_revnum</name></decl></param>,
                           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>rev_date</name></decl></param>,
                           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>rev_author</name></decl></param>,
                           <param><decl><type><name>apr_array_header_t</name> *</type><name>wcprop_changes</name></decl></param>,
                           <param><decl><type><name>svn_boolean_t</name></type> <name>remove_lock</name></decl></param>,
                           <param><decl><type><name>svn_boolean_t</name></type> <name>remove_changelist</name></decl></param>,
                           <param><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>digest</name></decl></param>,
                           <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>process_committed_leaf</name><argument_list>(<argument><expr>(*<name>log_number</name>)++</expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr>&amp;<name>recurse</name></expr></argument>,
                                 <argument><expr><name>new_revnum</name></expr></argument>, <argument><expr><name>rev_date</name></expr></argument>, <argument><expr><name>rev_author</name></expr></argument>,
                                 <argument><expr><name>wcprop_changes</name></expr></argument>,
                                 <argument><expr><name>remove_lock</name></expr></argument>, <argument><expr><name>remove_changelist</name></expr></argument>,
                                 <argument><expr><name>digest</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>recurse</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>entries</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <comment type="block">/* Read PATH's entries;  this is the absolute path. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_entries_read</name><argument_list>(<argument><expr>&amp;<name>entries</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Recursively loop over all children. */</comment>
      <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>entries</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>hi</name></expr>;</condition> <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
        <block>{
          <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>current_entry</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>this_path</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>svn_wc_adm_access_t</name> *</type><name>child_access</name></decl>;</decl_stmt>

          <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>name</name> = <name>key</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>current_entry</name> = <name>val</name></expr>;</expr_stmt>

          <comment type="block">/* Ignore the "this dir" entry. */</comment>
          <if>if <condition>(<expr>! <call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>SVN_WC_ENTRY_THIS_DIR</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <continue>continue;</continue></then></if>

          <comment type="block">/* Create child path by telescoping the main path. */</comment>
          <expr_stmt><expr><name>this_path</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <if>if <condition>(<expr><name><name>current_entry</name>-&gt;<name>kind</name></name> == <name>svn_node_dir</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_adm_retrieve</name><argument_list>(<argument><expr>&amp;<name>child_access</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>this_path</name></expr></argument>,
                                        <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
          <else>else
             <expr_stmt><expr><name>child_access</name> = <name>adm_access</name></expr>;</expr_stmt></else></if>

          <comment type="block">/* Recurse, but only allow further recursion if the child is
             a directory.  Pass null for wcprop_changes, because the
             ones present in the current call are only applicable to
             this one committed item. */</comment>
          <if>if <condition>(<expr><name><name>current_entry</name>-&gt;<name>kind</name></name> == <name>svn_node_dir</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_process_committed4</name>
                    <argument_list>(<argument><expr><name>this_path</name></expr></argument>, <argument><expr><name>child_access</name></expr></argument>,
                     <argument><expr><name>TRUE</name></expr></argument>,
                     <argument><expr><name>new_revnum</name></expr></argument>, <argument><expr><name>rev_date</name></expr></argument>, <argument><expr><name>rev_author</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                     <argument><expr><name>remove_changelist</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
          <else>else
            <block>{
              <comment type="block">/* Suppress log creation for deleted entries in a replaced
                 directory.  By the time any log we create here is run,
                 those entries will already have been removed (as a result
                 of running the log for the replaced directory that was
                 created at the start of this function). */</comment>
              <if>if <condition>(<expr><name><name>current_entry</name>-&gt;<name>schedule</name></name> == <name>svn_wc_schedule_delete</name></expr>)</condition><then>
                <block>{
                  <decl_stmt><decl><type><name>svn_wc_entry_t</name> *</type><name>parent_entry</name></decl>;</decl_stmt>

                  <expr_stmt><expr><name>parent_entry</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>entries</name></expr></argument>, <argument><expr><name>SVN_WC_ENTRY_THIS_DIR</name></expr></argument>,
                                              <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <if>if <condition>(<expr><name><name>parent_entry</name>-&gt;<name>schedule</name></name> == <name>svn_wc_schedule_replace</name></expr>)</condition><then>
                    <continue>continue;</continue></then></if>
                }</block></then></if>
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>process_committed_leaf</name>
                      <argument_list>(<argument><expr>(*<name>log_number</name>)++</expr></argument>, <argument><expr><name>this_path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                       <argument><expr><name>new_revnum</name></expr></argument>, <argument><expr><name>rev_date</name></expr></argument>, <argument><expr><name>rev_author</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                       <argument><expr><name>remove_changelist</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></for>

      <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
   }</block></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<struct>struct <name>svn_wc_committed_queue_t</name>
<block>{
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>queue</name></decl>;</decl_stmt>
}</block>;</struct>

<typedef>typedef <type><struct>struct <name>committed_queue_item_t</name>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>recurse</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>remove_lock</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>remove_changelist</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>wcprop_changes</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>digest</name></decl>;</decl_stmt>
}</block></struct></type> <name>committed_queue_item_t</name>;</typedef>


<function><type><name>svn_wc_committed_queue_t</name> *</type>
<name>svn_wc_committed_queue_create</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_wc_committed_queue_t</name> *</type><name>q</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>q</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>q</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>q</name>-&gt;<name>pool</name></name> = <name>pool</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>q</name>-&gt;<name>queue</name></name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>committed_queue_item_t</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>q</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_wc_queue_committed</name><parameter_list>(<param><decl><type><name>svn_wc_committed_queue_t</name> **</type><name>queue</name></decl></param>,
                       <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                       <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                       <param><decl><type><name>svn_boolean_t</name></type> <name>recurse</name></decl></param>,
                       <param><decl><type><name>apr_array_header_t</name> *</type><name>wcprop_changes</name></decl></param>,
                       <param><decl><type><name>svn_boolean_t</name></type> <name>remove_lock</name></decl></param>,
                       <param><decl><type><name>svn_boolean_t</name></type> <name>remove_changelist</name></decl></param>,
                       <param><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>digest</name></decl></param>,
                       <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>committed_queue_item_t</name> *</type><name>cqi</name></decl>;</decl_stmt>

  <comment type="block">/* Use the same pool as the one *QUEUE was allocated in,
     to prevent lifetime issues.  Intermediate operations
     should use POOL. */</comment>

  <comment type="block">/* Add to the array with paths and options */</comment>
  <expr_stmt><expr><name>cqi</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>(*<name>queue</name>)-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>cqi</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cqi</name>-&gt;<name>path</name></name> = <name>path</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cqi</name>-&gt;<name>adm_access</name></name> = <name>adm_access</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cqi</name>-&gt;<name>recurse</name></name> = <name>recurse</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cqi</name>-&gt;<name>remove_lock</name></name> = <name>remove_lock</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cqi</name>-&gt;<name>remove_changelist</name></name> = <name>remove_changelist</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cqi</name>-&gt;<name>wcprop_changes</name></name> = <name>wcprop_changes</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cqi</name>-&gt;<name>digest</name></name> = <name>digest</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>(*<name>queue</name>)-&gt;<name>queue</name></name></expr></argument>, <argument><expr><name>committed_queue_item_t</name> *</expr></argument>)</argument_list></call> = <name>cqi</name></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<typedef>typedef <type><struct>struct <name>affected_adm_t</name>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>next_log</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl>;</decl_stmt>
}</block></struct></type> <name>affected_adm_t</name>;</typedef>


<comment type="block">/* Return TRUE if any item of QUEUE
   is a parent of ITEM and will be processed recursively,
   return FALSE otherwise.

   If HAVE_ANY_RECURSIVE is FALSE, exit early returning FALSE.
   Recalculate its value otherwise, changing it to FALSE
   iff no recursive items are found.
*/</comment>
<function><type><specifier>static</specifier> <name>svn_boolean_t</name></type>
<name>have_recursive_parent</name><parameter_list>(<param><decl><type><name>svn_boolean_t</name> *</type><name>have_any_recursive</name></decl></param>,
                      <param><decl><type><name>apr_array_header_t</name> *</type><name>queue</name></decl></param>,
                      <param><decl><type><name>int</name></type> <name>item</name></decl></param>,
                      <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>found_recursive</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name>
    <init>= <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><name>item</name></expr></argument>, <argument><expr><name>committed_queue_item_t</name> *</expr></argument>)</argument_list></call>-&gt;<name>path</name></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr>! *<name>have_any_recursive</name></expr>)</condition><then>
    <return>return <expr><name>FALSE</name></expr>;</return></then></if>

  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>queue</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <decl_stmt><decl><type><name>committed_queue_item_t</name> *</type><name>qi</name>
        <init>= <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>queue</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>committed_queue_item_t</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><name>found_recursive</name> |= <name><name>qi</name>-&gt;<name>recurse</name></name></expr>;</expr_stmt>

      <if>if <condition>(<expr><name>i</name> == <name>item</name></expr>)</condition><then>
        <continue>continue;</continue></then></if>

      <if>if <condition>(<expr><name><name>qi</name>-&gt;<name>recurse</name></name>
          &amp;&amp; <call><name>svn_path_is_child</name><argument_list>(<argument><expr><name><name>qi</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>TRUE</name></expr>;</return></then></if>
    }</block></for>

  <comment type="block">/* Now we walked the entire array, change the cached value
     to reflect what we found. */</comment>
  <expr_stmt><expr>*<name>have_any_recursive</name> = <name>found_recursive</name></expr>;</expr_stmt>

  <return>return <expr><name>FALSE</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_wc_process_committed_queue</name><parameter_list>(<param><decl><type><name>svn_wc_committed_queue_t</name> *</type><name>queue</name></decl></param>,
                               <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                               <param><decl><type><name>svn_revnum_t</name></type> <name>new_revnum</name></decl></param>,
                               <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>rev_date</name></decl></param>,
                               <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>rev_author</name></decl></param>,
                               <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>updated_adms</name> <init>= <expr><call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>iterpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>have_any_recursive</name> <init>= <expr><name>TRUE</name></expr></init></decl>;</decl_stmt>
  <comment type="block">/* Assume we do have recursive items queued:
     we need to search for recursive parents until proven otherwise */</comment>


  <comment type="block">/* Now, we write all log files,
     collecting the affected adms in the process ... */</comment>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>queue</name>-&gt;<name>queue</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <decl_stmt><decl><type><name>affected_adm_t</name> *</type><name>affected_adm</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>adm_path</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>committed_queue_item_t</name> *</type><name>cqi</name>
        <init>= <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name><name>queue</name>-&gt;<name>queue</name></name></expr></argument>,
                        <argument><expr><name>i</name></expr></argument>, <argument><expr><name>committed_queue_item_t</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr><call><name>have_recursive_parent</name><argument_list>(<argument><expr>&amp;<name>have_any_recursive</name></expr></argument>,
                                <argument><expr><name><name>queue</name>-&gt;<name>queue</name></name></expr></argument>,
                                <argument><expr><name>i</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <continue>continue;</continue></then></if>

      <expr_stmt><expr><name>adm_path</name> = <call><name>svn_wc_adm_access_path</name><argument_list>(<argument><expr><name><name>cqi</name>-&gt;<name>adm_access</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>affected_adm</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>updated_adms</name></expr></argument>,
                                  <argument><expr><name>adm_path</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr>! <name>affected_adm</name></expr>)</condition><then>
        <block>{
          <comment type="block">/* allocate in pool instead of iterpool:
             we don't want this cleared at the next iteration */</comment>
          <expr_stmt><expr><name>affected_adm</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>affected_adm</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>affected_adm</name>-&gt;<name>next_log</name></name> = 0</expr>;</expr_stmt>
          <expr_stmt><expr><name><name>affected_adm</name>-&gt;<name>adm_access</name></name> = <name><name>cqi</name>-&gt;<name>adm_access</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>updated_adms</name></expr></argument>, <argument><expr><name>adm_path</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>,
                       <argument><expr><name>affected_adm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>process_committed_internal</name><argument_list>(<argument><expr>&amp;<name><name>affected_adm</name>-&gt;<name>next_log</name></name></expr></argument>, <argument><expr><name><name>cqi</name>-&gt;<name>path</name></name></expr></argument>,
                                         <argument><expr><name><name>cqi</name>-&gt;<name>adm_access</name></name></expr></argument>, <argument><expr><name><name>cqi</name>-&gt;<name>recurse</name></name></expr></argument>,
                                         <argument><expr><name>new_revnum</name></expr></argument>, <argument><expr><name>rev_date</name></expr></argument>, <argument><expr><name>rev_author</name></expr></argument>,
                                         <argument><expr><name><name>cqi</name>-&gt;<name>wcprop_changes</name></name></expr></argument>,
                                         <argument><expr><name><name>cqi</name>-&gt;<name>remove_lock</name></name></expr></argument>,
                                         <argument><expr><name><name>cqi</name>-&gt;<name>remove_changelist</name></name></expr></argument>,
                                         <argument><expr><name><name>cqi</name>-&gt;<name>digest</name></name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

  <comment type="block">/* ... and then we run them; all at once.

         This prevents writing the entries file
         more than once per adm area */</comment>
  <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>updated_adms</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>hi</name></expr>;</condition> <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
    <block>{
      <decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>affected_adm_t</name> *</type><name>this_adm</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>this_adm</name> = <name>val</name></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__run_log</name><argument_list>(<argument><expr><name><name>this_adm</name>-&gt;<name>adm_access</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

  <expr_stmt><expr><name><name>queue</name>-&gt;<name>queue</name>-&gt;<name>nelts</name></name> = 0</expr>;</expr_stmt>

  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_wc_process_committed4</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                          <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                          <param><decl><type><name>svn_boolean_t</name></type> <name>recurse</name></decl></param>,
                          <param><decl><type><name>svn_revnum_t</name></type> <name>new_revnum</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>rev_date</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>rev_author</name></decl></param>,
                          <param><decl><type><name>apr_array_header_t</name> *</type><name>wcprop_changes</name></decl></param>,
                          <param><decl><type><name>svn_boolean_t</name></type> <name>remove_lock</name></decl></param>,
                          <param><decl><type><name>svn_boolean_t</name></type> <name>remove_changelist</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>digest</name></decl></param>,
                          <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>log_number</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>process_committed_internal</name><argument_list>(<argument><expr>&amp;<name>log_number</name></expr></argument>,
                                     <argument><expr><name>path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>,
                                     <argument><expr><name>new_revnum</name></expr></argument>, <argument><expr><name>rev_date</name></expr></argument>, <argument><expr><name>rev_author</name></expr></argument>,
                                     <argument><expr><name>wcprop_changes</name></expr></argument>, <argument><expr><name>remove_lock</name></expr></argument>,
                                     <argument><expr><name>remove_changelist</name></expr></argument>, <argument><expr><name>digest</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Run the log file(s) we just created. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__run_log</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_wc_process_committed3</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                          <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                          <param><decl><type><name>svn_boolean_t</name></type> <name>recurse</name></decl></param>,
                          <param><decl><type><name>svn_revnum_t</name></type> <name>new_revnum</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>rev_date</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>rev_author</name></decl></param>,
                          <param><decl><type><name>apr_array_header_t</name> *</type><name>wcprop_changes</name></decl></param>,
                          <param><decl><type><name>svn_boolean_t</name></type> <name>remove_lock</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type><name>digest</name></decl></param>,
                          <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>svn_wc_process_committed4</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>new_revnum</name></expr></argument>,
                                   <argument><expr><name>rev_date</name></expr></argument>, <argument><expr><name>rev_author</name></expr></argument>, <argument><expr><name>wcprop_changes</name></expr></argument>,
                                   <argument><expr><name>remove_lock</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>digest</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_wc_process_committed2</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                          <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                          <param><decl><type><name>svn_boolean_t</name></type> <name>recurse</name></decl></param>,
                          <param><decl><type><name>svn_revnum_t</name></type> <name>new_revnum</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>rev_date</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>rev_author</name></decl></param>,
                          <param><decl><type><name>apr_array_header_t</name> *</type><name>wcprop_changes</name></decl></param>,
                          <param><decl><type><name>svn_boolean_t</name></type> <name>remove_lock</name></decl></param>,
                          <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>svn_wc_process_committed3</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>new_revnum</name></expr></argument>,
                                   <argument><expr><name>rev_date</name></expr></argument>, <argument><expr><name>rev_author</name></expr></argument>, <argument><expr><name>wcprop_changes</name></expr></argument>,
                                   <argument><expr><name>remove_lock</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_wc_process_committed</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                         <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                         <param><decl><type><name>svn_boolean_t</name></type> <name>recurse</name></decl></param>,
                         <param><decl><type><name>svn_revnum_t</name></type> <name>new_revnum</name></decl></param>,
                         <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>rev_date</name></decl></param>,
                         <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>rev_author</name></decl></param>,
                         <param><decl><type><name>apr_array_header_t</name> *</type><name>wcprop_changes</name></decl></param>,
                         <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>svn_wc_process_committed2</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>new_revnum</name></expr></argument>,
                                   <argument><expr><name>rev_date</name></expr></argument>, <argument><expr><name>rev_author</name></expr></argument>, <argument><expr><name>wcprop_changes</name></expr></argument>,
                                   <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Remove FILE if it exists and is a file.  If it does not exist, do
   nothing.  If it is not a file, error. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>remove_file_if_present</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>file</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>

  <comment type="block">/* Try to remove the file. */</comment>
  <expr_stmt><expr><name>err</name> = <call><name>svn_io_remove_file</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Ignore file not found error. */</comment>
  <if>if <condition>(<expr><name>err</name> &amp;&amp; <call><name>APR_STATUS_IS_ENOENT</name><argument_list>(<argument><expr><name><name>err</name>-&gt;<name>apr_err</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>err</name> = <name>SVN_NO_ERROR</name></expr>;</expr_stmt>
    }</block></then></if>

  <return>return <expr><name>err</name></expr>;</return>
}</block></function>

<escape char="0xc"/>
<comment type="block">/* Recursively mark a tree ADM_ACCESS with a SCHEDULE, COPIED and/or KEEP_LOCAL
   flag, depending on the state of MODIFY_FLAGS (which may contain only a
   subset of the possible modification flags, namely, those indicating a change
   to one of the three flags mentioned above). */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>mark_tree</name><parameter_list>(<param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
          <param><decl><type><name>apr_uint64_t</name></type> <name>modify_flags</name></decl></param>,
          <param><decl><type><name>svn_wc_schedule_t</name></type> <name>schedule</name></decl></param>,
          <param><decl><type><name>svn_boolean_t</name></type> <name>copied</name></decl></param>,
          <param><decl><type><name>svn_boolean_t</name></type> <name>keep_local</name></decl></param>,
          <param><decl><type><name>svn_cancel_func_t</name></type> <name>cancel_func</name></decl></param>,
          <param><decl><type><name>void</name> *</type><name>cancel_baton</name></decl></param>,
          <param><decl><type><name>svn_wc_notify_func2_t</name></type> <name>notify_func</name></decl></param>,
          <param><decl><type><name>void</name> *</type><name>notify_baton</name></decl></param>,
          <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>entries</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>entry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_wc_entry_t</name></type> <name>tmp_entry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_uint64_t</name></type> <name>this_dir_flags</name></decl>;</decl_stmt>

  <comment type="block">/* Read the entries file for this directory. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_entries_read</name><argument_list>(<argument><expr>&amp;<name>entries</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Mark each entry in the entries file. */</comment>
  <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>entries</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>hi</name></expr>;</condition> <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fullpath</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>base_name</name></decl>;</decl_stmt>

      <comment type="block">/* Clear our per-iteration pool. */</comment>
      <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Get the next entry */</comment>
      <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>entry</name> = <name>val</name></expr>;</expr_stmt>

      <comment type="block">/* Skip "this dir".  */</comment>
      <if>if <condition>(<expr>! <call><name>strcmp</name><argument_list>(<argument><expr>(const <name>char</name> *)<name>key</name></expr></argument>, <argument><expr><name>SVN_WC_ENTRY_THIS_DIR</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <continue>continue;</continue></then></if>

      <expr_stmt><expr><name>base_name</name> = <name>key</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>fullpath</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><call><name>svn_wc_adm_access_path</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>base_name</name></expr></argument>,
                               <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* If this is a directory, recurse. */</comment>
      <if>if <condition>(<expr><name><name>entry</name>-&gt;<name>kind</name></name> == <name>svn_node_dir</name></expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><name>svn_wc_adm_access_t</name> *</type><name>child_access</name></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_adm_retrieve</name><argument_list>(<argument><expr>&amp;<name>child_access</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>fullpath</name></expr></argument>,
                                      <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>mark_tree</name><argument_list>(<argument><expr><name>child_access</name></expr></argument>, <argument><expr><name>modify_flags</name></expr></argument>,
                            <argument><expr><name>schedule</name></expr></argument>, <argument><expr><name>copied</name></expr></argument>, <argument><expr><name>keep_local</name></expr></argument>,
                            <argument><expr><name>cancel_func</name></expr></argument>, <argument><expr><name>cancel_baton</name></expr></argument>,
                            <argument><expr><name>notify_func</name></expr></argument>, <argument><expr><name>notify_baton</name></expr></argument>,
                            <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

      <expr_stmt><expr><name><name>tmp_entry</name>.<name>schedule</name></name> = <name>schedule</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>tmp_entry</name>.<name>copied</name></name> = <name>copied</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__entry_modify</name>
              <argument_list>(<argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>base_name</name></expr></argument>, <argument><expr>&amp;<name>tmp_entry</name></expr></argument>,
               <argument><expr><name>modify_flags</name> &amp; (<name>SVN_WC__ENTRY_MODIFY_SCHEDULE</name>
                               | <name>SVN_WC__ENTRY_MODIFY_COPIED</name>)</expr></argument>,
               <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr><name>copied</name></expr>)</condition><then>
        <comment type="block">/* Remove now obsolete wcprops */</comment>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__props_delete</name><argument_list>(<argument><expr><name>fullpath</name></expr></argument>, <argument><expr><name>svn_wc__props_wcprop</name></expr></argument>,
                                     <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

      <comment type="block">/* Tell someone what we've done. */</comment>
      <if>if <condition>(<expr><name>schedule</name> == <name>svn_wc_schedule_delete</name> &amp;&amp; <name>notify_func</name> != <name>NULL</name></expr>)</condition><then>
        <expr_stmt><expr><call>(*<name>notify_func</name>)<argument_list>(<argument><expr><name>notify_baton</name></expr></argument>,
                       <argument><expr><call><name>svn_wc_create_notify</name><argument_list>(<argument><expr><name>fullpath</name></expr></argument>, <argument><expr><name>svn_wc_notify_delete</name></expr></argument>,
                                            <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></for>

  <comment type="block">/* Handle "this dir" for states that need it done post-recursion. */</comment>
  <expr_stmt><expr><name>entry</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>entries</name></expr></argument>, <argument><expr><name>SVN_WC_ENTRY_THIS_DIR</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>this_dir_flags</name> = 0</expr>;</expr_stmt>

  <comment type="block">/* Uncommitted directories (schedule add) that are to be scheduled for
     deletion are a special case, they don't need to be changed as they
     will be removed from their parent's entry list. */</comment>
  <if>if <condition>(<expr>! (<name><name>entry</name>-&gt;<name>schedule</name></name> == <name>svn_wc_schedule_add</name>
         &amp;&amp; <name>schedule</name> == <name>svn_wc_schedule_delete</name>)</expr>)</condition><then>
  <block>{
    <if>if <condition>(<expr><name>modify_flags</name> &amp; <name>SVN_WC__ENTRY_MODIFY_SCHEDULE</name></expr>)</condition><then>
      <block>{
        <expr_stmt><expr><name><name>tmp_entry</name>.<name>schedule</name></name> = <name>schedule</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>this_dir_flags</name> |= <name>SVN_WC__ENTRY_MODIFY_SCHEDULE</name></expr>;</expr_stmt>
      }</block></then></if>

    <if>if <condition>(<expr><name>modify_flags</name> &amp; <name>SVN_WC__ENTRY_MODIFY_COPIED</name></expr>)</condition><then>
      <block>{
        <expr_stmt><expr><name><name>tmp_entry</name>.<name>copied</name></name> = <name>copied</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>this_dir_flags</name> |= <name>SVN_WC__ENTRY_MODIFY_COPIED</name></expr>;</expr_stmt>
      }</block></then></if>
  }</block></then></if>

  <comment type="block">/* Set keep_local on the "this dir", if requested. */</comment>
  <if>if <condition>(<expr><name>modify_flags</name> &amp; <name>SVN_WC__ENTRY_MODIFY_KEEP_LOCAL</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name><name>tmp_entry</name>.<name>keep_local</name></name> = <name>keep_local</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>this_dir_flags</name> |= <name>SVN_WC__ENTRY_MODIFY_KEEP_LOCAL</name></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* Modify this_dir entry if requested. */</comment>
  <if>if <condition>(<expr><name>this_dir_flags</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__entry_modify</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>tmp_entry</name></expr></argument>, <argument><expr><name>this_dir_flags</name></expr></argument>,
                                 <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* Destroy our per-iteration pool. */</comment>
  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Remove/erase PATH from the working copy. This involves deleting PATH
 * from the physical filesystem. PATH is assumed to be an unversioned file
 * or directory.
 *
 * If CANCEL_FUNC is non-null, invoke it with CANCEL_BATON at various
 * points, return any error immediately.
 */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>erase_unversioned_from_wc</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                          <param><decl><type><name>svn_cancel_func_t</name></type> <name>cancel_func</name></decl></param>,
                          <param><decl><type><name>void</name> *</type><name>cancel_baton</name></decl></param>,
                          <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>

  <comment type="block">/* Optimize the common case: try to delete the file */</comment>
  <expr_stmt><expr><name>err</name> = <call><name>svn_io_remove_file</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* Then maybe it was a directory? */</comment>
      <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>err</name> = <call><name>svn_io_remove_dir2</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>cancel_func</name></expr></argument>, <argument><expr><name>cancel_baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
        <block>{
          <comment type="block">/* We're unlikely to end up here. But we need this fallback
             to make sure we report the right error *and* try the
             correct deletion at least once. */</comment>
          <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>

          <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_check_path</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>&amp;<name>kind</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>kind</name> == <name>svn_node_file</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_remove_file</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
          <else>else <if>if <condition>(<expr><name>kind</name> == <name>svn_node_dir</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_remove_dir2</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                                       <argument><expr><name>cancel_func</name></expr></argument>, <argument><expr><name>cancel_baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
          <else>else <if>if <condition>(<expr><name>kind</name> == <name>svn_node_none</name></expr>)</condition><then>
            <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_BAD_FILENAME</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                     <argument><expr><call><name>_</name><argument_list>(<argument><expr>"'%s' does not exist"</expr></argument>)</argument_list></call></expr></argument>,
                                     <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then>
          <else>else
            <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_UNSUPPORTED_FEATURE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                     <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Unsupported node kind for path '%s'"</expr></argument>)</argument_list></call></expr></argument>,
                                     <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></else></if></else></if></else></if>

        }</block></then></if>
    }</block></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Remove/erase PATH from the working copy. For files this involves
 * deletion from the physical filesystem.  For directories it involves the
 * deletion from the filesystem of all unversioned children, and all
 * versioned children that are files. By the time we get here, added but
 * not committed items will have been scheduled for deletion which means
 * they have become unversioned.
 *
 * The result is that all that remains are versioned directories, each with
 * its .svn directory and .svn contents.
 *
 * If CANCEL_FUNC is non-null, invoke it with CANCEL_BATON at various
 * points, return any error immediately.
 *
 * KIND is the node kind appropriate for PATH
 */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>erase_from_wc</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
              <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
              <param><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl></param>,
              <param><decl><type><name>svn_cancel_func_t</name></type> <name>cancel_func</name></decl></param>,
              <param><decl><type><name>void</name> *</type><name>cancel_baton</name></decl></param>,
              <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>entry</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>cancel_func</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>cancel_func</name><argument_list>(<argument><expr><name>cancel_baton</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <if>if <condition>(<expr><name>kind</name> == <name>svn_node_file</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>remove_file_if_present</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>

  <else>else <if>if <condition>(<expr><name>kind</name> == <name>svn_node_dir</name></expr>)</condition><then>
    <comment type="block">/* This must be a directory or absent */</comment>
    <block>{
      <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>ver</name></decl>, *<decl><type ref="prev"/><name>unver</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_wc_adm_access_t</name> *</type><name>dir_access</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>

      <comment type="block">/* ### Suspect that an iteration or recursion subpool would be
         good here. */</comment>

      <comment type="block">/* First handle the versioned items, this is better (probably) than
         simply using svn_io_get_dirents2 for everything as it avoids the
         need to do svn_io_check_path on each versioned item */</comment>
      <expr_stmt><expr><name>err</name> = <call><name>svn_wc_adm_retrieve</name><argument_list>(<argument><expr>&amp;<name>dir_access</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* If there's no on-disk item, be sure to exit early and
         not to return an error */</comment>
      <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>wc_kind</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err2</name> <init>= <expr><call><name>svn_io_check_path</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>&amp;<name>wc_kind</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

          <if>if <condition>(<expr><name>err2</name></expr>)</condition><then>
            <block>{
              <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <return>return <expr><name>err2</name></expr>;</return>
            }</block></then></if>

          <if>if <condition>(<expr><name>wc_kind</name> != <name>svn_node_none</name></expr>)</condition><then>
            <return>return <expr><name>err</name></expr>;</return></then></if>

          <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
        }</block></then></if>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_entries_read</name><argument_list>(<argument><expr>&amp;<name>ver</name></expr></argument>, <argument><expr><name>dir_access</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>ver</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>hi</name></expr>;</condition> <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
        <block>{
          <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>down_path</name></decl>;</decl_stmt>

          <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>name</name> = <name>key</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>entry</name> = <name>val</name></expr>;</expr_stmt>

          <if>if <condition>(<expr>!<call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>SVN_WC_ENTRY_THIS_DIR</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <continue>continue;</continue></then></if>

          <expr_stmt><expr><name>down_path</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>erase_from_wc</name><argument_list>(<argument><expr><name>down_path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name><name>entry</name>-&gt;<name>kind</name></name></expr></argument>,
                                <argument><expr><name>cancel_func</name></expr></argument>, <argument><expr><name>cancel_baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>

      <comment type="block">/* Now handle any remaining unversioned items */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_get_dirents2</name><argument_list>(<argument><expr>&amp;<name>unver</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>unver</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>hi</name></expr>;</condition> <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
        <block>{
          <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>down_path</name></decl>;</decl_stmt>

          <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>name</name> = <name>key</name></expr>;</expr_stmt>

          <comment type="block">/* The admin directory will show up, we don't want to delete it */</comment>
          <if>if <condition>(<expr><call><name>svn_wc_is_adm_dir</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <continue>continue;</continue></then></if>

          <comment type="block">/* Versioned directories will show up, don't delete those either */</comment>
          <if>if <condition>(<expr><call><name>apr_hash_get</name><argument_list>(<argument><expr><name>ver</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <continue>continue;</continue></then></if>

          <expr_stmt><expr><name>down_path</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>erase_unversioned_from_wc</name>
                  <argument_list>(<argument><expr><name>down_path</name></expr></argument>, <argument><expr><name>cancel_func</name></expr></argument>, <argument><expr><name>cancel_baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
    }</block></then></if></else></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_wc_delete3</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
               <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
               <param><decl><type><name>svn_cancel_func_t</name></type> <name>cancel_func</name></decl></param>,
               <param><decl><type><name>void</name> *</type><name>cancel_baton</name></decl></param>,
               <param><decl><type><name>svn_wc_notify_func2_t</name></type> <name>notify_func</name></decl></param>,
               <param><decl><type><name>void</name> *</type><name>notify_baton</name></decl></param>,
               <param><decl><type><name>svn_boolean_t</name></type> <name>keep_local</name></decl></param>,
               <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_wc_adm_access_t</name> *</type><name>dir_access</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>entry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>parent</name></decl>, *<decl><type ref="prev"/><name>base_name</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>was_schedule</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>was_kind</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>was_copied</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>was_deleted</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt> <comment type="block">/* Silence a gcc uninitialized warning */</comment>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_adm_probe_try3</name><argument_list>(<argument><expr>&amp;<name>dir_access</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
                                <argument><expr><name>TRUE</name></expr></argument>, <argument><expr>-1</expr></argument>, <argument><expr><name>cancel_func</name></expr></argument>, <argument><expr><name>cancel_baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>dir_access</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_entry</name><argument_list>(<argument><expr>&amp;<name>entry</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>dir_access</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name>entry</name> = <name>NULL</name></expr>;</expr_stmt></else></if>

  <if>if <condition>(<expr>!<name>entry</name></expr>)</condition><then>
    <return>return <expr><call><name>erase_unversioned_from_wc</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>cancel_func</name></expr></argument>, <argument><expr><name>cancel_baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Note: Entries caching?  What happens to this entry when the entries
     file is updated?  Lets play safe and copy the values */</comment>
  <expr_stmt><expr><name>was_schedule</name> = <name><name>entry</name>-&gt;<name>schedule</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>was_kind</name> = <name><name>entry</name>-&gt;<name>kind</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>was_copied</name> = <name><name>entry</name>-&gt;<name>copied</name></name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>svn_path_split</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>&amp;<name>parent</name></expr></argument>, <argument><expr>&amp;<name>base_name</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>was_kind</name> == <name>svn_node_dir</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_wc_adm_access_t</name> *</type><name>parent_access</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>entries</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>entry_in_parent</name></decl>;</decl_stmt>

      <comment type="block">/* The deleted state is only available in the entry in parent's
         entries file */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_adm_retrieve</name><argument_list>(<argument><expr>&amp;<name>parent_access</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_entries_read</name><argument_list>(<argument><expr>&amp;<name>entries</name></expr></argument>, <argument><expr><name>parent_access</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>entry_in_parent</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>entries</name></expr></argument>, <argument><expr><name>base_name</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>was_deleted</name> = <name>entry_in_parent</name> ? <name><name>entry_in_parent</name>-&gt;<name>deleted</name></name> : <name>FALSE</name></expr>;</expr_stmt>

      <if>if <condition>(<expr><name>was_schedule</name> == <name>svn_wc_schedule_add</name> &amp;&amp; !<name>was_deleted</name></expr>)</condition><then>
        <block>{
          <comment type="block">/* Deleting a directory that has been added but not yet
             committed is easy, just remove the administrative dir. */</comment>

          <if>if <condition>(<expr><name>dir_access</name> != <name>adm_access</name></expr>)</condition><then>
            <block>{
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_remove_from_revision_control</name>
                      <argument_list>(<argument><expr><name>dir_access</name></expr></argument>, <argument><expr><name>SVN_WC_ENTRY_THIS_DIR</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                       <argument><expr><name>cancel_func</name></expr></argument>, <argument><expr><name>cancel_baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
          <else>else
            <block>{
              <comment type="block">/* adm_probe_retrieve returned the parent access baton,
                 which is the same access baton that we came in here
                 with!  this means we're dealing with a missing item
                 that's scheduled for addition.  Easiest to just
                 remove the entry.  */</comment>
              <expr_stmt><expr><call><name>svn_wc__entry_remove</name><argument_list>(<argument><expr><name>entries</name></expr></argument>, <argument><expr><name>base_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__entries_write</name><argument_list>(<argument><expr><name>entries</name></expr></argument>, <argument><expr><name>parent_access</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></then>
      <else>else
        <block>{
          <comment type="block">/* if adm_probe_retrieve returned the parent access baton,
             (which is the same access baton that we came in here
             with), this means we're dealing with a missing directory.
             So there's no tree to mark for deletion.  Instead, the
             next phase of code will simply schedule the directory for
             deletion in its parent. */</comment>
          <if>if <condition>(<expr><name>dir_access</name> != <name>adm_access</name></expr>)</condition><then>
            <block>{
              <comment type="block">/* Recursively mark a whole tree for deletion. */</comment>
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>mark_tree</name><argument_list>(<argument><expr><name>dir_access</name></expr></argument>,
                                <argument><expr><name>SVN_WC__ENTRY_MODIFY_SCHEDULE</name>
                                | <name>SVN_WC__ENTRY_MODIFY_KEEP_LOCAL</name></expr></argument>,
                                <argument><expr><name>svn_wc_schedule_delete</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>keep_local</name></expr></argument>,
                                <argument><expr><name>cancel_func</name></expr></argument>, <argument><expr><name>cancel_baton</name></expr></argument>,
                                <argument><expr><name>notify_func</name></expr></argument>, <argument><expr><name>notify_baton</name></expr></argument>,
                                <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></else></if>
    }</block></then></if>

  <if>if <condition>(<expr>!(<name>was_kind</name> == <name>svn_node_dir</name> &amp;&amp; <name>was_schedule</name> == <name>svn_wc_schedule_add</name>
        &amp;&amp; !<name>was_deleted</name>)</expr>)</condition><then>
    <block>{
      <comment type="block">/* We need to mark this entry for deletion in its parent's entries
         file, so we split off base_name from the parent path, then fold in
         the addition of a delete flag. */</comment>
      <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>log_accum</name> <init>= <expr><call><name>svn_stringbuf_create</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_wc_entry_t</name></type> <name>tmp_entry</name></decl>;</decl_stmt>

      <comment type="block">/* Edit the entry to reflect the now deleted state.
         entries.c:fold_entry() clears the values of copied, copyfrom_rev
         and copyfrom_url. */</comment>
      <expr_stmt><expr><name><name>tmp_entry</name>.<name>schedule</name></name> = <name>svn_wc_schedule_delete</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_entry_modify</name><argument_list>(<argument><expr>&amp;<name>log_accum</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                                         <argument><expr><name>path</name></expr></argument>, <argument><expr>&amp;<name>tmp_entry</name></expr></argument>,
                                         <argument><expr><name>SVN_WC__ENTRY_MODIFY_SCHEDULE</name></expr></argument>,
                                         <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* is it a replacement with history? */</comment>
      <if>if <condition>(<expr><name>was_schedule</name> == <name>svn_wc_schedule_replace</name> &amp;&amp; <name>was_copied</name></expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>text_base</name> <init>=
            <expr><call><name>svn_wc__text_base_path</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>text_revert</name> <init>=
            <expr><call><name>svn_wc__text_revert_path</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

          <if>if <condition>(<expr><name>was_kind</name> != <name>svn_node_dir</name></expr>)</condition><then> <comment type="block">/* Dirs don't have text-bases */</comment>
            <comment type="block">/* Restore the original text-base */</comment>
            <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_move</name><argument_list>(<argument><expr>&amp;<name>log_accum</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                                       <argument><expr><name>text_revert</name></expr></argument>, <argument><expr><name>text_base</name></expr></argument>,
                                       <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_revert_props_restore</name><argument_list>(<argument><expr>&amp;<name>log_accum</name></expr></argument>,
                                                     <argument><expr><name>path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
      <if>if <condition>(<expr><name>was_schedule</name> == <name>svn_wc_schedule_add</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_props_delete</name><argument_list>(<argument><expr>&amp;<name>log_accum</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
                                           <argument><expr><name>svn_wc__props_base</name></expr></argument>,
                                           <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__write_log</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>log_accum</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__run_log</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    }</block></then></if>

  <comment type="block">/* Report the deletion to the caller. */</comment>
  <if>if <condition>(<expr><name>notify_func</name> != <name>NULL</name></expr>)</condition><then>
    <expr_stmt><expr><call>(*<name>notify_func</name>)<argument_list>(<argument><expr><name>notify_baton</name></expr></argument>,
                   <argument><expr><call><name>svn_wc_create_notify</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>svn_wc_notify_delete</name></expr></argument>,
                                        <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* By the time we get here, anything that was scheduled to be added has
     become unversioned */</comment>
  <if>if <condition>(<expr>!<name>keep_local</name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr><name>was_schedule</name> == <name>svn_wc_schedule_add</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>erase_unversioned_from_wc</name>
                <argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>cancel_func</name></expr></argument>, <argument><expr><name>cancel_baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
      <else>else
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>erase_from_wc</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>was_kind</name></expr></argument>,
                              <argument><expr><name>cancel_func</name></expr></argument>, <argument><expr><name>cancel_baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
    }</block></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_wc_delete2</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
               <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
               <param><decl><type><name>svn_cancel_func_t</name></type> <name>cancel_func</name></decl></param>,
               <param><decl><type><name>void</name> *</type><name>cancel_baton</name></decl></param>,
               <param><decl><type><name>svn_wc_notify_func2_t</name></type> <name>notify_func</name></decl></param>,
               <param><decl><type><name>void</name> *</type><name>notify_baton</name></decl></param>,
               <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>svn_wc_delete3</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>cancel_func</name></expr></argument>, <argument><expr><name>cancel_baton</name></expr></argument>,
                        <argument><expr><name>notify_func</name></expr></argument>, <argument><expr><name>notify_baton</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_wc_delete</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
              <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
              <param><decl><type><name>svn_cancel_func_t</name></type> <name>cancel_func</name></decl></param>,
              <param><decl><type><name>void</name> *</type><name>cancel_baton</name></decl></param>,
              <param><decl><type><name>svn_wc_notify_func_t</name></type> <name>notify_func</name></decl></param>,
              <param><decl><type><name>void</name> *</type><name>notify_baton</name></decl></param>,
              <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_wc__compat_notify_baton_t</name></type> <name>nb</name></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>nb</name>.<name>func</name></name> = <name>notify_func</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>nb</name>.<name>baton</name></name> = <name>notify_baton</name></expr>;</expr_stmt>

  <return>return <expr><call><name>svn_wc_delete2</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>cancel_func</name></expr></argument>, <argument><expr><name>cancel_baton</name></expr></argument>,
                        <argument><expr><name>svn_wc__compat_call_notify_func</name></expr></argument>, <argument><expr>&amp;<name>nb</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_wc_get_ancestry</name><parameter_list>(<param><decl><type><name>char</name> **</type><name>url</name></decl></param>,
                    <param><decl><type><name>svn_revnum_t</name> *</type><name>rev</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                    <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>ent</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__entry_versioned</name><argument_list>(<argument><expr>&amp;<name>ent</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>url</name></expr>)</condition><then>
    <expr_stmt><expr>*<name>url</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>ent</name>-&gt;<name>url</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <if>if <condition>(<expr><name>rev</name></expr>)</condition><then>
    <expr_stmt><expr>*<name>rev</name> = <name><name>ent</name>-&gt;<name>revision</name></name></expr>;</expr_stmt></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_wc_add2</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
            <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>parent_access</name></decl></param>,
            <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copyfrom_url</name></decl></param>,
            <param><decl><type><name>svn_revnum_t</name></type> <name>copyfrom_rev</name></decl></param>,
            <param><decl><type><name>svn_cancel_func_t</name></type> <name>cancel_func</name></decl></param>,
            <param><decl><type><name>void</name> *</type><name>cancel_baton</name></decl></param>,
            <param><decl><type><name>svn_wc_notify_func2_t</name></type> <name>notify_func</name></decl></param>,
            <param><decl><type><name>void</name> *</type><name>notify_baton</name></decl></param>,
            <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>parent_dir</name></decl>, *<decl><type ref="prev"/><name>base_name</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>orig_entry</name></decl>, *<decl><type ref="prev"/><name>parent_entry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_wc_entry_t</name></type> <name>tmp_entry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>is_replace</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_uint64_t</name></type> <name>modify_flags</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_path_check_valid</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Make sure something's there. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_check_path</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>&amp;<name>kind</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>kind</name> == <name>svn_node_none</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_WC_PATH_NOT_FOUND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><call><name>_</name><argument_list>(<argument><expr>"'%s' not found"</expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
  <if>if <condition>(<expr><name>kind</name> == <name>svn_node_unknown</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_UNSUPPORTED_FEATURE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Unsupported node kind for path '%s'"</expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Get the original entry for this path if one exists (perhaps
     this is actually a replacement of a previously deleted thing).

     Note that this is one of the few functions that is allowed to see
     'deleted' entries;  it's totally fine to have an entry that is
     scheduled for addition and still previously 'deleted'.  */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_adm_probe_try3</name><argument_list>(<argument><expr>&amp;<name>adm_access</name></expr></argument>, <argument><expr><name>parent_access</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
                                <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>copyfrom_url</name> != <name>NULL</name> ? -1 : 0</expr></argument>,
                                <argument><expr><name>cancel_func</name></expr></argument>, <argument><expr><name>cancel_baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>adm_access</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_entry</name><argument_list>(<argument><expr>&amp;<name>orig_entry</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name>orig_entry</name> = <name>NULL</name></expr>;</expr_stmt></else></if>

  <comment type="block">/* You can only add something that is not in revision control, or
     that is slated for deletion from revision control, or has been
     previously 'deleted', unless, of course, you're specifying an
     addition with -history-; then it's okay for the object to be
     under version control already; it's not really new.  */</comment>
  <if>if <condition>(<expr><name>orig_entry</name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr>(! <name>copyfrom_url</name>)
          &amp;&amp; (<name><name>orig_entry</name>-&gt;<name>schedule</name></name> != <name>svn_wc_schedule_delete</name>)
          &amp;&amp; (! <name><name>orig_entry</name>-&gt;<name>deleted</name></name>)</expr>)</condition><then>
        <block>{
          <return>return <expr><call><name>svn_error_createf</name>
            <argument_list>(<argument><expr><name>SVN_ERR_ENTRY_EXISTS</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
             <argument><expr><call><name>_</name><argument_list>(<argument><expr>"'%s' is already under version control"</expr></argument>)</argument_list></call></expr></argument>,
             <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then>
      <else>else <if>if <condition>(<expr><name><name>orig_entry</name>-&gt;<name>kind</name></name> != <name>kind</name></expr>)</condition><then>
        <block>{
          <comment type="block">/* ### todo: At some point, we obviously don't want to block
             replacements where the node kind changes.  When this
             happens, svn_wc_revert3() needs to learn how to revert
             this situation.  At present we are using a specific node-change
             error so that clients can detect it. */</comment>
          <return>return <expr><call><name>svn_error_createf</name>
            <argument_list>(<argument><expr><name>SVN_ERR_WC_NODE_KIND_CHANGE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
             <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't replace '%s' with a node of a differing type; "
               "the deletion must be committed and the parent updated "
               "before adding '%s'"</expr></argument>)</argument_list></call></expr></argument>,
             <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
             <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if></else></if>
      <if>if <condition>(<expr><name><name>orig_entry</name>-&gt;<name>schedule</name></name> == <name>svn_wc_schedule_delete</name></expr>)</condition><then>
        <expr_stmt><expr><name>is_replace</name> = <name>TRUE</name></expr>;</expr_stmt></then></if>
    }</block></then></if>

  <comment type="block">/* Split off the base_name from the parent directory. */</comment>
  <expr_stmt><expr><call><name>svn_path_split</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>&amp;<name>parent_dir</name></expr></argument>, <argument><expr>&amp;<name>base_name</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_entry</name><argument_list>(<argument><expr>&amp;<name>parent_entry</name></expr></argument>, <argument><expr><name>parent_dir</name></expr></argument>, <argument><expr><name>parent_access</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                       <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>! <name>parent_entry</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name>
      <argument_list>(<argument><expr><name>SVN_ERR_ENTRY_NOT_FOUND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't find parent directory's entry while trying to add '%s'"</expr></argument>)</argument_list></call></expr></argument>,
       <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
  <if>if <condition>(<expr><name><name>parent_entry</name>-&gt;<name>schedule</name></name> == <name>svn_wc_schedule_delete</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name>
      <argument_list>(<argument><expr><name>SVN_ERR_WC_SCHEDULE_CONFLICT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't add '%s' to a parent directory scheduled for deletion"</expr></argument>)</argument_list></call></expr></argument>,
       <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Init the modify flags. */</comment>
  <expr_stmt><expr><name>modify_flags</name> = <name>SVN_WC__ENTRY_MODIFY_SCHEDULE</name> | <name>SVN_WC__ENTRY_MODIFY_KIND</name></expr>;</expr_stmt>
  <if>if <condition>(<expr>! (<name>is_replace</name> || <name>copyfrom_url</name>)</expr>)</condition><then>
    <expr_stmt><expr><name>modify_flags</name> |= <name>SVN_WC__ENTRY_MODIFY_REVISION</name></expr>;</expr_stmt></then></if>

  <comment type="block">/* If a copy ancestor was given, make sure the copyfrom URL is in the same
     repository (if possible) and put the proper ancestry info in the new
     entry */</comment>
  <if>if <condition>(<expr><name>copyfrom_url</name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr><name><name>parent_entry</name>-&gt;<name>repos</name></name>
          &amp;&amp; ! <call><name>svn_path_is_ancestor</name><argument_list>(<argument><expr><name><name>parent_entry</name>-&gt;<name>repos</name></name></expr></argument>, <argument><expr><name>copyfrom_url</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_UNSUPPORTED_FEATURE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                 <argument><expr><call><name>_</name><argument_list>(<argument><expr>"The URL '%s' has a different repository "
                                   "root than its parent"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>copyfrom_url</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
      <expr_stmt><expr><name><name>tmp_entry</name>.<name>copyfrom_url</name></name> = <name>copyfrom_url</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>tmp_entry</name>.<name>copyfrom_rev</name></name> = <name>copyfrom_rev</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>tmp_entry</name>.<name>copied</name></name> = <name>TRUE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>modify_flags</name> |= <name>SVN_WC__ENTRY_MODIFY_COPYFROM_URL</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>modify_flags</name> |= <name>SVN_WC__ENTRY_MODIFY_COPYFROM_REV</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>modify_flags</name> |= <name>SVN_WC__ENTRY_MODIFY_COPIED</name></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* If this is a replacement we want to remove the checksum and the property
     flags so they are not set to their respective old values. */</comment>
  <if>if <condition>(<expr><name>is_replace</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name><name>tmp_entry</name>.<name>checksum</name></name> = <name>NULL</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>modify_flags</name> |= <name>SVN_WC__ENTRY_MODIFY_CHECKSUM</name></expr>;</expr_stmt>

      <expr_stmt><expr><name><name>tmp_entry</name>.<name>has_props</name></name> = <name>FALSE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>tmp_entry</name>.<name>has_prop_mods</name></name> = <name>FALSE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>modify_flags</name> |= <name>SVN_WC__ENTRY_MODIFY_HAS_PROPS</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>modify_flags</name> |= <name>SVN_WC__ENTRY_MODIFY_HAS_PROP_MODS</name></expr>;</expr_stmt>
    }</block></then></if>

  <expr_stmt><expr><name><name>tmp_entry</name>.<name>revision</name></name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>tmp_entry</name>.<name>kind</name></name> = <name>kind</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>tmp_entry</name>.<name>schedule</name></name> = <name>svn_wc_schedule_add</name></expr>;</expr_stmt>

  <comment type="block">/* Now, add the entry for this item to the parent_dir's
     entries file, marking it for addition. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__entry_modify</name><argument_list>(<argument><expr><name>parent_access</name></expr></argument>, <argument><expr><name>base_name</name></expr></argument>, <argument><expr>&amp;<name>tmp_entry</name></expr></argument>,
                               <argument><expr><name>modify_flags</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


  <comment type="block">/* If this is a replacement without history, we need to reset the
     properties for PATH. */</comment>
  <if>if <condition>(<expr><name>orig_entry</name> &amp;&amp; (! <name>copyfrom_url</name>)</expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__props_delete</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>svn_wc__props_working</name></expr></argument>,
                                 <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <if>if <condition>(<expr><name>kind</name> == <name>svn_node_dir</name></expr>)</condition><then> <comment type="block">/* scheduling a directory for addition */</comment>
    <block>{
      <comment type="block">/* Note that both calls to svn_wc_ensure_adm3() below pass
         svn_depth_infinity.  Even if 'svn add' were invoked with some
         other depth, we'd want to create the adm area with
         svn_depth_infinity, because when the user passes add a depth,
         that's just a way of telling Subversion what items to add,
         not a way of telling Subversion what depth the resultant
         newly-versioned directory should have. */</comment>

      <if>if <condition>(<expr>! <name>copyfrom_url</name></expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>p_entry</name></decl>;</decl_stmt> <comment type="block">/* ### why not use parent_entry? */</comment>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>new_url</name></decl>;</decl_stmt>

          <comment type="block">/* Get the entry for this directory's parent.  We need to snatch
             the ancestor path out of there. */</comment>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_entry</name><argument_list>(<argument><expr>&amp;<name>p_entry</name></expr></argument>, <argument><expr><name>parent_dir</name></expr></argument>, <argument><expr><name>parent_access</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                               <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Derive the parent path for our new addition here. */</comment>
          <expr_stmt><expr><name>new_url</name> = <call><name>svn_path_url_add_component</name><argument_list>(<argument><expr><name><name>p_entry</name>-&gt;<name>url</name></name></expr></argument>, <argument><expr><name>base_name</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Make sure this new directory has an admistrative subdirectory
             created inside of it */</comment>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_ensure_adm3</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>new_url</name></expr></argument>, <argument><expr><name><name>p_entry</name>-&gt;<name>repos</name></name></expr></argument>,
                                     <argument><expr>0</expr></argument>, <argument><expr><name>svn_depth_infinity</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
      <else>else
        <block>{
          <comment type="block">/* When we are called with the copyfrom arguments set and with
             the admin directory already in existence, then the dir will
             contain the copyfrom settings.  So we need to pass the
             copyfrom arguments to the ensure call. */</comment>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_ensure_adm3</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>copyfrom_url</name></expr></argument>,
                                     <argument><expr><name><name>parent_entry</name>-&gt;<name>repos</name></name></expr></argument>, <argument><expr><name>copyfrom_rev</name></expr></argument>,
                                     <argument><expr><name>svn_depth_infinity</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>

      <comment type="block">/* We want the locks to persist, so use the access baton's pool */</comment>
      <if>if <condition>(<expr>! <name>orig_entry</name> || <name><name>orig_entry</name>-&gt;<name>deleted</name></name></expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><name>apr_pool_t</name>*</type> <name>access_pool</name> <init>= <expr><call><name>svn_wc_adm_access_pool</name><argument_list>(<argument><expr><name>parent_access</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_adm_open3</name><argument_list>(<argument><expr>&amp;<name>adm_access</name></expr></argument>, <argument><expr><name>parent_access</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
                                   <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>copyfrom_url</name> != <name>NULL</name> ? -1 : 0</expr></argument>,
                                   <argument><expr><name>cancel_func</name></expr></argument>, <argument><expr><name>cancel_baton</name></expr></argument>,
                                   <argument><expr><name>access_pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

      <comment type="block">/* We're making the same mods we made above, but this time we'll
         force the scheduling.  Also make sure to undo the
         'incomplete' flag which svn_wc_ensure_adm3 sets by default. */</comment>
      <expr_stmt><expr><name>modify_flags</name> |= <name>SVN_WC__ENTRY_MODIFY_FORCE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>modify_flags</name> |= <name>SVN_WC__ENTRY_MODIFY_INCOMPLETE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>tmp_entry</name>.<name>schedule</name></name> = <name>is_replace</name>
                           ? <name>svn_wc_schedule_replace</name>
                           : <name>svn_wc_schedule_add</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>tmp_entry</name>.<name>incomplete</name></name> = <name>FALSE</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__entry_modify</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>tmp_entry</name></expr></argument>,
                                   <argument><expr><name>modify_flags</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr><name>copyfrom_url</name></expr>)</condition><then>
        <block>{
          <comment type="block">/* If this new directory has ancestry, it's not enough to
             schedule it for addition with copyfrom args.  We also
             need to rewrite its ancestor-url, and rewrite the
             ancestor-url of ALL its children!

             We're doing this because our current commit model (for
             hysterical raisins, presumably) assumes an entry's URL is
             correct before commit -- i.e. the URL is not tweaked in
             the post-commit bumping process.  We might want to change
             this model someday. */</comment>

          <comment type="block">/* Figure out what the new url should be. */</comment>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>new_url</name> <init>=
            <expr><call><name>svn_path_url_add_component</name><argument_list>(<argument><expr><name><name>parent_entry</name>-&gt;<name>url</name></name></expr></argument>, <argument><expr><name>base_name</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

          <comment type="block">/* Change the entry urls recursively (but not the working rev). */</comment>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__do_update_cleanup</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                                            <argument><expr><name>svn_depth_infinity</name></expr></argument>, <argument><expr><name>new_url</name></expr></argument>,
                                            <argument><expr><name><name>parent_entry</name>-&gt;<name>repos</name></name></expr></argument>,
                                            <argument><expr><name>SVN_INVALID_REVNUM</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                            <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                                            <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Recursively add the 'copied' existence flag as well!  */</comment>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>mark_tree</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>SVN_WC__ENTRY_MODIFY_COPIED</name></expr></argument>,
                            <argument><expr><name>svn_wc_schedule_normal</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                            <argument><expr><name>cancel_func</name></expr></argument>,
                            <argument><expr><name>cancel_baton</name></expr></argument>,
                            <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <comment type="block">/* N/A cuz we aren't deleting */</comment>
                            <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Clean out the now-obsolete wcprops. */</comment>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__props_delete</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>svn_wc__props_wcprop</name></expr></argument>,
                                       <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>

  <comment type="block">/* Report the addition to the caller. */</comment>
  <if>if <condition>(<expr><name>notify_func</name> != <name>NULL</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_wc_notify_t</name> *</type><name>notify</name> <init>= <expr><call><name>svn_wc_create_notify</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>svn_wc_notify_add</name></expr></argument>,
                                                     <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>notify</name>-&gt;<name>kind</name></name> = <name>kind</name></expr>;</expr_stmt>
      <expr_stmt><expr><call>(*<name>notify_func</name>)<argument_list>(<argument><expr><name>notify_baton</name></expr></argument>, <argument><expr><name>notify</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_wc_add</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
           <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>parent_access</name></decl></param>,
           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copyfrom_url</name></decl></param>,
           <param><decl><type><name>svn_revnum_t</name></type> <name>copyfrom_rev</name></decl></param>,
           <param><decl><type><name>svn_cancel_func_t</name></type> <name>cancel_func</name></decl></param>,
           <param><decl><type><name>void</name> *</type><name>cancel_baton</name></decl></param>,
           <param><decl><type><name>svn_wc_notify_func_t</name></type> <name>notify_func</name></decl></param>,
           <param><decl><type><name>void</name> *</type><name>notify_baton</name></decl></param>,
           <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_wc__compat_notify_baton_t</name></type> <name>nb</name></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>nb</name>.<name>func</name></name> = <name>notify_func</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>nb</name>.<name>baton</name></name> = <name>notify_baton</name></expr>;</expr_stmt>

  <return>return <expr><call><name>svn_wc_add2</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>parent_access</name></expr></argument>, <argument><expr><name>copyfrom_url</name></expr></argument>, <argument><expr><name>copyfrom_rev</name></expr></argument>,
                     <argument><expr><name>cancel_func</name></expr></argument>, <argument><expr><name>cancel_baton</name></expr></argument>,
                     <argument><expr><name>svn_wc__compat_call_notify_func</name></expr></argument>, <argument><expr>&amp;<name>nb</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<escape char="0xc"/>
<comment type="block">/* Thoughts on Reversion.

    What does is mean to revert a given PATH in a tree?  We'll
    consider things by their modifications.

    Adds

    - For files, svn_wc_remove_from_revision_control(), baby.

    - Added directories may contain nothing but added children, and
      reverting the addition of a directory necessarily means reverting
      the addition of all the directory's children.  Again,
      svn_wc_remove_from_revision_control() should do the trick.

    Deletes

    - Restore properties to their unmodified state.

    - For files, restore the pristine contents, and reset the schedule
      to 'normal'.

    - For directories, reset the schedule to 'normal'.  All children
      of a directory marked for deletion must also be marked for
      deletion, but it's okay for those children to remain deleted even
      if their parent directory is restored.  That's what the
      recursive flag is for.

    Replaces

    - Restore properties to their unmodified state.

    - For files, restore the pristine contents, and reset the schedule
      to 'normal'.

    - For directories, reset the schedule to normal.  A replaced
      directory can have deleted children (left over from the initial
      deletion), replaced children (children of the initial deletion
      now re-added), and added children (new entries under the
      replaced directory).  Since this is technically an addition, it
      necessitates recursion.

    Modifications

    - Restore properties and, for files, contents to their unmodified
      state.

*/</comment>

<comment type="block">/* Revert ENTRY for NAME in directory represented by ADM_ACCESS. Sets
   *REVERTED to TRUE if something actually is reverted.

   Use SVN_WC_ENTRY_THIS_DIR as NAME for reverting ADM_ACCESS directory
   itself.

   Use POOL for any temporary allocations.*/</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>revert_admin_things</name><parameter_list>(<param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>entry</name></decl></param>,
                    <param><decl><type><name>svn_boolean_t</name> *</type><name>reverted</name></decl></param>,
                    <param><decl><type><name>svn_boolean_t</name></type> <name>use_commit_times</name></decl></param>,
                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fullpath</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>reinstall_working</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt> <comment type="block">/* force working file reinstall? */</comment>
  <decl_stmt><decl><type><name>svn_wc_entry_t</name></type> <name>tmp_entry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_uint64_t</name></type> <name>flags</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>log_accum</name> <init>= <expr><call><name>svn_stringbuf_create</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>baseprops</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>revert_base</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Build the full path of the thing we're reverting. */</comment>
  <expr_stmt><expr><name>fullpath</name> = <call><name>svn_wc_adm_access_path</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>SVN_WC_ENTRY_THIS_DIR</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
    <expr_stmt><expr><name>fullpath</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>fullpath</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* Deal with properties. */</comment>
  <if>if <condition>(<expr><name><name>entry</name>-&gt;<name>schedule</name></name> == <name>svn_wc_schedule_replace</name></expr>)</condition><then>
    <block>{
       <expr_stmt><expr><name>revert_base</name> = <name><name>entry</name>-&gt;<name>copied</name></name></expr>;</expr_stmt>
      <comment type="block">/* Use the revertpath as the new propsbase if it exists. */</comment>

      <expr_stmt><expr><name>baseprops</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__load_props</name><argument_list>(<argument><expr>(! <name>revert_base</name>) ? &amp;<name>baseprops</name> : <name>NULL</name></expr></argument>,
                                 <argument><expr><name>NULL</name></expr></argument>,
                                 <argument><expr><name>revert_base</name> ? &amp;<name>baseprops</name> : <name>NULL</name></expr></argument>,
                                 <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>fullpath</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Ensure the revert propfile gets removed. */</comment>
      <if>if <condition>(<expr><name>revert_base</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_props_delete</name><argument_list>(<argument><expr>&amp;<name>log_accum</name></expr></argument>,
                                           <argument><expr><name>fullpath</name></expr></argument>, <argument><expr><name>svn_wc__props_revert</name></expr></argument>,
                                           <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
      <expr_stmt><expr>*<name>reverted</name> = <name>TRUE</name></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* If not schedule replace, or no revert props, use the normal
     base-props and working props. */</comment>
  <if>if <condition>(<expr>! <name>baseprops</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>modified</name></decl>;</decl_stmt>

      <comment type="block">/* Check for prop changes. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_props_modified_p</name><argument_list>(<argument><expr>&amp;<name>modified</name></expr></argument>, <argument><expr><name>fullpath</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                                      <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>modified</name></expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>propchanges</name></decl>;</decl_stmt>

          <comment type="block">/* Get the full list of property changes and see if any magic
             properties were changed. */</comment>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_get_prop_diffs</name><argument_list>(<argument><expr>&amp;<name>propchanges</name></expr></argument>, <argument><expr>&amp;<name>baseprops</name></expr></argument>, <argument><expr><name>fullpath</name></expr></argument>,
                                        <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Determine if any of the propchanges are the "magic" ones that
             might require changing the working file. */</comment>
          <expr_stmt><expr><name>reinstall_working</name> = <call><name>svn_wc__has_magic_property</name><argument_list>(<argument><expr><name>propchanges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        }</block></then></if>
    }</block></then></if>

  <comment type="block">/* Reinstall props if we need to.  Only rewrite the baseprops,
     if we're reverting a replacement.  This is just an optimization. */</comment>
  <if>if <condition>(<expr><name>baseprops</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__install_props</name><argument_list>(<argument><expr>&amp;<name>log_accum</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>fullpath</name></expr></argument>, 
                                    <argument><expr><name>baseprops</name></expr></argument>, <argument><expr><name>baseprops</name></expr></argument>, <argument><expr><name>revert_base</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>reverted</name> = <name>TRUE</name></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* Deal with the contents. */</comment>

  <if>if <condition>(<expr><name><name>entry</name>-&gt;<name>kind</name></name> == <name>svn_node_file</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>base_kind</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>base_thing</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>tgt_modified</name></decl>;</decl_stmt>

      <comment type="block">/* If the working file is missing, we need to reinstall it. */</comment>
      <if>if <condition>(<expr>! <name>reinstall_working</name></expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_check_path</name><argument_list>(<argument><expr><name>fullpath</name></expr></argument>, <argument><expr>&amp;<name>kind</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>kind</name> == <name>svn_node_none</name></expr>)</condition><then>
            <expr_stmt><expr><name>reinstall_working</name> = <name>TRUE</name></expr>;</expr_stmt></then></if>
        }</block></then></if>

      <expr_stmt><expr><name>base_thing</name> = <call><name>svn_wc__text_base_path</name><argument_list>(<argument><expr><name>fullpath</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Check for text base presence. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_check_path</name><argument_list>(<argument><expr><name>base_thing</name></expr></argument>, <argument><expr>&amp;<name>base_kind</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr><name>base_kind</name> != <name>svn_node_file</name></expr>)</condition><then>
        <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>APR_ENOENT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                 <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Error restoring text for '%s'"</expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>fullpath</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

      <comment type="block">/* Look for a revert base file.  If it exists use it for the
         text base for the file.  If it doesn't use the normal text base. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_move</name>
              <argument_list>(<argument><expr>&amp;<name>log_accum</name></expr></argument>, <argument><expr>&amp;<name>tgt_modified</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
               <argument><expr><call><name>svn_wc__text_revert_path</name><argument_list>(<argument><expr><name>fullpath</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>base_thing</name></expr></argument>,
               <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>reinstall_working</name> = <name>reinstall_working</name> || <name>tgt_modified</name></expr>;</expr_stmt>

      <comment type="block">/* A shortcut: since we will translate when reinstall_working,
         we don't need to check if the working file is modified. */</comment>
      <if>if <condition>(<expr>! <name>reinstall_working</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__text_modified_internal_p</name><argument_list>(<argument><expr>&amp;<name>reinstall_working</name></expr></argument>,
                                                 <argument><expr><name>fullpath</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                                                 <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

      <if>if <condition>(<expr><name>reinstall_working</name></expr>)</condition><then>
        <block>{
          <comment type="block">/* If there are textual mods (or if the working file is
             missing altogether), copy the text-base out into
             the working copy, and update the timestamp in the entries
             file. */</comment>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_copy</name><argument_list>(<argument><expr>&amp;<name>log_accum</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                                     <argument><expr><name>svn_wc__copy_translate</name></expr></argument>,
                                     <argument><expr><name>base_thing</name></expr></argument>, <argument><expr><name>fullpath</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Possibly set the timestamp to last-commit-time, rather
             than the 'now' time that already exists. */</comment>
          <if>if <condition>(<expr><name>use_commit_times</name> &amp;&amp; <name><name>entry</name>-&gt;<name>cmt_date</name></name></expr>)</condition><then>
            <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_set_timestamp</name>
                    <argument_list>(<argument><expr>&amp;<name>log_accum</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>fullpath</name></expr></argument>,
                     <argument><expr><call><name>svn_time_to_cstring</name><argument_list>(<argument><expr><name><name>entry</name>-&gt;<name>cmt_date</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                     <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_set_entry_timestamp_from_wc</name>
                  <argument_list>(<argument><expr>&amp;<name>log_accum</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                   <argument><expr><name>fullpath</name></expr></argument>, <argument><expr><name>SVN_WC__ENTRY_ATTR_TEXT_TIME</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_set_entry_working_size_from_wc</name>
                  <argument_list>(<argument><expr>&amp;<name>log_accum</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>fullpath</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <expr_stmt><expr>*<name>reverted</name> = <name>TRUE</name></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>

  <comment type="block">/* Remove conflict state (and conflict files), if any.
     Handle the three possible text conflict files. */</comment>
  <if>if <condition>(<expr><name><name>entry</name>-&gt;<name>conflict_old</name></name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>flags</name> |= <name>SVN_WC__ENTRY_MODIFY_CONFLICT_OLD</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>tmp_entry</name>.<name>conflict_old</name></name> = <name>NULL</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_remove</name>
              <argument_list>(<argument><expr>&amp;<name>log_accum</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
               <argument><expr><call><name>svn_path_join</name><argument_list>(<argument><expr><call><name>svn_wc_adm_access_path</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><name><name>entry</name>-&gt;<name>conflict_old</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  <if>if <condition>(<expr><name><name>entry</name>-&gt;<name>conflict_new</name></name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>flags</name> |= <name>SVN_WC__ENTRY_MODIFY_CONFLICT_NEW</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>tmp_entry</name>.<name>conflict_new</name></name> = <name>NULL</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_remove</name>
              <argument_list>(<argument><expr>&amp;<name>log_accum</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
               <argument><expr><call><name>svn_path_join</name><argument_list>(<argument><expr><call><name>svn_wc_adm_access_path</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><name><name>entry</name>-&gt;<name>conflict_new</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  <if>if <condition>(<expr><name><name>entry</name>-&gt;<name>conflict_wrk</name></name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>flags</name> |= <name>SVN_WC__ENTRY_MODIFY_CONFLICT_WRK</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>tmp_entry</name>.<name>conflict_wrk</name></name> = <name>NULL</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_remove</name>
              <argument_list>(<argument><expr>&amp;<name>log_accum</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
               <argument><expr><call><name>svn_path_join</name><argument_list>(<argument><expr><call><name>svn_wc_adm_access_path</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><name><name>entry</name>-&gt;<name>conflict_wrk</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* Remove the property conflict file if the entry lists one (and it
     exists) */</comment>
  <if>if <condition>(<expr><name><name>entry</name>-&gt;<name>prejfile</name></name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>flags</name> |= <name>SVN_WC__ENTRY_MODIFY_PREJFILE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>tmp_entry</name>.<name>prejfile</name></name> = <name>NULL</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_remove</name>
              <argument_list>(<argument><expr>&amp;<name>log_accum</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
               <argument><expr><call><name>svn_path_join</name><argument_list>(<argument><expr><call><name>svn_wc_adm_access_path</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><name><name>entry</name>-&gt;<name>prejfile</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* Clean up the copied state if this is a replacement. */</comment>
  <if>if <condition>(<expr><name><name>entry</name>-&gt;<name>schedule</name></name> == <name>svn_wc_schedule_replace</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>flags</name> |= <name>SVN_WC__ENTRY_MODIFY_COPIED</name> |
          <name>SVN_WC__ENTRY_MODIFY_COPYFROM_URL</name> |
          <name>SVN_WC__ENTRY_MODIFY_COPYFROM_REV</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>tmp_entry</name>.<name>copied</name></name> = <name>FALSE</name></expr>;</expr_stmt>

      <comment type="block">/* Reset the checksum if this is a replace-with-history. */</comment>
      <if>if <condition>(<expr><name><name>entry</name>-&gt;<name>kind</name></name> == <name>svn_node_file</name> &amp;&amp; <name><name>entry</name>-&gt;<name>copyfrom_url</name></name></expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>base_path</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>digest</name><index>[<expr><name>APR_MD5_DIGESTSIZE</name></expr>]</index></name></decl>;</decl_stmt>

          <expr_stmt><expr><name>base_path</name> = <call><name>svn_wc__text_revert_path</name><argument_list>(<argument><expr><name>fullpath</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_checksum</name><argument_list>(<argument><expr><name>digest</name></expr></argument>, <argument><expr><name>base_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>tmp_entry</name>.<name>checksum</name></name> = <call><name>svn_md5_digest_to_cstring</name><argument_list>(<argument><expr><name>digest</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>flags</name> |= <name>SVN_WC__ENTRY_MODIFY_CHECKSUM</name></expr>;</expr_stmt>
        }</block></then></if>

      <comment type="block">/* Set this to the empty string, because NULL values will disappear
         in the XML log file. */</comment>
      <expr_stmt><expr><name><name>tmp_entry</name>.<name>copyfrom_url</name></name> = ""</expr>;</expr_stmt>
      <expr_stmt><expr><name><name>tmp_entry</name>.<name>copyfrom_rev</name></name> = <name>SVN_INVALID_REVNUM</name></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* Reset schedule attribute to svn_wc_schedule_normal. */</comment>
  <if>if <condition>(<expr><name><name>entry</name>-&gt;<name>schedule</name></name> != <name>svn_wc_schedule_normal</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>flags</name> |= <name>SVN_WC__ENTRY_MODIFY_SCHEDULE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>tmp_entry</name>.<name>schedule</name></name> = <name>svn_wc_schedule_normal</name></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>reverted</name> = <name>TRUE</name></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* Modify the entry, loggily. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_entry_modify</name><argument_list>(<argument><expr>&amp;<name>log_accum</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>fullpath</name></expr></argument>,
                                     <argument><expr>&amp;<name>tmp_entry</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Don't run log if nothing to change. */</comment>
  <if>if <condition>(<expr>! <call><name>svn_stringbuf_isempty</name><argument_list>(<argument><expr><name>log_accum</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__write_log</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>log_accum</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__run_log</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Revert PATH of on-disk KIND.  ENTRY is the working copy entry for
   PATH.  *DEPTH is the depth of the reversion crawl the caller is
   using; this function may choose to override that value as needed.

   See svn_wc_revert3() for the interpretations of PARENT_ACCESS,
   USE_COMMIT_TIMES, CANCEL_FUNC, CANCEL_BATON, NOTIFY_FUNC, and
   NOTIFY_BATON.

   Use POOL for allocations.
 */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>revert_entry</name><parameter_list>(<param><decl><type><name>svn_depth_t</name> *</type><name>depth</name></decl></param>,
             <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
             <param><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl></param>,
             <param><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>entry</name></decl></param>,
             <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>parent_access</name></decl></param>,
             <param><decl><type><name>svn_boolean_t</name></type> <name>use_commit_times</name></decl></param>,
             <param><decl><type><name>svn_cancel_func_t</name></type> <name>cancel_func</name></decl></param>,
             <param><decl><type><name>void</name> *</type><name>cancel_baton</name></decl></param>,
             <param><decl><type><name>svn_wc_notify_func2_t</name></type> <name>notify_func</name></decl></param>,
             <param><decl><type><name>void</name> *</type><name>notify_baton</name></decl></param>,
             <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>bname</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>reverted</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>is_wc_root</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_wc_adm_access_t</name> *</type><name>dir_access</name></decl>;</decl_stmt>

  <comment type="block">/* Fetch the access baton for this path. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_adm_probe_retrieve</name><argument_list>(<argument><expr>&amp;<name>dir_access</name></expr></argument>, <argument><expr><name>parent_access</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* For directories, determine if PATH is a WC root so that we can
     tell if it is safe to split PATH into a parent directory and
     basename.  For files, we always do this split.  */</comment>
  <if>if <condition>(<expr><name>kind</name> == <name>svn_node_dir</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_is_wc_root</name><argument_list>(<argument><expr>&amp;<name>is_wc_root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>dir_access</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <expr_stmt><expr><name>bname</name> = <name>is_wc_root</name> ? <name>NULL</name> : <call><name>svn_path_basename</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* Additions. */</comment>
  <if>if <condition>(<expr><name><name>entry</name>-&gt;<name>schedule</name></name> == <name>svn_wc_schedule_add</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* Before removing item from revision control, notice if the
         entry is in a 'deleted' state; this is critical for
         directories, where this state only exists in its parent's
         entry. */</comment>
      <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>was_deleted</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>parent</name></decl>, *<decl><type ref="prev"/><name>basey</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>svn_path_split</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>&amp;<name>parent</name></expr></argument>, <argument><expr>&amp;<name>basey</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name><name>entry</name>-&gt;<name>kind</name></name> == <name>svn_node_file</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>was_deleted</name> = <name><name>entry</name>-&gt;<name>deleted</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_remove_from_revision_control</name><argument_list>(<argument><expr><name>parent_access</name></expr></argument>, <argument><expr><name>bname</name></expr></argument>,
                                                      <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                                                      <argument><expr><name>cancel_func</name></expr></argument>,
                                                      <argument><expr><name>cancel_baton</name></expr></argument>,
                                                      <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
      <else>else <if>if <condition>(<expr><name><name>entry</name>-&gt;<name>kind</name></name> == <name>svn_node_dir</name></expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>entries</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>parents_entry</name></decl>;</decl_stmt>

          <comment type="block">/* We are trying to revert the current directory which is
             scheduled for addition. This is supposed to fail (Issue #854) */</comment>
          <if>if <condition>(<expr><name><name>path</name><index>[<expr>0</expr>]</index></name> == '\0'</expr>)</condition><then>
            <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_WC_INVALID_OP_ON_CWD</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                    <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Cannot revert addition of current "
                                      "directory; please try again from the "
                                      "parent directory"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_entries_read</name><argument_list>(<argument><expr>&amp;<name>entries</name></expr></argument>, <argument><expr><name>parent_access</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>parents_entry</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>entries</name></expr></argument>, <argument><expr><name>basey</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>parents_entry</name></expr>)</condition><then>
            <expr_stmt><expr><name>was_deleted</name> = <name><name>parents_entry</name>-&gt;<name>deleted</name></name></expr>;</expr_stmt></then></if>

          <if>if <condition>(<expr><name>kind</name> == <name>svn_node_none</name>
              || <call><name>svn_wc__adm_missing</name><argument_list>(<argument><expr><name>parent_access</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <block>{
              <comment type="block">/* Schedule add but missing, just remove the entry
                 or it's missing an adm area in which case
                 svn_wc_adm_probe_retrieve() returned the parent's
                 adm_access, for which we definitely can't use the 'else'
                 code path (as it will remove the parent from version
                 control... (See issue 2425) */</comment>
              <expr_stmt><expr><call><name>svn_wc__entry_remove</name><argument_list>(<argument><expr><name>entries</name></expr></argument>, <argument><expr><name>basey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__entries_write</name><argument_list>(<argument><expr><name>entries</name></expr></argument>, <argument><expr><name>parent_access</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
          <else>else
            <block>{
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_remove_from_revision_control</name>
                      <argument_list>(<argument><expr><name>dir_access</name></expr></argument>, <argument><expr><name>SVN_WC_ENTRY_THIS_DIR</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                       <argument><expr><name>cancel_func</name></expr></argument>, <argument><expr><name>cancel_baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></then>
      <else>else  <comment type="block">/* Else it's `none', or something exotic like a symlink... */</comment>
        <block>{
          <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_NODE_UNKNOWN_KIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                   <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Unknown or unexpected kind for path "
                                     "'%s'"</expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>

        }</block></else></if></else></if>

      <comment type="block">/* Recursivity is taken care of by svn_wc_remove_from_revision_control,
         and we've definitely reverted PATH at this point. */</comment>
      <expr_stmt><expr>*<name>depth</name> = <name>svn_depth_empty</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>reverted</name> = <name>TRUE</name></expr>;</expr_stmt>

      <comment type="block">/* If the removed item was *also* in a 'deleted' state, make
         sure we leave just a plain old 'deleted' entry behind in the
         parent. */</comment>
      <if>if <condition>(<expr><name>was_deleted</name></expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><name>svn_wc_entry_t</name> *</type><name>tmpentry</name></decl>;</decl_stmt> <comment type="block">/* ### FIXME: Why the heap alloc? */</comment>
          <expr_stmt><expr><name>tmpentry</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>tmpentry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>tmpentry</name>-&gt;<name>kind</name></name> = <name><name>entry</name>-&gt;<name>kind</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>tmpentry</name>-&gt;<name>deleted</name></name> = <name>TRUE</name></expr>;</expr_stmt>

          <if>if <condition>(<expr><name><name>entry</name>-&gt;<name>kind</name></name> == <name>svn_node_dir</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__entry_modify</name><argument_list>(<argument><expr><name>parent_access</name></expr></argument>, <argument><expr><name>basey</name></expr></argument>, <argument><expr><name>tmpentry</name></expr></argument>,
                                         <argument><expr><name>SVN_WC__ENTRY_MODIFY_KIND</name>
                                         | <name>SVN_WC__ENTRY_MODIFY_DELETED</name></expr></argument>,
                                         <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
          <else>else
            <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__entry_modify</name><argument_list>(<argument><expr><name>parent_access</name></expr></argument>, <argument><expr><name>bname</name></expr></argument>, <argument><expr><name>tmpentry</name></expr></argument>,
                                         <argument><expr><name>SVN_WC__ENTRY_MODIFY_KIND</name>
                                         | <name>SVN_WC__ENTRY_MODIFY_DELETED</name></expr></argument>,
                                         <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
        }</block></then></if>
    }</block></then>
  <comment type="block">/* Regular prop and text edit. */</comment>
  <comment type="block">/* Deletions and replacements. */</comment>
  <else>else <if>if <condition>(<expr><name><name>entry</name>-&gt;<name>schedule</name></name> == <name>svn_wc_schedule_normal</name>
           || <name><name>entry</name>-&gt;<name>schedule</name></name> == <name>svn_wc_schedule_delete</name>
           || <name><name>entry</name>-&gt;<name>schedule</name></name> == <name>svn_wc_schedule_replace</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* Revert the prop and text mods (if any). */</comment>
      <switch>switch <condition>(<expr><name><name>entry</name>-&gt;<name>kind</name></name></expr>)</condition>
        <block>{
        <case>case <expr><name>svn_node_file</name></expr>:
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>revert_admin_things</name><argument_list>(<argument><expr><name>parent_access</name></expr></argument>, <argument><expr><name>bname</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>,
                                      <argument><expr>&amp;<name>reverted</name></expr></argument>, <argument><expr><name>use_commit_times</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>

        </case><case>case <expr><name>svn_node_dir</name></expr>:
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>revert_admin_things</name><argument_list>(<argument><expr><name>dir_access</name></expr></argument>, <argument><expr><name>SVN_WC_ENTRY_THIS_DIR</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>,
                                      <argument><expr>&amp;<name>reverted</name></expr></argument>, <argument><expr><name>use_commit_times</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Also revert the entry in the parent (issue #2804). */</comment>
          <if>if <condition>(<expr><name>reverted</name> &amp;&amp; <name>bname</name></expr>)</condition><then>
            <block>{
              <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>dummy_reverted</name></decl>;</decl_stmt>
              <decl_stmt><decl><type><name>svn_wc_entry_t</name> *</type><name>entry_in_parent</name></decl>;</decl_stmt>
              <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>entries</name></decl>;</decl_stmt>

              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_entries_read</name><argument_list>(<argument><expr>&amp;<name>entries</name></expr></argument>, <argument><expr><name>parent_access</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>,
                                          <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>entry_in_parent</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>entries</name></expr></argument>, <argument><expr><name>bname</name></expr></argument>,
                                             <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>revert_admin_things</name><argument_list>(<argument><expr><name>parent_access</name></expr></argument>, <argument><expr><name>bname</name></expr></argument>,
                                          <argument><expr><name>entry_in_parent</name></expr></argument>, <argument><expr>&amp;<name>dummy_reverted</name></expr></argument>,
                                          <argument><expr><name>use_commit_times</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>

          <comment type="block">/* Force recursion on replaced directories. */</comment>
          <if>if <condition>(<expr><name><name>entry</name>-&gt;<name>schedule</name></name> == <name>svn_wc_schedule_replace</name></expr>)</condition><then>
            <expr_stmt><expr>*<name>depth</name> = <name>svn_depth_infinity</name></expr>;</expr_stmt></then></if>
          <break>break;</break>

        </case><default>default:
          <comment type="block">/* No op? */</comment>
          <break>break;</break>
        </default>}</block></switch>
    }</block></then></if></else></if>

  <comment type="block">/* If PATH was reverted, tell our client that. */</comment>
  <if>if <condition>(<expr>(<name>notify_func</name> != <name>NULL</name>) &amp;&amp; <name>reverted</name></expr>)</condition><then>
    <expr_stmt><expr><call>(*<name>notify_func</name>)<argument_list>(<argument><expr><name>notify_baton</name></expr></argument>,
                   <argument><expr><call><name>svn_wc_create_notify</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>svn_wc_notify_revert</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                   <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* This is just the guts of svn_wc_revert3() save that it accepts a
   hash CHANGELIST_HASH whose keys are changelist names instead of an
   array of said names.  See svn_wc_revert3() for additional
   documentation. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>revert_internal</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>parent_access</name></decl></param>,
                <param><decl><type><name>svn_depth_t</name></type> <name>depth</name></decl></param>,
                <param><decl><type><name>svn_boolean_t</name></type> <name>use_commit_times</name></decl></param>,
                <param><decl><type><name>apr_hash_t</name> *</type><name>changelist_hash</name></decl></param>,
                <param><decl><type><name>svn_cancel_func_t</name></type> <name>cancel_func</name></decl></param>,
                <param><decl><type><name>void</name> *</type><name>cancel_baton</name></decl></param>,
                <param><decl><type><name>svn_wc_notify_func2_t</name></type> <name>notify_func</name></decl></param>,
                <param><decl><type><name>void</name> *</type><name>notify_baton</name></decl></param>,
                <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>entry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_wc_adm_access_t</name> *</type><name>dir_access</name></decl>;</decl_stmt>

  <comment type="block">/* Check cancellation here, so recursive calls get checked early. */</comment>
  <if>if <condition>(<expr><name>cancel_func</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>cancel_func</name><argument_list>(<argument><expr><name>cancel_baton</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* Fetch the access baton for this path. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_adm_probe_retrieve</name><argument_list>(<argument><expr>&amp;<name>dir_access</name></expr></argument>, <argument><expr><name>parent_access</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Safeguard 1:  is this a versioned resource? */</comment>
  <expr_stmt><expr><call><name>SVN_ERR_W</name><argument_list>(<argument><expr><call><name>svn_wc__entry_versioned</name><argument_list>(<argument><expr>&amp;<name>entry</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>dir_access</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Cannot revert"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Safeguard 1.5:  is this a missing versioned directory? */</comment>
  <if>if <condition>(<expr><name><name>entry</name>-&gt;<name>kind</name></name> == <name>svn_node_dir</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>disk_kind</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_check_path</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>&amp;<name>disk_kind</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr>(<name>disk_kind</name> != <name>svn_node_dir</name>)
          &amp;&amp; (<name><name>entry</name>-&gt;<name>schedule</name></name> != <name>svn_wc_schedule_add</name>)</expr>)</condition><then>
        <block>{
          <comment type="block">/* When the directory itself is missing, we can't revert without
             hitting the network.  Someday a '--force' option will
             make this happen.  For now, send notification of the failure. */</comment>
          <if>if <condition>(<expr><name>notify_func</name> != <name>NULL</name></expr>)</condition><then>
            <block>{
              <decl_stmt><decl><type><name>svn_wc_notify_t</name> *</type><name>notify</name> <init>= 
                <expr><call><name>svn_wc_create_notify</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>svn_wc_notify_failed_revert</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
              <expr_stmt><expr><call><name>notify_func</name><argument_list>(<argument><expr><name>notify_baton</name></expr></argument>, <argument><expr><name>notify</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
          <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
        }</block></then></if>
    }</block></then></if>

  <comment type="block">/* Safeguard 2:  can we handle this entry's recorded kind? */</comment>
  <if>if <condition>(<expr>(<name><name>entry</name>-&gt;<name>kind</name></name> != <name>svn_node_file</name>) &amp;&amp; (<name><name>entry</name>-&gt;<name>kind</name></name> != <name>svn_node_dir</name>)</expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name>
      <argument_list>(<argument><expr><name>SVN_ERR_UNSUPPORTED_FEATURE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Cannot revert '%s': unsupported entry node kind"</expr></argument>)</argument_list></call></expr></argument>,
       <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Safeguard 3:  can we deal with the node kind of PATH currently in
     the working copy? */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_check_path</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>&amp;<name>kind</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>(<name>kind</name> != <name>svn_node_none</name>)
      &amp;&amp; (<name>kind</name> != <name>svn_node_file</name>)
      &amp;&amp; (<name>kind</name> != <name>svn_node_dir</name>)</expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name>
      <argument_list>(<argument><expr><name>SVN_ERR_UNSUPPORTED_FEATURE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Cannot revert '%s': unsupported node kind in working copy"</expr></argument>)</argument_list></call></expr></argument>,
       <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* If the entry passes changelist filtering, revert it!  */</comment>
  <if>if <condition>(<expr><call><name>SVN_WC__CL_MATCH</name><argument_list>(<argument><expr><name>changelist_hash</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <comment type="block">/* Actually revert this entry.  If this is a working copy root,
         we provide a base_name from the parent path. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>revert_entry</name><argument_list>(<argument><expr>&amp;<name>depth</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>kind</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>,
                           <argument><expr><name>parent_access</name></expr></argument>, <argument><expr><name>use_commit_times</name></expr></argument>, <argument><expr><name>cancel_func</name></expr></argument>,
                           <argument><expr><name>cancel_baton</name></expr></argument>, <argument><expr><name>notify_func</name></expr></argument>, <argument><expr><name>notify_baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* Finally, recurse if requested. */</comment>
  <if>if <condition>(<expr><name><name>entry</name>-&gt;<name>kind</name></name> == <name>svn_node_dir</name> &amp;&amp; <name>depth</name> &gt; <name>svn_depth_empty</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>entries</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_entries_read</name><argument_list>(<argument><expr>&amp;<name>entries</name></expr></argument>, <argument><expr><name>dir_access</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>entries</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>hi</name></expr>;</condition> <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
        <block>{
          <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>keystring</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>full_entry_path</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>svn_depth_t</name></type> <name>depth_under_here</name> <init>= <expr><name>depth</name></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>svn_wc_entry_t</name> *</type><name>child_entry</name></decl>;</decl_stmt>

          <if>if <condition>(<expr><name>depth</name> == <name>svn_depth_files</name> || <name>depth</name> == <name>svn_depth_immediates</name></expr>)</condition><then>
            <expr_stmt><expr><name>depth_under_here</name> = <name>svn_depth_empty</name></expr>;</expr_stmt></then></if>

          <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Get the next entry */</comment>
          <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>keystring</name> = <name>key</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>child_entry</name> = <name>val</name></expr>;</expr_stmt>

          <comment type="block">/* Skip "this dir" */</comment>
          <if>if <condition>(<expr>! <call><name>strcmp</name><argument_list>(<argument><expr><name>keystring</name></expr></argument>, <argument><expr><name>SVN_WC_ENTRY_THIS_DIR</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <continue>continue;</continue></then></if>

          <comment type="block">/* Skip subdirectories if we're called with depth-files. */</comment>
          <if>if <condition>(<expr>(<name>depth</name> == <name>svn_depth_files</name>) 
              &amp;&amp; (<name><name>child_entry</name>-&gt;<name>kind</name></name> != <name>svn_node_file</name>)</expr>)</condition><then>
            <continue>continue;</continue></then></if>

          <comment type="block">/* Add the entry name to FULL_ENTRY_PATH. */</comment>
          <expr_stmt><expr><name>full_entry_path</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>keystring</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Revert the entry. */</comment>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>revert_internal</name><argument_list>(<argument><expr><name>full_entry_path</name></expr></argument>, <argument><expr><name>dir_access</name></expr></argument>, 
                                  <argument><expr><name>depth_under_here</name></expr></argument>, <argument><expr><name>use_commit_times</name></expr></argument>, 
                                  <argument><expr><name>changelist_hash</name></expr></argument>, <argument><expr><name>cancel_func</name></expr></argument>, <argument><expr><name>cancel_baton</name></expr></argument>,
                                  <argument><expr><name>notify_func</name></expr></argument>, <argument><expr><name>notify_baton</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>

      <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_wc_revert3</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
               <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>parent_access</name></decl></param>,
               <param><decl><type><name>svn_depth_t</name></type> <name>depth</name></decl></param>,
               <param><decl><type><name>svn_boolean_t</name></type> <name>use_commit_times</name></decl></param>,
               <param><decl><type><specifier>const</specifier> <name>apr_array_header_t</name> *</type><name>changelists</name></decl></param>,
               <param><decl><type><name>svn_cancel_func_t</name></type> <name>cancel_func</name></decl></param>,
               <param><decl><type><name>void</name> *</type><name>cancel_baton</name></decl></param>,
               <param><decl><type><name>svn_wc_notify_func2_t</name></type> <name>notify_func</name></decl></param>,
               <param><decl><type><name>void</name> *</type><name>notify_baton</name></decl></param>,
               <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>changelist_hash</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>changelists</name> &amp;&amp; <name><name>changelists</name>-&gt;<name>nelts</name></name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_hash_from_cstring_keys</name><argument_list>(<argument><expr>&amp;<name>changelist_hash</name></expr></argument>, <argument><expr><name>changelists</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <return>return <expr><call><name>revert_internal</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>parent_access</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>use_commit_times</name></expr></argument>,
                         <argument><expr><name>changelist_hash</name></expr></argument>, <argument><expr><name>cancel_func</name></expr></argument>, <argument><expr><name>cancel_baton</name></expr></argument>,
                         <argument><expr><name>notify_func</name></expr></argument>, <argument><expr><name>notify_baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_wc_revert2</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
               <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>parent_access</name></decl></param>,
               <param><decl><type><name>svn_boolean_t</name></type> <name>recursive</name></decl></param>,
               <param><decl><type><name>svn_boolean_t</name></type> <name>use_commit_times</name></decl></param>,
               <param><decl><type><name>svn_cancel_func_t</name></type> <name>cancel_func</name></decl></param>,
               <param><decl><type><name>void</name> *</type><name>cancel_baton</name></decl></param>,
               <param><decl><type><name>svn_wc_notify_func2_t</name></type> <name>notify_func</name></decl></param>,
               <param><decl><type><name>void</name> *</type><name>notify_baton</name></decl></param>,
               <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>svn_wc_revert3</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>parent_access</name></expr></argument>, 
                        <argument><expr><name>recursive</name> ? <name>svn_depth_infinity</name> : <name>svn_depth_empty</name></expr></argument>,
                        <argument><expr><name>use_commit_times</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>cancel_func</name></expr></argument>, <argument><expr><name>cancel_baton</name></expr></argument>,
                        <argument><expr><name>notify_func</name></expr></argument>, <argument><expr><name>notify_baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_wc_revert</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
              <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>parent_access</name></decl></param>,
              <param><decl><type><name>svn_boolean_t</name></type> <name>recursive</name></decl></param>,
              <param><decl><type><name>svn_boolean_t</name></type> <name>use_commit_times</name></decl></param>,
              <param><decl><type><name>svn_cancel_func_t</name></type> <name>cancel_func</name></decl></param>,
              <param><decl><type><name>void</name> *</type><name>cancel_baton</name></decl></param>,
              <param><decl><type><name>svn_wc_notify_func_t</name></type> <name>notify_func</name></decl></param>,
              <param><decl><type><name>void</name> *</type><name>notify_baton</name></decl></param>,
              <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_wc__compat_notify_baton_t</name></type> <name>nb</name></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>nb</name>.<name>func</name></name> = <name>notify_func</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>nb</name>.<name>baton</name></name> = <name>notify_baton</name></expr>;</expr_stmt>

  <return>return <expr><call><name>svn_wc_revert2</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>parent_access</name></expr></argument>, <argument><expr><name>recursive</name></expr></argument>, <argument><expr><name>use_commit_times</name></expr></argument>,
                        <argument><expr><name>cancel_func</name></expr></argument>, <argument><expr><name>cancel_baton</name></expr></argument>,
                        <argument><expr><name>svn_wc__compat_call_notify_func</name></expr></argument>, <argument><expr>&amp;<name>nb</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_wc_get_pristine_copy_path</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                              <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>pristine_path</name></decl></param>,
                              <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr>*<name>pristine_path</name> = <call><name>svn_wc__text_base_path</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_wc_remove_from_revision_control</name><parameter_list>(<param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>,
                                    <param><decl><type><name>svn_boolean_t</name></type> <name>destroy_wf</name></decl></param>,
                                    <param><decl><type><name>svn_boolean_t</name></type> <name>instant_error</name></decl></param>,
                                    <param><decl><type><name>svn_cancel_func_t</name></type> <name>cancel_func</name></decl></param>,
                                    <param><decl><type><name>void</name> *</type><name>cancel_baton</name></decl></param>,
                                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>is_file</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>left_something</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>entries</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>full_path</name> <init>= <expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>,
                                      <argument><expr><call><name>svn_wc_adm_access_path</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Check cancellation here, so recursive calls get checked early. */</comment>
  <if>if <condition>(<expr><name>cancel_func</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>cancel_func</name><argument_list>(<argument><expr><name>cancel_baton</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* NAME is either a file's basename or SVN_WC_ENTRY_THIS_DIR. */</comment>
  <expr_stmt><expr><name>is_file</name> = (<call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>SVN_WC_ENTRY_THIS_DIR</name></expr></argument>)</argument_list></call>) ? <name>TRUE</name> : <name>FALSE</name></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>is_file</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>wc_special</name></decl>, <decl><type ref="prev"/><name>local_special</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>text_modified_p</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>full_path</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>full_path</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Only check if the file was modified when it wasn't overwritten with a
         special file */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__get_special</name><argument_list>(<argument><expr>&amp;<name>wc_special</name></expr></argument>, <argument><expr><name>full_path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_check_special_path</name><argument_list>(<argument><expr><name>full_path</name></expr></argument>, <argument><expr>&amp;<name>kind</name></expr></argument>, <argument><expr>&amp;<name>local_special</name></expr></argument>,
                                        <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>wc_special</name> || ! <name>local_special</name></expr>)</condition><then>
        <block>{
          <comment type="block">/* Check for local mods. before removing entry */</comment>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_text_modified_p</name><argument_list>(<argument><expr>&amp;<name>text_modified_p</name></expr></argument>, <argument><expr><name>full_path</name></expr></argument>,
                  <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>text_modified_p</name> &amp;&amp; <name>instant_error</name></expr>)</condition><then>
            <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_WC_LEFT_LOCAL_MOD</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                   <argument><expr><call><name>_</name><argument_list>(<argument><expr>"File '%s' has local modifications"</expr></argument>)</argument_list></call></expr></argument>,
                   <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>full_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
        }</block></then></if>

      <comment type="block">/* Remove the wcprops. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__props_delete</name><argument_list>(<argument><expr><name>full_path</name></expr></argument>, <argument><expr><name>svn_wc__props_wcprop</name></expr></argument>,
                                   <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* Remove prop/NAME, prop-base/NAME.svn-base. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__props_delete</name><argument_list>(<argument><expr><name>full_path</name></expr></argument>, <argument><expr><name>svn_wc__props_working</name></expr></argument>,
                                   <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__props_delete</name><argument_list>(<argument><expr><name>full_path</name></expr></argument>, <argument><expr><name>svn_wc__props_base</name></expr></argument>,
                                   <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Remove NAME from PATH's entries file: */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_entries_read</name><argument_list>(<argument><expr>&amp;<name>entries</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>svn_wc__entry_remove</name><argument_list>(<argument><expr><name>entries</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__entries_write</name><argument_list>(<argument><expr><name>entries</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Remove text-base/NAME.svn-base */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>remove_file_if_present</name><argument_list>(<argument><expr><call><name>svn_wc__text_base_path</name><argument_list>(<argument><expr><name>full_path</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                                     <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* If we were asked to destroy the working file, do so unless
         it has local mods. */</comment>
      <if>if <condition>(<expr><name>destroy_wf</name></expr>)</condition><then>
        <block>{
          <comment type="block">/* Don't kill local mods. */</comment>
          <if>if <condition>(<expr><name>text_modified_p</name> || (! <name>wc_special</name> &amp;&amp; <name>local_special</name>)</expr>)</condition><then>
            <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_WC_LEFT_LOCAL_MOD</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></then>
          <else>else  <comment type="block">/* The working file is still present; remove it. */</comment>
            <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>remove_file_if_present</name><argument_list>(<argument><expr><name>full_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
        }</block></then></if>

    }</block></then>  <comment type="block">/* done with file case */</comment>

  <else>else <comment type="block">/* looking at THIS_DIR */</comment>
    <block>{
      <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_wc_entry_t</name></type> <name>incomplete_entry</name></decl>;</decl_stmt>

      <comment type="block">/* ### sanity check:  check 2 places for DELETED flag? */</comment>

      <comment type="block">/* Before we start removing entries from this dir's entries
         file, mark this directory as "incomplete".  This allows this
         function to be interruptible and the wc recoverable by 'svn
         up' later on. */</comment>
      <expr_stmt><expr><name><name>incomplete_entry</name>.<name>incomplete</name></name> = <name>TRUE</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__entry_modify</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>,
                                   <argument><expr><name>SVN_WC_ENTRY_THIS_DIR</name></expr></argument>,
                                   <argument><expr>&amp;<name>incomplete_entry</name></expr></argument>,
                                   <argument><expr><name>SVN_WC__ENTRY_MODIFY_INCOMPLETE</name></expr></argument>,
                                   <argument><expr><name>TRUE</name></expr></argument>, <comment type="block">/* sync to disk immediately */</comment>
                                   <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Get rid of all the wcprops in this directory.  This avoids rewriting
         the wcprops file over and over (meaning O(n^2) complexity)
         below. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__props_delete</name><argument_list>(<argument><expr><name>full_path</name></expr></argument>, <argument><expr><name>svn_wc__props_wcprop</name></expr></argument>,
                                   <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Walk over every entry. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_entries_read</name><argument_list>(<argument><expr>&amp;<name>entries</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>entries</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>hi</name></expr>;</condition> <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
        <block>{
          <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>current_entry_name</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>current_entry</name></decl>;</decl_stmt>

          <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>current_entry</name> = <name>val</name></expr>;</expr_stmt>
          <if>if <condition>(<expr>! <call><name>strcmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>SVN_WC_ENTRY_THIS_DIR</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><name>current_entry_name</name> = <name>NULL</name></expr>;</expr_stmt></then>
          <else>else
            <expr_stmt><expr><name>current_entry_name</name> = <name>key</name></expr>;</expr_stmt></else></if>

          <if>if <condition>(<expr><name><name>current_entry</name>-&gt;<name>kind</name></name> == <name>svn_node_file</name></expr>)</condition><then>
            <block>{
              <expr_stmt><expr><name>err</name> = <call><name>svn_wc_remove_from_revision_control</name>
                <argument_list>(<argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>current_entry_name</name></expr></argument>, <argument><expr><name>destroy_wf</name></expr></argument>, <argument><expr><name>instant_error</name></expr></argument>,
                 <argument><expr><name>cancel_func</name></expr></argument>, <argument><expr><name>cancel_baton</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

              <if>if <condition>(<expr><name>err</name> &amp;&amp; (<name><name>err</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_WC_LEFT_LOCAL_MOD</name>)</expr>)</condition><then>
                <block>{
                  <if>if <condition>(<expr><name>instant_error</name></expr>)</condition><then>
                    <block>{
                      <return>return <expr><name>err</name></expr>;</return>
                    }</block></then>
                  <else>else
                    <block>{
                      <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                      <expr_stmt><expr><name>left_something</name> = <name>TRUE</name></expr>;</expr_stmt>
                    }</block></else></if>
                }</block></then>
              <else>else <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
                <return>return <expr><name>err</name></expr>;</return></then></if></else></if>
            }</block></then>
          <else>else <if>if <condition>(<expr><name>current_entry_name</name> &amp;&amp; (<name><name>current_entry</name>-&gt;<name>kind</name></name> == <name>svn_node_dir</name>)</expr>)</condition><then>
            <block>{
              <decl_stmt><decl><type><name>svn_wc_adm_access_t</name> *</type><name>entry_access</name></decl>;</decl_stmt>
              <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>entrypath</name>
                <init>= <expr><call><name>svn_path_join</name><argument_list>(<argument><expr><call><name>svn_wc_adm_access_path</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><name>current_entry_name</name></expr></argument>,
                                <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

              <if>if <condition>(<expr><call><name>svn_wc__adm_missing</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>entrypath</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <block>{
                  <comment type="block">/* The directory is already missing, so don't try to
                     recurse, just delete the entry in the parent
                     directory. */</comment>
                  <expr_stmt><expr><call><name>svn_wc__entry_remove</name><argument_list>(<argument><expr><name>entries</name></expr></argument>, <argument><expr><name>current_entry_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then>
              <else>else
                <block>{
                  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_adm_retrieve</name><argument_list>(<argument><expr>&amp;<name>entry_access</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                                              <argument><expr><name>entrypath</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                  <expr_stmt><expr><name>err</name> = <call><name>svn_wc_remove_from_revision_control</name>
                    <argument_list>(<argument><expr><name>entry_access</name></expr></argument>, <argument><expr><name>SVN_WC_ENTRY_THIS_DIR</name></expr></argument>, <argument><expr><name>destroy_wf</name></expr></argument>,
                     <argument><expr><name>instant_error</name></expr></argument>, <argument><expr><name>cancel_func</name></expr></argument>, <argument><expr><name>cancel_baton</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                  <if>if <condition>(<expr><name>err</name> &amp;&amp; (<name><name>err</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_WC_LEFT_LOCAL_MOD</name>)</expr>)</condition><then>
                    <block>{
                      <if>if <condition>(<expr><name>instant_error</name></expr>)</condition><then>
                        <block>{
                          <return>return <expr><name>err</name></expr>;</return>
                        }</block></then>
                      <else>else
                        <block>{
                          <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                          <expr_stmt><expr><name>left_something</name> = <name>TRUE</name></expr>;</expr_stmt>
                        }</block></else></if>
                    }</block></then>
                  <else>else <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
                    <return>return <expr><name>err</name></expr>;</return></then></if></else></if>
                }</block></else></if>
            }</block></then></if></else></if>
        }</block></for>

      <comment type="block">/* At this point, every directory below this one has been
         removed from revision control. */</comment>

      <comment type="block">/* Remove self from parent's entries file, but only if parent is
         a working copy.  If it's not, that's fine, we just move on. */</comment>
      <block>{
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>parent_dir</name></decl>, *<decl><type ref="prev"/><name>base_name</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>is_root</name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_is_wc_root</name><argument_list>(<argument><expr>&amp;<name>is_root</name></expr></argument>, <argument><expr><name>full_path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* If full_path is not the top of a wc, then its parent
           directory is also a working copy and has an entry for
           full_path.  We need to remove that entry: */</comment>
        <if>if <condition>(<expr>! <name>is_root</name></expr>)</condition><then>
          <block>{
            <decl_stmt><decl><type><name>svn_wc_adm_access_t</name> *</type><name>parent_access</name></decl>;</decl_stmt>

            <expr_stmt><expr><call><name>svn_path_split</name><argument_list>(<argument><expr><name>full_path</name></expr></argument>, <argument><expr>&amp;<name>parent_dir</name></expr></argument>, <argument><expr>&amp;<name>base_name</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

            <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_adm_retrieve</name><argument_list>(<argument><expr>&amp;<name>parent_access</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                                        <argument><expr><name>parent_dir</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_entries_read</name><argument_list>(<argument><expr>&amp;<name>entries</name></expr></argument>, <argument><expr><name>parent_access</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>,
                                        <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>svn_wc__entry_remove</name><argument_list>(<argument><expr><name>entries</name></expr></argument>, <argument><expr><name>base_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__entries_write</name><argument_list>(<argument><expr><name>entries</name></expr></argument>, <argument><expr><name>parent_access</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          }</block></then></if>
      }</block>

      <comment type="block">/* Remove the entire administrative .svn area, thereby removing
         _this_ dir from revision control too.  */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__adm_destroy</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* If caller wants us to recursively nuke everything on disk, go
         ahead, provided that there are no dangling local-mod files
         below */</comment>
      <if>if <condition>(<expr><name>destroy_wf</name> &amp;&amp; (! <name>left_something</name>)</expr>)</condition><then>
        <block>{
          <comment type="block">/* If the dir is *truly* empty (i.e. has no unversioned
             resources, all versioned files are gone, all .svn dirs are
             gone, and contains nothing but empty dirs), then a
             *non*-recursive dir_remove should work.  If it doesn't,
             no big deal.  Just assume there are unversioned items in
             there and set "left_something" */</comment>
          <expr_stmt><expr><name>err</name> = <call><name>svn_io_dir_remove_nonrecursive</name>
            <argument_list>(<argument><expr><call><name>svn_wc_adm_access_path</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
            <block>{
              <expr_stmt><expr><name>left_something</name> = <name>TRUE</name></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then></if>

      <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    }</block></else></if>  <comment type="block">/* end of directory case */</comment>

  <if>if <condition>(<expr><name>left_something</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_WC_LEFT_LOCAL_MOD</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></then>
  <else>else
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></else></if>
}</block></function>


<escape char="0xc"/>
<comment type="block">/*** Resolving a conflict automatically ***/</comment>


<comment type="block">/* Helper for resolve_conflict_on_entry.  Delete the file BASE_NAME in
   PARENT_DIR if it exists.  Set WAS_PRESENT to TRUE if the file existed,
   and to FALSE otherwise. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>attempt_deletion</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>parent_dir</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>base_name</name></decl></param>,
                 <param><decl><type><name>svn_boolean_t</name> *</type><name>was_present</name></decl></param>,
                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>full_path</name> <init>= <expr><call><name>svn_path_join</name><argument_list>(<argument><expr><name>parent_dir</name></expr></argument>, <argument><expr><name>base_name</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name> <init>= <expr><call><name>svn_io_remove_file</name><argument_list>(<argument><expr><name>full_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr>*<name>was_present</name> = ! <name>err</name> || ! <call><name>APR_STATUS_IS_ENOENT</name><argument_list>(<argument><expr><name><name>err</name>-&gt;<name>apr_err</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>*<name>was_present</name></expr>)</condition><then>
    <return>return <expr><name>err</name></expr>;</return></then></if>

  <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Conflict resolution involves removing the conflict files, if they exist,
   and clearing the conflict filenames from the entry.  The latter needs to
   be done whether or not the conflict files exist.  If @a conflict_choice
   is svn_wc_conflict_choose_base, resolve the conflict with the old
   file contents; if svn_wc_conflict_choose_mine, use the original
   working contents; if svn_wc_conflict_choose_theirs, the new
   contents; and if svn_wc_conflict_choose_merged, don't change the
   contents at all, just remove the conflict status (i.e. pre-1.5 behavior).

   @since 1.5 Automatic Conflict Resolution (Issue 2784)

   PATH is the path to the item to be resolved, BASE_NAME is the basename
   of PATH, and CONFLICT_DIR is the access baton for PATH.  ORIG_ENTRY is
   the entry prior to resolution. RESOLVE_TEXT and RESOLVE_PROPS are TRUE
   if text and property conficts respectively are to be resolved. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>resolve_conflict_on_entry</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>orig_entry</name></decl></param>,
                          <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>conflict_dir</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>base_name</name></decl></param>,
                          <param><decl><type><name>svn_boolean_t</name></type> <name>resolve_text</name></decl></param>,
                          <param><decl><type><name>svn_boolean_t</name></type> <name>resolve_props</name></decl></param>,
                          <param><decl><type><name>svn_wc_conflict_choice_t</name></type> <name>conflict_choice</name></decl></param>,
                          <param><decl><type><name>svn_wc_notify_func2_t</name></type> <name>notify_func</name></decl></param>,
                          <param><decl><type><name>void</name> *</type><name>notify_baton</name></decl></param>,
                          <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>was_present</name></decl>, <decl><type ref="prev"/><name>need_feedback</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_uint64_t</name></type> <name>modify_flags</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_wc_entry_t</name> *</type><name>entry</name> <init>= <expr><call><name>svn_wc_entry_dup</name><argument_list>(<argument><expr><name>orig_entry</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>auto_resolve_src</name></decl>;</decl_stmt>

  <comment type="block">/* Handle automatic conflict resolution before the temporary files are
   * deleted, if necessary. */</comment>
  <switch>switch <condition>(<expr><name>conflict_choice</name></expr>)</condition>
    <block>{
    <case>case <expr><name>svn_wc_conflict_choose_base</name></expr>:
      <expr_stmt><expr><name>auto_resolve_src</name> = <name><name>entry</name>-&gt;<name>conflict_old</name></name></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr><name>svn_wc_conflict_choose_mine_full</name></expr>:
      <expr_stmt><expr><name>auto_resolve_src</name> = <name><name>entry</name>-&gt;<name>conflict_wrk</name></name></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr><name>svn_wc_conflict_choose_theirs_full</name></expr>:
      <expr_stmt><expr><name>auto_resolve_src</name> = <name><name>entry</name>-&gt;<name>conflict_new</name></name></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr><name>svn_wc_conflict_choose_merged</name></expr>:
      <expr_stmt><expr><name>auto_resolve_src</name> = <name>NULL</name></expr>;</expr_stmt>
      <break>break;</break>
    </case><default>default:
      <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_INCORRECT_PARAMS</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                              <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Invalid 'conflict_result' argument"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    </default>}</block></switch>

    <if>if <condition>(<expr><name>auto_resolve_src</name></expr>)</condition><then>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_copy_file</name><argument_list>(
        <argument><expr><call><name>svn_path_join</name><argument_list>(<argument><expr><call><name>svn_wc_adm_access_path</name><argument_list>(<argument><expr><name>conflict_dir</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>auto_resolve_src</name></expr></argument>,
                      <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><name>path</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* Yes indeed, being able to map a function over a list would be nice. */</comment>
  <if>if <condition>(<expr><name>resolve_text</name> &amp;&amp; <name><name>entry</name>-&gt;<name>conflict_old</name></name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>attempt_deletion</name><argument_list>(<argument><expr><call><name>svn_wc_adm_access_path</name><argument_list>(<argument><expr><name>conflict_dir</name></expr></argument>)</argument_list></call></expr></argument>,
                               <argument><expr><name><name>entry</name>-&gt;<name>conflict_old</name></name></expr></argument>, <argument><expr>&amp;<name>was_present</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>modify_flags</name> |= <name>SVN_WC__ENTRY_MODIFY_CONFLICT_OLD</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>entry</name>-&gt;<name>conflict_old</name></name> = <name>NULL</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>need_feedback</name> |= <name>was_present</name></expr>;</expr_stmt>
    }</block></then></if>
  <if>if <condition>(<expr><name>resolve_text</name> &amp;&amp; <name><name>entry</name>-&gt;<name>conflict_new</name></name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>attempt_deletion</name><argument_list>(<argument><expr><call><name>svn_wc_adm_access_path</name><argument_list>(<argument><expr><name>conflict_dir</name></expr></argument>)</argument_list></call></expr></argument>,
                               <argument><expr><name><name>entry</name>-&gt;<name>conflict_new</name></name></expr></argument>, <argument><expr>&amp;<name>was_present</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>modify_flags</name> |= <name>SVN_WC__ENTRY_MODIFY_CONFLICT_NEW</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>entry</name>-&gt;<name>conflict_new</name></name> = <name>NULL</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>need_feedback</name> |= <name>was_present</name></expr>;</expr_stmt>
    }</block></then></if>
  <if>if <condition>(<expr><name>resolve_text</name> &amp;&amp; <name><name>entry</name>-&gt;<name>conflict_wrk</name></name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>attempt_deletion</name><argument_list>(<argument><expr><call><name>svn_wc_adm_access_path</name><argument_list>(<argument><expr><name>conflict_dir</name></expr></argument>)</argument_list></call></expr></argument>,
                               <argument><expr><name><name>entry</name>-&gt;<name>conflict_wrk</name></name></expr></argument>, <argument><expr>&amp;<name>was_present</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>modify_flags</name> |= <name>SVN_WC__ENTRY_MODIFY_CONFLICT_WRK</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>entry</name>-&gt;<name>conflict_wrk</name></name> = <name>NULL</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>need_feedback</name> |= <name>was_present</name></expr>;</expr_stmt>
    }</block></then></if>
  <if>if <condition>(<expr><name>resolve_props</name> &amp;&amp; <name><name>entry</name>-&gt;<name>prejfile</name></name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>attempt_deletion</name><argument_list>(<argument><expr><call><name>svn_wc_adm_access_path</name><argument_list>(<argument><expr><name>conflict_dir</name></expr></argument>)</argument_list></call></expr></argument>,
                               <argument><expr><name><name>entry</name>-&gt;<name>prejfile</name></name></expr></argument>, <argument><expr>&amp;<name>was_present</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>modify_flags</name> |= <name>SVN_WC__ENTRY_MODIFY_PREJFILE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>entry</name>-&gt;<name>prejfile</name></name> = <name>NULL</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>need_feedback</name> |= <name>was_present</name></expr>;</expr_stmt>
    }</block></then></if>

  <if>if <condition>(<expr><name>modify_flags</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* Although removing the files is sufficient to indicate that the
         conflict is resolved, if we update the entry as well future checks
         for conflict state will be more efficient. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__entry_modify</name>
              <argument_list>(<argument><expr><name>conflict_dir</name></expr></argument>,
               <argument><expr>(<name><name>entry</name>-&gt;<name>kind</name></name> == <name>svn_node_dir</name> ? <name>NULL</name> : <name>base_name</name>)</expr></argument>,
               <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>modify_flags</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* No feedback if no files were deleted and all we did was change the
         entry, such a file did not appear as a conflict */</comment>
      <if>if <condition>(<expr><name>need_feedback</name> &amp;&amp; <name>notify_func</name></expr>)</condition><then>
        <block>{
          <comment type="block">/* Sanity check:  see if libsvn_wc *still* thinks this item is in a
             state of conflict that we have asked to resolve.  If not, report
             the successful resolution.  */</comment>
          <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>text_conflict</name></decl>, <decl><type ref="prev"/><name>prop_conflict</name></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_conflicted_p</name><argument_list>(<argument><expr>&amp;<name>text_conflict</name></expr></argument>, <argument><expr>&amp;<name>prop_conflict</name></expr></argument>,
                                      <argument><expr><call><name>svn_wc_adm_access_path</name><argument_list>(<argument><expr><name>conflict_dir</name></expr></argument>)</argument_list></call></expr></argument>,
                                      <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr>(! (<name>resolve_text</name> &amp;&amp; <name>text_conflict</name>))
              &amp;&amp; (! (<name>resolve_props</name> &amp;&amp; <name>prop_conflict</name>))</expr>)</condition><then>
            <expr_stmt><expr><call>(*<name>notify_func</name>)<argument_list>(<argument><expr><name>notify_baton</name></expr></argument>,
                           <argument><expr><call><name>svn_wc_create_notify</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>svn_wc_notify_resolved</name></expr></argument>,
                                                <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        }</block></then></if>
    }</block></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Machinery for an automated entries walk... */</comment>

<struct>struct <name>resolve_callback_baton</name>
<block>{
  <comment type="block">/* TRUE if text conflicts are to be resolved. */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>resolve_text</name></decl>;</decl_stmt>
  <comment type="block">/* TRUE if property conflicts are to be resolved. */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>resolve_props</name></decl>;</decl_stmt>
  <comment type="block">/* The type of automatic conflict resolution to perform */</comment>
  <decl_stmt><decl><type><name>svn_wc_conflict_choice_t</name></type> <name>conflict_choice</name></decl>;</decl_stmt>
  <comment type="block">/* An access baton for the tree, with write access */</comment>
  <decl_stmt><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl>;</decl_stmt>
  <comment type="block">/* Notification function and baton */</comment>
  <decl_stmt><decl><type><name>svn_wc_notify_func2_t</name></type> <name>notify_func</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> *</type><name>notify_baton</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>resolve_found_entry_callback</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                             <param><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>entry</name></decl></param>,
                             <param><decl><type><name>void</name> *</type><name>walk_baton</name></decl></param>,
                             <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>resolve_callback_baton</name> *</type><name>baton</name> <init>= <expr><name>walk_baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>conflict_dir</name></decl>, *<decl><type ref="prev"/><name>base_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl>;</decl_stmt>

  <comment type="block">/* We're going to receive dirents twice;  we want to ignore the
     first one (where it's a child of a parent dir), and only print
     the second one (where we're looking at THIS_DIR). */</comment>
  <if>if <condition>(<expr>(<name><name>entry</name>-&gt;<name>kind</name></name> == <name>svn_node_dir</name>)
      &amp;&amp; (<call><name>strcmp</name><argument_list>(<argument><expr><name><name>entry</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>SVN_WC_ENTRY_THIS_DIR</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <comment type="block">/* Figger out the directory in which the conflict resides. */</comment>
  <if>if <condition>(<expr><name><name>entry</name>-&gt;<name>kind</name></name> == <name>svn_node_dir</name></expr>)</condition><then>
    <expr_stmt><expr><name>conflict_dir</name> = <name>path</name></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><call><name>svn_path_split</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>&amp;<name>conflict_dir</name></expr></argument>, <argument><expr>&amp;<name>base_name</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_adm_retrieve</name><argument_list>(<argument><expr>&amp;<name>adm_access</name></expr></argument>, <argument><expr><name><name>baton</name>-&gt;<name>adm_access</name></name></expr></argument>, <argument><expr><name>conflict_dir</name></expr></argument>,
                              <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><call><name>resolve_conflict_on_entry</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>base_name</name></expr></argument>,
                                   <argument><expr><name><name>baton</name>-&gt;<name>resolve_text</name></name></expr></argument>, <argument><expr><name><name>baton</name>-&gt;<name>resolve_props</name></name></expr></argument>,
                                   <argument><expr><name><name>baton</name>-&gt;<name>conflict_choice</name></name></expr></argument>, <argument><expr><name><name>baton</name>-&gt;<name>notify_func</name></name></expr></argument>,
                                   <argument><expr><name><name>baton</name>-&gt;<name>notify_baton</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>svn_wc_entry_callbacks2_t</name></type>
<name>resolve_walk_callbacks</name> <init>=
  <expr><block>{
    <expr><name>resolve_found_entry_callback</name></expr>,
    <expr><name>svn_wc__walker_default_error_handler</name></expr>
  }</block></expr></init></decl>;</decl_stmt>


<comment type="block">/* The public function */</comment>
<function><type><name>svn_error_t</name> *</type>
<name>svn_wc_resolved_conflict</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                         <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                         <param><decl><type><name>svn_boolean_t</name></type> <name>resolve_text</name></decl></param>,
                         <param><decl><type><name>svn_boolean_t</name></type> <name>resolve_props</name></decl></param>,
                         <param><decl><type><name>svn_boolean_t</name></type> <name>recurse</name></decl></param>,
                         <param><decl><type><name>svn_wc_notify_func_t</name></type> <name>notify_func</name></decl></param>,
                         <param><decl><type><name>void</name> *</type><name>notify_baton</name></decl></param>,
                         <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_wc__compat_notify_baton_t</name></type> <name>nb</name></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>nb</name>.<name>func</name></name> = <name>notify_func</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>nb</name>.<name>baton</name></name> = <name>notify_baton</name></expr>;</expr_stmt>

  <return>return <expr><call><name>svn_wc_resolved_conflict2</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                                   <argument><expr><name>resolve_text</name></expr></argument>, <argument><expr><name>resolve_props</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>,
                                   <argument><expr><name>svn_wc__compat_call_notify_func</name></expr></argument>, <argument><expr>&amp;<name>nb</name></expr></argument>,
                                   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>

}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_wc_resolved_conflict2</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                          <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                          <param><decl><type><name>svn_boolean_t</name></type> <name>resolve_text</name></decl></param>,
                          <param><decl><type><name>svn_boolean_t</name></type> <name>resolve_props</name></decl></param>,
                          <param><decl><type><name>svn_boolean_t</name></type> <name>recurse</name></decl></param>,
                          <param><decl><type><name>svn_wc_notify_func2_t</name></type> <name>notify_func</name></decl></param>,
                          <param><decl><type><name>void</name> *</type><name>notify_baton</name></decl></param>,
                          <param><decl><type><name>svn_cancel_func_t</name></type> <name>cancel_func</name></decl></param>,
                          <param><decl><type><name>void</name> *</type><name>cancel_baton</name></decl></param>,
                          <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>svn_wc_resolved_conflict3</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>resolve_text</name></expr></argument>,
                                   <argument><expr><name>resolve_props</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>,
                                   <argument><expr><name>svn_wc_conflict_choose_merged</name></expr></argument>,
                                   <argument><expr><name>notify_func</name></expr></argument>, <argument><expr><name>notify_baton</name></expr></argument>, <argument><expr><name>cancel_func</name></expr></argument>,
                                   <argument><expr><name>cancel_baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_wc_resolved_conflict3</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                          <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                          <param><decl><type><name>svn_boolean_t</name></type> <name>resolve_text</name></decl></param>,
                          <param><decl><type><name>svn_boolean_t</name></type> <name>resolve_props</name></decl></param>,
                          <param><decl><type><name>svn_depth_t</name></type> <name>depth</name></decl></param>,
                          <param><decl><type><name>svn_wc_conflict_choice_t</name></type> <name>conflict_choice</name></decl></param>,
                          <param><decl><type><name>svn_wc_notify_func2_t</name></type> <name>notify_func</name></decl></param>,
                          <param><decl><type><name>void</name> *</type><name>notify_baton</name></decl></param>,
                          <param><decl><type><name>svn_cancel_func_t</name></type> <name>cancel_func</name></decl></param>,
                          <param><decl><type><name>void</name> *</type><name>cancel_baton</name></decl></param>,
                          <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>resolve_callback_baton</name> *</type><name>baton</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>baton</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>baton</name>-&gt;<name>resolve_text</name></name> = <name>resolve_text</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>baton</name>-&gt;<name>resolve_props</name></name> = <name>resolve_props</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>baton</name>-&gt;<name>adm_access</name></name> = <name>adm_access</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>baton</name>-&gt;<name>notify_func</name></name> = <name>notify_func</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>baton</name>-&gt;<name>notify_baton</name></name> = <name>notify_baton</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>baton</name>-&gt;<name>conflict_choice</name></name> = <name>conflict_choice</name></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>depth</name> == <name>svn_depth_empty</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>entry</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__entry_versioned</name><argument_list>(<argument><expr>&amp;<name>entry</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>resolve_found_entry_callback</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_walk_entries3</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                                   <argument><expr>&amp;<name>resolve_walk_callbacks</name></expr></argument>, <argument><expr><name>baton</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>,
                                   <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>cancel_func</name></expr></argument>, <argument><expr><name>cancel_baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    }</block></else></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type><name>svn_wc_add_lock</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>svn_lock_t</name> *</type><name>lock</name></decl></param>,
                             <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>entry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_wc_entry_t</name></type> <name>newentry</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__entry_versioned</name><argument_list>(<argument><expr>&amp;<name>entry</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


  <expr_stmt><expr><name><name>newentry</name>.<name>lock_token</name></name> = <name><name>lock</name>-&gt;<name>token</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>newentry</name>.<name>lock_owner</name></name> = <name><name>lock</name>-&gt;<name>owner</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>newentry</name>.<name>lock_comment</name></name> = <name><name>lock</name>-&gt;<name>comment</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>newentry</name>.<name>lock_creation_date</name></name> = <name><name>lock</name>-&gt;<name>creation_date</name></name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__entry_modify</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name><name>entry</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr>&amp;<name>newentry</name></expr></argument>,
                               <argument><expr><name>SVN_WC__ENTRY_MODIFY_LOCK_TOKEN</name>
                               | <name>SVN_WC__ENTRY_MODIFY_LOCK_OWNER</name>
                               | <name>SVN_WC__ENTRY_MODIFY_LOCK_COMMENT</name>
                               | <name>SVN_WC__ENTRY_MODIFY_LOCK_CREATION_DATE</name></expr></argument>,
                               <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <block>{ <comment type="block">/* if svn:needs-lock is present, then make the file read-write. */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>needs_lock</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_prop_get</name><argument_list>(<argument><expr>&amp;<name>needs_lock</name></expr></argument>, <argument><expr><name>SVN_PROP_NEEDS_LOCK</name></expr></argument>,
                            <argument><expr><name>path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>needs_lock</name></expr>)</condition><then>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_set_file_read_write</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  }</block>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type><name>svn_wc_remove_lock</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                             <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>entry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_wc_entry_t</name></type> <name>newentry</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__entry_versioned</name><argument_list>(<argument><expr>&amp;<name>entry</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>newentry</name>.<name>lock_token</name></name> = <name><name>newentry</name>.<name>lock_owner</name></name> = <name><name>newentry</name>.<name>lock_comment</name></name> = <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>newentry</name>.<name>lock_creation_date</name></name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__entry_modify</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name><name>entry</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr>&amp;<name>newentry</name></expr></argument>,
                               <argument><expr><name>SVN_WC__ENTRY_MODIFY_LOCK_TOKEN</name>
                               | <name>SVN_WC__ENTRY_MODIFY_LOCK_OWNER</name>
                               | <name>SVN_WC__ENTRY_MODIFY_LOCK_COMMENT</name>
                               | <name>SVN_WC__ENTRY_MODIFY_LOCK_CREATION_DATE</name></expr></argument>,
                               <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <block>{ <comment type="block">/* if svn:needs-lock is present, then make the file read-only. */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>needs_lock</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_prop_get</name><argument_list>(<argument><expr>&amp;<name>needs_lock</name></expr></argument>, <argument><expr><name>SVN_PROP_NEEDS_LOCK</name></expr></argument>,
                            <argument><expr><name>path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>needs_lock</name></expr>)</condition><then>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_set_file_read_only</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  }</block>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_wc_set_changelist</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                      <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>changelist</name></decl></param>,
                      <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                      <param><decl><type><name>svn_cancel_func_t</name></type> <name>cancel_func</name></decl></param>,
                      <param><decl><type><name>void</name> *</type><name>cancel_baton</name></decl></param>,
                      <param><decl><type><name>svn_wc_notify_func2_t</name></type> <name>notify_func</name></decl></param>,
                      <param><decl><type><name>void</name> *</type><name>notify_baton</name></decl></param>,
                      <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>entry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_wc_entry_t</name></type> <name>newentry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_wc_notify_t</name> *</type><name>notify</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_entry</name><argument_list>(<argument><expr>&amp;<name>entry</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>! <name>entry</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_UNVERSIONED_RESOURCE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><call><name>_</name><argument_list>(<argument><expr>"'%s' is not under version control"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* We can't do changelists on directories. */</comment>
  <if>if <condition>(<expr><name><name>entry</name>-&gt;<name>kind</name></name> == <name>svn_node_dir</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_CLIENT_IS_DIRECTORY</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><call><name>_</name><argument_list>(<argument><expr>"'%s' is a directory, and thus cannot"
                               " be a member of a changelist"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* If the path has no changelist and we're removing changelist, skip it. */</comment>
  <if>if <condition>(<expr>! (<name>changelist</name> || <name><name>entry</name>-&gt;<name>changelist</name></name>)</expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <comment type="block">/* If the path is already assigned to the changelist we're
     trying to assign, skip it. */</comment>
  <if>if <condition>(<expr><name><name>entry</name>-&gt;<name>changelist</name></name> 
      &amp;&amp; <name>changelist</name> 
      &amp;&amp; <call><name>strcmp</name><argument_list>(<argument><expr><name><name>entry</name>-&gt;<name>changelist</name></name></expr></argument>, <argument><expr><name>changelist</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <comment type="block">/* If the path is already a member of a changelist, warn the
     user about this, but still allow the reassignment to happen. */</comment>
  <if>if <condition>(<expr><name><name>entry</name>-&gt;<name>changelist</name></name> &amp;&amp; <name>changelist</name> &amp;&amp; <name>notify_func</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>reassign_err</name> <init>=
        <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_WC_CHANGELIST_MOVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                          <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Removing '%s' from changelist '%s'."</expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>entry</name>-&gt;<name>changelist</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>notify</name> = <call><name>svn_wc_create_notify</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>svn_wc_notify_changelist_moved</name></expr></argument>, 
                                    <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>notify</name>-&gt;<name>err</name></name> = <name>reassign_err</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>notify_func</name><argument_list>(<argument><expr><name>notify_baton</name></expr></argument>, <argument><expr><name>notify</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name><name>notify</name>-&gt;<name>err</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  
  <comment type="block">/* Tweak the entry. */</comment>
  <expr_stmt><expr><name><name>newentry</name>.<name>changelist</name></name> = <name>changelist</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__entry_modify</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name><name>entry</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr>&amp;<name>newentry</name></expr></argument>,
                               <argument><expr><name>SVN_WC__ENTRY_MODIFY_CHANGELIST</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <comment type="block">/* And tell someone what we've done. */</comment>
  <if>if <condition>(<expr><name>notify_func</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>notify</name> = <call><name>svn_wc_create_notify</name><argument_list>(<argument><expr><name>path</name></expr></argument>, 
                                    <argument><expr><name>changelist</name> 
                                    ? <name>svn_wc_notify_changelist_set</name>
                                    : <name>svn_wc_notify_changelist_clear</name></expr></argument>,
                                    <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>notify</name>-&gt;<name>changelist_name</name></name> = <name>changelist</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>notify_func</name><argument_list>(<argument><expr><name>notify_baton</name></expr></argument>, <argument><expr><name>notify</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
</unit>
