<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/subversion-1.5.1/source/subversion/libsvn_wc/merge.c"><comment type="block">/*
 * merge.c:  merging changes into a working file
 *
 * ====================================================================
 * Copyright (c) 2000-2006 CollabNet.  All rights reserved.
 *
 * This software is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at http://subversion.tigris.org/license-1.html.
 * If newer versions of this license are posted there, you may use a
 * newer version instead, at your option.
 *
 * This software consists of voluntary contributions made by many
 * individuals.  For exact contribution history, see the revision
 * history and logs, available at http://subversion.tigris.org/.
 * ====================================================================
 */</comment>


<escape char="0xc"/>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_wc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_diff.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_path.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"wc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"entries.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"translate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"questions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"log.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_private_config.h"</cpp:file></cpp:include>

<escape char="0xc"/>
<comment type="block">/* Return a pointer to the svn_prop_t structure from PROP_DIFF
   belonging to PROP_NAME, if any.  NULL otherwise.*/</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>svn_prop_t</name> *</type>
<name>get_prop</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>apr_array_header_t</name> *</type><name>prop_diff</name></decl></param>,
         <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>prop_name</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>prop_diff</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>prop_diff</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
        <block>{
          <decl_stmt><decl><type><specifier>const</specifier> <name>svn_prop_t</name> *</type><name>elt</name> <init>= <expr>&amp;<call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>prop_diff</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>svn_prop_t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>elt</name>-&gt;<name>name</name></name></expr></argument>,<argument><expr><name>prop_name</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
            <return>return <expr><name>elt</name></expr>;</return></then></if>
        }</block></for>
    }</block></then></if>

  <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>


<comment type="block">/* Detranslate a working copy file MERGE_TARGET to achieve the effect of:

   1. Detranslate
   2. Install new props
   3. Retranslate
   4. Detranslate

   in 1 pass to get a file which can be compared with the left and right
   files which were created with the 'new props' above.

   Property changes make this a little complex though. Changes in

   - svn:mime-type
   - svn:eol-style
   - svn:keywords
   - svn:special

   may change the way a file is translated.

   Effect for svn:mime-type:

     The value for svn:mime-type affects the translation wrt keywords
     and eol-style settings.

   I) both old and new mime-types are texty
      -&gt; just do the translation dance (as lined out below)

   II) the old one is texty, the new one is binary
      -&gt; detranslate with the old eol-style and keywords
         (the new re+detranslation is a no-op)

   III) the old one is binary, the new one texty
      -&gt; detranslate with the new eol-style
         (the old detranslation is a no-op)

   IV) the old and new ones are binary
      -&gt; don't detranslate, just make a straight copy


   Effect for svn:eol-style

   I) On add or change use the new value

   II) otherwise: use the old value (absent means 'no translation')


   Effect for svn:keywords

     Always use old settings (re+detranslation are no-op)


   Effect for svn:special

     Always use the old settings (same reasons as for svn:keywords)

*/</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>detranslate_wc_file</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>detranslated_file</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>merge_target</name></decl></param>,
                    <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                    <param><decl><type><name>svn_boolean_t</name></type> <name>force_copy</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>apr_array_header_t</name> *</type><name>prop_diff</name></decl></param>,
                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>is_binary</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_prop_t</name> *</type><name>prop</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_subst_eol_style_t</name></type> <name>style</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>eol</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>keywords</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>special</name></decl>;</decl_stmt>

  <comment type="block">/* Decide if the merge target currently is a text or binary file. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_has_binary_prop</name><argument_list>(<argument><expr>&amp;<name>is_binary</name></expr></argument>,
                                 <argument><expr><name>merge_target</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


  <comment type="block">/* See if we need to do a straight copy:
     - old and new mime-types are binary, or
     - old mime-type is binary and no new mime-type specified */</comment>
  <if>if <condition>(<expr><name>is_binary</name>
      &amp;&amp; (((<name>prop</name> = <call><name>get_prop</name><argument_list>(<argument><expr><name>prop_diff</name></expr></argument>, <argument><expr><name>SVN_PROP_MIME_TYPE</name></expr></argument>)</argument_list></call>)
           &amp;&amp; <name><name>prop</name>-&gt;<name>value</name></name> &amp;&amp; <call><name>svn_mime_type_is_binary</name><argument_list>(<argument><expr><name><name>prop</name>-&gt;<name>value</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call>)
          || <name>prop</name> == <name>NULL</name>)</expr>)</condition><then>
    <block>{
      <comment type="block">/* this is case IV above */</comment>
      <expr_stmt><expr><name>keywords</name> = <name>NULL</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>special</name> = <name>FALSE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>eol</name> = <name>NULL</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>style</name> = <name>svn_subst_eol_style_none</name></expr>;</expr_stmt>
    }</block></then>
  <else>else <if>if <condition>(<expr>(!<name>is_binary</name>)
           &amp;&amp; (<name>prop</name> = <call><name>get_prop</name><argument_list>(<argument><expr><name>prop_diff</name></expr></argument>, <argument><expr><name>SVN_PROP_MIME_TYPE</name></expr></argument>)</argument_list></call>)
           &amp;&amp; <name><name>prop</name>-&gt;<name>value</name></name> &amp;&amp; <call><name>svn_mime_type_is_binary</name><argument_list>(<argument><expr><name><name>prop</name>-&gt;<name>value</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <comment type="block">/* Old props indicate texty, new props indicate binary:
         detranslate keywords and old eol-style */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__get_keywords</name><argument_list>(<argument><expr>&amp;<name>keywords</name></expr></argument>, <argument><expr><name>merge_target</name></expr></argument>,
                                   <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__get_special</name><argument_list>(<argument><expr>&amp;<name>special</name></expr></argument>, <argument><expr><name>merge_target</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <comment type="block">/* New props indicate texty, regardless of old props */</comment>

      <comment type="block">/* In case the file used to be special, detranslate specially */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__get_special</name><argument_list>(<argument><expr>&amp;<name>special</name></expr></argument>, <argument><expr><name>merge_target</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr><name>special</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>keywords</name> = <name>NULL</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>eol</name> = <name>NULL</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>style</name> = <name>svn_subst_eol_style_none</name></expr>;</expr_stmt>
        }</block></then>
      <else>else
        <block>{
          <comment type="block">/* In case a new eol style was set, use that for detranslation */</comment>
          <if>if <condition>(<expr>(<name>prop</name> = <call><name>get_prop</name><argument_list>(<argument><expr><name>prop_diff</name></expr></argument>, <argument><expr><name>SVN_PROP_EOL_STYLE</name></expr></argument>)</argument_list></call>) &amp;&amp; <name><name>prop</name>-&gt;<name>value</name></name></expr>)</condition><then>
            <block>{
              <comment type="block">/* Value added or changed */</comment>
              <expr_stmt><expr><call><name>svn_subst_eol_style_from_value</name><argument_list>(<argument><expr>&amp;<name>style</name></expr></argument>, <argument><expr>&amp;<name>eol</name></expr></argument>, <argument><expr><name><name>prop</name>-&gt;<name>value</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
          <else>else <if>if <condition>(<expr>!<name>is_binary</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__get_eol_style</name><argument_list>(<argument><expr>&amp;<name>style</name></expr></argument>, <argument><expr>&amp;<name>eol</name></expr></argument>, <argument><expr><name>merge_target</name></expr></argument>,
                                          <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
          <else>else
            <block>{
              <expr_stmt><expr><name>eol</name> = <name>NULL</name></expr>;</expr_stmt>
              <expr_stmt><expr><name>style</name> = <name>svn_subst_eol_style_none</name></expr>;</expr_stmt>
            }</block></else></if></else></if>

          <comment type="block">/* In case there were keywords, detranslate with keywords
             (iff we were texty) */</comment>
          <if>if <condition>(<expr>!<name>is_binary</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__get_keywords</name><argument_list>(<argument><expr>&amp;<name>keywords</name></expr></argument>, <argument><expr><name>merge_target</name></expr></argument>,
                                         <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
          <else>else
            <expr_stmt><expr><name>keywords</name> = <name>NULL</name></expr>;</expr_stmt></else></if>
        }</block></else></if>
    }</block></else></if></else></if>

  <comment type="block">/* Now, detranslate with the settings we created above */</comment>

  <if>if <condition>(<expr><name>force_copy</name> || <name>keywords</name> || <name>eol</name> || <name>special</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>detranslated</name></decl>;</decl_stmt>
      <comment type="block">/* Force a copy into the temporary wc area to avoid having
         temporary files created below to appear in the actual wc. */</comment>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_create_tmp_file2</name>
              <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>detranslated</name></expr></argument>,
               <argument><expr><call><name>svn_wc_adm_access_path</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>)</argument_list></call></expr></argument>,
               <argument><expr><name>svn_io_file_del_none</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_subst_translate_to_normal_form</name><argument_list>(<argument><expr><name>merge_target</name></expr></argument>,
                                                 <argument><expr><name>detranslated</name></expr></argument>,
                                                 <argument><expr><name>style</name></expr></argument>,
                                                 <argument><expr><name>eol</name></expr></argument>, <argument><expr><name>eol</name> ? <name>FALSE</name> : <name>TRUE</name></expr></argument>,
                                                 <argument><expr><name>keywords</name></expr></argument>,
                                                 <argument><expr><name>special</name></expr></argument>,
                                                 <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>detranslated_file</name> = <name>detranslated</name></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <expr_stmt><expr>*<name>detranslated_file</name> = <name>merge_target</name></expr>;</expr_stmt></else></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Updates (by copying and translating) the eol style in
   OLD_TARGET returning the filename containing the
   correct eol style in NEW_TARGET, if an eol style
   change is contained in PROP_DIFF */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>maybe_update_target_eols</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>new_target</name></decl></param>,
                         <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>old_target</name></decl></param>,
                         <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                         <param><decl><type><specifier>const</specifier> <name>apr_array_header_t</name> *</type><name>prop_diff</name></decl></param>,
                         <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_prop_t</name> *</type><name>prop</name> <init>= <expr><call><name>get_prop</name><argument_list>(<argument><expr><name>prop_diff</name></expr></argument>, <argument><expr><name>SVN_PROP_EOL_STYLE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>prop</name> &amp;&amp; <name><name>prop</name>-&gt;<name>value</name></name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>eol</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>tmp_new</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>svn_subst_eol_style_from_value</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>eol</name></expr></argument>, <argument><expr><name><name>prop</name>-&gt;<name>value</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_create_tmp_file2</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>tmp_new</name></expr></argument>,
                                      <argument><expr><call><name>svn_wc_adm_access_path</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>)</argument_list></call></expr></argument>,
                                      <argument><expr><name>svn_io_file_del_none</name></expr></argument>,
                                      <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_subst_copy_and_translate3</name><argument_list>(<argument><expr><name>old_target</name></expr></argument>,
                                            <argument><expr><name>tmp_new</name></expr></argument>,
                                            <argument><expr><name>eol</name></expr></argument>, <argument><expr><name>eol</name> ? <name>FALSE</name> : <name>TRUE</name></expr></argument>,
                                            <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                                            <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>new_target</name> = <name>tmp_new</name></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <expr_stmt><expr>*<name>new_target</name> = <name>old_target</name></expr>;</expr_stmt></else></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Internal version of svn_wc_merge, also used to (loggily) merge updates
   from the repository.

   In the case of updating, the update can have sent new properties,
   which could affect the way the wc target is detranslated and
   compared with LEFT and RIGHT for merging.

   Property changes sent by the update are provided in PROP_DIFF.

   If COPYFROM_TEXT is non-null, the working text is taken from this
   file instead of from the actual version in the working copy (and
   the merge_target is allowed to not be under version control in this
   case).
 */</comment>
<decl_stmt><decl><type><name>svn_error_t</name> *</type>
<name>svn_wc__merge_internal</name><argument_list>(<argument><expr><name>svn_stringbuf_t</name> **<name>log_accum</name></expr></argument>,
                       <argument>enum <expr><name>svn_wc_merge_outcome_t</name> *<name>merge_outcome</name></expr></argument>,
                       <argument><expr>const <name>char</name> *<name>left</name></expr></argument>,
                       <argument><expr>const <name>char</name> *<name>right</name></expr></argument>,
                       <argument><expr>const <name>char</name> *<name>merge_target</name></expr></argument>,
                       <argument><expr>const <name>char</name> *<name>copyfrom_text</name></expr></argument>,
                       <argument><expr><name>svn_wc_adm_access_t</name> *<name>adm_access</name></expr></argument>,
                       <argument><expr>const <name>char</name> *<name>left_label</name></expr></argument>,
                       <argument><expr>const <name>char</name> *<name>right_label</name></expr></argument>,
                       <argument><expr>const <name>char</name> *<name>target_label</name></expr></argument>,
                       <argument><expr><name>svn_boolean_t</name> <name>dry_run</name></expr></argument>,
                       <argument><expr>const <name>char</name> *<name>diff3_cmd</name></expr></argument>,
                       <argument><expr>const <name>apr_array_header_t</name> *<name>merge_options</name></expr></argument>,
                       <argument><expr>const <name>apr_array_header_t</name> *<name>prop_diff</name></expr></argument>,
                       <argument><expr><name>svn_wc_conflict_resolver_func_t</name> <name>conflict_func</name></expr></argument>,
                       <argument><expr><name>void</name> *<name>conflict_baton</name></expr></argument>,
                       <argument><expr><name>apr_pool_t</name> *<name>pool</name></expr></argument>)</argument_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>tmp_target</name></decl>, *<decl><type ref="prev"/><name>result_target</name></decl>, *<decl><type ref="prev"/><name>working_text</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>adm_path</name> <init>= <expr><call><name>svn_wc_adm_access_path</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>result_f</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>is_binary</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>entry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>contains_conflicts</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_prop_t</name> *</type><name>mimeprop</name></decl>;</decl_stmt>

  <comment type="block">/* Sanity check:  the merge target must be under revision control (unless
     this is an add-with-history). */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_entry</name><argument_list>(<argument><expr>&amp;<name>entry</name></expr></argument>, <argument><expr><name>merge_target</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>! <name>entry</name> &amp;&amp; ! <name>copyfrom_text</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr>*<name>merge_outcome</name> = <name>svn_wc_merge_no_merge</name></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>

  <comment type="block">/* Decide if the merge target is a text or binary file. */</comment>
  <if>if <condition>(<expr>(<name>mimeprop</name> = <call><name>get_prop</name><argument_list>(<argument><expr><name>prop_diff</name></expr></argument>, <argument><expr><name>SVN_PROP_MIME_TYPE</name></expr></argument>)</argument_list></call>)
      &amp;&amp; <name><name>mimeprop</name>-&gt;<name>value</name></name></expr>)</condition><then>
    <expr_stmt><expr><name>is_binary</name> = <call><name>svn_mime_type_is_binary</name><argument_list>(<argument><expr><name><name>mimeprop</name>-&gt;<name>value</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else <if>if <condition>(<expr>! <name>copyfrom_text</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_has_binary_prop</name><argument_list>(<argument><expr>&amp;<name>is_binary</name></expr></argument>, <argument><expr><name>merge_target</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if>

  <expr_stmt><expr><name>working_text</name> = <name>copyfrom_text</name> ? <name>copyfrom_text</name> : <name>merge_target</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>detranslate_wc_file</name><argument_list>(<argument><expr>&amp;<name>tmp_target</name></expr></argument>, <argument><expr><name>working_text</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                              <argument><expr>(! <name>is_binary</name>) &amp;&amp; <name>diff3_cmd</name> != <name>NULL</name></expr></argument>,
                              <argument><expr><name>prop_diff</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* We cannot depend on the left file to contain the same eols as the
     right file. If the merge target has mods, this will mark the entire
     file as conflicted, so we need to compensate. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>maybe_update_target_eols</name><argument_list>(<argument><expr>&amp;<name>left</name></expr></argument>, <argument><expr><name>left</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>prop_diff</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr>! <name>is_binary</name></expr>)</condition><then>              <comment type="block">/* this is a text file */</comment>
    <block>{
      <comment type="block">/* Open a second temporary file for writing; this is where diff3
         will write the merged results. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_create_tmp_file2</name><argument_list>(<argument><expr>&amp;<name>result_f</name></expr></argument>, <argument><expr>&amp;<name>result_target</name></expr></argument>,
                                      <argument><expr><name>adm_path</name></expr></argument>, <argument><expr><name>svn_io_file_del_none</name></expr></argument>,
                                      <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Run an external merge if requested. */</comment>
      <if>if <condition>(<expr><name>diff3_cmd</name></expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><name>int</name></type> <name>exit_code</name></decl>;</decl_stmt>

          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_run_diff3_2</name><argument_list>(<argument><expr>&amp;<name>exit_code</name></expr></argument>, <argument><expr>"."</expr></argument>,
                                     <argument><expr><name>tmp_target</name></expr></argument>, <argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>,
                                     <argument><expr><name>target_label</name></expr></argument>, <argument><expr><name>left_label</name></expr></argument>, <argument><expr><name>right_label</name></expr></argument>,
                                     <argument><expr><name>result_f</name></expr></argument>, <argument><expr><name>diff3_cmd</name></expr></argument>,
                                     <argument><expr><name>merge_options</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <expr_stmt><expr><name>contains_conflicts</name> = <name>exit_code</name> == 1</expr>;</expr_stmt>
        }</block></then>
      <else>else
        <block>{
          <decl_stmt><decl><type><name>svn_diff_t</name> *</type><name>diff</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>target_marker</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>left_marker</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>right_marker</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>ostream</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>svn_diff_file_options_t</name> *</type><name>options</name></decl>;</decl_stmt>

          <expr_stmt><expr><name>ostream</name> = <call><name>svn_stream_from_aprfile</name><argument_list>(<argument><expr><name>result_f</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>options</name> = <call><name>svn_diff_file_options_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <if>if <condition>(<expr><name>merge_options</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_diff_file_options_parse</name><argument_list>(<argument><expr><name>options</name></expr></argument>, <argument><expr><name>merge_options</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_diff_file_diff3_2</name><argument_list>(<argument><expr>&amp;<name>diff</name></expr></argument>,
                                        <argument><expr><name>left</name></expr></argument>, <argument><expr><name>tmp_target</name></expr></argument>, <argument><expr><name>right</name></expr></argument>,
                                        <argument><expr><name>options</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Labels fall back to sensible defaults if not specified. */</comment>
          <if>if <condition>(<expr><name>target_label</name></expr>)</condition><then>
            <expr_stmt><expr><name>target_marker</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"&lt;&lt;&lt;&lt;&lt;&lt;&lt; %s"</expr></argument>, <argument><expr><name>target_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
          <else>else
            <expr_stmt><expr><name>target_marker</name> = "&lt;&lt;&lt;&lt;&lt;&lt;&lt; .working"</expr>;</expr_stmt></else></if>

          <if>if <condition>(<expr><name>left_label</name></expr>)</condition><then>
            <expr_stmt><expr><name>left_marker</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"||||||| %s"</expr></argument>, <argument><expr><name>left_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
          <else>else
            <expr_stmt><expr><name>left_marker</name> = "||||||| .old"</expr>;</expr_stmt></else></if>

          <if>if <condition>(<expr><name>right_label</name></expr>)</condition><then>
            <expr_stmt><expr><name>right_marker</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"&gt;&gt;&gt;&gt;&gt;&gt;&gt; %s"</expr></argument>, <argument><expr><name>right_label</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
          <else>else
            <expr_stmt><expr><name>right_marker</name> = "&gt;&gt;&gt;&gt;&gt;&gt;&gt; .new"</expr>;</expr_stmt></else></if>

          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_diff_file_output_merge</name><argument_list>(<argument><expr><name>ostream</name></expr></argument>, <argument><expr><name>diff</name></expr></argument>,
                                             <argument><expr><name>left</name></expr></argument>, <argument><expr><name>tmp_target</name></expr></argument>, <argument><expr><name>right</name></expr></argument>,
                                             <argument><expr><name>left_marker</name></expr></argument>,
                                             <argument><expr><name>target_marker</name></expr></argument>,
                                             <argument><expr><name>right_marker</name></expr></argument>,
                                             <argument><expr>"======="</expr></argument>, <comment type="block">/* seperator */</comment>
                                             <argument><expr><name>FALSE</name></expr></argument>, <comment type="block">/* display original */</comment>
                                             <argument><expr><name>FALSE</name></expr></argument>, <comment type="block">/* resolve conflicts */</comment>
                                             <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_close</name><argument_list>(<argument><expr><name>ostream</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <expr_stmt><expr><name>contains_conflicts</name> = <call><name>svn_diff_contains_conflicts</name><argument_list>(<argument><expr><name>diff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>

      <comment type="block">/* Close the output file */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_close</name><argument_list>(<argument><expr><name>result_f</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr><name>contains_conflicts</name> &amp;&amp; ! <name>dry_run</name></expr>)</condition><then>  <comment type="block">/* got a conflict */</comment>
        <block>{
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>left_copy</name></decl>, *<decl><type ref="prev"/><name>right_copy</name></decl>, *<decl><type ref="prev"/><name>target_copy</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>tmp_left</name></decl>, *<decl><type ref="prev"/><name>tmp_right</name></decl>, *<decl><type ref="prev"/><name>tmp_target_copy</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>parentt</name></decl>, *<decl><type ref="prev"/><name>target_base</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>svn_wc_adm_access_t</name> *</type><name>parent_access</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>svn_wc_entry_t</name></type> <name>tmp_entry</name></decl>;</decl_stmt>

          <comment type="block">/* Give the conflict resolution callback a chance to clean
             up the conflict before we mark the file 'conflicted' */</comment>
          <if>if <condition>(<expr><name>conflict_func</name></expr>)</condition><then>
            <block>{
              <decl_stmt><decl><type><name>svn_wc_conflict_result_t</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
              <decl_stmt><decl><type><name>svn_wc_conflict_description_t</name></type> <name>cdesc</name></decl>;</decl_stmt>

              <expr_stmt><expr><name><name>cdesc</name>.<name>path</name></name> = <name>merge_target</name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>cdesc</name>.<name>node_kind</name></name> = <name>svn_node_file</name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>cdesc</name>.<name>kind</name></name> = <name>svn_wc_conflict_kind_text</name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>cdesc</name>.<name>is_binary</name></name> = <name>FALSE</name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>cdesc</name>.<name>mime_type</name></name> = (<name>mimeprop</name> &amp;&amp; <name><name>mimeprop</name>-&gt;<name>value</name></name>)
                                  ? <name><name>mimeprop</name>-&gt;<name>value</name>-&gt;<name>data</name></name> : <name>NULL</name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>cdesc</name>.<name>access</name></name> = <name>adm_access</name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>cdesc</name>.<name>action</name></name> = <name>svn_wc_conflict_action_edit</name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>cdesc</name>.<name>reason</name></name> = <name>svn_wc_conflict_reason_edited</name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>cdesc</name>.<name>base_file</name></name> = <name>left</name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>cdesc</name>.<name>their_file</name></name> = <name>right</name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>cdesc</name>.<name>my_file</name></name> = <name>tmp_target</name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>cdesc</name>.<name>merged_file</name></name> = <name>result_target</name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>cdesc</name>.<name>property_name</name></name> = <name>NULL</name></expr>;</expr_stmt>

              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>conflict_func</name><argument_list>(<argument><expr>&amp;<name>result</name></expr></argument>, <argument><expr>&amp;<name>cdesc</name></expr></argument>, <argument><expr><name>conflict_baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
                <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_WC_CONFLICT_RESOLVER_FAILURE</name></expr></argument>,
                                        <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Conflict callback violated API:"
                                                " returned no results"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

              <switch>switch <condition>(<expr><name><name>result</name>-&gt;<name>choice</name></name></expr>)</condition>
                <block>{
                  <comment type="block">/* If the callback wants to use one of the fulltexts
                     to resolve the conflict, so be it.*/</comment>
                  <case>case <expr><name>svn_wc_conflict_choose_base</name></expr>:
                    <block>{
                      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_copy</name>
                              <argument_list>(<argument><expr><name>log_accum</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                               <argument><expr><name>svn_wc__copy_translate</name></expr></argument>,
                               <argument><expr><name>left</name></expr></argument>, <argument><expr><name>merge_target</name></expr></argument>,
                               <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                      <expr_stmt><expr>*<name>merge_outcome</name> = <name>svn_wc_merge_merged</name></expr>;</expr_stmt>
                      <expr_stmt><expr><name>contains_conflicts</name> = <name>FALSE</name></expr>;</expr_stmt>
                      <goto>goto <name>merge_complete</name>;</goto>
                    }</block>
                  </case><case>case <expr><name>svn_wc_conflict_choose_theirs_full</name></expr>:
                    <block>{
                      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_copy</name>
                              <argument_list>(<argument><expr><name>log_accum</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                               <argument><expr><name>svn_wc__copy_translate</name></expr></argument>,
                               <argument><expr><name>right</name></expr></argument>, <argument><expr><name>merge_target</name></expr></argument>,
                               <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                      <expr_stmt><expr>*<name>merge_outcome</name> = <name>svn_wc_merge_merged</name></expr>;</expr_stmt>
                      <expr_stmt><expr><name>contains_conflicts</name> = <name>FALSE</name></expr>;</expr_stmt>
                      <goto>goto <name>merge_complete</name>;</goto>
                    }</block>
                  </case><case>case <expr><name>svn_wc_conflict_choose_mine_full</name></expr>:
                    <block>{
                      <comment type="block">/* Do nothing to merge_target, let it live untouched! */</comment>
                      <expr_stmt><expr>*<name>merge_outcome</name> = <name>svn_wc_merge_merged</name></expr>;</expr_stmt>
                      <expr_stmt><expr><name>contains_conflicts</name> = <name>FALSE</name></expr>;</expr_stmt>
                      <goto>goto <name>merge_complete</name>;</goto>
                    }</block>

                    <comment type="block">/* For the case of 3-way file merging, we don't
                       really distinguish between these return values;
                       if the callback claims to have "generally
                       resolved" the situation, we still interpret
                       that as "OK, we'll assume the merged version is
                       good to use". */</comment>
                  </case><case>case <expr><name>svn_wc_conflict_choose_merged</name></expr>:
                    <block>{
                      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_copy</name>
                              <argument_list>(<argument><expr><name>log_accum</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                               <argument><expr><name>svn_wc__copy_translate</name></expr></argument>,
                               <comment type="block">/* Look for callback's own merged-file first: */</comment>
                               <argument><expr><name><name>result</name>-&gt;<name>merged_file</name></name> ?
                                  <name><name>result</name>-&gt;<name>merged_file</name></name> : <name>result_target</name></expr></argument>,
                               <argument><expr><name>merge_target</name></expr></argument>,
                               <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                      <expr_stmt><expr>*<name>merge_outcome</name> = <name>svn_wc_merge_merged</name></expr>;</expr_stmt>
                      <expr_stmt><expr><name>contains_conflicts</name> = <name>FALSE</name></expr>;</expr_stmt>
                      <goto>goto <name>merge_complete</name>;</goto>
                    }</block>
                  </case><case>case <expr><name>svn_wc_conflict_choose_postpone</name></expr>:
                  </case><default>default:
                    <block>{
                      <comment type="block">/* Assume conflict remains, fall through to code below. */</comment>
                    }</block>
                </default>}</block></switch>
            }</block></then></if>

          <comment type="block">/* Preserve the three pre-merge files, and modify the
             entry (mark as conflicted, track the preserved files). */</comment>

          <comment type="block">/* I miss Lisp. */</comment>

          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_open_unique_file2</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
                                           <argument><expr>&amp;<name>left_copy</name></expr></argument>,
                                           <argument><expr><name>merge_target</name></expr></argument>,
                                           <argument><expr><name>left_label</name></expr></argument>,
                                           <argument><expr><name>svn_io_file_del_none</name></expr></argument>,
                                           <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Have I mentioned how much I miss Lisp? */</comment>

          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_open_unique_file2</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
                                           <argument><expr>&amp;<name>right_copy</name></expr></argument>,
                                           <argument><expr><name>merge_target</name></expr></argument>,
                                           <argument><expr><name>right_label</name></expr></argument>,
                                           <argument><expr><name>svn_io_file_del_none</name></expr></argument>,
                                           <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Why, how much more pleasant to be forced to unroll my loops.
             If I'd been writing in Lisp, I might have mapped an inline
             lambda form over a list, or something equally disgusting.
             Thank goodness C was here to protect me! */</comment>

          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_open_unique_file2</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
                                           <argument><expr>&amp;<name>target_copy</name></expr></argument>,
                                           <argument><expr><name>merge_target</name></expr></argument>,
                                           <argument><expr><name>target_label</name></expr></argument>,
                                           <argument><expr><name>svn_io_file_del_none</name></expr></argument>,
                                           <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* We preserve all the files with keywords expanded and line
             endings in local (working) form. */</comment>

          <expr_stmt><expr><call><name>svn_path_split</name><argument_list>(<argument><expr><name>target_copy</name></expr></argument>, <argument><expr>&amp;<name>parentt</name></expr></argument>, <argument><expr>&amp;<name>target_base</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_adm_retrieve</name><argument_list>(<argument><expr>&amp;<name>parent_access</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>parentt</name></expr></argument>,
                                      <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Log files require their paths to be in the subtree
             relative to the adm_access path they are executed in.

             Make our LEFT and RIGHT files 'local' if they aren't... */</comment>
          <if>if <condition>(<expr>! <call><name>svn_path_is_child</name><argument_list>(<argument><expr><name>adm_path</name></expr></argument>, <argument><expr><name>left</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <block>{
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_create_tmp_file2</name>
                      <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>tmp_left</name></expr></argument>,
                       <argument><expr><name>adm_path</name></expr></argument>, <argument><expr><name>svn_io_file_del_none</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_copy_file</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>tmp_left</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
          <else>else
            <expr_stmt><expr><name>tmp_left</name> = <name>left</name></expr>;</expr_stmt></else></if>

          <if>if <condition>(<expr>! <call><name>svn_path_is_child</name><argument_list>(<argument><expr><name>adm_path</name></expr></argument>, <argument><expr><name>right</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <block>{
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_create_tmp_file2</name>
                      <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>tmp_right</name></expr></argument>,
                       <argument><expr><name>adm_path</name></expr></argument>, <argument><expr><name>svn_io_file_del_none</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_copy_file</name><argument_list>(<argument><expr><name>right</name></expr></argument>, <argument><expr><name>tmp_right</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
          <else>else
            <expr_stmt><expr><name>tmp_right</name> = <name>right</name></expr>;</expr_stmt></else></if>

          <comment type="block">/* NOTE: Callers must ensure that the svn:eol-style and
             svn:keywords property values are correct in the currently
             installed props.  With 'svn merge', it's no big deal.  But
             when 'svn up' calls this routine, it needs to make sure that
             this routine is using the newest property values that may
             have been received *during* the update.  Since this routine
             will be run from within a log-command, merge_file()
             needs to make sure that a previous log-command to 'install
             latest props' has already executed first.  Ben and I just
             checked, and that is indeed the order in which the log items
             are written, so everything should be fine.  Really.  */</comment>

          <comment type="block">/* Create LEFT and RIGHT backup files, in expanded form.
             We use merge_target's current properties to do the translation. */</comment>
          <comment type="block">/* Derive the basenames of the 3 backup files. */</comment>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_translated_file</name><argument_list>(<argument><expr><name>log_accum</name></expr></argument>,
                                                <argument><expr><name>adm_access</name></expr></argument>,
                                                <argument><expr><name>left_copy</name></expr></argument>, <argument><expr><name>tmp_left</name></expr></argument>,
                                                <argument><expr><name>merge_target</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_translated_file</name><argument_list>(<argument><expr><name>log_accum</name></expr></argument>,
                                                <argument><expr><name>adm_access</name></expr></argument>,
                                                <argument><expr><name>right_copy</name></expr></argument>, <argument><expr><name>tmp_right</name></expr></argument>,
                                                <argument><expr><name>merge_target</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Back up MERGE_TARGET through detranslation/retranslation:
             the new translation properties may not match the current ones */</comment>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_translated_file2</name><argument_list>(<argument><expr>&amp;<name>tmp_target_copy</name></expr></argument>,
                                          <argument><expr><name>merge_target</name></expr></argument>,
                                          <argument><expr><name>merge_target</name></expr></argument>,
                                          <argument><expr><name>adm_access</name></expr></argument>,
                                          <argument><expr><name>SVN_WC_TRANSLATE_TO_NF</name>
                                          | <name>SVN_WC_TRANSLATE_NO_OUTPUT_CLEANUP</name></expr></argument>,
                                          <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_translated_file</name>
                  <argument_list>(<argument><expr><name>log_accum</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                   <argument><expr><name>target_copy</name></expr></argument>, <argument><expr><name>tmp_target_copy</name></expr></argument>, <argument><expr><name>merge_target</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <expr_stmt><expr><name><name>tmp_entry</name>.<name>conflict_old</name></name>
            = <call><name>svn_path_is_child</name><argument_list>(<argument><expr><name>adm_path</name></expr></argument>, <argument><expr><name>left_copy</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>tmp_entry</name>.<name>conflict_new</name></name>
            = <call><name>svn_path_is_child</name><argument_list>(<argument><expr><name>adm_path</name></expr></argument>, <argument><expr><name>right_copy</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>tmp_entry</name>.<name>conflict_wrk</name></name> = <name>target_base</name></expr>;</expr_stmt>

          <comment type="block">/* Mark merge_target's entry as "Conflicted", and start tracking
             the backup files in the entry as well. */</comment>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_entry_modify</name>
                  <argument_list>(<argument><expr><name>log_accum</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                   <argument><expr><name>merge_target</name></expr></argument>, <argument><expr>&amp;<name>tmp_entry</name></expr></argument>,
                   <argument><expr><name>SVN_WC__ENTRY_MODIFY_CONFLICT_OLD</name>
                   | <name>SVN_WC__ENTRY_MODIFY_CONFLICT_NEW</name>
                   | <name>SVN_WC__ENTRY_MODIFY_CONFLICT_WRK</name></expr></argument>,
                   <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <expr_stmt><expr>*<name>merge_outcome</name> = <name>svn_wc_merge_conflict</name></expr>;</expr_stmt>
        }</block></then>
      <else>else <if>if <condition>(<expr><name>contains_conflicts</name> &amp;&amp; <name>dry_run</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr>*<name>merge_outcome</name> = <name>svn_wc_merge_conflict</name></expr>;</expr_stmt>
        }</block></then> <comment type="block">/* end of conflict handling */</comment>
      <else>else <if>if <condition>(<expr><name>copyfrom_text</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr>*<name>merge_outcome</name> = <name>svn_wc_merge_merged</name></expr>;</expr_stmt>
        }</block></then>
      <else>else
        <block>{
          <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>same</name></decl>, <decl><type ref="prev"/><name>special</name></decl>;</decl_stmt>
          <comment type="block">/* If 'special', then use the detranslated form of the
             target file.  This is so we don't try to follow symlinks,
             but the same treatment is probably also appropriate for
             whatever special file types we may invent in the future. */</comment>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__get_special</name><argument_list>(<argument><expr>&amp;<name>special</name></expr></argument>, <argument><expr><name>merge_target</name></expr></argument>,
                                      <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_files_contents_same_p</name><argument_list>(<argument><expr>&amp;<name>same</name></expr></argument>, <argument><expr><name>result_target</name></expr></argument>,
                                               <argument><expr>(<name>special</name> ?
                                                  <name>tmp_target</name> : 
                                                  <name>merge_target</name>)</expr></argument>,
                                               <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <expr_stmt><expr>*<name>merge_outcome</name> = <name>same</name> ? <name>svn_wc_merge_unchanged</name> : <name>svn_wc_merge_merged</name></expr>;</expr_stmt>
        }</block></else></if></else></if></else></if>

      <if>if <condition>(<expr>*<name>merge_outcome</name> != <name>svn_wc_merge_unchanged</name> &amp;&amp; ! <name>dry_run</name></expr>)</condition><then>
        <comment type="block">/* replace MERGE_TARGET with the new merged file, expanding. */</comment>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_copy</name><argument_list>(<argument><expr><name>log_accum</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                   <argument><expr><name>adm_access</name></expr></argument>,
                                   <argument><expr><name>svn_wc__copy_translate</name></expr></argument>,
                                   <argument><expr><name>result_target</name></expr></argument>, <argument><expr><name>merge_target</name></expr></argument>,
                                   <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    }</block></then> <comment type="block">/* end of merging for text files */</comment>

  <else>else <if>if <condition>(<expr>! <name>dry_run</name></expr>)</condition><then> <comment type="block">/* merging procedure for binary files */</comment>
    <block>{
      <comment type="block">/* ### when making the binary-file backups, should we be honoring
         keywords and eol stuff?   */</comment>

      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>left_copy</name></decl>, *<decl><type ref="prev"/><name>right_copy</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>parentt</name></decl>, *<decl><type ref="prev"/><name>left_base</name></decl>, *<decl><type ref="prev"/><name>right_base</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_wc_entry_t</name></type> <name>tmp_entry</name></decl>;</decl_stmt>

      <comment type="block">/* Give the conflict resolution callback a chance to clean
         up the conflict before we mark the file 'conflicted' */</comment>
      <if>if <condition>(<expr><name>conflict_func</name></expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><name>svn_wc_conflict_result_t</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>svn_wc_conflict_description_t</name></type> <name>cdesc</name></decl>;</decl_stmt>

          <expr_stmt><expr><name><name>cdesc</name>.<name>path</name></name> = <name>merge_target</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>cdesc</name>.<name>node_kind</name></name> = <name>svn_node_file</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>cdesc</name>.<name>kind</name></name> = <name>svn_wc_conflict_kind_text</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>cdesc</name>.<name>is_binary</name></name> = <name>TRUE</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>cdesc</name>.<name>mime_type</name></name> = (<name>mimeprop</name> &amp;&amp; <name><name>mimeprop</name>-&gt;<name>value</name></name>)
                                ? <name><name>mimeprop</name>-&gt;<name>value</name>-&gt;<name>data</name></name> : <name>NULL</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>cdesc</name>.<name>access</name></name> = <name>adm_access</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>cdesc</name>.<name>action</name></name> = <name>svn_wc_conflict_action_edit</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>cdesc</name>.<name>reason</name></name> = <name>svn_wc_conflict_reason_edited</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>cdesc</name>.<name>base_file</name></name> = <name>left</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>cdesc</name>.<name>their_file</name></name> = <name>right</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>cdesc</name>.<name>my_file</name></name> = <name>tmp_target</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>cdesc</name>.<name>merged_file</name></name> = <name>NULL</name></expr>;</expr_stmt>     <comment type="block">/* notice there is NO merged file! */</comment>
          <expr_stmt><expr><name><name>cdesc</name>.<name>property_name</name></name> = <name>NULL</name></expr>;</expr_stmt>

          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>conflict_func</name><argument_list>(<argument><expr>&amp;<name>result</name></expr></argument>, <argument><expr>&amp;<name>cdesc</name></expr></argument>, <argument><expr><name>conflict_baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
            <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_WC_CONFLICT_RESOLVER_FAILURE</name></expr></argument>,
                                    <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Conflict callback violated API:"
                                            " returned no results"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

          <switch>switch <condition>(<expr><name><name>result</name>-&gt;<name>choice</name></name></expr>)</condition>
            <block>{
              <comment type="block">/* For a binary file, there's no merged file to look at,
                 unless the conflict-callback did the merging itself. */</comment>
              <case>case <expr><name>svn_wc_conflict_choose_base</name></expr>:
                <block>{
                  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_copy</name>
                          <argument_list>(<argument><expr><name>log_accum</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                           <argument><expr><name>svn_wc__copy_translate</name></expr></argument>,
                           <argument><expr><name>left</name></expr></argument>, <argument><expr><name>merge_target</name></expr></argument>,
                           <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <expr_stmt><expr>*<name>merge_outcome</name> = <name>svn_wc_merge_merged</name></expr>;</expr_stmt>
                  <expr_stmt><expr><name>contains_conflicts</name> = <name>FALSE</name></expr>;</expr_stmt>
                  <goto>goto <name>merge_complete</name>;</goto>
                }</block>
              </case><case>case <expr><name>svn_wc_conflict_choose_theirs_full</name></expr>:
                <block>{
                  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_copy</name>
                          <argument_list>(<argument><expr><name>log_accum</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                           <argument><expr><name>svn_wc__copy_translate</name></expr></argument>,
                           <argument><expr><name>right</name></expr></argument>, <argument><expr><name>merge_target</name></expr></argument>,
                           <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <expr_stmt><expr>*<name>merge_outcome</name> = <name>svn_wc_merge_merged</name></expr>;</expr_stmt>
                  <expr_stmt><expr><name>contains_conflicts</name> = <name>FALSE</name></expr>;</expr_stmt>
                  <goto>goto <name>merge_complete</name>;</goto>
                }</block>
                <comment type="block">/* For a binary file, if the response is to use the
                   user's file, we do nothing.  We also do nothing if
                   the response claims to have already resolved the
                   problem.*/</comment>
              </case><case>case <expr><name>svn_wc_conflict_choose_mine_full</name></expr>:
                <block>{
                  <expr_stmt><expr>*<name>merge_outcome</name> = <name>svn_wc_merge_merged</name></expr>;</expr_stmt>
                  <expr_stmt><expr><name>contains_conflicts</name> = <name>FALSE</name></expr>;</expr_stmt>
                  <goto>goto <name>merge_complete</name>;</goto>
                }</block>
              </case><case>case <expr><name>svn_wc_conflict_choose_merged</name></expr>:
                <block>{
                  <if>if <condition>(<expr>! <name><name>result</name>-&gt;<name>merged_file</name></name></expr>)</condition><then>
                    <block>{
                      <comment type="block">/* Callback asked us to choose its own
                         merged file, but didn't provide one! */</comment>
                      <return>return <expr><call><name>svn_error_create</name>
                          <argument_list>(<argument><expr><name>SVN_ERR_WC_CONFLICT_RESOLVER_FAILURE</name></expr></argument>,
                           <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Conflict callback violated API:"
                                   " returned no merged file"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
                    }</block></then>
                  <else>else
                    <block>{
                      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_copy</name>
                              <argument_list>(<argument><expr><name>log_accum</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                               <argument><expr><name>svn_wc__copy_translate</name></expr></argument>,
                               <argument><expr><name><name>result</name>-&gt;<name>merged_file</name></name></expr></argument>, <argument><expr><name>merge_target</name></expr></argument>,
                               <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                      <expr_stmt><expr>*<name>merge_outcome</name> = <name>svn_wc_merge_merged</name></expr>;</expr_stmt>
                      <expr_stmt><expr><name>contains_conflicts</name> = <name>FALSE</name></expr>;</expr_stmt>
                      <goto>goto <name>merge_complete</name>;</goto>
                    }</block></else></if>
                }</block>
              </case><case>case <expr><name>svn_wc_conflict_choose_postpone</name></expr>:
              </case><default>default:
                <block>{
                  <comment type="block">/* Assume conflict remains, fall through to code below. */</comment>
                }</block>
            </default>}</block></switch>
        }</block></then></if>

      <comment type="block">/* reserve names for backups of left and right fulltexts */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_open_unique_file2</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
                                       <argument><expr>&amp;<name>left_copy</name></expr></argument>,
                                       <argument><expr><name>merge_target</name></expr></argument>,
                                       <argument><expr><name>left_label</name></expr></argument>,
                                       <argument><expr><name>svn_io_file_del_none</name></expr></argument>,
                                       <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_open_unique_file2</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
                                       <argument><expr>&amp;<name>right_copy</name></expr></argument>,
                                       <argument><expr><name>merge_target</name></expr></argument>,
                                       <argument><expr><name>right_label</name></expr></argument>,
                                       <argument><expr><name>svn_io_file_del_none</name></expr></argument>,
                                       <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* create the backup files */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_copy_file</name><argument_list>(<argument><expr><name>left</name></expr></argument>,
                               <argument><expr><name>left_copy</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_copy_file</name><argument_list>(<argument><expr><name>right</name></expr></argument>,
                               <argument><expr><name>right_copy</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Was the merge target detranslated? */</comment>
      <if>if <condition>(<expr><name>merge_target</name> != <name>tmp_target</name></expr>)</condition><then>
        <block>{
          <comment type="block">/* Create a .mine file too */</comment>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>mine_copy</name></decl>;</decl_stmt>

          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_open_unique_file2</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
                                           <argument><expr>&amp;<name>mine_copy</name></expr></argument>,
                                           <argument><expr><name>merge_target</name></expr></argument>,
                                           <argument><expr><name>target_label</name></expr></argument>,
                                           <argument><expr><name>svn_io_file_del_none</name></expr></argument>,
                                           <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_move</name><argument_list>(<argument><expr><name>log_accum</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                     <argument><expr><name>adm_access</name></expr></argument>,
                                     <argument><expr><name>tmp_target</name></expr></argument>,
                                     <argument><expr><name>mine_copy</name></expr></argument>,
                                     <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>mine_copy</name> = <call><name>svn_path_is_child</name><argument_list>(<argument><expr><name>adm_path</name></expr></argument>, <argument><expr><name>mine_copy</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>tmp_entry</name>.<name>conflict_wrk</name></name> = <name>mine_copy</name></expr>;</expr_stmt>
        }</block></then>
      <else>else
        <expr_stmt><expr><name><name>tmp_entry</name>.<name>conflict_wrk</name></name> = <name>NULL</name></expr>;</expr_stmt></else></if>

      <comment type="block">/* Derive the basenames of the backup files. */</comment>
      <expr_stmt><expr><call><name>svn_path_split</name><argument_list>(<argument><expr><name>left_copy</name></expr></argument>, <argument><expr>&amp;<name>parentt</name></expr></argument>, <argument><expr>&amp;<name>left_base</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>svn_path_split</name><argument_list>(<argument><expr><name>right_copy</name></expr></argument>, <argument><expr>&amp;<name>parentt</name></expr></argument>, <argument><expr>&amp;<name>right_base</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Mark merge_target's entry as "Conflicted", and start tracking
         the backup files in the entry as well. */</comment>
      <expr_stmt><expr><name><name>tmp_entry</name>.<name>conflict_old</name></name> = <name>left_base</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>tmp_entry</name>.<name>conflict_new</name></name> = <name>right_base</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_entry_modify</name>
              <argument_list>(<argument><expr><name>log_accum</name></expr></argument>,
               <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>merge_target</name></expr></argument>,
               <argument><expr>&amp;<name>tmp_entry</name></expr></argument>,
               <argument><expr><name>SVN_WC__ENTRY_MODIFY_CONFLICT_OLD</name>
               | <name>SVN_WC__ENTRY_MODIFY_CONFLICT_NEW</name>
               | <name>SVN_WC__ENTRY_MODIFY_CONFLICT_WRK</name></expr></argument>,
               <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr>*<name>merge_outcome</name> = <name>svn_wc_merge_conflict</name></expr>;</expr_stmt> <comment type="block">/* a conflict happened */</comment>

    }</block></then> <comment type="block">/* end of binary conflict handling */</comment>
  <else>else
    <expr_stmt><expr>*<name>merge_outcome</name> = <name>svn_wc_merge_conflict</name></expr>;</expr_stmt></else></if></else></if> <comment type="block">/* dry_run for binary files. */</comment>

  <label><name>merge_complete</name>:</label>
  <comment type="block">/* Merging is complete.  Regardless of text or binariness, we might
     need to tweak the executable bit on the new working file.  */</comment>
  <if>if <condition>(<expr>! <name>dry_run</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_maybe_set_executable</name><argument_list>(<argument><expr><name>log_accum</name></expr></argument>,
                                                 <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>merge_target</name></expr></argument>,
                                                 <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_maybe_set_readonly</name><argument_list>(<argument><expr><name>log_accum</name></expr></argument>,
                                                <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>merge_target</name></expr></argument>,
                                                <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    }</block></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></decl></decl_stmt>

<escape char="0xc"/>

<decl_stmt><decl><type><name>svn_error_t</name> *</type>
<name>svn_wc_merge3</name><argument_list>(<argument>enum <expr><name>svn_wc_merge_outcome_t</name> *<name>merge_outcome</name></expr></argument>,
              <argument><expr>const <name>char</name> *<name>left</name></expr></argument>,
              <argument><expr>const <name>char</name> *<name>right</name></expr></argument>,
              <argument><expr>const <name>char</name> *<name>merge_target</name></expr></argument>,
              <argument><expr><name>svn_wc_adm_access_t</name> *<name>adm_access</name></expr></argument>,
              <argument><expr>const <name>char</name> *<name>left_label</name></expr></argument>,
              <argument><expr>const <name>char</name> *<name>right_label</name></expr></argument>,
              <argument><expr>const <name>char</name> *<name>target_label</name></expr></argument>,
              <argument><expr><name>svn_boolean_t</name> <name>dry_run</name></expr></argument>,
              <argument><expr>const <name>char</name> *<name>diff3_cmd</name></expr></argument>,
              <argument><expr>const <name>apr_array_header_t</name> *<name>merge_options</name></expr></argument>,
              <argument><expr>const <name>apr_array_header_t</name> *<name>prop_diff</name></expr></argument>,
              <argument><expr><name>svn_wc_conflict_resolver_func_t</name> <name>conflict_func</name></expr></argument>,
              <argument><expr><name>void</name> *<name>conflict_baton</name></expr></argument>,
              <argument><expr><name>apr_pool_t</name> *<name>pool</name></expr></argument>)</argument_list>
<block>{
  <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>log_accum</name> <init>= <expr><call><name>svn_stringbuf_create</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__merge_internal</name><argument_list>(<argument><expr>&amp;<name>log_accum</name></expr></argument>, <argument><expr><name>merge_outcome</name></expr></argument>,
                                 <argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>, <argument><expr><name>merge_target</name></expr></argument>,
                                 <argument><expr><name>NULL</name></expr></argument>,
                                 <argument><expr><name>adm_access</name></expr></argument>,
                                 <argument><expr><name>left_label</name></expr></argument>, <argument><expr><name>right_label</name></expr></argument>, <argument><expr><name>target_label</name></expr></argument>,
                                 <argument><expr><name>dry_run</name></expr></argument>,
                                 <argument><expr><name>diff3_cmd</name></expr></argument>,
                                 <argument><expr><name>merge_options</name></expr></argument>,
                                 <argument><expr><name>prop_diff</name></expr></argument>,
                                 <argument><expr><name>conflict_func</name></expr></argument>, <argument><expr><name>conflict_baton</name></expr></argument>,
                                 <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Write our accumulation of log entries into a log file */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__write_log</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>log_accum</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__run_log</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></decl></decl_stmt>


<decl_stmt><decl><type><name>svn_error_t</name> *</type>
<name>svn_wc_merge2</name><argument_list>(<argument>enum <expr><name>svn_wc_merge_outcome_t</name> *<name>merge_outcome</name></expr></argument>,
              <argument><expr>const <name>char</name> *<name>left</name></expr></argument>,
              <argument><expr>const <name>char</name> *<name>right</name></expr></argument>,
              <argument><expr>const <name>char</name> *<name>merge_target</name></expr></argument>,
              <argument><expr><name>svn_wc_adm_access_t</name> *<name>adm_access</name></expr></argument>,
              <argument><expr>const <name>char</name> *<name>left_label</name></expr></argument>,
              <argument><expr>const <name>char</name> *<name>right_label</name></expr></argument>,
              <argument><expr>const <name>char</name> *<name>target_label</name></expr></argument>,
              <argument><expr><name>svn_boolean_t</name> <name>dry_run</name></expr></argument>,
              <argument><expr>const <name>char</name> *<name>diff3_cmd</name></expr></argument>,
              <argument><expr>const <name>apr_array_header_t</name> *<name>merge_options</name></expr></argument>,
              <argument><expr><name>apr_pool_t</name> *<name>pool</name></expr></argument>)</argument_list>
<block>{
  <return>return <expr><call><name>svn_wc_merge3</name><argument_list>(<argument><expr><name>merge_outcome</name></expr></argument>,
                       <argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>, <argument><expr><name>merge_target</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                       <argument><expr><name>left_label</name></expr></argument>, <argument><expr><name>right_label</name></expr></argument>, <argument><expr><name>target_label</name></expr></argument>,
                       <argument><expr><name>dry_run</name></expr></argument>, <argument><expr><name>diff3_cmd</name></expr></argument>, <argument><expr><name>merge_options</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                       <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></decl></decl_stmt>

<decl_stmt><decl><type><name>svn_error_t</name> *</type>
<name>svn_wc_merge</name><argument_list>(<argument><expr>const <name>char</name> *<name>left</name></expr></argument>,
             <argument><expr>const <name>char</name> *<name>right</name></expr></argument>,
             <argument><expr>const <name>char</name> *<name>merge_target</name></expr></argument>,
             <argument><expr><name>svn_wc_adm_access_t</name> *<name>adm_access</name></expr></argument>,
             <argument><expr>const <name>char</name> *<name>left_label</name></expr></argument>,
             <argument><expr>const <name>char</name> *<name>right_label</name></expr></argument>,
             <argument><expr>const <name>char</name> *<name>target_label</name></expr></argument>,
             <argument><expr><name>svn_boolean_t</name> <name>dry_run</name></expr></argument>,
             <argument>enum <expr><name>svn_wc_merge_outcome_t</name> *<name>merge_outcome</name></expr></argument>,
             <argument><expr>const <name>char</name> *<name>diff3_cmd</name></expr></argument>,
             <argument><expr><name>apr_pool_t</name> *<name>pool</name></expr></argument>)</argument_list>
<block>{
  <return>return <expr><call><name>svn_wc_merge3</name><argument_list>(<argument><expr><name>merge_outcome</name></expr></argument>,
                       <argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>, <argument><expr><name>merge_target</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                       <argument><expr><name>left_label</name></expr></argument>, <argument><expr><name>right_label</name></expr></argument>, <argument><expr><name>target_label</name></expr></argument>,
                       <argument><expr><name>dry_run</name></expr></argument>, <argument><expr><name>diff3_cmd</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                       <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></decl></decl_stmt>



<comment type="block">/* Constructor for the result-structure returned by conflict callbacks. */</comment>
<function><type><name>svn_wc_conflict_result_t</name> *</type>
<name>svn_wc_create_conflict_result</name><parameter_list>(<param><decl><type><name>svn_wc_conflict_choice_t</name></type> <name>choice</name></decl></param>,
                              <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>merged_file</name></decl></param>,
                              <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_wc_conflict_result_t</name> *</type><name>result</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>result</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>result</name>-&gt;<name>choice</name></name> = <name>choice</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>result</name>-&gt;<name>merged_file</name></name> = <name>merged_file</name></expr>;</expr_stmt>

  <comment type="block">/* If we add more fields to svn_wc_conflict_result_t, add them here. */</comment>

  <return>return <expr><name>result</name></expr>;</return>
}</block></function>
</unit>
