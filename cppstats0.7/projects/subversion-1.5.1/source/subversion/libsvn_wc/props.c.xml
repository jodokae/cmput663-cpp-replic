<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/subversion-1.5.1/source/subversion/libsvn_wc/props.c"><comment type="block">/*
 * props.c :  routines dealing with properties in the working copy
 *
 * ====================================================================
 * Copyright (c) 2000-2007 CollabNet.  All rights reserved.
 *
 * This software is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at http://subversion.tigris.org/license-1.html.
 * If newer versions of this license are posted there, you may use a
 * newer version instead, at your option.
 *
 * This software consists of voluntary contributions made by many
 * individuals.  For exact contribution history, see the revision
 * history and logs, available at http://subversion.tigris.org/.
 * ====================================================================
 */</comment>


<escape char="0xc"/>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_pools.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_hash.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_tables.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_file_io.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_strings.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_general.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_types.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_string.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_pools.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_path.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_xml.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_error.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_props.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_io.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_mergeinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_wc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_utf.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_diff.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"private/svn_wc_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"private/svn_mergeinfo_private.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"wc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"log.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"adm_files.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"entries.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"props.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"translate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"questions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lock.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_private_config.h"</cpp:file></cpp:include>

<comment type="block">/*---------------------------------------------------------------------*/</comment>
<escape char="0xc"/>
<comment type="block">/*** Deducing local changes to properties ***/</comment>

<comment type="block">/*---------------------------------------------------------------------*/</comment>
<escape char="0xc"/>
<comment type="block">/*** Reading/writing property hashes from disk ***/</comment>

<comment type="block">/* The real functionality here is part of libsvn_subr, in hashdump.c.
   But these are convenience routines for use in libsvn_wc. */</comment>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>get_prop_path</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>ppath</name></decl></param>,
          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
          <param><decl><type><name>svn_wc__props_kind_t</name></type> <name>props_kind</name></decl></param>,
          <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
          <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>entry</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__entry_versioned</name><argument_list>(<argument><expr>&amp;<name>entry</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__prop_path</name><argument_list>(<argument><expr><name>ppath</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>entry</name>-&gt;<name>kind</name></name></expr></argument>,
                            <argument><expr><name>props_kind</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* If PROPFILE_PATH exists (and is a file), assume it's full of
   properties and load this file into HASH.  Otherwise, leave HASH
   untouched.  */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>load_prop_file</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>propfile_path</name></decl></param>,
               <param><decl><type><name>apr_hash_t</name> *</type><name>hash</name></decl></param>,
               <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>propfile</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>err</name> = <call><name>svn_io_file_open</name><argument_list>(<argument><expr>&amp;<name>propfile</name></expr></argument>, <argument><expr><name>propfile_path</name></expr></argument>,
                         <argument><expr><name>APR_READ</name> | <name>APR_BUFFERED</name></expr></argument>, <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>,
                         <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>err</name> &amp;&amp; (<call><name>APR_STATUS_IS_ENOENT</name><argument_list>(<argument><expr><name><name>err</name>-&gt;<name>apr_err</name></name></expr></argument>)</argument_list></call>
              || <call><name>APR_STATUS_IS_ENOTDIR</name><argument_list>(<argument><expr><name><name>err</name>-&gt;<name>apr_err</name></name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR_W</name><argument_list>(<argument><expr><call><name>svn_hash_read</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>propfile</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't parse '%s'"</expr></argument>)</argument_list></call></expr></argument>,
                         <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>propfile_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_close</name><argument_list>(<argument><expr><name>propfile</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>



<comment type="block">/* Given a HASH full of property name/values, write them to a file
   located at PROPFILE_PATH.  If WRITE_EMPTY is TRUE then writing
   an emtpy property hash will result in an actual empty property
   file on disk, otherwise an empty hash will result in no file
   being written at all. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>save_prop_file</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>propfile_path</name></decl></param>,
               <param><decl><type><name>apr_hash_t</name> *</type><name>hash</name></decl></param>,
               <param><decl><type><name>svn_boolean_t</name></type> <name>write_empty</name></decl></param>,
               <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>prop_tmp</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_open</name><argument_list>(<argument><expr>&amp;<name>prop_tmp</name></expr></argument>, <argument><expr><name>propfile_path</name></expr></argument>,
                           <argument><expr>(<name>APR_WRITE</name> | <name>APR_CREATE</name> | <name>APR_TRUNCATE</name>
                            | <name>APR_BUFFERED</name>)</expr></argument>,
                           <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><call><name>apr_hash_count</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call> != 0 || <name>write_empty</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR_W</name><argument_list>(<argument><expr><call><name>svn_hash_write</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>prop_tmp</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
              <argument><expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>,
                           <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't write property hash to '%s'"</expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>propfile_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_close</name><argument_list>(<argument><expr><name>prop_tmp</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/*---------------------------------------------------------------------*/</comment>
<escape char="0xc"/>
<comment type="block">/*** Misc ***/</comment>

<comment type="block">/* Opens reject temporary file for FULL_PATH. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>open_reject_tmp_file</name><parameter_list>(<param><decl><type><name>apr_file_t</name> **</type><name>fp</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>reject_tmp_path</name></decl></param>,
                     <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>full_path</name></decl></param>,
                     <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                     <param><decl><type><name>svn_boolean_t</name></type> <name>is_dir</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>tmp_path</name></decl>;</decl_stmt>

  <comment type="block">/* Get path to /temporary/ local prop file */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__prop_path</name><argument_list>(<argument><expr>&amp;<name>tmp_path</name></expr></argument>, <argument><expr><name>full_path</name></expr></argument>,
                            <argument><expr><name>is_dir</name> ? <name>svn_node_dir</name> : <name>svn_node_file</name></expr></argument>,
                            <argument><expr><name>svn_wc__props_working</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Reserve a .prej file based on it.  */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_open_unique_file2</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>reject_tmp_path</name></expr></argument>, <argument><expr><name>tmp_path</name></expr></argument>,
                                   <argument><expr><name>SVN_WC__PROP_REJ_EXT</name></expr></argument>,
                                   <argument><expr><name>svn_io_file_del_none</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Assuming FP is a filehandle already open for appending, write
   CONFLICT_DESCRIPTION to file, plus a trailing EOL sequence. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>append_prop_conflict</name><parameter_list>(<param><decl><type><name>apr_file_t</name> *</type><name>fp</name></decl></param>,
                     <param><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>conflict_description</name></decl></param>,
                     <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* TODO:  someday, perhaps prefix each conflict_description with a
     timestamp or something? */</comment>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>written</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>native_text</name> <init>=
    <expr><call><name>svn_utf_cstring_from_utf8_fuzzy</name><argument_list>(<argument><expr><name><name>conflict_description</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_write_full</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>native_text</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>native_text</name></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr>&amp;<name>written</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>native_text</name> = <call><name>svn_utf_cstring_from_utf8_fuzzy</name><argument_list>(<argument><expr><name>APR_EOL_STR</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_write_full</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>native_text</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>native_text</name></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr>&amp;<name>written</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Look up the entry NAME within ADM_ACCESS and see if it has a `current'
   reject file describing a state of conflict.  Set *REJECT_FILE to the
   name of that file, or to NULL if no such file exists. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>get_existing_prop_reject_file</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>reject_file</name></decl></param>,
                              <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                              <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                              <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>entry</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__entry_versioned</name><argument_list>(<argument><expr>&amp;<name>entry</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>reject_file</name> = <name><name>entry</name>-&gt;<name>prejfile</name></name>
    ? <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><call><name>svn_wc_adm_access_path</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>)</argument_list></call></expr></argument>, 
                  <argument><expr><name><name>entry</name>-&gt;<name>prejfile</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call>
    : <name>NULL</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/*---------------------------------------------------------------------*/</comment>
<escape char="0xc"/>

<comment type="block">/* Build a space separated list of properties that are contained in
   the hash PROPS and which we want to cache.
   The string is allocated in POOL. */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type>
<name>build_present_props</name><parameter_list>(<param><decl><type><name>apr_hash_t</name> *</type><name>props</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>cachable</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>present_props</name> <init>= <expr><call><name>svn_stringbuf_create</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><call><name>apr_hash_count</name><argument_list>(<argument><expr><name>props</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
    <return>return <expr><name><name>present_props</name>-&gt;<name>data</name></name></expr>;</return></then></if>

  <expr_stmt><expr><name>cachable</name> = <call><name>svn_cstring_split</name><argument_list>(<argument><expr><name>SVN_WC__CACHABLE_PROPS</name></expr></argument>, <argument><expr>" "</expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>cachable</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>proptolookfor</name> <init>= <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>cachable</name></expr></argument>, <argument><expr><name>i</name></expr></argument>,
                                                <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <if>if <condition>(<expr><call><name>apr_hash_get</name><argument_list>(<argument><expr><name>props</name></expr></argument>, <argument><expr><name>proptolookfor</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call> != <name>NULL</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>svn_stringbuf_appendcstr</name><argument_list>(<argument><expr><name>present_props</name></expr></argument>, <argument><expr><name>proptolookfor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>svn_stringbuf_appendcstr</name><argument_list>(<argument><expr><name>present_props</name></expr></argument>, <argument><expr>" "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></for>

  <comment type="block">/* Avoid returning a string with a trailing space. */</comment>
  <expr_stmt><expr><call><name>svn_stringbuf_chop</name><argument_list>(<argument><expr><name>present_props</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name><name>present_props</name>-&gt;<name>data</name></name></expr>;</return>
}</block></function>

<comment type="block">/*** Loading regular properties. ***/</comment>
<function><type><name>svn_error_t</name> *</type>
<name>svn_wc__load_props</name><parameter_list>(<param><decl><type><name>apr_hash_t</name> **</type><name>base_props_p</name></decl></param>,
                   <param><decl><type><name>apr_hash_t</name> **</type><name>props_p</name></decl></param>,
                   <param><decl><type><name>apr_hash_t</name> **</type><name>revert_props_p</name></decl></param>,
                   <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>has_propcaching</name> <init>=
    <expr><call><name>svn_wc__adm_wc_format</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>)</argument_list></call> &gt; <name>SVN_WC__NO_PROPCACHING_VERSION</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>entry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>base_props</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt> <comment type="block">/* Silence uninitialized warning. */</comment>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_entry</name><argument_list>(<argument><expr>&amp;<name>entry</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* If there is no entry, we just return empty hashes, since the
     property merging can use this function when there is no entry. */</comment>
  <if>if <condition>(<expr>! <name>entry</name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr><name>base_props_p</name></expr>)</condition><then>
        <expr_stmt><expr>*<name>base_props_p</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
      <if>if <condition>(<expr><name>props_p</name></expr>)</condition><then>
        <expr_stmt><expr>*<name>props_p</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
      <if>if <condition>(<expr><name>revert_props_p</name></expr>)</condition><then>
        <expr_stmt><expr>*<name>revert_props_p</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>

  <expr_stmt><expr><name>kind</name> = <name><name>entry</name>-&gt;<name>kind</name></name></expr>;</expr_stmt>
  <comment type="block">/* We will need the base props if the user requested them, OR,
     our WC has prop caching, the user requested working props and there are no
     prop mods. */</comment>
  <if>if <condition>(<expr><name>base_props_p</name>
      || (<name>has_propcaching</name> &amp;&amp; ! <name><name>entry</name>-&gt;<name>has_prop_mods</name></name> &amp;&amp; <name><name>entry</name>-&gt;<name>has_props</name></name>)</expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>prop_base_path</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__prop_path</name><argument_list>(<argument><expr>&amp;<name>prop_base_path</name></expr></argument>,
                                <argument><expr><name>path</name></expr></argument>, <argument><expr><name>kind</name></expr></argument>, <argument><expr><name>svn_wc__props_base</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>base_props</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>load_prop_file</name><argument_list>(<argument><expr><name>prop_base_path</name></expr></argument>, <argument><expr><name>base_props</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr><name>base_props_p</name></expr>)</condition><then>
        <expr_stmt><expr>*<name>base_props_p</name> = <name>base_props</name></expr>;</expr_stmt></then></if>
    }</block></then></if>

  <if>if <condition>(<expr><name>props_p</name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr><name>has_propcaching</name> &amp;&amp; ! <name><name>entry</name>-&gt;<name>has_prop_mods</name></name> &amp;&amp; <name><name>entry</name>-&gt;<name>has_props</name></name></expr>)</condition><then>
        <expr_stmt><expr>*<name>props_p</name> = <call><name>apr_hash_copy</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>base_props</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
      <else>else <if>if <condition>(<expr>! <name>has_propcaching</name> || <name><name>entry</name>-&gt;<name>has_props</name></name></expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>prop_path</name></decl>;</decl_stmt>

          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__prop_path</name><argument_list>(<argument><expr>&amp;<name>prop_path</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>kind</name></expr></argument>,
                                    <argument><expr><name>svn_wc__props_working</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr>*<name>props_p</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>load_prop_file</name><argument_list>(<argument><expr><name>prop_path</name></expr></argument>, <argument><expr>*<name>props_p</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
      <else>else
        <expr_stmt><expr>*<name>props_p</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if>
    }</block></then></if>

  <if>if <condition>(<expr><name>revert_props_p</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr>*<name>revert_props_p</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr><name><name>entry</name>-&gt;<name>schedule</name></name> == <name>svn_wc_schedule_replace</name>
          &amp;&amp; <name><name>entry</name>-&gt;<name>copied</name></name></expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>revert_prop_path</name></decl>;</decl_stmt>

          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__prop_path</name><argument_list>(<argument><expr>&amp;<name>revert_prop_path</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>kind</name></expr></argument>,
                                    <argument><expr><name>svn_wc__props_revert</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>load_prop_file</name><argument_list>(<argument><expr><name>revert_prop_path</name></expr></argument>, <argument><expr>*<name>revert_props_p</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/*---------------------------------------------------------------------*/</comment>
<escape char="0xc"/>
<comment type="block">/*** Installing new properties. ***/</comment>
<function><type><name>svn_error_t</name> *</type>
<name>svn_wc__install_props</name><parameter_list>(<param><decl><type><name>svn_stringbuf_t</name> **</type><name>log_accum</name></decl></param>,
                      <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                      <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                      <param><decl><type><name>apr_hash_t</name> *</type><name>base_props</name></decl></param>,
                      <param><decl><type><name>apr_hash_t</name> *</type><name>working_props</name></decl></param>,
                      <param><decl><type><name>svn_boolean_t</name></type> <name>write_base_props</name></decl></param>,
                      <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>working_propfile_path</name></decl>, *<decl><type ref="prev"/><name>working_prop_tmp_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>prop_diffs</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>entry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_wc_entry_t</name></type> <name>tmp_entry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>has_propcaching</name> <init>=
    <expr><call><name>svn_wc__adm_wc_format</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>)</argument_list></call> &gt; <name>SVN_WC__NO_PROPCACHING_VERSION</name></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr>! <call><name>svn_path_is_child</name><argument_list>(<argument><expr><call><name>svn_wc_adm_access_path</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <expr_stmt><expr><name>kind</name> = <name>svn_node_dir</name></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name>kind</name> = <name>svn_node_file</name></expr>;</expr_stmt></else></if>

  <comment type="block">/* Check if the props are modified. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_prop_diffs</name><argument_list>(<argument><expr>&amp;<name>prop_diffs</name></expr></argument>, <argument><expr><name>working_props</name></expr></argument>, <argument><expr><name>base_props</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>tmp_entry</name>.<name>has_prop_mods</name></name> = (<name><name>prop_diffs</name>-&gt;<name>nelts</name></name> &gt; 0)</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>tmp_entry</name>.<name>has_props</name></name> = (<call><name>apr_hash_count</name><argument_list>(<argument><expr><name>working_props</name></expr></argument>)</argument_list></call> &gt; 0)</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>tmp_entry</name>.<name>cachable_props</name></name> = <name>SVN_WC__CACHABLE_PROPS</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>tmp_entry</name>.<name>present_props</name></name> = <call><name>build_present_props</name><argument_list>(<argument><expr><name>working_props</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_entry_modify</name><argument_list>(<argument><expr><name>log_accum</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                                     <argument><expr><name>path</name></expr></argument>, <argument><expr>&amp;<name>tmp_entry</name></expr></argument>,
                                     <argument><expr><name>SVN_WC__ENTRY_MODIFY_HAS_PROPS</name>
                                     | <name>SVN_WC__ENTRY_MODIFY_HAS_PROP_MODS</name>
                                     | <name>SVN_WC__ENTRY_MODIFY_CACHABLE_PROPS</name>
                                     | <name>SVN_WC__ENTRY_MODIFY_PRESENT_PROPS</name></expr></argument>,
                                     <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>has_propcaching</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_entry</name><argument_list>(<argument><expr>&amp;<name>entry</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name>entry</name> = <name>NULL</name></expr>;</expr_stmt></else></if>

  <comment type="block">/* Write our property hashes into temporary files.  Notice that the
     paths computed are ABSOLUTE pathnames, which is what our disk
     routines require. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__prop_path</name><argument_list>(<argument><expr>&amp;<name>working_propfile_path</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
                            <argument><expr><name>kind</name></expr></argument>, <argument><expr><name>svn_wc__props_working</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name><name>tmp_entry</name>.<name>has_prop_mods</name></name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__prop_path</name><argument_list>(<argument><expr>&amp;<name>working_prop_tmp_path</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
                                <argument><expr><name>kind</name></expr></argument>, <argument><expr><name>svn_wc__props_working</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Write the working prop hash to path/.svn/tmp/props/name or
         path/.svn/tmp/dir-props */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>save_prop_file</name><argument_list>(<argument><expr><name>working_prop_tmp_path</name></expr></argument>, <argument><expr><name>working_props</name></expr></argument>,
                             <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Write log entry to move working tmp copy to real working area. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_move</name><argument_list>(<argument><expr><name>log_accum</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                 <argument><expr><name>adm_access</name></expr></argument>,
                                 <argument><expr><name>working_prop_tmp_path</name></expr></argument>,
                                 <argument><expr><name>working_propfile_path</name></expr></argument>,
                                 <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Make props read-only */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_set_readonly</name><argument_list>(<argument><expr><name>log_accum</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                                         <argument><expr><name>working_propfile_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <comment type="block">/* No property modifications, remove the file instead. */</comment>
      <if>if <condition>(<expr>! <name>has_propcaching</name> || (<name>entry</name> &amp;&amp; <name><name>entry</name>-&gt;<name>has_prop_mods</name></name>)</expr>)</condition><then>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_remove</name><argument_list>(<argument><expr><name>log_accum</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                                     <argument><expr><name>working_propfile_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></else></if>

  <comment type="block">/* Repeat the above steps for the base properties if required. */</comment>
  <if>if <condition>(<expr><name>write_base_props</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>base_propfile_path</name></decl>, *<decl><type ref="prev"/><name>base_prop_tmp_path</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__prop_path</name><argument_list>(<argument><expr>&amp;<name>base_propfile_path</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
                                <argument><expr><name>kind</name></expr></argument>, <argument><expr><name>svn_wc__props_base</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr><call><name>apr_hash_count</name><argument_list>(<argument><expr><name>base_props</name></expr></argument>)</argument_list></call> &gt; 0</expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__prop_path</name><argument_list>(<argument><expr>&amp;<name>base_prop_tmp_path</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
                                    <argument><expr><name>kind</name></expr></argument>, <argument><expr><name>svn_wc__props_base</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>save_prop_file</name><argument_list>(<argument><expr><name>base_prop_tmp_path</name></expr></argument>, <argument><expr><name>base_props</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_move</name><argument_list>(<argument><expr><name>log_accum</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                                     <argument><expr><name>base_prop_tmp_path</name></expr></argument>,
                                     <argument><expr><name>base_propfile_path</name></expr></argument>,
                                     <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_set_readonly</name><argument_list>(<argument><expr><name>log_accum</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                                             <argument><expr><name>base_propfile_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
      <else>else
        <block>{
          <if>if <condition>(<expr>! <name>has_propcaching</name> || (<name>entry</name> &amp;&amp; <name><name>entry</name>-&gt;<name>has_props</name></name>)</expr>)</condition><then>
            <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_remove</name><argument_list>(<argument><expr><name>log_accum</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                                         <argument><expr><name>base_propfile_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        }</block></else></if>
    }</block></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>



<function><type><name>svn_error_t</name> *</type>
<name>svn_wc__working_props_committed</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                                <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                                <param><decl><type><name>svn_boolean_t</name></type> <name>sync_entries</name></decl></param>,
                                <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>working</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>base</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>entry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_wc_entry_t</name></type> <name>mod_entry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_wc_adm_access_t</name> *</type><name>mod_access</name></decl>;</decl_stmt>


  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__entry_versioned</name><argument_list>(<argument><expr>&amp;<name>entry</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__prop_path</name><argument_list>(<argument><expr>&amp;<name>working</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>entry</name>-&gt;<name>kind</name></name></expr></argument>,
                            <argument><expr><name>svn_wc__props_working</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__prop_path</name><argument_list>(<argument><expr>&amp;<name>base</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>entry</name>-&gt;<name>kind</name></name></expr></argument>,
                            <argument><expr><name>svn_wc__props_base</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* svn_io_file_rename() retains a read-only bit, so there's no
     need to explicitly set it. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_rename</name><argument_list>(<argument><expr><name>working</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_adm_probe_retrieve</name><argument_list>(<argument><expr>&amp;<name>mod_access</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>mod_entry</name>.<name>has_prop_mods</name></name> = <name>FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__entry_modify</name><argument_list>(<argument><expr><name>mod_access</name></expr></argument>, <argument><expr><name><name>entry</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr>&amp;<name>mod_entry</name></expr></argument>,
                               <argument><expr><name>SVN_WC__ENTRY_MODIFY_HAS_PROP_MODS</name></expr></argument>,
                               <argument><expr><name>sync_entries</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_wc__props_last_modified</name><parameter_list>(<param><decl><type><name>apr_time_t</name> *</type><name>mod_time</name></decl></param>,
                            <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                            <param><decl><type><name>svn_wc__props_kind_t</name></type> <name>props_kind</name></decl></param>,
                            <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                            <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>props_file</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_prop_path</name><argument_list>(<argument><expr>&amp;<name>props_file</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>props_kind</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>err</name> = <call><name>svn_io_file_affected_time</name><argument_list>(<argument><expr><name>mod_time</name></expr></argument>, <argument><expr><name>props_file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>err</name> &amp;&amp; <call><name>APR_STATUS_IS_ENOENT</name><argument_list>(<argument><expr><name><name>err</name>-&gt;<name>apr_err</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>mod_time</name> = 0</expr>;</expr_stmt>
    }</block></then>
  <else>else
    <expr_stmt><expr><call><name>SVN_ERR_W</name><argument_list>(<argument><expr><name>err</name></expr></argument>,
              <argument><expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>,
                           <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Error getting 'affected time' on '%s'"</expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>props_file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>remove_file_if_present</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>file</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>

  <comment type="block">/* Try to remove the file. */</comment>
  <expr_stmt><expr><name>err</name> = <call><name>svn_io_remove_file</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Ignore file not found error. */</comment>
  <if>if <condition>(<expr><name>err</name> &amp;&amp; <call><name>APR_STATUS_IS_ENOENT</name><argument_list>(<argument><expr><name><name>err</name>-&gt;<name>apr_err</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>err</name> = <name>SVN_NO_ERROR</name></expr>;</expr_stmt>
    }</block></then></if>

  <return>return <expr><name>err</name></expr>;</return>
}</block></function>


<comment type="block">/* If wcprops are stored in a single file in this working copy, read that file
   and store it in the cache of ADM_ACCESS.   Use POOL for temporary
   allocations. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>read_wcprops</name><parameter_list>(<param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>file</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>cache_pool</name> <init>= <expr><call><name>svn_wc_adm_access_pool</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>all_wcprops</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>proplist</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>stream</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>

  <comment type="block">/* If the WC format is too old, there is nothing to cache. */</comment>
  <if>if <condition>(<expr><call><name>svn_wc__adm_wc_format</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>)</argument_list></call> &lt;= <name>SVN_WC__WCPROPS_MANY_FILES_VERSION</name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <expr_stmt><expr><name>all_wcprops</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>cache_pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>err</name> = <call><name>svn_wc__open_adm_file</name><argument_list>(<argument><expr>&amp;<name>file</name></expr></argument>, <argument><expr><call><name>svn_wc_adm_access_path</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><name>SVN_WC__ADM_ALL_WCPROPS</name></expr></argument>,
                              <argument><expr><name>APR_READ</name> | <name>APR_BUFFERED</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* A non-existent file means there are no props. */</comment>
  <if>if <condition>(<expr><name>err</name> &amp;&amp; <call><name>APR_STATUS_IS_ENOENT</name><argument_list>(<argument><expr><name><name>err</name>-&gt;<name>apr_err</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>svn_wc__adm_access_set_wcprops</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>all_wcprops</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>stream</name> = <call><name>svn_stream_from_aprfile2</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Read the proplist for THIS_DIR. */</comment>
  <expr_stmt><expr><name>proplist</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>cache_pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_hash_read2</name><argument_list>(<argument><expr><name>proplist</name></expr></argument>, <argument><expr><name>stream</name></expr></argument>, <argument><expr><name>SVN_HASH_TERMINATOR</name></expr></argument>, <argument><expr><name>cache_pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>all_wcprops</name></expr></argument>, <argument><expr><name>SVN_WC_ENTRY_THIS_DIR</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>,
               <argument><expr><name>proplist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* And now, the children. */</comment>
  <while>while <condition>(<expr>1729</expr>)</condition>
    <block>{
      <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>line</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>eof</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_readline</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr>&amp;<name>line</name></expr></argument>, <argument><expr>"\n"</expr></argument>, <argument><expr>&amp;<name>eof</name></expr></argument>, <argument><expr><name>cache_pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>eof</name></expr>)</condition><then>
        <block>{
          <if>if <condition>(<expr><name><name>line</name>-&gt;<name>len</name></name> &gt; 0</expr>)</condition><then>
            <return>return <expr><call><name>svn_error_createf</name>
              <argument_list>(<argument><expr><name>SVN_ERR_WC_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
               <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Missing end of line in wcprops file for '%s'"</expr></argument>)</argument_list></call></expr></argument>,
               <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><call><name>svn_wc_adm_access_path</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
          <break>break;</break>
        }</block></then></if>
      <expr_stmt><expr><name>proplist</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>cache_pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_hash_read2</name><argument_list>(<argument><expr><name>proplist</name></expr></argument>, <argument><expr><name>stream</name></expr></argument>, <argument><expr><name>SVN_HASH_TERMINATOR</name></expr></argument>,
                             <argument><expr><name>cache_pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>all_wcprops</name></expr></argument>, <argument><expr><name><name>line</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>proplist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></while>

  <expr_stmt><expr><call><name>svn_wc__adm_access_set_wcprops</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>all_wcprops</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__close_adm_file</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><call><name>svn_wc_adm_access_path</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><name>SVN_WC__ADM_ALL_WCPROPS</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>write_wcprops</name><parameter_list>(<param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>wcprops</name> <init>= <expr><call><name>svn_wc__adm_access_wcprops</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>file</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>stream</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>proplist</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>any_props</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* If there are no cached wcprops, there is nothing to do. */</comment>
  <if>if <condition>(<expr>! <name>wcprops</name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <comment type="block">/* Check if there are any properties at all. */</comment>
  <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>wcprops</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>hi</name> &amp;&amp; ! <name>any_props</name></expr>;</condition>
       <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
    <block>{
      <decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>proplist</name> = <name>val</name></expr>;</expr_stmt>
      <if>if <condition>(<expr><call><name>apr_hash_count</name><argument_list>(<argument><expr><name>proplist</name></expr></argument>)</argument_list></call> &gt; 0</expr>)</condition><then>
        <expr_stmt><expr><name>any_props</name> = <name>TRUE</name></expr>;</expr_stmt></then></if>
    }</block></for>

  <comment type="block">/* If there are no props, remove the file. */</comment>
  <if>if <condition>(<expr>! <name>any_props</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>

      <expr_stmt><expr><name>err</name> = <call><name>svn_wc__remove_adm_file</name><argument_list>(<argument><expr><call><name>svn_wc_adm_access_path</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>,
                                    <argument><expr><name>SVN_WC__ADM_ALL_WCPROPS</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>err</name> &amp;&amp; <call><name>APR_STATUS_IS_ENOENT</name><argument_list>(<argument><expr><name><name>err</name>-&gt;<name>apr_err</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
        }</block></then>
      <else>else
        <return>return <expr><name>err</name></expr>;</return></else></if>
    }</block></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__open_adm_file</name><argument_list>(<argument><expr>&amp;<name>file</name></expr></argument>, <argument><expr><call><name>svn_wc_adm_access_path</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><name>SVN_WC__ADM_ALL_WCPROPS</name></expr></argument>,
                                <argument><expr><name>APR_WRITE</name> | <name>APR_BUFFERED</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>stream</name> = <call><name>svn_stream_from_aprfile2</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* First, the props for this_dir. */</comment>
  <expr_stmt><expr><name>proplist</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>wcprops</name></expr></argument>, <argument><expr><name>SVN_WC_ENTRY_THIS_DIR</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>! <name>proplist</name></expr>)</condition><then>
    <expr_stmt><expr><name>proplist</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_hash_write2</name><argument_list>(<argument><expr><name>proplist</name></expr></argument>, <argument><expr><name>stream</name></expr></argument>, <argument><expr><name>SVN_HASH_TERMINATOR</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Write children. */</comment>
  <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>wcprops</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>hi</name></expr>;</condition> <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>name</name> = <name>key</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>proplist</name> = <name>val</name></expr>;</expr_stmt>

      <comment type="block">/* We already wrote this_dir, and writing empty hashes makes me
         feel silly... */</comment>
      <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>SVN_WC_ENTRY_THIS_DIR</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> == 0
          || <call><name>apr_hash_count</name><argument_list>(<argument><expr><name>proplist</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
        <continue>continue;</continue></then></if>

      <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_printf</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>, <argument><expr>"%s\n"</expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_hash_write2</name><argument_list>(<argument><expr><name>proplist</name></expr></argument>, <argument><expr><name>stream</name></expr></argument>, <argument><expr><name>SVN_HASH_TERMINATOR</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__close_adm_file</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><call><name>svn_wc_adm_access_path</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><name>SVN_WC__ADM_ALL_WCPROPS</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_wc__props_flush</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                    <param><decl><type><name>svn_wc__props_kind_t</name></type> <name>props_kind</name></decl></param>,
                    <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>props_kind</name> != <name>svn_wc__props_wcprop</name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then>
  <else>else
    <block>{
      <decl_stmt><decl><type><name>svn_wc_adm_access_t</name> *</type><name>prop_access</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_adm_probe_retrieve</name><argument_list>(<argument><expr>&amp;<name>prop_access</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                                        <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt><empty_stmt>;</empty_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>write_wcprops</name><argument_list>(<argument><expr><name>prop_access</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>remove_wcprops</name><parameter_list>(<param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                       <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>,
                       <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>all_wcprops</name> <init>= <expr><call><name>svn_wc__adm_access_wcprops</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>write_needed</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr>! <name>name</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* There is no point in reading the props just to determine if we
         need to rewrite them:-), so assume a write is needed if the props
         aren't already cached. */</comment>
      <if>if <condition>(<expr>! <name>all_wcprops</name> || <call><name>apr_hash_count</name><argument_list>(<argument><expr><name>all_wcprops</name></expr></argument>)</argument_list></call> &gt; 0</expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>svn_wc__adm_access_set_wcprops</name>
            <argument_list>(<argument><expr><name>adm_access</name></expr></argument>, <argument><expr><call><name>apr_hash_make</name><argument_list>(<argument><expr><call><name>svn_wc_adm_access_pool</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>write_needed</name> = <name>TRUE</name></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then>
  <else>else
    <block>{
      <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>wcprops</name></decl>;</decl_stmt>
      <if>if <condition>(<expr>! <name>all_wcprops</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>read_wcprops</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>all_wcprops</name> = <call><name>svn_wc__adm_access_wcprops</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
      <if>if <condition>(<expr><name>all_wcprops</name></expr>)</condition><then>
        <expr_stmt><expr><name>wcprops</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>all_wcprops</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
      <else>else
        <expr_stmt><expr><name>wcprops</name> = <name>NULL</name></expr>;</expr_stmt></else></if>
      <if>if <condition>(<expr><name>wcprops</name> &amp;&amp; <call><name>apr_hash_count</name><argument_list>(<argument><expr><name>wcprops</name></expr></argument>)</argument_list></call> &gt; 0</expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>all_wcprops</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>write_needed</name> = <name>TRUE</name></expr>;</expr_stmt>
        }</block></then></if>
    }</block></else></if>
  <if>if <condition>(<expr><name>write_needed</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>write_wcprops</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_wc__loggy_props_delete</name><parameter_list>(<param><decl><type><name>svn_stringbuf_t</name> **</type><name>log_accum</name></decl></param>,
                           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                           <param><decl><type><name>svn_wc__props_kind_t</name></type> <name>props_kind</name></decl></param>,
                           <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                           <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>props_file</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>props_kind</name> == <name>svn_wc__props_wcprop</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* We use 1 file for all wcprops in a directory,
         use a helper to remove them from that file */</comment>
      <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>props</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>iterpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__wcprop_list</name><argument_list>(<argument><expr>&amp;<name>props</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* ### TODO: There's no log command to delete all wcprops
         from a file at once. Removing all props should do it though. */</comment>

      <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>props</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>hi</name></expr>;</condition> <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
        <block>{
          <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl>;</decl_stmt>

          <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>name</name> = <name>key</name></expr>;</expr_stmt>

          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_modify_wcprop</name><argument_list>(<argument><expr><name>log_accum</name></expr></argument>,
                                              <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
                                              <argument><expr><name>name</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>

      <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_prop_path</name><argument_list>(<argument><expr>&amp;<name>props_file</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>props_kind</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_remove</name><argument_list>(<argument><expr><name>log_accum</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>props_file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_wc__props_delete</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                     <param><decl><type><name>svn_wc__props_kind_t</name></type> <name>props_kind</name></decl></param>,
                     <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                     <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>props_file</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>props_kind</name> == <name>svn_wc__props_wcprop</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* We use 1 file for all wcprops in a directory,
         use a helper to remove them from that file */</comment>

      <decl_stmt><decl><type><name>svn_wc_adm_access_t</name> *</type><name>path_access</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_adm_probe_retrieve</name><argument_list>(<argument><expr>&amp;<name>path_access</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                                        <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>remove_wcprops</name>
              <argument_list>(<argument><expr><name>path_access</name></expr></argument>,
               <argument><expr><call><name>svn_path_is_child</name><argument_list>(<argument><expr><call><name>svn_wc_adm_access_path</name><argument_list>(<argument><expr><name>path_access</name></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><name>path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_prop_path</name><argument_list>(<argument><expr>&amp;<name>props_file</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>props_kind</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>remove_file_if_present</name><argument_list>(<argument><expr><name>props_file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_wc__loggy_revert_props_create</name><parameter_list>(<param><decl><type><name>svn_stringbuf_t</name> **</type><name>log_accum</name></decl></param>,
                                  <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                                  <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                                  <param><decl><type><name>svn_boolean_t</name></type> <name>destroy_baseprops</name></decl></param>,
                                  <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>entry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dst_rprop</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dst_bprop</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>tmp_rprop</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__entry_versioned</name><argument_list>(<argument><expr>&amp;<name>entry</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__prop_path</name><argument_list>(<argument><expr>&amp;<name>dst_rprop</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
                            <argument><expr><name><name>entry</name>-&gt;<name>kind</name></name></expr></argument>, <argument><expr><name>svn_wc__props_revert</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__prop_path</name><argument_list>(<argument><expr>&amp;<name>tmp_rprop</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
                            <argument><expr><name><name>entry</name>-&gt;<name>kind</name></name></expr></argument>, <argument><expr><name>svn_wc__props_revert</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__prop_path</name><argument_list>(<argument><expr>&amp;<name>dst_bprop</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
                            <argument><expr><name><name>entry</name>-&gt;<name>kind</name></name></expr></argument>, <argument><expr><name>svn_wc__props_base</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If prop base exist, copy it to revert base. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_check_path</name><argument_list>(<argument><expr><name>dst_bprop</name></expr></argument>, <argument><expr>&amp;<name>kind</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>kind</name> == <name>svn_node_file</name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr><name>destroy_baseprops</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_move</name><argument_list>(<argument><expr><name>log_accum</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                   <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>dst_bprop</name></expr></argument>, <argument><expr><name>dst_rprop</name></expr></argument>,
                                   <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
      <else>else
        <block>{
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_copy_file</name><argument_list>(<argument><expr><name>dst_bprop</name></expr></argument>, <argument><expr><name>tmp_rprop</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_move</name><argument_list>(<argument><expr><name>log_accum</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                                     <argument><expr><name>tmp_rprop</name></expr></argument>, <argument><expr><name>dst_rprop</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></then>
  <else>else <if>if <condition>(<expr><name>kind</name> == <name>svn_node_none</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* If there wasn't any prop base we still need an empty revert
         propfile, otherwise a revert won't know that a change to the
         props needs to be made (it'll just see no file, and do nothing).
         So manufacture an empty propfile and force it to be written out. */</comment>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__prop_path</name><argument_list>(<argument><expr>&amp;<name>dst_bprop</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>entry</name>-&gt;<name>kind</name></name></expr></argument>,
                                <argument><expr><name>svn_wc__props_revert</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>save_prop_file</name><argument_list>(<argument><expr><name>dst_bprop</name></expr></argument>, <argument><expr><call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_move</name><argument_list>(<argument><expr><name>log_accum</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                 <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>dst_bprop</name></expr></argument>, <argument><expr><name>dst_rprop</name></expr></argument>,
                                 <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if></else></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
<comment type="block">/*### Some day, when we get better log primitives,
  we probably want to stat() less, which can be done coding
  'calls' to functions like the one below into as a log command.*/</comment>
svn_error_t *
svn_wc__revert_props_create(const char *path,
                            svn_wc_adm_access_t *adm_access,
                            svn_boolean_t destroy_baseprops,
                            svn_boolean_t maybe_rerun,
                            apr_pool_t *pool)
{
  const svn_wc_entry_t *entry;
  const char *revert_file, *base_file;
  const char *tmp_revert_file;
  svn_error_t *err;

  SVN_ERR(svn_wc__entry_versioned(&amp;entry, path, adm_access, TRUE, pool));

  SVN_ERR(svn_wc__prop_path(&amp;base_file, path, entry-&gt;kind, svn_wc__props_base,
                            FALSE, pool));
  SVN_ERR(svn_wc__prop_path(&amp;revert_file, path, entry-&gt;kind,
                            svn_wc__props_revert, FALSE, pool));
  SVN_ERR(svn_wc__prop_path(&amp;tmp_revert_file, path, entry-&gt;kind,
                            svn_wc__props_revert, TRUE, pool));


  if (destroy_baseprops)
    err = svn_io_file_rename(base_file, revert_file, pool);
  else
    {
      err  = svn_io_copy_file(base_file, tmp_revert_file, TRUE, pool);
      if (! err)
        SVN_ERR(svn_io_file_rename(tmp_revert_file, revert_file, pool));
    }

  if (err &amp;&amp; APR_STATUS_IS_ENOENT(err-&gt;apr_err))
    <comment type="block">/* If there's no file to move or copy, create one. */</comment>
    {
      svn_node_kind_t kind = svn_node_none;

      svn_error_clear(err);

      if (maybe_rerun)
        SVN_ERR(svn_io_check_path(revert_file, &amp;kind, pool));

      if (kind == svn_node_none)
        {
          SVN_ERR(save_prop_file(tmp_revert_file,
                                 apr_hash_make(pool), TRUE, pool));
          SVN_ERR(svn_io_file_rename(base_file, revert_file, pool));
        }
    }

  return SVN_NO_ERROR;
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>svn_error_t</name> *</type>
<name>svn_wc__loggy_revert_props_restore</name><parameter_list>(<param><decl><type><name>svn_stringbuf_t</name> **</type><name>log_accum</name></decl></param>,
                                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                                   <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>entry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>revert_file</name></decl>, *<decl><type ref="prev"/><name>base_file</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__entry_versioned</name><argument_list>(<argument><expr>&amp;<name>entry</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__prop_path</name><argument_list>(<argument><expr>&amp;<name>base_file</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>entry</name>-&gt;<name>kind</name></name></expr></argument>, <argument><expr><name>svn_wc__props_base</name></expr></argument>,
                            <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__prop_path</name><argument_list>(<argument><expr>&amp;<name>revert_file</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>entry</name>-&gt;<name>kind</name></name></expr></argument>,
                            <argument><expr><name>svn_wc__props_revert</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_move</name><argument_list>(<argument><expr><name>log_accum</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                             <argument><expr><name>revert_file</name></expr></argument>, <argument><expr><name>base_file</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<cpp:if>#<cpp:directive>if</cpp:directive> <expr>0</expr></cpp:if>
<comment type="block">/*### Some day, when we get better log primitives,
  we probably want to stat() less, which can be done coding
  'calls' to functions like the one below into as a log command.*/</comment>
svn_error_t *
svn_wc__revert_props_restore(const char *path,
                             svn_wc_adm_access_t *adm_access,
                             apr_pool_t *pool)
{
  const svn_wc_entry_t *entry;
  const char *revert_file, *base_file;

  SVN_ERR(svn_wc__entry_versioned(&amp;entry, path, adm_access, TRUE, pool));

  SVN_ERR(svn_wc__prop_path(&amp;base_file, path, entry-&gt;kind, svn_wc__props_base,
                            FALSE, pool));
  SVN_ERR(svn_wc__prop_path(&amp;revert_file, path, entry-&gt;kind,
                            svn_wc__props_revert, FALSE, pool));

  SVN_ERR(svn_io_file_rename(revert_file, base_file, pool));
  return SVN_NO_ERROR;
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*---------------------------------------------------------------------*/</comment>
<escape char="0xc"/>
<comment type="block">/*** Merging propchanges into the working copy ***/</comment>


<comment type="block">/* Parse FROM_PROP_VAL and TO_PROP_VAL into mergeinfo hashes, and
   calculate the deltas between them. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>diff_mergeinfo_props</name><parameter_list>(<param><decl><type><name>svn_mergeinfo_t</name> *</type><name>deleted</name></decl></param>, <param><decl><type><name>svn_mergeinfo_t</name> *</type><name>added</name></decl></param>,
                     <param><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>from_prop_val</name></decl></param>,
                     <param><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>to_prop_val</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><call><name>svn_string_compare</name><argument_list>(<argument><expr><name>from_prop_val</name></expr></argument>, <argument><expr><name>to_prop_val</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <comment type="block">/* Don't bothering parsing identical mergeinfo. */</comment>
      <expr_stmt><expr>*<name>deleted</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>added</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <decl_stmt><decl><type><name>svn_mergeinfo_t</name></type> <name>from</name></decl>, <decl><type ref="prev"/><name>to</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo_parse</name><argument_list>(<argument><expr>&amp;<name>from</name></expr></argument>, <argument><expr><name><name>from_prop_val</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo_parse</name><argument_list>(<argument><expr>&amp;<name>to</name></expr></argument>, <argument><expr><name><name>to_prop_val</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo_diff</name><argument_list>(<argument><expr><name>deleted</name></expr></argument>, <argument><expr><name>added</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>to</name></expr></argument>,
                                 <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Parse the mergeinfo from PROP_VAL1 and PROP_VAL2, combine it, then
   reconstitute it into *OUTPUT.  Call when the WC's mergeinfo has
   been modified to combine it with incoming mergeinfo from the
   repos. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>combine_mergeinfo_props</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>svn_string_t</name> **</type><name>output</name></decl></param>,
                        <param><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>prop_val1</name></decl></param>,
                        <param><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>prop_val2</name></decl></param>,
                        <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_mergeinfo_t</name></type> <name>mergeinfo1</name></decl>, <decl><type ref="prev"/><name>mergeinfo2</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo_parse</name><argument_list>(<argument><expr>&amp;<name>mergeinfo1</name></expr></argument>, <argument><expr><name><name>prop_val1</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo_parse</name><argument_list>(<argument><expr>&amp;<name>mergeinfo2</name></expr></argument>, <argument><expr><name><name>prop_val2</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo_merge</name><argument_list>(<argument><expr><name>mergeinfo1</name></expr></argument>, <argument><expr><name>mergeinfo2</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo_to_string</name><argument_list>(<argument><expr>(<name>svn_string_t</name> **)<name>output</name></expr></argument>, <argument><expr><name>mergeinfo1</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Perform a 3-way merge operation on mergeinfo.  FROM_PROP_VAL is
   the "base" property value, WORKING_PROP_VAL is the current value,
   and TO_PROP_VAL is the new value. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>combine_forked_mergeinfo_props</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>svn_string_t</name> **</type><name>output</name></decl></param>,
                               <param><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>from_prop_val</name></decl></param>,
                               <param><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>working_prop_val</name></decl></param>,
                               <param><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>to_prop_val</name></decl></param>,
                               <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_mergeinfo_t</name></type> <name>from_mergeinfo</name></decl>, <decl><type ref="prev"/><name>l_deleted</name></decl>, <decl><type ref="prev"/><name>l_added</name></decl>, <decl><type ref="prev"/><name>r_deleted</name></decl>, <decl><type ref="prev"/><name>r_added</name></decl>;</decl_stmt>

  <comment type="block">/* ### OPTIMIZE: Use from_mergeinfo when diff'ing. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>diff_mergeinfo_props</name><argument_list>(<argument><expr>&amp;<name>l_deleted</name></expr></argument>, <argument><expr>&amp;<name>l_added</name></expr></argument>, <argument><expr><name>from_prop_val</name></expr></argument>,
                               <argument><expr><name>working_prop_val</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>diff_mergeinfo_props</name><argument_list>(<argument><expr>&amp;<name>r_deleted</name></expr></argument>, <argument><expr>&amp;<name>r_added</name></expr></argument>, <argument><expr><name>from_prop_val</name></expr></argument>,
                               <argument><expr><name>to_prop_val</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo_merge</name><argument_list>(<argument><expr><name>l_deleted</name></expr></argument>, <argument><expr><name>r_deleted</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo_merge</name><argument_list>(<argument><expr><name>l_added</name></expr></argument>, <argument><expr><name>r_added</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Apply the combined deltas to the base. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo_parse</name><argument_list>(<argument><expr>&amp;<name>from_mergeinfo</name></expr></argument>, <argument><expr><name><name>from_prop_val</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo_merge</name><argument_list>(<argument><expr><name>from_mergeinfo</name></expr></argument>, <argument><expr><name>l_added</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo_remove</name><argument_list>(<argument><expr>&amp;<name>from_mergeinfo</name></expr></argument>, <argument><expr><name>l_deleted</name></expr></argument>,
                               <argument><expr><name>from_mergeinfo</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><call><name>svn_mergeinfo_to_string</name><argument_list>(<argument><expr>(<name>svn_string_t</name> **)<name>output</name></expr></argument>, <argument><expr><name>from_mergeinfo</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_wc_merge_props</name><parameter_list>(<param><decl><type><name>svn_wc_notify_state_t</name> *</type><name>state</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                   <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                   <param><decl><type><name>apr_hash_t</name> *</type><name>baseprops</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>apr_array_header_t</name> *</type><name>propchanges</name></decl></param>,
                   <param><decl><type><name>svn_boolean_t</name></type> <name>base_merge</name></decl></param>,
                   <param><decl><type><name>svn_boolean_t</name></type> <name>dry_run</name></decl></param>,
                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>svn_wc_merge_props2</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>baseprops</name></expr></argument>, <argument><expr><name>propchanges</name></expr></argument>,
                             <argument><expr><name>base_merge</name></expr></argument>, <argument><expr><name>dry_run</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_wc_merge_props2</name><parameter_list>(<param><decl><type><name>svn_wc_notify_state_t</name> *</type><name>state</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                    <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                    <param><decl><type><name>apr_hash_t</name> *</type><name>baseprops</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>apr_array_header_t</name> *</type><name>propchanges</name></decl></param>,
                    <param><decl><type><name>svn_boolean_t</name></type> <name>base_merge</name></decl></param>,
                    <param><decl><type><name>svn_boolean_t</name></type> <name>dry_run</name></decl></param>,
                    <param><decl><type><name>svn_wc_conflict_resolver_func_t</name></type> <name>conflict_func</name></decl></param>,
                    <param><decl><type><name>void</name> *</type><name>conflict_baton</name></decl></param>,
                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>entry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>log_accum</name></decl>;</decl_stmt>

  <comment type="block">/* IMPORTANT: svn_wc_merge_prop_diffs relies on the fact that baseprops
     may be NULL. */</comment>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__entry_versioned</name><argument_list>(<argument><expr>&amp;<name>entry</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Notice that we're not using svn_path_split_if_file(), because
     that looks at the actual working file.  Its existence shouldn't
     matter, so we're looking at entry-&gt;kind instead. */</comment>
  <switch>switch <condition>(<expr><name><name>entry</name>-&gt;<name>kind</name></name></expr>)</condition>
    <block>{
    <case>case <expr><name>svn_node_dir</name></expr>:
    </case><case>case <expr><name>svn_node_file</name></expr>:
      <break>break;</break>
    </case><default>default:
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return> <comment type="block">/* ### svn_node_none or svn_node_unknown */</comment>
    </default>}</block></switch>

  <if>if <condition>(<expr>! <name>dry_run</name></expr>)</condition><then>
    <expr_stmt><expr><name>log_accum</name> = <call><name>svn_stringbuf_create</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* Note that while this routine does the "real" work, it's only
     prepping tempfiles and writing log commands.  */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__merge_props</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>baseprops</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                              <argument><expr><name>propchanges</name></expr></argument>, <argument><expr><name>base_merge</name></expr></argument>, <argument><expr><name>dry_run</name></expr></argument>,
                              <argument><expr><name>conflict_func</name></expr></argument>, <argument><expr><name>conflict_baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>&amp;<name>log_accum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr>! <name>dry_run</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__write_log</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>log_accum</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__run_log</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>



<comment type="block">/* Set the value of *STATE to NEW_VALUE if STATE is not NULL
 * and NEW_VALUE is a higer order value than *STATE's current value
 * using this ordering (lower order first):
 *
 * - unknown, unchanged, inapplicable
 * - changed
 * - merged
 * - missing
 * - obstructed
 * - conflicted
 *
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_prop_merge_state</name><parameter_list>(<param><decl><type><name>svn_wc_notify_state_t</name> *</type><name>state</name></decl></param>,
                     <param><decl><type><name>svn_wc_notify_state_t</name></type> <name>new_value</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>ordering</name><index>[]</index></name> <init>=
    <expr><block>{ <expr><name>svn_wc_notify_state_unknown</name></expr>,
      <expr><name>svn_wc_notify_state_unchanged</name></expr>,
      <expr><name>svn_wc_notify_state_inapplicable</name></expr>,
      <expr><name>svn_wc_notify_state_changed</name></expr>,
      <expr><name>svn_wc_notify_state_merged</name></expr>,
      <expr><name>svn_wc_notify_state_obstructed</name></expr>,
      <expr><name>svn_wc_notify_state_conflicted</name></expr> }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>state_pos</name> <init>= <expr>0</expr></init>, <name>i</name></decl>;</decl_stmt>

  <if>if <condition>(<expr>! <name>state</name></expr>)</condition><then>
    <return>return;</return></then></if>

  <comment type="block">/* Find *STATE in our ordering */</comment>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <sizeof>sizeof<argument_list>(<argument><expr><name>ordering</name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <if>if <condition>(<expr>*<name>state</name> == <name><name>ordering</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>state_pos</name> = <name>i</name></expr>;</expr_stmt>
          <break>break;</break>
        }</block></then></if>
    }</block></for>

  <comment type="block">/* Find NEW_VALUE in our ordering
   * We don't need to look further than where we found *STATE though:
   * If we find our value, it's order is too low.
   * If we don't find it, we'll want to set it, no matter its order.
   */</comment>

  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt;= <name>state_pos</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <if>if <condition>(<expr><name>new_value</name> == <name><name>ordering</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then>
        <return>return;</return></then></if>
    }</block></for>

  <expr_stmt><expr>*<name>state</name> = <name>new_value</name></expr>;</expr_stmt>
}</block></function>



<comment type="block">/* Helper function for the three apply_* functions below, used when
 * merging properties together.
 *
 * Given property PROPNAME on PATH, and four possible property values,
 * generate four tmpfiles and pass them to CONFLICT_FUNC callback.
 * This gives the client an opportunity to interactively resolve the
 * property conflict.  (ADM_ACCESS provides the ability to examine
 * PATH's entries.)
 *
 * BASE_VAL/WORKING_VAL represent the current state of the working
 * copy, and OLD_VAL/NEW_VAL represents the incoming propchange.  Any
 * of these values might be NULL, indicating either non-existence or
 * intent-to-delete.
 *
 * If the callback isn't available, or if it responds with
 * 'choose_postpone', then set *CONFLICT_REMAINS to true and return.
 *
 * If the callback responds with a choice of 'base', 'theirs', 'mine',
 * or 'merged', then install the proper value into WORKING_PROPS and
 * set *CONFLICT_REMAINS to false.
 *
 */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>maybe_generate_propconflict</name><parameter_list>(<param><decl><type><name>svn_boolean_t</name> *</type><name>conflict_remains</name></decl></param>,
                            <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                            <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                            <param><decl><type><name>svn_boolean_t</name></type> <name>is_dir</name></decl></param>,
                            <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>propname</name></decl></param>,
                            <param><decl><type><name>apr_hash_t</name> *</type><name>working_props</name></decl></param>,
                            <param><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>old_val</name></decl></param>,
                            <param><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>new_val</name></decl></param>,
                            <param><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>base_val</name></decl></param>,
                            <param><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>working_val</name></decl></param>,
                            <param><decl><type><name>svn_wc_conflict_resolver_func_t</name></type> <name>conflict_func</name></decl></param>,
                            <param><decl><type><name>void</name> *</type><name>conflict_baton</name></decl></param>,
                            <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_wc_conflict_result_t</name> *</type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>mime_propval</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>working_file</name></decl>, *<decl><type ref="prev"/><name>base_file</name></decl>, *<decl><type ref="prev"/><name>new_file</name></decl>, *<decl><type ref="prev"/><name>merged_file</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>working_path</name></decl>, *<decl><type ref="prev"/><name>base_path</name></decl>, *<decl><type ref="prev"/><name>new_path</name></decl>, *<decl><type ref="prev"/><name>merged_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>filepool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_wc_conflict_description_t</name> *</type><name>cdesc</name></decl>;</decl_stmt>

  <if>if <condition>(<expr>! <name>conflict_func</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* Just postpone the conflict. */</comment>
      <expr_stmt><expr>*<name>conflict_remains</name> = <name>TRUE</name></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>

  <expr_stmt><expr><name>cdesc</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>cdesc</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Create a tmpfile for each of the string_t's we've got.  */</comment>
  <if>if <condition>(<expr><name>working_val</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_open_unique_file2</name><argument_list>(<argument><expr>&amp;<name>working_file</name></expr></argument>, <argument><expr>&amp;<name>working_path</name></expr></argument>,
                                       <argument><expr><name>path</name></expr></argument>, <argument><expr>".tmp"</expr></argument>,
                                       <argument><expr><name>svn_io_file_del_on_pool_cleanup</name></expr></argument>,
                                       <argument><expr><name>filepool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_write_full</name><argument_list>(<argument><expr><name>working_file</name></expr></argument>, <argument><expr><name><name>working_val</name>-&gt;<name>data</name></name></expr></argument>,
                                     <argument><expr><name><name>working_val</name>-&gt;<name>len</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>filepool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_close</name><argument_list>(<argument><expr><name>working_file</name></expr></argument>, <argument><expr><name>filepool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>cdesc</name>-&gt;<name>my_file</name></name> = <name>working_path</name></expr>;</expr_stmt>
    }</block></then></if>

  <if>if <condition>(<expr><name>new_val</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_open_unique_file2</name><argument_list>(<argument><expr>&amp;<name>new_file</name></expr></argument>, <argument><expr>&amp;<name>new_path</name></expr></argument>,
                                       <argument><expr><name>path</name></expr></argument>, <argument><expr>".tmp"</expr></argument>,
                                       <argument><expr><name>svn_io_file_del_on_pool_cleanup</name></expr></argument>,
                                       <argument><expr><name>filepool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_write_full</name><argument_list>(<argument><expr><name>new_file</name></expr></argument>, <argument><expr><name><name>new_val</name>-&gt;<name>data</name></name></expr></argument>,
                                     <argument><expr><name><name>new_val</name>-&gt;<name>len</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>filepool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_close</name><argument_list>(<argument><expr><name>new_file</name></expr></argument>, <argument><expr><name>filepool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>cdesc</name>-&gt;<name>their_file</name></name> = <name>new_path</name></expr>;</expr_stmt>
    }</block></then></if>

  <if>if <condition>(<expr>!<name>base_val</name> &amp;&amp; !<name>old_val</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* If base and old are both NULL, then that's fine, we just let
         base_file stay NULL as-is.  Both agents are attempting to add a
         new property.  */</comment>
    }</block></then>

  <else>else <if>if <condition>(<expr>(<name>base_val</name> &amp;&amp; !<name>old_val</name>)
           || (!<name>base_val</name> &amp;&amp; <name>old_val</name>)</expr>)</condition><then>
    <block>{
      <comment type="block">/* If only one of base and old are defined, then we've got a
         situation where one agent is attempting to add the property
         for the first time, and the other agent is changing a
         property it thinks already exists.  In this case, we return
         whichever older-value happens to be defined, so that the
         conflict-callback can still attempt a 3-way merge. */</comment>

      <decl_stmt><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>the_val</name> <init>= <expr><name>base_val</name> ? <name>base_val</name> : <name>old_val</name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_open_unique_file2</name><argument_list>(<argument><expr>&amp;<name>base_file</name></expr></argument>, <argument><expr>&amp;<name>base_path</name></expr></argument>,
                                       <argument><expr><name>path</name></expr></argument>, <argument><expr>".tmp"</expr></argument>,
                                       <argument><expr><name>svn_io_file_del_on_pool_cleanup</name></expr></argument>,
                                       <argument><expr><name>filepool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_write_full</name><argument_list>(<argument><expr><name>base_file</name></expr></argument>,
                                     <argument><expr><name><name>the_val</name>-&gt;<name>data</name></name></expr></argument>,
                                     <argument><expr><name><name>the_val</name>-&gt;<name>len</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>filepool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_close</name><argument_list>(<argument><expr><name>base_file</name></expr></argument>, <argument><expr><name>filepool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>cdesc</name>-&gt;<name>base_file</name></name> = <name>base_path</name></expr>;</expr_stmt>
    }</block></then>

  <else>else  <comment type="block">/* base and old are both non-NULL */</comment>
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>the_val</name></decl>;</decl_stmt>

      <if>if <condition>(<expr>! <call><name>svn_string_compare</name><argument_list>(<argument><expr><name>base_val</name></expr></argument>, <argument><expr><name>old_val</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <comment type="block">/* What happens if 'base' and 'old' don't match up?  In an
             ideal situation, they would.  But if they don't, this is
             a classic example of a patch 'hunk' failing to apply due
             to a lack of context.  For example: imagine that the user
             is busy changing the property from a value of "cat" to
             "dog", but the incoming propchange wants to change the
             same property value from "red" to "green".  Total context
             mismatch.

             HOWEVER: we can still pass one of the two base values as
             'base_file' to the callback anyway.  It's still useful to
             present the working and new values to the user to
             compare. */</comment>

          <if>if <condition>(<expr><name>working_val</name> &amp;&amp; <call><name>svn_string_compare</name><argument_list>(<argument><expr><name>base_val</name></expr></argument>, <argument><expr><name>working_val</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><name>the_val</name> = <name>old_val</name></expr>;</expr_stmt></then>
          <else>else
            <expr_stmt><expr><name>the_val</name> = <name>base_val</name></expr>;</expr_stmt></else></if>
        }</block></then>
      <else>else
        <block>{
          <expr_stmt><expr><name>the_val</name> = <name>base_val</name></expr>;</expr_stmt>
        }</block></else></if>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_open_unique_file2</name><argument_list>(<argument><expr>&amp;<name>base_file</name></expr></argument>, <argument><expr>&amp;<name>base_path</name></expr></argument>,
                                       <argument><expr><name>path</name></expr></argument>, <argument><expr>".tmp"</expr></argument>,
                                       <argument><expr><name>svn_io_file_del_on_pool_cleanup</name></expr></argument>,
                                       <argument><expr><name>filepool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_write_full</name><argument_list>(<argument><expr><name>base_file</name></expr></argument>, <argument><expr><name><name>the_val</name>-&gt;<name>data</name></name></expr></argument>,
                                     <argument><expr><name><name>the_val</name>-&gt;<name>len</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>filepool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_close</name><argument_list>(<argument><expr><name>base_file</name></expr></argument>, <argument><expr><name>filepool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>cdesc</name>-&gt;<name>base_file</name></name> = <name>base_path</name></expr>;</expr_stmt>

      <if>if <condition>(<expr><name>working_val</name> &amp;&amp; <name>new_val</name></expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>mergestream</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>svn_diff_t</name> *</type><name>diff</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>svn_diff_file_options_t</name> *</type><name>options</name> <init>=
            <expr><call><name>svn_diff_file_options_create</name><argument_list>(<argument><expr><name>filepool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_open_unique_file2</name><argument_list>(<argument><expr>&amp;<name>merged_file</name></expr></argument>, <argument><expr>&amp;<name>merged_path</name></expr></argument>,
                                           <argument><expr><name>path</name></expr></argument>, <argument><expr>".tmp"</expr></argument>,
                                           <argument><expr><name>svn_io_file_del_on_pool_cleanup</name></expr></argument>,
                                           <argument><expr><name>filepool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>mergestream</name> = <call><name>svn_stream_from_aprfile2</name><argument_list>(<argument><expr><name>merged_file</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                                                 <argument><expr><name>filepool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_diff_mem_string_diff3</name><argument_list>(<argument><expr>&amp;<name>diff</name></expr></argument>, <argument><expr><name>the_val</name></expr></argument>, <argument><expr><name>working_val</name></expr></argument>,
                                            <argument><expr><name>new_val</name></expr></argument>, <argument><expr><name>options</name></expr></argument>, <argument><expr><name>filepool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_diff_mem_string_output_merge</name>
                  <argument_list>(<argument><expr><name>mergestream</name></expr></argument>, <argument><expr><name>diff</name></expr></argument>, <argument><expr><name>the_val</name></expr></argument>, <argument><expr><name>working_val</name></expr></argument>, <argument><expr><name>new_val</name></expr></argument>,
                   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>filepool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>svn_stream_close</name><argument_list>(<argument><expr><name>mergestream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <expr_stmt><expr><name><name>cdesc</name>-&gt;<name>merged_file</name></name> = <name>merged_path</name></expr>;</expr_stmt>
        }</block></then></if>
    }</block></else></if></else></if>

  <comment type="block">/* Build the rest of the description object: */</comment>
  <expr_stmt><expr><name><name>cdesc</name>-&gt;<name>path</name></name> = <name>path</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cdesc</name>-&gt;<name>node_kind</name></name> = <name>is_dir</name> ? <name>svn_node_dir</name> : <name>svn_node_file</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cdesc</name>-&gt;<name>kind</name></name> = <name>svn_wc_conflict_kind_property</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cdesc</name>-&gt;<name>property_name</name></name> = <name>propname</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cdesc</name>-&gt;<name>access</name></name> = <name>adm_access</name></expr>;</expr_stmt>

  <if>if <condition>(<expr>!<name>is_dir</name> &amp;&amp; <name>working_props</name></expr>)</condition><then>
    <expr_stmt><expr><name>mime_propval</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>working_props</name></expr></argument>, <argument><expr><name>SVN_PROP_MIME_TYPE</name></expr></argument>,
                                <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <expr_stmt><expr><name><name>cdesc</name>-&gt;<name>mime_type</name></name> = <name>mime_propval</name> ? <name><name>mime_propval</name>-&gt;<name>data</name></name> : <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cdesc</name>-&gt;<name>is_binary</name></name> = <name>mime_propval</name> ?
      <call><name>svn_mime_type_is_binary</name><argument_list>(<argument><expr><name><name>mime_propval</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call> : <name>FALSE</name></expr>;</expr_stmt>

  <if>if <condition>(<expr>!<name>old_val</name> &amp;&amp; <name>new_val</name></expr>)</condition><then>
    <expr_stmt><expr><name><name>cdesc</name>-&gt;<name>action</name></name> = <name>svn_wc_conflict_action_add</name></expr>;</expr_stmt></then>
  <else>else <if>if <condition>(<expr><name>old_val</name> &amp;&amp; !<name>new_val</name></expr>)</condition><then>
    <expr_stmt><expr><name><name>cdesc</name>-&gt;<name>action</name></name> = <name>svn_wc_conflict_action_delete</name></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name><name>cdesc</name>-&gt;<name>action</name></name> = <name>svn_wc_conflict_action_edit</name></expr>;</expr_stmt></else></if></else></if>

  <if>if <condition>(<expr><name>base_val</name> &amp;&amp; !<name>working_val</name></expr>)</condition><then>
    <expr_stmt><expr><name><name>cdesc</name>-&gt;<name>reason</name></name> = <name>svn_wc_conflict_reason_deleted</name></expr>;</expr_stmt></then>
  <else>else <if>if <condition>(<expr>!<name>base_val</name> &amp;&amp; <name>working_val</name></expr>)</condition><then>
    <expr_stmt><expr><name><name>cdesc</name>-&gt;<name>reason</name></name> = <name>svn_wc_conflict_reason_obstructed</name></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name><name>cdesc</name>-&gt;<name>reason</name></name> = <name>svn_wc_conflict_reason_edited</name></expr>;</expr_stmt></else></if></else></if>

  <comment type="block">/* Invoke the interactive conflict callback. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>conflict_func</name><argument_list>(<argument><expr>&amp;<name>result</name></expr></argument>, <argument><expr><name>cdesc</name></expr></argument>, <argument><expr><name>conflict_baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>result</name> == <name>NULL</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr>*<name>conflict_remains</name> = <name>TRUE</name></expr>;</expr_stmt>
      <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_WC_CONFLICT_RESOLVER_FAILURE</name></expr></argument>,
                              <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Conflict callback violated API:"
                                      " returned no results."</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

  <switch>switch <condition>(<expr><name><name>result</name>-&gt;<name>choice</name></name></expr>)</condition>
    <block>{
      <default>default:
      </default><case>case <expr><name>svn_wc_conflict_choose_postpone</name></expr>:
        <block>{
          <expr_stmt><expr>*<name>conflict_remains</name> = <name>TRUE</name></expr>;</expr_stmt>
          <break>break;</break>
        }</block>
      </case><case>case <expr><name>svn_wc_conflict_choose_mine_full</name></expr>:
        <block>{
          <comment type="block">/* No need to change working_props; it already contains working_val */</comment>
          <expr_stmt><expr>*<name>conflict_remains</name> = <name>FALSE</name></expr>;</expr_stmt>
          <break>break;</break>
        }</block>
      <comment type="block">/* I think _mine_full and _theirs_full are appropriate for prop
         behavior as well as the text behavior.  There should even be
         analogous behaviors for _mine and _theirs when those are
         ready, namely: fold in all non-conflicting prop changes, and
         then choose _mine side or _theirs side for conflicting ones. */</comment>
      </case><case>case <expr><name>svn_wc_conflict_choose_theirs_full</name></expr>:
        <block>{
          <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>working_props</name></expr></argument>, <argument><expr><name>propname</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>new_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr>*<name>conflict_remains</name> = <name>FALSE</name></expr>;</expr_stmt>
          <break>break;</break>
        }</block>
      </case><case>case <expr><name>svn_wc_conflict_choose_base</name></expr>:
        <block>{
          <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>working_props</name></expr></argument>, <argument><expr><name>propname</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>base_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr>*<name>conflict_remains</name> = <name>FALSE</name></expr>;</expr_stmt>
          <break>break;</break>
        }</block>
      </case><case>case <expr><name>svn_wc_conflict_choose_merged</name></expr>:
        <block>{
          <if>if <condition>(<expr>!<name><name>cdesc</name>-&gt;<name>merged_file</name></name> &amp;&amp; !<name><name>result</name>-&gt;<name>merged_file</name></name></expr>)</condition><then>
            <return>return <expr><call><name>svn_error_create</name>
                <argument_list>(<argument><expr><name>SVN_ERR_WC_CONFLICT_RESOLVER_FAILURE</name></expr></argument>,
                 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Conflict callback violated API:"
                         " returned no merged file."</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then>
          <else>else
            <block>{
              <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>merged_stringbuf</name></decl>;</decl_stmt>
              <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>merged_string</name></decl>;</decl_stmt>

              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stringbuf_from_file2</name><argument_list>(<argument><expr>&amp;<name>merged_stringbuf</name></expr></argument>,
                                               <argument><expr><name><name>result</name>-&gt;<name>merged_file</name></name> ?
                                                    <name><name>result</name>-&gt;<name>merged_file</name></name> :
                                                    <name><name>cdesc</name>-&gt;<name>merged_file</name></name></expr></argument>,
                                               <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>merged_string</name> = <call><name>svn_string_create_from_buf</name><argument_list>(<argument><expr><name>merged_stringbuf</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>working_props</name></expr></argument>, <argument><expr><name>propname</name></expr></argument>,
                           <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>merged_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr>*<name>conflict_remains</name> = <name>FALSE</name></expr>;</expr_stmt>
            }</block></else></if>
          <break>break;</break>
        }</block>
    </case>}</block></switch>

  <comment type="block">/* Delete any tmpfiles we made. */</comment>
  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>filepool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Add the property with name PROPNAME to the set of WORKING_PROPS on
 * PATH, setting *STATE or *CONFLICT according to merge outcomes.
 *
 * *STATE is an input and output parameter, its value is to be
 * set using set_merge_prop_state().
 *
 * BASE_VAL contains the working copy base property value
 *
 * NEW_VAL contains the value to be set.
 *
 * CONFLICT_FUNC/BATON is a callback to be called before declaring a
 * property conflict;  it gives the client a chance to resolve the
 * conflict interactively.  It uses ADM_ACCESS to possibly examine
 * PATH's entries.
 */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>apply_single_prop_add</name><parameter_list>(<param><decl><type><name>svn_wc_notify_state_t</name> *</type><name>state</name></decl></param>,
                      <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                      <param><decl><type><name>svn_boolean_t</name></type> <name>is_dir</name></decl></param>,
                      <param><decl><type><name>apr_hash_t</name> *</type><name>working_props</name></decl></param>,
                      <param><decl><type><name>svn_string_t</name> **</type><name>conflict</name></decl></param>,
                      <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>propname</name></decl></param>,
                      <param><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>base_val</name></decl></param>,
                      <param><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>new_val</name></decl></param>,
                      <param><decl><type><name>svn_wc_conflict_resolver_func_t</name></type> <name>conflict_func</name></decl></param>,
                      <param><decl><type><name>void</name> *</type><name>conflict_baton</name></decl></param>,
                      <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                      <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>

<block>{
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>got_conflict</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>working_val</name>
    <init>= <expr><call><name>apr_hash_get</name><argument_list>(<argument><expr><name>working_props</name></expr></argument>, <argument><expr><name>propname</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>working_val</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* the property already exists in working_props... */</comment>

      <if>if <condition>(<expr><call><name>svn_string_compare</name><argument_list>(<argument><expr><name>working_val</name></expr></argument>, <argument><expr><name>new_val</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <comment type="block">/* The value we want is already there, so it's a merge. */</comment>
        <expr_stmt><expr><call><name>set_prop_merge_state</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>svn_wc_notify_state_merged</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>

      <else>else
        <block>{
          <comment type="block">/* The WC difference doesn't match the new value.
           We only merge mergeinfo;  other props conflict */</comment>
          <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>propname</name></expr></argument>, <argument><expr><name>SVN_PROP_MERGEINFO</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
            <block>{
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>combine_mergeinfo_props</name><argument_list>(<argument><expr>&amp;<name>new_val</name></expr></argument>, <argument><expr><name>working_val</name></expr></argument>,
                                              <argument><expr><name>new_val</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>working_props</name></expr></argument>, <argument><expr><name>propname</name></expr></argument>,
                           <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>new_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>set_prop_merge_state</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>svn_wc_notify_state_merged</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
          <else>else
            <block>{
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>maybe_generate_propconflict</name><argument_list>(<argument><expr>&amp;<name>got_conflict</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
                                                  <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>is_dir</name></expr></argument>,
                                                  <argument><expr><name>propname</name></expr></argument>, <argument><expr><name>working_props</name></expr></argument>,
                                                  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>new_val</name></expr></argument>,
                                                  <argument><expr><name>base_val</name></expr></argument>, <argument><expr><name>working_val</name></expr></argument>,
                                                  <argument><expr><name>conflict_func</name></expr></argument>, <argument><expr><name>conflict_baton</name></expr></argument>,
                                                  <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <if>if <condition>(<expr><name>got_conflict</name></expr>)</condition><then>
                <expr_stmt><expr>*<name>conflict</name> = <call><name>svn_string_createf</name>
                    <argument_list>(<argument><expr><name>pool</name></expr></argument>,
                     <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Trying to add new property '%s' with value "
                       "'%s',\nbut property already exists with value '%s'."</expr></argument>)</argument_list></call></expr></argument>,
                     <argument><expr><name>propname</name></expr></argument>, <argument><expr><name><name>new_val</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>working_val</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            }</block></else></if>
        }</block></else></if>
    }</block></then>
  <else>else <if>if <condition>(<expr><name>base_val</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>maybe_generate_propconflict</name><argument_list>(<argument><expr>&amp;<name>got_conflict</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                                          <argument><expr><name>is_dir</name></expr></argument>, <argument><expr><name>propname</name></expr></argument>,
                                          <argument><expr><name>working_props</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>new_val</name></expr></argument>,
                                          <argument><expr><name>base_val</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                          <argument><expr><name>conflict_func</name></expr></argument>, <argument><expr><name>conflict_baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>got_conflict</name></expr>)</condition><then>
        <expr_stmt><expr>*<name>conflict</name> = <call><name>svn_string_createf</name>
            <argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Trying to create property '%s' with value '%s',\n"
                     "but it has been locally deleted."</expr></argument>)</argument_list></call></expr></argument>,
             <argument><expr><name>propname</name></expr></argument>, <argument><expr><name><name>new_val</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then>
  <else>else  <comment type="block">/* property doesn't yet exist in working_props...  */</comment>
    <comment type="block">/* so just set it */</comment>
    <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>working_props</name></expr></argument>, <argument><expr><name>propname</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>new_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Delete the property with name PROPNAME from the set of
 * WORKING_PROPS on PATH, setting *STATE or *CONFLICT according to
 * merge outcomes.
 *
 * *STATE is an input and output parameter, its value is to be
 * set using set_merge_prop_state().
 *
 * BASE_VAL contains the working copy base property value
 *
 * OLD_VAL contains the value the of the property the server
 * thinks it's deleting.
 *
 * CONFLICT_FUNC/BATON is a callback to be called before declaring a
 * property conflict;  it gives the client a chance to resolve the
 * conflict interactively.  It uses ADM_ACCESS to possibly examine
 * PATH's entries.
 */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>apply_single_prop_delete</name><parameter_list>(<param><decl><type><name>svn_wc_notify_state_t</name> *</type><name>state</name></decl></param>,
                         <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                         <param><decl><type><name>svn_boolean_t</name></type> <name>is_dir</name></decl></param>,
                         <param><decl><type><name>apr_hash_t</name> *</type><name>working_props</name></decl></param>,
                         <param><decl><type><name>svn_string_t</name> **</type><name>conflict</name></decl></param>,
                         <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>propname</name></decl></param>,
                         <param><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>base_val</name></decl></param>,
                         <param><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>old_val</name></decl></param>,
                         <param><decl><type><name>svn_wc_conflict_resolver_func_t</name></type> <name>conflict_func</name></decl></param>,
                         <param><decl><type><name>void</name> *</type><name>conflict_baton</name></decl></param>,
                         <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                         <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>got_conflict</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>working_val</name>
    <init>= <expr><call><name>apr_hash_get</name><argument_list>(<argument><expr><name>working_props</name></expr></argument>, <argument><expr><name>propname</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr>! <name>base_val</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>working_props</name></expr></argument>, <argument><expr><name>propname</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>old_val</name></expr>)</condition><then>
        <comment type="block">/* This is a merge, merging a delete into non-existent */</comment>
        <expr_stmt><expr><call><name>set_prop_merge_state</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>svn_wc_notify_state_merged</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then>

  <else>else <if>if <condition>(<expr><call><name>svn_string_compare</name><argument_list>(<argument><expr><name>base_val</name></expr></argument>, <argument><expr><name>old_val</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
       <if>if <condition>(<expr><name>working_val</name></expr>)</condition><then>
         <block>{
           <if>if <condition>(<expr><call><name>svn_string_compare</name><argument_list>(<argument><expr><name>working_val</name></expr></argument>, <argument><expr><name>old_val</name></expr></argument>)</argument_list></call></expr>)</condition><then>
             <comment type="block">/* they have the same values, so it's an update */</comment>
             <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>working_props</name></expr></argument>, <argument><expr><name>propname</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
           <else>else
             <block>{
               <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>maybe_generate_propconflict</name><argument_list>(<argument><expr>&amp;<name>got_conflict</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
                                                   <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>is_dir</name></expr></argument>,
                                                   <argument><expr><name>propname</name></expr></argument>, <argument><expr><name>working_props</name></expr></argument>,
                                                   <argument><expr><name>old_val</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                                   <argument><expr><name>base_val</name></expr></argument>, <argument><expr><name>working_val</name></expr></argument>,
                                                   <argument><expr><name>conflict_func</name></expr></argument>, <argument><expr><name>conflict_baton</name></expr></argument>,
                                                   <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
               <if>if <condition>(<expr><name>got_conflict</name></expr>)</condition><then>
                 <expr_stmt><expr>*<name>conflict</name> = <call><name>svn_string_createf</name>
                     <argument_list>(<argument><expr><name>pool</name></expr></argument>,
                      <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Trying to delete property '%s' with value '%s'\n"
                        "but it has been modified from '%s' to '%s'."</expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><name>propname</name></expr></argument>, <argument><expr><name><name>old_val</name>-&gt;<name>data</name></name></expr></argument>,
                      <argument><expr><name><name>base_val</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>working_val</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
             }</block></else></if>
         }</block></then>
       <else>else
         <comment type="block">/* The property is locally deleted, so it's a merge */</comment>
         <expr_stmt><expr><call><name>set_prop_merge_state</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>svn_wc_notify_state_merged</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
    }</block></then>

  <else>else
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>maybe_generate_propconflict</name><argument_list>(<argument><expr>&amp;<name>got_conflict</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                                          <argument><expr><name>is_dir</name></expr></argument>, <argument><expr><name>propname</name></expr></argument>,
                                          <argument><expr><name>working_props</name></expr></argument>, <argument><expr><name>old_val</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                          <argument><expr><name>base_val</name></expr></argument>, <argument><expr><name>working_val</name></expr></argument>,
                                          <argument><expr><name>conflict_func</name></expr></argument>, <argument><expr><name>conflict_baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>got_conflict</name></expr>)</condition><then>
        <expr_stmt><expr>*<name>conflict</name> = <call><name>svn_string_createf</name>
            <argument_list>(<argument><expr><name>pool</name></expr></argument>,
             <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Trying to delete property '%s' with value '%s'\n"
               "but the local value is '%s'."</expr></argument>)</argument_list></call></expr></argument>,
             <argument><expr><name>propname</name></expr></argument>, <argument><expr><name><name>base_val</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>working_val</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></else></if></else></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Change the property with name PROPNAME in the set of WORKING_PROPS
 * on PATH, setting *STATE or *CONFLICT according to merge outcomes.
 *
 * *STATE is an input and output parameter, its value is to be
 * set using set_merge_prop_state().
 *
 * BASE_VAL contains the working copy base property value
 *
 * OLD_VAL contains the value the of the property the server
 * thinks it's overwriting
 *
 * NEW_VAL contains the value to be set.
 *
 * CONFLICT_FUNC/BATON is a callback to be called before declaring a
 * property conflict;  it gives the client a chance to resolve the
 * conflict interactively.  It uses ADM_ACCESS to possibly examine the
 * path's entries.
 */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>apply_single_prop_change</name><parameter_list>(<param><decl><type><name>svn_wc_notify_state_t</name> *</type><name>state</name></decl></param>,
                         <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                         <param><decl><type><name>svn_boolean_t</name></type> <name>is_dir</name></decl></param>,
                         <param><decl><type><name>apr_hash_t</name> *</type><name>working_props</name></decl></param>,
                         <param><decl><type><name>svn_string_t</name> **</type><name>conflict</name></decl></param>,
                         <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>propname</name></decl></param>,
                         <param><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>base_val</name></decl></param>,
                         <param><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>old_val</name></decl></param>,
                         <param><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>new_val</name></decl></param>,
                         <param><decl><type><name>svn_wc_conflict_resolver_func_t</name></type> <name>conflict_func</name></decl></param>,
                         <param><decl><type><name>void</name> *</type><name>conflict_baton</name></decl></param>,
                         <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                         <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>got_conflict</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>working_val</name>
    <init>= <expr><call><name>apr_hash_get</name><argument_list>(<argument><expr><name>working_props</name></expr></argument>, <argument><expr><name>propname</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr>(<name>working_val</name> &amp;&amp; ! <name>base_val</name>)
      || (! <name>working_val</name> &amp;&amp; <name>base_val</name>)
      || (<name>working_val</name> &amp;&amp; <name>base_val</name>
          &amp;&amp; !<call><name>svn_string_compare</name><argument_list>(<argument><expr><name>working_val</name></expr></argument>, <argument><expr><name>base_val</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
    <block>{
      <comment type="block">/* Locally changed property */</comment>
      <if>if <condition>(<expr><name>working_val</name></expr>)</condition><then>
        <block>{
          <if>if <condition>(<expr><call><name>svn_string_compare</name><argument_list>(<argument><expr><name>working_val</name></expr></argument>, <argument><expr><name>new_val</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <comment type="block">/* The new value equals the changed value: a merge */</comment>
            <expr_stmt><expr><call><name>set_prop_merge_state</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>svn_wc_notify_state_merged</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
          <else>else
            <block>{
              <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>propname</name></expr></argument>, <argument><expr><name>SVN_PROP_MERGEINFO</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
                <block>{
                  <comment type="block">/* We have base, WC, and new values.  Discover
                     deltas between base &lt;-&gt; WC, and base &lt;-&gt;
                     incoming.  Combine those deltas, and apply
                     them to base to get the new value. */</comment>
                  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>combine_forked_mergeinfo_props</name><argument_list>(<argument><expr>&amp;<name>new_val</name></expr></argument>, <argument><expr><name>old_val</name></expr></argument>,
                                                         <argument><expr><name>working_val</name></expr></argument>,
                                                         <argument><expr><name>new_val</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>working_props</name></expr></argument>, <argument><expr><name>propname</name></expr></argument>,
                               <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>new_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <expr_stmt><expr><call><name>set_prop_merge_state</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>svn_wc_notify_state_merged</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then>
              <else>else
                <block>{
                  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>maybe_generate_propconflict</name><argument_list>(<argument><expr>&amp;<name>got_conflict</name></expr></argument>,
                                                      <argument><expr><name>path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>is_dir</name></expr></argument>,
                                                      <argument><expr><name>propname</name></expr></argument>, <argument><expr><name>working_props</name></expr></argument>,
                                                      <argument><expr><name>old_val</name></expr></argument>, <argument><expr><name>new_val</name></expr></argument>,
                                                      <argument><expr><name>base_val</name></expr></argument>, <argument><expr><name>working_val</name></expr></argument>,
                                                      <argument><expr><name>conflict_func</name></expr></argument>,
                                                      <argument><expr><name>conflict_baton</name></expr></argument>,
                                                      <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <if>if <condition>(<expr><name>got_conflict</name></expr>)</condition><then>
                    <block>{
                      <if>if <condition>(<expr><name>base_val</name></expr>)</condition><then>
                        <expr_stmt><expr>*<name>conflict</name> = <call><name>svn_string_createf</name>
                        <argument_list>(<argument><expr><name>pool</name></expr></argument>,
                         <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Trying to change property '%s' from '%s' to '%s',\n"
                           "but property has been locally changed "
                           "from '%s' to '%s'."</expr></argument>)</argument_list></call></expr></argument>,
                         <argument><expr><name>propname</name></expr></argument>, <argument><expr><name><name>old_val</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>new_val</name>-&gt;<name>data</name></name></expr></argument>,
                          <argument><expr><name><name>base_val</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>working_val</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
                      <else>else
                        <expr_stmt><expr>*<name>conflict</name> = <call><name>svn_string_createf</name>
                        <argument_list>(<argument><expr><name>pool</name></expr></argument>,
                         <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Trying to change property '%s' from '%s' to '%s',\n"
                           "but property has been locally added with "
                           "value '%s'"</expr></argument>)</argument_list></call></expr></argument>,
                         <argument><expr><name>propname</name></expr></argument>, <argument><expr><name><name>old_val</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>new_val</name>-&gt;<name>data</name></name></expr></argument>,
                         <argument><expr><name><name>working_val</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
                      }</block></then></if>
                }</block></else></if>
            }</block></else></if>
        }</block></then>

      <else>else
        <block>{
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>maybe_generate_propconflict</name><argument_list>(<argument><expr>&amp;<name>got_conflict</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                                              <argument><expr><name>is_dir</name></expr></argument>, <argument><expr><name>propname</name></expr></argument>, <argument><expr><name>working_props</name></expr></argument>,
                                              <argument><expr><name>old_val</name></expr></argument>, <argument><expr><name>new_val</name></expr></argument>,
                                              <argument><expr><name>base_val</name></expr></argument>, <argument><expr><name>working_val</name></expr></argument>,
                                              <argument><expr><name>conflict_func</name></expr></argument>, <argument><expr><name>conflict_baton</name></expr></argument>,
                                              <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>got_conflict</name></expr>)</condition><then>
            <expr_stmt><expr>*<name>conflict</name> = <call><name>svn_string_createf</name>
                <argument_list>(<argument><expr><name>pool</name></expr></argument>,
                 <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Trying to change property '%s' from '%s' to '%s',\n"
                   "but it has been locally deleted."</expr></argument>)</argument_list></call></expr></argument>,
                 <argument><expr><name>propname</name></expr></argument>, <argument><expr><name><name>old_val</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>new_val</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        }</block></else></if>
    }</block></then>

  <else>else <if>if <condition>(<expr>! <name>working_val</name></expr>)</condition><then> <comment type="block">/* means !working_val &amp;&amp; !base_val due
                             to conditions above: no prop at all */</comment>
    <block>{
      <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>propname</name></expr></argument>, <argument><expr><name>SVN_PROP_MERGEINFO</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
        <block>{
          <comment type="block">/* Discover any mergeinfo additions in the
             incoming value relative to the base, and
             "combine" those with the empty WC value. */</comment>
          <decl_stmt><decl><type><name>svn_mergeinfo_t</name></type> <name>deleted_mergeinfo</name></decl>, <decl><type ref="prev"/><name>added_mergeinfo</name></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>diff_mergeinfo_props</name><argument_list>(<argument><expr>&amp;<name>deleted_mergeinfo</name></expr></argument>,
                                       <argument><expr>&amp;<name>added_mergeinfo</name></expr></argument>,
                                       <argument><expr><name>old_val</name></expr></argument>, <argument><expr><name>new_val</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo_to_string</name><argument_list>(<argument><expr>(<name>svn_string_t</name> **)&amp;<name>new_val</name></expr></argument>,
                                          <argument><expr><name>added_mergeinfo</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>working_props</name></expr></argument>, <argument><expr><name>propname</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>new_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
      <else>else
        <block>{
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>maybe_generate_propconflict</name><argument_list>(<argument><expr>&amp;<name>got_conflict</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                                              <argument><expr><name>is_dir</name></expr></argument>, <argument><expr><name>propname</name></expr></argument>, <argument><expr><name>working_props</name></expr></argument>,
                                              <argument><expr><name>old_val</name></expr></argument>, <argument><expr><name>new_val</name></expr></argument>,
                                              <argument><expr><name>base_val</name></expr></argument>, <argument><expr><name>working_val</name></expr></argument>,
                                              <argument><expr><name>conflict_func</name></expr></argument>, <argument><expr><name>conflict_baton</name></expr></argument>,
                                              <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>got_conflict</name></expr>)</condition><then>
            <expr_stmt><expr>*<name>conflict</name> = <call><name>svn_string_createf</name>
                <argument_list>(<argument><expr><name>pool</name></expr></argument>,
                 <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Trying to change property '%s' from '%s' to '%s',\n"
                   "but the property does not exist."</expr></argument>)</argument_list></call></expr></argument>,
                 <argument><expr><name>propname</name></expr></argument>, <argument><expr><name><name>old_val</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>new_val</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        }</block></else></if>
    }</block></then>

  <else>else <comment type="block">/* means working &amp;&amp; base &amp;&amp; svn_string_compare(working, base) */</comment>
    <block>{
      <if>if <condition>(<expr><call><name>svn_string_compare</name><argument_list>(<argument><expr><name>old_val</name></expr></argument>, <argument><expr><name>base_val</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>working_props</name></expr></argument>, <argument><expr><name>propname</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>new_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>

      <else>else
        <block>{
          <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>propname</name></expr></argument>, <argument><expr><name>SVN_PROP_MERGEINFO</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
            <block>{
              <comment type="block">/* We have base, WC, and new values.  Discover
                 deltas between base &lt;-&gt; WC, and base &lt;-&gt;
                 incoming.  Combine those deltas, and apply
                 them to base to get the new value. */</comment>
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>combine_forked_mergeinfo_props</name><argument_list>(<argument><expr>&amp;<name>new_val</name></expr></argument>, <argument><expr><name>old_val</name></expr></argument>,
                                                     <argument><expr><name>working_val</name></expr></argument>,
                                                     <argument><expr><name>new_val</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>working_props</name></expr></argument>, <argument><expr><name>propname</name></expr></argument>,
                           <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>new_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>set_prop_merge_state</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>svn_wc_notify_state_merged</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
          <else>else
            <block>{
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>maybe_generate_propconflict</name><argument_list>(<argument><expr>&amp;<name>got_conflict</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
                                                  <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>is_dir</name></expr></argument>,
                                                  <argument><expr><name>propname</name></expr></argument>, <argument><expr><name>working_props</name></expr></argument>,
                                                  <argument><expr><name>old_val</name></expr></argument>, <argument><expr><name>new_val</name></expr></argument>,
                                                  <argument><expr><name>base_val</name></expr></argument>, <argument><expr><name>working_val</name></expr></argument>,
                                                  <argument><expr><name>conflict_func</name></expr></argument>, <argument><expr><name>conflict_baton</name></expr></argument>,
                                                  <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <if>if <condition>(<expr><name>got_conflict</name></expr>)</condition><then>
                <expr_stmt><expr>*<name>conflict</name> = <call><name>svn_string_createf</name>
                    <argument_list>(<argument><expr><name>pool</name></expr></argument>,
                     <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Trying to change property '%s' from '%s' to '%s',\n"
                       "but property already exists with value '%s'."</expr></argument>)</argument_list></call></expr></argument>,
                     <argument><expr><name>propname</name></expr></argument>, <argument><expr><name><name>old_val</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>new_val</name>-&gt;<name>data</name></name></expr></argument>,
                     <argument><expr><name><name>working_val</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            }</block></else></if>
        }</block></else></if>
    }</block></else></if></else></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_wc__merge_props</name><parameter_list>(<param><decl><type><name>svn_wc_notify_state_t</name> *</type><name>state</name></decl></param>,
                    <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                    <param><decl><type><name>apr_hash_t</name> *</type><name>server_baseprops</name></decl></param>,
                    <param><decl><type><name>apr_hash_t</name> *</type><name>base_props</name></decl></param>,
                    <param><decl><type><name>apr_hash_t</name> *</type><name>working_props</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>apr_array_header_t</name> *</type><name>propchanges</name></decl></param>,
                    <param><decl><type><name>svn_boolean_t</name></type> <name>base_merge</name></decl></param>,
                    <param><decl><type><name>svn_boolean_t</name></type> <name>dry_run</name></decl></param>,
                    <param><decl><type><name>svn_wc_conflict_resolver_func_t</name></type> <name>conflict_func</name></decl></param>,
                    <param><decl><type><name>void</name> *</type><name>conflict_baton</name></decl></param>,
                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                    <param><decl><type><name>svn_stringbuf_t</name> **</type><name>entry_accum</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>is_dir</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>reject_path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>reject_tmp_fp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>       <comment type="block">/* the temporary conflicts file */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>reject_tmp_path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr>! <call><name>svn_path_is_child</name><argument_list>(<argument><expr><call><name>svn_wc_adm_access_path</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <expr_stmt><expr><name>is_dir</name> = <name>TRUE</name></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name>is_dir</name> = <name>FALSE</name></expr>;</expr_stmt></else></if>

  <comment type="block">/* If not provided, load the base &amp; working property files into hashes */</comment>
  <if>if <condition>(<expr>! <name>base_props</name> || ! <name>working_props</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__load_props</name><argument_list>(<argument><expr><name>base_props</name> ? <name>NULL</name> : &amp;<name>base_props</name></expr></argument>,
                               <argument><expr><name>working_props</name> ? <name>NULL</name> : &amp;<name>working_props</name></expr></argument>,
                               <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <if>if <condition>(<expr>!<name>server_baseprops</name></expr>)</condition><then>
    <expr_stmt><expr><name>server_baseprops</name> = <name>base_props</name></expr>;</expr_stmt></then></if>

  <if>if <condition>(<expr><name>state</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* Start out assuming no changes or conflicts.  Don't bother to
         examine propchanges-&gt;nelts yet; even if we knew there were
         propchanges, we wouldn't yet know if they are "normal" props,
         as opposed wc or entry props.  */</comment>
      <expr_stmt><expr>*<name>state</name> = <name>svn_wc_notify_state_unchanged</name></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* Looping over the array of incoming propchanges we want to apply: */</comment>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>propchanges</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>propname</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>conflict</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>svn_prop_t</name> *</type><name>incoming_change</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>from_val</name></decl>, *<decl><type ref="prev"/><name>to_val</name></decl>, *<decl><type ref="prev"/><name>working_val</name></decl>, *<decl><type ref="prev"/><name>base_val</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>is_normal</name></decl>;</decl_stmt>

      <comment type="block">/* For the incoming propchange, figure out the TO and FROM values. */</comment>
      <expr_stmt><expr><name>incoming_change</name> = &amp;<call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>propchanges</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>svn_prop_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>propname</name> = <name><name>incoming_change</name>-&gt;<name>name</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>is_normal</name> = <call><name>svn_wc_is_normal_prop</name><argument_list>(<argument><expr><name>propname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>to_val</name> = <name><name>incoming_change</name>-&gt;<name>value</name></name>
        ? <call><name>svn_string_dup</name><argument_list>(<argument><expr><name><name>incoming_change</name>-&gt;<name>value</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call> : <name>NULL</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>from_val</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>server_baseprops</name></expr></argument>, <argument><expr><name>propname</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>working_val</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>working_props</name></expr></argument>, <argument><expr><name>propname</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>base_val</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>base_props</name></expr></argument>, <argument><expr><name>propname</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr><name>base_merge</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>base_props</name></expr></argument>, <argument><expr><name>propname</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>to_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

      <comment type="block">/* We already know that state is at least `changed', so mark
         that, but remember that we may later upgrade to `merged' or
         even `conflicted'. */</comment>
      <if>if <condition>(<expr><name>is_normal</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>set_prop_merge_state</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>svn_wc_notify_state_changed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

      <if>if <condition>(<expr>! <name>from_val</name></expr>)</condition><then>  <comment type="block">/* adding a new property */</comment>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>apply_single_prop_add</name><argument_list>(<argument><expr><name>is_normal</name> ? <name>state</name> : <name>NULL</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>is_dir</name></expr></argument>,
                                      <argument><expr><name>working_props</name></expr></argument>, <argument><expr>&amp;<name>conflict</name></expr></argument>,
                                      <argument><expr><name>propname</name></expr></argument>, <argument><expr><name>base_val</name></expr></argument>, <argument><expr><name>to_val</name></expr></argument>,
                                      <argument><expr><name>conflict_func</name></expr></argument>, <argument><expr><name>conflict_baton</name></expr></argument>,
                                      <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>

      <else>else <if>if <condition>(<expr>! <name>to_val</name></expr>)</condition><then> <comment type="block">/* delete an existing property */</comment>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>apply_single_prop_delete</name><argument_list>(<argument><expr><name>is_normal</name> ? <name>state</name> : <name>NULL</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>is_dir</name></expr></argument>,
                                         <argument><expr><name>working_props</name></expr></argument>, <argument><expr>&amp;<name>conflict</name></expr></argument>,
                                         <argument><expr><name>propname</name></expr></argument>, <argument><expr><name>base_val</name></expr></argument>, <argument><expr><name>from_val</name></expr></argument>,
                                         <argument><expr><name>conflict_func</name></expr></argument>, <argument><expr><name>conflict_baton</name></expr></argument>,
                                         <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>

      <else>else  <comment type="block">/* changing an existing property */</comment>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>apply_single_prop_change</name><argument_list>(<argument><expr><name>is_normal</name> ? <name>state</name> : <name>NULL</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>is_dir</name></expr></argument>,
                                         <argument><expr><name>working_props</name></expr></argument>, <argument><expr>&amp;<name>conflict</name></expr></argument>,
                                         <argument><expr><name>propname</name></expr></argument>, <argument><expr><name>base_val</name></expr></argument>, <argument><expr><name>from_val</name></expr></argument>, <argument><expr><name>to_val</name></expr></argument>,
                                         <argument><expr><name>conflict_func</name></expr></argument>, <argument><expr><name>conflict_baton</name></expr></argument>,
                                         <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if></else></if>


      <comment type="block">/* merging logic complete, now we need to possibly log conflict
         data to tmpfiles.  */</comment>

      <if>if <condition>(<expr><name>conflict</name></expr>)</condition><then>
        <block>{
          <if>if <condition>(<expr><name>is_normal</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>set_prop_merge_state</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>svn_wc_notify_state_conflicted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

          <if>if <condition>(<expr><name>dry_run</name></expr>)</condition><then>
            <continue>continue;</continue></then></if>   <comment type="block">/* skip to next incoming change */</comment>

          <if>if <condition>(<expr>! <name>reject_tmp_fp</name></expr>)</condition><then>
            <comment type="block">/* This is the very first prop conflict found on this item. */</comment>
            <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>open_reject_tmp_file</name><argument_list>(<argument><expr>&amp;<name>reject_tmp_fp</name></expr></argument>, <argument><expr>&amp;<name>reject_tmp_path</name></expr></argument>,
                                         <argument><expr><name>path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>is_dir</name></expr></argument>,
                                         <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

          <comment type="block">/* Append the conflict to the open tmp/PROPS/---.prej file */</comment>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>append_prop_conflict</name><argument_list>(<argument><expr><name>reject_tmp_fp</name></expr></argument>, <argument><expr><name>conflict</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

    }</block></for>  <comment type="block">/* foreach propchange ... */</comment>

  <comment type="block">/* Finished applying all incoming propchanges to our hashes! */</comment>

  <if>if <condition>(<expr><name>dry_run</name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__install_props</name><argument_list>(<argument><expr><name>entry_accum</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
                                <argument><expr><name>base_props</name></expr></argument>, <argument><expr><name>working_props</name></expr></argument>, <argument><expr><name>base_merge</name></expr></argument>,
                                <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>reject_tmp_fp</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* There's a .prej file sitting in .svn/tmp/ somewhere.  Deal
         with the conflicts.  */</comment>

      <comment type="block">/* First, _close_ this temporary conflicts file.  We've been
         appending to it all along. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_close</name><argument_list>(<argument><expr><name>reject_tmp_fp</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Now try to get the name of a pre-existing .prej file from the
         entries file */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_existing_prop_reject_file</name><argument_list>(<argument><expr>&amp;<name>reject_path</name></expr></argument>,
                                            <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr>! <name>reject_path</name></expr>)</condition><then>
        <block>{
          <comment type="block">/* Reserve a new .prej file *above* the .svn/ directory by
             opening and closing it. */</comment>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>full_reject_path</name></decl>;</decl_stmt>

          <expr_stmt><expr><name>full_reject_path</name> = (!<name>is_dir</name>) ? <name>path</name> :
            <call><name>svn_path_join</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>SVN_WC__THIS_DIR_PREJ</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_open_unique_file2</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>reject_path</name></expr></argument>,
                                           <argument><expr><name>full_reject_path</name></expr></argument>,
                                           <argument><expr><name>SVN_WC__PROP_REJ_EXT</name></expr></argument>,
                                           <argument><expr><name>svn_io_file_del_none</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* This file will be overwritten when the log is run; that's
             ok, because at least now we have a reservation on
             disk. */</comment>
        }</block></then></if>

      <comment type="block">/* We've now guaranteed that some kind of .prej file exists
         above the .svn/ dir.  We write log entries to append our
         conflicts to it. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_append</name><argument_list>(<argument><expr><name>entry_accum</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                                   <argument><expr><name>reject_tmp_path</name></expr></argument>, <argument><expr><name>reject_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* And of course, delete the temporary reject file. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_remove</name><argument_list>(<argument><expr><name>entry_accum</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                                   <argument><expr><name>reject_tmp_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Mark entry as "conflicted" with a particular .prej file. */</comment>
      <block>{
        <decl_stmt><decl><type><name>svn_wc_entry_t</name></type> <name>entry</name></decl>;</decl_stmt>

        <expr_stmt><expr><name><name>entry</name>.<name>prejfile</name></name> = <call><name>svn_path_is_child</name><argument_list>(<argument><expr><call><name>svn_wc_adm_access_path</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>)</argument_list></call></expr></argument>,
                                           <argument><expr><name>reject_path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_entry_modify</name><argument_list>(<argument><expr><name>entry_accum</name></expr></argument>,
                                           <argument><expr><name>adm_access</name></expr></argument>,
                                           <argument><expr><name>path</name></expr></argument>,
                                           <argument><expr>&amp;<name>entry</name></expr></argument>,
                                           <argument><expr><name>SVN_WC__ENTRY_MODIFY_PREJFILE</name></expr></argument>,
                                           <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block>

    }</block></then></if> <comment type="block">/* if (reject_tmp_fp) */</comment>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* This is DEPRECATED, use svn_wc_merge_props() instead. */</comment>
<function><type><name>svn_error_t</name> *</type>
<name>svn_wc_merge_prop_diffs</name><parameter_list>(<param><decl><type><name>svn_wc_notify_state_t</name> *</type><name>state</name></decl></param>,
                        <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                        <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                        <param><decl><type><specifier>const</specifier> <name>apr_array_header_t</name> *</type><name>propchanges</name></decl></param>,
                        <param><decl><type><name>svn_boolean_t</name></type> <name>base_merge</name></decl></param>,
                        <param><decl><type><name>svn_boolean_t</name></type> <name>dry_run</name></decl></param>,
                        <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* NOTE: Here, we use implementation knowledge.  The public
     svn_wc_merge_props doesn't allow NULL as baseprops argument, but we know
     that it works. */</comment>
  <return>return <expr><call><name>svn_wc_merge_props</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>propchanges</name></expr></argument>,
                            <argument><expr><name>base_merge</name></expr></argument>, <argument><expr><name>dry_run</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>



<comment type="block">/*------------------------------------------------------------------*/</comment>
<escape char="0xc"/>
<comment type="block">/*** Private 'wc prop' functions ***/</comment>


<function><type><name>svn_error_t</name> *</type>
<name>svn_wc__wcprop_list</name><parameter_list>(<param><decl><type><name>apr_hash_t</name> **</type><name>wcprops</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>entryname</name></decl></param>,
                    <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>prop_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>entry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>all_wcprops</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>cache_pool</name> <init>= <expr><call><name>svn_wc_adm_access_pool</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name> <init>= <expr><call><name>svn_path_join</name><argument_list>(<argument><expr><call><name>svn_wc_adm_access_path</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr><name>entryname</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_entry</name><argument_list>(<argument><expr>&amp;<name>entry</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>! <name>entry</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* No entry exists, therefore no wcprop-file can exist */</comment>
      <expr_stmt><expr>*<name>wcprops</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>

  <comment type="block">/* Try the cache first. */</comment>
  <expr_stmt><expr><name>all_wcprops</name> = <call><name>svn_wc__adm_access_wcprops</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>! <name>all_wcprops</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>read_wcprops</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>all_wcprops</name> = <call><name>svn_wc__adm_access_wcprops</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  <if>if <condition>(<expr><name>all_wcprops</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr>*<name>wcprops</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>all_wcprops</name></expr></argument>, <argument><expr><name>entryname</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* The cache contains no hash tables for empty proplist, so we just
         create one here if that's the case. */</comment>
      <if>if <condition>(<expr>! *<name>wcprops</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr>*<name>wcprops</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>cache_pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>entryname</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>cache_pool</name></expr></argument>, <argument><expr><name>entryname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>all_wcprops</name></expr></argument>, <argument><expr><name>entryname</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr>*<name>wcprops</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>

  <comment type="block">/* Fall back on individual files for backwards compatibility. */</comment>

  <comment type="block">/* Construct a path to the relevant property file */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__prop_path</name><argument_list>(<argument><expr>&amp;<name>prop_path</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>entry</name>-&gt;<name>kind</name></name></expr></argument>,
                            <argument><expr><name>svn_wc__props_wcprop</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>wcprops</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>load_prop_file</name><argument_list>(<argument><expr><name>prop_path</name></expr></argument>, <argument><expr>*<name>wcprops</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Get a single 'wcprop' NAME for versioned object PATH, return in
   *VALUE.  ADM_ACCESS is an access baton set that contains PATH. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>wcprop_get</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>svn_string_t</name> **</type><name>value</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                   <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>prophash</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>entry</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_entry</name><argument_list>(<argument><expr>&amp;<name>entry</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>! <name>entry</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr>*<name>value</name> = <name>NULL</name></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>
  <if>if <condition>(<expr><name><name>entry</name>-&gt;<name>kind</name></name> == <name>svn_node_dir</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_adm_retrieve</name><argument_list>(<argument><expr>&amp;<name>adm_access</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_adm_retrieve</name><argument_list>(<argument><expr>&amp;<name>adm_access</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                                <argument><expr><call><name>svn_path_dirname</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

  <expr_stmt><expr><call><name>SVN_ERR_W</name><argument_list>(<argument><expr><call><name>svn_wc__wcprop_list</name><argument_list>(<argument><expr>&amp;<name>prophash</name></expr></argument>, <argument><expr><name><name>entry</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Failed to load properties from disk"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>value</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>prophash</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_wc__wcprop_set</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>value</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                   <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                   <param><decl><type><name>svn_boolean_t</name></type> <name>force_write</name></decl></param>,
                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>prophash</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>fp</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>cache_pool</name> <init>= <expr><call><name>svn_wc_adm_access_pool</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>entry</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__entry_versioned</name><argument_list>(<argument><expr>&amp;<name>entry</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name><name>entry</name>-&gt;<name>kind</name></name> == <name>svn_node_dir</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_adm_retrieve</name><argument_list>(<argument><expr>&amp;<name>adm_access</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_adm_retrieve</name><argument_list>(<argument><expr>&amp;<name>adm_access</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                                <argument><expr><call><name>svn_path_dirname</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
  <expr_stmt><expr><call><name>SVN_ERR_W</name><argument_list>(<argument><expr><call><name>svn_wc__wcprop_list</name><argument_list>(<argument><expr>&amp;<name>prophash</name></expr></argument>, <argument><expr><name><name>entry</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Failed to load properties from disk"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Now we have all the properties in our hash.  Simply merge the new
     property into it. */</comment>
  <expr_stmt><expr><name>name</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>cache_pool</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>value</name></expr>)</condition><then>
    <expr_stmt><expr><name>value</name> = <call><name>svn_string_dup</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>cache_pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>prophash</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><call><name>svn_wc__adm_wc_format</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>)</argument_list></call> &gt; <name>SVN_WC__WCPROPS_MANY_FILES_VERSION</name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr><name>force_write</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>write_wcprops</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then>
  <else>else
    <block>{
      <comment type="block">/* For backwards compatibility.  We don't use the cache in this case,
         so write to disk regardless of force_write. */</comment>
      <comment type="block">/* Open the propfile for writing. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__open_props</name><argument_list>(<argument><expr>&amp;<name>fp</name></expr></argument>,
                                 <argument><expr><name>path</name></expr></argument>, <comment type="block">/* open in PATH */</comment> <argument><expr><name><name>entry</name>-&gt;<name>kind</name></name></expr></argument>,
                                 <argument><expr>(<name>APR_WRITE</name> | <name>APR_CREATE</name> | <name>APR_BUFFERED</name>)</expr></argument>,
                                 <argument><expr>0</expr></argument>, <comment type="block">/* not base props */</comment>
                                 <argument><expr>1</expr></argument>, <comment type="block">/* we DO want wcprops */</comment>
                                 <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* Write. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR_W</name><argument_list>(<argument><expr><call><name>svn_hash_write</name><argument_list>(<argument><expr><name>prophash</name></expr></argument>, <argument><expr><name>fp</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>,
                             <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Cannot write property hash for '%s'"</expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Close file, doing an atomic "move". */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__close_props</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>entry</name>-&gt;<name>kind</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>1</expr></argument>,
                                  <argument><expr>1</expr></argument>, <comment type="block">/* sync! */</comment>
                                  <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/*------------------------------------------------------------------*/</comment>
<escape char="0xc"/>

<comment type="block">/*** Public Functions ***/</comment>


<function><type><name>svn_error_t</name> *</type>
<name>svn_wc_prop_list</name><parameter_list>(<param><decl><type><name>apr_hash_t</name> **</type><name>props</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                 <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>entry</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_entry</name><argument_list>(<argument><expr>&amp;<name>entry</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* if there is no entry, 'path' is not under version control and
     therefore has no props */</comment>
  <if>if <condition>(<expr>! <name>entry</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr>*<name>props</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>

  <if>if <condition>(<expr><name><name>entry</name>-&gt;<name>kind</name></name> == <name>svn_node_dir</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_adm_retrieve</name><argument_list>(<argument><expr>&amp;<name>adm_access</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_adm_retrieve</name><argument_list>(<argument><expr>&amp;<name>adm_access</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                                <argument><expr><call><name>svn_path_dirname</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

  <return>return <expr><call><name>svn_wc__load_props</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>props</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Determine if PROPNAME is contained in the list of space separated
   values STRING.  */</comment>

<function><type><specifier>static</specifier> <name>svn_boolean_t</name></type>
<name>string_contains_prop</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>string</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>propname</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>place</name> <init>= <expr><call><name>strstr</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><name>propname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>proplen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>propname</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr>!<name>place</name></expr>)</condition><then>
    <return>return <expr><name>FALSE</name></expr>;</return></then></if>

  <while>while <condition>(<expr><name>place</name></expr>)</condition>
    <block>{
      <if>if <condition>(<expr><name><name>place</name><index>[<expr><name>proplen</name></expr>]</index></name> == ' ' || <name><name>place</name><index>[<expr><name>proplen</name></expr>]</index></name> == 0</expr>)</condition><then>
        <return>return <expr><name>TRUE</name></expr>;</return></then></if>
      <expr_stmt><expr><name>place</name> = <call><name>strstr</name><argument_list>(<argument><expr><name>place</name> + 1</expr></argument>, <argument><expr><name>propname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></while>
  <return>return <expr><name>FALSE</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_wc_prop_get</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>svn_string_t</name> **</type><name>value</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>prophash</name></decl>;</decl_stmt>
  <enum>enum <name>svn_prop_kind</name> <name>kind</name> <expr_stmt><expr>= <call><name>svn_property_kind</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></enum>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>entry</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_entry</name><argument_list>(<argument><expr>&amp;<name>entry</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>entry</name> == <name>NULL</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr>*<name>value</name> = <name>NULL</name></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>

  <if>if <condition>(<expr><name><name>entry</name>-&gt;<name>cachable_props</name></name>
      &amp;&amp; <call><name>string_contains_prop</name><argument_list>(<argument><expr><name><name>entry</name>-&gt;<name>cachable_props</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <comment type="block">/* We separate these two cases so that we can return the correct
         value for booleans if they exist in the string.  */</comment>
      <if>if <condition>(<expr>!<name><name>entry</name>-&gt;<name>present_props</name></name>
          || !<call><name>string_contains_prop</name><argument_list>(<argument><expr><name><name>entry</name>-&gt;<name>present_props</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <expr_stmt><expr>*<name>value</name> = <name>NULL</name></expr>;</expr_stmt>
          <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
        }</block></then></if>
      <if>if <condition>(<expr><call><name>svn_prop_is_boolean</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <expr_stmt><expr>*<name>value</name> = <call><name>svn_string_create</name><argument_list>(<argument><expr><name>SVN_PROP_BOOLEAN_TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>*<name>value</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
        }</block></then></if>
    }</block></then></if>

  <if>if <condition>(<expr><name>kind</name> == <name>svn_prop_wc_kind</name></expr>)</condition><then>
    <block>{
      <return>return <expr><call><name>wcprop_get</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>
  <if>if <condition>(<expr><name>kind</name> == <name>svn_prop_entry_kind</name></expr>)</condition><then>
    <block>{
      <return>return <expr><call><name>svn_error_createf</name>   <comment type="block">/* we don't do entry properties here */</comment>
        <argument_list>(<argument><expr><name>SVN_ERR_BAD_PROP_KIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
         <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Property '%s' is an entry property"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then>
  <else>else  <comment type="block">/* regular prop */</comment>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR_W</name><argument_list>(<argument><expr><call><name>svn_wc_prop_list</name><argument_list>(<argument><expr>&amp;<name>prophash</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Failed to load properties from disk"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr>*<name>value</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>prophash</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></else></if>
}</block></function>


<comment type="block">/* The special Subversion properties are not valid for all node kinds.
   Return an error if NAME is an invalid Subversion property for PATH which
   is of kind NODE_KIND. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>validate_prop_against_node_kind</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>,
                                <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                                <param><decl><type><name>svn_node_kind_t</name></type> <name>node_kind</name></decl></param>,
                                <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{

  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name><name>file_prohibit</name><index>[]</index></name> <init>= <expr><block>{ <expr><name>SVN_PROP_IGNORE</name></expr>,
                                  <expr><name>SVN_PROP_EXTERNALS</name></expr>,
                                  <expr><name>NULL</name></expr> }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name><name>dir_prohibit</name><index>[]</index></name> <init>= <expr><block>{ <expr><name>SVN_PROP_EXECUTABLE</name></expr>,
                                 <expr><name>SVN_PROP_KEYWORDS</name></expr>,
                                 <expr><name>SVN_PROP_EOL_STYLE</name></expr>,
                                 <expr><name>SVN_PROP_MIME_TYPE</name></expr>,
                                 <expr><name>SVN_PROP_NEEDS_LOCK</name></expr>,
                                 <expr><name>NULL</name></expr> }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> **</type><name>node_kind_prohibit</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path_display</name>
    <init>= <expr><call><name>svn_path_is_url</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call> ? <name>path</name> : <call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <switch>switch <condition>(<expr><name>node_kind</name></expr>)</condition>
    <block>{
    <case>case <expr><name>svn_node_dir</name></expr>:
      <expr_stmt><expr><name>node_kind_prohibit</name> = <name>dir_prohibit</name></expr>;</expr_stmt>
      <while>while <condition>(<expr>*<name>node_kind_prohibit</name></expr>)</condition>
        <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>*<name>node_kind_prohibit</name>++</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
          <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_ILLEGAL_TARGET</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                   <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Cannot set '%s' on a directory ('%s')"</expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr><name>name</name></expr></argument>, <argument><expr><name>path_display</name></expr></argument>)</argument_list></call></expr>;</return></then></if></while>
      <break>break;</break>
    </case><case>case <expr><name>svn_node_file</name></expr>:
      <expr_stmt><expr><name>node_kind_prohibit</name> = <name>file_prohibit</name></expr>;</expr_stmt>
      <while>while <condition>(<expr>*<name>node_kind_prohibit</name></expr>)</condition>
        <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>*<name>node_kind_prohibit</name>++</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
          <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_ILLEGAL_TARGET</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                   <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Cannot set '%s' on a file ('%s')"</expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr><name>name</name></expr></argument>,
                                   <argument><expr><name>path_display</name></expr></argument>)</argument_list></call></expr>;</return></then></if></while>
      <break>break;</break>
    </case><default>default:
      <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_NODE_UNEXPECTED_KIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                               <argument><expr><call><name>_</name><argument_list>(<argument><expr>"'%s' is not a file or directory"</expr></argument>)</argument_list></call></expr></argument>,
                               <argument><expr><name>path_display</name></expr></argument>)</argument_list></call></expr>;</return>
    </default>}</block></switch>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<struct>struct <name>getter_baton</name> <block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl>;</decl_stmt>
}</block>;</struct>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>get_file_for_validation</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>svn_string_t</name> **</type><name>mime_type</name></decl></param>,
                        <param><decl><type><name>svn_stream_t</name> *</type><name>stream</name></decl></param>,
                        <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>,
                        <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>getter_baton</name> *</type><name>gb</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>mime_type</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_prop_get</name><argument_list>(<argument><expr><name>mime_type</name></expr></argument>, <argument><expr><name>SVN_PROP_MIME_TYPE</name></expr></argument>,
                            <argument><expr><name><name>gb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name><name>gb</name>-&gt;<name>adm_access</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <if>if <condition>(<expr><name>stream</name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>fp</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>read_stream</name></decl>;</decl_stmt>

    <comment type="block">/* Open PATH. */</comment>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_open</name><argument_list>(<argument><expr>&amp;<name>fp</name></expr></argument>, <argument><expr><name><name>gb</name>-&gt;<name>path</name></name></expr></argument>,
                             <argument><expr>(<name>APR_READ</name> | <name>APR_BINARY</name> | <name>APR_BUFFERED</name>)</expr></argument>,
                             <argument><expr>0</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Get a READ_STREAM from the file we just opened. */</comment>
    <expr_stmt><expr><name>read_stream</name> = <call><name>svn_stream_from_aprfile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Copy from the file into the translating stream. */</comment>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_copy</name><argument_list>(<argument><expr><name>read_stream</name></expr></argument>, <argument><expr><name>stream</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_close</name><argument_list>(<argument><expr><name>read_stream</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_close</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>validate_eol_prop_against_file</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                               <param><decl><type><name>svn_wc_canonicalize_svn_prop_get_file_t</name></type> <name>getter</name></decl></param>,
                               <param><decl><type><name>void</name> *</type><name>getter_baton</name></decl></param>,
                               <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>translating_stream</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>mime_type</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path_display</name>
    <init>= <expr><call><name>svn_path_is_url</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call> ? <name>path</name> : <call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="block">/* First just ask the "getter" for the MIME type. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>getter</name><argument_list>(<argument><expr>&amp;<name>mime_type</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>getter_baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* See if this file has been determined to be binary. */</comment>
  <if>if <condition>(<expr><name>mime_type</name> &amp;&amp; <call><name>svn_mime_type_is_binary</name><argument_list>(<argument><expr><name><name>mime_type</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name>
      <argument_list>(<argument><expr><name>SVN_ERR_ILLEGAL_TARGET</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"File '%s' has binary mime type property"</expr></argument>)</argument_list></call></expr></argument>,
       <argument><expr><name>path_display</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Now ask the getter for the contents of the file; this will do a
     newline translation.  All we really care about here is whether or
     not the function fails on inconsistent line endings.  The
     function is "translating" to an empty stream.  This is
     sneeeeeeeeeeeaky. */</comment>
  <expr_stmt><expr><name>translating_stream</name> = <call><name>svn_subst_stream_translated</name><argument_list>(<argument><expr><call><name>svn_stream_empty</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                                                   <argument><expr>""</expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                                                   <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>err</name> = <call><name>getter</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>translating_stream</name></expr></argument>, <argument><expr><name>getter_baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr>!<name>err</name></expr>)</condition><then>
    <expr_stmt><expr><name>err</name> = <call><name>svn_stream_close</name><argument_list>(<argument><expr><name>translating_stream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <if>if <condition>(<expr><name>err</name> &amp;&amp; <name><name>err</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_IO_INCONSISTENT_EOL</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_ILLEGAL_TARGET</name></expr></argument>, <argument><expr><name>err</name></expr></argument>,
                             <argument><expr><call><name>_</name><argument_list>(<argument><expr>"File '%s' has inconsistent newlines"</expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><name>path_display</name></expr></argument>)</argument_list></call></expr>;</return></then>
  <else>else <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
    <return>return <expr><name>err</name></expr>;</return></then></if></else></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_wc_prop_set2</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>value</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                 <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                 <param><decl><type><name>svn_boolean_t</name></type> <name>skip_checks</name></decl></param>,
                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>prophash</name></decl>, *<decl><type ref="prev"/><name>base_prophash</name></decl>;</decl_stmt>
  <enum>enum <name>svn_prop_kind</name> <name>prop_kind</name> <expr_stmt><expr>= <call><name>svn_property_kind</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></enum>
  <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>log_accum</name> <init>= <expr><call><name>svn_stringbuf_create</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>entry</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>prop_kind</name> == <name>svn_prop_wc_kind</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_wc__wcprop_set</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return></then>
  <else>else <if>if <condition>(<expr><name>prop_kind</name> == <name>svn_prop_entry_kind</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name>   <comment type="block">/* we don't do entry properties here */</comment>
      <argument_list>(<argument><expr><name>SVN_ERR_BAD_PROP_KIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Property '%s' is an entry property"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return></then></if></else></if>

  <comment type="block">/* Else, handle a regular property: */</comment>

  <comment type="block">/* Get the entry and name for this path. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__entry_versioned</name><argument_list>(<argument><expr>&amp;<name>entry</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Get the access baton for the entry's directory. */</comment>
  <if>if <condition>(<expr><name><name>entry</name>-&gt;<name>kind</name></name> == <name>svn_node_dir</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_adm_retrieve</name><argument_list>(<argument><expr>&amp;<name>adm_access</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_adm_retrieve</name><argument_list>(<argument><expr>&amp;<name>adm_access</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                                <argument><expr><call><name>svn_path_dirname</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

  <comment type="block">/* Setting an inappropriate property is not allowed (unless
     overridden by 'skip_checks', in some circumstances).  Deleting an
     inappropriate property is allowed, however, since older clients
     allowed (and other clients possibly still allow) setting it in
     the first place. */</comment>
  <if>if <condition>(<expr><name>value</name> &amp;&amp; <call><name>svn_prop_is_svn_prop</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>new_value</name></decl>;</decl_stmt>
      <decl_stmt><decl><type>struct <name>getter_baton</name> *</type><name>gb</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>gb</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><name><name>gb</name>-&gt;<name>path</name></name> = <name>path</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>gb</name>-&gt;<name>adm_access</name></name> = <name>adm_access</name></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_canonicalize_svn_prop</name><argument_list>(<argument><expr>&amp;<name>new_value</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
                                           <argument><expr><name><name>entry</name>-&gt;<name>kind</name></name></expr></argument>, <argument><expr><name>skip_checks</name></expr></argument>,
                                           <argument><expr><name>get_file_for_validation</name></expr></argument>, <argument><expr><name>gb</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>value</name> = <name>new_value</name></expr>;</expr_stmt>
    }</block></then></if>

  <if>if <condition>(<expr><name><name>entry</name>-&gt;<name>kind</name></name> == <name>svn_node_file</name> &amp;&amp; <call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>SVN_PROP_EXECUTABLE</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
    <block>{
      <comment type="block">/* If the svn:executable property was set, then chmod +x.
         If the svn:executable property was deleted (NULL value passed
         in), then chmod -x. */</comment>
      <if>if <condition>(<expr><name>value</name> == <name>NULL</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_set_file_executable</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
      <else>else
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_set_file_executable</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
    }</block></then></if>

  <if>if <condition>(<expr><name><name>entry</name>-&gt;<name>kind</name></name> == <name>svn_node_file</name> &amp;&amp; <call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>SVN_PROP_NEEDS_LOCK</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
    <block>{
      <comment type="block">/* If the svn:needs-lock property was set to NULL, set the file
         to read-write */</comment>
      <if>if <condition>(<expr><name>value</name> == <name>NULL</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_set_file_read_write</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

      <comment type="block">/* If not, we'll set the file to read-only at commit time. */</comment>
    }</block></then></if>

  <expr_stmt><expr><call><name>SVN_ERR_W</name><argument_list>(<argument><expr><call><name>svn_wc__load_props</name><argument_list>(<argument><expr>&amp;<name>base_prophash</name></expr></argument>, <argument><expr>&amp;<name>prophash</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                               <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Failed to load properties from disk"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If we're changing this file's list of expanded keywords, then
   * we'll need to invalidate its text timestamp, since keyword
   * expansion affects the comparison of working file to text base.
   *
   * Here we retrieve the old list of expanded keywords; after the
   * property is set, we'll grab the new list and see if it differs
   * from the old one.
   */</comment>
  <if>if <condition>(<expr><name><name>entry</name>-&gt;<name>kind</name></name> == <name>svn_node_file</name> &amp;&amp; <call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>SVN_PROP_KEYWORDS</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>old_value</name> <init>= <expr><call><name>apr_hash_get</name><argument_list>(<argument><expr><name>prophash</name></expr></argument>, <argument><expr><name>SVN_PROP_KEYWORDS</name></expr></argument>,
                                             <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>old_keywords</name></decl>, *<decl><type ref="prev"/><name>new_keywords</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__get_keywords</name><argument_list>(<argument><expr>&amp;<name>old_keywords</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                                   <argument><expr><name>old_value</name> ? <name><name>old_value</name>-&gt;<name>data</name></name> : ""</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__get_keywords</name><argument_list>(<argument><expr>&amp;<name>new_keywords</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                                   <argument><expr><name>value</name> ? <name><name>value</name>-&gt;<name>data</name></name> : ""</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr><call><name>svn_subst_keywords_differ2</name><argument_list>(<argument><expr><name>old_keywords</name></expr></argument>, <argument><expr><name>new_keywords</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><name>svn_wc_entry_t</name></type> <name>tmp_entry</name></decl>;</decl_stmt>

          <comment type="block">/* If we changed the keywords or newlines, void the entry
             timestamp for this file, so svn_wc_text_modified_p() does
             a real (albeit slow) check later on. */</comment>
          <expr_stmt><expr><name><name>tmp_entry</name>.<name>kind</name></name> = <name>svn_node_file</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>tmp_entry</name>.<name>text_time</name></name> = 0</expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_entry_modify</name><argument_list>(<argument><expr>&amp;<name>log_accum</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                                             <argument><expr><name>path</name></expr></argument>, <argument><expr>&amp;<name>tmp_entry</name></expr></argument>,
                                             <argument><expr><name>SVN_WC__ENTRY_MODIFY_TEXT_TIME</name></expr></argument>,
                                             <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>

  <comment type="block">/* Now we have all the properties in our hash.  Simply merge the new
     property into it. */</comment>
  <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>prophash</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__install_props</name><argument_list>(<argument><expr>&amp;<name>log_accum</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
                                <argument><expr><name>base_prophash</name></expr></argument>, <argument><expr><name>prophash</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__write_log</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>log_accum</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__run_log</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_wc_prop_set</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>value</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>svn_wc_prop_set2</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_wc_canonicalize_svn_prop</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>svn_string_t</name> **</type><name>propval_p</name></decl></param>,
                             <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>propname</name></decl></param>,
                             <param><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>propval</name></decl></param>,
                             <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                             <param><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl></param>,
                             <param><decl><type><name>svn_boolean_t</name></type> <name>skip_some_checks</name></decl></param>,
                             <param><decl><type><name>svn_wc_canonicalize_svn_prop_get_file_t</name></type> <name>getter</name></decl></param>,
                             <param><decl><type><name>void</name> *</type><name>getter_baton</name></decl></param>,
                             <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>new_value</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Keep this static, it may get stored (for read-only purposes) in a
     hash that outlives this function. */</comment>
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>svn_string_t</name></type> <name>boolean_value</name> <init>=
    <expr><block>{
      <expr><name>SVN_PROP_BOOLEAN_TRUE</name></expr>,
      <expr><sizeof>sizeof<argument_list>(<argument><expr><name>SVN_PROP_BOOLEAN_TRUE</name></expr></argument>)</argument_list></sizeof> - 1</expr>
    }</block></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>validate_prop_against_node_kind</name><argument_list>(<argument><expr><name>propname</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>kind</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr>!<name>skip_some_checks</name> &amp;&amp; (<call><name>strcmp</name><argument_list>(<argument><expr><name>propname</name></expr></argument>, <argument><expr><name>SVN_PROP_EOL_STYLE</name></expr></argument>)</argument_list></call> == 0)</expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_subst_eol_style_t</name></type> <name>eol_style</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ignored_eol</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>new_value</name> = <call><name>svn_stringbuf_create_from_string</name><argument_list>(<argument><expr><name>propval</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>svn_stringbuf_strip_whitespace</name><argument_list>(<argument><expr><name>new_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>svn_subst_eol_style_from_value</name><argument_list>(<argument><expr>&amp;<name>eol_style</name></expr></argument>, <argument><expr>&amp;<name>ignored_eol</name></expr></argument>, <argument><expr><name><name>new_value</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>eol_style</name> == <name>svn_subst_eol_style_unknown</name></expr>)</condition><then>
        <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_IO_UNKNOWN_EOL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                 <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Unrecognized line ending style for '%s'"</expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>validate_eol_prop_against_file</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>getter</name></expr></argument>, <argument><expr><name>getter_baton</name></expr></argument>,
                                             <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else <if>if <condition>(<expr>!<name>skip_some_checks</name> &amp;&amp; (<call><name>strcmp</name><argument_list>(<argument><expr><name>propname</name></expr></argument>, <argument><expr><name>SVN_PROP_MIME_TYPE</name></expr></argument>)</argument_list></call> == 0)</expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>new_value</name> = <call><name>svn_stringbuf_create_from_string</name><argument_list>(<argument><expr><name>propval</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>svn_stringbuf_strip_whitespace</name><argument_list>(<argument><expr><name>new_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mime_type_validate</name><argument_list>(<argument><expr><name><name>new_value</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>propname</name></expr></argument>, <argument><expr><name>SVN_PROP_IGNORE</name></expr></argument>)</argument_list></call> == 0
           || <call><name>strcmp</name><argument_list>(<argument><expr><name>propname</name></expr></argument>, <argument><expr><name>SVN_PROP_EXTERNALS</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
    <block>{
      <comment type="block">/* Make sure that the last line ends in a newline */</comment>
      <if>if <condition>(<expr><name><name>propval</name>-&gt;<name>data</name><index>[<expr><name><name>propval</name>-&gt;<name>len</name></name> - 1</expr>]</index></name> != '\n'</expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>new_value</name> = <call><name>svn_stringbuf_create_from_string</name><argument_list>(<argument><expr><name>propval</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>svn_stringbuf_appendbytes</name><argument_list>(<argument><expr><name>new_value</name></expr></argument>, <argument><expr>"\n"</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

      <comment type="block">/* Make sure this is a valid externals property.  Do not
         allow 'skip_some_checks' to override, as there is no circumstance in
         which this is proper (because there is no circumstance in
         which Subversion can handle it). */</comment>
      <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>propname</name></expr></argument>, <argument><expr><name>SVN_PROP_EXTERNALS</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
        <block>{
          <comment type="block">/* We don't allow "." nor ".." as target directories in
             an svn:externals line.  As it happens, our parse code
             checks for this, so all we have to is invoke it --
             we're not interested in the parsed result, only in
             whether or the parsing errored. */</comment>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_parse_externals_description3</name>
                  <argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>propval</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then>
  <else>else <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>propname</name></expr></argument>, <argument><expr><name>SVN_PROP_KEYWORDS</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>new_value</name> = <call><name>svn_stringbuf_create_from_string</name><argument_list>(<argument><expr><name>propval</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>svn_stringbuf_strip_whitespace</name><argument_list>(<argument><expr><name>new_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>propname</name></expr></argument>, <argument><expr><name>SVN_PROP_EXECUTABLE</name></expr></argument>)</argument_list></call> == 0
        || <call><name>strcmp</name><argument_list>(<argument><expr><name>propname</name></expr></argument>, <argument><expr><name>SVN_PROP_NEEDS_LOCK</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>new_value</name> = <call><name>svn_stringbuf_create_from_string</name><argument_list>(<argument><expr>&amp;<name>boolean_value</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>propname</name></expr></argument>, <argument><expr><name>SVN_PROP_MERGEINFO</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>mergeinfo</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo_parse</name><argument_list>(<argument><expr>&amp;<name>mergeinfo</name></expr></argument>, <argument><expr><name><name>propval</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if></else></if></else></if></else></if></else></if></else></if>

  <if>if <condition>(<expr><name>new_value</name></expr>)</condition><then>
    <expr_stmt><expr>*<name>propval_p</name> = <call><name>svn_string_create_from_buf</name><argument_list>(<argument><expr><name>new_value</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr>*<name>propval_p</name> = <name>propval</name></expr>;</expr_stmt></else></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_boolean_t</name></type>
<name>svn_wc_is_normal_prop</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>)</parameter_list>
<block>{
  <enum>enum <name>svn_prop_kind</name> <name>kind</name> <expr_stmt><expr>= <call><name>svn_property_kind</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></enum>
  <return>return <expr>(<name>kind</name> == <name>svn_prop_regular_kind</name>)</expr>;</return>
}</block></function>


<function><type><name>svn_boolean_t</name></type>
<name>svn_wc_is_wc_prop</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>)</parameter_list>
<block>{
  <enum>enum <name>svn_prop_kind</name> <name>kind</name> <expr_stmt><expr>= <call><name>svn_property_kind</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></enum>
  <return>return <expr>(<name>kind</name> == <name>svn_prop_wc_kind</name>)</expr>;</return>
}</block></function>


<function><type><name>svn_boolean_t</name></type>
<name>svn_wc_is_entry_prop</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>)</parameter_list>
<block>{
  <enum>enum <name>svn_prop_kind</name> <name>kind</name> <expr_stmt><expr>= <call><name>svn_property_kind</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></enum>
  <return>return <expr>(<name>kind</name> == <name>svn_prop_entry_kind</name>)</expr>;</return>
}</block></function>


<comment type="block">/* Helper to optimize svn_wc_props_modified_p().

   If PATH_TO_PROP_FILE is nonexistent, is empty, or is of size 4 bytes
   ("END\n"), then set EMPTY_P to true.   Otherwise set EMPTY_P to false,
   which means that the file must contain real properties.  */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>empty_props_p</name><parameter_list>(<param><decl><type><name>svn_boolean_t</name> *</type><name>empty_p</name></decl></param>,
              <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path_to_prop_file</name></decl></param>,
              <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_finfo_t</name></type> <name>finfo</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>err</name> = <call><name>svn_io_stat</name><argument_list>(<argument><expr>&amp;<name>finfo</name></expr></argument>, <argument><expr><name>path_to_prop_file</name></expr></argument>, <argument><expr><name>APR_FINFO_MIN</name> | <name>APR_FINFO_TYPE</name></expr></argument>,
                    <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr>! <call><name>APR_STATUS_IS_ENOENT</name><argument_list>(<argument><expr><name><name>err</name>-&gt;<name>apr_err</name></name></expr></argument>)</argument_list></call>
          &amp;&amp; ! <call><name>APR_STATUS_IS_ENOTDIR</name><argument_list>(<argument><expr><name><name>err</name>-&gt;<name>apr_err</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>err</name></expr>;</return></then></if>

      <comment type="block">/* nonexistent */</comment>
      <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>empty_p</name> = <name>TRUE</name></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{


      <comment type="block">/* If we remove props from a propfile, eventually the file will
         be empty, or, for working copies written by pre-1.3 libraries, will
         contain nothing but "END\n" */</comment>
      <if>if <condition>(<expr><name><name>finfo</name>.<name>filetype</name></name> == <name>APR_REG</name> &amp;&amp; (<name><name>finfo</name>.<name>size</name></name> == 4 || <name><name>finfo</name>.<name>size</name></name> == 0)</expr>)</condition><then>
        <expr_stmt><expr>*<name>empty_p</name> = <name>TRUE</name></expr>;</expr_stmt></then>
      <else>else
        <expr_stmt><expr>*<name>empty_p</name> = <name>FALSE</name></expr>;</expr_stmt></else></if>

      <comment type="block">/* If the size is between 1 and 4, then something is corrupt.
         If the size is between 4 and 16, then something is corrupt,
         because 16 is the -smallest- the file can possibly be if it
         contained only one property.  So long as we say it is "not
         empty", we will discover such corruption later when we try
         to read the properties from the file. */</comment>
    }</block></else></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Simple wrapper around empty_props_p, and inversed. */</comment>
<function><type><name>svn_error_t</name> *</type>
<name>svn_wc__has_props</name><parameter_list>(<param><decl><type><name>svn_boolean_t</name> *</type><name>has_props</name></decl></param>,
                  <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                  <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                  <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>is_empty</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>prop_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>entry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>has_propcaching</name> <init>=
    <expr><call><name>svn_wc__adm_wc_format</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>)</argument_list></call> &gt; <name>SVN_WC__NO_PROPCACHING_VERSION</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_entry</name><argument_list>(<argument><expr>&amp;<name>entry</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/*### Maybe assert (entry); calling svn_wc__has_props
    for an unversioned path is bogus */</comment>
  <if>if <condition>(<expr>! <name>entry</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr>*<name>has_props</name> = <name>FALSE</name></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>

  <comment type="block">/* Use the flag in the entry if the WC is recent enough. */</comment>
  <if>if <condition>(<expr><name>has_propcaching</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr>*<name>has_props</name> = <name><name>entry</name>-&gt;<name>has_props</name></name></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>

  <comment type="block">/* The rest is for compatibility with WCs that don't have propcaching. */</comment>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__prop_path</name><argument_list>(<argument><expr>&amp;<name>prop_path</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>entry</name>-&gt;<name>kind</name></name></expr></argument>,
                            <argument><expr><name>svn_wc__props_working</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>empty_props_p</name><argument_list>(<argument><expr>&amp;<name>is_empty</name></expr></argument>, <argument><expr><name>prop_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>is_empty</name></expr>)</condition><then>
    <expr_stmt><expr>*<name>has_props</name> = <name>FALSE</name></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr>*<name>has_props</name> = <name>TRUE</name></expr>;</expr_stmt></else></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Common implementation for svn_wc_props_modified_p()
   and svn_wc__props_modified().

   Set *MODIFIED_P to true if PATH's properties are modified
   with regard to the base revision, else set MODIFIED_P to false.

   If WHICH_PROPS is non-null and there are prop mods then set
   *WHICH_PROPS to a (const char *propname) -&gt;
   (const svn_string_t *propvalue) key:value mapping of only
   the modified properties. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>modified_props</name><parameter_list>(<param><decl><type><name>svn_boolean_t</name> *</type><name>modified_p</name></decl></param>,
               <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
               <param><decl><type><name>apr_hash_t</name> **</type><name>which_props</name></decl></param>,
               <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
               <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>prop_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>prop_base_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>entry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>wc_format</name> <init>= <expr><call><name>svn_wc__adm_wc_format</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>want_props</name> <init>= <expr><name>which_props</name> ? <name>TRUE</name> : <name>FALSE</name></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>want_props</name></expr>)</condition><then>
    <expr_stmt><expr>*<name>which_props</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_entry</name><argument_list>(<argument><expr>&amp;<name>entry</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If we have no entry, we can't have any prop mods. */</comment>
  <if>if <condition>(<expr>! <name>entry</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr>*<name>modified_p</name> = <name>FALSE</name></expr>;</expr_stmt>
      <goto>goto <name>cleanup</name>;</goto>
    }</block></then></if>

  <comment type="block">/* For newer WCs, if there is an entry for the path, we have a fast
   * and nice way to retrieve the information from the entry. */</comment>
  <if>if <condition>(<expr><name>wc_format</name> &gt; <name>SVN_WC__NO_PROPCACHING_VERSION</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* Only continue if there are prop mods
         and we want to know the details. */</comment>
      <expr_stmt><expr>*<name>modified_p</name> = <name><name>entry</name>-&gt;<name>has_prop_mods</name></name></expr>;</expr_stmt>
      <if>if <condition>(<expr>!*<name>modified_p</name> || !<name>want_props</name></expr>)</condition><then>
        <goto>goto <name>cleanup</name>;</goto></then></if>
    }</block></then></if>

  <comment type="block">/* So, we have a WC in an older format or we have propcaching
     but need to find the specific prop changes.  Either way we
     have some work to do... */</comment>

  <comment type="block">/* First, get the paths of the working and 'base' prop files. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__prop_path</name><argument_list>(<argument><expr>&amp;<name>prop_path</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>entry</name>-&gt;<name>kind</name></name></expr></argument>,
                            <argument><expr><name>svn_wc__props_working</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__prop_path</name><argument_list>(<argument><expr>&amp;<name>prop_base_path</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>entry</name>-&gt;<name>kind</name></name></expr></argument>,
                            <argument><expr><name>svn_wc__props_base</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check for numerous easy outs on older WC formats before we
     resort to svn_prop_diffs(). */</comment>
  <if>if <condition>(<expr><name>wc_format</name> &lt;= <name>SVN_WC__NO_PROPCACHING_VERSION</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>bempty</name></decl>, <decl><type ref="prev"/><name>wempty</name></decl>;</decl_stmt>
      <comment type="block">/* Decide if either path is "empty" of properties. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>empty_props_p</name><argument_list>(<argument><expr>&amp;<name>wempty</name></expr></argument>, <argument><expr><name>prop_path</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>empty_props_p</name><argument_list>(<argument><expr>&amp;<name>bempty</name></expr></argument>, <argument><expr><name>prop_base_path</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* If something is scheduled for replacement, we do *not* want to
         pay attention to any base-props;  they might be residual from the
         old deleted file. */</comment>
      <if>if <condition>(<expr><name><name>entry</name>-&gt;<name>schedule</name></name> == <name>svn_wc_schedule_replace</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr>*<name>modified_p</name> = <name>wempty</name> ? <name>FALSE</name> : <name>TRUE</name></expr>;</expr_stmt>

          <comment type="block">/* Only continue if there are prop mods
             and we want to know the details. */</comment>
          <if>if <condition>(<expr>!*<name>modified_p</name> || !<name>want_props</name></expr>)</condition><then>
            <goto>goto <name>cleanup</name>;</goto></then></if>
        }</block></then></if>

      <comment type="block">/* Easy out:  if the base file is empty, we know the answer
         immediately. */</comment>
      <if>if <condition>(<expr><name>bempty</name></expr>)</condition><then>
        <block>{
          <if>if <condition>(<expr>! <name>wempty</name></expr>)</condition><then>
            <block>{
              <comment type="block">/* base is empty, but working is not */</comment>
              <expr_stmt><expr>*<name>modified_p</name> = <name>TRUE</name></expr>;</expr_stmt>

              <comment type="block">/* Only continue if we want to know the details. */</comment>
              <if>if <condition>(<expr>!<name>want_props</name></expr>)</condition><then>
                <goto>goto <name>cleanup</name>;</goto></then></if>
            }</block></then>
          <else>else
            <block>{
              <comment type="block">/* base and working are both empty */</comment>
              <expr_stmt><expr>*<name>modified_p</name> = <name>FALSE</name></expr>;</expr_stmt>
              <goto>goto <name>cleanup</name>;</goto>
            }</block></else></if>
        }</block></then>
      <comment type="block">/* OK, so the base file is non-empty.  One more easy out: */</comment>
      <else>else <if>if <condition>(<expr><name>wempty</name></expr>)</condition><then>
        <block>{
          <comment type="block">/* base exists, working is empty */</comment>
          <expr_stmt><expr>*<name>modified_p</name> = <name>TRUE</name></expr>;</expr_stmt>

          <comment type="block">/* Only continue if we want to know the details. */</comment>
          <if>if <condition>(<expr>!<name>want_props</name></expr>)</condition><then>
            <goto>goto <name>cleanup</name>;</goto></then></if>
        }</block></then>
      <else>else
        <block>{
          <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>different_filesizes</name></decl>;</decl_stmt>

          <comment type="block">/* At this point, we know both files exists.  Therefore we have no
             choice but to start checking their contents. */</comment>

          <comment type="block">/* There are at least three tests we can try in succession. */</comment>

          <comment type="block">/* Easy-answer attempt #1:  (### this stat's the files again) */</comment>

          <comment type="block">/* Check if the local and prop-base file have *definitely*
             different filesizes. */</comment>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_filesizes_different_p</name><argument_list>(<argument><expr>&amp;<name>different_filesizes</name></expr></argument>,
                                               <argument><expr><name>prop_path</name></expr></argument>,
                                               <argument><expr><name>prop_base_path</name></expr></argument>,
                                               <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>different_filesizes</name></expr>)</condition><then>
            <block>{
              <expr_stmt><expr>*<name>modified_p</name> = <name>TRUE</name></expr>;</expr_stmt>

              <comment type="block">/* Only continue if we want to know the details. */</comment>
              <if>if <condition>(<expr>!<name>want_props</name></expr>)</condition><then>
                <goto>goto <name>cleanup</name>;</goto></then></if>
            }</block></then>
          <else>else
            <block>{
              <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>equal_timestamps</name></decl>;</decl_stmt>

              <comment type="block">/* Easy-answer attempt #2: (### this stat's the files again) */</comment>

              <comment type="block">/* See if the local file's prop timestamp is the same as the
                 one recorded in the administrative directory.  */</comment>
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__timestamps_equal_p</name><argument_list>(<argument><expr>&amp;<name>equal_timestamps</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
                                                 <argument><expr><name>adm_access</name></expr></argument>,
                                                 <argument><expr><name>svn_wc__prop_time</name></expr></argument>,
                                                 <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <if>if <condition>(<expr><name>equal_timestamps</name></expr>)</condition><then>
                <block>{
                  <expr_stmt><expr>*<name>modified_p</name> = <name>FALSE</name></expr>;</expr_stmt>
                  <goto>goto <name>cleanup</name>;</goto>
                }</block></then></if>
            }</block></else></if>
        }</block></else></if></else></if>
    }</block></then></if> <comment type="block">/* wc_format &lt;= SVN_WC__NO_PROPCACHING_VERSION */</comment>

  <comment type="block">/* If we get here, then we either known we have prop changes and want
     the specific changed props or we have a pre-propcaching WC version
     and still haven't figured out if we even have changes.  Regardless,
     our approach is the same in both cases.

     In the pre-propcaching case:

       We know that the filesizes are the same,
       but the timestamps are different.  That's still not enough
       evidence to make a correct decision;  we need to look at the
       files' contents directly.

       However, doing a byte-for-byte comparison won't work.  The two
       properties files may have the *exact* same name/value pairs, but
       arranged in a different order.  (Our hashdump format makes no
       guarantees about ordering.)

       Therefore, rather than use contents_identical_p(), we use
       svn_prop_diffs(). */</comment>
  <block>{
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>local_propchanges</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>localprops</name> <init>= <expr><call><name>apr_hash_make</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>baseprops</name> <init>= <expr><call><name>apr_hash_make</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* ### Amazingly, this stats the files again! */</comment>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>load_prop_file</name><argument_list>(<argument><expr><name>prop_path</name></expr></argument>, <argument><expr><name>localprops</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>load_prop_file</name><argument_list>(<argument><expr><name>prop_base_path</name></expr></argument>, <argument><expr><name>baseprops</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Don't use the subpool is we are hanging on to the changed props. */</comment>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_prop_diffs</name><argument_list>(<argument><expr>&amp;<name>local_propchanges</name></expr></argument>, <argument><expr><name>localprops</name></expr></argument>,
                           <argument><expr><name>baseprops</name></expr></argument>,
                           <argument><expr><name>want_props</name> ? <name>pool</name> : <name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name><name>local_propchanges</name>-&gt;<name>nelts</name></name> == 0</expr>)</condition><then>
      <block>{
        <expr_stmt><expr>*<name>modified_p</name> = <name>FALSE</name></expr>;</expr_stmt>
      }</block></then>
    <else>else
      <block>{
        <expr_stmt><expr>*<name>modified_p</name> = <name>TRUE</name></expr>;</expr_stmt>

        <comment type="block">/* Record the changed props if that's what we want. */</comment>
        <if>if <condition>(<expr><name>want_props</name></expr>)</condition><then>
          <block>{
            <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
            <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>local_propchanges</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
              <block>{
                <decl_stmt><decl><type><name>svn_prop_t</name> *</type><name>propt</name> <init>= <expr>&amp;<call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>local_propchanges</name></expr></argument>, <argument><expr><name>i</name></expr></argument>,
                                                   <argument><expr><name>svn_prop_t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr>*<name>which_props</name></expr></argument>, <argument><expr><name><name>propt</name>-&gt;<name>name</name></name></expr></argument>,
                             <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name><name>propt</name>-&gt;<name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              }</block></for>
           }</block></then></if>
      }</block></else></if>
  }</block>

 <label><name>cleanup</name>:</label>
  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_wc__props_modified</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                       <param><decl><type><name>apr_hash_t</name> **</type><name>which_props</name></decl></param>,
                       <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                       <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>modified_p</name></decl>;</decl_stmt>
  <return>return <expr><call><name>modified_props</name><argument_list>(<argument><expr>&amp;<name>modified_p</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>which_props</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_wc_props_modified_p</name><parameter_list>(<param><decl><type><name>svn_boolean_t</name> *</type><name>modified_p</name></decl></param>,
                        <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                        <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                        <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>modified_props</name><argument_list>(<argument><expr><name>modified_p</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_wc__has_prop_mods</name><parameter_list>(<param><decl><type><name>svn_boolean_t</name> *</type><name>prop_mods</name></decl></param>,
                      <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                      <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                      <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{

  <comment type="block">/* For an enough recent WC, we can have a really easy out. */</comment>
  <if>if <condition>(<expr><call><name>svn_wc__adm_wc_format</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>)</argument_list></call> &gt; <name>SVN_WC__NO_PROPCACHING_VERSION</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>entry</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__entry_versioned</name><argument_list>(<argument><expr>&amp;<name>entry</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>prop_mods</name> = <name><name>entry</name>-&gt;<name>has_prop_mods</name></name></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>propmods</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>localprops</name> <init>= <expr><call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>baseprops</name> <init>= <expr><call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <comment type="block">/* Load all properties into hashes */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__load_props</name><argument_list>(<argument><expr>&amp;<name>baseprops</name></expr></argument>, <argument><expr>&amp;<name>localprops</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                 <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Get an array of local changes by comparing the hashes. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_prop_diffs</name><argument_list>(<argument><expr>&amp;<name>propmods</name></expr></argument>, <argument><expr><name>localprops</name></expr></argument>, <argument><expr><name>baseprops</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr>*<name>prop_mods</name> = <name><name>propmods</name>-&gt;<name>nelts</name></name> &gt; 0</expr>;</expr_stmt>
    }</block></else></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_wc_get_prop_diffs</name><parameter_list>(<param><decl><type><name>apr_array_header_t</name> **</type><name>propchanges</name></decl></param>,
                      <param><decl><type><name>apr_hash_t</name> **</type><name>original_props</name></decl></param>,
                      <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                      <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                      <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>entry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>baseprops</name></decl>, *<decl><type ref="prev"/><name>props</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>entryname</name></decl>;</decl_stmt>

  <comment type="block">/*### Maybe assert (entry); calling svn_wc_get_prop_diffs
    for an unversioned path is bogus */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_entry</name><argument_list>(<argument><expr>&amp;<name>entry</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr>! <name>entry</name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr><name>original_props</name></expr>)</condition><then>
        <expr_stmt><expr>*<name>original_props</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

      <if>if <condition>(<expr><name>propchanges</name></expr>)</condition><then>
        <expr_stmt><expr>*<name>propchanges</name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>svn_prop_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>

  <if>if <condition>(<expr><name><name>entry</name>-&gt;<name>kind</name></name> == <name>svn_node_dir</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_adm_retrieve</name><argument_list>(<argument><expr>&amp;<name>adm_access</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>entryname</name> = <name>SVN_WC_ENTRY_THIS_DIR</name></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dirname</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>svn_path_split</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>&amp;<name>dirname</name></expr></argument>, <argument><expr>&amp;<name>entryname</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_adm_retrieve</name><argument_list>(<argument><expr>&amp;<name>adm_access</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>dirname</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__load_props</name><argument_list>(<argument><expr>&amp;<name>baseprops</name></expr></argument>, <argument><expr><name>propchanges</name> ? &amp;<name>props</name> : <name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>original_props</name> != <name>NULL</name></expr>)</condition><then>
    <expr_stmt><expr>*<name>original_props</name> = <name>baseprops</name></expr>;</expr_stmt></then></if>

  <if>if <condition>(<expr><name>propchanges</name> != <name>NULL</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_prop_diffs</name><argument_list>(<argument><expr><name>propchanges</name></expr></argument>, <argument><expr><name>props</name></expr></argument>, <argument><expr><name>baseprops</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<escape char="0xc"/>
<comment type="block">/** Externals **/</comment>

<comment type="block">/*
 * Look for either
 *
 *   -r N
 *   -rN
 *
 * in the LINE_PARTS array and update the revision field in ITEM with
 * the revision if the revision is found.  Set REV_IDX to the index in
 * LINE_PARTS where the revision specification starts.  Remove from
 * LINE_PARTS the element(s) that specify the revision.
 * PARENT_DIRECTORY_DISPLAY and LINE are given to return a nice error
 * string.
 *
 * If this function returns successfully, then LINE_PARTS will have
 * only two elements in it.
 */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>find_and_remove_externals_revision</name><parameter_list>(<param><decl><type><name>int</name> *</type><name>rev_idx</name></decl></param>,
                                   <param><decl><type><name>apr_array_header_t</name> *</type><name>line_parts</name></decl></param>,
                                   <param><decl><type><name>svn_wc_external_item2_t</name> *</type><name>item</name></decl></param>,
                                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>parent_directory_display</name></decl></param>,
                                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>line</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; 2</expr>;</condition> <incr><expr>++<name>i</name></expr></incr>)
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>token</name> <init>= <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>line_parts</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <if>if <condition>(<expr><name><name>token</name><index>[<expr>0</expr>]</index></name> == '-' &amp;&amp; <name><name>token</name><index>[<expr>1</expr>]</index></name> == 'r'</expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>digits_ptr</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>end_ptr</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>shift_count</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>;</decl_stmt>

          <expr_stmt><expr>*<name>rev_idx</name> = <name>i</name></expr>;</expr_stmt>

          <if>if <condition>(<expr><name><name>token</name><index>[<expr>2</expr>]</index></name> == '\0'</expr>)</condition><then>
            <block>{
              <comment type="block">/* There must be a total of four elements in the line if
                 -r N is used. */</comment>
              <if>if <condition>(<expr><name><name>line_parts</name>-&gt;<name>nelts</name></name> != 4</expr>)</condition><then>
                <goto>goto <name>parse_error</name>;</goto></then></if>

              <expr_stmt><expr><name>shift_count</name> = 2</expr>;</expr_stmt>
              <expr_stmt><expr><name>digits_ptr</name> = <call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>line_parts</name></expr></argument>, <argument><expr><name>i</name>+1</expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
          <else>else
            <block>{
              <comment type="block">/* There must be a total of three elements in the line
                 if -rN is used. */</comment>
              <if>if <condition>(<expr><name><name>line_parts</name>-&gt;<name>nelts</name></name> != 3</expr>)</condition><then>
                <goto>goto <name>parse_error</name>;</goto></then></if>

              <expr_stmt><expr><name>shift_count</name> = 1</expr>;</expr_stmt>
              <expr_stmt><expr><name>digits_ptr</name> = <name>token</name>+2</expr>;</expr_stmt>
            }</block></else></if>

          <expr_stmt><expr><name><name>item</name>-&gt;<name>revision</name>.<name>kind</name></name> = <name>svn_opt_revision_number</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_revnum_parse</name><argument_list>(<argument><expr>&amp;<name><name>item</name>-&gt;<name>revision</name>.<name>value</name>.<name>number</name></name></expr></argument>,
                                   <argument><expr><name>digits_ptr</name></expr></argument>,
                                   <argument><expr>&amp;<name>end_ptr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* If there's trailing garbage after the digits, then treat
             the revision as invalid. */</comment>
          <if>if <condition>(<expr>*<name>end_ptr</name> != '\0'</expr>)</condition><then>
            <goto>goto <name>parse_error</name>;</goto></then></if>

          <comment type="block">/* Shift any line elements past the revision specification
             down over the revision specification. */</comment>
          <for>for (<init><expr><name>j</name> = <name>i</name></expr>;</init> <condition><expr><name>j</name> &lt; <name><name>line_parts</name>-&gt;<name>nelts</name></name>-<name>shift_count</name></expr>;</condition> <incr><expr>++<name>j</name></expr></incr>)
            <expr_stmt><expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>line_parts</name></expr></argument>, <argument><expr><name>j</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call> =
              <call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>line_parts</name></expr></argument>, <argument><expr><name>j</name>+<name>shift_count</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt></for>
          <for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name>j</name> &lt; <name>shift_count</name></expr>;</condition> <incr><expr>++<name>j</name></expr></incr>)
            <expr_stmt><expr><call><name>apr_array_pop</name><argument_list>(<argument><expr><name>line_parts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>

          <comment type="block">/* Found the revision, so leave the function immediately, do
           * not continue looking for additional revisions. */</comment>
          <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
        }</block></then></if>
    }</block></for>

  <comment type="block">/* No revision was found, so there must be exactly two items in the
     line array. */</comment>
  <if>if <condition>(<expr><name><name>line_parts</name>-&gt;<name>nelts</name></name> == 2</expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

 <label><name>parse_error</name>:</label>
  <return>return <expr><call><name>svn_error_createf</name>
    <argument_list>(<argument><expr><name>SVN_ERR_CLIENT_INVALID_EXTERNALS_DESCRIPTION</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
     <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Error parsing %s property on '%s': '%s'"</expr></argument>)</argument_list></call></expr></argument>,
     <argument><expr><name>SVN_PROP_EXTERNALS</name></expr></argument>,
     <argument><expr><name>parent_directory_display</name></expr></argument>,
     <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_wc_parse_externals_description3</name><parameter_list>(<param><decl><type><name>apr_array_header_t</name> **</type><name>externals_p</name></decl></param>,
                                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>parent_directory</name></decl></param>,
                                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>desc</name></decl></param>,
                                    <param><decl><type><name>svn_boolean_t</name></type> <name>canonicalize_url</name></decl></param>,
                                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>lines</name> <init>= <expr><call><name>svn_cstring_split</name><argument_list>(<argument><expr><name>desc</name></expr></argument>, <argument><expr>"\n\r"</expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>parent_directory_display</name> <init>= <expr><call><name>svn_path_is_url</name><argument_list>(<argument><expr><name>parent_directory</name></expr></argument>)</argument_list></call> ?
    <name>parent_directory</name> : <call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>parent_directory</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>externals_p</name></expr>)</condition><then>
    <expr_stmt><expr>*<name>externals_p</name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>svn_wc_external_item2_t</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>lines</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>line</name> <init>= <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>lines</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>line_parts</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_wc_external_item2_t</name> *</type><name>item</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>token0</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>token1</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>token0_is_url</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>token1_is_url</name></decl>;</decl_stmt>

      <comment type="block">/* Index into line_parts where the revision specification
         started. */</comment>
      <decl_stmt><decl><type><name>int</name></type> <name>rev_idx</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>

      <if>if <condition>(<expr>(! <name>line</name>) || (<name><name>line</name><index>[<expr>0</expr>]</index></name> == '#')</expr>)</condition><then>
        <continue>continue;</continue></then></if>

      <comment type="block">/* else proceed */</comment>

      <expr_stmt><expr><name>line_parts</name> = <call><name>svn_cstring_split</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr>" \t"</expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_external_item_create</name>
              <argument_list>(<argument><expr>(const <name>svn_wc_external_item2_t</name> **) &amp;<name>item</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>item</name>-&gt;<name>revision</name>.<name>kind</name></name> = <name>svn_opt_revision_unspecified</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>item</name>-&gt;<name>peg_revision</name>.<name>kind</name></name> = <name>svn_opt_revision_unspecified</name></expr>;</expr_stmt>

      <comment type="block">/*
       * There are six different formats of externals:
       *
       * 1) DIR URL
       * 2) DIR -r N URL
       * 3) DIR -rN  URL
       * 4) URL DIR
       * 5) -r N URL DIR
       * 6) -rN URL DIR
       *
       * The last three allow peg revisions in the URL.
       *
       * With relative URLs and no '-rN' or '-r N', there is no way to
       * distinguish between 'DIR URL' and 'URL DIR' when URL is a
       * relative URL like /svn/repos/trunk, so this case is taken as
       * case 4).
       */</comment>
      <if>if <condition>(<expr><name><name>line_parts</name>-&gt;<name>nelts</name></name> &lt; 2 || <name><name>line_parts</name>-&gt;<name>nelts</name></name> &gt; 4</expr>)</condition><then>
        <return>return <expr><call><name>svn_error_createf</name>
          <argument_list>(<argument><expr><name>SVN_ERR_CLIENT_INVALID_EXTERNALS_DESCRIPTION</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
           <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Error parsing %s property on '%s': '%s'"</expr></argument>)</argument_list></call></expr></argument>,
           <argument><expr><name>SVN_PROP_EXTERNALS</name></expr></argument>,
           <argument><expr><name>parent_directory_display</name></expr></argument>,
           <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

      <comment type="block">/* To make it easy to check for the forms, find and remove -r N
         or -rN from the line item array.  If it is found, rev_idx
         contains the index into line_parts where '-r' was found and
         set item-&gt;revision to the parsed revision. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>find_and_remove_externals_revision</name><argument_list>(<argument><expr>&amp;<name>rev_idx</name></expr></argument>, <argument><expr><name>line_parts</name></expr></argument>, <argument><expr><name>item</name></expr></argument>,
                                                 <argument><expr><name>parent_directory_display</name></expr></argument>,
                                                 <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>token0</name> = <call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>line_parts</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>token1</name> = <call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>line_parts</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>token0_is_url</name> = <call><name>svn_path_is_url</name><argument_list>(<argument><expr><name>token0</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>token1_is_url</name> = <call><name>svn_path_is_url</name><argument_list>(<argument><expr><name>token1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* If -r is at the beginning of the line or the first token is
         an absolute URL or if the second token is not an absolute
         URL, then the URL supports peg revisions. */</comment>
      <if>if <condition>(<expr>0 == <name>rev_idx</name> || <name>token0_is_url</name> || ! <name>token1_is_url</name></expr>)</condition><then>
        <block>{
          <comment type="block">/* The URL is passed to svn_opt_parse_path in
             uncanonicalized form so that the scheme relative URL
             //hostname/foo is not collapsed to a server root relative
             URL /hostname/foo. */</comment>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_opt_parse_path</name><argument_list>(<argument><expr>&amp;<name><name>item</name>-&gt;<name>peg_revision</name></name></expr></argument>, <argument><expr>&amp;<name><name>item</name>-&gt;<name>url</name></name></expr></argument>,
                                     <argument><expr><name>token0</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>item</name>-&gt;<name>target_dir</name></name> = <name>token1</name></expr>;</expr_stmt>
        }</block></then>
      <else>else
        <block>{
          <expr_stmt><expr><name><name>item</name>-&gt;<name>target_dir</name></name> = <name>token0</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>item</name>-&gt;<name>url</name></name> = <name>token1</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>item</name>-&gt;<name>peg_revision</name></name> = <name><name>item</name>-&gt;<name>revision</name></name></expr>;</expr_stmt>
        }</block></else></if>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_opt_resolve_revisions</name><argument_list>(<argument><expr>&amp;<name><name>item</name>-&gt;<name>peg_revision</name></name></expr></argument>,
                                        <argument><expr>&amp;<name><name>item</name>-&gt;<name>revision</name></name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                                        <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name><name>item</name>-&gt;<name>target_dir</name></name> = <call><name>svn_path_canonicalize</name>
        <argument_list>(<argument><expr><call><name>svn_path_internal_style</name><argument_list>(<argument><expr><name><name>item</name>-&gt;<name>target_dir</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr><name><name>item</name>-&gt;<name>target_dir</name><index>[<expr>0</expr>]</index></name> == '\0' || <name><name>item</name>-&gt;<name>target_dir</name><index>[<expr>0</expr>]</index></name> == '/'
          || <call><name>svn_path_is_backpath_present</name><argument_list>(<argument><expr><name><name>item</name>-&gt;<name>target_dir</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><call><name>svn_error_createf</name>
          <argument_list>(<argument><expr><name>SVN_ERR_CLIENT_INVALID_EXTERNALS_DESCRIPTION</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
           <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Invalid %s property on '%s': "
             "target '%s' is an absolute path or involves '..'"</expr></argument>)</argument_list></call></expr></argument>,
           <argument><expr><name>SVN_PROP_EXTERNALS</name></expr></argument>,
           <argument><expr><name>parent_directory_display</name></expr></argument>,
           <argument><expr><name><name>item</name>-&gt;<name>target_dir</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>

      <if>if <condition>(<expr><name>canonicalize_url</name></expr>)</condition><then>
          <expr_stmt><expr><name><name>item</name>-&gt;<name>url</name></name> = <call><name>svn_path_canonicalize</name><argument_list>(<argument><expr><name><name>item</name>-&gt;<name>url</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

      <if>if <condition>(<expr><name>externals_p</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr>*<name>externals_p</name></expr></argument>, <argument><expr><name>svn_wc_external_item2_t</name> *</expr></argument>)</argument_list></call> = <name>item</name></expr>;</expr_stmt></then></if>
    }</block></for>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_wc_parse_externals_description2</name><parameter_list>(<param><decl><type><name>apr_array_header_t</name> **</type><name>externals_p</name></decl></param>,
                                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>parent_directory</name></decl></param>,
                                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>desc</name></decl></param>,
                                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>list</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_parse_externals_description3</name><argument_list>(<argument><expr><name>externals_p</name> ? &amp;<name>list</name> : <name>NULL</name></expr></argument>,
                                              <argument><expr><name>parent_directory</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>,
                                              <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>externals_p</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr>*<name>externals_p</name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>list</name>-&gt;<name>nelts</name></name></expr></argument>,
                                    <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>svn_wc_external_item_t</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>list</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
        <block>{
          <decl_stmt><decl><type><name>svn_wc_external_item2_t</name> *</type><name>item2</name> <init>= <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>i</name></expr></argument>,
                                             <argument><expr><name>svn_wc_external_item2_t</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>svn_wc_external_item_t</name> *</type><name>item</name> <init>= <expr><call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof <argument_list>(<argument><expr>*<name>item</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

          <if>if <condition>(<expr><name><name>item2</name>-&gt;<name>target_dir</name></name></expr>)</condition><then>
            <expr_stmt><expr><name><name>item</name>-&gt;<name>target_dir</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>item2</name>-&gt;<name>target_dir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
          <if>if <condition>(<expr><name><name>item2</name>-&gt;<name>url</name></name></expr>)</condition><then>
            <expr_stmt><expr><name><name>item</name>-&gt;<name>url</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>item2</name>-&gt;<name>url</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
          <expr_stmt><expr><name><name>item</name>-&gt;<name>revision</name></name> = <name><name>item2</name>-&gt;<name>revision</name></name></expr>;</expr_stmt>

          <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr>*<name>externals_p</name></expr></argument>, <argument><expr><name>svn_wc_external_item_t</name> *</expr></argument>)</argument_list></call> = <name>item</name></expr>;</expr_stmt>
        }</block></for>
    }</block></then></if>

  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_wc_parse_externals_description</name><parameter_list>(<param><decl><type><name>apr_hash_t</name> **</type><name>externals_p</name></decl></param>,
                                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>parent_directory</name></decl></param>,
                                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>desc</name></decl></param>,
                                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>list</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_parse_externals_description2</name><argument_list>(<argument><expr><name>externals_p</name> ? &amp;<name>list</name> : <name>NULL</name></expr></argument>,
                                              <argument><expr><name>parent_directory</name></expr></argument>, <argument><expr><name>desc</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Store all of the items into the hash if that was requested. */</comment>
  <if>if <condition>(<expr><name>externals_p</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr>*<name>externals_p</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>list</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
        <block>{
          <decl_stmt><decl><type><name>svn_wc_external_item_t</name> *</type><name>item</name></decl>;</decl_stmt>
          <expr_stmt><expr><name>item</name> = <call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>svn_wc_external_item_t</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr>*<name>externals_p</name></expr></argument>, <argument><expr><name><name>item</name>-&gt;<name>target_dir</name></name></expr></argument>,
                       <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
    }</block></then></if>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>svn_boolean_t</name></type>
<name>svn_wc__has_special_property</name><parameter_list>(<param><decl><type><name>apr_hash_t</name> *</type><name>props</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>apr_hash_get</name><argument_list>(<argument><expr><name>props</name></expr></argument>, <argument><expr><name>SVN_PROP_SPECIAL</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call> != <name>NULL</name></expr>;</return>
}</block></function>

<function><type><name>svn_boolean_t</name></type>
<name>svn_wc__has_magic_property</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>apr_array_header_t</name> *</type><name>properties</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>properties</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>svn_prop_t</name> *</type><name>property</name> <init>= <expr>&amp;<call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>properties</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>svn_prop_t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>property</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>SVN_PROP_EXECUTABLE</name></expr></argument>)</argument_list></call> == 0
          || <call><name>strcmp</name><argument_list>(<argument><expr><name><name>property</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>SVN_PROP_KEYWORDS</name></expr></argument>)</argument_list></call> == 0
          || <call><name>strcmp</name><argument_list>(<argument><expr><name><name>property</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>SVN_PROP_EOL_STYLE</name></expr></argument>)</argument_list></call> == 0
          || <call><name>strcmp</name><argument_list>(<argument><expr><name><name>property</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>SVN_PROP_SPECIAL</name></expr></argument>)</argument_list></call> == 0
          || <call><name>strcmp</name><argument_list>(<argument><expr><name><name>property</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>SVN_PROP_NEEDS_LOCK</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
        <return>return <expr><name>TRUE</name></expr>;</return></then></if>
    }</block></for>
  <return>return <expr><name>FALSE</name></expr>;</return>
}</block></function>
</unit>
