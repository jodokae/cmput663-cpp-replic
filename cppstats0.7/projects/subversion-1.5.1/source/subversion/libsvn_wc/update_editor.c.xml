<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/subversion-1.5.1/source/subversion/libsvn_wc/update_editor.c"><comment type="block">/*
 * update_editor.c :  main editor for checkouts and updates
 *
 * ====================================================================
 * Copyright (c) 2000-2007 CollabNet.  All rights reserved.
 *
 * This software is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at http://subversion.tigris.org/license-1.html.
 * If newer versions of this license are posted there, you may use a
 * newer version instead, at your option.
 *
 * This software consists of voluntary contributions made by many
 * individuals.  For exact contribution history, see the revision
 * history and logs, available at http://subversion.tigris.org/.
 * ====================================================================
 */</comment>


<escape char="0xc"/>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_pools.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_hash.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_md5.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_tables.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_file_io.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_strings.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_types.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_pools.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_delta.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_string.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_path.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_xml.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_error.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_io.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_md5.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_private_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_time.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_config.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"wc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"questions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"log.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"adm_files.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"adm_ops.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"entries.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"props.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"translate.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"private/svn_wc_private.h"</cpp:file></cpp:include>


<comment type="block">/** Forward declarations  **/</comment>

<function_decl><type><specifier>static</specifier> <name>svn_error_t</name> *</type><name>add_file_with_history</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                                          <param><decl><type><name>void</name> *</type><name>parent_baton</name></decl></param>,
                                          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copyfrom_path</name></decl></param>,
                                          <param><decl><type><name>svn_revnum_t</name></type> <name>copyfrom_rev</name></decl></param>,
                                          <param><decl><type><name>void</name> **</type><name>file_baton</name></decl></param>,
                                          <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>

<escape char="0xc"/>
<comment type="block">/*** batons ***/</comment>

<struct>struct <name>edit_baton</name>
<block>{
  <comment type="block">/* For updates, the "destination" of the edit is the ANCHOR (the
     directory at which the edit is rooted) plus the TARGET (the
     actual thing we wish to update).  For checkouts, ANCHOR holds the
     whole path, and TARGET is unused. */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>anchor</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>target</name></decl>;</decl_stmt>

  <comment type="block">/* ADM_ACCESS is an access baton that includes the ANCHOR directory */</comment>
  <decl_stmt><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl>;</decl_stmt>

  <comment type="block">/* Array of file extension patterns to preserve as extensions in
     generated conflict files. */</comment>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>ext_patterns</name></decl>;</decl_stmt>

  <comment type="block">/* The revision we're targeting...or something like that.  This
     starts off as a pointer to the revision to which we are updating,
     or SVN_INVALID_REVNUM, but by the end of the edit, should be
     pointing to the final revision. */</comment>
  <decl_stmt><decl><type><name>svn_revnum_t</name> *</type><name>target_revision</name></decl>;</decl_stmt>

  <comment type="block">/* The requested depth of this edit. */</comment>
  <decl_stmt><decl><type><name>svn_depth_t</name></type> <name>requested_depth</name></decl>;</decl_stmt>

  <comment type="block">/* Is the requested depth merely an operational limitation, or is
     also the new sticky ambient depth of the update target? */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>depth_is_sticky</name></decl>;</decl_stmt>

  <comment type="block">/* Need to know if the user wants us to overwrite the 'now' times on
     edited/added files with the last-commit-time. */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>use_commit_times</name></decl>;</decl_stmt>

  <comment type="block">/* Was the root actually opened (was this a non-empty edit)? */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>root_opened</name></decl>;</decl_stmt>

  <comment type="block">/* Was the update-target deleted?  This is a special situation. */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>target_deleted</name></decl>;</decl_stmt>

  <comment type="block">/* Allow unversioned obstructions when adding a path. */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>allow_unver_obstructions</name></decl>;</decl_stmt>

  <comment type="block">/* Non-null if this is a 'switch' operation. */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>switch_url</name></decl>;</decl_stmt>

  <comment type="block">/* The URL to the root of the repository, or NULL. */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>repos</name></decl>;</decl_stmt>

  <comment type="block">/* External diff3 to use for merges (can be null, in which case
     internal merge code is used). */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>diff3_cmd</name></decl>;</decl_stmt>

  <comment type="block">/* Object for gathering info to be accessed after the edit is
     complete. */</comment>
  <decl_stmt><decl><type><name>svn_wc_traversal_info_t</name> *</type><name>traversal_info</name></decl>;</decl_stmt>

  <comment type="block">/* This editor sends back notifications as it edits. */</comment>
  <decl_stmt><decl><type><name>svn_wc_notify_func2_t</name></type> <name>notify_func</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> *</type><name>notify_baton</name></decl>;</decl_stmt>

  <comment type="block">/* This editor is normally wrapped in a cancellation editor anyway,
     so it doesn't bother to check for cancellation itself.  However,
     it needs a cancel_func and cancel_baton available to pass to
     long-running functions. */</comment>
  <decl_stmt><decl><type><name>svn_cancel_func_t</name></type> <name>cancel_func</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> *</type><name>cancel_baton</name></decl>;</decl_stmt>

  <comment type="block">/* This editor will invoke a interactive conflict-resolution
     callback, if available. */</comment>
  <decl_stmt><decl><type><name>svn_wc_conflict_resolver_func_t</name></type> <name>conflict_func</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> *</type><name>conflict_baton</name></decl>;</decl_stmt>

  <comment type="block">/* If the server sends add_file(copyfrom=...) and we don't have the
     copyfrom file in the working copy, we use this callback to fetch
     it directly from the repository. */</comment>
  <decl_stmt><decl><type><name>svn_wc_get_file_t</name></type> <name>fetch_func</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> *</type><name>fetch_baton</name></decl>;</decl_stmt>

  <comment type="block">/* Paths that were skipped during the edit, and therefore shouldn't have
     their revision/url info updated at the end.
     The keys are pathnames and the values unspecified. */</comment>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>skipped_paths</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>
}</block>;</struct>


<struct>struct <name>dir_baton</name>
<block>{
  <comment type="block">/* The path to this directory. */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>

  <comment type="block">/* Basename of this directory. */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl>;</decl_stmt>

  <comment type="block">/* The repository URL this directory will correspond to. */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>new_URL</name></decl>;</decl_stmt>

  <comment type="block">/* The global edit baton. */</comment>
  <decl_stmt><decl><type>struct <name>edit_baton</name> *</type><name>edit_baton</name></decl>;</decl_stmt>

  <comment type="block">/* Baton for this directory's parent, or NULL if this is the root
     directory. */</comment>
  <decl_stmt><decl><type>struct <name>dir_baton</name> *</type><name>parent_baton</name></decl>;</decl_stmt>

  <comment type="block">/* Gets set iff this is a new directory that is not yet versioned and not
     yet in the parent's list of entries */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>added</name></decl>;</decl_stmt>

  <comment type="block">/* Set if an unversioned dir of the same name already existed in
     this directory. */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>existed</name></decl>;</decl_stmt>

  <comment type="block">/* Set if a dir of the same name already exists and is
     scheduled for addition without history. */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>add_existed</name></decl>;</decl_stmt>

  <comment type="block">/* An array of svn_prop_t structures, representing all the property
     changes to be applied to this directory. */</comment>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>propchanges</name></decl>;</decl_stmt>

  <comment type="block">/* The bump information for this directory. */</comment>
  <decl_stmt><decl><type>struct <name>bump_dir_info</name> *</type><name>bump_info</name></decl>;</decl_stmt>

  <comment type="block">/* The current log file number. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>log_number</name></decl>;</decl_stmt>

  <comment type="block">/* The current log buffer. The content of this accumulator may be
     flushed and run at any time (in pool cleanup), so only append
     complete sets of operations to it; you may need to build up a
     buffer of operations and append it atomically with
     svn_stringbuf_appendstr. */</comment>
  <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>log_accum</name></decl>;</decl_stmt>

  <comment type="block">/* The depth of the directory in the wc (or inferred if added).  Not
     used for filtering; we have a separate wrapping editor for that. */</comment>
  <decl_stmt><decl><type><name>svn_depth_t</name></type> <name>ambient_depth</name></decl>;</decl_stmt>

  <comment type="block">/* The pool in which this baton itself is allocated. */</comment>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>
}</block>;</struct>


<comment type="block">/* The bump information is tracked separately from the directory batons.
   This is a small structure kept in the edit pool, while the heavier
   directory baton is managed by the editor driver.

   In a postfix delta case, the directory batons are going to disappear.
   The files will refer to these structures, rather than the full
   directory baton.  */</comment>
<struct>struct <name>bump_dir_info</name>
<block>{
  <comment type="block">/* ptr to the bump information for the parent directory */</comment>
  <decl_stmt><decl><type>struct <name>bump_dir_info</name> *</type><name>parent</name></decl>;</decl_stmt>

  <comment type="block">/* how many entries are referring to this bump information? */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>ref_count</name></decl>;</decl_stmt>

  <comment type="block">/* the path of the directory to bump */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>

  <comment type="block">/* Set if this directory is skipped due to prop conflicts.
     This does NOT mean that children are skipped. */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>skipped</name></decl>;</decl_stmt>
}</block>;</struct>


<struct>struct <name>handler_baton</name>
<block>{
  <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>source</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>dest</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_txdelta_window_handler_t</name></type> <name>apply_handler</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> *</type><name>apply_baton</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>file_baton</name> *</type><name>fb</name></decl>;</decl_stmt>
}</block>;</struct>


<comment type="block">/* Return the url for NAME in DIR, allocated in POOL, or null if
 * unable to obtain a url.  If NAME is null, get the url for DIR.
 *
 * Use ASSOCIATED_ACCESS to retrieve an access baton for PATH, and do
 * all temporary allocation in POOL.
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type>
<name>get_entry_url</name><parameter_list>(<param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>associated_access</name></decl></param>,
              <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dir</name></decl></param>,
              <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>,
              <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>entry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>err</name> = <call><name>svn_wc_adm_retrieve</name><argument_list>(<argument><expr>&amp;<name>adm_access</name></expr></argument>, <argument><expr><name>associated_access</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr>! <name>err</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* Note that `name' itself may be NULL. */</comment>
      <expr_stmt><expr><name>err</name> = <call><name>svn_wc_entry</name><argument_list>(<argument><expr>&amp;<name>entry</name></expr></argument>, <argument><expr><call><name>svn_path_join_many</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>dir</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>,
                         <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  <if>if <condition>(<expr><name>err</name> || (! <name>entry</name>) || (! <name><name>entry</name>-&gt;<name>url</name></name>)</expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>NULL</name></expr>;</return>
    }</block></then></if>

  <return>return <expr><name><name>entry</name>-&gt;<name>url</name></name></expr>;</return>
}</block></function>

<comment type="block">/* Flush accumulated log entries to a log file on disk for DIR_BATON and
 * increase the log number of the dir baton.
 * Use POOL for temporary allocations. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>flush_log</name><parameter_list>(<param><decl><type>struct <name>dir_baton</name> *</type><name>db</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>! <call><name>svn_stringbuf_isempty</name><argument_list>(<argument><expr><name><name>db</name>-&gt;<name>log_accum</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_adm_retrieve</name><argument_list>(<argument><expr>&amp;<name>adm_access</name></expr></argument>, <argument><expr><name><name>db</name>-&gt;<name>edit_baton</name>-&gt;<name>adm_access</name></name></expr></argument>,
                                   <argument><expr><name><name>db</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__write_log</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name><name>db</name>-&gt;<name>log_number</name></name></expr></argument>, <argument><expr><name><name>db</name>-&gt;<name>log_accum</name></name></expr></argument>,
                                <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>db</name>-&gt;<name>log_number</name></name>++</expr>;</expr_stmt>
      <expr_stmt><expr><call><name>svn_stringbuf_setempty</name><argument_list>(<argument><expr><name><name>db</name>-&gt;<name>log_accum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* An APR pool cleanup handler.  This runs the log file for a
   directory baton. */</comment>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type>
<name>cleanup_dir_baton</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>dir_baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>dir_baton</name> *</type><name>db</name> <init>= <expr><name>dir_baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_status_t</name></type> <name>apr_err</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name> <init>= <expr><call><name>apr_pool_parent_get</name><argument_list>(<argument><expr><name><name>db</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>err</name> = <call><name>flush_log</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>! <name>err</name> &amp;&amp; <name><name>db</name>-&gt;<name>log_number</name></name> &gt; 0</expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>err</name> = <call><name>svn_wc_adm_retrieve</name><argument_list>(<argument><expr>&amp;<name>adm_access</name></expr></argument>, <argument><expr><name><name>db</name>-&gt;<name>edit_baton</name>-&gt;<name>adm_access</name></name></expr></argument>,
                                <argument><expr><name><name>db</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr>! <name>err</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>err</name> = <call><name>svn_wc__run_log</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <if>if <condition>(<expr>! <name>err</name></expr>)</condition><then>
            <return>return <expr><name>APR_SUCCESS</name></expr>;</return></then></if>
        }</block></then></if>
    }</block></then></if>

  <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
    <expr_stmt><expr><name>apr_err</name> = <name><name>err</name>-&gt;<name>apr_err</name></name></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name>apr_err</name> = <name>APR_SUCCESS</name></expr>;</expr_stmt></else></if>
  <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>apr_err</name></expr>;</return>
}</block></function>

<comment type="block">/* An APR pool cleanup handler.  This is a child handler, it removes
   the mail pool handler. */</comment>
<function><type><specifier>static</specifier> <name>apr_status_t</name></type>
<name>cleanup_dir_baton_child</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>dir_baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>dir_baton</name> *</type><name>db</name> <init>= <expr><name>dir_baton</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>apr_pool_cleanup_kill</name><argument_list>(<argument><expr><name><name>db</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name>cleanup_dir_baton</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>APR_SUCCESS</name></expr>;</return>
}</block></function>


<comment type="block">/* Return a new dir_baton to represent NAME (a subdirectory of
   PARENT_BATON).  If PATH is NULL, this is the root directory of the
   edit. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>make_dir_baton</name><parameter_list>(<param><decl><type>struct <name>dir_baton</name> **</type><name>d_p</name></decl></param>,
               <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
               <param><decl><type>struct <name>edit_baton</name> *</type><name>eb</name></decl></param>,
               <param><decl><type>struct <name>dir_baton</name> *</type><name>pb</name></decl></param>,
               <param><decl><type><name>svn_boolean_t</name></type> <name>added</name></decl></param>,
               <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>dir_baton</name> *</type><name>d</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>bump_dir_info</name> *</type><name>bdi</name></decl>;</decl_stmt>

  <comment type="block">/* Don't do this.  Just do NOT do this to me. */</comment>
  <if>if <condition>(<expr><name>pb</name> &amp;&amp; (! <name>path</name>)</expr>)</condition><then>
    <expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* Okay, no easy out, so allocate and initialize a dir baton. */</comment>
  <expr_stmt><expr><name>d</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>d</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Construct the PATH and baseNAME of this directory. */</comment>
  <expr_stmt><expr><name><name>d</name>-&gt;<name>path</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>eb</name>-&gt;<name>anchor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>path</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name><name>d</name>-&gt;<name>path</name></name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name><name>d</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>d</name>-&gt;<name>name</name></name> = <call><name>svn_path_basename</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <expr_stmt><expr><name><name>d</name>-&gt;<name>name</name></name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></else></if>

  <comment type="block">/* Figure out the new_URL for this directory. */</comment>
  <if>if <condition>(<expr><name><name>eb</name>-&gt;<name>switch_url</name></name></expr>)</condition><then>
    <block>{
      <comment type="block">/* Switches are, shall we say, complex.  If this directory is
         the root directory (it has no parent), then it either gets
         the SWITCH_URL for its own (if it is both anchor and target)
         or the parent of the SWITCH_URL (if it is anchor, but there's
         another target). */</comment>
      <if>if <condition>(<expr>! <name>pb</name></expr>)</condition><then>
        <block>{
          <if>if <condition>(<expr>! *<name><name>eb</name>-&gt;<name>target</name></name></expr>)</condition><then> <comment type="block">/* anchor is also target */</comment>
            <expr_stmt><expr><name><name>d</name>-&gt;<name>new_URL</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>eb</name>-&gt;<name>switch_url</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
          <else>else
            <expr_stmt><expr><name><name>d</name>-&gt;<name>new_URL</name></name> = <call><name>svn_path_dirname</name><argument_list>(<argument><expr><name><name>eb</name>-&gt;<name>switch_url</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
        }</block></then>
      <comment type="block">/* Else this directory is *not* the root (has a parent).  If it
         is the target (there is a target, and this directory has no
         grandparent), then it gets the SWITCH_URL for its own.
         Otherwise, it gets a child of its parent's URL. */</comment>
      <else>else
        <block>{
          <if>if <condition>(<expr>*<name><name>eb</name>-&gt;<name>target</name></name> &amp;&amp; (! <name><name>pb</name>-&gt;<name>parent_baton</name></name>)</expr>)</condition><then>
            <expr_stmt><expr><name><name>d</name>-&gt;<name>new_URL</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>eb</name>-&gt;<name>switch_url</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
          <else>else
            <expr_stmt><expr><name><name>d</name>-&gt;<name>new_URL</name></name> = <call><name>svn_path_url_add_component</name><argument_list>(<argument><expr><name><name>pb</name>-&gt;<name>new_URL</name></name></expr></argument>,
                                                    <argument><expr><name><name>d</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
        }</block></else></if>
    }</block></then>
  <else>else  <comment type="block">/* must be an update */</comment>
    <block>{
      <comment type="block">/* updates are the odds ones.  if we're updating a path already
         present on disk, we use its original URL.  otherwise, we'll
         telescope based on its parent's URL. */</comment>
      <expr_stmt><expr><name><name>d</name>-&gt;<name>new_URL</name></name> = <call><name>get_entry_url</name><argument_list>(<argument><expr><name><name>eb</name>-&gt;<name>adm_access</name></name></expr></argument>, <argument><expr><name><name>d</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr>(! <name><name>d</name>-&gt;<name>new_URL</name></name>) &amp;&amp; <name>pb</name></expr>)</condition><then>
        <expr_stmt><expr><name><name>d</name>-&gt;<name>new_URL</name></name> = <call><name>svn_path_url_add_component</name><argument_list>(<argument><expr><name><name>pb</name>-&gt;<name>new_URL</name></name></expr></argument>, <argument><expr><name><name>d</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></else></if>

  <comment type="block">/* the bump information lives in the edit pool */</comment>
  <expr_stmt><expr><name>bdi</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>eb</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>bdi</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>bdi</name>-&gt;<name>parent</name></name> = <name>pb</name> ? <name><name>pb</name>-&gt;<name>bump_info</name></name> : <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>bdi</name>-&gt;<name>ref_count</name></name> = 1</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>bdi</name>-&gt;<name>path</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>eb</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>d</name>-&gt;<name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>bdi</name>-&gt;<name>skipped</name></name> = <name>FALSE</name></expr>;</expr_stmt>

  <comment type="block">/* the parent's bump info has one more referer */</comment>
  <if>if <condition>(<expr><name>pb</name></expr>)</condition><then>
    <expr_stmt><expr>++<name><name>bdi</name>-&gt;<name>parent</name>-&gt;<name>ref_count</name></name></expr>;</expr_stmt></then></if>

  <expr_stmt><expr><name><name>d</name>-&gt;<name>edit_baton</name></name>   = <name>eb</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>d</name>-&gt;<name>parent_baton</name></name> = <name>pb</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>d</name>-&gt;<name>pool</name></name>         = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>d</name>-&gt;<name>propchanges</name></name>  = <call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>svn_prop_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>d</name>-&gt;<name>added</name></name>        = <name>added</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>d</name>-&gt;<name>existed</name></name>      = <name>FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>d</name>-&gt;<name>add_existed</name></name>  = <name>FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>d</name>-&gt;<name>bump_info</name></name>    = <name>bdi</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>d</name>-&gt;<name>log_number</name></name>   = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>d</name>-&gt;<name>log_accum</name></name>    = <call><name>svn_stringbuf_create</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* The caller of this function needs to fill this in. */</comment>
  <expr_stmt><expr><name><name>d</name>-&gt;<name>ambient_depth</name></name> = <name>svn_depth_unknown</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>apr_pool_cleanup_register</name><argument_list>(<argument><expr><name><name>d</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>d</name></expr></argument>, <argument><expr><name>cleanup_dir_baton</name></expr></argument>,
                            <argument><expr><name>cleanup_dir_baton_child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>d_p</name> = <name>d</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>



<comment type="block">/* Helper for maybe_bump_dir_info():

   In a single atomic action, (1) remove any 'deleted' entries from a
   directory, (2) remove any 'absent' entries whose revision numbers
   are different from the parent's new target revision, (3) remove any
   'missing' dir entries, and (4) remove the directory's 'incomplete'
   flag. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>complete_directory</name><parameter_list>(<param><decl><type>struct <name>edit_baton</name> *</type><name>eb</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                   <param><decl><type><name>svn_boolean_t</name></type> <name>is_root_dir</name></decl></param>,
                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>entries</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_wc_entry_t</name> *</type><name>entry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_wc_entry_t</name> *</type><name>current_entry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl>;</decl_stmt>

  <comment type="block">/* If this is the root directory and there is a target, we can't
     mark this directory complete. */</comment>
  <if>if <condition>(<expr><name>is_root_dir</name> &amp;&amp; *<name><name>eb</name>-&gt;<name>target</name></name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <comment type="block">/* All operations are on the in-memory entries hash. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_adm_retrieve</name><argument_list>(<argument><expr>&amp;<name>adm_access</name></expr></argument>, <argument><expr><name><name>eb</name>-&gt;<name>adm_access</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_entries_read</name><argument_list>(<argument><expr>&amp;<name>entries</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Mark THIS_DIR complete. */</comment>
  <expr_stmt><expr><name>entry</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>entries</name></expr></argument>, <argument><expr><name>SVN_WC_ENTRY_THIS_DIR</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>! <name>entry</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_ENTRY_NOT_FOUND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><call><name>_</name><argument_list>(<argument><expr>"No '.' entry in: '%s'"</expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
  <expr_stmt><expr><name><name>entry</name>-&gt;<name>incomplete</name></name> = <name>FALSE</name></expr>;</expr_stmt>

  <comment type="block">/* After a depth upgrade the entry must reflect the new depth.
     Upgrading to infinity changes the depth of *all* directories,
     upgrading to something else only changes the target. */</comment>
  <if>if <condition>(<expr><name><name>eb</name>-&gt;<name>depth_is_sticky</name></name> &amp;&amp;
      (<name><name>eb</name>-&gt;<name>requested_depth</name></name> == <name>svn_depth_infinity</name>
       || (<call><name>strcmp</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>svn_path_join</name><argument_list>(<argument><expr><name><name>eb</name>-&gt;<name>anchor</name></name></expr></argument>, <argument><expr><name><name>eb</name>-&gt;<name>target</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == 0
           &amp;&amp; <name><name>eb</name>-&gt;<name>requested_depth</name></name> &gt; <name><name>entry</name>-&gt;<name>depth</name></name>))</expr>)</condition><then>
    <expr_stmt><expr><name><name>entry</name>-&gt;<name>depth</name></name> = <name><name>eb</name>-&gt;<name>requested_depth</name></name></expr>;</expr_stmt></then></if>

  <comment type="block">/* Remove any deleted or missing entries. */</comment>
  <expr_stmt><expr><name>subpool</name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>entries</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>hi</name></expr>;</condition> <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>name</name> = <name>key</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>current_entry</name> = <name>val</name></expr>;</expr_stmt>

      <comment type="block">/* Any entry still marked as deleted (and not schedule add) can now
         be removed -- if it wasn't undeleted by the update, then it
         shouldn't stay in the updated working set.  Schedule add items
         should remain.
      */</comment>
      <if>if <condition>(<expr><name><name>current_entry</name>-&gt;<name>deleted</name></name></expr>)</condition><then>
        <block>{
          <if>if <condition>(<expr><name><name>current_entry</name>-&gt;<name>schedule</name></name> != <name>svn_wc_schedule_add</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>svn_wc__entry_remove</name><argument_list>(<argument><expr><name>entries</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
          <else>else
            <block>{
              <decl_stmt><decl><type><name>svn_wc_entry_t</name></type> <name>tmpentry</name></decl>;</decl_stmt>
              <expr_stmt><expr><name><name>tmpentry</name>.<name>deleted</name></name> = <name>FALSE</name></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__entry_modify</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name><name>current_entry</name>-&gt;<name>name</name></name></expr></argument>,
                                           <argument><expr>&amp;<name>tmpentry</name></expr></argument>,
                                           <argument><expr><name>SVN_WC__ENTRY_MODIFY_DELETED</name></expr></argument>,
                                           <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></then>
      <comment type="block">/* An absent entry might have been reconfirmed as absent, and the way
         we can tell is by looking at its revision number: a revision
         number different from the target revision of the update means the
         update never mentioned the item, so the entry should be
         removed. */</comment>
      <else>else <if>if <condition>(<expr><name><name>current_entry</name>-&gt;<name>absent</name></name>
               &amp;&amp; (<name><name>current_entry</name>-&gt;<name>revision</name></name> != *(<name><name>eb</name>-&gt;<name>target_revision</name></name>))</expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>svn_wc__entry_remove</name><argument_list>(<argument><expr><name>entries</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
      <else>else <if>if <condition>(<expr><name><name>current_entry</name>-&gt;<name>kind</name></name> == <name>svn_node_dir</name></expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>child_path</name> <init>= <expr><call><name>svn_path_join</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

          <if>if <condition>(<expr>(<call><name>svn_wc__adm_missing</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>child_path</name></expr></argument>)</argument_list></call>)
              &amp;&amp; (! <name><name>current_entry</name>-&gt;<name>absent</name></name>)
              &amp;&amp; (<name><name>current_entry</name>-&gt;<name>schedule</name></name> != <name>svn_wc_schedule_add</name>)</expr>)</condition><then>
            <block>{
              <expr_stmt><expr><call><name>svn_wc__entry_remove</name><argument_list>(<argument><expr><name>entries</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <if>if <condition>(<expr><name><name>eb</name>-&gt;<name>notify_func</name></name></expr>)</condition><then>
                <block>{
                  <decl_stmt><decl><type><name>svn_wc_notify_t</name> *</type><name>notify</name>
                    <init>= <expr><call><name>svn_wc_create_notify</name><argument_list>(<argument><expr><name>child_path</name></expr></argument>,
                                           <argument><expr><name>svn_wc_notify_update_delete</name></expr></argument>,
                                           <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
                  <expr_stmt><expr><name><name>notify</name>-&gt;<name>kind</name></name> = <name><name>current_entry</name>-&gt;<name>kind</name></name></expr>;</expr_stmt>
                  <expr_stmt><expr><call>(* <name><name>eb</name>-&gt;<name>notify_func</name></name>)<argument_list>(<argument><expr><name><name>eb</name>-&gt;<name>notify_baton</name></name></expr></argument>, <argument><expr><name>notify</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then></if>
            }</block></then></if>
        }</block></then></if></else></if></else></if>
    }</block></for>

  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* An atomic write of the whole entries file. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__entries_write</name><argument_list>(<argument><expr><name>entries</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>



<comment type="block">/* Decrement the bump_dir_info's reference count. If it hits zero,
   then this directory is "done". This means it is safe to remove the
   'incomplete' flag attached to the THIS_DIR entry.

   In addition, when the directory is "done", we loop onto the parent's
   bump information to possibly mark it as done, too.
*/</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>maybe_bump_dir_info</name><parameter_list>(<param><decl><type>struct <name>edit_baton</name> *</type><name>eb</name></decl></param>,
                    <param><decl><type>struct <name>bump_dir_info</name> *</type><name>bdi</name></decl></param>,
                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* Keep moving up the tree of directories until we run out of parents,
     or a directory is not yet "done".  */</comment>
  <for>for ( <init>;</init> <condition><expr><name>bdi</name> != <name>NULL</name></expr>;</condition> <incr><expr><name>bdi</name> = <name><name>bdi</name>-&gt;<name>parent</name></name></expr></incr>)
    <block>{
      <if>if <condition>(<expr>--<name><name>bdi</name>-&gt;<name>ref_count</name></name> &gt; 0</expr>)</condition><then>
        <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>    <comment type="block">/* directory isn't done yet */</comment>

      <comment type="block">/* The refcount is zero, so we remove any 'dead' entries from
         the directory and mark it 'complete'.  */</comment>
      <if>if <condition>(<expr>! <name><name>bdi</name>-&gt;<name>skipped</name></name></expr>)</condition><then>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>complete_directory</name><argument_list>(<argument><expr><name>eb</name></expr></argument>, <argument><expr><name><name>bdi</name>-&gt;<name>path</name></name></expr></argument>,
                                   <argument><expr><name><name>bdi</name>-&gt;<name>parent</name></name> ? <name>FALSE</name> : <name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></for>
  <comment type="block">/* we exited the for loop because there are no more parents */</comment>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<struct>struct <name>file_baton</name>
<block>{
  <comment type="block">/* The global edit baton. */</comment>
  <decl_stmt><decl><type>struct <name>edit_baton</name> *</type><name>edit_baton</name></decl>;</decl_stmt>

  <comment type="block">/* The parent directory of this file. */</comment>
  <decl_stmt><decl><type>struct <name>dir_baton</name> *</type><name>dir_baton</name></decl>;</decl_stmt>

  <comment type="block">/* Pool specific to this file_baton. */</comment>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>

  <comment type="block">/* Name of this file (its entry in the directory). */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl>;</decl_stmt>

  <comment type="block">/* Path to this file, either abs or relative to the change-root. */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>

  <comment type="block">/* The repository URL this file will correspond to. */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>new_URL</name></decl>;</decl_stmt>

  <comment type="block">/* Set if this file is new. */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>added</name></decl>;</decl_stmt>

  <comment type="block">/* Set if this file is new with history. */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>added_with_history</name></decl>;</decl_stmt>

  <comment type="block">/* Set if this file is skipped because it was in conflict. */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>skipped</name></decl>;</decl_stmt>

  <comment type="block">/* Set if an unversioned file of the same name already existed in
     this directory. */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>existed</name></decl>;</decl_stmt>

  <comment type="block">/* Set if a file of the same name already exists and is
     scheduled for addition without history. */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>add_existed</name></decl>;</decl_stmt>

  <comment type="block">/* The path to the current text base, if any.
     This gets set if there are file content changes. */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>text_base_path</name></decl>;</decl_stmt>

  <comment type="block">/* This gets set if the file underwent a text change, which guides
     the code that syncs up the adm dir and working copy. */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>new_text_base_path</name></decl>;</decl_stmt>

  <comment type="block">/* If this file was added with history, this is the path to a copy
     of the text base of the copyfrom file (in the temporary area). */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copied_text_base</name></decl>;</decl_stmt>

  <comment type="block">/* If this file was added with history, and the copyfrom had local
     mods, this is the path to a copy of the user's version with local
     mods (in the temporary area). */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copied_working_text</name></decl>;</decl_stmt>

  <comment type="block">/* If this file was added with history, this hash contains the base
     properties of the copied file. */</comment>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>copied_base_props</name></decl>;</decl_stmt>

  <comment type="block">/* If this file was added with history, this hash contains the working
     properties of the copied file. */</comment>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>copied_working_props</name></decl>;</decl_stmt>

  <comment type="block">/* Set if we've received an apply_textdelta for this file. */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>received_textdelta</name></decl>;</decl_stmt>

  <comment type="block">/* An array of svn_prop_t structures, representing all the property
     changes to be applied to this file. */</comment>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>propchanges</name></decl>;</decl_stmt>

  <comment type="block">/* The last-changed-date of the file.  This is actually a property
     that comes through as an 'entry prop', and will be used to set
     the working file's timestamp if it's added.  */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>last_changed_date</name></decl>;</decl_stmt>

  <comment type="block">/* Bump information for the directory this file lives in */</comment>
  <decl_stmt><decl><type>struct <name>bump_dir_info</name> *</type><name>bump_info</name></decl>;</decl_stmt>

  <comment type="block">/* This is initialized to all zeroes when the baton is created, then
     populated with the MD5 digest of the resultant fulltext after the
     last window is handled by the handler returned from
     apply_textdelta(). */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>digest</name><index>[<expr><name>APR_MD5_DIGESTSIZE</name></expr>]</index></name></decl>;</decl_stmt>
}</block>;</struct>


<comment type="block">/* Make a new file baton in the provided POOL, with PB as the parent baton.
   PATH is relative to the root of the edit. */</comment>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>make_file_baton</name><parameter_list>(<param><decl><type>struct <name>file_baton</name> **</type><name>f_p</name></decl></param>,
                <param><decl><type>struct <name>dir_baton</name> *</type><name>pb</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                <param><decl><type><name>svn_boolean_t</name></type> <name>adding</name></decl></param>,
                <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>file_baton</name> *</type><name>f</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>f</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="block">/* I rather need this information, yes. */</comment>
  <if>if <condition>(<expr>! <name>path</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* Make the file's on-disk name. */</comment>
  <expr_stmt><expr><name><name>f</name>-&gt;<name>path</name></name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name><name>pb</name>-&gt;<name>edit_baton</name>-&gt;<name>anchor</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>f</name>-&gt;<name>name</name></name> = <call><name>svn_path_basename</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Figure out the new_URL for this file. */</comment>
  <if>if <condition>(<expr><name><name>pb</name>-&gt;<name>edit_baton</name>-&gt;<name>switch_url</name></name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name><name>f</name>-&gt;<name>new_URL</name></name> = <call><name>svn_path_url_add_component</name><argument_list>(<argument><expr><name><name>pb</name>-&gt;<name>new_URL</name></name></expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <expr_stmt><expr><name><name>f</name>-&gt;<name>new_URL</name></name> = <call><name>get_entry_url</name><argument_list>(<argument><expr><name><name>pb</name>-&gt;<name>edit_baton</name>-&gt;<name>adm_access</name></name></expr></argument>,
                                 <argument><expr><name><name>pb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name><name>f</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

  <expr_stmt><expr><name><name>f</name>-&gt;<name>pool</name></name>              = <name>pool</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>f</name>-&gt;<name>edit_baton</name></name>        = <name><name>pb</name>-&gt;<name>edit_baton</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>f</name>-&gt;<name>propchanges</name></name>       = <call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>svn_prop_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>f</name>-&gt;<name>bump_info</name></name>         = <name><name>pb</name>-&gt;<name>bump_info</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>f</name>-&gt;<name>added</name></name>             = <name>adding</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>f</name>-&gt;<name>existed</name></name>           = <name>FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>f</name>-&gt;<name>add_existed</name></name>       = <name>FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>f</name>-&gt;<name>dir_baton</name></name>         = <name>pb</name></expr>;</expr_stmt>

  <comment type="block">/* No need to initialize f-&gt;digest, since we used pcalloc(). */</comment>

  <comment type="block">/* the directory's bump info has one more referer now */</comment>
  <expr_stmt><expr>++<name><name>f</name>-&gt;<name>bump_info</name>-&gt;<name>ref_count</name></name></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>f_p</name> = <name>f</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<escape char="0xc"/>
<comment type="block">/*** Helpers for the editor callbacks. ***/</comment>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>window_handler</name><parameter_list>(<param><decl><type><name>svn_txdelta_window_t</name> *</type><name>window</name></decl></param>, <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>handler_baton</name> *</type><name>hb</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>file_baton</name> *</type><name>fb</name> <init>= <expr><name><name>hb</name>-&gt;<name>fb</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>, *<decl><type ref="prev"/><name>err2</name></decl>;</decl_stmt>

  <comment type="block">/* Apply this window.  We may be done at that point.  */</comment>
  <expr_stmt><expr><name>err</name> = <call><name><name>hb</name>-&gt;<name>apply_handler</name></name><argument_list>(<argument><expr><name>window</name></expr></argument>, <argument><expr><name><name>hb</name>-&gt;<name>apply_baton</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>window</name> != <name>NULL</name> &amp;&amp; !<name>err</name></expr>)</condition><then>
    <return>return <expr><name>err</name></expr>;</return></then></if>

  <comment type="block">/* Either we're done (window is NULL) or we had an error.  In either
     case, clean up the handler.  */</comment>
  <if>if <condition>(<expr><name><name>hb</name>-&gt;<name>source</name></name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr><name><name>fb</name>-&gt;<name>copied_text_base</name></name></expr>)</condition><then>
        <expr_stmt><expr><name>err2</name> = <call><name>svn_io_file_close</name><argument_list>(<argument><expr><name><name>hb</name>-&gt;<name>source</name></name></expr></argument>, <argument><expr><name><name>hb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
      <else>else
        <expr_stmt><expr><name>err2</name> = <call><name>svn_wc__close_text_base</name><argument_list>(<argument><expr><name><name>hb</name>-&gt;<name>source</name></name></expr></argument>, <argument><expr><name><name>fb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>hb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

      <if>if <condition>(<expr><name>err2</name> &amp;&amp; !<name>err</name></expr>)</condition><then>
        <expr_stmt><expr><name>err</name> = <name>err2</name></expr>;</expr_stmt></then>
      <else>else
        <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
    }</block></then></if>
  <expr_stmt><expr><name>err2</name> = <call><name>svn_wc__close_text_base</name><argument_list>(<argument><expr><name><name>hb</name>-&gt;<name>dest</name></name></expr></argument>, <argument><expr><name><name>fb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>hb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>err2</name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr>!<name>err</name></expr>)</condition><then>
        <expr_stmt><expr><name>err</name> = <name>err2</name></expr>;</expr_stmt></then>
      <else>else
        <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
    }</block></then></if>

  <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* We failed to apply the delta; clean up the temporary file.  */</comment>
      <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><call><name>svn_io_remove_file</name><argument_list>(<argument><expr><name><name>fb</name>-&gt;<name>new_text_base_path</name></name></expr></argument>, <argument><expr><name><name>hb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>fb</name>-&gt;<name>new_text_base_path</name></name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></then></if>

  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name><name>hb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>err</name></expr>;</return>
}</block></function>


<comment type="block">/* Prepare directory for dir_baton DB for updating or checking out.
 * Give it depth DEPTH.
 *
 * If the path already exists, but is not a working copy for
 * ANCESTOR_URL and ANCESTOR_REVISION, then an error will be returned.
 */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>prep_directory</name><parameter_list>(<param><decl><type>struct <name>dir_baton</name> *</type><name>db</name></decl></param>,
               <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ancestor_url</name></decl></param>,
               <param><decl><type><name>svn_revnum_t</name></type> <name>ancestor_revision</name></decl></param>,
               <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>repos</name></decl>;</decl_stmt>

  <comment type="block">/* Make sure the directory exists. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__ensure_directory</name><argument_list>(<argument><expr><name><name>db</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Use the repository root of the anchor, but only if it actually is an
     ancestor of the URL of this directory. */</comment>
  <if>if <condition>(<expr><name><name>db</name>-&gt;<name>edit_baton</name>-&gt;<name>repos</name></name>
      &amp;&amp; <call><name>svn_path_is_ancestor</name><argument_list>(<argument><expr><name><name>db</name>-&gt;<name>edit_baton</name>-&gt;<name>repos</name></name></expr></argument>, <argument><expr><name>ancestor_url</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <expr_stmt><expr><name>repos</name> = <name><name>db</name>-&gt;<name>edit_baton</name>-&gt;<name>repos</name></name></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name>repos</name> = <name>NULL</name></expr>;</expr_stmt></else></if>

  <comment type="block">/* Make sure it's the right working copy, either by creating it so,
     or by checking that it is so already. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_ensure_adm3</name><argument_list>(<argument><expr><name><name>db</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><name>ancestor_url</name></expr></argument>, <argument><expr><name>repos</name></expr></argument>,
                             <argument><expr><name>ancestor_revision</name></expr></argument>, <argument><expr><name><name>db</name>-&gt;<name>ambient_depth</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr>! <name><name>db</name>-&gt;<name>edit_baton</name>-&gt;<name>adm_access</name></name>
      || <call><name>strcmp</name><argument_list>(<argument><expr><call><name>svn_wc_adm_access_path</name><argument_list>(<argument><expr><name><name>db</name>-&gt;<name>edit_baton</name>-&gt;<name>adm_access</name></name></expr></argument>)</argument_list></call></expr></argument>,
                <argument><expr><name><name>db</name>-&gt;<name>path</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>adm_access_pool</name>
        <init>= <expr><name><name>db</name>-&gt;<name>edit_baton</name>-&gt;<name>adm_access</name></name>
        ? <call><name>svn_wc_adm_access_pool</name><argument_list>(<argument><expr><name><name>db</name>-&gt;<name>edit_baton</name>-&gt;<name>adm_access</name></name></expr></argument>)</argument_list></call>
        : <name><name>db</name>-&gt;<name>edit_baton</name>-&gt;<name>pool</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name> <init>= <expr><call><name>svn_wc_adm_open3</name><argument_list>(<argument><expr>&amp;<name>adm_access</name></expr></argument>,
                                          <argument><expr><name><name>db</name>-&gt;<name>edit_baton</name>-&gt;<name>adm_access</name></name></expr></argument>,
                                          <argument><expr><name><name>db</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                          <argument><expr><name>adm_access_pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <comment type="block">/* db-&gt;path may be scheduled for addition without history.
         In that case db-&gt;edit_baton-&gt;adm_access already has it locked. */</comment>
      <if>if <condition>(<expr><name>err</name> &amp;&amp; <name><name>err</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_WC_LOCKED</name></expr>)</condition><then>
        <block>{
           <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
           <expr_stmt><expr><name>err</name> = <call><name>svn_wc_adm_retrieve</name><argument_list>(<argument><expr>&amp;<name>adm_access</name></expr></argument>,
                                     <argument><expr><name><name>db</name>-&gt;<name>edit_baton</name>-&gt;<name>adm_access</name></name></expr></argument>,
                                     <argument><expr><name><name>db</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>adm_access_pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr>!<name><name>db</name>-&gt;<name>edit_baton</name>-&gt;<name>adm_access</name></name></expr>)</condition><then>
        <expr_stmt><expr><name><name>db</name>-&gt;<name>edit_baton</name>-&gt;<name>adm_access</name></name> = <name>adm_access</name></expr>;</expr_stmt></then></if>
    }</block></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Accumulate tags in LOG_ACCUM to set ENTRY_PROPS for PATH.
   ENTRY_PROPS is an array of svn_prop_t* entry props.
   If ENTRY_PROPS contains the removal of a lock token, all entryprops
   related to a lock will be removed and LOCK_STATE, if non-NULL, will be
   set to svn_wc_notify_lock_state_unlocked.  Else, LOCK_STATE, if non-NULL
   will be set to svn_wc_lock_state_unchanged. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>accumulate_entry_props</name><parameter_list>(<param><decl><type><name>svn_stringbuf_t</name> *</type><name>log_accum</name></decl></param>,
                       <param><decl><type><name>svn_wc_notify_lock_state_t</name> *</type><name>lock_state</name></decl></param>,
                       <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                       <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                       <param><decl><type><name>apr_array_header_t</name> *</type><name>entry_props</name></decl></param>,
                       <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_wc_entry_t</name></type> <name>tmp_entry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_uint64_t</name></type> <name>flags</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>lock_state</name></expr>)</condition><then>
    <expr_stmt><expr>*<name>lock_state</name> = <name>svn_wc_notify_lock_state_unchanged</name></expr>;</expr_stmt></then></if>

  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>entry_props</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>)
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>svn_prop_t</name> *</type><name>prop</name> <init>= <expr>&amp;<call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>entry_props</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>svn_prop_t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>val</name></decl>;</decl_stmt>

      <comment type="block">/* The removal of the lock-token entryprop means that the lock was
         defunct. */</comment>
      <if>if <condition>(<expr>! <call><name>strcmp</name><argument_list>(<argument><expr><name><name>prop</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>SVN_PROP_ENTRY_LOCK_TOKEN</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_delete_lock</name>
                  <argument_list>(<argument><expr>&amp;<name>log_accum</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <if>if <condition>(<expr><name>lock_state</name></expr>)</condition><then>
            <expr_stmt><expr>*<name>lock_state</name> = <name>svn_wc_notify_lock_state_unlocked</name></expr>;</expr_stmt></then></if>
          <continue>continue;</continue>
        }</block></then></if>
      <comment type="block">/* A prop value of NULL means the information was not
         available.  We don't remove this field from the entries
         file; we have convention just leave it empty.  So let's
         just skip those entry props that have no values. */</comment>
      <if>if <condition>(<expr>! <name><name>prop</name>-&gt;<name>value</name></name></expr>)</condition><then>
        <continue>continue;</continue></then></if>

      <expr_stmt><expr><name>val</name> = <name><name>prop</name>-&gt;<name>value</name>-&gt;<name>data</name></name></expr>;</expr_stmt>

      <if>if <condition>(<expr>! <call><name>strcmp</name><argument_list>(<argument><expr><name><name>prop</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>SVN_PROP_ENTRY_LAST_AUTHOR</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>flags</name> |= <name>SVN_WC__ENTRY_MODIFY_CMT_AUTHOR</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>tmp_entry</name>.<name>cmt_author</name></name> = <name>val</name></expr>;</expr_stmt>
        }</block></then>
      <else>else <if>if <condition>(<expr>! <call><name>strcmp</name><argument_list>(<argument><expr><name><name>prop</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>SVN_PROP_ENTRY_COMMITTED_REV</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>flags</name> |= <name>SVN_WC__ENTRY_MODIFY_CMT_REV</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>tmp_entry</name>.<name>cmt_rev</name></name> = <call><name>SVN_STR_TO_REV</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
      <else>else <if>if <condition>(<expr>! <call><name>strcmp</name><argument_list>(<argument><expr><name><name>prop</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>SVN_PROP_ENTRY_COMMITTED_DATE</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>flags</name> |= <name>SVN_WC__ENTRY_MODIFY_CMT_DATE</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_time_from_cstring</name><argument_list>(<argument><expr>&amp;<name><name>tmp_entry</name>.<name>cmt_date</name></name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
      <else>else <if>if <condition>(<expr>! <call><name>strcmp</name><argument_list>(<argument><expr><name><name>prop</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>SVN_PROP_ENTRY_UUID</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>flags</name> |= <name>SVN_WC__ENTRY_MODIFY_UUID</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>tmp_entry</name>.<name>uuid</name></name> = <name>val</name></expr>;</expr_stmt>
        }</block></then></if></else></if></else></if></else></if>
    }</block></for>

  <if>if <condition>(<expr><name>flags</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_entry_modify</name><argument_list>(<argument><expr>&amp;<name>log_accum</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
                                       <argument><expr>&amp;<name>tmp_entry</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Accumulate tags in LOG_ACCUM to set WCPROPS for PATH.  WCPROPS is
   an array of svn_prop_t* wc props. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>accumulate_wcprops</name><parameter_list>(<param><decl><type><name>svn_stringbuf_t</name> *</type><name>log_accum</name></decl></param>,
                   <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                   <param><decl><type><name>apr_array_header_t</name> *</type><name>wcprops</name></decl></param>,
                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <comment type="block">/* ### The log file will rewrite the props file for each property :( It
     ### would be better if all the changes could be combined into one
     ### write. */</comment>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>wcprops</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>)
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>svn_prop_t</name> *</type><name>prop</name> <init>= <expr>&amp;<call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>wcprops</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>svn_prop_t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_modify_wcprop</name>
              <argument_list>(<argument><expr>&amp;<name>log_accum</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
               <argument><expr><name><name>prop</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name><name>prop</name>-&gt;<name>value</name></name> ? <name><name>prop</name>-&gt;<name>value</name>-&gt;<name>data</name></name> : <name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Check that when ADD_PATH is joined to BASE_PATH, the resulting path
 * is still under BASE_PATH in the local filesystem.  If not, return
 * SVN_ERR_WC_OBSTRUCTED_UPDATE; else return success.
 *
 * This is to prevent the situation where the repository contains,
 * say, "..\nastyfile".  Although that's perfectly legal on some
 * systems, when checked out onto Win32 it would cause "nastyfile" to
 * be created in the parent of the current edit directory.
 *
 * (http://cve.mitre.org/cgi-bin/cvename.cgi?name=2007-3846)
 */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>check_path_under_root</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>base_path</name></decl></param>,
                      <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>add_path</name></decl></param>,
                      <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>char</name> *</type><name>full_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_status_t</name></type> <name>path_status</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>path_status</name> = <call><name>apr_filepath_merge</name>
    <argument_list>(<argument><expr>&amp;<name>full_path</name></expr></argument>, <argument><expr><name>base_path</name></expr></argument>, <argument><expr><name>add_path</name></expr></argument>,
     <argument><expr><name>APR_FILEPATH_NOTABOVEROOT</name> | <name>APR_FILEPATH_SECUREROOTTEST</name></expr></argument>,
     <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>path_status</name> != <name>APR_SUCCESS</name></expr>)</condition><then>
    <block>{
      <return>return <expr><call><name>svn_error_createf</name>
        <argument_list>(<argument><expr><name>SVN_ERR_WC_OBSTRUCTED_UPDATE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
         <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Path '%s' is not in the working copy"</expr></argument>)</argument_list></call></expr></argument>,
         <comment type="block">/* Not using full_path here because it might be NULL or
            undefined, since apr_filepath_merge() returned error.
            (Pity we can't pass NULL for &amp;full_path in the first place,
            but the APR docs don't bless that.) */</comment>
         <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><call><name>svn_path_join</name><argument_list>(<argument><expr><name>base_path</name></expr></argument>, <argument><expr><name>add_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<escape char="0xc"/>
<comment type="block">/*** The callbacks we'll plug into an svn_delta_editor_t structure. ***/</comment>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>set_target_revision</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>edit_baton</name></decl></param>,
                    <param><decl><type><name>svn_revnum_t</name></type> <name>target_revision</name></decl></param>,
                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>edit_baton</name> *</type><name>eb</name> <init>= <expr><name>edit_baton</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Stashing a target_revision in the baton */</comment>
  <expr_stmt><expr>*(<name><name>eb</name>-&gt;<name>target_revision</name></name>) = <name>target_revision</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>open_root</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>edit_baton</name></decl></param>,
          <param><decl><type><name>svn_revnum_t</name></type> <name>base_revision</name></decl></param>, <comment type="block">/* This is ignored in co */</comment>
          <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
          <param><decl><type><name>void</name> **</type><name>dir_baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>edit_baton</name> *</type><name>eb</name> <init>= <expr><name>edit_baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>dir_baton</name> *</type><name>d</name></decl>;</decl_stmt>

  <comment type="block">/* Note that something interesting is actually happening in this
     edit run. */</comment>
  <expr_stmt><expr><name><name>eb</name>-&gt;<name>root_opened</name></name> = <name>TRUE</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>make_dir_baton</name><argument_list>(<argument><expr>&amp;<name>d</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>eb</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>dir_baton</name> = <name>d</name></expr>;</expr_stmt>

  <if>if <condition>(<expr>! *<name><name>eb</name>-&gt;<name>target</name></name></expr>)</condition><then>
    <block>{
      <comment type="block">/* For an update with a NULL target, this is equivalent to open_dir(): */</comment>
      <decl_stmt><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_wc_entry_t</name></type> <name>tmp_entry</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>entry</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_uint64_t</name></type> <name>flags</name> <init>= <expr><name>SVN_WC__ENTRY_MODIFY_REVISION</name> |
        <name>SVN_WC__ENTRY_MODIFY_URL</name> | <name>SVN_WC__ENTRY_MODIFY_INCOMPLETE</name></expr></init></decl>;</decl_stmt>

      <comment type="block">/* Read the depth from the entry. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_entry</name><argument_list>(<argument><expr>&amp;<name>entry</name></expr></argument>, <argument><expr><name><name>d</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name><name>eb</name>-&gt;<name>adm_access</name></name></expr></argument>,
                           <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>entry</name></expr>)</condition><then>
        <expr_stmt><expr><name><name>d</name>-&gt;<name>ambient_depth</name></name> = <name><name>entry</name>-&gt;<name>depth</name></name></expr>;</expr_stmt></then></if>

      <comment type="block">/* Mark directory as being at target_revision, but incomplete. */</comment>
      <expr_stmt><expr><name><name>tmp_entry</name>.<name>revision</name></name> = *(<name><name>eb</name>-&gt;<name>target_revision</name></name>)</expr>;</expr_stmt>
      <expr_stmt><expr><name><name>tmp_entry</name>.<name>url</name></name> = <name><name>d</name>-&gt;<name>new_URL</name></name></expr>;</expr_stmt>
      <comment type="block">/* See open_directory() for why this check is necessary. */</comment>
      <if>if <condition>(<expr><name><name>eb</name>-&gt;<name>repos</name></name> &amp;&amp; <call><name>svn_path_is_ancestor</name><argument_list>(<argument><expr><name><name>eb</name>-&gt;<name>repos</name></name></expr></argument>, <argument><expr><name><name>d</name>-&gt;<name>new_URL</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name><name>tmp_entry</name>.<name>repos</name></name> = <name><name>eb</name>-&gt;<name>repos</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name>flags</name> |= <name>SVN_WC__ENTRY_MODIFY_REPOS</name></expr>;</expr_stmt>
        }</block></then></if>
      <expr_stmt><expr><name><name>tmp_entry</name>.<name>incomplete</name></name> = <name>TRUE</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_adm_retrieve</name><argument_list>(<argument><expr>&amp;<name>adm_access</name></expr></argument>, <argument><expr><name><name>eb</name>-&gt;<name>adm_access</name></name></expr></argument>,
                                  <argument><expr><name><name>d</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__entry_modify</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument> <comment type="block">/* THIS_DIR */</comment>,
                                   <argument><expr>&amp;<name>tmp_entry</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>,
                                   <argument><expr><name>TRUE</name></expr></argument> <comment type="block">/* immediate write */</comment>,
                                   <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Helper for delete_entry().

   Search an error chain (ERR) for evidence that a local mod was left.
   If so, cleanup LOGFILE and return an appropriate error.  Otherwise,
   just return the original error chain.
*/</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>leftmod_error_chain</name><parameter_list>(<param><decl><type><name>svn_error_t</name> *</type><name>err</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>logfile</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>tmp_err</name></decl>;</decl_stmt>

  <if>if <condition>(<expr>! <name>err</name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <comment type="block">/* Advance TMP_ERR to the part of the error chain that reveals that
     a local mod was left, or to the NULL end of the chain. */</comment>
  <for>for (<init><expr><name>tmp_err</name> = <name>err</name></expr>;</init> <condition><expr><name>tmp_err</name></expr>;</condition> <incr><expr><name>tmp_err</name> = <name><name>tmp_err</name>-&gt;<name>child</name></name></expr></incr>)
    <if>if <condition>(<expr><name><name>tmp_err</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_WC_LEFT_LOCAL_MOD</name></expr>)</condition><then>
      <break>break;</break></then></if></for>

  <comment type="block">/* If we found a "left a local mod" error, wrap and return it.
     Otherwise, we just return our top-most error. */</comment>
  <if>if <condition>(<expr><name>tmp_err</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* Remove the LOGFILE (and eat up errors from this process). */</comment>
      <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><call><name>svn_io_remove_file</name><argument_list>(<argument><expr><name>logfile</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <return>return <expr><call><name>svn_error_createf</name>
        <argument_list>(<argument><expr><name>SVN_ERR_WC_OBSTRUCTED_UPDATE</name></expr></argument>, <argument><expr><name>tmp_err</name></expr></argument>,
         <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Won't delete locally modified directory '%s'"</expr></argument>)</argument_list></call></expr></argument>,
         <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

  <return>return <expr><name>err</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>do_entry_deletion</name><parameter_list>(<param><decl><type>struct <name>edit_baton</name> *</type><name>eb</name></decl></param>,
                  <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>parent_path</name></decl></param>,
                  <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                  <param><decl><type><name>int</name> *</type><name>log_number</name></decl></param>,
                  <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>entry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>full_path</name> <init>= <expr><call><name>svn_path_join</name><argument_list>(<argument><expr><name><name>eb</name>-&gt;<name>anchor</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>log_item</name> <init>= <expr><call><name>svn_stringbuf_create</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_adm_retrieve</name><argument_list>(<argument><expr>&amp;<name>adm_access</name></expr></argument>, <argument><expr><name><name>eb</name>-&gt;<name>adm_access</name></name></expr></argument>,
                              <argument><expr><name>parent_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_delete_entry</name><argument_list>(<argument><expr>&amp;<name>log_item</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>full_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__entry_versioned</name><argument_list>(<argument><expr>&amp;<name>entry</name></expr></argument>, <argument><expr><name>full_path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If the thing being deleted is the *target* of this update, then
     we need to recreate a 'deleted' entry, so that parent can give
     accurate reports about itself in the future. */</comment>
  <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>eb</name>-&gt;<name>target</name></name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_wc_entry_t</name></type> <name>tmp_entry</name></decl>;</decl_stmt>

      <expr_stmt><expr><name><name>tmp_entry</name>.<name>revision</name></name> = *(<name><name>eb</name>-&gt;<name>target_revision</name></name>)</expr>;</expr_stmt>
      <expr_stmt><expr><name><name>tmp_entry</name>.<name>kind</name></name> =
        (<name><name>entry</name>-&gt;<name>kind</name></name> == <name>svn_node_file</name>) ? <name>svn_node_file</name> : <name>svn_node_dir</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>tmp_entry</name>.<name>deleted</name></name> = <name>TRUE</name></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_entry_modify</name><argument_list>(<argument><expr>&amp;<name>log_item</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                                         <argument><expr><name>full_path</name></expr></argument>, <argument><expr>&amp;<name>tmp_entry</name></expr></argument>,
                                         <argument><expr><name>SVN_WC__ENTRY_MODIFY_REVISION</name>
                                         | <name>SVN_WC__ENTRY_MODIFY_KIND</name>
                                         | <name>SVN_WC__ENTRY_MODIFY_DELETED</name></expr></argument>,
                                         <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name><name>eb</name>-&gt;<name>target_deleted</name></name> = <name>TRUE</name></expr>;</expr_stmt>
    }</block></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__write_log</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>, <argument><expr>*<name>log_number</name></expr></argument>, <argument><expr><name>log_item</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name><name>eb</name>-&gt;<name>switch_url</name></name></expr>)</condition><then>
    <block>{
      <comment type="block">/* The SVN_WC__LOG_DELETE_ENTRY log item will cause
       * svn_wc_remove_from_revision_control() to be run.  But that
       * function checks whether the deletion target's URL is child of
       * its parent directory's URL, and if it's not, then the entry
       * in parent won't be deleted (because presumably the child
       * represents a disjoint working copy, i.e., it is a wc_root).
       *
       * However, during a switch this works against us, because by
       * the time we get here, the parent's URL has already been
       * changed.  So we manually remove the child from revision
       * control after the delete-entry item has been written in the
       * parent's log, but before it is run, so the only work left for
       * the log item is to remove the entry in the parent directory.
       */</comment>

      <if>if <condition>(<expr><name><name>entry</name>-&gt;<name>kind</name></name> == <name>svn_node_dir</name></expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><name>svn_wc_adm_access_t</name> *</type><name>child_access</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>logfile_path</name>
            <init>= <expr><call><name>svn_wc__adm_path</name><argument_list>(<argument><expr><name>parent_path</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>,
                               <argument><expr><call><name>svn_wc__logfile_path</name><argument_list>(<argument><expr>*<name>log_number</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_adm_retrieve</name>
                  <argument_list>(<argument><expr>&amp;<name>child_access</name></expr></argument>, <argument><expr><name><name>eb</name>-&gt;<name>adm_access</name></name></expr></argument>,
                   <argument><expr><name>full_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>leftmod_error_chain</name>
                  <argument_list>(<argument><expr><call><name>svn_wc_remove_from_revision_control</name>
                   <argument_list>(<argument><expr><name>child_access</name></expr></argument>,
                    <argument><expr><name>SVN_WC_ENTRY_THIS_DIR</name></expr></argument>,
                    <argument><expr><name>TRUE</name></expr></argument>, <comment type="block">/* destroy */</comment>
                    <argument><expr><name>TRUE</name></expr></argument>, <comment type="block">/* instant error */</comment>
                    <argument><expr><name><name>eb</name>-&gt;<name>cancel_func</name></name></expr></argument>,
                    <argument><expr><name><name>eb</name>-&gt;<name>cancel_baton</name></name></expr></argument>,
                    <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                   <argument><expr><name>logfile_path</name></expr></argument>, <argument><expr><name>parent_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__run_log</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>log_number</name> = 0</expr>;</expr_stmt>

  <if>if <condition>(<expr><name><name>eb</name>-&gt;<name>notify_func</name></name></expr>)</condition><then>
    <expr_stmt><expr><call>(*<name><name>eb</name>-&gt;<name>notify_func</name></name>)
      <argument_list>(<argument><expr><name><name>eb</name>-&gt;<name>notify_baton</name></name></expr></argument>,
       <argument><expr><call><name>svn_wc_create_notify</name><argument_list>(<argument><expr><name>full_path</name></expr></argument>,
                            <argument><expr><name>svn_wc_notify_update_delete</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>delete_entry</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
             <param><decl><type><name>svn_revnum_t</name></type> <name>revision</name></decl></param>,
             <param><decl><type><name>void</name> *</type><name>parent_baton</name></decl></param>,
             <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>dir_baton</name> *</type><name>pb</name> <init>= <expr><name>parent_baton</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>check_path_under_root</name><argument_list>(<argument><expr><name><name>pb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><call><name>svn_path_basename</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>do_entry_deletion</name><argument_list>(<argument><expr><name><name>pb</name>-&gt;<name>edit_baton</name></name></expr></argument>, <argument><expr><name><name>pb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr>&amp;<name><name>pb</name>-&gt;<name>log_number</name></name></expr></argument>,
                           <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>add_directory</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
              <param><decl><type><name>void</name> *</type><name>parent_baton</name></decl></param>,
              <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copyfrom_path</name></decl></param>,
              <param><decl><type><name>svn_revnum_t</name></type> <name>copyfrom_revision</name></decl></param>,
              <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
              <param><decl><type><name>void</name> **</type><name>child_baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>dir_baton</name> *</type><name>pb</name> <init>= <expr><name>parent_baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>edit_baton</name> *</type><name>eb</name> <init>= <expr><name><name>pb</name>-&gt;<name>edit_baton</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>dir_baton</name> *</type><name>db</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>make_dir_baton</name><argument_list>(<argument><expr>&amp;<name>db</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>eb</name></expr></argument>, <argument><expr><name>pb</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>child_baton</name> = <name>db</name></expr>;</expr_stmt>

  <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>eb</name>-&gt;<name>target</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
    <block>{
      <comment type="block">/* The target of the edit is being added, give it the requested
         depth of the edit (but convert svn_depth_unknown to
         svn_depth_infinity). */</comment>
      <expr_stmt><expr><name><name>db</name>-&gt;<name>ambient_depth</name></name> = (<name><name>eb</name>-&gt;<name>requested_depth</name></name> == <name>svn_depth_unknown</name>)
        ? <name>svn_depth_infinity</name> : <name><name>eb</name>-&gt;<name>requested_depth</name></name></expr>;</expr_stmt>
    }</block></then>
  <else>else <if>if <condition>(<expr><name><name>eb</name>-&gt;<name>requested_depth</name></name> == <name>svn_depth_immediates</name>
           || (<name><name>eb</name>-&gt;<name>requested_depth</name></name> == <name>svn_depth_unknown</name>
               &amp;&amp; <name><name>pb</name>-&gt;<name>ambient_depth</name></name> == <name>svn_depth_immediates</name>)</expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name><name>db</name>-&gt;<name>ambient_depth</name></name> = <name>svn_depth_empty</name></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <expr_stmt><expr><name><name>db</name>-&gt;<name>ambient_depth</name></name> = <name>svn_depth_infinity</name></expr>;</expr_stmt>
    }</block></else></if></else></if>


  <comment type="block">/* Flush the log for the parent directory before going into this subtree. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>flush_log</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Semantic check.  Either both "copyfrom" args are valid, or they're
     NULL and SVN_INVALID_REVNUM.  A mixture is illegal semantics. */</comment>
  <if>if <condition>(<expr>(<name>copyfrom_path</name> &amp;&amp; (! <call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name>copyfrom_revision</name></expr></argument>)</argument_list></call>))
      || ((! <name>copyfrom_path</name>) &amp;&amp; (<call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name>copyfrom_revision</name></expr></argument>)</argument_list></call>))</expr>)</condition><then>
    <expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>check_path_under_root</name><argument_list>(<argument><expr><name><name>pb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name><name>db</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_check_path</name><argument_list>(<argument><expr><name><name>db</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr>&amp;<name>kind</name></expr></argument>, <argument><expr><name><name>db</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* The path can exist, but it must be a directory... */</comment>
  <if>if <condition>(<expr><name>kind</name> == <name>svn_node_file</name> || <name>kind</name> == <name>svn_node_unknown</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name>
      <argument_list>(<argument><expr><name>SVN_ERR_WC_OBSTRUCTED_UPDATE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Failed to add directory '%s': a non-directory object of the "
         "same name already exists"</expr></argument>)</argument_list></call></expr></argument>,
       <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name><name>db</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <if>if <condition>(<expr><name>kind</name> == <name>svn_node_dir</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* ...Ok, it's a directory but it can't be versioned or
         scheduled for addition with history. */</comment>
      <decl_stmt><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl>;</decl_stmt>

      <comment type="block">/* Test the obstructing dir to see if it's versioned. */</comment>
      <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name> <init>= <expr><call><name>svn_wc_adm_open3</name><argument_list>(<argument><expr>&amp;<name>adm_access</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                          <argument><expr><name><name>db</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr>0</expr></argument>,
                                          <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <if>if <condition>(<expr><name>err</name> &amp;&amp; <name><name>err</name>-&gt;<name>apr_err</name></name> != <name>SVN_ERR_WC_NOT_DIRECTORY</name></expr>)</condition><then>
        <block>{
          <comment type="block">/* Something quite unexepected has happened. */</comment>
          <return>return <expr><name>err</name></expr>;</return>
        }</block></then>
      <else>else <if>if <condition>(<expr><name>err</name></expr>)</condition><then> <comment type="block">/* Not a versioned dir. */</comment>
        <block>{
          <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name><name>eb</name>-&gt;<name>allow_unver_obstructions</name></name></expr>)</condition><then>
            <block>{
              <comment type="block">/* Obstructing dir is not versioned, just need to flag it as
                 existing then we are done here. */</comment>
              <expr_stmt><expr><name><name>db</name>-&gt;<name>existed</name></name> = <name>TRUE</name></expr>;</expr_stmt>
            }</block></then>
          <else>else
            <block>{
              <return>return <expr><call><name>svn_error_createf</name>
                <argument_list>(<argument><expr><name>SVN_ERR_WC_OBSTRUCTED_UPDATE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                 <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Failed to add directory '%s': an unversioned "
                   "directory of the same name already exists"</expr></argument>)</argument_list></call></expr></argument>,
                 <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name><name>db</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
            }</block></else></if>
        }</block></then>
      <else>else <comment type="block">/* Obstructing dir *is* versioned or scheduled for addition. */</comment>
        <block>{
          <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>entry</name></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_entry</name><argument_list>(<argument><expr>&amp;<name>entry</name></expr></argument>, <argument><expr><name><name>db</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Anything other than a dir scheduled for addition without
             history is an error. */</comment>
          <if>if <condition>(<expr><name>entry</name>
              &amp;&amp; <name><name>entry</name>-&gt;<name>schedule</name></name> == <name>svn_wc_schedule_add</name>
              &amp;&amp; ! <name><name>entry</name>-&gt;<name>copied</name></name></expr>)</condition><then>
            <block>{
              <expr_stmt><expr><name><name>db</name>-&gt;<name>add_existed</name></name> = <name>TRUE</name></expr>;</expr_stmt>
            }</block></then>
          <else>else
            <block>{
              <return>return <expr><call><name>svn_error_createf</name>
                <argument_list>(<argument><expr><name>SVN_ERR_WC_OBSTRUCTED_UPDATE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                 <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Failed to add directory '%s': a versioned "
                   "directory of the same name already exists"</expr></argument>)</argument_list></call></expr></argument>,
                 <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name><name>db</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
            }</block></else></if>
        }</block></else></if></else></if>
    }</block></then></if>

  <comment type="block">/* It may not be named the same as the administrative directory. */</comment>
  <if>if <condition>(<expr><call><name>svn_wc_is_adm_dir</name><argument_list>(<argument><expr><call><name>svn_path_basename</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name>
      <argument_list>(<argument><expr><name>SVN_ERR_WC_OBSTRUCTED_UPDATE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Failed to add directory '%s': object of the same name as the "
         "administrative directory"</expr></argument>)</argument_list></call></expr></argument>,
       <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name><name>db</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Either we got real copyfrom args... */</comment>
  <if>if <condition>(<expr><name>copyfrom_path</name> || <call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name>copyfrom_revision</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <comment type="block">/* ### todo: for now, this editor doesn't know how to deal with
         copyfrom args.  Someday it will interpet them as an update
         optimization, and actually copy one part of the wc to another.
         Then it will recursively "normalize" all the ancestry in the
         copied tree.  Someday! */</comment>
      <return>return <expr><call><name>svn_error_createf</name>
        <argument_list>(<argument><expr><name>SVN_ERR_UNSUPPORTED_FEATURE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
         <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Failed to add directory '%s': "
           "copyfrom arguments not yet supported"</expr></argument>)</argument_list></call></expr></argument>,
         <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name><name>db</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then>
  <else>else  <comment type="block">/* ...or we got invalid copyfrom args. */</comment>
    <block>{
      <decl_stmt><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_wc_entry_t</name></type> <name>tmp_entry</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_uint64_t</name></type> <name>modify_flags</name> <init>= <expr><name>SVN_WC__ENTRY_MODIFY_KIND</name> |
        <name>SVN_WC__ENTRY_MODIFY_DELETED</name> | <name>SVN_WC__ENTRY_MODIFY_ABSENT</name></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_adm_retrieve</name><argument_list>(<argument><expr>&amp;<name>adm_access</name></expr></argument>, <argument><expr><name><name>eb</name>-&gt;<name>adm_access</name></name></expr></argument>,
                                  <argument><expr><name><name>pb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name><name>db</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Immediately create an entry for the new directory in the parent.
         Note that the parent must already be either added or opened, and
         thus it's in an 'incomplete' state just like the new dir.
         The entry may already exist if the new directory is already
         scheduled for addition without history, in that case set
         its schedule to normal. */</comment>
      <expr_stmt><expr><name><name>tmp_entry</name>.<name>kind</name></name> = <name>svn_node_dir</name></expr>;</expr_stmt>
      <comment type="block">/* Note that there may already exist a 'ghost' entry in the
         parent with the same name, in a 'deleted' or 'absent' state.
         If so, it's fine to overwrite it... but we need to make sure
         we get rid of the state flag when doing so: */</comment>
      <expr_stmt><expr><name><name>tmp_entry</name>.<name>deleted</name></name> = <name>FALSE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>tmp_entry</name>.<name>absent</name></name> = <name>FALSE</name></expr>;</expr_stmt>

      <if>if <condition>(<expr><name><name>db</name>-&gt;<name>add_existed</name></name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name><name>tmp_entry</name>.<name>schedule</name></name> = <name>svn_wc_schedule_normal</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>modify_flags</name> |= <name>SVN_WC__ENTRY_MODIFY_SCHEDULE</name> |
            <name>SVN_WC__ENTRY_MODIFY_FORCE</name></expr>;</expr_stmt>
        }</block></then></if>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__entry_modify</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name><name>db</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr>&amp;<name>tmp_entry</name></expr></argument>,
                                   <argument><expr><name>modify_flags</name></expr></argument>,
                                   <argument><expr><name>TRUE</name></expr></argument> <comment type="block">/* immediate write */</comment>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr><name><name>db</name>-&gt;<name>add_existed</name></name></expr>)</condition><then>
        <block>{
          <comment type="block">/* Immediately tweak the schedule for "this dir" so it too
             is no longer scheduled for addition.  Change rev from 0
             to the target revision allowing prep_directory() to do
             its thing without error. */</comment>
          <expr_stmt><expr><name>modify_flags</name>  = <name>SVN_WC__ENTRY_MODIFY_SCHEDULE</name>
            | <name>SVN_WC__ENTRY_MODIFY_FORCE</name> | <name>SVN_WC__ENTRY_MODIFY_REVISION</name></expr>;</expr_stmt>

          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_adm_retrieve</name><argument_list>(<argument><expr>&amp;<name>adm_access</name></expr></argument>,
                                      <argument><expr><name><name>db</name>-&gt;<name>edit_baton</name>-&gt;<name>adm_access</name></name></expr></argument>,
                                      <argument><expr><name><name>db</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>tmp_entry</name>.<name>revision</name></name> = *(<name><name>eb</name>-&gt;<name>target_revision</name></name>)</expr>;</expr_stmt>

          <if>if <condition>(<expr><name><name>eb</name>-&gt;<name>switch_url</name></name></expr>)</condition><then>
            <block>{
              <expr_stmt><expr><name><name>tmp_entry</name>.<name>url</name></name> = <call><name>svn_path_url_add_component</name><argument_list>(<argument><expr><name><name>eb</name>-&gt;<name>switch_url</name></name></expr></argument>,
                                                         <argument><expr><name><name>db</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>modify_flags</name> |= <name>SVN_WC__ENTRY_MODIFY_URL</name></expr>;</expr_stmt>
            }</block></then></if>

          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__entry_modify</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>tmp_entry</name></expr></argument>,
                                       <argument><expr><name>modify_flags</name></expr></argument>,
                                       <argument><expr><name>TRUE</name></expr></argument> <comment type="block">/* immediate write */</comment>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></else></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>prep_directory</name><argument_list>(<argument><expr><name>db</name></expr></argument>,
                         <argument><expr><name><name>db</name>-&gt;<name>new_URL</name></name></expr></argument>,
                         <argument><expr>*(<name><name>eb</name>-&gt;<name>target_revision</name></name>)</expr></argument>,
                         <argument><expr><name><name>db</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If this add was obstructed by dir scheduled for addition without
     history let close_file() handle the notification because there
     might be properties to deal with. */</comment>
  <if>if <condition>(<expr><name><name>eb</name>-&gt;<name>notify_func</name></name> &amp;&amp; !(<name><name>db</name>-&gt;<name>add_existed</name></name>)</expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_wc_notify_t</name> *</type><name>notify</name> <init>= <expr><call><name>svn_wc_create_notify</name><argument_list>(
        <argument><expr><name><name>db</name>-&gt;<name>path</name></name></expr></argument>,
        <argument><expr><name><name>db</name>-&gt;<name>existed</name></name> ?
        <name>svn_wc_notify_exists</name> : <name>svn_wc_notify_update_add</name></expr></argument>,
        <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>notify</name>-&gt;<name>kind</name></name> = <name>svn_node_dir</name></expr>;</expr_stmt>
      <expr_stmt><expr><call>(*<name><name>eb</name>-&gt;<name>notify_func</name></name>)<argument_list>(<argument><expr><name><name>eb</name>-&gt;<name>notify_baton</name></name></expr></argument>, <argument><expr><name>notify</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>open_directory</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
               <param><decl><type><name>void</name> *</type><name>parent_baton</name></decl></param>,
               <param><decl><type><name>svn_revnum_t</name></type> <name>base_revision</name></decl></param>,
               <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
               <param><decl><type><name>void</name> **</type><name>child_baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>dir_baton</name> *</type><name>db</name></decl>, *<decl><type ref="prev"/><name>pb</name> <init>= <expr><name>parent_baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>edit_baton</name> *</type><name>eb</name> <init>= <expr><name><name>pb</name>-&gt;<name>edit_baton</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>entry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_wc_entry_t</name></type> <name>tmp_entry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_uint64_t</name></type> <name>flags</name> <init>= <expr><name>SVN_WC__ENTRY_MODIFY_REVISION</name> |
    <name>SVN_WC__ENTRY_MODIFY_URL</name> | <name>SVN_WC__ENTRY_MODIFY_INCOMPLETE</name></expr></init></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>make_dir_baton</name><argument_list>(<argument><expr>&amp;<name>db</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>eb</name></expr></argument>, <argument><expr><name>pb</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>child_baton</name> = <name>db</name></expr>;</expr_stmt>

  <comment type="block">/* Flush the log for the parent directory before going into this subtree. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>flush_log</name><argument_list>(<argument><expr><name>pb</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>check_path_under_root</name><argument_list>(<argument><expr><name><name>pb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name><name>db</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Skip this directory if it has property conflicts. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_entry</name><argument_list>(<argument><expr>&amp;<name>entry</name></expr></argument>, <argument><expr><name><name>db</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name><name>eb</name>-&gt;<name>adm_access</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>entry</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* Text conflicts can't happen for a directory, but we need to supply
         both flags. */</comment>
      <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>text_conflicted</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>prop_conflicted</name></decl>;</decl_stmt>

      <expr_stmt><expr><name><name>db</name>-&gt;<name>ambient_depth</name></name> = <name><name>entry</name>-&gt;<name>depth</name></name></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_conflicted_p</name><argument_list>(<argument><expr>&amp;<name>text_conflicted</name></expr></argument>, <argument><expr>&amp;<name>prop_conflicted</name></expr></argument>,
                                  <argument><expr><name><name>db</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>! <name>text_conflicted</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>prop_conflicted</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name><name>db</name>-&gt;<name>bump_info</name>-&gt;<name>skipped</name></name> = <name>TRUE</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name><name>eb</name>-&gt;<name>skipped_paths</name></name></expr></argument>, <argument><expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>eb</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>db</name>-&gt;<name>path</name></name></expr></argument>)</argument_list></call></expr></argument>,
                       <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr>(<name>void</name>*)1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name><name>eb</name>-&gt;<name>notify_func</name></name></expr>)</condition><then>
            <block>{
              <decl_stmt><decl><type><name>svn_wc_notify_t</name> *</type><name>notify</name>
                <init>= <expr><call><name>svn_wc_create_notify</name><argument_list>(<argument><expr><name><name>db</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>svn_wc_notify_skip</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
              <expr_stmt><expr><name><name>notify</name>-&gt;<name>kind</name></name> = <name>svn_node_dir</name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>notify</name>-&gt;<name>prop_state</name></name> = <name>svn_wc_notify_state_conflicted</name></expr>;</expr_stmt>
              <expr_stmt><expr><call>(*<name><name>eb</name>-&gt;<name>notify_func</name></name>)<argument_list>(<argument><expr><name><name>eb</name>-&gt;<name>notify_baton</name></name></expr></argument>, <argument><expr><name>notify</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
          <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
        }</block></then></if>
    }</block></then></if>

  <comment type="block">/* Mark directory as being at target_revision and URL, but incomplete. */</comment>
  <expr_stmt><expr><name><name>tmp_entry</name>.<name>revision</name></name> = *(<name><name>eb</name>-&gt;<name>target_revision</name></name>)</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>tmp_entry</name>.<name>url</name></name> = <name><name>db</name>-&gt;<name>new_URL</name></name></expr>;</expr_stmt>
  <comment type="block">/* In some situations, the URL of this directory does not have the same
     repository root as the anchor of the update; we can't just blindly
     use the that repository root here, so make sure it is really an
     ancestor. */</comment>
  <if>if <condition>(<expr><name><name>eb</name>-&gt;<name>repos</name></name> &amp;&amp; <call><name>svn_path_is_ancestor</name><argument_list>(<argument><expr><name><name>eb</name>-&gt;<name>repos</name></name></expr></argument>, <argument><expr><name><name>db</name>-&gt;<name>new_URL</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name><name>tmp_entry</name>.<name>repos</name></name> = <name><name>eb</name>-&gt;<name>repos</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>flags</name> |= <name>SVN_WC__ENTRY_MODIFY_REPOS</name></expr>;</expr_stmt>
    }</block></then></if>
  <expr_stmt><expr><name><name>tmp_entry</name>.<name>incomplete</name></name> = <name>TRUE</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_adm_retrieve</name><argument_list>(<argument><expr>&amp;<name>adm_access</name></expr></argument>, <argument><expr><name><name>eb</name>-&gt;<name>adm_access</name></name></expr></argument>,
                              <argument><expr><name><name>db</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__entry_modify</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument> <comment type="block">/* THIS_DIR */</comment>,
                               <argument><expr>&amp;<name>tmp_entry</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>,
                               <argument><expr><name>TRUE</name></expr></argument> <comment type="block">/* immediate write */</comment>,
                               <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>change_dir_prop</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>dir_baton</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>value</name></decl></param>,
                <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_prop_t</name> *</type><name>propchange</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>dir_baton</name> *</type><name>db</name> <init>= <expr><name>dir_baton</name></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name><name>db</name>-&gt;<name>bump_info</name>-&gt;<name>skipped</name></name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <expr_stmt><expr><name>propchange</name> = <call><name>apr_array_push</name><argument_list>(<argument><expr><name><name>db</name>-&gt;<name>propchanges</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>propchange</name>-&gt;<name>name</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>db</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>propchange</name>-&gt;<name>value</name></name> = <name>value</name> ? <call><name>svn_string_dup</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name><name>db</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call> : <name>NULL</name></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>



<comment type="block">/* If any of the svn_prop_t objects in PROPCHANGES represents a change
   to the SVN_PROP_EXTERNALS property, return that change, else return
   null.  If PROPCHANGES contains more than one such change, return
   the first. */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>svn_prop_t</name> *</type>
<name>externals_prop_changed</name><parameter_list>(<param><decl><type><name>apr_array_header_t</name> *</type><name>propchanges</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>propchanges</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>svn_prop_t</name> *</type><name>p</name> <init>= <expr>&amp;(<call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>propchanges</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>svn_prop_t</name></expr></argument>)</argument_list></call>)</expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>p</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>SVN_PROP_EXTERNALS</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
        <return>return <expr><name>p</name></expr>;</return></then></if>
    }</block></for>

  <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>close_directory</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>dir_baton</name></decl></param>,
                <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>dir_baton</name> *</type><name>db</name> <init>= <expr><name>dir_baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_wc_notify_state_t</name></type> <name>prop_state</name> <init>= <expr><name>svn_wc_notify_state_unknown</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>entry_props</name></decl>, *<decl><type ref="prev"/><name>wc_props</name></decl>, *<decl><type ref="prev"/><name>regular_props</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_categorize_props</name><argument_list>(<argument><expr><name><name>db</name>-&gt;<name>propchanges</name></name></expr></argument>, <argument><expr>&amp;<name>entry_props</name></expr></argument>, <argument><expr>&amp;<name>wc_props</name></expr></argument>,
                               <argument><expr>&amp;<name>regular_props</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_adm_retrieve</name><argument_list>(<argument><expr>&amp;<name>adm_access</name></expr></argument>, <argument><expr><name><name>db</name>-&gt;<name>edit_baton</name>-&gt;<name>adm_access</name></name></expr></argument>,
                              <argument><expr><name><name>db</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name><name>db</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If this directory has property changes stored up, now is the time
     to deal with them. */</comment>
  <if>if <condition>(<expr><name><name>regular_props</name>-&gt;<name>nelts</name></name> || <name><name>entry_props</name>-&gt;<name>nelts</name></name> || <name><name>wc_props</name>-&gt;<name>nelts</name></name></expr>)</condition><then>
    <block>{
      <comment type="block">/* Make a temporary log accumulator for dirprop changes.*/</comment>
      <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>dirprop_log</name> <init>= <expr><call><name>svn_stringbuf_create</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <if>if <condition>(<expr><name><name>regular_props</name>-&gt;<name>nelts</name></name></expr>)</condition><then>
        <block>{
          <comment type="block">/* If recording traversal info, then see if the
             SVN_PROP_EXTERNALS property on this directory changed,
             and record before and after for the change. */</comment>
          <if>if <condition>(<expr><name><name>db</name>-&gt;<name>edit_baton</name>-&gt;<name>traversal_info</name></name></expr>)</condition><then>
            <block>{
              <decl_stmt><decl><type><name>svn_wc_traversal_info_t</name> *</type><name>ti</name> <init>= <expr><name><name>db</name>-&gt;<name>edit_baton</name>-&gt;<name>traversal_info</name></name></expr></init></decl>;</decl_stmt>
              <decl_stmt><decl><type><specifier>const</specifier> <name>svn_prop_t</name> *</type><name>change</name> <init>= <expr><call><name>externals_prop_changed</name><argument_list>(<argument><expr><name>regular_props</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

              <if>if <condition>(<expr><name>change</name></expr>)</condition><then>
                <block>{
                  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>new_val_s</name> <init>= <expr><name><name>change</name>-&gt;<name>value</name></name></expr></init></decl>;</decl_stmt>
                  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>old_val_s</name></decl>;</decl_stmt>

                  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_prop_get</name>
                          <argument_list>(<argument><expr>&amp;<name>old_val_s</name></expr></argument>, <argument><expr><name>SVN_PROP_EXTERNALS</name></expr></argument>,
                           <argument><expr><name><name>db</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name><name>db</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                  <if>if <condition>(<expr>(<name>new_val_s</name> == <name>NULL</name>) &amp;&amp; (<name>old_val_s</name> == <name>NULL</name>)</expr>)</condition><then>
                    <empty_stmt>;</empty_stmt></then> <comment type="block">/* No value before, no value after... so do nothing. */</comment>
                  <else>else <if>if <condition>(<expr><name>new_val_s</name> &amp;&amp; <name>old_val_s</name>
                           &amp;&amp; (<call><name>svn_string_compare</name><argument_list>(<argument><expr><name>old_val_s</name></expr></argument>, <argument><expr><name>new_val_s</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
                    <empty_stmt>;</empty_stmt></then> <comment type="block">/* Value did not change... so do nothing. */</comment>
                  <else>else <if>if <condition>(<expr><name>old_val_s</name> || <name>new_val_s</name></expr>)</condition><then>
                    <comment type="block">/* something changed, record the change */</comment>
                    <block>{
                      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>d_path</name> <init>= <expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>ti</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>db</name>-&gt;<name>path</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

                      <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name><name>ti</name>-&gt;<name>depths</name></name></expr></argument>, <argument><expr><name>d_path</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>,
                                   <argument><expr><call><name>svn_depth_to_word</name><argument_list>(<argument><expr><name><name>db</name>-&gt;<name>ambient_depth</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

                      <comment type="block">/* We can't assume that ti came pre-loaded with
                         the old values of the svn:externals property.
                         Yes, most callers will have already
                         initialized ti by sending it through
                         svn_wc_crawl_revisions, but we shouldn't
                         count on that here -- so we set both the old
                         and new values again. */</comment>
                      <if>if <condition>(<expr><name>old_val_s</name></expr>)</condition><then>
                        <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name><name>ti</name>-&gt;<name>externals_old</name></name></expr></argument>, <argument><expr><name>d_path</name></expr></argument>,
                                     <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>,
                                     <argument><expr><call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name><name>ti</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>old_val_s</name>-&gt;<name>data</name></name></expr></argument>,
                                                    <argument><expr><name><name>old_val_s</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
                      <if>if <condition>(<expr><name>new_val_s</name></expr>)</condition><then>
                        <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name><name>ti</name>-&gt;<name>externals_new</name></name></expr></argument>, <argument><expr><name>d_path</name></expr></argument>,
                                     <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>,
                                     <argument><expr><call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name><name>ti</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>new_val_s</name>-&gt;<name>data</name></name></expr></argument>,
                                                    <argument><expr><name><name>new_val_s</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
                    }</block></then></if></else></if></else></if>
                }</block></then></if>
            }</block></then></if>

          <comment type="block">/* Merge pending properties into temporary files (ignoring
             conflicts). */</comment>
          <expr_stmt><expr><call><name>SVN_ERR_W</name><argument_list>(<argument><expr><call><name>svn_wc__merge_props</name><argument_list>(<argument><expr>&amp;<name>prop_state</name></expr></argument>,
                                        <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name><name>db</name>-&gt;<name>path</name></name></expr></argument>,
                                        <argument><expr><name>NULL</name></expr></argument> <comment type="block">/* use baseprops */</comment>,
                                        <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                        <argument><expr><name>regular_props</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                                        <argument><expr><name><name>db</name>-&gt;<name>edit_baton</name>-&gt;<name>conflict_func</name></name></expr></argument>,
                                        <argument><expr><name><name>db</name>-&gt;<name>edit_baton</name>-&gt;<name>conflict_baton</name></name></expr></argument>,
                                        <argument><expr><name><name>db</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>&amp;<name>dirprop_log</name></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Couldn't do property merge"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>accumulate_entry_props</name><argument_list>(<argument><expr><name>dirprop_log</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                     <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name><name>db</name>-&gt;<name>path</name></name></expr></argument>,
                                     <argument><expr><name>entry_props</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>accumulate_wcprops</name><argument_list>(<argument><expr><name>dirprop_log</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                                 <argument><expr><name><name>db</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>wc_props</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Add the dirprop loggy entries to the baton's log
         accumulator. */</comment>
      <expr_stmt><expr><call><name>svn_stringbuf_appendstr</name><argument_list>(<argument><expr><name><name>db</name>-&gt;<name>log_accum</name></name></expr></argument>, <argument><expr><name>dirprop_log</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* Flush and run the log. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>flush_log</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__run_log</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name><name>db</name>-&gt;<name>edit_baton</name>-&gt;<name>diff3_cmd</name></name></expr></argument>, <argument><expr><name><name>db</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name>-&gt;<name>log_number</name></name> = 0</expr>;</expr_stmt>

  <comment type="block">/* We're done with this directory, so remove one reference from the
     bump information. This may trigger a number of actions. See
     maybe_bump_dir_info() for more information.  */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>maybe_bump_dir_info</name><argument_list>(<argument><expr><name><name>db</name>-&gt;<name>edit_baton</name></name></expr></argument>, <argument><expr><name><name>db</name>-&gt;<name>bump_info</name></name></expr></argument>, <argument><expr><name><name>db</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Notify of any prop changes on this directory -- but do nothing
     if it's an added or skipped directory, because notification has already
     happened in that case - unless the add was obstructed by a dir
     scheduled for addition without history, in which case we handle
     notification here). */</comment>
  <if>if <condition>(<expr>! <name><name>db</name>-&gt;<name>bump_info</name>-&gt;<name>skipped</name></name> &amp;&amp; (<name><name>db</name>-&gt;<name>add_existed</name></name> || (! <name><name>db</name>-&gt;<name>added</name></name>))
      &amp;&amp; (<name><name>db</name>-&gt;<name>edit_baton</name>-&gt;<name>notify_func</name></name>)</expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_wc_notify_t</name> *</type><name>notify</name>
        <init>= <expr><call><name>svn_wc_create_notify</name><argument_list>(<argument><expr><name><name>db</name>-&gt;<name>path</name></name></expr></argument>,
                               <argument><expr><name><name>db</name>-&gt;<name>existed</name></name> || <name><name>db</name>-&gt;<name>add_existed</name></name>
                               ? <name>svn_wc_notify_exists</name>
                               : <name>svn_wc_notify_update_update</name></expr></argument>,
                               <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>notify</name>-&gt;<name>kind</name></name> = <name>svn_node_dir</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>notify</name>-&gt;<name>prop_state</name></name> = <name>prop_state</name></expr>;</expr_stmt>
    <expr_stmt><expr><call>(*<name><name>db</name>-&gt;<name>edit_baton</name>-&gt;<name>notify_func</name></name>)<argument_list>(<argument><expr><name><name>db</name>-&gt;<name>edit_baton</name>-&gt;<name>notify_baton</name></name></expr></argument>,
                                   <argument><expr><name>notify</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Common code for 'absent_file' and 'absent_directory'. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>absent_file_or_dir</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                   <param><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl></param>,
                   <param><decl><type><name>void</name> *</type><name>parent_baton</name></decl></param>,
                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name> <init>= <expr><call><name>svn_path_basename</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>dir_baton</name> *</type><name>pb</name> <init>= <expr><name>parent_baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>edit_baton</name> *</type><name>eb</name> <init>= <expr><name><name>pb</name>-&gt;<name>edit_baton</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>entries</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>ent</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_wc_entry_t</name></type> <name>tmp_entry</name></decl>;</decl_stmt>

  <comment type="block">/* Extra check: an item by this name may not exist, but there may
     still be one scheduled for addition.  That's a genuine
     tree-conflict.  */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_adm_retrieve</name><argument_list>(<argument><expr>&amp;<name>adm_access</name></expr></argument>, <argument><expr><name><name>eb</name>-&gt;<name>adm_access</name></name></expr></argument>, <argument><expr><name><name>pb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_entries_read</name><argument_list>(<argument><expr>&amp;<name>entries</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>ent</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>entries</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>ent</name> &amp;&amp; (<name><name>ent</name>-&gt;<name>schedule</name></name> == <name>svn_wc_schedule_add</name>)</expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name>
      <argument_list>(<argument><expr><name>SVN_ERR_WC_OBSTRUCTED_UPDATE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Failed to mark '%s' absent: item of the same name is already "
         "scheduled for addition"</expr></argument>)</argument_list></call></expr></argument>,
       <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Immediately create an entry for the new item in the parent.  Note
     that the parent must already be either added or opened, and thus
     it's in an 'incomplete' state just like the new item.  */</comment>
  <expr_stmt><expr><name><name>tmp_entry</name>.<name>kind</name></name> = <name>kind</name></expr>;</expr_stmt>

  <comment type="block">/* Note that there may already exist a 'ghost' entry in the parent
     with the same name, in a 'deleted' state.  If so, it's fine to
     overwrite it... but we need to make sure we get rid of the
     'deleted' flag when doing so: */</comment>
  <expr_stmt><expr><name><name>tmp_entry</name>.<name>deleted</name></name> = <name>FALSE</name></expr>;</expr_stmt>

  <comment type="block">/* Post-update processing knows to leave this entry if its revision
     is equal to the target revision of the overall update. */</comment>
  <expr_stmt><expr><name><name>tmp_entry</name>.<name>revision</name></name> = *(<name><name>eb</name>-&gt;<name>target_revision</name></name>)</expr>;</expr_stmt>

  <comment type="block">/* And, of course, marking as absent is the whole point. */</comment>
  <expr_stmt><expr><name><name>tmp_entry</name>.<name>absent</name></name> = <name>TRUE</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__entry_modify</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr>&amp;<name>tmp_entry</name></expr></argument>,
                               <argument><expr>(<name>SVN_WC__ENTRY_MODIFY_KIND</name>    |
                                <name>SVN_WC__ENTRY_MODIFY_REVISION</name> |
                                <name>SVN_WC__ENTRY_MODIFY_DELETED</name> |
                                <name>SVN_WC__ENTRY_MODIFY_ABSENT</name>)</expr></argument>,
                               <argument><expr><name>TRUE</name></expr></argument> <comment type="block">/* immediate write */</comment>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>absent_file</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
            <param><decl><type><name>void</name> *</type><name>parent_baton</name></decl></param>,
            <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>absent_file_or_dir</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>svn_node_file</name></expr></argument>, <argument><expr><name>parent_baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>absent_directory</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                 <param><decl><type><name>void</name> *</type><name>parent_baton</name></decl></param>,
                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>absent_file_or_dir</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>svn_node_dir</name></expr></argument>, <argument><expr><name>parent_baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>



<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>add_file</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
         <param><decl><type><name>void</name> *</type><name>parent_baton</name></decl></param>,
         <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copyfrom_path</name></decl></param>,
         <param><decl><type><name>svn_revnum_t</name></type> <name>copyfrom_rev</name></decl></param>,
         <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
         <param><decl><type><name>void</name> **</type><name>file_baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>dir_baton</name> *</type><name>pb</name> <init>= <expr><name>parent_baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>edit_baton</name> *</type><name>eb</name> <init>= <expr><name><name>pb</name>-&gt;<name>edit_baton</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>file_baton</name> *</type><name>fb</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>entry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>copyfrom_path</name> || <call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name>copyfrom_rev</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <comment type="block">/* Sanity checks */</comment>
      <if>if <condition>(<expr>! (<name>copyfrom_path</name> &amp;&amp; <call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name>copyfrom_rev</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
        <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_WC_INVALID_OP_ON_CWD</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                  <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Bad copyfrom arguments received"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

      <return>return <expr><call><name>add_file_with_history</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>parent_baton</name></expr></argument>,
                                   <argument><expr><name>copyfrom_path</name></expr></argument>, <argument><expr><name>copyfrom_rev</name></expr></argument>,
                                   <argument><expr><name>file_baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

  <comment type="block">/* The file_pool can stick around for a *long* time, so we want to
     use a subpool for any temporary allocations. */</comment>
  <expr_stmt><expr><name>subpool</name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>make_file_baton</name><argument_list>(<argument><expr>&amp;<name>fb</name></expr></argument>, <argument><expr><name>pb</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>file_baton</name> = <name>fb</name></expr>;</expr_stmt>


  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>check_path_under_root</name><argument_list>(<argument><expr><name><name>fb</name>-&gt;<name>dir_baton</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name><name>fb</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* It is interesting to note: everything below is just validation. We
     aren't actually doing any "work" or fetching any persistent data. */</comment>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_check_path</name><argument_list>(<argument><expr><name><name>fb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr>&amp;<name>kind</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_adm_retrieve</name><argument_list>(<argument><expr>&amp;<name>adm_access</name></expr></argument>, <argument><expr><name><name>eb</name>-&gt;<name>adm_access</name></name></expr></argument>,
                              <argument><expr><name><name>pb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_entry</name><argument_list>(<argument><expr>&amp;<name>entry</name></expr></argument>, <argument><expr><name><name>fb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Sanity checks. */</comment>

  <comment type="block">/* When adding, there should be nothing with this name unless unversioned
     obstructions are permitted or the obstruction is scheduled for addition
     without history. */</comment>
  <if>if <condition>(<expr><name>kind</name> != <name>svn_node_none</name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr><name><name>eb</name>-&gt;<name>allow_unver_obstructions</name></name>
          || (<name>entry</name> &amp;&amp; <name><name>entry</name>-&gt;<name>schedule</name></name> == <name>svn_wc_schedule_add</name>)</expr>)</condition><then>
        <block>{
          <if>if <condition>(<expr><name>entry</name> &amp;&amp; <name><name>entry</name>-&gt;<name>copied</name></name></expr>)</condition><then>
            <block>{
              <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_WC_OBSTRUCTED_UPDATE</name></expr></argument>,
                                       <argument><expr><name>NULL</name></expr></argument>,
                                       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Failed to add file '%s': a "
                                         "file of the same name is "
                                         "already scheduled for addition "
                                         "with history"</expr></argument>)</argument_list></call></expr></argument>,
                                       <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name><name>fb</name>-&gt;<name>path</name></name></expr></argument>,
                                                            <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
            }</block></then></if>

          <comment type="block">/* The name can exist, but it better *really* be a file. */</comment>
          <if>if <condition>(<expr><name>kind</name> != <name>svn_node_file</name></expr>)</condition><then>
            <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_WC_OBSTRUCTED_UPDATE</name></expr></argument>,
                                     <argument><expr><name>NULL</name></expr></argument>,
                                     <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Failed to add file '%s': "
                                       "a non-file object of the same "
                                       "name already exists"</expr></argument>)</argument_list></call></expr></argument>,
                                     <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name><name>fb</name>-&gt;<name>path</name></name></expr></argument>,
                                                          <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

          <if>if <condition>(<expr><name>entry</name></expr>)</condition><then>
            <expr_stmt><expr><name><name>fb</name>-&gt;<name>add_existed</name></name> = <name>TRUE</name></expr>;</expr_stmt></then> <comment type="block">/* Flag as addition without history. */</comment>
          <else>else
            <expr_stmt><expr><name><name>fb</name>-&gt;<name>existed</name></name> = <name>TRUE</name></expr>;</expr_stmt></else></if>     <comment type="block">/* Flag as unversioned obstruction. */</comment>
        }</block></then>
      <else>else
        <block>{
          <return>return <expr><call><name>svn_error_createf</name>
            <argument_list>(<argument><expr><name>SVN_ERR_WC_OBSTRUCTED_UPDATE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
             <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Failed to add file '%s': object of the same name "
               "already exists"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name><name>fb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></else></if>
    }</block></then></if>
  <comment type="block">/* sussman sez: If we're trying to add a file that's already in
     `entries' (but not on disk), that's okay.  It's probably because
     the user deleted the working version and ran 'svn up' as a means
     of getting the file back.

     It certainly doesn't hurt to re-add the file.  We can't possibly
     get the entry showing up twice in `entries', since it's a hash;
     and we know that we won't lose any local mods.  Let the existing
     entry be overwritten. */</comment>

  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>open_file</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
          <param><decl><type><name>void</name> *</type><name>parent_baton</name></decl></param>,
          <param><decl><type><name>svn_revnum_t</name></type> <name>base_revision</name></decl></param>,
          <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
          <param><decl><type><name>void</name> **</type><name>file_baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>dir_baton</name> *</type><name>pb</name> <init>= <expr><name>parent_baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>edit_baton</name> *</type><name>eb</name> <init>= <expr><name><name>pb</name>-&gt;<name>edit_baton</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>file_baton</name> *</type><name>fb</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>entry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>text_conflicted</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>prop_conflicted</name></decl>;</decl_stmt>

  <comment type="block">/* the file_pool can stick around for a *long* time, so we want to use
     a subpool for any temporary allocations. */</comment>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>make_file_baton</name><argument_list>(<argument><expr>&amp;<name>fb</name></expr></argument>, <argument><expr><name>pb</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>file_baton</name> = <name>fb</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>check_path_under_root</name><argument_list>(<argument><expr><name><name>fb</name>-&gt;<name>dir_baton</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name><name>fb</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* It is interesting to note: everything below is just validation. We
     aren't actually doing any "work" or fetching any persistent data. */</comment>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_check_path</name><argument_list>(<argument><expr><name><name>fb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr>&amp;<name>kind</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_adm_retrieve</name><argument_list>(<argument><expr>&amp;<name>adm_access</name></expr></argument>, <argument><expr><name><name>eb</name>-&gt;<name>adm_access</name></name></expr></argument>,
                              <argument><expr><name><name>pb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_entry</name><argument_list>(<argument><expr>&amp;<name>entry</name></expr></argument>, <argument><expr><name><name>fb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Sanity checks. */</comment>

  <comment type="block">/* If replacing, make sure the .svn entry already exists. */</comment>
  <if>if <condition>(<expr>! <name>entry</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_UNVERSIONED_RESOURCE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><call><name>_</name><argument_list>(<argument><expr>"File '%s' in directory '%s' "
                               "is not a versioned resource"</expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><name><name>fb</name>-&gt;<name>name</name></name></expr></argument>,
                             <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name><name>pb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* If the file is in conflict, don't mess with it. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_conflicted_p</name><argument_list>(<argument><expr>&amp;<name>text_conflicted</name></expr></argument>, <argument><expr>&amp;<name>prop_conflicted</name></expr></argument>,
                              <argument><expr><name><name>pb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>text_conflicted</name> || <name>prop_conflicted</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name><name>fb</name>-&gt;<name>skipped</name></name> = <name>TRUE</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name><name>eb</name>-&gt;<name>skipped_paths</name></name></expr></argument>, <argument><expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>eb</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>fb</name>-&gt;<name>path</name></name></expr></argument>)</argument_list></call></expr></argument>,
                   <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr>(<name>void</name>*)1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name><name>eb</name>-&gt;<name>notify_func</name></name></expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><name>svn_wc_notify_t</name> *</type><name>notify</name>
            <init>= <expr><call><name>svn_wc_create_notify</name><argument_list>(<argument><expr><name><name>fb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>svn_wc_notify_skip</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name><name>notify</name>-&gt;<name>kind</name></name> = <name>svn_node_file</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>notify</name>-&gt;<name>content_state</name></name> = <name>text_conflicted</name>
            ? <name>svn_wc_notify_state_conflicted</name>
            : <name>svn_wc_notify_state_unknown</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>notify</name>-&gt;<name>prop_state</name></name> = <name>prop_conflicted</name>
            ? <name>svn_wc_notify_state_conflicted</name>
            : <name>svn_wc_notify_state_unknown</name></expr>;</expr_stmt>
          <expr_stmt><expr><call>(*<name><name>eb</name>-&gt;<name>notify_func</name></name>)<argument_list>(<argument><expr><name><name>eb</name>-&gt;<name>notify_baton</name></name></expr></argument>, <argument><expr><name>notify</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>

  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Fill out FB-&gt;text_base_path and FB-&gt;new_text_base_path to the
   permanent and temporary text-base paths respectively, or (if the
   entry is replaced with history) to the permanent and temporary
   revert-base paths respectively.

   If REPLACED_P and USE_REVERT_BASE are non-NULL, set *REPLACED_P and
   *USE_REVERT_BASE_P to whether or not the entry is replaced, and to
   whether or not it needs to use the revert base (i.e., it's replaced
   with history), respectively.  If CHECKSUM_P is non-NULL and the
   path already has an entry, set *CHECKSUM_P to the entry's checksum.

   Use POOL for temporary allocation and for *CHECKSUM_P (if
   applicable), but allocate FB-&gt;text_base_path and
   FB-&gt;new_text_base_path in FB-&gt;pool. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>choose_base_paths</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>checksum_p</name></decl></param>,
                  <param><decl><type><name>svn_boolean_t</name> *</type><name>replaced_p</name></decl></param>,
                  <param><decl><type><name>svn_boolean_t</name> *</type><name>use_revert_base_p</name></decl></param>,
                  <param><decl><type>struct <name>file_baton</name> *</type><name>fb</name></decl></param>,
                  <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>edit_baton</name> *</type><name>eb</name> <init>= <expr><name><name>fb</name>-&gt;<name>edit_baton</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>ent</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>replaced</name></decl>, <decl><type ref="prev"/><name>use_revert_base</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_adm_retrieve</name><argument_list>(<argument><expr>&amp;<name>adm_access</name></expr></argument>, <argument><expr><name><name>eb</name>-&gt;<name>adm_access</name></name></expr></argument>,
                              <argument><expr><call><name>svn_path_dirname</name><argument_list>(<argument><expr><name><name>fb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_entry</name><argument_list>(<argument><expr>&amp;<name>ent</name></expr></argument>, <argument><expr><name><name>fb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>replaced</name> = <name>ent</name> &amp;&amp; <name><name>ent</name>-&gt;<name>schedule</name></name> == <name>svn_wc_schedule_replace</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>use_revert_base</name> = <name>replaced</name> &amp;&amp; (<name><name>ent</name>-&gt;<name>copyfrom_url</name></name> != <name>NULL</name>)</expr>;</expr_stmt>
  <if>if <condition>(<expr><name>use_revert_base</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name><name>fb</name>-&gt;<name>text_base_path</name></name> = <call><name>svn_wc__text_revert_path</name><argument_list>(<argument><expr><name><name>fb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name><name>fb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>fb</name>-&gt;<name>new_text_base_path</name></name> = <call><name>svn_wc__text_revert_path</name><argument_list>(<argument><expr><name><name>fb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>,
                                                        <argument><expr><name><name>fb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <expr_stmt><expr><name><name>fb</name>-&gt;<name>text_base_path</name></name> = <call><name>svn_wc__text_base_path</name><argument_list>(<argument><expr><name><name>fb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name><name>fb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>fb</name>-&gt;<name>new_text_base_path</name></name> = <call><name>svn_wc__text_base_path</name><argument_list>(<argument><expr><name><name>fb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>,
                                                      <argument><expr><name><name>fb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

  <if>if <condition>(<expr><name>checksum_p</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr>*<name>checksum_p</name> = <name>NULL</name></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>ent</name></expr>)</condition><then>
        <expr_stmt><expr>*<name>checksum_p</name> = <name><name>ent</name>-&gt;<name>checksum</name></name></expr>;</expr_stmt></then></if>
    }</block></then></if>
  <if>if <condition>(<expr><name>replaced_p</name></expr>)</condition><then>
    <expr_stmt><expr>*<name>replaced_p</name> = <name>replaced</name></expr>;</expr_stmt></then></if>
  <if>if <condition>(<expr><name>use_revert_base_p</name></expr>)</condition><then>
    <expr_stmt><expr>*<name>use_revert_base_p</name> = <name>use_revert_base</name></expr>;</expr_stmt></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>



<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>apply_textdelta</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>file_baton</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>base_checksum</name></decl></param>,
                <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                <param><decl><type><name>svn_txdelta_window_handler_t</name> *</type><name>handler</name></decl></param>,
                <param><decl><type><name>void</name> **</type><name>handler_baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>file_baton</name> *</type><name>fb</name> <init>= <expr><name>file_baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>handler_pool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name><name>fb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>handler_baton</name> *</type><name>hb</name> <init>= <expr><call><name>apr_palloc</name><argument_list>(<argument><expr><name>handler_pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>hb</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>checksum</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>replaced</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>use_revert_base</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><name><name>fb</name>-&gt;<name>skipped</name></name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr>*<name>handler</name> = <name>svn_delta_noop_window_handler</name></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>handler_baton</name> = <name>NULL</name></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>

  <expr_stmt><expr><name><name>fb</name>-&gt;<name>received_textdelta</name></name> = <name>TRUE</name></expr>;</expr_stmt>

  <comment type="block">/* Before applying incoming svndiff data to text base, make sure
     text base hasn't been corrupted, and that its checksum
     matches the expected base checksum. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>choose_base_paths</name><argument_list>(<argument><expr>&amp;<name>checksum</name></expr></argument>, <argument><expr>&amp;<name>replaced</name></expr></argument>, <argument><expr>&amp;<name>use_revert_base</name></expr></argument>,
                            <argument><expr><name>fb</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Only compare checksums if this file has an entry, and the entry has
     a checksum.  If there's no entry, it just means the file is
     created in this update, so there won't be any previously recorded
     checksum to compare against.  If no checksum, well, for backwards
     compatibility we assume that no checksum always matches. */</comment>
  <if>if <condition>(<expr><name>checksum</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>digest</name><index>[<expr><name>APR_MD5_DIGESTSIZE</name></expr>]</index></name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>hex_digest</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_checksum</name><argument_list>(<argument><expr><name>digest</name></expr></argument>, <argument><expr><name><name>fb</name>-&gt;<name>text_base_path</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>hex_digest</name> = <call><name>svn_md5_digest_to_cstring_display</name><argument_list>(<argument><expr><name>digest</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Compare the base_checksum here, rather than in the window
         handler, because there's no guarantee that the handler will
         see every byte of the base file. */</comment>
      <if>if <condition>(<expr><name>base_checksum</name></expr>)</condition><then>
        <block>{
          <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>hex_digest</name></expr></argument>, <argument><expr><name>base_checksum</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
            <return>return <expr><call><name>svn_error_createf</name>
              <argument_list>(<argument><expr><name>SVN_ERR_WC_CORRUPT_TEXT_BASE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
               <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Checksum mismatch for '%s'; expected: '%s', actual: '%s'"</expr></argument>)</argument_list></call></expr></argument>,
               <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name><name>fb</name>-&gt;<name>text_base_path</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>base_checksum</name></expr></argument>,
               <argument><expr><name>hex_digest</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
        }</block></then></if>

      <if>if <condition>(<expr>! <name>replaced</name> &amp;&amp; <call><name>strcmp</name><argument_list>(<argument><expr><name>hex_digest</name></expr></argument>, <argument><expr><name>checksum</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
        <block>{
          <return>return <expr><call><name>svn_error_createf</name>
            <argument_list>(<argument><expr><name>SVN_ERR_WC_CORRUPT_TEXT_BASE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
             <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Checksum mismatch for '%s'; recorded: '%s', actual: '%s'"</expr></argument>)</argument_list></call></expr></argument>,
             <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name><name>fb</name>-&gt;<name>text_base_path</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>checksum</name></expr></argument>,
             <argument><expr><name>hex_digest</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
    }</block></then></if>

  <comment type="block">/* Open the text base for reading, unless this is an added file. */</comment>

  <comment type="block">/*
     kff todo: what we really need to do here is:

     1. See if there's a file or dir by this name already here.
     2. See if it's under revision control.
     3. If both are true, open text-base.
     4. If only 1 is true, bail, because we can't go destroying user's
        files (or as an alternative to bailing, move it to some tmp
        name and somehow tell the user, but communicating with the
        user without erroring is a whole callback system we haven't
        finished inventing yet.)
  */</comment>

  <if>if <condition>(<expr>! <name><name>fb</name>-&gt;<name>added</name></name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr><name>use_revert_base</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__open_revert_base</name><argument_list>(<argument><expr>&amp;<name><name>hb</name>-&gt;<name>source</name></name></expr></argument>, <argument><expr><name><name>fb</name>-&gt;<name>path</name></name></expr></argument>,
                                         <argument><expr><name>APR_READ</name></expr></argument>,
                                         <argument><expr><name>handler_pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
      <else>else
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__open_text_base</name><argument_list>(<argument><expr>&amp;<name><name>hb</name>-&gt;<name>source</name></name></expr></argument>, <argument><expr><name><name>fb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>APR_READ</name></expr></argument>,
                                       <argument><expr><name>handler_pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

    }</block></then>
  <else>else
    <block>{
      <if>if <condition>(<expr><name><name>fb</name>-&gt;<name>copied_text_base</name></name></expr>)</condition><then>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_open</name><argument_list>(<argument><expr>&amp;<name><name>hb</name>-&gt;<name>source</name></name></expr></argument>, <argument><expr><name><name>fb</name>-&gt;<name>copied_text_base</name></name></expr></argument>,
                                 <argument><expr><name>APR_READ</name></expr></argument>, <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>, <argument><expr><name>handler_pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
      <else>else
        <expr_stmt><expr><name><name>hb</name>-&gt;<name>source</name></name> = <name>NULL</name></expr>;</expr_stmt></else></if>
    }</block></else></if>

  <comment type="block">/* Open the text base for writing (this will get us a temporary file).  */</comment>

  <if>if <condition>(<expr><name>use_revert_base</name></expr>)</condition><then>
    <expr_stmt><expr><name>err</name> = <call><name>svn_wc__open_revert_base</name><argument_list>(<argument><expr>&amp;<name><name>hb</name>-&gt;<name>dest</name></name></expr></argument>, <argument><expr><name><name>fb</name>-&gt;<name>path</name></name></expr></argument>,
                                   <argument><expr>(<name>APR_WRITE</name> | <name>APR_TRUNCATE</name> | <name>APR_CREATE</name>)</expr></argument>,
                                   <argument><expr><name>handler_pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name>err</name> = <call><name>svn_wc__open_text_base</name><argument_list>(<argument><expr>&amp;<name><name>hb</name>-&gt;<name>dest</name></name></expr></argument>, <argument><expr><name><name>fb</name>-&gt;<name>path</name></name></expr></argument>,
                                 <argument><expr>(<name>APR_WRITE</name> | <name>APR_TRUNCATE</name> | <name>APR_CREATE</name>)</expr></argument>,
                                 <argument><expr><name>handler_pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

  <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>handler_pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>err</name></expr>;</return>
    }</block></then></if>

  <comment type="block">/* Prepare to apply the delta.  */</comment>
  <expr_stmt><expr><call><name>svn_txdelta_apply</name><argument_list>(<argument><expr><call><name>svn_stream_from_aprfile</name><argument_list>(<argument><expr><name><name>hb</name>-&gt;<name>source</name></name></expr></argument>, <argument><expr><name>handler_pool</name></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><call><name>svn_stream_from_aprfile</name><argument_list>(<argument><expr><name><name>hb</name>-&gt;<name>dest</name></name></expr></argument>, <argument><expr><name>handler_pool</name></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><name><name>fb</name>-&gt;<name>digest</name></name></expr></argument>, <argument><expr><name><name>fb</name>-&gt;<name>new_text_base_path</name></name></expr></argument>, <argument><expr><name>handler_pool</name></expr></argument>,
                    <argument><expr>&amp;<name><name>hb</name>-&gt;<name>apply_handler</name></name></expr></argument>, <argument><expr>&amp;<name><name>hb</name>-&gt;<name>apply_baton</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>hb</name>-&gt;<name>pool</name></name> = <name>handler_pool</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>hb</name>-&gt;<name>fb</name></name> = <name>fb</name></expr>;</expr_stmt>

  <comment type="block">/* We're all set.  */</comment>
  <expr_stmt><expr>*<name>handler_baton</name> = <name>hb</name></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>handler</name> = <name>window_handler</name></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>




<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>change_file_prop</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>file_baton</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>value</name></decl></param>,
                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>file_baton</name> *</type><name>fb</name> <init>= <expr><name>file_baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>edit_baton</name> *</type><name>eb</name> <init>= <expr><name><name>fb</name>-&gt;<name>edit_baton</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_prop_t</name> *</type><name>propchange</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><name><name>fb</name>-&gt;<name>skipped</name></name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <comment type="block">/* Push a new propchange to the file baton's array of propchanges */</comment>
  <expr_stmt><expr><name>propchange</name> = <call><name>apr_array_push</name><argument_list>(<argument><expr><name><name>fb</name>-&gt;<name>propchanges</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>propchange</name>-&gt;<name>name</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>fb</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>propchange</name>-&gt;<name>value</name></name> = <name>value</name> ? <call><name>svn_string_dup</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name><name>fb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call> : <name>NULL</name></expr>;</expr_stmt>

  <comment type="block">/* Special case: If use-commit-times config variable is set we
     cache the last-changed-date propval so we can use it to set
     the working file's timestamp. */</comment>
  <if>if <condition>(<expr><name><name>eb</name>-&gt;<name>use_commit_times</name></name>
      &amp;&amp; (<call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>SVN_PROP_ENTRY_COMMITTED_DATE</name></expr></argument>)</argument_list></call> == 0)
      &amp;&amp; <name>value</name></expr>)</condition><then>
    <expr_stmt><expr><name><name>fb</name>-&gt;<name>last_changed_date</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>fb</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>value</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Write log commands to merge PROP_CHANGES into the existing
   properties of FILE_PATH.  PROP_CHANGES can contain regular
   properties as well as entryprops and wcprops.  Update *PROP_STATE
   to reflect the result of the regular prop merge.  Make *LOCK_STATE
   reflect the possible removal of a lock token from FILE_PATH's
   entryprops.  BASE_PROPS and WORKING_PROPS are hashes of the base and
   working props of the file; if NULL they are read from the wc.

   CONFICT_FUNC/BATON is a callback which allows the client to
   possibly resolve a property conflict interactively.

   ADM_ACCESS is the access baton for FILE_PATH.  Append log commands to
   LOG_ACCUM.  Use POOL for temporary allocations. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>merge_props</name><parameter_list>(<param><decl><type><name>svn_stringbuf_t</name> *</type><name>log_accum</name></decl></param>,
            <param><decl><type><name>svn_wc_notify_state_t</name> *</type><name>prop_state</name></decl></param>,
            <param><decl><type><name>svn_wc_notify_lock_state_t</name> *</type><name>lock_state</name></decl></param>,
            <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
            <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>file_path</name></decl></param>,
            <param><decl><type><specifier>const</specifier> <name>apr_array_header_t</name> *</type><name>prop_changes</name></decl></param>,
            <param><decl><type><name>apr_hash_t</name> *</type><name>base_props</name></decl></param>,
            <param><decl><type><name>apr_hash_t</name> *</type><name>working_props</name></decl></param>,
            <param><decl><type><name>svn_wc_conflict_resolver_func_t</name></type> <name>conflict_func</name></decl></param>,
            <param><decl><type><name>void</name> *</type><name>conflict_baton</name></decl></param>,
            <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>regular_props</name> <init>= <expr><name>NULL</name></expr></init>, *<name>wc_props</name> <init>= <expr><name>NULL</name></expr></init>,
    *<name>entry_props</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Sort the property list into three arrays, based on kind. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_categorize_props</name><argument_list>(<argument><expr><name>prop_changes</name></expr></argument>,
                               <argument><expr>&amp;<name>entry_props</name></expr></argument>, <argument><expr>&amp;<name>wc_props</name></expr></argument>, <argument><expr>&amp;<name>regular_props</name></expr></argument>,
                               <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Always initialize to unknown state. */</comment>
  <expr_stmt><expr>*<name>prop_state</name> = <name>svn_wc_notify_state_unknown</name></expr>;</expr_stmt>

  <comment type="block">/* Merge the 'regular' props into the existing working proplist. */</comment>
  <if>if <condition>(<expr><name>regular_props</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* This will merge the old and new props into a new prop db, and
         write &lt;cp&gt; commands to the logfile to install the merged
         props.  */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__merge_props</name><argument_list>(<argument><expr><name>prop_state</name></expr></argument>,
                                  <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>file_path</name></expr></argument>,
                                  <argument><expr><name>NULL</name></expr></argument> <comment type="block">/* update, not merge */</comment>,
                                  <argument><expr><name>base_props</name></expr></argument>,
                                  <argument><expr><name>working_props</name></expr></argument>,
                                  <argument><expr><name>regular_props</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                                  <argument><expr><name>conflict_func</name></expr></argument>, <argument><expr><name>conflict_baton</name></expr></argument>,
                                  <argument><expr><name>pool</name></expr></argument>, <argument><expr>&amp;<name>log_accum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* If there are any ENTRY PROPS, make sure those get appended to the
     growing log as fields for the file's entry.

     Note that no merging needs to happen; these kinds of props aren't
     versioned, so if the property is present, we overwrite the value. */</comment>
  <if>if <condition>(<expr><name>entry_props</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>accumulate_entry_props</name><argument_list>(<argument><expr><name>log_accum</name></expr></argument>, <argument><expr><name>lock_state</name></expr></argument>,
                                   <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>file_path</name></expr></argument>,
                                   <argument><expr><name>entry_props</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr>*<name>lock_state</name> = <name>svn_wc_notify_lock_state_unchanged</name></expr>;</expr_stmt></else></if>

  <comment type="block">/* This writes a whole bunch of log commands to install wcprops.  */</comment>
  <if>if <condition>(<expr><name>wc_props</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>accumulate_wcprops</name><argument_list>(<argument><expr><name>log_accum</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                               <argument><expr><name>file_path</name></expr></argument>, <argument><expr><name>wc_props</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Append, to LOG_ACCUM, log commands to update the entry for NAME in
   ADM_ACCESS with a NEW_REVISION and a NEW_URL (if non-NULL), making sure
   the entry refers to a file and has no absent or deleted state.
   Use POOL for temporary allocations. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>loggy_tweak_entry</name><parameter_list>(<param><decl><type><name>svn_stringbuf_t</name> *</type><name>log_accum</name></decl></param>,
                  <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                  <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                  <param><decl><type><name>svn_revnum_t</name></type> <name>new_revision</name></decl></param>,
                  <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>new_URL</name></decl></param>,
                  <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* Write log entry which will bump the revision number.  Also, just
     in case we're overwriting an existing phantom 'deleted' or
     'absent' entry, be sure to remove the hiddenness. */</comment>
  <decl_stmt><decl><type><name>svn_wc_entry_t</name></type> <name>tmp_entry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_uint64_t</name></type> <name>modify_flags</name> <init>= <expr><name>SVN_WC__ENTRY_MODIFY_KIND</name>
    | <name>SVN_WC__ENTRY_MODIFY_REVISION</name>
    | <name>SVN_WC__ENTRY_MODIFY_DELETED</name>
    | <name>SVN_WC__ENTRY_MODIFY_ABSENT</name>
    | <name>SVN_WC__ENTRY_MODIFY_TEXT_TIME</name>
    | <name>SVN_WC__ENTRY_MODIFY_WORKING_SIZE</name></expr></init></decl>;</decl_stmt>


  <expr_stmt><expr><name><name>tmp_entry</name>.<name>revision</name></name> = <name>new_revision</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>tmp_entry</name>.<name>kind</name></name> = <name>svn_node_file</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>tmp_entry</name>.<name>deleted</name></name> = <name>FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>tmp_entry</name>.<name>absent</name></name> = <name>FALSE</name></expr>;</expr_stmt>
  <comment type="block">/* Indicate the file was locally modified and we didn't get to
     calculate the true value, but we can't set it to UNKNOWN (-1),
     because that would indicate absense of this value.
     If it isn't locally modified,
     we'll overwrite with the actual value later. */</comment>
  <expr_stmt><expr><name><name>tmp_entry</name>.<name>working_size</name></name> = <name>SVN_WC_ENTRY_WORKING_SIZE_UNKNOWN</name></expr>;</expr_stmt>
  <comment type="block">/* The same is true for the TEXT_TIME field, except that that doesn't
     have an explicid 'changed' value, so we set the value to 'undefined'. */</comment>
  <expr_stmt><expr><name><name>tmp_entry</name>.<name>text_time</name></name> = 0</expr>;</expr_stmt>

  <comment type="block">/* Possibly install a *non*-inherited URL in the entry. */</comment>
  <if>if <condition>(<expr><name>new_URL</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name><name>tmp_entry</name>.<name>url</name></name> = <name>new_URL</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>modify_flags</name> |= <name>SVN_WC__ENTRY_MODIFY_URL</name></expr>;</expr_stmt>
    }</block></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_entry_modify</name><argument_list>(<argument><expr>&amp;<name>log_accum</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                                     <argument><expr><name>path</name></expr></argument>, <argument><expr>&amp;<name>tmp_entry</name></expr></argument>, <argument><expr><name>modify_flags</name></expr></argument>,
                                     <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* This is the small planet.  It has the complex responsibility of
 * "integrating" a new revision of a file into a working copy.
 *
 * Given a file_baton FB for a file either already under version control, or
 * prepared (see below) to join version control, fully install a
 * new revision of the file.
 *
 * By "install", we mean: create a new text-base and prop-base, merge
 * any textual and property changes into the working file, and finally
 * update all metadata so that the working copy believes it has a new
 * working revision of the file.  All of this work includes being
 * sensitive to eol translation, keyword substitution, and performing
 * all actions accumulated to FB-&gt;DIR_BATON-&gt;LOG_ACCUM.
 *
 * If there's a new text base, FB-&gt;NEW_TEXT_BASE_PATH must be the full
 * pathname of the new text base, somewhere in the administrative area
 * of the working file.  The temporary text base will be removed after
 * a successful run of the generated log commands.
 *
 * Set *CONTENT_STATE, *PROP_STATE and *LOCK_STATE to the state of the
 * contents, properties and repository lock, respectively, after the
 * installation.  If an error is returned, the value of these three
 * variables is undefined.
 *
 * POOL is used for all bookkeeping work during the installation.
 */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>merge_file</name><parameter_list>(<param><decl><type><name>svn_wc_notify_state_t</name> *</type><name>content_state</name></decl></param>,
           <param><decl><type><name>svn_wc_notify_state_t</name> *</type><name>prop_state</name></decl></param>,
           <param><decl><type><name>svn_wc_notify_lock_state_t</name> *</type><name>lock_state</name></decl></param>,
           <param><decl><type>struct <name>file_baton</name> *</type><name>fb</name></decl></param>,
           <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>parent_dir</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>edit_baton</name> *</type><name>eb</name> <init>= <expr><name><name>fb</name>-&gt;<name>edit_baton</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>log_accum</name> <init>= <expr><call><name>svn_stringbuf_create</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>is_locally_modified</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>is_replaced</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>magic_props_changed</name></decl>;</decl_stmt>
  <enum>enum <name>svn_wc_merge_outcome_t</name> <name>merge_outcome</name> <expr_stmt><expr>= <name>svn_wc_merge_unchanged</name></expr>;</expr_stmt></enum>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>entry</name></decl>;</decl_stmt>

  <comment type="block">/* Accumulated entry modifications. */</comment>
  <decl_stmt><decl><type><name>svn_wc_entry_t</name></type> <name>tmp_entry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_uint64_t</name></type> <name>flags</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

  <comment type="block">/*
     When this function is called on file F, we assume the following
     things are true:

         - The new pristine text of F, if any, is present at
           fb-&gt;new_text_base_path

         - The .svn/entries file still reflects the old version of F.

         - fb-&gt;old_text_base_path is the old pristine F.
           (This is only set if there's a new text base).

      The goal is to update the local working copy of F to reflect
      the changes received from the repository, preserving any local
      modifications.
  */</comment>

  <comment type="block">/* Start by splitting the file path, getting an access baton for the parent,
     and an entry for the file if any. */</comment>
  <expr_stmt><expr><call><name>svn_path_split</name><argument_list>(<argument><expr><name><name>fb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr>&amp;<name>parent_dir</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_adm_retrieve</name><argument_list>(<argument><expr>&amp;<name>adm_access</name></expr></argument>, <argument><expr><name><name>eb</name>-&gt;<name>adm_access</name></name></expr></argument>,
                              <argument><expr><name>parent_dir</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_entry</name><argument_list>(<argument><expr>&amp;<name>entry</name></expr></argument>, <argument><expr><name><name>fb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>! <name>entry</name> &amp;&amp; ! <name><name>fb</name>-&gt;<name>added</name></name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name><argument_list>(
        <argument><expr><name>SVN_ERR_UNVERSIONED_RESOURCE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
        <argument><expr><call><name>_</name><argument_list>(<argument><expr>"'%s' is not under version control"</expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name><name>fb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Determine if any of the propchanges are the "magic" ones that
     might require changing the working file. */</comment>
  <expr_stmt><expr><name>magic_props_changed</name> = <call><name>svn_wc__has_magic_property</name><argument_list>(<argument><expr><name><name>fb</name>-&gt;<name>propchanges</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Install all kinds of properties.  It is important to do this before
     any file content merging, since that process might expand keywords, in
     which case we want the new entryprops to be in place. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>merge_props</name><argument_list>(<argument><expr><name>log_accum</name></expr></argument>, <argument><expr><name>prop_state</name></expr></argument>, <argument><expr><name>lock_state</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                      <argument><expr><name><name>fb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name><name>fb</name>-&gt;<name>propchanges</name></name></expr></argument>,
                      <argument><expr><name><name>fb</name>-&gt;<name>copied_base_props</name></name></expr></argument>, <argument><expr><name><name>fb</name>-&gt;<name>copied_working_props</name></name></expr></argument>,
                      <argument><expr><name><name>eb</name>-&gt;<name>conflict_func</name></name></expr></argument>, <argument><expr><name><name>eb</name>-&gt;<name>conflict_baton</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Has the user made local mods to the working file?
     Note that this compares to the current pristine file, which is
     different from fb-&gt;old_text_base_path if we have a replaced-with-history
     file.  However, in the case we had an obstruction, we check against the
     new text base. (And if we're doing an add-with-history and we've already
     saved a copy of a locally-modified file, then there certainly are mods.) */</comment>
  <if>if <condition>(<expr><name><name>fb</name>-&gt;<name>copied_working_text</name></name></expr>)</condition><then>
    <expr_stmt><expr><name>is_locally_modified</name> = <name>TRUE</name></expr>;</expr_stmt></then>
  <else>else <if>if <condition>(<expr>! <name><name>fb</name>-&gt;<name>existed</name></name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__text_modified_internal_p</name><argument_list>(<argument><expr>&amp;<name>is_locally_modified</name></expr></argument>, <argument><expr><name><name>fb</name>-&gt;<name>path</name></name></expr></argument>,
                                             <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else <if>if <condition>(<expr><name><name>fb</name>-&gt;<name>new_text_base_path</name></name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__versioned_file_modcheck</name><argument_list>(<argument><expr>&amp;<name>is_locally_modified</name></expr></argument>, <argument><expr><name><name>fb</name>-&gt;<name>path</name></name></expr></argument>,
                                             <argument><expr><name>adm_access</name></expr></argument>,
                                             <argument><expr><name><name>fb</name>-&gt;<name>new_text_base_path</name></name></expr></argument>,
                                             <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name>is_locally_modified</name> = <name>FALSE</name></expr>;</expr_stmt></else></if></else></if></else></if>

  <if>if <condition>(<expr><name>entry</name> &amp;&amp; <name><name>entry</name>-&gt;<name>schedule</name></name> == <name>svn_wc_schedule_replace</name></expr>)</condition><then>
    <expr_stmt><expr><name>is_replaced</name> = <name>TRUE</name></expr>;</expr_stmt></then></if>

  <if>if <condition>(<expr><name><name>fb</name>-&gt;<name>add_existed</name></name></expr>)</condition><then>
    <block>{
      <comment type="block">/* Tweak schedule for the file's entry so it is no longer
         scheduled for addition. */</comment>
      <expr_stmt><expr><name><name>tmp_entry</name>.<name>schedule</name></name> = <name>svn_wc_schedule_normal</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>flags</name> |= (<name>SVN_WC__ENTRY_MODIFY_SCHEDULE</name> |
                <name>SVN_WC__ENTRY_MODIFY_FORCE</name>)</expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* Set the new revision and URL in the entry and clean up some other
     fields. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>loggy_tweak_entry</name><argument_list>(<argument><expr><name>log_accum</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name><name>fb</name>-&gt;<name>path</name></name></expr></argument>,
                            <argument><expr>*<name><name>eb</name>-&gt;<name>target_revision</name></name></expr></argument>, <argument><expr><name><name>fb</name>-&gt;<name>new_URL</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* For 'textual' merging, we implement this matrix.

                          Text file                   Binary File
                         -----------------------------------------------
    "Local Mods" &amp;&amp;      | svn_wc_merge uses diff3, | svn_wc_merge     |
    (!fb-&gt;existed ||     | possibly makes backups &amp; | makes backups,   |
     fb-&gt;add_existed)    | marks file as conflicted.| marks conflicted |
                         -----------------------------------------------
    "Local Mods" &amp;&amp;      |        Just leave obstructing file as-is.   |
    fb-&gt;existed          |                                             |
                         -----------------------------------------------
    No Mods              |        Just overwrite working file.         |
                         |                                             |
                         -----------------------------------------------

   So the first thing we do is figure out where we are in the
   matrix. */</comment>
  <if>if <condition>(<expr><name><name>fb</name>-&gt;<name>new_text_base_path</name></name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr>! <name>is_locally_modified</name> &amp;&amp; ! <name>is_replaced</name></expr>)</condition><then>
        <block>{
          <comment type="block">/* If there are no local mods, who cares whether it's a text
             or binary file!  Just write a log command to overwrite
             any working file with the new text-base.  If newline
             conversion or keyword substitution is activated, this
             will happen as well during the copy.
             For replaced files, though, we want to merge in the changes
             even if the file is not modified compared to the (non-revert)
             text-base. */</comment>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_copy</name><argument_list>(<argument><expr>&amp;<name>log_accum</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                                     <argument><expr><name>svn_wc__copy_translate</name></expr></argument>,
                                     <argument><expr><name><name>fb</name>-&gt;<name>new_text_base_path</name></name></expr></argument>,
                                     <argument><expr><name><name>fb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
      <else>else   <comment type="block">/* working file or obstruction is locally modified... */</comment>
        <block>{
          <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>wfile_kind</name> <init>= <expr><name>svn_node_unknown</name></expr></init></decl>;</decl_stmt>

          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_check_path</name><argument_list>(<argument><expr><name><name>fb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr>&amp;<name>wfile_kind</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>wfile_kind</name> == <name>svn_node_none</name> &amp;&amp; ! <name><name>fb</name>-&gt;<name>added_with_history</name></name></expr>)</condition><then>
            <block>{
              <comment type="block">/* working file is missing?!
                 Just copy the new text-base to the file. */</comment>
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_copy</name><argument_list>(<argument><expr>&amp;<name>log_accum</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                                         <argument><expr><name>svn_wc__copy_translate</name></expr></argument>,
                                         <argument><expr><name><name>fb</name>-&gt;<name>new_text_base_path</name></name></expr></argument>,
                                         <argument><expr><name><name>fb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
          <else>else <if>if <condition>(<expr>! <name><name>fb</name>-&gt;<name>existed</name></name></expr>)</condition><then>
            <comment type="block">/* Working file exists and has local mods
               or is scheduled for addition but is not an obstruction. */</comment>
            <block>{
              <comment type="block">/* Now we need to let loose svn_wc__merge_internal() to merge
                 the textual changes into the working file. */</comment>
              <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>oldrev_str</name></decl>, *<decl><type ref="prev"/><name>newrev_str</name></decl>, *<decl><type ref="prev"/><name>mine_str</name></decl>;</decl_stmt>
              <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>merge_left</name></decl>;</decl_stmt>
              <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path_ext</name> <init>= <expr>""</expr></init></decl>;</decl_stmt>

              <comment type="block">/* If we have any file extensions we're supposed to
                 preserve in generated conflict file names, then find
                 this path's extension.  But then, if it isn't one of
                 the ones we want to keep in conflict filenames,
                 pretend it doesn't have an extension at all. */</comment>
              <if>if <condition>(<expr><name><name>eb</name>-&gt;<name>ext_patterns</name></name> &amp;&amp; <name><name>eb</name>-&gt;<name>ext_patterns</name>-&gt;<name>nelts</name></name></expr>)</condition><then>
                <block>{
                  <expr_stmt><expr><call><name>svn_path_splitext</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>path_ext</name></expr></argument>, <argument><expr><name><name>fb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <if>if <condition>(<expr>! (*<name>path_ext</name>
                         &amp;&amp; <call><name>svn_cstring_match_glob_list</name><argument_list>(<argument><expr><name>path_ext</name></expr></argument>,
                                                        <argument><expr><name><name>eb</name>-&gt;<name>ext_patterns</name></name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
                    <expr_stmt><expr><name>path_ext</name> = ""</expr>;</expr_stmt></then></if>
                }</block></then></if>

              <comment type="block">/* Create strings representing the revisions of the
                 old and new text-bases. */</comment>
              <comment type="block">/* Either an old version, or an add-with-history */</comment>
              <if>if <condition>(<expr><name><name>fb</name>-&gt;<name>added_with_history</name></name></expr>)</condition><then>
                <expr_stmt><expr><name>oldrev_str</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>".copied%s%s"</expr></argument>,
                                          <argument><expr>*<name>path_ext</name> ? "." : ""</expr></argument>,
                                          <argument><expr>*<name>path_ext</name> ? <name>path_ext</name> : ""</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
              <else>else
                <expr_stmt><expr><name>oldrev_str</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>".r%ld%s%s"</expr></argument>,
                                          <argument><expr><name><name>entry</name>-&gt;<name>revision</name></name></expr></argument>,
                                          <argument><expr>*<name>path_ext</name> ? "." : ""</expr></argument>,
                                          <argument><expr>*<name>path_ext</name> ? <name>path_ext</name> : ""</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

              <expr_stmt><expr><name>newrev_str</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>".r%ld%s%s"</expr></argument>,
                                        <argument><expr>*<name><name>eb</name>-&gt;<name>target_revision</name></name></expr></argument>,
                                        <argument><expr>*<name>path_ext</name> ? "." : ""</expr></argument>,
                                        <argument><expr>*<name>path_ext</name> ? <name>path_ext</name> : ""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>mine_str</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>".mine%s%s"</expr></argument>,
                                      <argument><expr>*<name>path_ext</name> ? "." : ""</expr></argument>,
                                      <argument><expr>*<name>path_ext</name> ? <name>path_ext</name> : ""</expr></argument>)</argument_list></call></expr>;</expr_stmt>

              <if>if <condition>(<expr><name><name>fb</name>-&gt;<name>add_existed</name></name> &amp;&amp; ! <name>is_replaced</name></expr>)</condition><then>
                <block>{
                  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_create_tmp_file2</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>merge_left</name></expr></argument>,
                                                  <argument><expr><call><name>svn_wc_adm_access_path</name><argument_list>(
                                                      <argument><expr><name>adm_access</name></expr></argument>)</argument_list></call></expr></argument>,
                                                  <argument><expr><name>svn_io_file_del_none</name></expr></argument>,
                                                  <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                }</block></then>
              <else>else <if>if <condition>(<expr><name><name>fb</name>-&gt;<name>copied_text_base</name></name></expr>)</condition><then>
                <expr_stmt><expr><name>merge_left</name> = <name><name>fb</name>-&gt;<name>copied_text_base</name></name></expr>;</expr_stmt></then>
              <else>else
                <expr_stmt><expr><name>merge_left</name> = <name><name>fb</name>-&gt;<name>text_base_path</name></name></expr>;</expr_stmt></else></if></else></if>

              <comment type="block">/* Merge the changes from the old textbase to the new
                 textbase into the file we're updating.
                 Remember that this function wants full paths! */</comment>
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__merge_internal</name>
                      <argument_list>(<argument><expr>&amp;<name>log_accum</name></expr></argument>, <argument><expr>&amp;<name>merge_outcome</name></expr></argument>,
                       <argument><expr><name>merge_left</name></expr></argument>,
                       <argument><expr><name><name>fb</name>-&gt;<name>new_text_base_path</name></name></expr></argument>,
                       <argument><expr><name><name>fb</name>-&gt;<name>path</name></name></expr></argument>,
                       <argument><expr><name><name>fb</name>-&gt;<name>copied_working_text</name></name></expr></argument>,
                       <argument><expr><name>adm_access</name></expr></argument>,
                       <argument><expr><name>oldrev_str</name></expr></argument>, <argument><expr><name>newrev_str</name></expr></argument>, <argument><expr><name>mine_str</name></expr></argument>,
                       <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name><name>eb</name>-&gt;<name>diff3_cmd</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>fb</name>-&gt;<name>propchanges</name></name></expr></argument>,
                       <argument><expr><name><name>eb</name>-&gt;<name>conflict_func</name></name></expr></argument>, <argument><expr><name><name>eb</name>-&gt;<name>conflict_baton</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

              <comment type="block">/* If we created a temporary left merge file, get rid of it. */</comment>
              <if>if <condition>(<expr><name>merge_left</name> != <name><name>fb</name>-&gt;<name>text_base_path</name></name></expr>)</condition><then>
                <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_remove</name><argument_list>(<argument><expr>&amp;<name>log_accum</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                                             <argument><expr><name>merge_left</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

              <comment type="block">/* And clean up add-with-history-related temp file too. */</comment>
              <if>if <condition>(<expr><name><name>fb</name>-&gt;<name>copied_working_text</name></name></expr>)</condition><then>
                <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_remove</name><argument_list>(<argument><expr>&amp;<name>log_accum</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                                             <argument><expr><name><name>fb</name>-&gt;<name>copied_working_text</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

            }</block></then></if></else></if> <comment type="block">/* end: working file exists and has mods */</comment>
        }</block></else></if> <comment type="block">/* end: working file has mods */</comment>
    }</block></then> <comment type="block">/* end: "textual" merging process */</comment>
  <else>else
    <block>{
      <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>keywords</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__get_keywords</name><argument_list>(<argument><expr>&amp;<name>keywords</name></expr></argument>, <argument><expr><name><name>fb</name>-&gt;<name>path</name></name></expr></argument>,
                                   <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>magic_props_changed</name> || <name>keywords</name></expr>)</condition><then>
        <comment type="block">/* no new text base, but... */</comment>
        <block>{
          <comment type="block">/* Special edge-case: it's possible that this file installation
             only involves propchanges, but that some of those props still
             require a retranslation of the working file.

             OR that the file doesn't involve propchanges which by themselves
             require retranslation, but receiving a change bumps the revision
             number which requires re-expansion of keywords... */</comment>

          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>tmptext</name></decl>;</decl_stmt>

          <comment type="block">/* Copy and DEtranslate the working file to a temp text-base.
             Note that detranslation is done according to the old props. */</comment>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_translated_file2</name><argument_list>(<argument><expr>&amp;<name>tmptext</name></expr></argument>, <argument><expr><name><name>fb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name><name>fb</name>-&gt;<name>path</name></name></expr></argument>,
                                          <argument><expr><name>adm_access</name></expr></argument>,
                                          <argument><expr><name>SVN_WC_TRANSLATE_TO_NF</name>
                                          | <name>SVN_WC_TRANSLATE_NO_OUTPUT_CLEANUP</name></expr></argument>,
                                          <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* A log command that copies the tmp-text-base and REtranslates
             it back to the working file.
             Now, since this is done during the execution of the log file, this
             retranslation is actually done according to the new props. */</comment>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_copy</name><argument_list>(<argument><expr>&amp;<name>log_accum</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                                     <argument><expr><name>svn_wc__copy_translate</name></expr></argument>,
                                     <argument><expr><name>tmptext</name></expr></argument>, <argument><expr><name><name>fb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

      <if>if <condition>(<expr>*<name>lock_state</name> == <name>svn_wc_notify_lock_state_unlocked</name></expr>)</condition><then>
        <comment type="block">/* If a lock was removed and we didn't update the text contents, we
           might need to set the file read-only. */</comment>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_maybe_set_readonly</name><argument_list>(<argument><expr>&amp;<name>log_accum</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                                                 <argument><expr><name><name>fb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></else></if>

  <comment type="block">/* Deal with installation of the new textbase, if appropriate. */</comment>
  <if>if <condition>(<expr><name><name>fb</name>-&gt;<name>new_text_base_path</name></name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_move</name><argument_list>(<argument><expr>&amp;<name>log_accum</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                 <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name><name>fb</name>-&gt;<name>new_text_base_path</name></name></expr></argument>,
                                 <argument><expr><name><name>fb</name>-&gt;<name>text_base_path</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_set_readonly</name><argument_list>(<argument><expr>&amp;<name>log_accum</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                                         <argument><expr><name><name>fb</name>-&gt;<name>text_base_path</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* If the file is replaced don't write the checksum.  Checksum is blank
         on replaced files. */</comment>
      <if>if <condition>(<expr>!<name>is_replaced</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name><name>tmp_entry</name>.<name>checksum</name></name> = <call><name>svn_md5_digest_to_cstring</name><argument_list>(<argument><expr><name><name>fb</name>-&gt;<name>digest</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>flags</name> |= <name>SVN_WC__ENTRY_MODIFY_CHECKSUM</name></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>

  <comment type="block">/* Do the entry modifications we've accumulated. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_entry_modify</name><argument_list>(<argument><expr>&amp;<name>log_accum</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                                     <argument><expr><name><name>fb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr>&amp;<name>tmp_entry</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Log commands to handle text-timestamp and working-size,
     if the file is - or will be - unmodified and schedule-normal */</comment>
  <if>if <condition>(<expr>!<name>is_locally_modified</name> &amp;&amp;
      (<name><name>fb</name>-&gt;<name>added</name></name> || <name><name>entry</name>-&gt;<name>schedule</name></name> == <name>svn_wc_schedule_normal</name>)</expr>)</condition><then>
    <block>{
      <comment type="block">/* Adjust working copy file unless this file is an allowed
         obstruction. */</comment>
      <if>if <condition>(<expr><name><name>fb</name>-&gt;<name>last_changed_date</name></name> &amp;&amp; !<name><name>fb</name>-&gt;<name>existed</name></name></expr>)</condition><then>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_set_timestamp</name><argument_list>(<argument><expr>&amp;<name>log_accum</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                                            <argument><expr><name><name>fb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name><name>fb</name>-&gt;<name>last_changed_date</name></name></expr></argument>,
                                            <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

      <if>if <condition>(<expr><name><name>fb</name>-&gt;<name>new_text_base_path</name></name> || <name>magic_props_changed</name></expr>)</condition><then>
        <block>{
          <comment type="block">/* Adjust entries file to match working file */</comment>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_set_entry_timestamp_from_wc</name>
                  <argument_list>(<argument><expr>&amp;<name>log_accum</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                   <argument><expr><name><name>fb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>SVN_WC__ENTRY_ATTR_TEXT_TIME</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_set_entry_working_size_from_wc</name>
              <argument_list>(<argument><expr>&amp;<name>log_accum</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name><name>fb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* Clean up add-with-history temp file. */</comment>
  <if>if <condition>(<expr><name><name>fb</name>-&gt;<name>copied_text_base</name></name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_remove</name><argument_list>(<argument><expr>&amp;<name>log_accum</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                                 <argument><expr><name><name>fb</name>-&gt;<name>copied_text_base</name></name></expr></argument>,
                                 <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>


  <comment type="block">/* Set the returned content state. */</comment>

  <comment type="block">/* This is kind of interesting.  Even if no new text was
     installed (i.e., new_text_path was null), we could still
     report a pre-existing conflict state.  Say a file, already
     in a state of textual conflict, receives prop mods during an
     update.  Then we'll notify that it has text conflicts.  This
     seems okay to me.  I guess.  I dunno.  You? */</comment>

  <if>if <condition>(<expr><name>merge_outcome</name> == <name>svn_wc_merge_conflict</name></expr>)</condition><then>
    <expr_stmt><expr>*<name>content_state</name> = <name>svn_wc_notify_state_conflicted</name></expr>;</expr_stmt></then>
  <else>else <if>if <condition>(<expr><name><name>fb</name>-&gt;<name>new_text_base_path</name></name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr><name>is_locally_modified</name></expr>)</condition><then>
        <expr_stmt><expr>*<name>content_state</name> = <name>svn_wc_notify_state_merged</name></expr>;</expr_stmt></then>
      <else>else
        <expr_stmt><expr>*<name>content_state</name> = <name>svn_wc_notify_state_changed</name></expr>;</expr_stmt></else></if>
    }</block></then>
  <else>else
    <expr_stmt><expr>*<name>content_state</name> = <name>svn_wc_notify_state_unchanged</name></expr>;</expr_stmt></else></if></else></if>

  <comment type="block">/* Now that we've built up *all* of the loggy commands for this
     file, add them to the directory's log accumulator in one fell
     swoop. */</comment>
  <expr_stmt><expr><call><name>svn_stringbuf_appendstr</name><argument_list>(<argument><expr><name><name>fb</name>-&gt;<name>dir_baton</name>-&gt;<name>log_accum</name></name></expr></argument>, <argument><expr><name>log_accum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Mostly a wrapper around merge_file. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>close_file</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>file_baton</name></decl></param>,
           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>text_checksum</name></decl></param>,
           <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>file_baton</name> *</type><name>fb</name> <init>= <expr><name>file_baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>edit_baton</name> *</type><name>eb</name> <init>= <expr><name><name>fb</name>-&gt;<name>edit_baton</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_wc_notify_state_t</name></type> <name>content_state</name></decl>, <decl><type ref="prev"/><name>prop_state</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_wc_notify_lock_state_t</name></type> <name>lock_state</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><name><name>fb</name>-&gt;<name>skipped</name></name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>maybe_bump_dir_info</name><argument_list>(<argument><expr><name>eb</name></expr></argument>, <argument><expr><name><name>fb</name>-&gt;<name>bump_info</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>

  <comment type="block">/* Was this an add-with-history, with no apply_textdelta? */</comment>
  <if>if <condition>(<expr><name><name>fb</name>-&gt;<name>added_with_history</name></name> &amp;&amp; ! <name><name>fb</name>-&gt;<name>received_textdelta</name></name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>! <name><name>fb</name>-&gt;<name>text_base_path</name></name> &amp;&amp; ! <name><name>fb</name>-&gt;<name>new_text_base_path</name></name>
             &amp;&amp; <name><name>fb</name>-&gt;<name>copied_text_base</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Set up the base paths like apply_textdelta does. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>choose_base_paths</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>fb</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Now simulate applying a trivial delta. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_copy_file</name><argument_list>(<argument><expr><name><name>fb</name>-&gt;<name>copied_text_base</name></name></expr></argument>,
                               <argument><expr><name><name>fb</name>-&gt;<name>new_text_base_path</name></name></expr></argument>,
                               <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_checksum</name><argument_list>(<argument><expr><name><name>fb</name>-&gt;<name>digest</name></name></expr></argument>,
                                   <argument><expr><name><name>fb</name>-&gt;<name>new_text_base_path</name></name></expr></argument>,
                                   <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* window-handler assembles new pristine text in .svn/tmp/text-base/  */</comment>
  <if>if <condition>(<expr><name><name>fb</name>-&gt;<name>new_text_base_path</name></name> &amp;&amp; <name>text_checksum</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>real_sum</name> <init>= <expr><call><name>svn_md5_digest_to_cstring</name><argument_list>(<argument><expr><name><name>fb</name>-&gt;<name>digest</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <if>if <condition>(<expr><name>real_sum</name> &amp;&amp; (<call><name>strcmp</name><argument_list>(<argument><expr><name>text_checksum</name></expr></argument>, <argument><expr><name>real_sum</name></expr></argument>)</argument_list></call> != 0)</expr>)</condition><then>
        <return>return <expr><call><name>svn_error_createf</name>
          <argument_list>(<argument><expr><name>SVN_ERR_CHECKSUM_MISMATCH</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
           <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Checksum mismatch for '%s'; expected: '%s', actual: '%s'"</expr></argument>)</argument_list></call></expr></argument>,
           <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name><name>fb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>text_checksum</name></expr></argument>, <argument><expr><name>real_sum</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
    }</block></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>merge_file</name><argument_list>(<argument><expr>&amp;<name>content_state</name></expr></argument>, <argument><expr>&amp;<name>prop_state</name></expr></argument>, <argument><expr>&amp;<name>lock_state</name></expr></argument>, <argument><expr><name>fb</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* We have one less referrer to the directory's bump information. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>maybe_bump_dir_info</name><argument_list>(<argument><expr><name>eb</name></expr></argument>, <argument><expr><name><name>fb</name>-&gt;<name>bump_info</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr>((<name>content_state</name> != <name>svn_wc_notify_state_unchanged</name>) ||
       (<name>prop_state</name> != <name>svn_wc_notify_state_unchanged</name>) ||
       (<name>lock_state</name> != <name>svn_wc_notify_lock_state_unchanged</name>))
      &amp;&amp; <name><name>eb</name>-&gt;<name>notify_func</name></name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_wc_notify_t</name> *</type><name>notify</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_wc_notify_action_t</name></type> <name>action</name> <init>= <expr><name>svn_wc_notify_update_update</name></expr></init></decl>;</decl_stmt>

      <if>if <condition>(<expr><name><name>fb</name>-&gt;<name>existed</name></name> || <name><name>fb</name>-&gt;<name>add_existed</name></name></expr>)</condition><then>
        <block>{
          <if>if <condition>(<expr><name>content_state</name> != <name>svn_wc_notify_state_conflicted</name></expr>)</condition><then>
            <expr_stmt><expr><name>action</name> = <name>svn_wc_notify_exists</name></expr>;</expr_stmt></then></if>
        }</block></then>
      <else>else <if>if <condition>(<expr><name><name>fb</name>-&gt;<name>added</name></name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>action</name> = <name>svn_wc_notify_update_add</name></expr>;</expr_stmt>
        }</block></then></if></else></if>

      <expr_stmt><expr><name>notify</name> = <call><name>svn_wc_create_notify</name><argument_list>(<argument><expr><name><name>fb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>action</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>notify</name>-&gt;<name>kind</name></name> = <name>svn_node_file</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>notify</name>-&gt;<name>content_state</name></name> = <name>content_state</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>notify</name>-&gt;<name>prop_state</name></name> = <name>prop_state</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>notify</name>-&gt;<name>lock_state</name></name> = <name>lock_state</name></expr>;</expr_stmt>
      <comment type="block">/* ### use merge_file() mimetype here */</comment>
      <expr_stmt><expr><call>(*<name><name>eb</name>-&gt;<name>notify_func</name></name>)<argument_list>(<argument><expr><name><name>eb</name>-&gt;<name>notify_baton</name></name></expr></argument>, <argument><expr><name>notify</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>



<comment type="block">/* Beginning at DEST_DIR (and its associated entry DEST_ENTRY) within
   a working copy, search the working copy for an pre-existing
   versioned file which is exactly equal to COPYFROM_PATH@COPYFROM_REV.

   If the file isn't found, set *RETURN_PATH to NULL.

   If the file is found, return the absolute path to it in
   *RETURN_PATH, its entry in *RETURN_ENTRY, and a (read-only)
   access_t for its parent in *RETURN_ACCESS.
*/</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>locate_copyfrom</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copyfrom_path</name></decl></param>,
                <param><decl><type><name>svn_revnum_t</name></type> <name>copyfrom_rev</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dest_dir</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>dest_entry</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>return_path</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> **</type><name>return_entry</name></decl></param>,
                <param><decl><type><name>svn_wc_adm_access_t</name> **</type><name>return_access</name></decl></param>,
                <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dest_fs_path</name></decl>, *<decl><type ref="prev"/><name>ancestor_fs_path</name></decl>, *<decl><type ref="prev"/><name>ancestor_url</name></decl>, *<decl><type ref="prev"/><name>file_url</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copyfrom_parent</name></decl>, *<decl><type ref="prev"/><name>copyfrom_file</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>abs_dest_dir</name></decl>, *<decl><type ref="prev"/><name>extra_components</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>ancestor_entry</name></decl>, *<decl><type ref="prev"/><name>file_entry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_wc_adm_access_t</name> *</type><name>ancestor_access</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>levels_up</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>cwd</name></decl>, *<decl><type ref="prev"/><name>cwd_parent</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Be pessimistic.  This function is basically a series of tests
     that gives dozens of ways to fail our search, returning
     SVN_NO_ERROR in each case.  If we make it all the way to the
     bottom, we have a real discovery to return. */</comment>
  <expr_stmt><expr>*<name>return_path</name> = <name>NULL</name></expr>;</expr_stmt>

  <if>if <condition>(<expr>(! <name><name>dest_entry</name>-&gt;<name>repos</name></name>) || (! <name><name>dest_entry</name>-&gt;<name>url</name></name>)</expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_WC_COPYFROM_PATH_NOT_FOUND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                            <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Destination directory of add-with-history "
                              "is missing a URL"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><call><name>svn_path_split</name><argument_list>(<argument><expr><name>copyfrom_path</name></expr></argument>, <argument><expr>&amp;<name>copyfrom_parent</name></expr></argument>, <argument><expr>&amp;<name>copyfrom_file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_path_get_absolute</name><argument_list>(<argument><expr>&amp;<name>abs_dest_dir</name></expr></argument>, <argument><expr><name>dest_dir</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Subtract the dest_dir's URL from the repository "root" URL to get
     the absolute FS path represented by dest_dir. */</comment>
  <expr_stmt><expr><name>dest_fs_path</name> = <call><name>svn_path_is_child</name><argument_list>(<argument><expr><name><name>dest_entry</name>-&gt;<name>repos</name></name></expr></argument>, <argument><expr><name><name>dest_entry</name>-&gt;<name>url</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>! <name>dest_fs_path</name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>dest_entry</name>-&gt;<name>repos</name></name></expr></argument>, <argument><expr><name><name>dest_entry</name>-&gt;<name>url</name></name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
        <expr_stmt><expr><name>dest_fs_path</name> = ""</expr>;</expr_stmt></then>  <comment type="block">/* the urls are identical; that's ok. */</comment>
      <else>else
        <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_WC_COPYFROM_PATH_NOT_FOUND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Destination URLs are broken"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></else></if>
    }</block></then></if>
  <expr_stmt><expr><name>dest_fs_path</name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"/"</expr></argument>, <argument><expr><name>dest_fs_path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>dest_fs_path</name> = <call><name>svn_path_canonicalize</name><argument_list>(<argument><expr><name>dest_fs_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Find nearest FS ancestor dir of current FS path and copyfrom_parent */</comment>
  <expr_stmt><expr><name>ancestor_fs_path</name> = <call><name>svn_path_get_longest_ancestor</name><argument_list>(<argument><expr><name>dest_fs_path</name></expr></argument>,
                                                   <argument><expr><name>copyfrom_parent</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>ancestor_fs_path</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <comment type="block">/* Move 'up' the working copy to what ought to be the common ancestor dir. */</comment>
  <expr_stmt><expr><name>levels_up</name> = <call><name>svn_path_component_count</name><argument_list>(<argument><expr><name>dest_fs_path</name></expr></argument>)</argument_list></call>
              - <call><name>svn_path_component_count</name><argument_list>(<argument><expr><name>ancestor_fs_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>cwd</name> = <call><name>svn_stringbuf_create</name><argument_list>(<argument><expr><name>dest_dir</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_path_remove_components</name><argument_list>(<argument><expr><name>cwd</name></expr></argument>, <argument><expr><name>levels_up</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Open up this hypothetical common ancestor directory. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_check_path</name><argument_list>(<argument><expr><name><name>cwd</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr>&amp;<name>kind</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>kind</name> != <name>svn_node_dir</name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>
  <expr_stmt><expr><name>err</name> = <call><name>svn_wc_adm_open3</name><argument_list>(<argument><expr>&amp;<name>ancestor_access</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>cwd</name>-&gt;<name>data</name></name></expr></argument>,
                         <argument><expr><name>FALSE</name></expr></argument>, <comment type="block">/* open read-only, please */</comment>
                         <argument><expr>0</expr></argument>,     <comment type="block">/* open only this directory */</comment>
                         <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>err</name> &amp;&amp; <name><name>err</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_WC_NOT_DIRECTORY</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* The common ancestor directory isn't version-controlled. */</comment>
      <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then>
  <else>else <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
    <return>return <expr><name>err</name></expr>;</return></then></if></else></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_entry</name><argument_list>(<argument><expr>&amp;<name>ancestor_entry</name></expr></argument>, <argument><expr><name><name>cwd</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name>ancestor_access</name></expr></argument>,
                       <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If we got this far, we know that the ancestor dir exists, and
     that it's a working copy too.  But is it from the same
     repository?  And does it represent the URL we expect it to? */</comment>
  <if>if <condition>(<expr><name><name>dest_entry</name>-&gt;<name>uuid</name></name> &amp;&amp; <name><name>ancestor_entry</name>-&gt;<name>uuid</name></name>
      &amp;&amp; (<call><name>strcmp</name><argument_list>(<argument><expr><name><name>dest_entry</name>-&gt;<name>uuid</name></name></expr></argument>, <argument><expr><name><name>ancestor_entry</name>-&gt;<name>uuid</name></name></expr></argument>)</argument_list></call> != 0)</expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <expr_stmt><expr><name>ancestor_url</name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>,
                             <argument><expr><name><name>dest_entry</name>-&gt;<name>repos</name></name></expr></argument>, <argument><expr><name>ancestor_fs_path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>ancestor_url</name></expr></argument>, <argument><expr><name><name>ancestor_entry</name>-&gt;<name>url</name></name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* clean up adm_access junk. */</comment>

  <comment type="block">/* Add the remaining components to cwd, then 'drill down' to where
     we hope the copyfrom_path file exists. */</comment>
  <expr_stmt><expr><name>extra_components</name> = <call><name>svn_path_is_child</name><argument_list>(<argument><expr><name>ancestor_fs_path</name></expr></argument>,
                                       <argument><expr><name>copyfrom_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_path_add_component</name><argument_list>(<argument><expr><name>cwd</name></expr></argument>, <argument><expr><name>extra_components</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>cwd_parent</name> = <call><name>svn_stringbuf_create</name><argument_list>(<argument><expr><name><name>cwd</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_path_remove_component</name><argument_list>(<argument><expr><name>cwd_parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* First: does the proposed file path even exist? */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_check_path</name><argument_list>(<argument><expr><name><name>cwd</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr>&amp;<name>kind</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>kind</name> != <name>svn_node_file</name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <comment type="block">/* Next: is the file's parent-dir under version control?   */</comment>
  <expr_stmt><expr><name>err</name> = <call><name>svn_wc_adm_open3</name><argument_list>(<argument><expr>&amp;<name>ancestor_access</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>cwd_parent</name>-&gt;<name>data</name></name></expr></argument>,
                         <argument><expr><name>FALSE</name></expr></argument>, <comment type="block">/* open read-only, please */</comment>
                         <argument><expr>0</expr></argument>,     <comment type="block">/* open only the parent dir */</comment>
                         <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>err</name> &amp;&amp; <name><name>err</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_WC_NOT_DIRECTORY</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* There's an unversioned directory (and file) in the exact
         correct place in the working copy.  Chances are high that
         this file (or some parent) was deleted by 'svn update' --
         perhaps as part of a move operation -- and this file was left
         behind becouse it had local edits.  If that's true, we may
         want this thing copied over to the new place.

         Unfortunately, we have no way of knowing if this file is the
         one we're looking for.  Guessing incorrectly can be really
         hazardous, breaking the entire update.: we might find out
         when the server fails to apply a subsequent txdelta against
         it.  Or, if the server doesn't try to do that now, what if a
         future update fails to apply?  For now, the only safe thing
         to do is return no results. :-/
      */</comment>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then>
  <else>else <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
    <return>return <expr><name>err</name></expr>;</return></then></if></else></if>

  <comment type="block">/* The candidate file is under version control;  but is it
     really the file we're looking for?  &lt;wave hand in circle&gt; */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_entry</name><argument_list>(<argument><expr>&amp;<name>file_entry</name></expr></argument>, <argument><expr><name><name>cwd</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name>ancestor_access</name></expr></argument>,
                       <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>! <name>file_entry</name></expr>)</condition><then>
    <comment type="block">/* Parent dir is versioned, but file is not.  Be safe and
       return no results (see large discourse above.) */</comment>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <comment type="block">/* Is the repos UUID and file's URL what we expect it to be? */</comment>
  <if>if <condition>(<expr><name><name>file_entry</name>-&gt;<name>uuid</name></name> &amp;&amp; <name><name>dest_entry</name>-&gt;<name>uuid</name></name>
      &amp;&amp; (<call><name>strcmp</name><argument_list>(<argument><expr><name><name>file_entry</name>-&gt;<name>uuid</name></name></expr></argument>, <argument><expr><name><name>dest_entry</name>-&gt;<name>uuid</name></name></expr></argument>)</argument_list></call> != 0)</expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <expr_stmt><expr><name>file_url</name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>, <argument><expr><name><name>file_entry</name>-&gt;<name>repos</name></name></expr></argument>, <argument><expr><name>copyfrom_path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>file_url</name></expr></argument>, <argument><expr><name><name>file_entry</name>-&gt;<name>url</name></name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <comment type="block">/* Do we actually have valid revisions for the file?  (See Issue
     #2977.) */</comment>
  <if>if <condition>(<expr>! (<call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name><name>file_entry</name>-&gt;<name>cmt_rev</name></name></expr></argument>)</argument_list></call>
         &amp;&amp; <call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name><name>file_entry</name>-&gt;<name>revision</name></name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <comment type="block">/* Do we have the the right *version* of the file? */</comment>
  <if>if <condition>(<expr>! ((<name><name>file_entry</name>-&gt;<name>cmt_rev</name></name> &lt;= <name>copyfrom_rev</name>)
         &amp;&amp; (<name>copyfrom_rev</name> &lt;= <name><name>file_entry</name>-&gt;<name>revision</name></name>))</expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <comment type="block">/* Success!  We found the exact file we wanted! */</comment>
  <expr_stmt><expr>*<name>return_path</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>cwd</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>return_entry</name> = <name>file_entry</name></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>return_access</name> = <name>ancestor_access</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Given a set of properties PROPS_IN, find all regular properties
   and shallowly copy them into a new set (allocate the new set in
   POOL, but the set's members retain their original allocations). */</comment>
<function><type><specifier>static</specifier> <name>apr_hash_t</name> *</type>
<name>copy_regular_props</name><parameter_list>(<param><decl><type><name>apr_hash_t</name> *</type><name>props_in</name></decl></param>,
                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>props_out</name> <init>= <expr><call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>

  <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>props_in</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>hi</name></expr>;</condition> <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>propname</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>propval</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>propname</name> = <name>key</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>propval</name> = <name>val</name></expr>;</expr_stmt>

      <if>if <condition>(<expr><call><name>svn_property_kind</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>propname</name></expr></argument>)</argument_list></call> == <name>svn_prop_regular_kind</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>props_out</name></expr></argument>, <argument><expr><name>propname</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>propval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></for>
  <return>return <expr><name>props_out</name></expr>;</return>
}</block></function>


<comment type="block">/* Similar to add_file(), but not actually part of the editor vtable.

   Attempt to locate COPYFROM_PATH@COPYFROM_REV within the existing
   working copy.  If found, copy it to PATH, and install it as a
   normal versioned file.  (Local edits are copied as well.)  If not
   found, then resort to fetching the file in a special RA request.

   After the file is fully installed, call the editor's open_file() on
   it, so that any subsequent apply_textdelta() commands coming from
   the server can further alter the file.
*/</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>add_file_with_history</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                      <param><decl><type><name>void</name> *</type><name>parent_baton</name></decl></param>,
                      <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copyfrom_path</name></decl></param>,
                      <param><decl><type><name>svn_revnum_t</name></type> <name>copyfrom_rev</name></decl></param>,
                      <param><decl><type><name>void</name> **</type><name>file_baton</name></decl></param>,
                      <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>void</name> *</type><name>fb</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>file_baton</name> *</type><name>tfb</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>dir_baton</name> *</type><name>pb</name> <init>= <expr><name>parent_baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>edit_baton</name> *</type><name>eb</name> <init>= <expr><name><name>pb</name>-&gt;<name>edit_baton</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl>, *<decl><type ref="prev"/><name>src_access</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>src_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>src_entry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>base_props</name></decl>, *<decl><type ref="prev"/><name>working_props</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>path_entry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>

  <comment type="block">/* The file_pool can stick around for a *long* time, so we want to
     use a subpool for any temporary allocations. */</comment>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="block">/* First, fake an add_file() call.  Notice that we don't send any
     copyfrom args, lest we end up infinitely recursing.  :-)  */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>add_file</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>parent_baton</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>SVN_INVALID_REVNUM</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>&amp;<name>fb</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>tfb</name> = (struct <name>file_baton</name> *)<name>fb</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>tfb</name>-&gt;<name>added_with_history</name></name> = <name>TRUE</name></expr>;</expr_stmt>

  <comment type="block">/* Attempt to locate the copyfrom_path in the working copy first. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_entry</name><argument_list>(<argument><expr>&amp;<name>path_entry</name></expr></argument>, <argument><expr><name><name>pb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name><name>eb</name>-&gt;<name>adm_access</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>err</name> = <call><name>locate_copyfrom</name><argument_list>(<argument><expr><name>copyfrom_path</name></expr></argument>, <argument><expr><name>copyfrom_rev</name></expr></argument>,
                        <argument><expr><name><name>pb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>path_entry</name></expr></argument>,
                        <argument><expr>&amp;<name>src_path</name></expr></argument>, <argument><expr>&amp;<name>src_entry</name></expr></argument>, <argument><expr>&amp;<name>src_access</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>err</name> &amp;&amp; <name><name>err</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_WC_COPYFROM_PATH_NOT_FOUND</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
    <return>return <expr><name>err</name></expr>;</return></then></if></else></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_adm_retrieve</name><argument_list>(<argument><expr>&amp;<name>adm_access</name></expr></argument>, <argument><expr><name><name>pb</name>-&gt;<name>edit_baton</name>-&gt;<name>adm_access</name></name></expr></argument>,
                              <argument><expr><name><name>pb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* Make a unique file name for the copyfrom text-base. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_create_tmp_file2</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name><name>tfb</name>-&gt;<name>copied_text_base</name></name></expr></argument>,
                                  <argument><expr><call><name>svn_wc_adm_access_path</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>)</argument_list></call></expr></argument>,
                                  <argument><expr><name>svn_io_file_del_none</name></expr></argument>,
                                  <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>src_path</name> != <name>NULL</name></expr>)</condition><then> <comment type="block">/* Found a file to copy */</comment>
    <block>{
      <comment type="block">/* Copy the existing file's text-base over to the (temporary)
         new text-base, where the file baton expects it to be.  Get
         the text base and props from the usual place or from the
         revert place, depending on scheduling. */</comment>

      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>src_text_base_path</name></decl>;</decl_stmt>

      <if>if <condition>(<expr><name><name>src_entry</name>-&gt;<name>schedule</name></name> == <name>svn_wc_schedule_replace</name>
          &amp;&amp; <name><name>src_entry</name>-&gt;<name>copyfrom_url</name></name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>src_text_base_path</name> = <call><name>svn_wc__text_revert_path</name><argument_list>(<argument><expr><name>src_path</name></expr></argument>,
                                                        <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__load_props</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>base_props</name></expr></argument>,
                                     <argument><expr><name>src_access</name></expr></argument>, <argument><expr><name>src_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <comment type="block">/* The old working props are lost, just like the old
             working file text is.  Just use the base props. */</comment>
          <expr_stmt><expr><name>working_props</name> = <name>base_props</name></expr>;</expr_stmt>
        }</block></then>
      <else>else
        <block>{
          <expr_stmt><expr><name>src_text_base_path</name> = <call><name>svn_wc__text_base_path</name><argument_list>(<argument><expr><name>src_path</name></expr></argument>,
                                                      <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__load_props</name><argument_list>(<argument><expr>&amp;<name>base_props</name></expr></argument>, <argument><expr>&amp;<name>working_props</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                     <argument><expr><name>src_access</name></expr></argument>, <argument><expr><name>src_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_copy_file</name><argument_list>(<argument><expr><name>src_text_base_path</name></expr></argument>, <argument><expr><name><name>tfb</name>-&gt;<name>copied_text_base</name></name></expr></argument>,
                               <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else  <comment type="block">/* Couldn't find a file to copy  */</comment>
    <block>{
      <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>textbase_file</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>textbase_stream</name></decl>;</decl_stmt>

      <comment type="block">/* Fall back to fetching it from the repository instead. */</comment>

      <if>if <condition>(<expr>! <name><name>eb</name>-&gt;<name>fetch_func</name></name></expr>)</condition><then>
        <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_WC_INVALID_OP_ON_CWD</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                <argument><expr><call><name>_</name><argument_list>(<argument><expr>"No fetch_func supplied to update_editor"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

      <comment type="block">/* Fetch the repository file's text-base and base-props;
         svn_stream_close() automatically closes the text-base file for us. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_open</name><argument_list>(<argument><expr>&amp;<name>textbase_file</name></expr></argument>, <argument><expr><name><name>tfb</name>-&gt;<name>copied_text_base</name></name></expr></argument>,
                               <argument><expr>(<name>APR_WRITE</name> | <name>APR_TRUNCATE</name> | <name>APR_CREATE</name>)</expr></argument>,
                               <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>textbase_stream</name> = <call><name>svn_stream_from_aprfile2</name><argument_list>(<argument><expr><name>textbase_file</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* copyfrom_path is a absolute path, fetch_func requires a path relative
         to the root of the repository so skip the first '/'. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>eb</name>-&gt;<name>fetch_func</name></name><argument_list>(<argument><expr><name><name>eb</name>-&gt;<name>fetch_baton</name></name></expr></argument>, <argument><expr><name>copyfrom_path</name> + 1</expr></argument>, <argument><expr><name>copyfrom_rev</name></expr></argument>,
                             <argument><expr><name>textbase_stream</name></expr></argument>,
                             <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>base_props</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_close</name><argument_list>(<argument><expr><name>textbase_stream</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>working_props</name> = <name>base_props</name></expr>;</expr_stmt>
    }</block></else></if>

  <comment type="block">/* Loop over whatever props we have in memory, and add all
     regular props to hashes in the baton. Skip entry and wc
     properties, these are only valid for the original file. */</comment>
  <expr_stmt><expr><name><name>tfb</name>-&gt;<name>copied_base_props</name></name> = <call><name>copy_regular_props</name><argument_list>(<argument><expr><name>base_props</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>tfb</name>-&gt;<name>copied_working_props</name></name> = <call><name>copy_regular_props</name><argument_list>(<argument><expr><name>working_props</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>src_path</name> != <name>NULL</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* If we copied an existing file over, we need copy its working
         text and props too, to preserve any local mods. */</comment>
      <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>text_changed</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_text_modified_p</name><argument_list>(<argument><expr>&amp;<name>text_changed</name></expr></argument>, <argument><expr><name>src_path</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                                     <argument><expr><name>src_access</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr><name>text_changed</name></expr>)</condition><then>
        <block>{
          <comment type="block">/* Make a unique file name for the copied_working_text. */</comment>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_create_tmp_file2</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name><name>tfb</name>-&gt;<name>copied_working_text</name></name></expr></argument>,
                                          <argument><expr><call><name>svn_wc_adm_access_path</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>)</argument_list></call></expr></argument>,
                                          <argument><expr><name>svn_io_file_del_none</name></expr></argument>,
                                          <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_copy_file</name><argument_list>(<argument><expr><name>src_path</name></expr></argument>, <argument><expr><name><name>tfb</name>-&gt;<name>copied_working_text</name></name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>,
                                   <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>

  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>file_baton</name> = <name>tfb</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>close_edit</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>edit_baton</name></decl></param>,
           <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>edit_baton</name> *</type><name>eb</name> <init>= <expr><name>edit_baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>target_path</name> <init>= <expr><call><name>svn_path_join</name><argument_list>(<argument><expr><name><name>eb</name>-&gt;<name>anchor</name></name></expr></argument>, <argument><expr><name><name>eb</name>-&gt;<name>target</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>log_number</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

  <comment type="block">/* If there is a target and that target is missing, then it
     apparently wasn't re-added by the update process, so we'll
     pretend that the editor deleted the entry.  The helper function
     do_entry_deletion() will take care of the necessary steps.  */</comment>
  <if>if <condition>(<expr>(*<name><name>eb</name>-&gt;<name>target</name></name>) &amp;&amp; (<call><name>svn_wc__adm_missing</name><argument_list>(<argument><expr><name><name>eb</name>-&gt;<name>adm_access</name></name></expr></argument>, <argument><expr><name>target_path</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>do_entry_deletion</name><argument_list>(<argument><expr><name>eb</name></expr></argument>, <argument><expr><name><name>eb</name>-&gt;<name>anchor</name></name></expr></argument>, <argument><expr><name><name>eb</name>-&gt;<name>target</name></name></expr></argument>, <argument><expr>&amp;<name>log_number</name></expr></argument>,
                              <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* The editor didn't even open the root; we have to take care of
     some cleanup stuffs. */</comment>
  <if>if <condition>(<expr>! <name><name>eb</name>-&gt;<name>root_opened</name></name></expr>)</condition><then>
    <block>{
      <comment type="block">/* We need to "un-incomplete" the root directory. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>complete_directory</name><argument_list>(<argument><expr><name>eb</name></expr></argument>, <argument><expr><name><name>eb</name>-&gt;<name>anchor</name></name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>


  <comment type="block">/* By definition, anybody "driving" this editor for update or switch
     purposes at a *minimum* must have called set_target_revision() at
     the outset, and close_edit() at the end -- even if it turned out
     that no changes ever had to be made, and open_root() was never
     called.  That's fine.  But regardless, when the edit is over,
     this editor needs to make sure that *all* paths have had their
     revisions bumped to the new target revision. */</comment>

  <comment type="block">/* Make sure our update target now has the new working revision.
     Also, if this was an 'svn switch', then rewrite the target's
     url.  All of this tweaking might happen recursively!  Note
     that if eb-&gt;target is NULL, that's okay (albeit "sneaky",
     some might say).  */</comment>

  <comment type="block">/* Extra check: if the update did nothing but make its target
     'deleted', then do *not* run cleanup on the target, as it
     will only remove the deleted entry!  */</comment>
  <if>if <condition>(<expr>! <name><name>eb</name>-&gt;<name>target_deleted</name></name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__do_update_cleanup</name><argument_list>(<argument><expr><name>target_path</name></expr></argument>,
                                      <argument><expr><name><name>eb</name>-&gt;<name>adm_access</name></name></expr></argument>,
                                      <argument><expr><name><name>eb</name>-&gt;<name>requested_depth</name></name></expr></argument>,
                                      <argument><expr><name><name>eb</name>-&gt;<name>switch_url</name></name></expr></argument>,
                                      <argument><expr><name><name>eb</name>-&gt;<name>repos</name></name></expr></argument>,
                                      <argument><expr>*(<name><name>eb</name>-&gt;<name>target_revision</name></name>)</expr></argument>,
                                      <argument><expr><name><name>eb</name>-&gt;<name>notify_func</name></name></expr></argument>,
                                      <argument><expr><name><name>eb</name>-&gt;<name>notify_baton</name></name></expr></argument>,
                                      <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name><name>eb</name>-&gt;<name>skipped_paths</name></name></expr></argument>,
                                      <argument><expr><name><name>eb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* The edit is over, free its pool.
     ### No, this is wrong.  Who says this editor/baton won't be used
     again?  But the change is not merely to remove this call.  We
     should also make eb-&gt;pool not be a subpool (see make_editor),
     and change callers of svn_client_{checkout,update,switch} to do
     better pool management. ### */</comment>
  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name><name>eb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<escape char="0xc"/>
<comment type="block">/*** Returning editors. ***/</comment>

<comment type="block">/* Helper for the three public editor-supplying functions. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>make_editor</name><parameter_list>(<param><decl><type><name>svn_revnum_t</name> *</type><name>target_revision</name></decl></param>,
            <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
            <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>anchor</name></decl></param>,
            <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>target</name></decl></param>,
            <param><decl><type><name>svn_boolean_t</name></type> <name>use_commit_times</name></decl></param>,
            <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>switch_url</name></decl></param>,
            <param><decl><type><name>svn_depth_t</name></type> <name>depth</name></decl></param>,
            <param><decl><type><name>svn_boolean_t</name></type> <name>depth_is_sticky</name></decl></param>,
            <param><decl><type><name>svn_boolean_t</name></type> <name>allow_unver_obstructions</name></decl></param>,
            <param><decl><type><name>svn_wc_notify_func2_t</name></type> <name>notify_func</name></decl></param>,
            <param><decl><type><name>void</name> *</type><name>notify_baton</name></decl></param>,
            <param><decl><type><name>svn_cancel_func_t</name></type> <name>cancel_func</name></decl></param>,
            <param><decl><type><name>void</name> *</type><name>cancel_baton</name></decl></param>,
            <param><decl><type><name>svn_wc_conflict_resolver_func_t</name></type> <name>conflict_func</name></decl></param>,
            <param><decl><type><name>void</name> *</type><name>conflict_baton</name></decl></param>,
            <param><decl><type><name>svn_wc_get_file_t</name></type> <name>fetch_func</name></decl></param>,
            <param><decl><type><name>void</name> *</type><name>fetch_baton</name></decl></param>,
            <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>diff3_cmd</name></decl></param>,
            <param><decl><type><name>apr_array_header_t</name> *</type><name>preserved_exts</name></decl></param>,
            <param><decl><type><specifier>const</specifier> <name>svn_delta_editor_t</name> **</type><name>editor</name></decl></param>,
            <param><decl><type><name>void</name> **</type><name>edit_baton</name></decl></param>,
            <param><decl><type><name>svn_wc_traversal_info_t</name> *</type><name>traversal_info</name></decl></param>,
            <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>edit_baton</name> *</type><name>eb</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> *</type><name>inner_baton</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_delta_editor_t</name> *</type><name>tree_editor</name> <init>= <expr><call><name>svn_delta_default_editor</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_delta_editor_t</name> *</type><name>inner_editor</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>entry</name></decl>;</decl_stmt>

  <comment type="block">/* An unknown depth can't be sticky. */</comment>
  <if>if <condition>(<expr><name>depth</name> == <name>svn_depth_unknown</name></expr>)</condition><then>
    <expr_stmt><expr><name>depth_is_sticky</name> = <name>FALSE</name></expr>;</expr_stmt></then></if>
  
  <comment type="block">/* Get the anchor entry, so we can fetch the repository root. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_entry</name><argument_list>(<argument><expr>&amp;<name>entry</name></expr></argument>, <argument><expr><name>anchor</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Disallow a switch operation to change the repository root of the target,
     if that is known. */</comment>
  <if>if <condition>(<expr><name>switch_url</name> &amp;&amp; <name>entry</name> &amp;&amp; <name><name>entry</name>-&gt;<name>repos</name></name> &amp;&amp;
      ! <call><name>svn_path_is_ancestor</name><argument_list>(<argument><expr><name><name>entry</name>-&gt;<name>repos</name></name></expr></argument>, <argument><expr><name>switch_url</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name>
      <argument_list>(<argument><expr><name>SVN_ERR_WC_INVALID_SWITCH</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"'%s'\n"
         "is not the same repository as\n"
         "'%s'"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>switch_url</name></expr></argument>, <argument><expr><name><name>entry</name>-&gt;<name>repos</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Construct an edit baton. */</comment>
  <expr_stmt><expr><name>eb</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>eb</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>eb</name>-&gt;<name>pool</name></name>                     = <name>subpool</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>eb</name>-&gt;<name>use_commit_times</name></name>         = <name>use_commit_times</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>eb</name>-&gt;<name>target_revision</name></name>          = <name>target_revision</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>eb</name>-&gt;<name>switch_url</name></name>               = <name>switch_url</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>eb</name>-&gt;<name>repos</name></name>                    = <name>entry</name> ? <name><name>entry</name>-&gt;<name>repos</name></name> : <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>eb</name>-&gt;<name>adm_access</name></name>               = <name>adm_access</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>eb</name>-&gt;<name>anchor</name></name>                   = <name>anchor</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>eb</name>-&gt;<name>target</name></name>                   = <name>target</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>eb</name>-&gt;<name>requested_depth</name></name>          = <name>depth</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>eb</name>-&gt;<name>depth_is_sticky</name></name>          = <name>depth_is_sticky</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>eb</name>-&gt;<name>notify_func</name></name>              = <name>notify_func</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>eb</name>-&gt;<name>notify_baton</name></name>             = <name>notify_baton</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>eb</name>-&gt;<name>traversal_info</name></name>           = <name>traversal_info</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>eb</name>-&gt;<name>diff3_cmd</name></name>                = <name>diff3_cmd</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>eb</name>-&gt;<name>cancel_func</name></name>              = <name>cancel_func</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>eb</name>-&gt;<name>cancel_baton</name></name>             = <name>cancel_baton</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>eb</name>-&gt;<name>conflict_func</name></name>            = <name>conflict_func</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>eb</name>-&gt;<name>conflict_baton</name></name>           = <name>conflict_baton</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>eb</name>-&gt;<name>fetch_func</name></name>               = <name>fetch_func</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>eb</name>-&gt;<name>fetch_baton</name></name>              = <name>fetch_baton</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>eb</name>-&gt;<name>allow_unver_obstructions</name></name> = <name>allow_unver_obstructions</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>eb</name>-&gt;<name>skipped_paths</name></name>            = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>eb</name>-&gt;<name>ext_patterns</name></name>             = <name>preserved_exts</name></expr>;</expr_stmt>

  <comment type="block">/* Construct an editor. */</comment>
  <expr_stmt><expr><name><name>tree_editor</name>-&gt;<name>set_target_revision</name></name> = <name>set_target_revision</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>tree_editor</name>-&gt;<name>open_root</name></name> = <name>open_root</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>tree_editor</name>-&gt;<name>delete_entry</name></name> = <name>delete_entry</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>tree_editor</name>-&gt;<name>add_directory</name></name> = <name>add_directory</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>tree_editor</name>-&gt;<name>open_directory</name></name> = <name>open_directory</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>tree_editor</name>-&gt;<name>change_dir_prop</name></name> = <name>change_dir_prop</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>tree_editor</name>-&gt;<name>close_directory</name></name> = <name>close_directory</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>tree_editor</name>-&gt;<name>absent_directory</name></name> = <name>absent_directory</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>tree_editor</name>-&gt;<name>add_file</name></name> = <name>add_file</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>tree_editor</name>-&gt;<name>open_file</name></name> = <name>open_file</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>tree_editor</name>-&gt;<name>apply_textdelta</name></name> = <name>apply_textdelta</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>tree_editor</name>-&gt;<name>change_file_prop</name></name> = <name>change_file_prop</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>tree_editor</name>-&gt;<name>close_file</name></name> = <name>close_file</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>tree_editor</name>-&gt;<name>absent_file</name></name> = <name>absent_file</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>tree_editor</name>-&gt;<name>close_edit</name></name> = <name>close_edit</name></expr>;</expr_stmt>

  <comment type="block">/* Fiddle with the type system. */</comment>
  <expr_stmt><expr><name>inner_editor</name> = <name>tree_editor</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>inner_baton</name> = <name>eb</name></expr>;</expr_stmt>

  <comment type="block">/* If our requested depth is sticky, we'll raise an error if asked
     to make our target more shallow, which is currently unsupported.

     Otherwise, if our requested depth is *not* sticky, then we need
     to limit the scope of our operation to the ambient depths present
     in the working copy already.  If a depth was explicitly
     requested, libsvn_delta/depth_filter_editor.c will ensure that we
     never see editor calls that extend beyond the scope of the
     requested depth.  But even what we do so might extend beyond the
     scope of our ambient depth.  So we use another filtering editor
     to avoid modifying the ambient working copy depth when not asked
     to do so.  (This can also be skipped if the server understands
     consider letting the depth RA capability percolate down to this
     level.) */</comment>
  <if>if <condition>(<expr><name>depth_is_sticky</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>target_entry</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_entry</name><argument_list>(<argument><expr>&amp;<name>target_entry</name></expr></argument>, <argument><expr><call><name>svn_path_join</name><argument_list>(<argument><expr><name>anchor</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, 
                           <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>target_entry</name> &amp;&amp; (<name><name>target_entry</name>-&gt;<name>depth</name></name> &gt; <name>depth</name>)</expr>)</condition><then>
        <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_UNSUPPORTED_FEATURE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                 <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Shallowing of working copy depths is not "
                                   "yet supported"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
    }</block></then>
  <else>else
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__ambient_depth_filter_editor</name><argument_list>(<argument><expr>&amp;<name>inner_editor</name></expr></argument>,
                                                  <argument><expr>&amp;<name>inner_baton</name></expr></argument>,
                                                  <argument><expr><name>inner_editor</name></expr></argument>,
                                                  <argument><expr><name>inner_baton</name></expr></argument>,
                                                  <argument><expr><name>anchor</name></expr></argument>,
                                                  <argument><expr><name>target</name></expr></argument>,
                                                  <argument><expr><name>adm_access</name></expr></argument>,
                                                  <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_delta_get_cancellation_editor</name><argument_list>(<argument><expr><name>cancel_func</name></expr></argument>,
                                            <argument><expr><name>cancel_baton</name></expr></argument>,
                                            <argument><expr><name>inner_editor</name></expr></argument>,
                                            <argument><expr><name>inner_baton</name></expr></argument>,
                                            <argument><expr><name>editor</name></expr></argument>,
                                            <argument><expr><name>edit_baton</name></expr></argument>,
                                            <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_wc_get_update_editor3</name><parameter_list>(<param><decl><type><name>svn_revnum_t</name> *</type><name>target_revision</name></decl></param>,
                          <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>anchor</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>target</name></decl></param>,
                          <param><decl><type><name>svn_boolean_t</name></type> <name>use_commit_times</name></decl></param>,
                          <param><decl><type><name>svn_depth_t</name></type> <name>depth</name></decl></param>,
                          <param><decl><type><name>svn_boolean_t</name></type> <name>depth_is_sticky</name></decl></param>,
                          <param><decl><type><name>svn_boolean_t</name></type> <name>allow_unver_obstructions</name></decl></param>,
                          <param><decl><type><name>svn_wc_notify_func2_t</name></type> <name>notify_func</name></decl></param>,
                          <param><decl><type><name>void</name> *</type><name>notify_baton</name></decl></param>,
                          <param><decl><type><name>svn_cancel_func_t</name></type> <name>cancel_func</name></decl></param>,
                          <param><decl><type><name>void</name> *</type><name>cancel_baton</name></decl></param>,
                          <param><decl><type><name>svn_wc_conflict_resolver_func_t</name></type> <name>conflict_func</name></decl></param>,
                          <param><decl><type><name>void</name> *</type><name>conflict_baton</name></decl></param>,
                          <param><decl><type><name>svn_wc_get_file_t</name></type> <name>fetch_func</name></decl></param>,
                          <param><decl><type><name>void</name> *</type><name>fetch_baton</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>diff3_cmd</name></decl></param>,
                          <param><decl><type><name>apr_array_header_t</name> *</type><name>preserved_exts</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>svn_delta_editor_t</name> **</type><name>editor</name></decl></param>,
                          <param><decl><type><name>void</name> **</type><name>edit_baton</name></decl></param>,
                          <param><decl><type><name>svn_wc_traversal_info_t</name> *</type><name>traversal_info</name></decl></param>,
                          <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>make_editor</name><argument_list>(<argument><expr><name>target_revision</name></expr></argument>, <argument><expr><name>anchor</name></expr></argument>, <argument><expr><call><name>svn_wc_adm_access_path</name><argument_list>(<argument><expr><name>anchor</name></expr></argument>)</argument_list></call></expr></argument>,
                     <argument><expr><name>target</name></expr></argument>, <argument><expr><name>use_commit_times</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>depth_is_sticky</name></expr></argument>,
                     <argument><expr><name>allow_unver_obstructions</name></expr></argument>, <argument><expr><name>notify_func</name></expr></argument>, <argument><expr><name>notify_baton</name></expr></argument>,
                     <argument><expr><name>cancel_func</name></expr></argument>, <argument><expr><name>cancel_baton</name></expr></argument>, <argument><expr><name>conflict_func</name></expr></argument>, <argument><expr><name>conflict_baton</name></expr></argument>,
                     <argument><expr><name>fetch_func</name></expr></argument>, <argument><expr><name>fetch_baton</name></expr></argument>,
                     <argument><expr><name>diff3_cmd</name></expr></argument>, <argument><expr><name>preserved_exts</name></expr></argument>, <argument><expr><name>editor</name></expr></argument>, <argument><expr><name>edit_baton</name></expr></argument>,
                     <argument><expr><name>traversal_info</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_wc_get_update_editor2</name><parameter_list>(<param><decl><type><name>svn_revnum_t</name> *</type><name>target_revision</name></decl></param>,
                          <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>anchor</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>target</name></decl></param>,
                          <param><decl><type><name>svn_boolean_t</name></type> <name>use_commit_times</name></decl></param>,
                          <param><decl><type><name>svn_boolean_t</name></type> <name>recurse</name></decl></param>,
                          <param><decl><type><name>svn_wc_notify_func2_t</name></type> <name>notify_func</name></decl></param>,
                          <param><decl><type><name>void</name> *</type><name>notify_baton</name></decl></param>,
                          <param><decl><type><name>svn_cancel_func_t</name></type> <name>cancel_func</name></decl></param>,
                          <param><decl><type><name>void</name> *</type><name>cancel_baton</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>diff3_cmd</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>svn_delta_editor_t</name> **</type><name>editor</name></decl></param>,
                          <param><decl><type><name>void</name> **</type><name>edit_baton</name></decl></param>,
                          <param><decl><type><name>svn_wc_traversal_info_t</name> *</type><name>traversal_info</name></decl></param>,
                          <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>svn_wc_get_update_editor3</name><argument_list>(<argument><expr><name>target_revision</name></expr></argument>, <argument><expr><name>anchor</name></expr></argument>, <argument><expr><name>target</name></expr></argument>,
                                   <argument><expr><name>use_commit_times</name></expr></argument>,
                                   <argument><expr><call><name>SVN_DEPTH_INFINITY_OR_FILES</name><argument_list>(<argument><expr><name>recurse</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                                   <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>notify_func</name></expr></argument>, <argument><expr><name>notify_baton</name></expr></argument>,
                                   <argument><expr><name>cancel_func</name></expr></argument>, <argument><expr><name>cancel_baton</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                   <argument><expr><name>diff3_cmd</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>editor</name></expr></argument>, <argument><expr><name>edit_baton</name></expr></argument>,
                                   <argument><expr><name>traversal_info</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_wc_get_update_editor</name><parameter_list>(<param><decl><type><name>svn_revnum_t</name> *</type><name>target_revision</name></decl></param>,
                         <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>anchor</name></decl></param>,
                         <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>target</name></decl></param>,
                         <param><decl><type><name>svn_boolean_t</name></type> <name>use_commit_times</name></decl></param>,
                         <param><decl><type><name>svn_boolean_t</name></type> <name>recurse</name></decl></param>,
                         <param><decl><type><name>svn_wc_notify_func_t</name></type> <name>notify_func</name></decl></param>,
                         <param><decl><type><name>void</name> *</type><name>notify_baton</name></decl></param>,
                         <param><decl><type><name>svn_cancel_func_t</name></type> <name>cancel_func</name></decl></param>,
                         <param><decl><type><name>void</name> *</type><name>cancel_baton</name></decl></param>,
                         <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>diff3_cmd</name></decl></param>,
                         <param><decl><type><specifier>const</specifier> <name>svn_delta_editor_t</name> **</type><name>editor</name></decl></param>,
                         <param><decl><type><name>void</name> **</type><name>edit_baton</name></decl></param>,
                         <param><decl><type><name>svn_wc_traversal_info_t</name> *</type><name>traversal_info</name></decl></param>,
                         <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_wc__compat_notify_baton_t</name> *</type><name>nb</name> <init>= <expr><call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>nb</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>nb</name>-&gt;<name>func</name></name> = <name>notify_func</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>nb</name>-&gt;<name>baton</name></name> = <name>notify_baton</name></expr>;</expr_stmt>

  <return>return <expr><call><name>svn_wc_get_update_editor3</name><argument_list>(<argument><expr><name>target_revision</name></expr></argument>, <argument><expr><name>anchor</name></expr></argument>, <argument><expr><name>target</name></expr></argument>,
                                   <argument><expr><name>use_commit_times</name></expr></argument>,
                                   <argument><expr><call><name>SVN_DEPTH_INFINITY_OR_FILES</name><argument_list>(<argument><expr><name>recurse</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                                   <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>svn_wc__compat_call_notify_func</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>,
                                   <argument><expr><name>cancel_func</name></expr></argument>, <argument><expr><name>cancel_baton</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                   <argument><expr><name>diff3_cmd</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>editor</name></expr></argument>, <argument><expr><name>edit_baton</name></expr></argument>,
                                   <argument><expr><name>traversal_info</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_wc_get_switch_editor3</name><parameter_list>(<param><decl><type><name>svn_revnum_t</name> *</type><name>target_revision</name></decl></param>,
                          <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>anchor</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>target</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>switch_url</name></decl></param>,
                          <param><decl><type><name>svn_boolean_t</name></type> <name>use_commit_times</name></decl></param>,
                          <param><decl><type><name>svn_depth_t</name></type> <name>depth</name></decl></param>,
                          <param><decl><type><name>svn_boolean_t</name></type> <name>depth_is_sticky</name></decl></param>,
                          <param><decl><type><name>svn_boolean_t</name></type> <name>allow_unver_obstructions</name></decl></param>,
                          <param><decl><type><name>svn_wc_notify_func2_t</name></type> <name>notify_func</name></decl></param>,
                          <param><decl><type><name>void</name> *</type><name>notify_baton</name></decl></param>,
                          <param><decl><type><name>svn_cancel_func_t</name></type> <name>cancel_func</name></decl></param>,
                          <param><decl><type><name>void</name> *</type><name>cancel_baton</name></decl></param>,
                          <param><decl><type><name>svn_wc_conflict_resolver_func_t</name></type> <name>conflict_func</name></decl></param>,
                          <param><decl><type><name>void</name> *</type><name>conflict_baton</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>diff3_cmd</name></decl></param>,
                          <param><decl><type><name>apr_array_header_t</name> *</type><name>preserved_exts</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>svn_delta_editor_t</name> **</type><name>editor</name></decl></param>,
                          <param><decl><type><name>void</name> **</type><name>edit_baton</name></decl></param>,
                          <param><decl><type><name>svn_wc_traversal_info_t</name> *</type><name>traversal_info</name></decl></param>,
                          <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>switch_url</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><call><name>make_editor</name><argument_list>(<argument><expr><name>target_revision</name></expr></argument>, <argument><expr><name>anchor</name></expr></argument>, <argument><expr><call><name>svn_wc_adm_access_path</name><argument_list>(<argument><expr><name>anchor</name></expr></argument>)</argument_list></call></expr></argument>,
                     <argument><expr><name>target</name></expr></argument>, <argument><expr><name>use_commit_times</name></expr></argument>, <argument><expr><name>switch_url</name></expr></argument>, 
                     <argument><expr><name>depth</name></expr></argument>, <argument><expr><name>depth_is_sticky</name></expr></argument>, <argument><expr><name>allow_unver_obstructions</name></expr></argument>, 
                     <argument><expr><name>notify_func</name></expr></argument>, <argument><expr><name>notify_baton</name></expr></argument>, <argument><expr><name>cancel_func</name></expr></argument>, <argument><expr><name>cancel_baton</name></expr></argument>,
                     <argument><expr><name>conflict_func</name></expr></argument>, <argument><expr><name>conflict_baton</name></expr></argument>,
                     <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <comment type="block">/* TODO(sussman): add fetch callback here  */</comment>
                     <argument><expr><name>diff3_cmd</name></expr></argument>, <argument><expr><name>preserved_exts</name></expr></argument>,
                     <argument><expr><name>editor</name></expr></argument>, <argument><expr><name>edit_baton</name></expr></argument>, <argument><expr><name>traversal_info</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_wc_get_switch_editor2</name><parameter_list>(<param><decl><type><name>svn_revnum_t</name> *</type><name>target_revision</name></decl></param>,
                          <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>anchor</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>target</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>switch_url</name></decl></param>,
                          <param><decl><type><name>svn_boolean_t</name></type> <name>use_commit_times</name></decl></param>,
                          <param><decl><type><name>svn_boolean_t</name></type> <name>recurse</name></decl></param>,
                          <param><decl><type><name>svn_wc_notify_func2_t</name></type> <name>notify_func</name></decl></param>,
                          <param><decl><type><name>void</name> *</type><name>notify_baton</name></decl></param>,
                          <param><decl><type><name>svn_cancel_func_t</name></type> <name>cancel_func</name></decl></param>,
                          <param><decl><type><name>void</name> *</type><name>cancel_baton</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>diff3_cmd</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>svn_delta_editor_t</name> **</type><name>editor</name></decl></param>,
                          <param><decl><type><name>void</name> **</type><name>edit_baton</name></decl></param>,
                          <param><decl><type><name>svn_wc_traversal_info_t</name> *</type><name>traversal_info</name></decl></param>,
                          <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>switch_url</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><call><name>svn_wc_get_switch_editor3</name><argument_list>(<argument><expr><name>target_revision</name></expr></argument>, <argument><expr><name>anchor</name></expr></argument>, <argument><expr><name>target</name></expr></argument>,
                                   <argument><expr><name>switch_url</name></expr></argument>, <argument><expr><name>use_commit_times</name></expr></argument>,
                                   <argument><expr><call><name>SVN_DEPTH_INFINITY_OR_FILES</name><argument_list>(<argument><expr><name>recurse</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                                   <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>notify_func</name></expr></argument>, <argument><expr><name>notify_baton</name></expr></argument>,
                                   <argument><expr><name>cancel_func</name></expr></argument>, <argument><expr><name>cancel_baton</name></expr></argument>,
                                   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>diff3_cmd</name></expr></argument>,
                                   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>editor</name></expr></argument>, <argument><expr><name>edit_baton</name></expr></argument>, <argument><expr><name>traversal_info</name></expr></argument>,
                                   <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_wc_get_switch_editor</name><parameter_list>(<param><decl><type><name>svn_revnum_t</name> *</type><name>target_revision</name></decl></param>,
                         <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>anchor</name></decl></param>,
                         <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>target</name></decl></param>,
                         <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>switch_url</name></decl></param>,
                         <param><decl><type><name>svn_boolean_t</name></type> <name>use_commit_times</name></decl></param>,
                         <param><decl><type><name>svn_boolean_t</name></type> <name>recurse</name></decl></param>,
                         <param><decl><type><name>svn_wc_notify_func_t</name></type> <name>notify_func</name></decl></param>,
                         <param><decl><type><name>void</name> *</type><name>notify_baton</name></decl></param>,
                         <param><decl><type><name>svn_cancel_func_t</name></type> <name>cancel_func</name></decl></param>,
                         <param><decl><type><name>void</name> *</type><name>cancel_baton</name></decl></param>,
                         <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>diff3_cmd</name></decl></param>,
                         <param><decl><type><specifier>const</specifier> <name>svn_delta_editor_t</name> **</type><name>editor</name></decl></param>,
                         <param><decl><type><name>void</name> **</type><name>edit_baton</name></decl></param>,
                         <param><decl><type><name>svn_wc_traversal_info_t</name> *</type><name>traversal_info</name></decl></param>,
                         <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_wc__compat_notify_baton_t</name> *</type><name>nb</name> <init>= <expr><call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>nb</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>nb</name>-&gt;<name>func</name></name> = <name>notify_func</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>nb</name>-&gt;<name>baton</name></name> = <name>notify_baton</name></expr>;</expr_stmt>

  <return>return <expr><call><name>svn_wc_get_switch_editor3</name><argument_list>(<argument><expr><name>target_revision</name></expr></argument>, <argument><expr><name>anchor</name></expr></argument>, <argument><expr><name>target</name></expr></argument>,
                                   <argument><expr><name>switch_url</name></expr></argument>, <argument><expr><name>use_commit_times</name></expr></argument>,
                                   <argument><expr><call><name>SVN_DEPTH_INFINITY_OR_FILES</name><argument_list>(<argument><expr><name>recurse</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                                   <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>svn_wc__compat_call_notify_func</name></expr></argument>, <argument><expr><name>nb</name></expr></argument>,
                                   <argument><expr><name>cancel_func</name></expr></argument>, <argument><expr><name>cancel_baton</name></expr></argument>,
                                   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>diff3_cmd</name></expr></argument>,
                                   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>editor</name></expr></argument>, <argument><expr><name>edit_baton</name></expr></argument>, <argument><expr><name>traversal_info</name></expr></argument>,
                                   <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><name>svn_wc_traversal_info_t</name> *</type>
<name>svn_wc_init_traversal_info</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_wc_traversal_info_t</name> *</type><name>ti</name> <init>= <expr><call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>ti</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>ti</name>-&gt;<name>pool</name></name>           = <name>pool</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ti</name>-&gt;<name>externals_old</name></name>  = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ti</name>-&gt;<name>externals_new</name></name>  = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ti</name>-&gt;<name>depths</name></name>         = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>ti</name></expr>;</return>
}</block></function>


<function><type><name>void</name></type>
<name>svn_wc_edited_externals</name><parameter_list>(<param><decl><type><name>apr_hash_t</name> **</type><name>externals_old</name></decl></param>,
                        <param><decl><type><name>apr_hash_t</name> **</type><name>externals_new</name></decl></param>,
                        <param><decl><type><name>svn_wc_traversal_info_t</name> *</type><name>traversal_info</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr>*<name>externals_old</name> = <name><name>traversal_info</name>-&gt;<name>externals_old</name></name></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>externals_new</name> = <name><name>traversal_info</name>-&gt;<name>externals_new</name></name></expr>;</expr_stmt>
}</block></function>


<function><type><name>void</name></type>
<name>svn_wc_traversed_depths</name><parameter_list>(<param><decl><type><name>apr_hash_t</name> **</type><name>depths</name></decl></param>,
                        <param><decl><type><name>svn_wc_traversal_info_t</name> *</type><name>traversal_info</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr>*<name>depths</name> = <name><name>traversal_info</name>-&gt;<name>depths</name></name></expr>;</expr_stmt>
}</block></function>


<comment type="block">/* THE GOAL

   Note the following actions, where X is the thing we wish to update,
   P is a directory whose repository URL is the parent of
   X's repository URL, N is directory whose repository URL is *not*
   the parent directory of X (including the case where N is not a
   versioned resource at all):

      1.  `svn up .' from inside X.
      2.  `svn up ...P/X' from anywhere.
      3.  `svn up ...N/X' from anywhere.

   For the purposes of the discussion, in the '...N/X' situation, X is
   said to be a "working copy (WC) root" directory.

   Now consider the four cases for X's type (file/dir) in the working
   copy vs. the repository:

      A.  dir in working copy, dir in repos.
      B.  dir in working copy, file in repos.
      C.  file in working copy, dir in repos.
      D.  file in working copy, file in repos.

   Here are the results we expect for each combination of the above:

      1A. Successfully update X.
      1B. Error (you don't want to remove your current working
          directory out from underneath the application).
      1C. N/A (you can't be "inside X" if X is a file).
      1D. N/A (you can't be "inside X" if X is a file).

      2A. Successfully update X.
      2B. Successfully update X.
      2C. Successfully update X.
      2D. Successfully update X.

      3A. Successfully update X.
      3B. Error (you can't create a versioned file X inside a
          non-versioned directory).
      3C. N/A (you can't have a versioned file X in directory that is
          not its repository parent).
      3D. N/A (you can't have a versioned file X in directory that is
          not its repository parent).

   To summarize, case 2 always succeeds, and cases 1 and 3 always fail
   (or can't occur) *except* when the target is a dir that remains a
   dir after the update.

   ACCOMPLISHING THE GOAL

   Updates are accomplished by driving an editor, and an editor is
   "rooted" on a directory.  So, in order to update a file, we need to
   break off the basename of the file, rooting the editor in that
   file's parent directory, and then updating only that file, not the
   other stuff in its parent directory.

   Secondly, we look at the case where we wish to update a directory.
   This is typically trivial.  However, one problematic case, exists
   when we wish to update a directory that has been removed from the
   repository and replaced with a file of the same name.  If we root
   our edit at the initial directory, there is no editor mechanism for
   deleting that directory and replacing it with a file (this would be
   like having an editor now anchored on a file, which is disallowed).

   All that remains is to have a function with the knowledge required
   to properly decide where to root our editor, and what to act upon
   with that now-rooted editor.  Given a path to be updated, this
   function should conditionally split that path into an "anchor" and
   a "target", where the "anchor" is the directory at which the update
   editor is rooted (meaning, editor-&gt;open_root() is called with
   this directory in mind), and the "target" is the actual intended
   subject of the update.

   svn_wc_get_actual_target() is that function.

   So, what are the conditions?

   Case I: Any time X is '.' (implying it is a directory), we won't
   lop off a basename.  So we'll root our editor at X, and update all
   of X.

   Cases II &amp; III: Any time we are trying to update some path ...N/X,
   we again will not lop off a basename.  We can't root an editor at
   ...N with X as a target, either because ...N isn't a versioned
   resource at all (Case II) or because X is X is not a child of ...N
   in the repository (Case III).  We root at X, and update X.

   Cases IV-???: We lop off a basename when we are updating a
   path ...P/X, rooting our editor at ...P and updating X, or when X
   is missing from disk.

   These conditions apply whether X is a file or directory.

   ---

   As it turns out, commits need to have a similar check in place,
   too, specifically for the case where a single directory is being
   committed (we have to anchor at that directory's parent in case the
   directory itself needs to be modified) */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>check_wc_root</name><parameter_list>(<param><decl><type><name>svn_boolean_t</name> *</type><name>wc_root</name></decl></param>,
              <param><decl><type><name>svn_node_kind_t</name> *</type><name>kind</name></decl></param>,
              <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
              <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
              <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>parent</name></decl>, *<decl><type ref="prev"/><name>base_name</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>p_entry</name></decl>, *<decl><type ref="prev"/><name>entry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_wc_adm_access_t</name> *</type><name>p_access</name></decl>;</decl_stmt>

  <comment type="block">/* Go ahead and initialize our return value to the most common
     (code-wise) values. */</comment>
  <expr_stmt><expr>*<name>wc_root</name> = <name>TRUE</name></expr>;</expr_stmt>

  <comment type="block">/* Get our ancestry.  In the event that the path is unversioned,
     treat it as if it were a file so that the anchor will be the
     parent directory. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_entry</name><argument_list>(<argument><expr>&amp;<name>entry</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>kind</name></expr>)</condition><then>
    <expr_stmt><expr>*<name>kind</name> = <name>entry</name> ? <name><name>entry</name>-&gt;<name>kind</name></name> : <name>svn_node_file</name></expr>;</expr_stmt></then></if>

  <comment type="block">/* If PATH is the current working directory, we have no choice but
     to consider it a WC root (we can't examine its parent at all) */</comment>
  <if>if <condition>(<expr><call><name>svn_path_is_empty</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <comment type="block">/* If this is the root folder (of a drive), it should be the WC
     root too. */</comment>
  <if>if <condition>(<expr><call><name>svn_dirent_is_root</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <comment type="block">/* If we cannot get an entry for PATH's parent, PATH is a WC root. */</comment>
  <expr_stmt><expr><name>p_entry</name> = <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_path_split</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>&amp;<name>parent</name></expr></argument>, <argument><expr>&amp;<name>base_name</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__adm_retrieve_internal</name><argument_list>(<argument><expr>&amp;<name>p_access</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>,
                                        <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>err</name> = <name>SVN_NO_ERROR</name></expr>;</expr_stmt>
  <if>if <condition>(<expr>! <name>p_access</name></expr>)</condition><then>
    <comment type="block">/* For historical reasons we cannot rely on the caller having opened
       the parent, so try it here.  I'd like this bit to go away.  */</comment>
    <expr_stmt><expr><name>err</name> = <call><name>svn_wc_adm_probe_open3</name><argument_list>(<argument><expr>&amp;<name>p_access</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr>0</expr></argument>,
                                 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <if>if <condition>(<expr>! <name>err</name></expr>)</condition><then>
    <expr_stmt><expr><name>err</name> = <call><name>svn_wc_entry</name><argument_list>(<argument><expr>&amp;<name>p_entry</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>p_access</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <if>if <condition>(<expr><name>err</name> || (! <name>p_entry</name>)</expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>

  <comment type="block">/* If the parent directory has no url information, something is
     messed up.  Bail with an error. */</comment>
  <if>if <condition>(<expr>! <name><name>p_entry</name>-&gt;<name>url</name></name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name>
      <argument_list>(<argument><expr><name>SVN_ERR_ENTRY_MISSING_URL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"'%s' has no ancestry information"</expr></argument>)</argument_list></call></expr></argument>,
       <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* If PATH's parent in the WC is not its parent in the repository,
     PATH is a WC root. */</comment>
  <if>if <condition>(<expr><name>entry</name> &amp;&amp; <name><name>entry</name>-&gt;<name>url</name></name>
      &amp;&amp; (<call><name>strcmp</name><argument_list>(<argument><expr><call><name>svn_path_url_add_component</name><argument_list>(<argument><expr><name><name>p_entry</name>-&gt;<name>url</name></name></expr></argument>, <argument><expr><name>base_name</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                 <argument><expr><name><name>entry</name>-&gt;<name>url</name></name></expr></argument>)</argument_list></call> != 0)</expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <comment type="block">/* If PATH's parent in the repository is not its parent in the WC,
     PATH is a WC root. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_entry</name><argument_list>(<argument><expr>&amp;<name>p_entry</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>p_access</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>! <name>p_entry</name></expr>)</condition><then>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <comment type="block">/* If we have not determined that PATH is a WC root by now, it must
     not be! */</comment>
  <expr_stmt><expr>*<name>wc_root</name> = <name>FALSE</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_wc_is_wc_root</name><parameter_list>(<param><decl><type><name>svn_boolean_t</name> *</type><name>wc_root</name></decl></param>,
                  <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                  <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                  <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>check_wc_root</name><argument_list>(<argument><expr><name>wc_root</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_wc_get_actual_target</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                         <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>anchor</name></decl></param>,
                         <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>target</name></decl></param>,
                         <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>is_wc_root</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_adm_probe_open3</name><argument_list>(<argument><expr>&amp;<name>adm_access</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr>0</expr></argument>,
                                 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>check_wc_root</name><argument_list>(<argument><expr>&amp;<name>is_wc_root</name></expr></argument>, <argument><expr>&amp;<name>kind</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_adm_close</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If PATH is not a WC root, or if it is a file, lop off a basename. */</comment>
  <if>if <condition>(<expr>(! <name>is_wc_root</name>) || (<name>kind</name> == <name>svn_node_file</name>)</expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>svn_path_split</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>anchor</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <expr_stmt><expr>*<name>anchor</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>target</name> = ""</expr>;</expr_stmt>
    }</block></else></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Write, to LOG_ACCUM, commands to install properties for an added DST_PATH.
   NEW_BASE_PROPS and NEW_PROPS are base and working properties, respectively.
   BASE_PROPS can contain entryprops and wcprops as well.  ADM_ACCESS must
   be an access baton for DST_PATH.
   Use @a POOL for temporary allocations. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>install_added_props</name><parameter_list>(<param><decl><type><name>svn_stringbuf_t</name> *</type><name>log_accum</name></decl></param>,
                    <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dst_path</name></decl></param>,
                    <param><decl><type><name>apr_hash_t</name> *</type><name>new_base_props</name></decl></param>,
                    <param><decl><type><name>apr_hash_t</name> *</type><name>new_props</name></decl></param>,
                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>regular_props</name> <init>= <expr><name>NULL</name></expr></init>, *<name>wc_props</name> <init>= <expr><name>NULL</name></expr></init>,
    *<name>entry_props</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Categorize the base properties. */</comment>
  <block>{
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>prop_array</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <comment type="block">/* Diff an empty prop has against the new base props gives us an array
       of all props. */</comment>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_prop_diffs</name><argument_list>(<argument><expr>&amp;<name>prop_array</name></expr></argument>, <argument><expr><name>new_base_props</name></expr></argument>,
                           <argument><expr><call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_categorize_props</name><argument_list>(<argument><expr><name>prop_array</name></expr></argument>,
                                 <argument><expr>&amp;<name>entry_props</name></expr></argument>, <argument><expr>&amp;<name>wc_props</name></expr></argument>, <argument><expr>&amp;<name>regular_props</name></expr></argument>,
                                 <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Put regular props back into a hash table. */</comment>
    <expr_stmt><expr><name>new_base_props</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>regular_props</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>)
      <block>{
        <decl_stmt><decl><type><specifier>const</specifier> <name>svn_prop_t</name> *</type><name>prop</name> <init>= <expr>&amp;<call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>regular_props</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>svn_prop_t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>new_base_props</name></expr></argument>, <argument><expr><name><name>prop</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>,
                     <argument><expr><name><name>prop</name>-&gt;<name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></for>
  }</block>

  <comment type="block">/* Install base and working props. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__install_props</name><argument_list>(<argument><expr>&amp;<name>log_accum</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>dst_path</name></expr></argument>,
                                <argument><expr><name>new_base_props</name></expr></argument>,
                                <argument><expr><name>new_props</name> ? <name>new_props</name> : <name>new_base_props</name></expr></argument>,
                                <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Install the entry props. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>accumulate_entry_props</name><argument_list>(<argument><expr><name>log_accum</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                 <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>dst_path</name></expr></argument>,
                                 <argument><expr><name>entry_props</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* This writes a whole bunch of log commands to install wcprops.  */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>accumulate_wcprops</name><argument_list>(<argument><expr><name>log_accum</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                             <argument><expr><name>dst_path</name></expr></argument>, <argument><expr><name>wc_props</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_wc_add_repos_file2</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dst_path</name></decl></param>,
                       <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                       <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>new_text_base_path</name></decl></param>,
                       <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>new_text_path</name></decl></param>,
                       <param><decl><type><name>apr_hash_t</name> *</type><name>new_base_props</name></decl></param>,
                       <param><decl><type><name>apr_hash_t</name> *</type><name>new_props</name></decl></param>,
                       <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copyfrom_url</name></decl></param>,
                       <param><decl><type><name>svn_revnum_t</name></type> <name>copyfrom_rev</name></decl></param>,
                       <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>new_URL</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>adm_path</name> <init>= <expr><call><name>svn_wc_adm_access_path</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>tmp_text_base_path</name> <init>=
    <expr><call><name>svn_wc__text_base_path</name><argument_list>(<argument><expr><name>dst_path</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>text_base_path</name> <init>=
    <expr><call><name>svn_wc__text_base_path</name><argument_list>(<argument><expr><name>dst_path</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>ent</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_wc_entry_t</name> *</type><name>dst_entry</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>log_accum</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dir_name</name></decl>, *<decl><type ref="prev"/><name>base_name</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>svn_path_split</name><argument_list>(<argument><expr><name>dst_path</name></expr></argument>, <argument><expr>&amp;<name>dir_name</name></expr></argument>, <argument><expr>&amp;<name>base_name</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Fabricate the anticipated new URL of the target and check the
     copyfrom URL to be in the same repository. */</comment>
  <block>{
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__entry_versioned</name><argument_list>(<argument><expr>&amp;<name>ent</name></expr></argument>, <argument><expr><name>dir_name</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>new_URL</name> = <call><name>svn_path_url_add_component</name><argument_list>(<argument><expr><name><name>ent</name>-&gt;<name>url</name></name></expr></argument>, <argument><expr><name>base_name</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>copyfrom_url</name> &amp;&amp; <name><name>ent</name>-&gt;<name>repos</name></name> &amp;&amp;
        ! <call><name>svn_path_is_ancestor</name><argument_list>(<argument><expr><name><name>ent</name>-&gt;<name>repos</name></name></expr></argument>, <argument><expr><name>copyfrom_url</name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_UNSUPPORTED_FEATURE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                               <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Copyfrom-url '%s' has different repository"
                                 " root than '%s'"</expr></argument>)</argument_list></call></expr></argument>,
                               <argument><expr><name>copyfrom_url</name></expr></argument>, <argument><expr><name><name>ent</name>-&gt;<name>repos</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>
  }</block>

  <comment type="block">/* Accumulate log commands in this buffer until we're ready to close
     and run the log.  */</comment>
  <expr_stmt><expr><name>log_accum</name> = <call><name>svn_stringbuf_create</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If we're replacing the file then we need to save the destination files
     text base and prop base before replacing it. This allows us to revert
     the entire change. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_entry</name><argument_list>(<argument><expr>&amp;<name>dst_entry</name></expr></argument>, <argument><expr><name>dst_path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>dst_entry</name> &amp;&amp; <name><name>dst_entry</name>-&gt;<name>schedule</name></name> == <name>svn_wc_schedule_delete</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dst_rtext</name> <init>= <expr><call><name>svn_wc__text_revert_path</name><argument_list>(<argument><expr><name>dst_path</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                                                       <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dst_txtb</name> <init>= <expr><call><name>svn_wc__text_base_path</name><argument_list>(<argument><expr><name>dst_path</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_move</name><argument_list>(<argument><expr>&amp;<name>log_accum</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                 <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>dst_txtb</name></expr></argument>, <argument><expr><name>dst_rtext</name></expr></argument>,
                                 <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_revert_props_create</name><argument_list>(<argument><expr>&amp;<name>log_accum</name></expr></argument>,
                                                <argument><expr><name>dst_path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                                                <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* Schedule this for addition first, before the entry exists.
   * Otherwise we'll get bounced out with an error about scheduling
   * an already-versioned item for addition.
   */</comment>
  <block>{
    <decl_stmt><decl><type><name>svn_wc_entry_t</name></type> <name>tmp_entry</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_uint64_t</name></type> <name>modify_flags</name> <init>= <expr><name>SVN_WC__ENTRY_MODIFY_SCHEDULE</name></expr></init></decl>;</decl_stmt>

    <expr_stmt><expr><name><name>tmp_entry</name>.<name>schedule</name></name> = <name>svn_wc_schedule_add</name></expr>;</expr_stmt>

    <if>if <condition>(<expr><name>copyfrom_url</name></expr>)</condition><then>
      <block>{
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name>copyfrom_rev</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><name><name>tmp_entry</name>.<name>copyfrom_url</name></name> = <name>copyfrom_url</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tmp_entry</name>.<name>copyfrom_rev</name></name> = <name>copyfrom_rev</name></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>tmp_entry</name>.<name>copied</name></name> = <name>TRUE</name></expr>;</expr_stmt>

        <expr_stmt><expr><name>modify_flags</name> |= <name>SVN_WC__ENTRY_MODIFY_COPYFROM_URL</name>
          | <name>SVN_WC__ENTRY_MODIFY_COPYFROM_REV</name>
          | <name>SVN_WC__ENTRY_MODIFY_COPIED</name></expr>;</expr_stmt>
      }</block></then></if>

    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_entry_modify</name><argument_list>(<argument><expr>&amp;<name>log_accum</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                                       <argument><expr><name>dst_path</name></expr></argument>, <argument><expr>&amp;<name>tmp_entry</name></expr></argument>,
                                       <argument><expr><name>modify_flags</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block>

  <comment type="block">/* Set the new revision number and URL in the entry and clean up some other
     fields. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>loggy_tweak_entry</name><argument_list>(<argument><expr><name>log_accum</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>dst_path</name></expr></argument>,
                            <argument><expr><name>dst_entry</name> ? <name><name>dst_entry</name>-&gt;<name>revision</name></name> : <name><name>ent</name>-&gt;<name>revision</name></name></expr></argument>,
                            <argument><expr><name>new_URL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>install_added_props</name><argument_list>(<argument><expr><name>log_accum</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>dst_path</name></expr></argument>,
                              <argument><expr><name>new_base_props</name></expr></argument>, <argument><expr><name>new_props</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Make sure the text base is where our log file can refer to it. */</comment>
  <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>tmp_text_base_path</name></expr></argument>, <argument><expr><name>new_text_base_path</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_move</name><argument_list>(<argument><expr><name>new_text_base_path</name></expr></argument>, <argument><expr><name>tmp_text_base_path</name></expr></argument>,
                             <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* Install working file. */</comment>
  <if>if <condition>(<expr><name>new_text_path</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* If the caller gave us a new working file, move it in place. */</comment>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>tmp_text_path</name></decl>;</decl_stmt>

      <comment type="block">/* Move new text to temporary file in adm_access. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc_create_tmp_file2</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>tmp_text_path</name></expr></argument>, <argument><expr><name>adm_path</name></expr></argument>,
                                      <argument><expr><name>svn_io_file_del_none</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_move</name><argument_list>(<argument><expr><name>new_text_path</name></expr></argument>, <argument><expr><name>tmp_text_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Translate/rename new temporary text file to working text. */</comment>
      <if>if <condition>(<expr><call><name>svn_wc__has_special_property</name><argument_list>(<argument><expr><name>new_base_props</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_copy</name><argument_list>(<argument><expr>&amp;<name>log_accum</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                                     <argument><expr><name>svn_wc__copy_translate_special_only</name></expr></argument>,
                                     <argument><expr><name>tmp_text_path</name></expr></argument>,
                                     <argument><expr><name>dst_path</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <comment type="block">/* Remove the copy-source, making it look like a move */</comment>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_remove</name><argument_list>(<argument><expr>&amp;<name>log_accum</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                                       <argument><expr><name>tmp_text_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
      <else>else
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_move</name><argument_list>(<argument><expr>&amp;<name>log_accum</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                                   <argument><expr><name>tmp_text_path</name></expr></argument>, <argument><expr><name>dst_path</name></expr></argument>,
                                   <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_maybe_set_readonly</name><argument_list>(<argument><expr>&amp;<name>log_accum</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                                               <argument><expr><name>dst_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <comment type="block">/* No working file provided by the caller, copy and translate the
         text base. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_copy</name><argument_list>(<argument><expr>&amp;<name>log_accum</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                                 <argument><expr><name>svn_wc__copy_translate</name></expr></argument>,
                                 <argument><expr><name>tmp_text_base_path</name></expr></argument>, <argument><expr><name>dst_path</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                                 <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_set_entry_timestamp_from_wc</name>
              <argument_list>(<argument><expr>&amp;<name>log_accum</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
               <argument><expr><name>dst_path</name></expr></argument>, <argument><expr><name>SVN_WC__ENTRY_ATTR_TEXT_TIME</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_set_entry_working_size_from_wc</name>
              <argument_list>(<argument><expr>&amp;<name>log_accum</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>dst_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

  <comment type="block">/* Install new text base. */</comment>
  <block>{
    <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>digest</name><index>[<expr><name>APR_MD5_DIGESTSIZE</name></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>svn_wc_entry_t</name></type> <name>tmp_entry</name></decl>;</decl_stmt>

    <comment type="block">/* Write out log commands to set up the new text base and its
       checksum. */</comment>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_move</name><argument_list>(<argument><expr>&amp;<name>log_accum</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                               <argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>tmp_text_base_path</name></expr></argument>,
                               <argument><expr><name>text_base_path</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_set_readonly</name><argument_list>(<argument><expr>&amp;<name>log_accum</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                                       <argument><expr><name>text_base_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_checksum</name><argument_list>(<argument><expr><name>digest</name></expr></argument>, <argument><expr><name>tmp_text_base_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>tmp_entry</name>.<name>checksum</name></name> = <call><name>svn_md5_digest_to_cstring</name><argument_list>(<argument><expr><name>digest</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__loggy_entry_modify</name><argument_list>(<argument><expr>&amp;<name>log_accum</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                                       <argument><expr><name>dst_path</name></expr></argument>, <argument><expr>&amp;<name>tmp_entry</name></expr></argument>,
                                       <argument><expr><name>SVN_WC__ENTRY_MODIFY_CHECKSUM</name></expr></argument>,
                                       <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block>


  <comment type="block">/* Write our accumulation of log entries into a log file */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__write_log</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>log_accum</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_wc__run_log</name><argument_list>(<argument><expr><name>adm_access</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_wc_add_repos_file</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dst_path</name></decl></param>,
                      <param><decl><type><name>svn_wc_adm_access_t</name> *</type><name>adm_access</name></decl></param>,
                      <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>new_text_path</name></decl></param>,
                      <param><decl><type><name>apr_hash_t</name> *</type><name>new_props</name></decl></param>,
                      <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copyfrom_url</name></decl></param>,
                      <param><decl><type><name>svn_revnum_t</name></type> <name>copyfrom_rev</name></decl></param>,
                      <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>svn_wc_add_repos_file2</name><argument_list>(<argument><expr><name>dst_path</name></expr></argument>, <argument><expr><name>adm_access</name></expr></argument>,
                                <argument><expr><name>new_text_path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                <argument><expr><name>new_props</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                <argument><expr><name>copyfrom_url</name></expr></argument>, <argument><expr><name>copyfrom_rev</name></expr></argument>,
                                <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
</unit>
