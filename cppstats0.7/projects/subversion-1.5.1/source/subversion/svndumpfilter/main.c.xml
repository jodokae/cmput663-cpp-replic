<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/subversion-1.5.1/source/subversion/svndumpfilter/main.c"><comment type="block">/*
 * main.c: Subversion dump stream filtering tool.
 *
 * ====================================================================
 * Copyright (c) 2000-2006 CollabNet.  All rights reserved.
 *
 * This software is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at http://subversion.tigris.org/license-1.html.
 * If newer versions of this license are posted there, you may use a
 * newer version instead, at your option.
 *
 * This software consists of voluntary contributions made by many
 * individuals.  For exact contribution history, see the revision
 * history and logs, available at http://subversion.tigris.org/.
 * ====================================================================
 */</comment>


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_file_io.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_private_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_cmdline.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_error.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_string.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_opt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_utf.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_path.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_repos.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_fs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_pools.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_sorts.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_props.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_mergeinfo.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"private/svn_mergeinfo_private.h"</cpp:file></cpp:include>

<escape char="0xc"/>
<comment type="block">/*** Code. ***/</comment>

<comment type="block">/* Helper to open stdio streams */</comment>

<comment type="block">/* NOTE: we used to call svn_stream_from_stdio(), which wraps a stream
   around a standard stdio.h FILE pointer.  The problem is that these
   pointers operate through C Run Time (CRT) on Win32, which does all
   sorts of translation on them: LF's become CRLF's, and ctrl-Z's
   embedded in Word documents are interpreted as premature EOF's.

   So instead, we use apr_file_open_std*, which bypass the CRT and
   directly wrap the OS's file-handles, which don't know or care about
   translation.  Thus dump/load works correctly on Win32.
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>create_stdio_stream</name><argument_list>(<argument><expr><name>svn_stream_t</name> **<name>stream</name></expr></argument>,
                    <argument><expr><macro><name>APR_DECLARE</name><argument_list>(<argument>apr_status_t</argument>)</argument_list></macro> <call><name>open_fn</name><argument_list>(<argument><expr><name>apr_file_t</name> **</expr></argument>,
                                                      <argument><expr><name>apr_pool_t</name> *</expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><name>apr_pool_t</name> *<name>pool</name></expr></argument>)</argument_list>
<block>{
  <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>stdio_file</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_status_t</name></type> <name>apr_err</name> <init>= <expr><call><name>open_fn</name><argument_list>(<argument><expr>&amp;<name>stdio_file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>apr_err</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_wrap_apr</name><argument_list>(<argument><expr><name>apr_err</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't open stdio file"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr>*<name>stream</name> = <call><name>svn_stream_from_aprfile</name><argument_list>(<argument><expr><name>stdio_file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></decl></decl_stmt>


<comment type="block">/* Writes a property in dumpfile format to given stringbuf. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>write_prop_to_stringbuf</name><parameter_list>(<param><decl><type><name>svn_stringbuf_t</name> **</type><name>strbuf</name></decl></param>,
                        <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>,
                        <param><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>value</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>bytes_used</name></decl>, <decl><type ref="prev"/><name>namelen</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>SVN_KEYLINE_MAXLEN</name></expr>]</index></name></decl>;</decl_stmt>

  <comment type="block">/* Output name length, then name. */</comment>
  <expr_stmt><expr><name>namelen</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_stringbuf_appendbytes</name><argument_list>(<argument><expr>*<name>strbuf</name></expr></argument>, <argument><expr>"K "</expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>bytes_used</name> = <call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>"%d"</expr></argument>, <argument><expr><name>namelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_stringbuf_appendbytes</name><argument_list>(<argument><expr>*<name>strbuf</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bytes_used</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_stringbuf_appendbytes</name><argument_list>(<argument><expr>*<name>strbuf</name></expr></argument>, <argument><expr>"\n"</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>svn_stringbuf_appendbytes</name><argument_list>(<argument><expr>*<name>strbuf</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>namelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_stringbuf_appendbytes</name><argument_list>(<argument><expr>*<name>strbuf</name></expr></argument>, <argument><expr>"\n"</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Output value length, then value. */</comment>
  <expr_stmt><expr><call><name>svn_stringbuf_appendbytes</name><argument_list>(<argument><expr>*<name>strbuf</name></expr></argument>, <argument><expr>"V "</expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>bytes_used</name> = <call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>"%" <name>APR_SIZE_T_FMT</name></expr></argument>, <argument><expr><name><name>value</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_stringbuf_appendbytes</name><argument_list>(<argument><expr>*<name>strbuf</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bytes_used</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_stringbuf_appendbytes</name><argument_list>(<argument><expr>*<name>strbuf</name></expr></argument>, <argument><expr>"\n"</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>svn_stringbuf_appendbytes</name><argument_list>(<argument><expr>*<name>strbuf</name></expr></argument>, <argument><expr><name><name>value</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>value</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_stringbuf_appendbytes</name><argument_list>(<argument><expr>*<name>strbuf</name></expr></argument>, <argument><expr>"\n"</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<comment type="block">/* Prefix matching function to compare node-path with set of prefixes. */</comment>
<function><type><specifier>static</specifier> <name>svn_boolean_t</name></type>
<name>ary_prefix_match</name><parameter_list>(<param><decl><type><name>apr_array_header_t</name> *</type><name>pfxlist</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>pfx_len</name></decl>, <decl><type ref="prev"/><name>path_len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>pfx</name></decl>;</decl_stmt>

  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>pfxlist</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <expr_stmt><expr><name>pfx</name> = <call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>pfxlist</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pfx_len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>pfx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>path_len</name> &lt; <name>pfx_len</name></expr>)</condition><then>
        <continue>continue;</continue></then></if>
      <if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pfx</name></expr></argument>, <argument><expr><name>pfx_len</name></expr></argument>)</argument_list></call> == 0
          &amp;&amp; (<name><name>path</name><index>[<expr><name>pfx_len</name></expr>]</index></name> == '\0' || <name><name>path</name><index>[<expr><name>pfx_len</name></expr>]</index></name> == '/')</expr>)</condition><then>
        <return>return <expr><name>TRUE</name></expr>;</return></then></if>
    }</block></for>

  <return>return <expr><name>FALSE</name></expr>;</return>
}</block></function>


<comment type="block">/* Check whether we need to skip this PATH based on its presence in
   the PREFIXES list, and the DO_EXCLUDE option. */</comment>
<function><type><specifier>static</specifier> <name>APR_INLINE</name> <name>svn_boolean_t</name></type>
<name>skip_path</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><name>apr_array_header_t</name> *</type><name>prefixes</name></decl></param>,
          <param><decl><type><name>svn_boolean_t</name></type> <name>do_exclude</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* NXOR */</comment>
  <return>return <expr>(<call><name>ary_prefix_match</name><argument_list>(<argument><expr><name>prefixes</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call> ? <name>do_exclude</name> : !<name>do_exclude</name>)</expr>;</return>
}</block></function>


<escape char="0xc"/>
<comment type="block">/* Note: the input stream parser calls us with events.
   Output of the filtered dump occurs for the most part streamily with the
   event callbacks, to avoid caching large quantities of data in memory.
   The exceptions this are:
   - All revision data (headers and props) must be cached until a non-skipped
     node within the revision is found, or the revision is closed.
   - Node headers and props must be cached until all props have been received
     (to allow the Prop-content-length to be found). This is signalled either
     by the node text arriving, or the node being closed.
   The writing_begun members of the associated object batons track the state.
   output_revision() and output_node() are called to cause this flushing of
   cached data to occur.
*/</comment>


<comment type="block">/* Filtering batons */</comment>

<struct>struct <name>revmap_t</name>
<block>{
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl>;</decl_stmt> <comment type="block">/* Last non-dropped revision to which this maps. */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>was_dropped</name></decl>;</decl_stmt> <comment type="block">/* Was this revision dropped? */</comment>
}</block>;</struct>

<struct>struct <name>parse_baton_t</name>
<block>{
  <comment type="block">/* Command-line options values. */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>do_exclude</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>quiet</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>drop_empty_revs</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>do_renumber_revs</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>preserve_revprops</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>skip_missing_merge_sources</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>prefixes</name></decl>;</decl_stmt>

  <comment type="block">/* Input and output streams. */</comment>
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>in_stream</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>out_stream</name></decl>;</decl_stmt>

  <comment type="block">/* State for the filtering process. */</comment>
  <decl_stmt><decl><type><name>apr_int32_t</name></type> <name>rev_drop_count</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>dropped_nodes</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>renumber_history</name></decl>;</decl_stmt>  <comment type="block">/* svn_revnum_t -&gt; struct revmap_t */</comment>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>last_live_revision</name></decl>;</decl_stmt>
}</block>;</struct>

<struct>struct <name>revision_baton_t</name>
<block>{
  <comment type="block">/* Reference to the global parse baton. */</comment>
  <decl_stmt><decl><type>struct <name>parse_baton_t</name> *</type><name>pb</name></decl>;</decl_stmt>

  <comment type="block">/* Does this revision have node or prop changes? */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>has_nodes</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>has_props</name></decl>;</decl_stmt>

  <comment type="block">/* Did we drop any nodes? */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>had_dropped_nodes</name></decl>;</decl_stmt>

  <comment type="block">/* Written to output stream? */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>writing_begun</name></decl>;</decl_stmt>

  <comment type="block">/* The original and new (re-mapped) revision numbers. */</comment>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>rev_orig</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>rev_actual</name></decl>;</decl_stmt>

  <comment type="block">/* Pointers to dumpfile data. */</comment>
  <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>header</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>props</name></decl>;</decl_stmt>
}</block>;</struct>

<struct>struct <name>node_baton_t</name>
<block>{
  <comment type="block">/* Reference to the current revision baton. */</comment>
  <decl_stmt><decl><type>struct <name>revision_baton_t</name> *</type><name>rb</name></decl>;</decl_stmt>

  <comment type="block">/* Are we skipping this node? */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>do_skip</name></decl>;</decl_stmt>

  <comment type="block">/* Have we been instructed to change or remove props on, or change
     the text of, this node? */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>has_props</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>has_text</name></decl>;</decl_stmt>

  <comment type="block">/* Written to output stream? */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>writing_begun</name></decl>;</decl_stmt>

  <comment type="block">/* The text content length according to the dumpfile headers, because we
     need the length before we have the actual text. */</comment>
  <decl_stmt><decl><type><name>svn_filesize_t</name></type> <name>tcl</name></decl>;</decl_stmt>

  <comment type="block">/* Pointers to dumpfile data. */</comment>
  <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>header</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>props</name></decl>;</decl_stmt>
}</block>;</struct>

<escape char="0xc"/>

<comment type="block">/* Filtering vtable members */</comment>

<comment type="block">/* New revision: set up revision_baton, decide if we skip it. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>new_revision_record</name><parameter_list>(<param><decl><type><name>void</name> **</type><name>revision_baton</name></decl></param>,
                    <param><decl><type><name>apr_hash_t</name> *</type><name>headers</name></decl></param>,
                    <param><decl><type><name>void</name> *</type><name>parse_baton</name></decl></param>,
                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>revision_baton_t</name> *</type><name>rb</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>header_stream</name></decl>;</decl_stmt>

  <expr_stmt><expr>*<name>revision_baton</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument>struct <expr><name>revision_baton_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rb</name> = *<name>revision_baton</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>rb</name>-&gt;<name>pb</name></name> = <name>parse_baton</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>rb</name>-&gt;<name>has_nodes</name></name> = <name>FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>rb</name>-&gt;<name>has_props</name></name> = <name>FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>rb</name>-&gt;<name>had_dropped_nodes</name></name> = <name>FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>rb</name>-&gt;<name>writing_begun</name></name> = <name>FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>rb</name>-&gt;<name>header</name></name> = <call><name>svn_stringbuf_create</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>rb</name>-&gt;<name>props</name></name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>header_stream</name> = <call><name>svn_stream_from_stringbuf</name><argument_list>(<argument><expr><name><name>rb</name>-&gt;<name>header</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>val</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>headers</name></expr></argument>, <argument><expr><name>SVN_REPOS_DUMPFILE_REVISION_NUMBER</name></expr></argument>,
                     <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>rb</name>-&gt;<name>rev_orig</name></name> = <call><name>SVN_STR_TO_REV</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name><name>rb</name>-&gt;<name>pb</name>-&gt;<name>do_renumber_revs</name></name></expr>)</condition><then>
    <expr_stmt><expr><name><name>rb</name>-&gt;<name>rev_actual</name></name> = <name><name>rb</name>-&gt;<name>rev_orig</name></name> - <name><name>rb</name>-&gt;<name>pb</name>-&gt;<name>rev_drop_count</name></name></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name><name>rb</name>-&gt;<name>rev_actual</name></name> = <name><name>rb</name>-&gt;<name>rev_orig</name></name></expr>;</expr_stmt></else></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_printf</name><argument_list>(<argument><expr><name>header_stream</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>,
                            <argument><expr><name>SVN_REPOS_DUMPFILE_REVISION_NUMBER</name> ": %ld\n"</expr></argument>,
                            <argument><expr><name><name>rb</name>-&gt;<name>rev_actual</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>headers</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>hi</name></expr>;</condition> <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
    <block>{
      <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr>(!<call><name>strcmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>SVN_REPOS_DUMPFILE_CONTENT_LENGTH</name></expr></argument>)</argument_list></call>)
          || (!<call><name>strcmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>SVN_REPOS_DUMPFILE_PROP_CONTENT_LENGTH</name></expr></argument>)</argument_list></call>)
          || (!<call><name>strcmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>SVN_REPOS_DUMPFILE_REVISION_NUMBER</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
        <continue>continue;</continue></then></if>

      <comment type="block">/* passthru: put header into header stringbuf. */</comment>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_printf</name><argument_list>(<argument><expr><name>header_stream</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"%s: %s\n"</expr></argument>,
                                <argument><expr>(const <name>char</name> *)<name>key</name></expr></argument>,
                                <argument><expr>(const <name>char</name> *)<name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_close</name><argument_list>(<argument><expr><name>header_stream</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Output revision to dumpstream
   This may be called by new_node_record(), iff rb-&gt;has_nodes has been set
   to TRUE, or by close_revision() otherwise. This must only be called
   if rb-&gt;writing_begun is FALSE. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>output_revision</name><parameter_list>(<param><decl><type>struct <name>revision_baton_t</name> *</type><name>rb</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>bytes_used</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>SVN_KEYLINE_MAXLEN</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>hash_pool</name> <init>= <expr><call><name>apr_hash_pool_get</name><argument_list>(<argument><expr><name><name>rb</name>-&gt;<name>props</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>props</name> <init>= <expr><call><name>svn_stringbuf_create</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr><name>hash_pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>hash_pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>rb</name>-&gt;<name>writing_begun</name></name> = <name>TRUE</name></expr>;</expr_stmt>

  <comment type="block">/* If this revision has no nodes left because the ones it had were
     dropped, and we are not dropping empty revisions, and we were not
     told to preserve revision props, then we want to fixup the
     revision props to only contain:
       - the date
       - a log message that reports that this revision is just stuffing. */</comment>
  <if>if <condition>(<expr>(! <name><name>rb</name>-&gt;<name>pb</name>-&gt;<name>preserve_revprops</name></name>)
      &amp;&amp; (! <name><name>rb</name>-&gt;<name>has_nodes</name></name>)
      &amp;&amp; <name><name>rb</name>-&gt;<name>had_dropped_nodes</name></name>
      &amp;&amp; (! <name><name>rb</name>-&gt;<name>pb</name>-&gt;<name>drop_empty_revs</name></name>)</expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>old_props</name> <init>= <expr><name><name>rb</name>-&gt;<name>props</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>rb</name>-&gt;<name>has_props</name></name> = <name>TRUE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>rb</name>-&gt;<name>props</name></name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>hash_pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name><name>rb</name>-&gt;<name>props</name></name></expr></argument>, <argument><expr><name>SVN_PROP_REVISION_DATE</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>,
                   <argument><expr><call><name>apr_hash_get</name><argument_list>(<argument><expr><name>old_props</name></expr></argument>, <argument><expr><name>SVN_PROP_REVISION_DATE</name></expr></argument>,
                                <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name><name>rb</name>-&gt;<name>props</name></name></expr></argument>, <argument><expr><name>SVN_PROP_REVISION_LOG</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>,
                   <argument><expr><call><name>svn_string_create</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr>"This is an empty revision for "
                                       "padding."</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>hash_pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* Now, "rasterize" the props to a string, and append the property
     information to the header string.  */</comment>
  <if>if <condition>(<expr><name><name>rb</name>-&gt;<name>has_props</name></name></expr>)</condition><then>
    <block>{
      <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>, <argument><expr><name><name>rb</name>-&gt;<name>props</name></name></expr></argument>)</argument_list></call></expr>;</init>
           <condition><expr><name>hi</name></expr>;</condition>
           <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
        <block>{
          <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>write_prop_to_stringbuf</name><argument_list>(<argument><expr>&amp;<name>props</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
      <expr_stmt><expr><call><name>svn_stringbuf_appendcstr</name><argument_list>(<argument><expr><name>props</name></expr></argument>, <argument><expr>"PROPS-END\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>svn_stringbuf_appendcstr</name><argument_list>(<argument><expr><name><name>rb</name>-&gt;<name>header</name></name></expr></argument>,
                               <argument><expr><name>SVN_REPOS_DUMPFILE_PROP_CONTENT_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>bytes_used</name> = <call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>": %" <name>APR_SIZE_T_FMT</name></expr></argument>, <argument><expr><name><name>props</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>svn_stringbuf_appendbytes</name><argument_list>(<argument><expr><name><name>rb</name>-&gt;<name>header</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bytes_used</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>svn_stringbuf_appendbytes</name><argument_list>(<argument><expr><name><name>rb</name>-&gt;<name>header</name></name></expr></argument>, <argument><expr>"\n"</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <expr_stmt><expr><call><name>svn_stringbuf_appendcstr</name><argument_list>(<argument><expr><name><name>rb</name>-&gt;<name>header</name></name></expr></argument>, <argument><expr><name>SVN_REPOS_DUMPFILE_CONTENT_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>bytes_used</name> = <call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>": %" <name>APR_SIZE_T_FMT</name></expr></argument>, <argument><expr><name><name>props</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_stringbuf_appendbytes</name><argument_list>(<argument><expr><name><name>rb</name>-&gt;<name>header</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bytes_used</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_stringbuf_appendbytes</name><argument_list>(<argument><expr><name><name>rb</name>-&gt;<name>header</name></name></expr></argument>, <argument><expr>"\n"</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* put an end to headers */</comment>
  <expr_stmt><expr><call><name>svn_stringbuf_appendbytes</name><argument_list>(<argument><expr><name><name>rb</name>-&gt;<name>header</name></name></expr></argument>, <argument><expr>"\n"</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* put an end to revision */</comment>
  <expr_stmt><expr><call><name>svn_stringbuf_appendbytes</name><argument_list>(<argument><expr><name>props</name></expr></argument>,  <argument><expr>"\n"</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* write out the revision */</comment>
  <comment type="block">/* Revision is written out in the following cases:
     1. No --drop-empty-revs has been supplied.
     2. --drop-empty-revs has been supplied,
     but revision has not all nodes dropped
     3. Revision had no nodes to begin with.
  */</comment>
  <if>if <condition>(<expr><name><name>rb</name>-&gt;<name>has_nodes</name></name>
      || (! <name><name>rb</name>-&gt;<name>pb</name>-&gt;<name>drop_empty_revs</name></name>)
      || (! <name><name>rb</name>-&gt;<name>had_dropped_nodes</name></name>)</expr>)</condition><then>
    <block>{
      <comment type="block">/* This revision is a keeper. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_write</name><argument_list>(<argument><expr><name><name>rb</name>-&gt;<name>pb</name>-&gt;<name>out_stream</name></name></expr></argument>,
                               <argument><expr><name><name>rb</name>-&gt;<name>header</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr>&amp;(<name><name>rb</name>-&gt;<name>header</name>-&gt;<name>len</name></name>)</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_write</name><argument_list>(<argument><expr><name><name>rb</name>-&gt;<name>pb</name>-&gt;<name>out_stream</name></name></expr></argument>,
                               <argument><expr><name><name>props</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr>&amp;(<name><name>props</name>-&gt;<name>len</name></name>)</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr><name><name>rb</name>-&gt;<name>pb</name>-&gt;<name>do_renumber_revs</name></name></expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><name>svn_revnum_t</name> *</type><name>rr_key</name></decl>;</decl_stmt>
          <decl_stmt><decl><type>struct <name>revmap_t</name> *</type><name>rr_val</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>rr_pool</name> <init>= <expr><call><name>apr_hash_pool_get</name><argument_list>(<argument><expr><name><name>rb</name>-&gt;<name>pb</name>-&gt;<name>renumber_history</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>rr_key</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>rr_pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>rr_key</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>rr_val</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>rr_pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>rr_val</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr>*<name>rr_key</name> = <name><name>rb</name>-&gt;<name>rev_orig</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>rr_val</name>-&gt;<name>rev</name></name> = <name><name>rb</name>-&gt;<name>rev_actual</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>rr_val</name>-&gt;<name>was_dropped</name></name> = <name>FALSE</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name><name>rb</name>-&gt;<name>pb</name>-&gt;<name>renumber_history</name></name></expr></argument>, <argument><expr><name>rr_key</name></expr></argument>,
                       <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>rr_key</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>rr_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>rb</name>-&gt;<name>pb</name>-&gt;<name>last_live_revision</name></name> = <name><name>rb</name>-&gt;<name>rev_actual</name></name></expr>;</expr_stmt>
        }</block></then></if>

      <if>if <condition>(<expr>! <name><name>rb</name>-&gt;<name>pb</name>-&gt;<name>quiet</name></name></expr>)</condition><then>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>,
                                    <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Revision %ld committed as %ld.\n"</expr></argument>)</argument_list></call></expr></argument>,
                                    <argument><expr><name><name>rb</name>-&gt;<name>rev_orig</name></name></expr></argument>, <argument><expr><name><name>rb</name>-&gt;<name>rev_actual</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then>
  <else>else
    <block>{
      <comment type="block">/* We're dropping this revision. */</comment>
      <expr_stmt><expr><name><name>rb</name>-&gt;<name>pb</name>-&gt;<name>rev_drop_count</name></name>++</expr>;</expr_stmt>
      <if>if <condition>(<expr><name><name>rb</name>-&gt;<name>pb</name>-&gt;<name>do_renumber_revs</name></name></expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><name>svn_revnum_t</name> *</type><name>rr_key</name></decl>;</decl_stmt>
          <decl_stmt><decl><type>struct <name>revmap_t</name> *</type><name>rr_val</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>rr_pool</name> <init>= <expr><call><name>apr_hash_pool_get</name><argument_list>(<argument><expr><name><name>rb</name>-&gt;<name>pb</name>-&gt;<name>renumber_history</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>rr_key</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>rr_pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>rr_key</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>rr_val</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>rr_pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>rr_val</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr>*<name>rr_key</name> = <name><name>rb</name>-&gt;<name>rev_orig</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>rr_val</name>-&gt;<name>rev</name></name> = <name><name>rb</name>-&gt;<name>pb</name>-&gt;<name>last_live_revision</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>rr_val</name>-&gt;<name>was_dropped</name></name> = <name>TRUE</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name><name>rb</name>-&gt;<name>pb</name>-&gt;<name>renumber_history</name></name></expr></argument>, <argument><expr><name>rr_key</name></expr></argument>,
                       <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>rr_key</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>rr_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

      <if>if <condition>(<expr>! <name><name>rb</name>-&gt;<name>pb</name>-&gt;<name>quiet</name></name></expr>)</condition><then>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>,
                                    <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Revision %ld skipped.\n"</expr></argument>)</argument_list></call></expr></argument>,
                                    <argument><expr><name><name>rb</name>-&gt;<name>rev_orig</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></else></if>
  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* UUID record here: dump it, as we do not filter them. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>uuid_record</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>uuid</name></decl></param>, <param><decl><type><name>void</name> *</type><name>parse_baton</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>parse_baton_t</name> *</type><name>pb</name> <init>= <expr><name>parse_baton</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_printf</name><argument_list>(<argument><expr><name><name>pb</name>-&gt;<name>out_stream</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>,
                            <argument><expr><name>SVN_REPOS_DUMPFILE_UUID</name> ": %s\n\n"</expr></argument>, <argument><expr><name>uuid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* New node here. Set up node_baton by copying headers. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>new_node_record</name><parameter_list>(<param><decl><type><name>void</name> **</type><name>node_baton</name></decl></param>,
                <param><decl><type><name>apr_hash_t</name> *</type><name>headers</name></decl></param>,
                <param><decl><type><name>void</name> *</type><name>rev_baton</name></decl></param>,
                <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>parse_baton_t</name> *</type><name>pb</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>node_baton_t</name> *</type><name>nb</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>node_path</name></decl>, *<decl><type ref="prev"/><name>copyfrom_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>tcl</name></decl>;</decl_stmt>

  <expr_stmt><expr>*<name>node_baton</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument>struct <expr><name>node_baton_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>nb</name>          = *<name>node_baton</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>nb</name>-&gt;<name>rb</name></name>      = <name>rev_baton</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>pb</name>          = <name><name>nb</name>-&gt;<name>rb</name>-&gt;<name>pb</name></name></expr>;</expr_stmt>

  <expr_stmt><expr><name>node_path</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>headers</name></expr></argument>, <argument><expr><name>SVN_REPOS_DUMPFILE_NODE_PATH</name></expr></argument>,
                           <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>copyfrom_path</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>headers</name></expr></argument>,
                               <argument><expr><name>SVN_REPOS_DUMPFILE_NODE_COPYFROM_PATH</name></expr></argument>,
                               <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Ensure that paths start with a leading '/'. */</comment>
  <expr_stmt><expr><name>node_path</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr>"/"</expr></argument>, <argument><expr><name>node_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>copyfrom_path</name></expr>)</condition><then>
    <expr_stmt><expr><name>copyfrom_path</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr>"/"</expr></argument>, <argument><expr><name>copyfrom_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <expr_stmt><expr><name><name>nb</name>-&gt;<name>do_skip</name></name> = <call><name>skip_path</name><argument_list>(<argument><expr><name>node_path</name></expr></argument>, <argument><expr><name><name>pb</name>-&gt;<name>prefixes</name></name></expr></argument>, <argument><expr><name><name>pb</name>-&gt;<name>do_exclude</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If we're skipping the node, take note of path, discarding the
     rest.  */</comment>
  <if>if <condition>(<expr><name><name>nb</name>-&gt;<name>do_skip</name></name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name><name>pb</name>-&gt;<name>dropped_nodes</name></name></expr></argument>,
                   <argument><expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><call><name>apr_hash_pool_get</name><argument_list>(<argument><expr><name><name>pb</name>-&gt;<name>dropped_nodes</name></name></expr></argument>)</argument_list></call></expr></argument>,
                               <argument><expr><name>node_path</name></expr></argument>)</argument_list></call></expr></argument>,
                   <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr>(<name>void</name> *)1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>nb</name>-&gt;<name>rb</name>-&gt;<name>had_dropped_nodes</name></name> = <name>TRUE</name></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <expr_stmt><expr><name>tcl</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>headers</name></expr></argument>, <argument><expr><name>SVN_REPOS_DUMPFILE_TEXT_CONTENT_LENGTH</name></expr></argument>,
                         <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Test if this node was copied from dropped source. */</comment>
      <if>if <condition>(<expr><name>copyfrom_path</name> &amp;&amp;
          <call><name>skip_path</name><argument_list>(<argument><expr><name>copyfrom_path</name></expr></argument>, <argument><expr><name><name>pb</name>-&gt;<name>prefixes</name></name></expr></argument>, <argument><expr><name><name>pb</name>-&gt;<name>do_exclude</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <comment type="block">/* This node was copied from a dropped source.
             We have a problem, since we did not want to drop this node too.

             However, there is one special case we'll handle.  If the node is
             a file, and this was a copy-and-modify operation, then the
             dumpfile should contain the new contents of the file.  In this
             scenario, we'll just do an add without history using the new
             contents.  */</comment>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>kind</name></decl>;</decl_stmt>
          <expr_stmt><expr><name>kind</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>headers</name></expr></argument>, <argument><expr><name>SVN_REPOS_DUMPFILE_NODE_KIND</name></expr></argument>,
                              <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* If there is a Text-content-length header, and the kind is
             "file", we just fallback to an add without history. */</comment>
          <if>if <condition>(<expr><name>tcl</name> &amp;&amp; (<call><name>strcmp</name><argument_list>(<argument><expr><name>kind</name></expr></argument>, <argument><expr>"file"</expr></argument>)</argument_list></call> == 0)</expr>)</condition><then>
            <block>{
              <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>headers</name></expr></argument>, <argument><expr><name>SVN_REPOS_DUMPFILE_NODE_COPYFROM_PATH</name></expr></argument>,
                           <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>headers</name></expr></argument>, <argument><expr><name>SVN_REPOS_DUMPFILE_NODE_COPYFROM_REV</name></expr></argument>,
                           <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>copyfrom_path</name> = <name>NULL</name></expr>;</expr_stmt>
            }</block></then>
          <comment type="block">/* Else, this is either a directory or a file whose contents we
             don't have readily available.  */</comment>
          <else>else
            <block>{
              <return>return <expr><call><name>svn_error_createf</name>
                <argument_list>(<argument><expr><name>SVN_ERR_INCOMPLETE_DATA</name></expr></argument>, <argument><expr>0</expr></argument>,
                 <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Invalid copy source path '%s'"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>copyfrom_path</name></expr></argument>)</argument_list></call></expr>;</return>
            }</block></else></if>
        }</block></then></if>

      <expr_stmt><expr><name><name>nb</name>-&gt;<name>has_props</name></name> = <name>FALSE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>nb</name>-&gt;<name>has_text</name></name> = <name>FALSE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>nb</name>-&gt;<name>writing_begun</name></name> = <name>FALSE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>nb</name>-&gt;<name>tcl</name></name> = <name>tcl</name> ? <call><name>svn__atoui64</name><argument_list>(<argument><expr><name>tcl</name></expr></argument>)</argument_list></call> : 0</expr>;</expr_stmt>
      <expr_stmt><expr><name><name>nb</name>-&gt;<name>header</name></name> = <call><name>svn_stringbuf_create</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>nb</name>-&gt;<name>props</name></name> = <call><name>svn_stringbuf_create</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Now we know for sure that we have a node that will not be
         skipped, flush the revision if it has not already been done. */</comment>
      <expr_stmt><expr><name><name>nb</name>-&gt;<name>rb</name>-&gt;<name>has_nodes</name></name> = <name>TRUE</name></expr>;</expr_stmt>
      <if>if <condition>(<expr>! <name><name>nb</name>-&gt;<name>rb</name>-&gt;<name>writing_begun</name></name></expr>)</condition><then>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>output_revision</name><argument_list>(<argument><expr><name><name>nb</name>-&gt;<name>rb</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

      <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>headers</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>hi</name></expr>;</condition> <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
        <block>{
          <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>(const <name>void</name> **) &amp;<name>key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr>(!<call><name>strcmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>SVN_REPOS_DUMPFILE_CONTENT_LENGTH</name></expr></argument>)</argument_list></call>)
              || (!<call><name>strcmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>SVN_REPOS_DUMPFILE_PROP_CONTENT_LENGTH</name></expr></argument>)</argument_list></call>)
              || (!<call><name>strcmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>SVN_REPOS_DUMPFILE_TEXT_CONTENT_LENGTH</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
            <continue>continue;</continue></then></if>

          <comment type="block">/* Rewrite Node-Copyfrom-Rev if we are renumbering revisions.
             The number points to some revision in the past. We keep track
             of revision renumbering in an apr_hash, which maps original
             revisions to new ones. Dropped revision are mapped to -1.
             This should never happen here.
          */</comment>
          <if>if <condition>(<expr><name><name>pb</name>-&gt;<name>do_renumber_revs</name></name>
              &amp;&amp; (!<call><name>strcmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>SVN_REPOS_DUMPFILE_NODE_COPYFROM_REV</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
            <block>{
              <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>cf_orig_rev</name></decl>;</decl_stmt>
              <decl_stmt><decl><type>struct <name>revmap_t</name> *</type><name>cf_renum_val</name></decl>;</decl_stmt>

              <expr_stmt><expr><name>cf_orig_rev</name> = <call><name>SVN_STR_TO_REV</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>cf_renum_val</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name><name>pb</name>-&gt;<name>renumber_history</name></name></expr></argument>,
                                          <argument><expr>&amp;<name>cf_orig_rev</name></expr></argument>,
                                          <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>svn_revnum_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <if>if <condition>(<expr>! (<name>cf_renum_val</name> &amp;&amp; <call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name><name>cf_renum_val</name>-&gt;<name>rev</name></name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
                <return>return <expr><call><name>svn_error_createf</name>
                  <argument_list>(<argument><expr><name>SVN_ERR_NODE_UNEXPECTED_KIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                   <argument><expr><call><name>_</name><argument_list>(<argument><expr>"No valid copyfrom revision in filtered stream"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_printf</name>
                      <argument_list>(<argument><expr><name><name>nb</name>-&gt;<name>rb</name>-&gt;<name>pb</name>-&gt;<name>out_stream</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>,
                       <argument><expr><name>SVN_REPOS_DUMPFILE_NODE_COPYFROM_REV</name> ": %ld\n"</expr></argument>,
                       <argument><expr><name><name>cf_renum_val</name>-&gt;<name>rev</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <continue>continue;</continue>
            }</block></then></if>

          <comment type="block">/* passthru: put header straight to output */</comment>

          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_printf</name><argument_list>(<argument><expr><name><name>nb</name>-&gt;<name>rb</name>-&gt;<name>pb</name>-&gt;<name>out_stream</name></name></expr></argument>,
                                    <argument><expr><name>pool</name></expr></argument>, <argument><expr>"%s: %s\n"</expr></argument>,
                                    <argument><expr>(const <name>char</name> *)<name>key</name></expr></argument>,
                                    <argument><expr>(const <name>char</name> *)<name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
    }</block></else></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Output node header and props to dumpstream
   This will be called by set_fulltext() after setting nb-&gt;has_text to TRUE,
   if the node has any text, or by close_node() otherwise. This must only
   be called if nb-&gt;writing_begun is FALSE. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>output_node</name><parameter_list>(<param><decl><type>struct <name>node_baton_t</name> *</type><name>nb</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>bytes_used</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>SVN_KEYLINE_MAXLEN</name></expr>]</index></name></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>nb</name>-&gt;<name>writing_begun</name></name> = <name>TRUE</name></expr>;</expr_stmt>

  <comment type="block">/* when there are no props nb-&gt;props-&gt;len would be zero and won't mess up
     Content-Length. */</comment>
  <if>if <condition>(<expr><name><name>nb</name>-&gt;<name>has_props</name></name></expr>)</condition><then>
    <expr_stmt><expr><call><name>svn_stringbuf_appendcstr</name><argument_list>(<argument><expr><name><name>nb</name>-&gt;<name>props</name></name></expr></argument>, <argument><expr>"PROPS-END\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* 1. recalculate &amp; check text-md5 if present. Passed through right now. */</comment>

  <comment type="block">/* 2. recalculate and add content-lengths */</comment>

  <if>if <condition>(<expr><name><name>nb</name>-&gt;<name>has_props</name></name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>svn_stringbuf_appendcstr</name><argument_list>(<argument><expr><name><name>nb</name>-&gt;<name>header</name></name></expr></argument>,
                               <argument><expr><name>SVN_REPOS_DUMPFILE_PROP_CONTENT_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>bytes_used</name> = <call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>": %" <name>APR_SIZE_T_FMT</name></expr></argument>, <argument><expr><name><name>nb</name>-&gt;<name>props</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>svn_stringbuf_appendbytes</name><argument_list>(<argument><expr><name><name>nb</name>-&gt;<name>header</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bytes_used</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>svn_stringbuf_appendbytes</name><argument_list>(<argument><expr><name><name>nb</name>-&gt;<name>header</name></name></expr></argument>, <argument><expr>"\n"</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  <if>if <condition>(<expr><name><name>nb</name>-&gt;<name>has_text</name></name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>svn_stringbuf_appendcstr</name><argument_list>(<argument><expr><name><name>nb</name>-&gt;<name>header</name></name></expr></argument>,
                               <argument><expr><name>SVN_REPOS_DUMPFILE_TEXT_CONTENT_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>bytes_used</name> = <call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>": %" <name>SVN_FILESIZE_T_FMT</name></expr></argument>, <argument><expr><name><name>nb</name>-&gt;<name>tcl</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>svn_stringbuf_appendbytes</name><argument_list>(<argument><expr><name><name>nb</name>-&gt;<name>header</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bytes_used</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>svn_stringbuf_appendbytes</name><argument_list>(<argument><expr><name><name>nb</name>-&gt;<name>header</name></name></expr></argument>, <argument><expr>"\n"</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  <expr_stmt><expr><call><name>svn_stringbuf_appendcstr</name><argument_list>(<argument><expr><name><name>nb</name>-&gt;<name>header</name></name></expr></argument>, <argument><expr><name>SVN_REPOS_DUMPFILE_CONTENT_LENGTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>bytes_used</name> = <call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>": %" <name>SVN_FILESIZE_T_FMT</name></expr></argument>,
                       <argument><expr><call>(<name>svn_filesize_t</name>) <argument_list>(<argument><expr><name><name>nb</name>-&gt;<name>props</name>-&gt;<name>len</name></name> + <name><name>nb</name>-&gt;<name>tcl</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_stringbuf_appendbytes</name><argument_list>(<argument><expr><name><name>nb</name>-&gt;<name>header</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>bytes_used</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_stringbuf_appendbytes</name><argument_list>(<argument><expr><name><name>nb</name>-&gt;<name>header</name></name></expr></argument>, <argument><expr>"\n"</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* put an end to headers */</comment>
  <expr_stmt><expr><call><name>svn_stringbuf_appendbytes</name><argument_list>(<argument><expr><name><name>nb</name>-&gt;<name>header</name></name></expr></argument>, <argument><expr>"\n"</expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* 3. output all the stuff */</comment>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_write</name><argument_list>(<argument><expr><name><name>nb</name>-&gt;<name>rb</name>-&gt;<name>pb</name>-&gt;<name>out_stream</name></name></expr></argument>,
                           <argument><expr><name><name>nb</name>-&gt;<name>header</name>-&gt;<name>data</name></name></expr></argument> , <argument><expr>&amp;(<name><name>nb</name>-&gt;<name>header</name>-&gt;<name>len</name></name>)</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_write</name><argument_list>(<argument><expr><name><name>nb</name>-&gt;<name>rb</name>-&gt;<name>pb</name>-&gt;<name>out_stream</name></name></expr></argument>,
                           <argument><expr><name><name>nb</name>-&gt;<name>props</name>-&gt;<name>data</name></name></expr></argument> , <argument><expr>&amp;(<name><name>nb</name>-&gt;<name>props</name>-&gt;<name>len</name></name>)</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Examine the mergeinfo in INITIAL_VAL, omitting missing merge
   sources or renumbering revisions in rangelists as appropriate, and
   return the (possibly new) mergeinfo in *FINAL_VAL (allocated from
   POOL). */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>adjust_mergeinfo</name><parameter_list>(<param><decl><type><name>svn_string_t</name> **</type><name>final_val</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>initial_val</name></decl></param>,
                 <param><decl><type>struct <name>revision_baton_t</name> *</type><name>rb</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>mergeinfo</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>final_mergeinfo</name> <init>= <expr><call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo_parse</name><argument_list>(<argument><expr>&amp;<name>mergeinfo</name></expr></argument>, <argument><expr><name><name>initial_val</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>mergeinfo</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>hi</name></expr>;</condition> <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>merge_source</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>rangelist</name></decl>;</decl_stmt>
      <decl_stmt><decl><type>struct <name>parse_baton_t</name> *</type><name>pb</name> <init>= <expr><name><name>rb</name>-&gt;<name>pb</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>merge_source</name> = (const <name>char</name> *) <name>key</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>rangelist</name> = (<name>apr_array_header_t</name> *) <name>val</name></expr>;</expr_stmt>

      <comment type="block">/* Determine whether the merge_source is a part of the prefix. */</comment>
      <if>if <condition>(<expr><call><name>skip_path</name><argument_list>(<argument><expr><name>merge_source</name></expr></argument>, <argument><expr><name><name>pb</name>-&gt;<name>prefixes</name></name></expr></argument>, <argument><expr><name><name>pb</name>-&gt;<name>do_exclude</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <if>if <condition>(<expr><name><name>pb</name>-&gt;<name>skip_missing_merge_sources</name></name></expr>)</condition><then>
            <continue>continue;</continue></then>
          <else>else
            <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_INCOMPLETE_DATA</name></expr></argument>, <argument><expr>0</expr></argument>,
                                     <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Missing merge source path '%s'; try "
                                       "with --skip-missing-merge-sources"</expr></argument>)</argument_list></call></expr></argument>,
                                     <argument><expr><name>merge_source</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
        }</block></then></if>

      <comment type="block">/* Possibly renumber revisions in merge source's rangelist. */</comment>
      <if>if <condition>(<expr><name><name>pb</name>-&gt;<name>do_renumber_revs</name></name></expr>)</condition><then>
        <block>{
          <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>rangelist</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
            <block>{
              <decl_stmt><decl><type>struct <name>revmap_t</name> *</type><name>revmap_start</name></decl>;</decl_stmt>
              <decl_stmt><decl><type>struct <name>revmap_t</name> *</type><name>revmap_end</name></decl>;</decl_stmt>
              <decl_stmt><decl><type><name>svn_merge_range_t</name> *</type><name>range</name> <init>= <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>rangelist</name></expr></argument>, <argument><expr><name>i</name></expr></argument>,
                                                       <argument><expr><name>svn_merge_range_t</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

              <expr_stmt><expr><name>revmap_start</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name><name>pb</name>-&gt;<name>renumber_history</name></name></expr></argument>,
                                          <argument><expr>&amp;<name><name>range</name>-&gt;<name>start</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>svn_revnum_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <if>if <condition>(<expr>! (<name>revmap_start</name> &amp;&amp; <call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name><name>revmap_start</name>-&gt;<name>rev</name></name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
                <return>return <expr><call><name>svn_error_createf</name>
                  <argument_list>(<argument><expr><name>SVN_ERR_NODE_UNEXPECTED_KIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                   <argument><expr><call><name>_</name><argument_list>(<argument><expr>"No valid revision range 'start' in filtered stream"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

              <expr_stmt><expr><name>revmap_end</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name><name>pb</name>-&gt;<name>renumber_history</name></name></expr></argument>,
                                        <argument><expr>&amp;<name><name>range</name>-&gt;<name>end</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>svn_revnum_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <if>if <condition>(<expr>! (<name>revmap_end</name> &amp;&amp; <call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name><name>revmap_end</name>-&gt;<name>rev</name></name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
                <return>return <expr><call><name>svn_error_createf</name>
                  <argument_list>(<argument><expr><name>SVN_ERR_NODE_UNEXPECTED_KIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                   <argument><expr><call><name>_</name><argument_list>(<argument><expr>"No valid revision range 'end' in filtered stream"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

              <expr_stmt><expr><name><name>range</name>-&gt;<name>start</name></name> = <name><name>revmap_start</name>-&gt;<name>rev</name></name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>range</name>-&gt;<name>end</name></name> = <name><name>revmap_end</name>-&gt;<name>rev</name></name></expr>;</expr_stmt>
            }</block></for>
        }</block></then></if>
      <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>final_mergeinfo</name></expr></argument>, <argument><expr><name>merge_source</name></expr></argument>,
                   <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>rangelist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo_sort</name><argument_list>(<argument><expr><name>final_mergeinfo</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo_to_string</name><argument_list>(<argument><expr><name>final_val</name></expr></argument>, <argument><expr><name>final_mergeinfo</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>set_revision_property</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>revision_baton</name></decl></param>,
                      <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>,
                      <param><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>value</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>revision_baton_t</name> *</type><name>rb</name> <init>= <expr><name>revision_baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>hash_pool</name> <init>= <expr><call><name>apr_hash_pool_get</name><argument_list>(<argument><expr><name><name>rb</name>-&gt;<name>props</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>rb</name>-&gt;<name>has_props</name></name> = <name>TRUE</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name><name>rb</name>-&gt;<name>props</name></name></expr></argument>, <argument><expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>hash_pool</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>,
               <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><call><name>svn_string_dup</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>hash_pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>set_node_property</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>node_baton</name></decl></param>,
                  <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>,
                  <param><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>value</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>node_baton_t</name> *</type><name>nb</name> <init>= <expr><name>node_baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>revision_baton_t</name> *</type><name>rb</name> <init>= <expr><name><name>nb</name>-&gt;<name>rb</name></name></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name><name>nb</name>-&gt;<name>do_skip</name></name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <if>if <condition>(<expr>!<name><name>nb</name>-&gt;<name>has_props</name></name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_UNSUPPORTED_FEATURE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                            <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Delta property block detected - "
                              "not supported by svndumpfilter"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>SVN_PROP_MERGEINFO</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>filtered_mergeinfo</name></decl>;</decl_stmt>  <comment type="block">/* Avoid compiler warning. */</comment> 
      <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name> <init>= <expr><call><name>apr_hash_pool_get</name><argument_list>(<argument><expr><name><name>rb</name>-&gt;<name>props</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>adjust_mergeinfo</name><argument_list>(<argument><expr>&amp;<name>filtered_mergeinfo</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>rb</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>value</name> = <name>filtered_mergeinfo</name></expr>;</expr_stmt>
    }</block></then></if>

  <expr_stmt><expr><call><name>write_prop_to_stringbuf</name><argument_list>(<argument><expr>&amp;(<name><name>nb</name>-&gt;<name>props</name></name>)</expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>remove_node_props</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>node_baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>node_baton_t</name> *</type><name>nb</name> <init>= <expr><name>node_baton</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* In this case, not actually indicating that the node *has* props,
     rather that we know about all the props that it has, since it now
     has none. */</comment>
  <expr_stmt><expr><name><name>nb</name>-&gt;<name>has_props</name></name> = <name>TRUE</name></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>set_fulltext</name><parameter_list>(<param><decl><type><name>svn_stream_t</name> **</type><name>stream</name></decl></param>, <param><decl><type><name>void</name> *</type><name>node_baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>node_baton_t</name> *</type><name>nb</name> <init>= <expr><name>node_baton</name></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr>!<name><name>nb</name>-&gt;<name>do_skip</name></name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name><name>nb</name>-&gt;<name>has_text</name></name> = <name>TRUE</name></expr>;</expr_stmt>
      <if>if <condition>(<expr>! <name><name>nb</name>-&gt;<name>writing_begun</name></name></expr>)</condition><then>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>output_node</name><argument_list>(<argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
      <expr_stmt><expr>*<name>stream</name> = <name><name>nb</name>-&gt;<name>rb</name>-&gt;<name>pb</name>-&gt;<name>out_stream</name></name></expr>;</expr_stmt>
    }</block></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Finalize node */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>close_node</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>node_baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>node_baton_t</name> *</type><name>nb</name> <init>= <expr><name>node_baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name> <init>= <expr>2</expr></init></decl>;</decl_stmt>

  <comment type="block">/* Get out of here if we can. */</comment>
  <if>if <condition>(<expr><name><name>nb</name>-&gt;<name>do_skip</name></name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <comment type="block">/* If the node was not flushed already to output its text, do it now. */</comment>
  <if>if <condition>(<expr>! <name><name>nb</name>-&gt;<name>writing_begun</name></name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>output_node</name><argument_list>(<argument><expr><name>nb</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* put an end to node. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_write</name><argument_list>(<argument><expr><name><name>nb</name>-&gt;<name>rb</name>-&gt;<name>pb</name>-&gt;<name>out_stream</name></name></expr></argument>, <argument><expr>"\n\n"</expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Finalize revision */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>close_revision</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>revision_baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>revision_baton_t</name> *</type><name>rb</name> <init>= <expr><name>revision_baton</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* If no node has yet flushed the revision, do it now. */</comment>
  <if>if <condition>(<expr>! <name><name>rb</name>-&gt;<name>writing_begun</name></name></expr>)</condition><then>
    <return>return <expr><call><name>output_revision</name><argument_list>(<argument><expr><name>rb</name></expr></argument>)</argument_list></call></expr>;</return></then>
  <else>else
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></else></if>
}</block></function>


<comment type="block">/* Filtering vtable */</comment>
<decl_stmt><decl><type><name>svn_repos_parser_fns2_t</name></type> <name>filtering_vtable</name> <init>=
  <expr><block>{
    <expr><name>new_revision_record</name></expr>,
    <expr><name>uuid_record</name></expr>,
    <expr><name>new_node_record</name></expr>,
    <expr><name>set_revision_property</name></expr>,
    <expr><name>set_node_property</name></expr>,
    <expr><name>NULL</name></expr>,
    <expr><name>remove_node_props</name></expr>,
    <expr><name>set_fulltext</name></expr>,
    <expr><name>NULL</name></expr>,
    <expr><name>close_node</name></expr>,
    <expr><name>close_revision</name></expr>
  }</block></expr></init></decl>;</decl_stmt>


<escape char="0xc"/>
<comment type="block">/** Subcommands. **/</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>svn_opt_subcommand_t</name></type>
  <name>subcommand_help</name></decl>,
  <decl><type ref="prev"/><name>subcommand_exclude</name></decl>,
  <decl><type ref="prev"/><name>subcommand_include</name></decl>;</decl_stmt>

<enum>enum
  <block>{
    <decl><name>svndumpfilter__drop_empty_revs</name> <init>= <expr><name>SVN_OPT_FIRST_LONGOPT_ID</name></expr></init></decl>,
    <decl><name>svndumpfilter__renumber_revs</name></decl>,
    <decl><name>svndumpfilter__preserve_revprops</name></decl>,
    <decl><name>svndumpfilter__skip_missing_merge_sources</name></decl>,
    <decl><name>svndumpfilter__quiet</name></decl>,
    <decl><name>svndumpfilter__version</name></decl>
  }</block>;</enum>

<comment type="block">/* Option codes and descriptions.
 *
 * The entire list must be terminated with an entry of nulls.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>apr_getopt_option_t</name></type> <name><name>options_table</name><index>[]</index></name> <init>=
  <expr><block>{
    <expr><block>{<expr>"help"</expr>,          <expr>'h'</expr>, <expr>0</expr>,
     <macro><name>N_</name><argument_list>(<argument>"show help on a subcommand"</argument>)</argument_list></macro>}</block></expr>,

    <expr><block>{<expr><name>NULL</name></expr>,            <expr>'?'</expr>, <expr>0</expr>,
     <macro><name>N_</name><argument_list>(<argument>"show help on a subcommand"</argument>)</argument_list></macro>}</block></expr>,

    <expr><block>{<expr>"version"</expr>,            <expr><name>svndumpfilter__version</name></expr>, <expr>0</expr>,
     <macro><name>N_</name><argument_list>(<argument>"show program version information"</argument>)</argument_list></macro> }</block></expr>,
    <expr><block>{<expr>"quiet"</expr>,              <expr><name>svndumpfilter__quiet</name></expr>, <expr>0</expr>,
     <macro><name>N_</name><argument_list>(<argument>"Do not display filtering statistics."</argument>)</argument_list></macro> }</block></expr>,
    <expr><block>{<expr>"drop-empty-revs"</expr>,    <expr><name>svndumpfilter__drop_empty_revs</name></expr>, <expr>0</expr>,
     <macro><name>N_</name><argument_list>(<argument>"Remove revisions emptied by filtering."</argument>)</argument_list></macro>}</block></expr>,
    <expr><block>{<expr>"renumber-revs"</expr>,      <expr><name>svndumpfilter__renumber_revs</name></expr>, <expr>0</expr>,
     <macro><name>N_</name><argument_list>(<argument>"Renumber revisions left after filtering."</argument>)</argument_list></macro> }</block></expr>,
    <expr><block>{<expr>"skip-missing-merge-sources"</expr>,
     <expr><name>svndumpfilter__skip_missing_merge_sources</name></expr>, <expr>0</expr>,
     <macro><name>N_</name><argument_list>(<argument>"Skip missing merge sources."</argument>)</argument_list></macro> }</block></expr>,
    <expr><block>{<expr>"preserve-revprops"</expr>,  <expr><name>svndumpfilter__preserve_revprops</name></expr>, <expr>0</expr>,
     <macro><name>N_</name><argument_list>(<argument>"Don't filter revision properties."</argument>)</argument_list></macro> }</block></expr>,
    <expr><block>{<expr><name>NULL</name></expr>}</block></expr>
  }</block></expr></init></decl>;</decl_stmt>


<comment type="block">/* Array of available subcommands.
 * The entire list must be terminated with an entry of nulls.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>svn_opt_subcommand_desc_t</name></type> <name><name>cmd_table</name><index>[]</index></name> <init>=
  <expr><block>{
    <expr><block>{<expr>"exclude"</expr>, <expr><name>subcommand_exclude</name></expr>, <expr><block>{<expr>0</expr>}</block></expr>,
     <expr><call><name>N_</name><argument_list>(<argument><expr>"Filter out nodes with given prefixes from dumpstream.\n"
        "usage: svndumpfilter exclude PATH_PREFIX...\n"</expr></argument>)</argument_list></call></expr>,
     <expr><block>{<expr><name>svndumpfilter__drop_empty_revs</name></expr>, <expr><name>svndumpfilter__renumber_revs</name></expr>,
      <expr><name>svndumpfilter__skip_missing_merge_sources</name></expr>,
      <expr><name>svndumpfilter__preserve_revprops</name></expr>, <expr><name>svndumpfilter__quiet</name></expr>}</block></expr> }</block></expr>,

    <expr><block>{<expr>"include"</expr>, <expr><name>subcommand_include</name></expr>, <expr><block>{<expr>0</expr>}</block></expr>,
     <expr><call><name>N_</name><argument_list>(<argument><expr>"Filter out nodes without given prefixes from dumpstream.\n"
        "usage: svndumpfilter include PATH_PREFIX...\n"</expr></argument>)</argument_list></call></expr>,
     <expr><block>{<expr><name>svndumpfilter__drop_empty_revs</name></expr>, <expr><name>svndumpfilter__renumber_revs</name></expr>,
      <expr><name>svndumpfilter__skip_missing_merge_sources</name></expr>,
      <expr><name>svndumpfilter__preserve_revprops</name></expr>, <expr><name>svndumpfilter__quiet</name></expr>}</block></expr> }</block></expr>,

    <expr><block>{<expr>"help"</expr>, <expr><name>subcommand_help</name></expr>, <expr><block>{<expr>"?"</expr>, <expr>"h"</expr>}</block></expr>,
     <expr><call><name>N_</name><argument_list>(<argument><expr>"Describe the usage of this program or its subcommands.\n"
        "usage: svndumpfilter help [SUBCOMMAND...]\n"</expr></argument>)</argument_list></call></expr>,
     <expr><block>{<expr>0</expr>}</block></expr> }</block></expr>,

    <expr><block>{ <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><block>{<expr>0</expr>}</block></expr>, <expr><name>NULL</name></expr>, <expr><block>{<expr>0</expr>}</block></expr> }</block></expr>
  }</block></expr></init></decl>;</decl_stmt>


<comment type="block">/* Baton for passing option/argument state to a subcommand function. */</comment>
<struct>struct <name>svndumpfilter_opt_state</name>
<block>{
  <decl_stmt><decl><type><name>svn_opt_revision_t</name></type> <name>start_revision</name></decl>;</decl_stmt>     <comment type="block">/* -r X[:Y] is         */</comment>
  <decl_stmt><decl><type><name>svn_opt_revision_t</name></type> <name>end_revision</name></decl>;</decl_stmt>       <comment type="block">/* not implemented.    */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>quiet</name></decl>;</decl_stmt>                   <comment type="block">/* --quiet             */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>version</name></decl>;</decl_stmt>                 <comment type="block">/* --version           */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>drop_empty_revs</name></decl>;</decl_stmt>         <comment type="block">/* --drop-empty-revs   */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>help</name></decl>;</decl_stmt>                    <comment type="block">/* --help or -?        */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>renumber_revs</name></decl>;</decl_stmt>           <comment type="block">/* --renumber-revs     */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>preserve_revprops</name></decl>;</decl_stmt>       <comment type="block">/* --preserve-revprops */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>skip_missing_merge_sources</name></decl>;</decl_stmt>
                                         <comment type="block">/* --skip-missing-merge-sources */</comment>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>prefixes</name></decl>;</decl_stmt>          <comment type="block">/* mainargs.           */</comment>
}</block>;</struct>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>parse_baton_initialize</name><parameter_list>(<param><decl><type>struct <name>parse_baton_t</name> **</type><name>pb</name></decl></param>,
                       <param><decl><type>struct <name>svndumpfilter_opt_state</name> *</type><name>opt_state</name></decl></param>,
                       <param><decl><type><name>svn_boolean_t</name></type> <name>do_exclude</name></decl></param>,
                       <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>parse_baton_t</name> *</type><name>baton</name> <init>= <expr><call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>baton</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Read the stream from STDIN.  Users can redirect a file. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>create_stdio_stream</name><argument_list>(<argument><expr>&amp;(<name><name>baton</name>-&gt;<name>in_stream</name></name>)</expr></argument>,
                              <argument><expr><name>apr_file_open_stdin</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Have the parser dump results to STDOUT. Users can redirect a file. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>create_stdio_stream</name><argument_list>(<argument><expr>&amp;(<name><name>baton</name>-&gt;<name>out_stream</name></name>)</expr></argument>,
                              <argument><expr><name>apr_file_open_stdout</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>baton</name>-&gt;<name>do_exclude</name></name> = <name>do_exclude</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>baton</name>-&gt;<name>do_renumber_revs</name></name> = <name><name>opt_state</name>-&gt;<name>renumber_revs</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>baton</name>-&gt;<name>drop_empty_revs</name></name> = <name><name>opt_state</name>-&gt;<name>drop_empty_revs</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>baton</name>-&gt;<name>preserve_revprops</name></name> = <name><name>opt_state</name>-&gt;<name>preserve_revprops</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>baton</name>-&gt;<name>quiet</name></name> = <name><name>opt_state</name>-&gt;<name>quiet</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>baton</name>-&gt;<name>prefixes</name></name> = <name><name>opt_state</name>-&gt;<name>prefixes</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>baton</name>-&gt;<name>skip_missing_merge_sources</name></name> = <name><name>opt_state</name>-&gt;<name>skip_missing_merge_sources</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>baton</name>-&gt;<name>rev_drop_count</name></name> = 0</expr>;</expr_stmt> <comment type="block">/* used to shift revnums while filtering */</comment>
  <expr_stmt><expr><name><name>baton</name>-&gt;<name>dropped_nodes</name></name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>baton</name>-&gt;<name>renumber_history</name></name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>baton</name>-&gt;<name>last_live_revision</name></name> = <name>SVN_INVALID_REVNUM</name></expr>;</expr_stmt>

  <comment type="block">/* This is non-ideal: We should pass through the version of the
   * input dumpstream.  However, our API currently doesn't allow that.
   * Hardcoding version 2 is acceptable because:
   *   - We currently do not accept version 3 or greater.
   *   - Dumpstream version 1 is so ancient as to be ignorable
   *     (0.17.x and earlier)
   */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_printf</name><argument_list>(<argument><expr><name><name>baton</name>-&gt;<name>out_stream</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>,
                            <argument><expr><name>SVN_REPOS_DUMPFILE_MAGIC_HEADER</name> ": %d\n\n"</expr></argument>,
                            <argument><expr>2</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>pb</name> = <name>baton</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* This implements `help` subcommand. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>subcommand_help</name><parameter_list>(<param><decl><type><name>apr_getopt_t</name> *</type><name>os</name></decl></param>, <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>svndumpfilter_opt_state</name> *</type><name>opt_state</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>header</name> <init>=
    <expr><call><name>_</name><argument_list>(<argument><expr>"general usage: svndumpfilter SUBCOMMAND [ARGS &amp; OPTIONS ...]\n"
      "Type 'svndumpfilter help &lt;subcommand&gt;' for help on a "
      "specific subcommand.\n"
      "Type 'svndumpfilter --version' to see the program version.\n"
      "\n"
      "Available subcommands:\n"</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_opt_print_help</name><argument_list>(<argument><expr><name>os</name></expr></argument>, <argument><expr>"svndumpfilter"</expr></argument>,
                             <argument><expr><name>opt_state</name> ? <name><name>opt_state</name>-&gt;<name>version</name></name> : <name>FALSE</name></expr></argument>,
                             <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><name>header</name></expr></argument>, <argument><expr><name>cmd_table</name></expr></argument>, <argument><expr><name>options_table</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Version compatibility check */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>check_lib_versions</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>svn_version_checklist_t</name></type> <name><name>checklist</name><index>[]</index></name> <init>=
    <expr><block>{
      <expr><block>{ <expr>"svn_subr"</expr>,  <expr><name>svn_subr_version</name></expr> }</block></expr>,
      <expr><block>{ <expr>"svn_repos"</expr>, <expr><name>svn_repos_version</name></expr> }</block></expr>,
      <expr><block>{ <expr>"svn_delta"</expr>, <expr><name>svn_delta_version</name></expr> }</block></expr>,
      <expr><block>{ <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr> }</block></expr>
    }</block></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_VERSION_DEFINE</name><argument_list>(<argument><expr><name>my_version</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>svn_ver_check_list</name><argument_list>(<argument><expr>&amp;<name>my_version</name></expr></argument>, <argument><expr><name>checklist</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<comment type="block">/* Do the real work of filtering. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>do_filter</name><parameter_list>(<param><decl><type><name>apr_getopt_t</name> *</type><name>os</name></decl></param>,
          <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>,
          <param><decl><type><name>svn_boolean_t</name></type> <name>do_exclude</name></decl></param>,
          <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>svndumpfilter_opt_state</name> *</type><name>opt_state</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>parse_baton_t</name> *</type><name>pb</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>keys</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>num_keys</name></decl>;</decl_stmt>

  <if>if <condition>(<expr>! <name><name>opt_state</name>-&gt;<name>quiet</name></name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>,
                                  <argument><expr><name>do_exclude</name>
                                  ? <name><name>opt_state</name>-&gt;<name>drop_empty_revs</name></name>
                                  ? <call><name>_</name><argument_list>(<argument><expr>"Excluding (and dropping empty "
                                      "revisions for) prefixes:\n"</expr></argument>)</argument_list></call>
                                  : <call><name>_</name><argument_list>(<argument><expr>"Excluding prefixes:\n"</expr></argument>)</argument_list></call>
                                  : <name><name>opt_state</name>-&gt;<name>drop_empty_revs</name></name>
                                  ? <call><name>_</name><argument_list>(<argument><expr>"Including (and dropping empty "
                                      "revisions for) prefixes:\n"</expr></argument>)</argument_list></call>
                                  : <call><name>_</name><argument_list>(<argument><expr>"Including prefixes:\n"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>opt_state</name>-&gt;<name>prefixes</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
        <block>{
          <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_fprintf</name>
                  <argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>, <argument><expr>"   '%s'\n"</expr></argument>,
                   <argument><expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name><name>opt_state</name>-&gt;<name>prefixes</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_fputs</name><argument_list>(<argument><expr>"\n"</expr></argument>, <argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>parse_baton_initialize</name><argument_list>(<argument><expr>&amp;<name>pb</name></expr></argument>, <argument><expr><name>opt_state</name></expr></argument>, <argument><expr><name>do_exclude</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_repos_parse_dumpstream2</name><argument_list>(<argument><expr><name><name>pb</name>-&gt;<name>in_stream</name></name></expr></argument>, <argument><expr>&amp;<name>filtering_vtable</name></expr></argument>, <argument><expr><name>pb</name></expr></argument>,
                                      <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* The rest of this is just reporting.  If we aren't reporting, get
     outta here. */</comment>
  <if>if <condition>(<expr><name><name>opt_state</name>-&gt;<name>quiet</name></name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_fputs</name><argument_list>(<argument><expr>"\n"</expr></argument>, <argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name><name>pb</name>-&gt;<name>rev_drop_count</name></name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>,
                                <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Dropped %d revision(s).\n\n"</expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><name><name>pb</name>-&gt;<name>rev_drop_count</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <if>if <condition>(<expr><name><name>pb</name>-&gt;<name>do_renumber_revs</name></name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_fputs</name><argument_list>(<argument><expr><call><name>_</name><argument_list>(<argument><expr>"Revisions renumbered as follows:\n"</expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Get the keys of the hash, sort them, then print the hash keys
         and values, sorted by keys. */</comment>
      <expr_stmt><expr><name>num_keys</name> = <call><name>apr_hash_count</name><argument_list>(<argument><expr><name><name>pb</name>-&gt;<name>renumber_history</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>keys</name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>num_keys</name> + 1</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>svn_revnum_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>pb</name>-&gt;<name>renumber_history</name></name></expr></argument>)</argument_list></call></expr>;</init>
           <condition><expr><name>hi</name></expr>;</condition>
           <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
        <block>{
          <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>keys</name></expr></argument>, <argument><expr><name>svn_revnum_t</name></expr></argument>)</argument_list></call> = *((const <name>svn_revnum_t</name> *) <name>key</name>)</expr>;</expr_stmt>
        }</block></for>
      <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name><name>keys</name>-&gt;<name>elts</name></name></expr></argument>, <argument><expr><name><name>keys</name>-&gt;<name>nelts</name></name></expr></argument>,
            <argument><expr><name><name>keys</name>-&gt;<name>elt_size</name></name></expr></argument>, <argument><expr><name>svn_sort_compare_revisions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>keys</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
        <block>{
          <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>this_key</name></decl>;</decl_stmt>
          <decl_stmt><decl><type>struct <name>revmap_t</name> *</type><name>this_val</name></decl>;</decl_stmt>

          <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>this_key</name> = <call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>keys</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>svn_revnum_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>this_val</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name><name>pb</name>-&gt;<name>renumber_history</name></name></expr></argument>, <argument><expr>&amp;<name>this_key</name></expr></argument>,
                                  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>this_key</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name><name>this_val</name>-&gt;<name>was_dropped</name></name></expr>)</condition><then>
            <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>,
                                        <argument><expr><call><name>_</name><argument_list>(<argument><expr>"   %ld =&gt; (dropped)\n"</expr></argument>)</argument_list></call></expr></argument>,
                                        <argument><expr><name>this_key</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
          <else>else
            <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>,
                                        <argument><expr>"   %ld =&gt; %ld\n"</expr></argument>,
                                        <argument><expr><name>this_key</name></expr></argument>, <argument><expr><name><name>this_val</name>-&gt;<name>rev</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
        }</block></for>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_fputs</name><argument_list>(<argument><expr>"\n"</expr></argument>, <argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <if>if <condition>(<expr><call><name>apr_hash_count</name><argument_list>(<argument><expr><name><name>pb</name>-&gt;<name>dropped_nodes</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>,
                                  <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Dropped %d node(s):\n"</expr></argument>)</argument_list></call></expr></argument>,
                                  <argument><expr><call><name>apr_hash_count</name><argument_list>(<argument><expr><name><name>pb</name>-&gt;<name>dropped_nodes</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Get the keys of the hash, sort them, then print the hash keys
         and values, sorted by keys. */</comment>
      <expr_stmt><expr><name>num_keys</name> = <call><name>apr_hash_count</name><argument_list>(<argument><expr><name><name>pb</name>-&gt;<name>dropped_nodes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>keys</name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>num_keys</name> + 1</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>const <name>char</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>pb</name>-&gt;<name>dropped_nodes</name></name></expr></argument>)</argument_list></call></expr>;</init>
           <condition><expr><name>hi</name></expr>;</condition>
           <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
        <block>{
          <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>keys</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call> = <name>key</name></expr>;</expr_stmt>
        }</block></for>
      <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name><name>keys</name>-&gt;<name>elts</name></name></expr></argument>, <argument><expr><name><name>keys</name>-&gt;<name>nelts</name></name></expr></argument>, <argument><expr><name><name>keys</name>-&gt;<name>elt_size</name></name></expr></argument>, <argument><expr><name>svn_sort_compare_paths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>keys</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
        <block>{
          <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_fprintf</name>
                  <argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>, <argument><expr>"   '%s'\n"</expr></argument>,
                   <argument><expr>(const <name>char</name> *)<call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>keys</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_fputs</name><argument_list>(<argument><expr>"\n"</expr></argument>, <argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* This implements `exclude' subcommand. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>subcommand_exclude</name><parameter_list>(<param><decl><type><name>apr_getopt_t</name> *</type><name>os</name></decl></param>, <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>do_filter</name><argument_list>(<argument><expr><name>os</name></expr></argument>, <argument><expr><name>baton</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<comment type="block">/* This implements `include` subcommand. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>subcommand_include</name><parameter_list>(<param><decl><type><name>apr_getopt_t</name> *</type><name>os</name></decl></param>, <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>do_filter</name><argument_list>(<argument><expr><name>os</name></expr></argument>, <argument><expr><name>baton</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<escape char="0xc"/>
<comment type="block">/** Main. **/</comment>

<function><type><name>int</name></type>
<name>main</name><parameter_list>(<param><decl><type><name>int</name></type> <name>argc</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name><name>argv</name><index>[]</index></name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_status_t</name></type> <name>apr_err</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_allocator_t</name> *</type><name>allocator</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_opt_subcommand_desc_t</name> *</type><name>subcommand</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>svndumpfilter_opt_state</name></type> <name>opt_state</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_getopt_t</name> *</type><name>os</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>opt_id</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>received_opts</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>


  <comment type="block">/* Initialize the app. */</comment>
  <if>if <condition>(<expr><call><name>svn_cmdline_init</name><argument_list>(<argument><expr>"svndumpfilter"</expr></argument>, <argument><expr><name>stderr</name></expr></argument>)</argument_list></call> != <name>EXIT_SUCCESS</name></expr>)</condition><then>
    <return>return <expr><name>EXIT_FAILURE</name></expr>;</return></then></if>

  <comment type="block">/* Create our top-level pool.  Use a seperate mutexless allocator,
   * given this application is single threaded.
   */</comment>
  <if>if <condition>(<expr><call><name>apr_allocator_create</name><argument_list>(<argument><expr>&amp;<name>allocator</name></expr></argument>)</argument_list></call></expr>)</condition><then>
   <return>return <expr><name>EXIT_FAILURE</name></expr>;</return></then></if>

  <expr_stmt><expr><call><name>apr_allocator_max_free_set</name><argument_list>(<argument><expr><name>allocator</name></expr></argument>, <argument><expr><name>SVN_ALLOCATOR_RECOMMENDED_MAX_FREE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>pool</name> = <call><name>svn_pool_create_ex</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>allocator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>apr_allocator_owner_set</name><argument_list>(<argument><expr><name>allocator</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check library versions */</comment>
  <expr_stmt><expr><name>err</name> = <call><name>check_lib_versions</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_cmdline_handle_exit_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"svndumpfilter: "</expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><name>received_opts</name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>SVN_OPT_MAX_OPTIONS</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Initialize the FS library. */</comment>
  <expr_stmt><expr><name>err</name> = <call><name>svn_fs_initialize</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_cmdline_handle_exit_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"svndumpfilter: "</expr></argument>)</argument_list></call></expr>;</return></then></if>

  <if>if <condition>(<expr><name>argc</name> &lt;= 1</expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>subcommand_help</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>EXIT_FAILURE</name></expr>;</return>
    }</block></then></if>

  <comment type="block">/* Initialize opt_state. */</comment>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>opt_state</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>opt_state</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>opt_state</name>.<name>start_revision</name>.<name>kind</name></name> = <name>svn_opt_revision_unspecified</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>opt_state</name>.<name>end_revision</name>.<name>kind</name></name> = <name>svn_opt_revision_unspecified</name></expr>;</expr_stmt>

  <comment type="block">/* Parse options. */</comment>
  <expr_stmt><expr><name>err</name> = <call><name>svn_cmdline__getopt_init</name><argument_list>(<argument><expr>&amp;<name>os</name></expr></argument>, <argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_cmdline_handle_exit_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"svndumpfilter: "</expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><name><name>os</name>-&gt;<name>interleave</name></name> = 1</expr>;</expr_stmt>
  <while>while <condition>(<expr>1</expr>)</condition>
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>opt_arg</name></decl>;</decl_stmt>

      <comment type="block">/* Parse the next option. */</comment>
      <expr_stmt><expr><name>apr_err</name> = <call><name>apr_getopt_long</name><argument_list>(<argument><expr><name>os</name></expr></argument>, <argument><expr><name>options_table</name></expr></argument>, <argument><expr>&amp;<name>opt_id</name></expr></argument>, <argument><expr>&amp;<name>opt_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><call><name>APR_STATUS_IS_EOF</name><argument_list>(<argument><expr><name>apr_err</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <break>break;</break></then>
      <else>else <if>if <condition>(<expr><name>apr_err</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>subcommand_help</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>EXIT_FAILURE</name></expr>;</return>
        }</block></then></if></else></if>

      <comment type="block">/* Stash the option code in an array before parsing it. */</comment>
      <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>received_opts</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call> = <name>opt_id</name></expr>;</expr_stmt>

      <switch>switch <condition>(<expr><name>opt_id</name></expr>)</condition>
        <block>{
        <case>case <expr>'h'</expr>:
        </case><case>case <expr>'?'</expr>:
          <expr_stmt><expr><name><name>opt_state</name>.<name>help</name></name> = <name>TRUE</name></expr>;</expr_stmt>
          <break>break;</break>
        </case><case>case <expr><name>svndumpfilter__version</name></expr>:
          <expr_stmt><expr><name><name>opt_state</name>.<name>version</name></name> = <name>TRUE</name></expr>;</expr_stmt>
        </case><case>case <expr><name>svndumpfilter__quiet</name></expr>:
          <expr_stmt><expr><name><name>opt_state</name>.<name>quiet</name></name> = <name>TRUE</name></expr>;</expr_stmt>
          <break>break;</break>
        </case><case>case <expr><name>svndumpfilter__drop_empty_revs</name></expr>:
          <expr_stmt><expr><name><name>opt_state</name>.<name>drop_empty_revs</name></name> = <name>TRUE</name></expr>;</expr_stmt>
          <break>break;</break>
        </case><case>case <expr><name>svndumpfilter__renumber_revs</name></expr>:
          <expr_stmt><expr><name><name>opt_state</name>.<name>renumber_revs</name></name> = <name>TRUE</name></expr>;</expr_stmt>
          <break>break;</break>
        </case><case>case <expr><name>svndumpfilter__preserve_revprops</name></expr>:
          <expr_stmt><expr><name><name>opt_state</name>.<name>preserve_revprops</name></name> = <name>TRUE</name></expr>;</expr_stmt>
          <break>break;</break>
        </case><case>case <expr><name>svndumpfilter__skip_missing_merge_sources</name></expr>:
          <expr_stmt><expr><name><name>opt_state</name>.<name>skip_missing_merge_sources</name></name> = <name>TRUE</name></expr>;</expr_stmt>
          <break>break;</break>
        </case><default>default:
          <block>{
            <expr_stmt><expr><call><name>subcommand_help</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <return>return <expr><name>EXIT_FAILURE</name></expr>;</return>
          }</block>
        </default>}</block></switch>  <comment type="block">/* close `switch' */</comment>
    }</block></while>  <comment type="block">/* close `while' */</comment>

  <comment type="block">/* If the user asked for help, then the rest of the arguments are
     the names of subcommands to get help on (if any), or else they're
     just typos/mistakes.  Whatever the case, the subcommand to
     actually run is subcommand_help(). */</comment>
  <if>if <condition>(<expr><name><name>opt_state</name>.<name>help</name></name></expr>)</condition><then>
    <expr_stmt><expr><name>subcommand</name> = <call><name>svn_opt_get_canonical_subcommand</name><argument_list>(<argument><expr><name>cmd_table</name></expr></argument>, <argument><expr>"help"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* If we're not running the `help' subcommand, then look for a
     subcommand in the first argument. */</comment>
  <if>if <condition>(<expr><name>subcommand</name> == <name>NULL</name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr><name><name>os</name>-&gt;<name>ind</name></name> &gt;= <name><name>os</name>-&gt;<name>argc</name></name></expr>)</condition><then>
        <block>{
          <if>if <condition>(<expr><name><name>opt_state</name>.<name>version</name></name></expr>)</condition><then>
            <block>{
              <comment type="block">/* Use the "help" subcommand to handle the "--version" option. */</comment>
              <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>svn_opt_subcommand_desc_t</name></type> <name>pseudo_cmd</name> <init>=
                <expr><block>{ <expr>"--version"</expr>, <expr><name>subcommand_help</name></expr>, <expr><block>{<expr>0</expr>}</block></expr>, <expr>""</expr>,
                  <expr><block>{<expr><name>svndumpfilter__version</name></expr>,  <comment type="block">/* must accept its own option */</comment>
                  }</block></expr> }</block></expr></init></decl>;</decl_stmt>

              <expr_stmt><expr><name>subcommand</name> = &amp;<name>pseudo_cmd</name></expr>;</expr_stmt>
            }</block></then>
          <else>else
            <block>{
              <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><call><name>svn_cmdline_fprintf</name>
                              <argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>,
                               <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Subcommand argument required\n"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>subcommand_help</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <return>return <expr><name>EXIT_FAILURE</name></expr>;</return>
            }</block></else></if>
        }</block></then>
      <else>else
        <block>{
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>first_arg</name> <init>= <expr><name><name>os</name>-&gt;<name>argv</name><index>[<expr><name><name>os</name>-&gt;<name>ind</name></name>++</expr>]</index></name></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>subcommand</name> = <call><name>svn_opt_get_canonical_subcommand</name><argument_list>(<argument><expr><name>cmd_table</name></expr></argument>, <argument><expr><name>first_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>subcommand</name> == <name>NULL</name></expr>)</condition><then>
            <block>{
              <decl_stmt><decl><type><specifier>const</specifier> <name>char</name>*</type> <name>first_arg_utf8</name></decl>;</decl_stmt>
              <if>if <condition>(<expr>(<name>err</name> = <call><name>svn_utf_cstring_to_utf8</name><argument_list>(<argument><expr>&amp;<name>first_arg_utf8</name></expr></argument>, <argument><expr><name>first_arg</name></expr></argument>,
                                                 <argument><expr><name>pool</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
                <return>return <expr><call><name>svn_cmdline_handle_exit_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>,
                                                     <argument><expr>"svndumpfilter: "</expr></argument>)</argument_list></call></expr>;</return></then></if>

              <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><call><name>svn_cmdline_fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>,
                                                  <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Unknown command: '%s'\n"</expr></argument>)</argument_list></call></expr></argument>,
                                                  <argument><expr><name>first_arg_utf8</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>subcommand_help</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <return>return <expr><name>EXIT_FAILURE</name></expr>;</return>
            }</block></then></if>
        }</block></else></if>
    }</block></then></if>

  <comment type="block">/* If there's a second argument, it's probably [one of] prefixes.
     Every subcommand except `help' requires at least one, so we parse
     them out here and store in opt_state. */</comment>

  <if>if <condition>(<expr><name><name>subcommand</name>-&gt;<name>cmd_func</name></name> != <name>subcommand_help</name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr><name><name>os</name>-&gt;<name>ind</name></name> &gt;= <name><name>os</name>-&gt;<name>argc</name></name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><call><name>svn_cmdline_fprintf</name>
                          <argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>,
                           <argument><expr><call><name>_</name><argument_list>(<argument><expr>"\nError: no prefixes supplied.\n"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>EXIT_FAILURE</name></expr>;</return>
        }</block></then></if>

      <expr_stmt><expr><name><name>opt_state</name>.<name>prefixes</name></name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>os</name>-&gt;<name>argc</name></name> - <name><name>os</name>-&gt;<name>ind</name></name></expr></argument>,
                                          <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>const <name>char</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <for>for (<init><expr><name>i</name> = <name><name>os</name>-&gt;<name>ind</name></name></expr> ;</init> <condition><expr><name>i</name>&lt; <name><name>os</name>-&gt;<name>argc</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
        <block>{
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>prefix</name></decl>;</decl_stmt>

          <comment type="block">/* Ensure that each prefix is UTF8-encoded, in internal
             style, and absolute. */</comment>
          <expr_stmt><expr><call><name>SVN_INT_ERR</name><argument_list>(<argument><expr><call><name>svn_utf_cstring_to_utf8</name><argument_list>(<argument><expr>&amp;<name>prefix</name></expr></argument>, <argument><expr><name><name>os</name>-&gt;<name>argv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>prefix</name> = <call><name>svn_path_internal_style</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>prefix</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr>"/"</expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name><name>opt_state</name>.<name>prefixes</name></name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call> = <name>prefix</name></expr>;</expr_stmt>
        }</block></for>
    }</block></then></if>


  <comment type="block">/* Check that the subcommand wasn't passed any inappropriate options. */</comment>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>received_opts</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <expr_stmt><expr><name>opt_id</name> = <call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>received_opts</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>int</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* All commands implicitly accept --help, so just skip over this
         when we see it. Note that we don't want to include this option
         in their "accepted options" list because it would be awfully
         redundant to display it in every commands' help text. */</comment>
      <if>if <condition>(<expr><name>opt_id</name> == 'h' || <name>opt_id</name> == '?'</expr>)</condition><then>
        <continue>continue;</continue></then></if>

      <if>if <condition>(<expr>! <call><name>svn_opt_subcommand_takes_option</name><argument_list>(<argument><expr><name>subcommand</name></expr></argument>, <argument><expr><name>opt_id</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>optstr</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>apr_getopt_option_t</name> *</type><name>badopt</name> <init>=
            <expr><call><name>svn_opt_get_option_from_code</name><argument_list>(<argument><expr><name>opt_id</name></expr></argument>, <argument><expr><name>options_table</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>svn_opt_format_option</name><argument_list>(<argument><expr>&amp;<name>optstr</name></expr></argument>, <argument><expr><name>badopt</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name><name>subcommand</name>-&gt;<name>name</name><index>[<expr>0</expr>]</index></name> == '-'</expr>)</condition><then>
            <expr_stmt><expr><call><name>subcommand_help</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
          <else>else
            <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><call><name>svn_cmdline_fprintf</name>
                            <argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>,
                             <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Subcommand '%s' doesn't accept option '%s'\n"
                               "Type 'svndumpfilter help %s' for usage.\n"</expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><name><name>subcommand</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>optstr</name></expr></argument>, <argument><expr><name><name>subcommand</name>-&gt;<name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
          <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>EXIT_FAILURE</name></expr>;</return>
        }</block></then></if>
    }</block></for>

  <comment type="block">/* Run the subcommand. */</comment>
  <expr_stmt><expr><name>err</name> = <call>(*<name><name>subcommand</name>-&gt;<name>cmd_func</name></name>)<argument_list>(<argument><expr><name>os</name></expr></argument>, <argument><expr>&amp;<name>opt_state</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* For argument-related problems, suggest using the 'help'
         subcommand. */</comment>
      <if>if <condition>(<expr><name><name>err</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_CL_INSUFFICIENT_ARGS</name>
          || <name><name>err</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_CL_ARG_PARSING_ERROR</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>err</name> = <call><name>svn_error_quick_wrap</name><argument_list>(<argument><expr><name>err</name></expr></argument>,
                                     <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Try 'svndumpfilter help' for more "
                                       "info"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
      <return>return <expr><call><name>svn_cmdline_handle_exit_error</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"svndumpfilter: "</expr></argument>)</argument_list></call></expr>;</return>
    }</block></then>
  <else>else
    <block>{
      <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Flush stdout, making sure the user will see any print errors. */</comment>
      <expr_stmt><expr><call><name>SVN_INT_ERR</name><argument_list>(<argument><expr><call><name>svn_cmdline_fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>EXIT_SUCCESS</name></expr>;</return>
    }</block></else></if>
}</block></function>
</unit>
