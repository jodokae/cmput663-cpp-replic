<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/subversion-1.5.1/source/subversion/libsvn_ra/compat.c"><comment type="block">/*
 * compat.c:  compatibility compliance logic
 *
 * ====================================================================
 * Copyright (c) 2004-2007 CollabNet.  All rights reserved.
 *
 * This software is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at http://subversion.tigris.org/license-1.html.
 * If newer versions of this license are posted there, you may use a
 * newer version instead, at your option.
 *
 * This software consists of voluntary contributions made by many
 * individuals.  For exact contribution history, see the revision
 * history and logs, available at http://subversion.tigris.org/.
 * ====================================================================
 */</comment>

<comment type="block">/* ==================================================================== */</comment>
<escape char="0xc"/>
<comment type="block">/*** Includes. ***/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_pools.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_error.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_pools.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_sorts.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_path.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_ra.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_io.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_compat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ra_loader.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_private_config.h"</cpp:file></cpp:include>

<escape char="0xc"/>

<comment type="block">/* This is just like svn_sort_compare_revisions, save that it sorts
   the revisions in *ascending* order. */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>compare_revisions</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>a</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>b</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>a_rev</name> <init>= <expr>*(const <name>svn_revnum_t</name> *)<name>a</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>b_rev</name> <init>= <expr>*(const <name>svn_revnum_t</name> *)<name>b</name></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>a_rev</name> == <name>b_rev</name></expr>)</condition><then>
    <return>return <expr>0</expr>;</return></then></if>
  <return>return <expr><name>a_rev</name> &lt; <name>b_rev</name> ? -1 : 1</expr>;</return>
}</block></function>

<comment type="block">/* Given the CHANGED_PATHS and REVISION from an instance of a
   svn_log_message_receiver_t function, determine at which location
   PATH may be expected in the next log message, and set *PREV_PATH_P
   to that value.  KIND is the node kind of PATH.  Set *ACTION_P to a
   character describing the change that caused this revision (as
   listed in svn_log_changed_path_t) and set *COPYFROM_REV_P to the
   revision PATH was copied from, or SVN_INVALID_REVNUM if it was not
   copied.  ACTION_P and COPYFROM_REV_P may be NULL, in which case
   they are not used.  Perform all allocations in POOL.

   This is useful for tracking the various changes in location a
   particular resource has undergone when performing an RA-&gt;get_logs()
   operation on that resource.
*/</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>prev_log_path</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>prev_path_p</name></decl></param>,
              <param><decl><type><name>char</name> *</type><name>action_p</name></decl></param>,
              <param><decl><type><name>svn_revnum_t</name> *</type><name>copyfrom_rev_p</name></decl></param>,
              <param><decl><type><name>apr_hash_t</name> *</type><name>changed_paths</name></decl></param>,
              <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
              <param><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl></param>,
              <param><decl><type><name>svn_revnum_t</name></type> <name>revision</name></decl></param>,
              <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_log_changed_path_t</name> *</type><name>change</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>prev_path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* It's impossible to find the predecessor path of a NULL path. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Initialize our return values for the action and copyfrom_rev in
     case we have an unhandled case later on. */</comment>
  <if>if <condition>(<expr><name>action_p</name></expr>)</condition><then>
    <expr_stmt><expr>*<name>action_p</name> = 'M'</expr>;</expr_stmt></then></if>
  <if>if <condition>(<expr><name>copyfrom_rev_p</name></expr>)</condition><then>
    <expr_stmt><expr>*<name>copyfrom_rev_p</name> = <name>SVN_INVALID_REVNUM</name></expr>;</expr_stmt></then></if>

  <if>if <condition>(<expr><name>changed_paths</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* See if PATH was explicitly changed in this revision. */</comment>
      <expr_stmt><expr><name>change</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>changed_paths</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>change</name></expr>)</condition><then>
        <block>{
          <comment type="block">/* If PATH was not newly added in this revision, then it may or may
             not have also been part of a moved subtree.  In this case, set a
             default previous path, but still look through the parents of this
             path for a possible copy event. */</comment>
          <if>if <condition>(<expr><name><name>change</name>-&gt;<name>action</name></name> != 'A' &amp;&amp; <name><name>change</name>-&gt;<name>action</name></name> != 'R'</expr>)</condition><then>
            <block>{
              <expr_stmt><expr><name>prev_path</name> = <name>path</name></expr>;</expr_stmt>
            }</block></then>
          <else>else
            <block>{
              <comment type="block">/* PATH is new in this revision.  This means it cannot have been
                 part of a copied subtree. */</comment>
              <if>if <condition>(<expr><name><name>change</name>-&gt;<name>copyfrom_path</name></name></expr>)</condition><then>
                <expr_stmt><expr><name>prev_path</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>change</name>-&gt;<name>copyfrom_path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
              <else>else
                <expr_stmt><expr><name>prev_path</name> = <name>NULL</name></expr>;</expr_stmt></else></if>
              
              <expr_stmt><expr>*<name>prev_path_p</name> = <name>prev_path</name></expr>;</expr_stmt>
              <if>if <condition>(<expr><name>action_p</name></expr>)</condition><then>
                <expr_stmt><expr>*<name>action_p</name> = <name><name>change</name>-&gt;<name>action</name></name></expr>;</expr_stmt></then></if>
              <if>if <condition>(<expr><name>copyfrom_rev_p</name></expr>)</condition><then>
                <expr_stmt><expr>*<name>copyfrom_rev_p</name> = <name><name>change</name>-&gt;<name>copyfrom_rev</name></name></expr>;</expr_stmt></then></if>
              <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
            }</block></else></if>
        }</block></then></if>
      
      <if>if <condition>(<expr><call><name>apr_hash_count</name><argument_list>(<argument><expr><name>changed_paths</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <comment type="block">/* The path was not explicitly changed in this revision.  The
             fact that we're hearing about this revision implies, then,
             that the path was a child of some copied directory.  We need
             to find that directory, and effectively "re-base" our path on
             that directory's copyfrom_path. */</comment>
          <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>paths</name></decl>;</decl_stmt>
          
          <comment type="block">/* Build a sorted list of the changed paths. */</comment>
          <expr_stmt><expr><name>paths</name> = <call><name>svn_sort__hash</name><argument_list>(<argument><expr><name>changed_paths</name></expr></argument>,
                                 <argument><expr><name>svn_sort_compare_items_as_paths</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          
          <comment type="block">/* Now, walk the list of paths backwards, looking a parent of
             our path that has copyfrom information. */</comment>
          <for>for (<init><expr><name>i</name> = <name><name>paths</name>-&gt;<name>nelts</name></name></expr>;</init> <condition><expr><name>i</name> &gt; 0</expr>;</condition> <incr><expr><name>i</name>--</expr></incr>)
            <block>{
              <decl_stmt><decl><type><name>svn_sort__item_t</name></type> <name>item</name> <init>= <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>paths</name></expr></argument>,
                                                    <argument><expr><name>i</name> - 1</expr></argument>, <argument><expr><name>svn_sort__item_t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
              <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ch_path</name> <init>= <expr><name><name>item</name>.<name>key</name></name></expr></init></decl>;</decl_stmt>
              <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>ch_path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
              
              <comment type="block">/* See if our path is the child of this change path.  If
                 not, keep looking.  */</comment>
              <if>if <condition>(<expr>! ((<call><name>strncmp</name><argument_list>(<argument><expr><name>ch_path</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> == 0) &amp;&amp; (<name><name>path</name><index>[<expr><name>len</name></expr>]</index></name> == '/'))</expr>)</condition><then>
                <continue>continue;</continue></then></if>
              
              <comment type="block">/* Okay, our path *is* a child of this change path.  If
                 this change was copied, we just need to apply the
                 portion of our path that is relative to this change's
                 path, to the change's copyfrom path.  Otherwise, this
                 change isn't really interesting to us, and our search
                 continues. */</comment>
              <expr_stmt><expr><name>change</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>changed_paths</name></expr></argument>, <argument><expr><name>ch_path</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <if>if <condition>(<expr><name><name>change</name>-&gt;<name>copyfrom_path</name></name></expr>)</condition><then>
                <block>{
                  <if>if <condition>(<expr><name>action_p</name></expr>)</condition><then>
                    <expr_stmt><expr>*<name>action_p</name> = <name><name>change</name>-&gt;<name>action</name></name></expr>;</expr_stmt></then></if>
                  <if>if <condition>(<expr><name>copyfrom_rev_p</name></expr>)</condition><then>
                    <expr_stmt><expr>*<name>copyfrom_rev_p</name> = <name><name>change</name>-&gt;<name>copyfrom_rev</name></name></expr>;</expr_stmt></then></if>
                  <expr_stmt><expr><name>prev_path</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name><name>change</name>-&gt;<name>copyfrom_path</name></name></expr></argument>,
                                            <argument><expr><name>path</name> + <name>len</name> + 1</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <break>break;</break>
                }</block></then></if>
            }</block></for>
        }</block></then></if>
    }</block></then></if>

  <comment type="block">/* If we didn't find what we expected to find, return an error.
     (Because directories bubble-up, we get a bunch of logs we might
     not want.  Be forgiving in that case.)  */</comment>
  <if>if <condition>(<expr>! <name>prev_path</name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr><name>kind</name> == <name>svn_node_dir</name></expr>)</condition><then>
        <expr_stmt><expr><name>prev_path</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
      <else>else
        <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_CLIENT_UNRELATED_RESOURCES</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                 <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Missing changed-path information for "
                                   "'%s' in revision %ld"</expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>revision</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
    }</block></then></if>

  <expr_stmt><expr>*<name>prev_path_p</name> = <name>prev_path</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<escape char="0xc"/>
<comment type="block">/*** Fallback implementation of svn_ra_get_locations(). ***/</comment>


<comment type="block">/* ### This is to support 1.0 servers. */</comment>
<struct>struct <name>log_receiver_baton</name>
<block>{
  <comment type="block">/* The kind of the path we're tracing. */</comment>
  <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>

  <comment type="block">/* The path at which we are trying to find our versioned resource in
     the log output. */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>last_path</name></decl>;</decl_stmt>

  <comment type="block">/* Input revisions and output hash; the whole point of this little game. */</comment>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>peg_revision</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>location_revisions</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>peg_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>locations</name></decl>;</decl_stmt>

  <comment type="block">/* A pool from which to allocate stuff stored in this baton. */</comment>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>
}</block>;</struct>


<comment type="block">/* Implements svn_log_entry_receiver_t; helper for slow_get_locations.
   As input, takes log_receiver_baton (defined above) and attempts to
   "fill in" locations in the baton over the course of many
   iterations. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>log_receiver</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>,
             <param><decl><type><name>svn_log_entry_t</name> *</type><name>log_entry</name></decl></param>,
             <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>log_receiver_baton</name> *</type><name>lrb</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>hash_pool</name> <init>= <expr><call><name>apr_hash_pool_get</name><argument_list>(<argument><expr><name><name>lrb</name>-&gt;<name>locations</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>current_path</name> <init>= <expr><name><name>lrb</name>-&gt;<name>last_path</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>prev_path</name></decl>;</decl_stmt>

  <comment type="block">/* No paths were changed in this revision.  Nothing to do. */</comment>
  <if>if <condition>(<expr>! <name><name>log_entry</name>-&gt;<name>changed_paths</name></name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <comment type="block">/* If we've run off the end of the path's history, there's nothing
     to do.  (This should never happen with a properly functioning
     server, since we'd get no more log messages after the one where
     path was created.  But a malfunctioning server shouldn't cause us
     to trigger an assertion failure.) */</comment>
  <if>if <condition>(<expr>! <name>current_path</name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <comment type="block">/* If we haven't found our peg path yet, and we are now looking at a
     revision equal to or older than the peg revision, then our
     "current" path is our peg path. */</comment>
  <if>if <condition>(<expr>(! <name><name>lrb</name>-&gt;<name>peg_path</name></name>) &amp;&amp; (<name><name>log_entry</name>-&gt;<name>revision</name></name> &lt;= <name><name>lrb</name>-&gt;<name>peg_revision</name></name>)</expr>)</condition><then>
    <expr_stmt><expr><name><name>lrb</name>-&gt;<name>peg_path</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>lrb</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>current_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* Determine the paths for any of the revisions for which we haven't
     gotten paths already. */</comment>
  <while>while <condition>(<expr><name><name>lrb</name>-&gt;<name>location_revisions</name>-&gt;<name>nelts</name></name></expr>)</condition>
    <block>{
      <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>next</name> <init>= <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name><name>lrb</name>-&gt;<name>location_revisions</name></name></expr></argument>,
                                        <argument><expr><name><name>lrb</name>-&gt;<name>location_revisions</name>-&gt;<name>nelts</name></name> - 1</expr></argument>,
                                        <argument><expr><name>svn_revnum_t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><name><name>log_entry</name>-&gt;<name>revision</name></name> &lt;= <name>next</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name><name>lrb</name>-&gt;<name>locations</name></name></expr></argument>,
                       <argument><expr><call><name>apr_pmemdup</name><argument_list>(<argument><expr><name>hash_pool</name></expr></argument>, <argument><expr>&amp;<name>next</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>next</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>,
                       <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>next</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                       <argument><expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>hash_pool</name></expr></argument>, <argument><expr><name>current_path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>apr_array_pop</name><argument_list>(<argument><expr><name><name>lrb</name>-&gt;<name>location_revisions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
      <else>else
        <break>break;</break></else></if>
    }</block></while>

  <comment type="block">/* Figure out at which repository path our object of interest lived
     in the previous revision. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>prev_log_path</name><argument_list>(<argument><expr>&amp;<name>prev_path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>log_entry</name>-&gt;<name>changed_paths</name></name></expr></argument>,
                        <argument><expr><name>current_path</name></expr></argument>, <argument><expr><name><name>lrb</name>-&gt;<name>kind</name></name></expr></argument>, <argument><expr><name><name>log_entry</name>-&gt;<name>revision</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Squirrel away our "next place to look" path (suffer the strcmp
     hit to save on allocations). */</comment>
  <if>if <condition>(<expr>! <name>prev_path</name></expr>)</condition><then>
    <expr_stmt><expr><name><name>lrb</name>-&gt;<name>last_path</name></name> = <name>NULL</name></expr>;</expr_stmt></then>
  <else>else <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>prev_path</name></expr></argument>, <argument><expr><name>current_path</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
    <expr_stmt><expr><name><name>lrb</name>-&gt;<name>last_path</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>lrb</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>prev_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_ra__locations_from_log</name><parameter_list>(<param><decl><type><name>svn_ra_session_t</name> *</type><name>session</name></decl></param>,
                           <param><decl><type><name>apr_hash_t</name> **</type><name>locations_p</name></decl></param>,
                           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                           <param><decl><type><name>svn_revnum_t</name></type> <name>peg_revision</name></decl></param>,
                           <param><decl><type><name>apr_array_header_t</name> *</type><name>location_revisions</name></decl></param>,
                           <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>locations</name> <init>= <expr><call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>log_receiver_baton</name></type> <name>lrb</name> <init>= <expr><block>{ <expr>0</expr> }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>targets</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>youngest_requested</name></decl>, <decl><type ref="prev"/><name>oldest_requested</name></decl>, <decl><type ref="prev"/><name>youngest</name></decl>, <decl><type ref="prev"/><name>oldest</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>root_url</name></decl>, *<decl><type ref="prev"/><name>url</name></decl>, *<decl><type ref="prev"/><name>rel_path</name></decl>;</decl_stmt>

  <comment type="block">/* Fetch the repository root URL and relative path. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_get_repos_root2</name><argument_list>(<argument><expr><name>session</name></expr></argument>, <argument><expr>&amp;<name>root_url</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_get_session_url</name><argument_list>(<argument><expr><name>session</name></expr></argument>, <argument><expr>&amp;<name>url</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>url</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>url</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rel_path</name> = <call><name>svn_path_uri_decode</name><argument_list>(<argument><expr><name>url</name> + <call><name>strlen</name><argument_list>(<argument><expr><name>root_url</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Sanity check: verify that the peg-object exists in repos. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_check_path</name><argument_list>(<argument><expr><name>session</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>peg_revision</name></expr></argument>, <argument><expr>&amp;<name>kind</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>kind</name> == <name>svn_node_none</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_FS_NOT_FOUND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Path '%s' doesn't exist in revision %ld"</expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><name>rel_path</name></expr></argument>, <argument><expr><name>peg_revision</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Easy out: no location revisions. */</comment>
  <if>if <condition>(<expr>! <name><name>location_revisions</name>-&gt;<name>nelts</name></name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr>*<name>locations_p</name> = <name>locations</name></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>

  <comment type="block">/* Figure out the youngest and oldest revs (amongst the set of
     requested revisions + the peg revision) so we can avoid
     unnecessary log parsing. */</comment>
  <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name><name>location_revisions</name>-&gt;<name>elts</name></name></expr></argument>, <argument><expr><name><name>location_revisions</name>-&gt;<name>nelts</name></name></expr></argument>,
        <argument><expr><name><name>location_revisions</name>-&gt;<name>elt_size</name></name></expr></argument>, <argument><expr><name>compare_revisions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>oldest_requested</name> = <call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>location_revisions</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>svn_revnum_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>youngest_requested</name> = <call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>location_revisions</name></expr></argument>,
                                     <argument><expr><name><name>location_revisions</name>-&gt;<name>nelts</name></name> - 1</expr></argument>,
                                     <argument><expr><name>svn_revnum_t</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>youngest</name> = <name>peg_revision</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>youngest</name> = (<name>oldest_requested</name> &gt; <name>youngest</name>) ? <name>oldest_requested</name> : <name>youngest</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>youngest</name> = (<name>youngest_requested</name> &gt; <name>youngest</name>) ? <name>youngest_requested</name> : <name>youngest</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>oldest</name> = <name>peg_revision</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>oldest</name> = (<name>oldest_requested</name> &lt; <name>oldest</name>) ? <name>oldest_requested</name> : <name>oldest</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>oldest</name> = (<name>youngest_requested</name> &lt; <name>oldest</name>) ? <name>youngest_requested</name> : <name>oldest</name></expr>;</expr_stmt>

  <comment type="block">/* Populate most of our log receiver baton structure. */</comment>
  <expr_stmt><expr><name><name>lrb</name>.<name>kind</name></name> = <name>kind</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>lrb</name>.<name>last_path</name></name> = <name>rel_path</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>lrb</name>.<name>location_revisions</name></name> = <call><name>apr_array_copy</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>location_revisions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>lrb</name>.<name>peg_revision</name></name> = <name>peg_revision</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>lrb</name>.<name>peg_path</name></name> = <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>lrb</name>.<name>locations</name></name> = <name>locations</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>lrb</name>.<name>pool</name></name> = <name>pool</name></expr>;</expr_stmt>

  <comment type="block">/* Let the RA layer drive our log information handler, which will do
     the work of finding the actual locations for our resource.
     Notice that we always run on the youngest rev of the 3 inputs. */</comment>
  <expr_stmt><expr><name>targets</name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>const <name>char</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>targets</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call> = <name>path</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_get_log2</name><argument_list>(<argument><expr><name>session</name></expr></argument>, <argument><expr><name>targets</name></expr></argument>, <argument><expr><name>youngest</name></expr></argument>, <argument><expr><name>oldest</name></expr></argument>, <argument><expr>0</expr></argument>,
                          <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                          <argument><expr><call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>const <name>char</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><name>log_receiver</name></expr></argument>, <argument><expr>&amp;<name>lrb</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If the received log information did not cover any of the
     requested revisions, use the last known path.  (This normally
     just means that ABS_PATH was not modified between the requested
     revision and OLDEST.  If the file was created at some point after
     OLDEST, then lrb.last_path should be NULL.) */</comment>
  <if>if <condition>(<expr>! <name><name>lrb</name>.<name>peg_path</name></name></expr>)</condition><then>
    <expr_stmt><expr><name><name>lrb</name>.<name>peg_path</name></name> = <name><name>lrb</name>.<name>last_path</name></name></expr>;</expr_stmt></then></if>
  <if>if <condition>(<expr><name><name>lrb</name>.<name>last_path</name></name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>location_revisions</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
        <block>{
          <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>rev</name> <init>= <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>location_revisions</name></expr></argument>, <argument><expr><name>i</name></expr></argument>,
                                           <argument><expr><name>svn_revnum_t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <if>if <condition>(<expr>! <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>locations</name></expr></argument>, <argument><expr>&amp;<name>rev</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>rev</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>locations</name></expr></argument>, <argument><expr><call><name>apr_pmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>&amp;<name>rev</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>rev</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>,
                         <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>rev</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>lrb</name>.<name>last_path</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        }</block></for>
    }</block></then></if>

  <comment type="block">/* Check that we got the peg path. */</comment>
  <if>if <condition>(<expr>! <name><name>lrb</name>.<name>peg_path</name></name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name>
      <argument_list>(<argument><expr><name>APR_EGENERAL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Unable to find repository location for '%s' in revision %ld"</expr></argument>)</argument_list></call></expr></argument>,
       <argument><expr><name>rel_path</name></expr></argument>, <argument><expr><name>peg_revision</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Sanity check: make sure that our calculated peg path is the same
     as what we expected it to be. */</comment>
  <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>rel_path</name></expr></argument>, <argument><expr><name><name>lrb</name>.<name>peg_path</name></name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name>
      <argument_list>(<argument><expr><name>SVN_ERR_CLIENT_UNRELATED_RESOURCES</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"'%s' in revision %ld is an unrelated object"</expr></argument>)</argument_list></call></expr></argument>,
       <argument><expr><name>rel_path</name></expr></argument>, <argument><expr><name>youngest</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr>*<name>locations_p</name> = <name>locations</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>



<escape char="0xc"/>
<comment type="block">/*** Fallback implementation of svn_ra_get_location_segments(). ***/</comment>

<struct>struct <name>gls_log_receiver_baton</name> <block>{
  <comment type="block">/* The kind of the path we're tracing. */</comment>
  <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>

  <comment type="block">/* Are we finished (and just listening to log entries because our
     caller won't shut up?). */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>done</name></decl>;</decl_stmt>

  <comment type="block">/* The path at which we are trying to find our versioned resource in
     the log output. */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>last_path</name></decl>;</decl_stmt>

  <comment type="block">/* Input data. */</comment>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>start_rev</name></decl>;</decl_stmt>

  <comment type="block">/* Output intermediate state and callback/baton. */</comment>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>range_end</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_location_segment_receiver_t</name></type> <name>receiver</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> *</type><name>receiver_baton</name></decl>;</decl_stmt>

  <comment type="block">/* A pool from which to allocate stuff stored in this baton. */</comment>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/* Build a node location segment object from PATH, RANGE_START, and
   RANGE_END, and pass it off to RECEIVER/RECEIVER_BATON. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>maybe_crop_and_send_segment</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                            <param><decl><type><name>svn_revnum_t</name></type> <name>start_rev</name></decl></param>,
                            <param><decl><type><name>svn_revnum_t</name></type> <name>range_start</name></decl></param>,
                            <param><decl><type><name>svn_revnum_t</name></type> <name>range_end</name></decl></param>,
                            <param><decl><type><name>svn_location_segment_receiver_t</name></type> <name>receiver</name></decl></param>,
                            <param><decl><type><name>void</name> *</type><name>receiver_baton</name></decl></param>,
                            <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_location_segment_t</name> *</type><name>segment</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>segment</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>segment</name>-&gt;<name>path</name></name> = <name>path</name> ? ((*<name>path</name> == '/') ? <name>path</name> + 1 : <name>path</name>) : <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>segment</name>-&gt;<name>range_start</name></name> = <name>range_start</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>segment</name>-&gt;<name>range_end</name></name> = <name>range_end</name></expr>;</expr_stmt>
  <if>if <condition>(<expr><name><name>segment</name>-&gt;<name>range_start</name></name> &lt;= <name>start_rev</name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr><name><name>segment</name>-&gt;<name>range_end</name></name> &gt; <name>start_rev</name></expr>)</condition><then>
        <expr_stmt><expr><name><name>segment</name>-&gt;<name>range_end</name></name> = <name>start_rev</name></expr>;</expr_stmt></then></if>
      <return>return <expr><call><name>receiver</name><argument_list>(<argument><expr><name>segment</name></expr></argument>, <argument><expr><name>receiver_baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>gls_log_receiver</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>,
                 <param><decl><type><name>svn_log_entry_t</name> *</type><name>log_entry</name></decl></param>,
                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>gls_log_receiver_baton</name> *</type><name>lrb</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>current_path</name> <init>= <expr><name><name>lrb</name>-&gt;<name>last_path</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>prev_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>copyfrom_rev</name></decl>;</decl_stmt>

  <comment type="block">/* If we're done, ignore this invocation. */</comment>
  <if>if <condition>(<expr><name><name>lrb</name>-&gt;<name>done</name></name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <comment type="block">/* Figure out at which repository path our object of interest lived
     in the previous revision, and if its current location is the
     result of copy since then. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>prev_log_path</name><argument_list>(<argument><expr>&amp;<name>prev_path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>copyfrom_rev</name></expr></argument>,
                        <argument><expr><name><name>log_entry</name>-&gt;<name>changed_paths</name></name></expr></argument>, <argument><expr><name>current_path</name></expr></argument>,
                        <argument><expr><name><name>lrb</name>-&gt;<name>kind</name></name></expr></argument>, <argument><expr><name><name>log_entry</name>-&gt;<name>revision</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If we've run off the end of the path's history, we need to report
     our final segment (and then, we're done). */</comment>
  <if>if <condition>(<expr>! <name>prev_path</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name><name>lrb</name>-&gt;<name>done</name></name> = <name>TRUE</name></expr>;</expr_stmt>
      <return>return <expr><call><name>maybe_crop_and_send_segment</name><argument_list>(<argument><expr><name>current_path</name></expr></argument>, <argument><expr><name><name>lrb</name>-&gt;<name>start_rev</name></name></expr></argument>,
                                         <argument><expr><name><name>log_entry</name>-&gt;<name>revision</name></name></expr></argument>, <argument><expr><name><name>lrb</name>-&gt;<name>range_end</name></name></expr></argument>,
                                         <argument><expr><name><name>lrb</name>-&gt;<name>receiver</name></name></expr></argument>, <argument><expr><name><name>lrb</name>-&gt;<name>receiver_baton</name></name></expr></argument>,
                                         <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

  <comment type="block">/* If there was a copy operation of interest... */</comment>
  <if>if <condition>(<expr><call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name>copyfrom_rev</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <comment type="block">/* ...then report the segment between this revision and the
         last-reported revision. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>maybe_crop_and_send_segment</name><argument_list>(<argument><expr><name>current_path</name></expr></argument>, <argument><expr><name><name>lrb</name>-&gt;<name>start_rev</name></name></expr></argument>,
                                          <argument><expr><name><name>log_entry</name>-&gt;<name>revision</name></name></expr></argument>, <argument><expr><name><name>lrb</name>-&gt;<name>range_end</name></name></expr></argument>,
                                          <argument><expr><name><name>lrb</name>-&gt;<name>receiver</name></name></expr></argument>, <argument><expr><name><name>lrb</name>-&gt;<name>receiver_baton</name></name></expr></argument>,
                                          <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>lrb</name>-&gt;<name>range_end</name></name> = <name><name>log_entry</name>-&gt;<name>revision</name></name> - 1</expr>;</expr_stmt>

      <comment type="block">/* And if there was a revision gap, we need to report that, too. */</comment>
      <if>if <condition>(<expr><name><name>log_entry</name>-&gt;<name>revision</name></name> - <name>copyfrom_rev</name> &gt; 1</expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>maybe_crop_and_send_segment</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>lrb</name>-&gt;<name>start_rev</name></name></expr></argument>,
                                              <argument><expr><name>copyfrom_rev</name> + 1</expr></argument>, <argument><expr><name><name>lrb</name>-&gt;<name>range_end</name></name></expr></argument>,
                                              <argument><expr><name><name>lrb</name>-&gt;<name>receiver</name></name></expr></argument>,
                                              <argument><expr><name><name>lrb</name>-&gt;<name>receiver_baton</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>lrb</name>-&gt;<name>range_end</name></name> = <name>copyfrom_rev</name></expr>;</expr_stmt>
        }</block></then></if>

      <comment type="block">/* Update our state variables. */</comment>
      <expr_stmt><expr><name><name>lrb</name>-&gt;<name>last_path</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>lrb</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>prev_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_ra__location_segments_from_log</name><parameter_list>(<param><decl><type><name>svn_ra_session_t</name> *</type><name>session</name></decl></param>,
                                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                                   <param><decl><type><name>svn_revnum_t</name></type> <name>peg_revision</name></decl></param>,
                                   <param><decl><type><name>svn_revnum_t</name></type> <name>start_rev</name></decl></param>,
                                   <param><decl><type><name>svn_revnum_t</name></type> <name>end_rev</name></decl></param>,
                                   <param><decl><type><name>svn_location_segment_receiver_t</name></type> <name>receiver</name></decl></param>,
                                   <param><decl><type><name>void</name> *</type><name>receiver_baton</name></decl></param>,
                                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>gls_log_receiver_baton</name></type> <name>lrb</name> <init>= <expr><block>{ <expr>0</expr> }</block></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>targets</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>youngest_rev</name> <init>= <expr><name>SVN_INVALID_REVNUM</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>root_url</name></decl>, *<decl><type ref="prev"/><name>url</name></decl>, *<decl><type ref="prev"/><name>rel_path</name></decl>;</decl_stmt>

  <comment type="block">/* Fetch the repository root URL and relative path. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_get_repos_root2</name><argument_list>(<argument><expr><name>session</name></expr></argument>, <argument><expr>&amp;<name>root_url</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_get_session_url</name><argument_list>(<argument><expr><name>session</name></expr></argument>, <argument><expr>&amp;<name>url</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>url</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>url</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rel_path</name> = <call><name>svn_path_uri_decode</name><argument_list>(<argument><expr><name>url</name> + <call><name>strlen</name><argument_list>(<argument><expr><name>root_url</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If PEG_REVISION is invalid, it means HEAD.  If START_REV is
     invalid, it means HEAD.  If END_REV is SVN_INVALID_REVNUM, we'll
     use 0. */</comment>
  <if>if <condition>(<expr>! <call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name>peg_revision</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_get_latest_revnum</name><argument_list>(<argument><expr><name>session</name></expr></argument>, <argument><expr>&amp;<name>youngest_rev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>peg_revision</name> = <name>youngest_rev</name></expr>;</expr_stmt>
    }</block></then></if>
  <if>if <condition>(<expr>! <call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name>start_rev</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr><call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name>youngest_rev</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><name>start_rev</name> = <name>youngest_rev</name></expr>;</expr_stmt></then>
      <else>else
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_get_latest_revnum</name><argument_list>(<argument><expr><name>session</name></expr></argument>, <argument><expr>&amp;<name>start_rev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
    }</block></then></if>
  <if>if <condition>(<expr>! <call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name>end_rev</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>end_rev</name> = 0</expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* The API demands a certain ordering of our revision inputs. Enforce it. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>(<name>peg_revision</name> &gt;= <name>start_rev</name>) &amp;&amp; (<name>start_rev</name> &gt;= <name>end_rev</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Sanity check: verify that the peg-object exists in repos. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_check_path</name><argument_list>(<argument><expr><name>session</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>peg_revision</name></expr></argument>, <argument><expr>&amp;<name>kind</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>kind</name> == <name>svn_node_none</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_FS_NOT_FOUND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Path '%s' doesn't exist in revision %ld"</expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><name>rel_path</name></expr></argument>, <argument><expr><name>start_rev</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Populate most of our log receiver baton structure. */</comment>
  <expr_stmt><expr><name><name>lrb</name>.<name>kind</name></name> = <name>kind</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>lrb</name>.<name>last_path</name></name> = <name>rel_path</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>lrb</name>.<name>done</name></name> = <name>FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>lrb</name>.<name>start_rev</name></name> = <name>start_rev</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>lrb</name>.<name>range_end</name></name> = <name>start_rev</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>lrb</name>.<name>receiver</name></name> = <name>receiver</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>lrb</name>.<name>receiver_baton</name></name> = <name>receiver_baton</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>lrb</name>.<name>pool</name></name> = <name>pool</name></expr>;</expr_stmt>

  <comment type="block">/* Let the RA layer drive our log information handler, which will do
     the work of finding the actual locations for our resource.
     Notice that we always run on the youngest rev of the 3 inputs. */</comment>
  <expr_stmt><expr><name>targets</name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>const <name>char</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>targets</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call> = <name>path</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_get_log2</name><argument_list>(<argument><expr><name>session</name></expr></argument>, <argument><expr><name>targets</name></expr></argument>, <argument><expr><name>peg_revision</name></expr></argument>, <argument><expr><name>end_rev</name></expr></argument>, <argument><expr>0</expr></argument>,
                          <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                          <argument><expr><call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>const <name>char</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>,
                          <argument><expr><name>gls_log_receiver</name></expr></argument>, <argument><expr>&amp;<name>lrb</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If we didn't finish, we need to do so with a final segment send. */</comment>
  <if>if <condition>(<expr>! <name><name>lrb</name>.<name>done</name></name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>maybe_crop_and_send_segment</name><argument_list>(<argument><expr><name><name>lrb</name>.<name>last_path</name></name></expr></argument>, <argument><expr><name>start_rev</name></expr></argument>,
                                        <argument><expr><name>end_rev</name></expr></argument>, <argument><expr><name><name>lrb</name>.<name>range_end</name></name></expr></argument>,
                                        <argument><expr><name>receiver</name></expr></argument>, <argument><expr><name>receiver_baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<escape char="0xc"/>
<comment type="block">/*** Fallback implementation of svn_ra_get_file_revs(). ***/</comment>

<comment type="block">/* The metadata associated with a particular revision. */</comment>
<struct>struct <name>rev</name>
<block>{
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>revision</name></decl>;</decl_stmt> <comment type="block">/* the revision number */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>      <comment type="block">/* the absolute repository path */</comment>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>props</name></decl>;</decl_stmt>     <comment type="block">/* the revprops for this revision */</comment>
  <decl_stmt><decl><type>struct <name>rev</name> *</type><name>next</name></decl>;</decl_stmt>      <comment type="block">/* the next revision */</comment>
}</block>;</struct>

<comment type="block">/* File revs log message baton. */</comment>
<struct>struct <name>fr_log_message_baton</name> <block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>        <comment type="block">/* The path to be processed */</comment>
  <decl_stmt><decl><type>struct <name>rev</name> *</type><name>eldest</name></decl>;</decl_stmt>      <comment type="block">/* The eldest revision processed */</comment>
  <decl_stmt><decl><type><name>char</name></type> <name>action</name></decl>;</decl_stmt>             <comment type="block">/* The action associated with the eldest */</comment>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>copyrev</name></decl>;</decl_stmt>    <comment type="block">/* The revision the eldest was copied from */</comment>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/* Callback for log messages: implements svn_log_entry_receiver_t and
   accumulates revision metadata into a chronologically ordered list stored in
   the baton. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>fr_log_message_receiver</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>,
                        <param><decl><type><name>svn_log_entry_t</name> *</type><name>log_entry</name></decl></param>,
                        <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>fr_log_message_baton</name> *</type><name>lmb</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>rev</name> *</type><name>rev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>rev</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>lmb</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>rev</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>rev</name>-&gt;<name>revision</name></name> = <name><name>log_entry</name>-&gt;<name>revision</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>rev</name>-&gt;<name>path</name></name> = <name><name>lmb</name>-&gt;<name>path</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>rev</name>-&gt;<name>next</name></name> = <name><name>lmb</name>-&gt;<name>eldest</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>lmb</name>-&gt;<name>eldest</name></name> = <name>rev</name></expr>;</expr_stmt>

  <comment type="block">/* Duplicate log_entry revprops into rev-&gt;props */</comment>
  <expr_stmt><expr><name><name>rev</name>-&gt;<name>props</name></name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name><name>lmb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>log_entry</name>-&gt;<name>revprops</name></name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>hi</name></expr>;</condition>
       <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
    <block>{
      <decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name><name>rev</name>-&gt;<name>props</name></name></expr></argument>, <argument><expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>lmb</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>,
                   <argument><expr><call><name>svn_string_dup</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name><name>lmb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

  <return>return <expr><call><name>prev_log_path</name><argument_list>(<argument><expr>&amp;<name><name>lmb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr>&amp;<name><name>lmb</name>-&gt;<name>action</name></name></expr></argument>,
                       <argument><expr>&amp;<name><name>lmb</name>-&gt;<name>copyrev</name></name></expr></argument>, <argument><expr><name><name>log_entry</name>-&gt;<name>changed_paths</name></name></expr></argument>,
                       <argument><expr><name><name>lmb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>svn_node_file</name></expr></argument>, <argument><expr><name><name>log_entry</name>-&gt;<name>revision</name></name></expr></argument>,
                       <argument><expr><name><name>lmb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_ra__file_revs_from_log</name><parameter_list>(<param><decl><type><name>svn_ra_session_t</name> *</type><name>ra_session</name></decl></param>,
                           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                           <param><decl><type><name>svn_revnum_t</name></type> <name>start</name></decl></param>,
                           <param><decl><type><name>svn_revnum_t</name></type> <name>end</name></decl></param>,
                           <param><decl><type><name>svn_file_rev_handler_t</name></type> <name>handler</name></decl></param>,
                           <param><decl><type><name>void</name> *</type><name>handler_baton</name></decl></param>,
                           <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>repos_url</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>session_url</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>tmp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>repos_abs_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>condensed_targets</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>fr_log_message_baton</name></type> <name>lmb</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>rev</name> *</type><name>rev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>last_props</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>last_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>last_stream</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>currpool</name></decl>, *<decl><type ref="prev"/><name>lastpool</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_get_repos_root2</name><argument_list>(<argument><expr><name>ra_session</name></expr></argument>, <argument><expr>&amp;<name>repos_url</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_get_session_url</name><argument_list>(<argument><expr><name>ra_session</name></expr></argument>, <argument><expr>&amp;<name>session_url</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Create the initial path, using the repos_url and session_url */</comment>
  <expr_stmt><expr><name>tmp</name> = <call><name>svn_path_is_child</name><argument_list>(<argument><expr><name>repos_url</name></expr></argument>, <argument><expr><name>session_url</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>repos_abs_path</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>repos_abs_path</name><index>[<expr>0</expr>]</index></name> = '/'</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>repos_abs_path</name> + 1</expr></argument>, <argument><expr><name>tmp</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check to make sure we're dealing with a file. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_check_path</name><argument_list>(<argument><expr><name>ra_session</name></expr></argument>, <argument><expr>""</expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr>&amp;<name>kind</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>kind</name> == <name>svn_node_dir</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_FS_NOT_FILE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><call><name>_</name><argument_list>(<argument><expr>"'%s' is not a file"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>repos_abs_path</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><name>condensed_targets</name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>const <name>char</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>condensed_targets</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call> = ""</expr>;</expr_stmt>

  <expr_stmt><expr><name><name>lmb</name>.<name>path</name></name> = <call><name>svn_path_uri_decode</name><argument_list>(<argument><expr><name>repos_abs_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>lmb</name>.<name>eldest</name></name> = <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>lmb</name>.<name>pool</name></name> = <name>pool</name></expr>;</expr_stmt>

  <comment type="block">/* Accumulate revision metadata by walking the revisions
     backwards; this allows us to follow moves/copies
     correctly. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_get_log2</name><argument_list>(<argument><expr><name>ra_session</name></expr></argument>,
                          <argument><expr><name>condensed_targets</name></expr></argument>,
                          <argument><expr><name>end</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr>0</expr></argument>, <comment type="block">/* no limit */</comment>
                          <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                          <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>fr_log_message_receiver</name></expr></argument>, <argument><expr>&amp;<name>lmb</name></expr></argument>,
                          <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Reparent the session while we go back through the history. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_reparent</name><argument_list>(<argument><expr><name>ra_session</name></expr></argument>, <argument><expr><name>repos_url</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>currpool</name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>lastpool</name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* We want the first txdelta to be against the empty file. */</comment>
  <expr_stmt><expr><name>last_props</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>lastpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>last_path</name> = <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>last_stream</name> = <call><name>svn_stream_empty</name><argument_list>(<argument><expr><name>lastpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Walk the revision list in chronological order, downloading each fulltext,
     diffing it with its predecessor, and calling the file_revs handler for
     each one.  Use two iteration pools rather than one, because the diff
     routines need to look at a sliding window of revisions.  Two pools gives
     us a ring buffer of sorts. */</comment>
  <for>for (<init><expr><name>rev</name> = <name><name>lmb</name>.<name>eldest</name></name></expr>;</init> <condition><expr><name>rev</name></expr>;</condition> <incr><expr><name>rev</name> = <name><name>rev</name>-&gt;<name>next</name></name></expr></incr>)
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>temp_path</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>temp_dir</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>tmppool</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>props</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>file</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>stream</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>prop_diffs</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_txdelta_stream_t</name> *</type><name>delta_stream</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_txdelta_window_handler_t</name></type> <name>delta_handler</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>void</name> *</type><name>delta_baton</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>currpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Get the contents of the file from the repository, and put them in
         a temporary local file. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_temp_dir</name><argument_list>(<argument><expr>&amp;<name>temp_dir</name></expr></argument>, <argument><expr><name>currpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_open_unique_file2</name>
              <argument_list>(<argument><expr>&amp;<name>file</name></expr></argument>, <argument><expr>&amp;<name>temp_path</name></expr></argument>,
               <argument><expr><call><name>svn_path_join</name><argument_list>(<argument><expr><name>temp_dir</name></expr></argument>, <argument><expr>"tmp"</expr></argument>, <argument><expr><name>currpool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>".tmp"</expr></argument>,
               <argument><expr><name>svn_io_file_del_on_pool_cleanup</name></expr></argument>, <argument><expr><name>currpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>stream</name> = <call><name>svn_stream_from_aprfile</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>currpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ra_get_file</name><argument_list>(<argument><expr><name>ra_session</name></expr></argument>, <argument><expr><name><name>rev</name>-&gt;<name>path</name></name> + 1</expr></argument>, <argument><expr><name><name>rev</name>-&gt;<name>revision</name></name></expr></argument>,
                              <argument><expr><name>stream</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>props</name></expr></argument>, <argument><expr><name>currpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_close</name><argument_list>(<argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_close</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>currpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Open up a stream to the local file. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_open</name><argument_list>(<argument><expr>&amp;<name>file</name></expr></argument>, <argument><expr><name>temp_path</name></expr></argument>, <argument><expr><name>APR_READ</name></expr></argument>, <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>,
                               <argument><expr><name>currpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>stream</name> = <call><name>svn_stream_from_aprfile2</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>currpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Calculate the property diff */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_prop_diffs</name><argument_list>(<argument><expr>&amp;<name>prop_diffs</name></expr></argument>, <argument><expr><name>props</name></expr></argument>, <argument><expr><name>last_props</name></expr></argument>, <argument><expr><name>lastpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Call the file_rev handler */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>handler</name><argument_list>(<argument><expr><name>handler_baton</name></expr></argument>, <argument><expr><name><name>rev</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name><name>rev</name>-&gt;<name>revision</name></name></expr></argument>, <argument><expr><name><name>rev</name>-&gt;<name>props</name></name></expr></argument>,
                      <argument><expr><name>FALSE</name></expr></argument>, <comment type="block">/* merged revision */</comment>
                      <argument><expr>&amp;<name>delta_handler</name></expr></argument>, <argument><expr>&amp;<name>delta_baton</name></expr></argument>, <argument><expr><name>prop_diffs</name></expr></argument>, <argument><expr><name>lastpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Compute and send delta if client asked for it. */</comment>
      <if>if <condition>(<expr><name>delta_handler</name></expr>)</condition><then>
        <block>{
          <comment type="block">/* Get the content delta. */</comment>
          <expr_stmt><expr><call><name>svn_txdelta</name><argument_list>(<argument><expr>&amp;<name>delta_stream</name></expr></argument>, <argument><expr><name>last_stream</name></expr></argument>, <argument><expr><name>stream</name></expr></argument>, <argument><expr><name>lastpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* And send. */</comment>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_txdelta_send_txstream</name><argument_list>(<argument><expr><name>delta_stream</name></expr></argument>, <argument><expr><name>delta_handler</name></expr></argument>,
                                            <argument><expr><name>delta_baton</name></expr></argument>, <argument><expr><name>lastpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

      <comment type="block">/* Switch the pools and data for the next iteration */</comment>
      <expr_stmt><expr><name>tmppool</name> = <name>currpool</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>currpool</name> = <name>lastpool</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>lastpool</name> = <name>tmppool</name></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>svn_stream_close</name><argument_list>(<argument><expr><name>last_stream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>last_stream</name> = <name>stream</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>last_props</name> = <name>props</name></expr>;</expr_stmt>
    }</block></for>

  <expr_stmt><expr><call><name>svn_stream_close</name><argument_list>(<argument><expr><name>last_stream</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>currpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>lastpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Reparent the session back to the original URL. */</comment>
  <return>return <expr><call><name>svn_ra_reparent</name><argument_list>(<argument><expr><name>ra_session</name></expr></argument>, <argument><expr><name>session_url</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
</unit>
