<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/subversion-1.5.1/source/subversion/libsvn_ra_local/split_url.c"><comment type="block">/*
 * checkout.c : read a repository and drive a checkout editor.
 *
 * ====================================================================
 * Copyright (c) 2000-2004 CollabNet.  All rights reserved.
 *
 * This software is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at http://subversion.tigris.org/license-1.html.
 * If newer versions of this license are posted there, you may use a
 * newer version instead, at your option.
 *
 * This software consists of voluntary contributions made by many
 * individuals.  For exact contribution history, see the revision
 * history and logs, available at http://subversion.tigris.org/.
 * ====================================================================
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"ra_local.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_path.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_private_config.h"</cpp:file></cpp:include>


<function><type><name>svn_error_t</name> *</type>
<name>svn_ra_local__split_URL</name><parameter_list>(<param><decl><type><name>svn_repos_t</name> **</type><name>repos</name></decl></param>,
                        <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>repos_url</name></decl></param>,
                        <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>fs_path</name></decl></param>,
                        <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>URL</name></decl></param>,
                        <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name> <init>= <expr><name>SVN_NO_ERROR</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>repos_root</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>hostname</name></decl>, *<decl><type ref="prev"/><name>path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>urlbuf</name></decl>;</decl_stmt>

  <comment type="block">/* Verify that the URL is well-formed (loosely) */</comment>

  <comment type="block">/* First, check for the "file://" prefix. */</comment>
  <if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>URL</name></expr></argument>, <argument><expr>"file://"</expr></argument>, <argument><expr>7</expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name>
      <argument_list>(<argument><expr><name>SVN_ERR_RA_ILLEGAL_URL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Local URL '%s' does not contain 'file://' prefix"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>URL</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Then, skip what's between the "file://" prefix and the next
     occurance of '/' -- this is the hostname, and we are considering
     everything from that '/' until the end of the URL to be the
     absolute path portion of the URL. */</comment>
  <expr_stmt><expr><name>hostname</name> = <name>URL</name> + 7</expr>;</expr_stmt>
  <expr_stmt><expr><name>path</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>hostname</name></expr></argument>, <argument><expr>'/'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>! <name>path</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name>
      <argument_list>(<argument><expr><name>SVN_ERR_RA_ILLEGAL_URL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Local URL '%s' contains only a hostname, no path"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>URL</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Treat localhost as an empty hostname. */</comment>
  <if>if <condition>(<expr><name>hostname</name> != <name>path</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>hostname</name> = <call><name>svn_path_uri_decode</name><argument_list>(<argument><expr><call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>hostname</name></expr></argument>,
                                                    <argument><expr><name>path</name> - <name>hostname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>hostname</name></expr></argument>, <argument><expr>"localhost"</expr></argument>, <argument><expr>9</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
        <expr_stmt><expr><name>hostname</name> = <name>NULL</name></expr>;</expr_stmt></then></if>
    }</block></then>
  <else>else
    <expr_stmt><expr><name>hostname</name> = <name>NULL</name></expr>;</expr_stmt></else></if>

  <comment type="block">/* Duplicate the URL, starting at the top of the path.
     At the same time, we URI-decode the path. */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <comment type="block">/* On Windows, we'll typically have to skip the leading / if the
     path starts with a drive letter.  Like most Web browsers, We
     support two variants of this scheme:

         file:///X:/path    and
         file:///X|/path

    Note that, at least on WinNT and above,  file:////./X:/path  will
    also work, so we must make sure the transformation doesn't break
    that, and  file:///path  (that looks within the current drive
    only) should also keep working.
    If we got a non-empty hostname other than localhost, we convert this
    into an UNC path.  In this case, we obviously don't strip the slash
    even if the path looks like it starts with a drive letter.
    Another thing to remember is that the form file:///\machine/share
    was the only way to access UNC paths in svn before 1.2.  We
    need to support that for compatibility with old working copies.
  */</comment>
  <block>{
    <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>valid_drive_letters</name><index>[]</index></name> <init>=
      <expr>"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"</expr></init></decl>;</decl_stmt>
    <comment type="block">/* Casting away const! */</comment>
    <decl_stmt><decl><type><name>char</name> *</type><name>dup_path</name> <init>= <expr>(<name>char</name> *)<call><name>svn_path_uri_decode</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <if>if <condition>(<expr>!<name>hostname</name> &amp;&amp; <name><name>dup_path</name><index>[<expr>1</expr>]</index></name> &amp;&amp; <call><name>strchr</name><argument_list>(<argument><expr><name>valid_drive_letters</name></expr></argument>, <argument><expr><name><name>dup_path</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call>
        &amp;&amp; (<name><name>dup_path</name><index>[<expr>2</expr>]</index></name> == ':' || <name><name>dup_path</name><index>[<expr>2</expr>]</index></name> == '|')
        &amp;&amp; <name><name>dup_path</name><index>[<expr>3</expr>]</index></name> == '/'</expr>)</condition><then>
      <block>{
        <comment type="block">/* Skip the leading slash. */</comment>
        <expr_stmt><expr>++<name>dup_path</name></expr>;</expr_stmt>
        <comment type="block">/* We're using path below to calculate fs_path, so keep it in sync. */</comment>
        <expr_stmt><expr>++<name>path</name></expr>;</expr_stmt>
        <if>if <condition>(<expr><name><name>dup_path</name><index>[<expr>1</expr>]</index></name> == '|'</expr>)</condition><then>
          <expr_stmt><expr><name><name>dup_path</name><index>[<expr>1</expr>]</index></name> = ':'</expr>;</expr_stmt></then></if>
      }</block></then></if>
    <if>if <condition>(<expr><name>hostname</name></expr>)</condition><then>
      <comment type="block">/* We still know that the path starts with a slash. */</comment>
      <expr_stmt><expr><name>repos_root</name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"//"</expr></argument>, <argument><expr><name>hostname</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
    <else>else
      <expr_stmt><expr><name>repos_root</name> = <name>dup_path</name></expr>;</expr_stmt></else></if>
  }</block>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
  <comment type="block">/* Currently, the only hostnames we are allowing on non-Win32 platforms
     are the empty string and 'localhost'. */</comment>
  <if>if <condition>(<expr><name>hostname</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name>
      <argument_list>(<argument><expr><name>SVN_ERR_RA_ILLEGAL_URL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Local URL '%s' contains unsupported hostname"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>URL</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><name>repos_root</name> = <call><name>svn_path_uri_decode</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <comment type="block">/* Search for a repository in the full path. */</comment>
  <expr_stmt><expr><name>repos_root</name> = <call><name>svn_repos_find_root_path</name><argument_list>(<argument><expr><name>repos_root</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<name>repos_root</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name>
      <argument_list>(<argument><expr><name>SVN_ERR_RA_LOCAL_REPOS_OPEN_FAILED</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Unable to open repository '%s'"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>URL</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Attempt to open a repository at URL. */</comment>
  <expr_stmt><expr><name>err</name> = <call><name>svn_repos_open</name><argument_list>(<argument><expr><name>repos</name></expr></argument>, <argument><expr><name>repos_root</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name>
      <argument_list>(<argument><expr><name>SVN_ERR_RA_LOCAL_REPOS_OPEN_FAILED</name></expr></argument>, <argument><expr><name>err</name></expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Unable to open repository '%s'"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>URL</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Assert capabilities directly, since client == server. */</comment>
  <block>{
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>caps</name> <init>= <expr><call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>const <name>char</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>caps</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call> = <name>SVN_RA_CAPABILITY_MERGEINFO</name></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_repos_remember_client_capabilities</name><argument_list>(<argument><expr>*<name>repos</name></expr></argument>, <argument><expr><name>caps</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block>

  <comment type="block">/* What remains of URL after being hacked at in the previous step is
     REPOS_URL.  FS_PATH is what we've hacked off in the process.
     Note that path is not encoded and what we gave to svn_root_find_root_path
     may have been destroyed by that function.  So we have to decode it once
     more.  But then, it is ours...
     We want the suffix of path after the repos root part.  Note that
     repos_root may contain //hostname, but path doesn't.  */</comment>
  <expr_stmt><expr>*<name>fs_path</name> = <call><name>svn_path_uri_decode</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call>
    + (<call><name>strlen</name><argument_list>(<argument><expr><name>repos_root</name></expr></argument>)</argument_list></call>
       - (<name>hostname</name> ? <call><name>strlen</name><argument_list>(<argument><expr><name>hostname</name></expr></argument>)</argument_list></call> + 2 : 0))</expr>;</expr_stmt>

  <comment type="block">/* Ensure that *FS_PATH has its leading slash. */</comment>
  <if>if <condition>(<expr>**<name>fs_path</name> != '/'</expr>)</condition><then>
    <expr_stmt><expr>*<name>fs_path</name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"/"</expr></argument>, <argument><expr>*<name>fs_path</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  
  <comment type="block">/* Remove the path components in *fs_path from the original URL, to get
     the URL to the repository root. */</comment>
  <expr_stmt><expr><name>urlbuf</name> = <call><name>svn_stringbuf_create</name><argument_list>(<argument><expr><name>URL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_path_remove_components</name><argument_list>(<argument><expr><name>urlbuf</name></expr></argument>,
                             <argument><expr><call><name>svn_path_component_count</name><argument_list>(<argument><expr>*<name>fs_path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>repos_url</name> = <name><name>urlbuf</name>-&gt;<name>data</name></name></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
</unit>
