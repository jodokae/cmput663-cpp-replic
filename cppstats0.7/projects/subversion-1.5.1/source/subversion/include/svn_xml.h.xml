<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/subversion-1.5.1/source/subversion/include/svn_xml.h"><comment type="block">/**
 * @copyright
 * ====================================================================
 * Copyright (c) 2000-2006 CollabNet.  All rights reserved.
 *
 * This software is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at http://subversion.tigris.org/license-1.html.
 * If newer versions of this license are posted there, you may use a
 * newer version instead, at your option.
 *
 * This software consists of voluntary contributions made by many
 * individuals.  For exact contribution history, see the revision
 * history and logs, available at http://subversion.tigris.org/.
 * ====================================================================
 * @endcopyright
 *
 * @file svn_xml.h
 * @brief XML code shared by various Subversion libraries.
 */</comment>


<escape char="0xc"/>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SVN_XML_H</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_XML_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_pools.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_hash.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_error.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_string.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
<extern>extern "C" <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* __cplusplus */</comment>

<comment type="block">/** The namespace all Subversion XML uses. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_XML_NAMESPACE</name></cpp:macro> <cpp:value>"svn:"</cpp:value></cpp:define>

<comment type="block">/** Used as style argument to svn_xml_make_open_tag() and friends. */</comment>
<enum>enum <name>svn_xml_open_tag_style</name> <block>{
  <comment type="block">/** &lt;tag ...&gt; */</comment>
  <decl><name>svn_xml_normal</name> <init>= <expr>1</expr></init></decl>,

  <comment type="block">/** &lt;tag ...&gt;, no cosmetic newline */</comment>
  <decl><name>svn_xml_protect_pcdata</name></decl>,

  <comment type="block">/** &lt;tag .../&gt;  */</comment>
  <decl><name>svn_xml_self_closing</name></decl>
}</block>;</enum>

<escape char="0xc"/>

<comment type="block">/** Determine if a string of character @a data of length @a len is a
 * safe bet for use with the svn_xml_escape_* functions found in this
 * header.
 *
 * Return @c TRUE if it is, @c FALSE otherwise.
 *
 * Essentially, this function exists to determine whether or not
 * simply running a string of bytes through the Subversion XML escape
 * routines will produce legitimate XML.  It should only be necessary
 * for data which might contain bytes that cannot be safely encoded
 * into XML (certain control characters, for example).
 */</comment>
<function_decl><type><name>svn_boolean_t</name></type> <name>svn_xml_is_xml_safe</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name></decl></param>,
                                  <param><decl><type><name>apr_size_t</name></type> <name>len</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/** Create or append in @a *outstr an xml-escaped version of @a string,
 * suitable for output as character data.
 *
 * If @a *outstr is @c NULL, store a new stringbuf, else append to the
 * existing stringbuf there.
 */</comment>
<function_decl><type><name>void</name></type> <name>svn_xml_escape_cdata_stringbuf</name><parameter_list>(<param><decl><type><name>svn_stringbuf_t</name> **</type><name>outstr</name></decl></param>,
                                    <param><decl><type><specifier>const</specifier> <name>svn_stringbuf_t</name> *</type><name>string</name></decl></param>,
                                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/** Same as svn_xml_escape_cdata_stringbuf(), but @a string is an
 * @c svn_string_t.
 */</comment>
<function_decl><type><name>void</name></type> <name>svn_xml_escape_cdata_string</name><parameter_list>(<param><decl><type><name>svn_stringbuf_t</name> **</type><name>outstr</name></decl></param>,
                                 <param><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>string</name></decl></param>,
                                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/** Same as svn_xml_escape_cdata_stringbuf(), but @a string is a
 * NULL-terminated C string.
 */</comment>
<function_decl><type><name>void</name></type> <name>svn_xml_escape_cdata_cstring</name><parameter_list>(<param><decl><type><name>svn_stringbuf_t</name> **</type><name>outstr</name></decl></param>,
                                  <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>string</name></decl></param>,
                                  <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>


<comment type="block">/** Create or append in @a *outstr an xml-escaped version of @a string,
 * suitable for output as an attribute value.
 *
 * If @a *outstr is @c NULL, store a new stringbuf, else append to the
 * existing stringbuf there.
 */</comment>
<function_decl><type><name>void</name></type> <name>svn_xml_escape_attr_stringbuf</name><parameter_list>(<param><decl><type><name>svn_stringbuf_t</name> **</type><name>outstr</name></decl></param>,
                                   <param><decl><type><specifier>const</specifier> <name>svn_stringbuf_t</name> *</type><name>string</name></decl></param>,
                                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/** Same as svn_xml_escape_attr_stringbuf(), but @a string is an
 * @c svn_string_t.
 */</comment>
<function_decl><type><name>void</name></type> <name>svn_xml_escape_attr_string</name><parameter_list>(<param><decl><type><name>svn_stringbuf_t</name> **</type><name>outstr</name></decl></param>,
                                <param><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>string</name></decl></param>,
                                <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/** Same as svn_xml_escape_attr_stringbuf(), but @a string is a
 * NULL-terminated C string.
 */</comment>
<function_decl><type><name>void</name></type> <name>svn_xml_escape_attr_cstring</name><parameter_list>(<param><decl><type><name>svn_stringbuf_t</name> **</type><name>outstr</name></decl></param>,
                                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>string</name></decl></param>,
                                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Return UTF-8 string @a string if it contains no characters that are
 * unrepresentable in XML.  Else, return a copy of @a string,
 * allocated in @a pool, with each unrepresentable character replaced
 * by "?\uuu", where "uuu" is the three-digit unsigned decimal value
 * of that character.
 *
 * Neither the input nor the output need be valid XML; however, the
 * output can always be safely XML-escaped.
 *
 * @note The current implementation treats all Unicode characters as
 * representable, except for most ASCII control characters (the
 * exceptions being CR, LF, and TAB, which are valid in XML).  There
 * may be other UTF-8 characters that are invalid in XML; see
 * http://subversion.tigris.org/servlets/ReadMsg?list=dev&amp;msgNo=90591
 * and its thread for details.
 *
 * @since New in 1.2.
 */</comment>
<function_decl><type><specifier>const</specifier> <name>char</name> *</type><name>svn_xml_fuzzy_escape</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>string</name></decl></param>,
                                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>


<comment type="block">/*---------------------------------------------------------------*/</comment>
<escape char="0xc"/>
<comment type="block">/* Generalized Subversion XML Parsing */</comment>

<comment type="block">/** A generalized Subversion XML parser object */</comment>
<typedef>typedef <type>struct <name>svn_xml_parser_t</name></type> <name>svn_xml_parser_t</name>;</typedef>

<typedef>typedef <function_decl><type><name>void</name></type> (*<name>svn_xml_start_elem</name>)<parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>,
                                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>,
                                   <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>atts</name></decl></param>)</parameter_list>;</function_decl></typedef>

<typedef>typedef <function_decl><type><name>void</name></type> (*<name>svn_xml_end_elem</name>)<parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>)</parameter_list>;</function_decl></typedef>

<comment type="block">/* data is not NULL-terminated. */</comment>
<typedef>typedef <function_decl><type><name>void</name></type> (*<name>svn_xml_char_data</name>)<parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>,
                                  <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name></decl></param>,
                                  <param><decl><type><name>apr_size_t</name></type> <name>len</name></decl></param>)</parameter_list>;</function_decl></typedef>


<comment type="block">/** Create a general Subversion XML parser */</comment>
<function_decl><type><name>svn_xml_parser_t</name> *</type><name>svn_xml_make_parser</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>,
                                      <param><decl><type><name>svn_xml_start_elem</name></type> <name>start_handler</name></decl></param>,
                                      <param><decl><type><name>svn_xml_end_elem</name></type> <name>end_handler</name></decl></param>,
                                      <param><decl><type><name>svn_xml_char_data</name></type> <name>data_handler</name></decl></param>,
                                      <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>


<comment type="block">/** Free a general Subversion XML parser */</comment>
<function_decl><type><name>void</name></type> <name>svn_xml_free_parser</name><parameter_list>(<param><decl><type><name>svn_xml_parser_t</name> *</type><name>svn_parser</name></decl></param>)</parameter_list>;</function_decl>


<comment type="block">/** Push @a len bytes of xml data in @a buf at @a svn_parser.
 *
 * If this is the final push, @a is_final must be set.
 *
 * An error will be returned if there was a syntax problem in the XML,
 * or if any of the callbacks set an error using
 * svn_xml_signal_bailout().
 *
 * If an error is returned, the @c svn_xml_parser_t will have been freed
 * automatically, so the caller should not call svn_xml_free_parser().
 */</comment>
<function_decl><type><name>svn_error_t</name> *</type><name>svn_xml_parse</name><parameter_list>(<param><decl><type><name>svn_xml_parser_t</name> *</type><name>svn_parser</name></decl></param>,
                           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>buf</name></decl></param>,
                           <param><decl><type><name>apr_size_t</name></type> <name>len</name></decl></param>,
                           <param><decl><type><name>svn_boolean_t</name></type> <name>is_final</name></decl></param>)</parameter_list>;</function_decl>



<comment type="block">/** The way to officially bail out of xml parsing.
 *
 * Store @a error in @a svn_parser and set all expat callbacks to @c NULL.
 */</comment>
<function_decl><type><name>void</name></type> <name>svn_xml_signal_bailout</name><parameter_list>(<param><decl><type><name>svn_error_t</name> *</type><name>error</name></decl></param>,
                            <param><decl><type><name>svn_xml_parser_t</name> *</type><name>svn_parser</name></decl></param>)</parameter_list>;</function_decl>




<escape char="0xc"/>
<comment type="block">/*** Helpers for dealing with the data Expat gives us. ***/</comment>

<comment type="block">/** Return the value associated with @a name in expat attribute array @a atts,
 * else return @c NULL.
 *
 * (There could never be a @c NULL attribute value in the XML,
 * although the empty string is possible.)
 *
 * @a atts is an array of c-strings: even-numbered indexes are names,
 * odd-numbers hold values.  If all is right, it should end on an
 * even-numbered index pointing to @c NULL.
 */</comment>
<function_decl><type><specifier>const</specifier> <name>char</name> *</type><name>svn_xml_get_attr_value</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>atts</name></decl></param>)</parameter_list>;</function_decl>


<escape char="0xc"/>
<comment type="block">/* Converting between Expat attribute lists and APR hash tables. */</comment>


<comment type="block">/** Create an attribute hash from @c va_list @a ap.
 *
 * The contents of @a ap are alternating &lt;tt&gt;char *&lt;/tt&gt; keys and
 * &lt;tt&gt;char *&lt;/tt&gt; vals, terminated by a final @c NULL falling on an
 * even index (zero-based).
 */</comment>
<function_decl><type><name>apr_hash_t</name> *</type><name>svn_xml_ap_to_hash</name><parameter_list>(<param><decl><type><name>va_list</name></type> <name>ap</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/** Create a hash that corresponds to Expat xml attribute list @a atts.
 *
 * The hash's keys and values are &lt;tt&gt;char *&lt;/tt&gt;'s.
 *
 * @a atts may be NULL, in which case you just get an empty hash back
 * (this makes life more convenient for some callers).
 */</comment>
<function_decl><type><name>apr_hash_t</name> *</type><name>svn_xml_make_att_hash</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>atts</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>


<comment type="block">/** Like svn_xml_make_att_hash(), but takes a hash and preserves any
 * key/value pairs already in it.
 */</comment>
<function_decl><type><name>void</name></type> <name>svn_xml_hash_atts_preserving</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>atts</name></decl></param>,
                                  <param><decl><type><name>apr_hash_t</name> *</type><name>ht</name></decl></param>,
                                  <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/** Like svn_xml_make_att_hash(), but takes a hash and overwrites
 * key/value pairs already in it that also appear in @a atts.
 */</comment>
<function_decl><type><name>void</name></type> <name>svn_xml_hash_atts_overlaying</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>atts</name></decl></param>,
                                  <param><decl><type><name>apr_hash_t</name> *</type><name>ht</name></decl></param>,
                                  <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>


<escape char="0xc"/>
<comment type="block">/* Printing XML */</comment>

<comment type="block">/** Create an XML header and return it in @a *str.
 *
 * Fully-formed XML documents should start out with a header,
 * something like
 *         \&lt;?xml version="1.0" encoding="utf-8"?\&gt;
 *
 * This function returns such a header.  @a *str must either be @c NULL, in
 * which case a new string is created, or it must point to an existing
 * string to be appended to.
 */</comment>
<function_decl><type><name>void</name></type> <name>svn_xml_make_header</name><parameter_list>(<param><decl><type><name>svn_stringbuf_t</name> **</type><name>str</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>


<comment type="block">/** Store a new xml tag @a tagname in @a *str.
 *
 * If @a str is @c NULL, allocate @a *str in @a pool; else append the new
 * tag to @a *str, allocating in @a str's pool
 *
 * Take the tag's attributes from varargs, a NULL-terminated list of
 * alternating &lt;tt&gt;char *&lt;/tt&gt; key and &lt;tt&gt;char *&lt;/tt&gt; val.  Do xml-escaping
 * on each val.
 *
 * @a style is one of the enumerated styles in @c svn_xml_open_tag_style.
 */</comment>
<decl_stmt><decl><type><name>void</name></type> <name>svn_xml_make_open_tag</name><argument_list>(<argument><expr><name>svn_stringbuf_t</name> **<name>str</name></expr></argument>,
                           <argument><expr><name>apr_pool_t</name> *<name>pool</name></expr></argument>,
                           <argument>enum <expr><name>svn_xml_open_tag_style</name> <name>style</name></expr></argument>,
                           <argument><expr>const <name>char</name> *<name>tagname</name></expr></argument>,
                           <argument>...<expr/></argument>)</argument_list></decl>;</decl_stmt>


<comment type="block">/** Like svn_xml_make_open_tag(), but takes a @c va_list instead of being
 * variadic.
 */</comment>
<decl_stmt><decl><type><name>void</name></type> <name>svn_xml_make_open_tag_v</name><argument_list>(<argument><expr><name>svn_stringbuf_t</name> **<name>str</name></expr></argument>,
                             <argument><expr><name>apr_pool_t</name> *<name>pool</name></expr></argument>,
                             <argument>enum <expr><name>svn_xml_open_tag_style</name> <name>style</name></expr></argument>,
                             <argument><expr>const <name>char</name> *<name>tagname</name></expr></argument>,
                             <argument><expr><name>va_list</name> <name>ap</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<comment type="block">/** Like svn_xml_make_open_tag(), but takes a hash table of attributes
 * (&lt;tt&gt;char *&lt;/tt&gt; keys mapping to &lt;tt&gt;char *&lt;/tt&gt; values).
 *
 * You might ask, why not just provide svn_xml_make_tag_atts()?
 *
 * The reason is that a hash table is the most natural interface to an
 * attribute list; the fact that Expat uses &lt;tt&gt;char **&lt;/tt&gt; atts instead is
 * certainly a defensible implementation decision, but since we'd have
 * to have special code to support such lists throughout Subversion
 * anyway, we might as well write that code for the natural interface
 * (hashes) and then convert in the few cases where conversion is
 * needed.  Someday it might even be nice to change expat-lite to work
 * with apr hashes.
 *
 * See conversion functions svn_xml_make_att_hash() and
 * svn_xml_make_att_hash_overlaying().  Callers should use those to
 * convert Expat attr lists into hashes when necessary.
 */</comment>
<decl_stmt><decl><type><name>void</name></type> <name>svn_xml_make_open_tag_hash</name><argument_list>(<argument><expr><name>svn_stringbuf_t</name> **<name>str</name></expr></argument>,
                                <argument><expr><name>apr_pool_t</name> *<name>pool</name></expr></argument>,
                                <argument>enum <expr><name>svn_xml_open_tag_style</name> <name>style</name></expr></argument>,
                                <argument><expr>const <name>char</name> *<name>tagname</name></expr></argument>,
                                <argument><expr><name>apr_hash_t</name> *<name>attributes</name></expr></argument>)</argument_list></decl>;</decl_stmt>


<comment type="block">/** Makes a close tag. */</comment>
<function_decl><type><name>void</name></type> <name>svn_xml_make_close_tag</name><parameter_list>(<param><decl><type><name>svn_stringbuf_t</name> **</type><name>str</name></decl></param>,
                            <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                            <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>tagname</name></decl></param>)</parameter_list>;</function_decl>



<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
}</block></extern>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* __cplusplus */</comment>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SVN_XML_H */</comment>
</unit>
