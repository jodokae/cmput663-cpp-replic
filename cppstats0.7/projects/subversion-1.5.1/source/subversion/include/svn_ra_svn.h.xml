<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/subversion-1.5.1/source/subversion/include/svn_ra_svn.h"><comment type="block">/**
 * @copyright
 * ====================================================================
 * Copyright (c) 2000-2006 CollabNet.  All rights reserved.
 *
 * This software is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at http://subversion.tigris.org/license-1.html.
 * If newer versions of this license are posted there, you may use a
 * newer version instead, at your option.
 *
 * This software consists of voluntary contributions made by many
 * individuals.  For exact contribution history, see the revision
 * history and logs, available at http://subversion.tigris.org/.
 * ====================================================================
 * @endcopyright
 *
 * @file svn_ra_svn.h
 * @brief libsvn_ra_svn functions used by the server
 */</comment>


<escape char="0xc"/>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SVN_RA_SVN_H</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_RA_SVN_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_pools.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_network_io.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_config.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_delta.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
<extern>extern "C" <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* __cplusplus */</comment>

<comment type="block">/** The well-known svn port number. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_RA_SVN_PORT</name></cpp:macro> <cpp:value>3690</cpp:value></cpp:define>

<comment type="block">/** Currently-defined capabilities. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_RA_SVN_CAP_EDIT_PIPELINE</name></cpp:macro> <cpp:value>"edit-pipeline"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_RA_SVN_CAP_SVNDIFF1</name></cpp:macro> <cpp:value>"svndiff1"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_RA_SVN_CAP_ABSENT_ENTRIES</name></cpp:macro> <cpp:value>"absent-entries"</cpp:value></cpp:define>
<comment type="block">/* maps to SVN_RA_CAPABILITY_COMMIT_REVPROPS: */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_RA_SVN_CAP_COMMIT_REVPROPS</name></cpp:macro> <cpp:value>"commit-revprops"</cpp:value></cpp:define>
<comment type="block">/* maps to SVN_RA_CAPABILITY_MERGEINFO: */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_RA_SVN_CAP_MERGEINFO</name></cpp:macro> <cpp:value>"mergeinfo"</cpp:value></cpp:define>
<comment type="block">/* maps to SVN_RA_CAPABILITY_DEPTH: */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_RA_SVN_CAP_DEPTH</name></cpp:macro> <cpp:value>"depth"</cpp:value></cpp:define>
<comment type="block">/* maps to SVN_RA_CAPABILITY_LOG_REVPROPS */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_RA_SVN_CAP_LOG_REVPROPS</name></cpp:macro> <cpp:value>"log-revprops"</cpp:value></cpp:define>
<comment type="block">/* maps to SVN_RA_CAPABILITY_PARTIAL_REPLAY */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_RA_SVN_CAP_PARTIAL_REPLAY</name></cpp:macro> <cpp:value>"partial-replay"</cpp:value></cpp:define>

<comment type="block">/** ra_svn passes @c svn_dirent_t fields over the wire as a list of
 * words, these are the values used to represent each field.
 *
 * @defgroup ra_svn_dirent_fields Definitions of ra_svn dirent fields
 * @{
 */</comment>

<comment type="block">/** The ra_svn way of saying @c SVN_DIRENT_KIND. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_RA_SVN_DIRENT_KIND</name></cpp:macro> <cpp:value>"kind"</cpp:value></cpp:define>

<comment type="block">/** The ra_svn way of saying @c SVN_DIRENT_SIZE. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_RA_SVN_DIRENT_SIZE</name></cpp:macro> <cpp:value>"size"</cpp:value></cpp:define>

<comment type="block">/** The ra_svn way of saying @c SVN_DIRENT_HAS_PROPS. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_RA_SVN_DIRENT_HAS_PROPS</name></cpp:macro> <cpp:value>"has-props"</cpp:value></cpp:define>

<comment type="block">/** The ra_svn way of saying @c SVN_DIRENT_CREATED_REV. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_RA_SVN_DIRENT_CREATED_REV</name></cpp:macro> <cpp:value>"created-rev"</cpp:value></cpp:define>

<comment type="block">/** The ra_svn way of saying @c SVN_DIRENT_TIME. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_RA_SVN_DIRENT_TIME</name></cpp:macro> <cpp:value>"time"</cpp:value></cpp:define>

<comment type="block">/** The ra_svn way of saying @c SVN_DIRENT_LAST_AUTHOR. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_RA_SVN_DIRENT_LAST_AUTHOR</name></cpp:macro> <cpp:value>"last-author"</cpp:value></cpp:define>

<comment type="block">/** @} */</comment>

<comment type="block">/** A value used to indicate an optional number element in a tuple that was
 * not received.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_RA_SVN_UNSPECIFIED_NUMBER</name></cpp:macro> <cpp:value>~((apr_uint64_t) 0)</cpp:value></cpp:define>

<comment type="block">/** A specialized form of @c SVN_ERR to deal with errors which occur in an
 * svn_ra_svn_command_handler().
 *
 * An error returned with this macro will be passed back to the other side
 * of the connection.  Use this macro when performing the requested operation;
 * use the regular @c SVN_ERR when performing I/O with the client.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_CMD_ERR</name><parameter_list>(<param><type><name>expr</name></type></param>)</parameter_list></cpp:macro>                                     \
  <cpp:value>do {                                                        \
    svn_error_t *svn_err__temp = (expr);                      \
    if (svn_err__temp)                                        \
      return svn_error_create(SVN_ERR_RA_SVN_CMD_ERR,         \
                              svn_err__temp, NULL);           \
  } while (0)</cpp:value></cpp:define>

<comment type="block">/** an ra_svn connection. */</comment>
<typedef>typedef <type>struct <name>svn_ra_svn_conn_st</name></type> <name>svn_ra_svn_conn_t</name>;</typedef>

<comment type="block">/** Command handler, used by svn_ra_svn_handle_commands(). */</comment>
<typedef>typedef <function_decl><type><name>svn_error_t</name> *</type>(*<name>svn_ra_svn_command_handler</name>)<parameter_list>(<param><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name></decl></param>,
                                                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                                                   <param><decl><type><name>apr_array_header_t</name> *</type><name>params</name></decl></param>,
                                                   <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list>;</function_decl></typedef>

<comment type="block">/** Command table, used by svn_ra_svn_handle_commands().
 */</comment>
<typedef>typedef <type><struct>struct <name>svn_ra_svn_cmd_entry_t</name>
<block>{
  <comment type="block">/** Name of the command */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>cmdname</name></decl>;</decl_stmt>

  <comment type="block">/** Handler for the command */</comment>
  <decl_stmt><decl><type><name>svn_ra_svn_command_handler</name></type> <name>handler</name></decl>;</decl_stmt>

  <comment type="block">/** Termination flag.  If set, command-handling will cease after
   * command is processed. */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>terminate</name></decl>;</decl_stmt>
}</block></struct></type> <name>svn_ra_svn_cmd_entry_t</name>;</typedef>

<comment type="block">/** Memory representation of an on-the-wire data item. */</comment>
<typedef>typedef <type><struct>struct <name>svn_ra_svn_item_t</name>
<block>{
  <comment type="block">/** Variant indicator. */</comment>
  <enum>enum <block>{
    <decl><name>SVN_RA_SVN_NUMBER</name></decl>,
    <decl><name>SVN_RA_SVN_STRING</name></decl>,
    <decl><name>SVN_RA_SVN_WORD</name></decl>,
    <decl><name>SVN_RA_SVN_LIST</name></decl>
  }</block> <decl><name>kind</name></decl>;</enum>
  <comment type="block">/** Variant data. */</comment>
  <union>union <block>{
    <decl_stmt><decl><type><name>apr_uint64_t</name></type> <name>number</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>string</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>word</name></decl>;</decl_stmt>

    <comment type="block">/** Contains @c svn_ra_svn_item_t's. */</comment>
    <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>list</name></decl>;</decl_stmt>
  }</block> <decl><name>u</name></decl>;</union>
}</block></struct></type> <name>svn_ra_svn_item_t</name>;</typedef>

<typedef>typedef <function_decl><type><name>svn_error_t</name> *</type>(*<name>svn_ra_svn_edit_callback</name>)<parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list>;</function_decl></typedef>

<comment type="block">/** Initialize a connection structure for the given socket or
 * input/output files.
 *
 * Either @a sock or @a in_file/@a out_file must be set, not both.
 */</comment>
<function_decl><type><name>svn_ra_svn_conn_t</name> *</type><name>svn_ra_svn_create_conn</name><parameter_list>(<param><decl><type><name>apr_socket_t</name> *</type><name>sock</name></decl></param>,
                                          <param><decl><type><name>apr_file_t</name> *</type><name>in_file</name></decl></param>,
                                          <param><decl><type><name>apr_file_t</name> *</type><name>out_file</name></decl></param>,
                                          <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/** Add the capabilities in @a list to @a conn's capabilities.
 * @a list contains svn_ra_svn_item_t entries (which should be of type
 * SVN_RA_SVN_WORD; a malformed data error will result if any are not).
 *
 * This is idempotent: if a given capability was already set for
 * @a conn, it remains set.
 */</comment>
<function_decl><type><name>svn_error_t</name> *</type><name>svn_ra_svn_set_capabilities</name><parameter_list>(<param><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name></decl></param>,
                                         <param><decl><type><name>apr_array_header_t</name> *</type><name>list</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/** Return @c TRUE if @a conn has the capability @a capability, or
 * @c FALSE if it does not. */</comment>
<function_decl><type><name>svn_boolean_t</name></type> <name>svn_ra_svn_has_capability</name><parameter_list>(<param><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name></decl></param>,
                                        <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>capability</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/** Write a number over the net.
 *
 * Writes will be buffered until the next read or flush.
 */</comment>
<function_decl><type><name>svn_error_t</name> *</type><name>svn_ra_svn_write_number</name><parameter_list>(<param><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                                     <param><decl><type><name>apr_uint64_t</name></type> <name>number</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/** Write a string over the net.
 *
 * Writes will be buffered until the next read or flush.
 */</comment>
<function_decl><type><name>svn_error_t</name> *</type><name>svn_ra_svn_write_string</name><parameter_list>(<param><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                                     <param><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>str</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/** Write a cstring over the net.
 *
 * Writes will be buffered until the next read or flush.
 */</comment>
<function_decl><type><name>svn_error_t</name> *</type><name>svn_ra_svn_write_cstring</name><parameter_list>(<param><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name></decl></param>,
                                      <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/** Write a word over the net.
 *
 * Writes will be buffered until the next read or flush.
 */</comment>
<function_decl><type><name>svn_error_t</name> *</type><name>svn_ra_svn_write_word</name><parameter_list>(<param><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>word</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/** Write a list of properties over the net.  @a props is allowed to be NULL,
 * in which case an empty list will be written out.
 *
 * @since New in 1.5.
 */</comment>
<function_decl><type><name>svn_error_t</name> *</type><name>svn_ra_svn_write_proplist</name><parameter_list>(<param><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name></decl></param>,
                                       <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                                       <param><decl><type><name>apr_hash_t</name> *</type><name>props</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/** Begin a list.  Writes will be buffered until the next read or flush. */</comment>
<function_decl><type><name>svn_error_t</name> *</type><name>svn_ra_svn_start_list</name><parameter_list>(<param><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/** End a list.  Writes will be buffered until the next read or flush. */</comment>
<function_decl><type><name>svn_error_t</name> *</type><name>svn_ra_svn_end_list</name><parameter_list>(<param><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/** Flush the write buffer.
 *
 * Normally this shouldn't be necessary, since the write buffer is flushed
 * when a read is attempted.
 */</comment>
<function_decl><type><name>svn_error_t</name> *</type><name>svn_ra_svn_flush</name><parameter_list>(<param><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/** Write a tuple, using a printf-like interface.
 *
 * The format string @a fmt may contain:
 *
 *@verbatim
     Spec  Argument type         Item type
     ----  --------------------  ---------
     n     apr_uint64_t          Number
     r     svn_revnum_t          Number
     s     const svn_string_t *  String
     c     const char *          String
     w     const char *          Word
     b     svn_boolean_t         Word ("true" or "false")
     (                           Begin tuple
     )                           End tuple
     ?                           Remaining elements optional
     ! (at beginning or end)     Suppress opening or closing of tuple
  @endverbatim
 *
 * Inside the optional part of a tuple, 'r' values may be @c
 * SVN_INVALID_REVNUM, 'n' values may be
 * SVN_RA_SVN_UNSPECIFIED_NUMBER, and 's', 'c', and 'w' values may be
 * @c NULL; in these cases no data will be written.  'b' and '(' may
 * not appear in the optional part of a tuple.  Either all or none of
 * the optional values should be valid.
 *
 * (If we ever have a need for an optional boolean value, we should
 * invent a 'B' specifier which stores a boolean into an int, using -1
 * for unspecified.  Right now there is no need for such a thing.)
 *
 * Use the '!' format specifier to write partial tuples when you have
 * to transmit an array or other unusual data.  For example, to write
 * a tuple containing a revision, an array of words, and a boolean:
 * @verbatim
     SVN_ERR(svn_ra_svn_write_tuple(conn, pool, "r(!", rev));
     for (i = 0; i &lt; n; i++)
       SVN_ERR(svn_ra_svn_write_word(conn, pool, words[i]));
     SVN_ERR(svn_ra_svn_write_tuple(conn, pool, "!)b", flag)); @endverbatim
 */</comment>
<function_decl><type><name>svn_error_t</name> *</type><name>svn_ra_svn_write_tuple</name><parameter_list>(<param><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fmt</name></decl></param>, <param><decl><type>...</type></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/** Read an item from the network into @a *item. */</comment>
<function_decl><type><name>svn_error_t</name> *</type><name>svn_ra_svn_read_item</name><parameter_list>(<param><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                                  <param><decl><type><name>svn_ra_svn_item_t</name> **</type><name>item</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/** Scan data on @a conn until we find something which looks like the
 * beginning of an svn server greeting (an open paren followed by a
 * whitespace character).  This function is appropriate for beginning
 * a client connection opened in tunnel mode, since people's dotfiles
 * sometimes write output to stdout.  It may only be called at the
 * beginning of a client connection.
 */</comment>
<function_decl><type><name>svn_error_t</name> *</type><name>svn_ra_svn_skip_leading_garbage</name><parameter_list>(<param><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name></decl></param>,
                                             <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/** Parse an array of @c svn_sort__item_t structures as a tuple, using a
 * printf-like interface.  The format string @a fmt may contain:
 *
 *@verbatim
     Spec  Argument type          Item type
     ----  --------------------   ---------
     n     apr_uint64_t *         Number
     r     svn_revnum_t *         Number
     s     svn_string_t **        String
     c     const char **          String
     w     const char **          Word
     b     svn_boolean_t *        Word ("true" or "false")
     B     apr_uint64_t *         Word ("true" or "false")
     l     apr_array_header_t **  List
     (                            Begin tuple
     )                            End tuple
     ?                            Tuple is allowed to end here
  @endverbatim
 *
 * Note that a tuple is only allowed to end precisely at a '?', or at
 * the end of the specification.  So if @a fmt is "c?cc" and @a list
 * contains two elements, an error will result.
 *
 * 'B' is similar to 'b', but may be used in the optional tuple specification.
 * It returns TRUE, FALSE, or SVN_RA_SVN_UNSPECIFIED_NUMBER.
 *
 * If an optional part of a tuple contains no data, 'r' values will be
 * set to @c SVN_INVALID_REVNUM, 'n' and 'B' values will be set to
 * SVN_RA_SVN_UNSPECIFIED_NUMBER, and 's', 'c', 'w', and 'l' values
 * will be set to @c NULL.  'b' may not appear inside an optional
 * tuple specification; use 'B' instead.
 */</comment>
<function_decl><type><name>svn_error_t</name> *</type><name>svn_ra_svn_parse_tuple</name><parameter_list>(<param><decl><type><name>apr_array_header_t</name> *</type><name>list</name></decl></param>,
                                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fmt</name></decl></param>, <param><decl><type>...</type></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/** Read a tuple from the network and parse it as a tuple, using the
 * format string notation from svn_ra_svn_parse_tuple().
 */</comment>
<function_decl><type><name>svn_error_t</name> *</type><name>svn_ra_svn_read_tuple</name><parameter_list>(<param><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fmt</name></decl></param>, <param><decl><type>...</type></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/** Parse an array of @c svn_ra_svn_item_t structures as a list of
 * properties, storing the properties in a hash table.
 *
 * @since New in 1.5.
 */</comment>
<function_decl><type><name>svn_error_t</name> *</type><name>svn_ra_svn_parse_proplist</name><parameter_list>(<param><decl><type><name>apr_array_header_t</name> *</type><name>list</name></decl></param>,
                                       <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                                       <param><decl><type><name>apr_hash_t</name> **</type><name>props</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/** Read a command response from the network and parse it as a tuple, using
 * the format string notation from svn_ra_svn_parse_tuple().
 */</comment>
<function_decl><type><name>svn_error_t</name> *</type><name>svn_ra_svn_read_cmd_response</name><parameter_list>(<param><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name></decl></param>,
                                          <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                                          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fmt</name></decl></param>, <param><decl><type>...</type></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/** Accept commands over the network and handle them according to @a
 * commands.  Command handlers will be passed @a conn, a subpool of @a
 * pool (cleared after each command is handled), the parameters of the
 * command, and @a baton.  Commands will be accepted until a
 * terminating command is received (a command with "terminate" set in
 * the command table).  If a command handler returns an error wrapped
 * in SVN_RA_SVN_CMD_ERR (see the @c SVN_CMD_ERR macro), the error
 * will be reported to the other side of the connection and the
 * command loop will continue; any other kind of error (typically a
 * network or protocol error) is passed through to the caller.
 */</comment>
<function_decl><type><name>svn_error_t</name> *</type><name>svn_ra_svn_handle_commands</name><parameter_list>(<param><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name></decl></param>,
                                        <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                                        <param><decl><type><specifier>const</specifier> <name>svn_ra_svn_cmd_entry_t</name> *</type><name>commands</name></decl></param>,
                                        <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/** Write a command over the network, using the same format string notation
 * as svn_ra_svn_write_tuple().
 */</comment>
<function_decl><type><name>svn_error_t</name> *</type><name>svn_ra_svn_write_cmd</name><parameter_list>(<param><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                                  <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>cmdname</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fmt</name></decl></param>, <param><decl><type>...</type></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/** Write a successful command response over the network, using the
 * same format string notation as svn_ra_svn_write_tuple().  Do not use
 * partial tuples with this function; if you need to use partial
 * tuples, just write out the "success" and argument tuple by hand.
 */</comment>
<function_decl><type><name>svn_error_t</name> *</type><name>svn_ra_svn_write_cmd_response</name><parameter_list>(<param><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name></decl></param>,
                                           <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                                           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fmt</name></decl></param>, <param><decl><type>...</type></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/** Write an unsuccessful command response over the network. */</comment>
<function_decl><type><name>svn_error_t</name> *</type><name>svn_ra_svn_write_cmd_failure</name><parameter_list>(<param><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name></decl></param>,
                                          <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>, <param><decl><type><name>svn_error_t</name> *</type><name>err</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/** Set @a *editor and @a *edit_baton to an editor which will pass editing
 * operations over the network, using @a conn and @a pool.
 *
 * Upon successful completion of the edit, the editor will invoke @a callback
 * with @a callback_baton as an argument.
 */</comment>
<function_decl><type><name>void</name></type> <name>svn_ra_svn_get_editor</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>svn_delta_editor_t</name> **</type><name>editor</name></decl></param>,
                           <param><decl><type><name>void</name> **</type><name>edit_baton</name></decl></param>, <param><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name></decl></param>,
                           <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>, <param><decl><type><name>svn_ra_svn_edit_callback</name></type> <name>callback</name></decl></param>,
                           <param><decl><type><name>void</name> *</type><name>callback_baton</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/** Receive edit commands over the network and use them to drive @a editor
 * with @a edit_baton.  On return, @a *aborted will be set if the edit was
 * aborted.  The drive can be terminated with a finish-replay command only
 * if @a for_replay is TRUE.
 */</comment>
<function_decl><type><name>svn_error_t</name> *</type><name>svn_ra_svn_drive_editor2</name><parameter_list>(<param><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name></decl></param>,
                                      <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                                      <param><decl><type><specifier>const</specifier> <name>svn_delta_editor_t</name> *</type><name>editor</name></decl></param>,
                                      <param><decl><type><name>void</name> *</type><name>edit_baton</name></decl></param>,
                                      <param><decl><type><name>svn_boolean_t</name> *</type><name>aborted</name></decl></param>,
                                      <param><decl><type><name>svn_boolean_t</name></type> <name>for_replay</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/** Like svn_ra_svn_drive_editor2, but with @a for_replay always FALSE.
 */</comment>
<function_decl><type><name>svn_error_t</name> *</type><name>svn_ra_svn_drive_editor</name><parameter_list>(<param><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                                     <param><decl><type><specifier>const</specifier> <name>svn_delta_editor_t</name> *</type><name>editor</name></decl></param>,
                                     <param><decl><type><name>void</name> *</type><name>edit_baton</name></decl></param>,
                                     <param><decl><type><name>svn_boolean_t</name> *</type><name>aborted</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/** This function is only intended for use by svnserve.
 *
 * Perform CRAM-MD5 password authentication.  On success, return
 * SVN_NO_ERROR with *user set to the username and *success set to
 * TRUE.  On an error which can be reported to the client, report the
 * error and return SVN_NO_ERROR with *success set to FALSE.  On
 * communications failure, return an error.
 */</comment>
<function_decl><type><name>svn_error_t</name> *</type><name>svn_ra_svn_cram_server</name><parameter_list>(<param><decl><type><name>svn_ra_svn_conn_t</name> *</type><name>conn</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                                    <param><decl><type><name>svn_config_t</name> *</type><name>pwdb</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>user</name></decl></param>,
                                    <param><decl><type><name>svn_boolean_t</name> *</type><name>success</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Get libsvn_ra_svn version information.
 * @since New in 1.1.
 */</comment>
<function_decl><type><specifier>const</specifier> <name>svn_version_t</name> *</type><name>svn_ra_svn_version</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
}</block></extern>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* __cplusplus */</comment>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SVN_RA_SVN_H */</comment>
</unit>
