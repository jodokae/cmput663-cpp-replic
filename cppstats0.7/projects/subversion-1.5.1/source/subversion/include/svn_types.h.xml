<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/subversion-1.5.1/source/subversion/include/svn_types.h"><comment type="block">/**
 * @copyright
 * ====================================================================
 * Copyright (c) 2000-2008 CollabNet.  All rights reserved.
 *
 * This software is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at http://subversion.tigris.org/license-1.html.
 * If newer versions of this license are posted there, you may use a
 * newer version instead, at your option.
 *
 * This software consists of voluntary contributions made by many
 * individuals.  For exact contribution history, see the revision
 * history and logs, available at http://subversion.tigris.org/.
 * ====================================================================
 * @endcopyright
 *
 * @file svn_types.h
 * @brief Subversion's data types
 */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SVN_TYPES_H</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_TYPES_H</name></cpp:macro></cpp:define>

<comment type="block">/* ### this should go away, but it causes too much breakage right now */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr.h&gt;</cpp:file></cpp:include>        <comment type="block">/* for apr_size_t */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_pools.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_hash.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_tables.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_time.h&gt;</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
<extern>extern "C" <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* __cplusplus */</comment>


<escape char="0xc"/>
<comment type="block">/** Subversion error object.
 *
 * Defined here, rather than in svn_error.h, to avoid a recursive @#include
 * situation.
 */</comment>
<typedef>typedef <type><struct>struct <name>svn_error_t</name>
<block>{
  <comment type="block">/** APR error value, possibly SVN_ custom err */</comment>
  <decl_stmt><decl><type><name>apr_status_t</name></type> <name>apr_err</name></decl>;</decl_stmt>

  <comment type="block">/** details from producer of error */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>message</name></decl>;</decl_stmt>

  <comment type="block">/** ptr to the error we "wrap" */</comment>
  <decl_stmt><decl><type>struct <name>svn_error_t</name> *</type><name>child</name></decl>;</decl_stmt>

  <comment type="block">/** The pool holding this error and any child errors it wraps */</comment>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>

  <comment type="block">/** Source file where the error originated.  Only used iff @c SVN_DEBUG. */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>file</name></decl>;</decl_stmt>

  <comment type="block">/** Source line where the error originated.  Only used iff @c SVN_DEBUG. */</comment>
  <decl_stmt><decl><type><name>long</name></type> <name>line</name></decl>;</decl_stmt>

}</block></struct></type> <name>svn_error_t</name>;</typedef>


<escape char="0xc"/>
<comment type="block">/** @defgroup APR_ARRAY_compat_macros APR Array Compatibility Helper Macros
 * These macros are provided by APR itself from version 1.3.
 * Definitions are provided here for when using older versions of APR.
 * @{
 */</comment>

<comment type="block">/** index into an apr_array_header_t */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>APR_ARRAY_IDX</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APR_ARRAY_IDX</name><parameter_list>(<param><type><name>ary</name></type></param>,<param><type><name>i</name></type></param>,<param><type><name>type</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(((type *)(ary)-&gt;elts)[i])</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/** easier array-pushing syntax */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>APR_ARRAY_PUSH</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>APR_ARRAY_PUSH</name><parameter_list>(<param><type><name>ary</name></type></param>,<param><type><name>type</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(*((type *)apr_array_push(ary)))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/** @} */</comment>
<escape char="0xc"/>
<comment type="block">/** The various types of nodes in the Subversion filesystem. */</comment>
<typedef>typedef <type><enum>enum
<block>{
  <comment type="block">/** absent */</comment>
  <decl><name>svn_node_none</name></decl>,

  <comment type="block">/** regular file */</comment>
  <decl><name>svn_node_file</name></decl>,

  <comment type="block">/** directory */</comment>
  <decl><name>svn_node_dir</name></decl>,

  <comment type="block">/** something's here, but we don't know what */</comment>
  <decl><name>svn_node_unknown</name></decl>
}</block></enum></type> <name>svn_node_kind_t</name>;</typedef>

<comment type="block">/** About Special Files in Subversion
 *
 * Subversion denotes files that cannot be portably created or
 * modified as "special" files (svn_node_special).  It stores these
 * files in the repository as a plain text file with the svn:special
 * property set.  The file contents contain: a platform-specific type
 * string, a space character, then any information necessary to create
 * the file on a supported platform.  For example, if a symbolic link
 * were being represented, the repository file would have the
 * following contents:
 *
 * "link /path/to/link/target"
 *
 * Where 'link' is the identifier string showing that this special
 * file should be a symbolic link and '/path/to/link/target' is the
 * destination of the symbolic link.
 *
 * Special files are stored in the text-base exactly as they are
 * stored in the repository.  The platform specific files are created
 * in the working copy at EOL/keyword translation time using
 * svn_subst_copy_and_translate2().  If the current platform does not
 * support a specific special file type, the file is copied into the
 * working copy as it is seen in the repository.  Because of this,
 * users of other platforms can still view and modify the special
 * files, even if they do not have their unique properties.
 *
 * New types of special files can be added by:
 *  1. Implementing a platform-dependent routine to create a uniquely
 *     named special file and one to read the special file in
 *     libsvn_subr/io.c.
 *  2. Creating a new textual name similar to
 *     SVN_SUBST__SPECIAL_LINK_STR in libsvn_subr/subst.c.
 *  3. Handling the translation/detranslation case for the new type in
 *     create_special_file and detranslate_special_file, using the
 *     routines from 1.
 */</comment>

<comment type="block">/** A revision number. */</comment>
<typedef>typedef <type><name>long</name> <name>int</name></type> <name>svn_revnum_t</name>;</typedef>

<comment type="block">/** Valid revision numbers begin at 0 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_IS_VALID_REVNUM</name><parameter_list>(<param><type><name>n</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((n) &gt;= 0)</cpp:value></cpp:define>

<comment type="block">/** The 'official' invalid revision num */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_INVALID_REVNUM</name></cpp:macro> <cpp:value>((svn_revnum_t) -1)</cpp:value></cpp:define>

<comment type="block">/** Not really invalid...just unimportant -- one day, this can be its
 * own unique value, for now, just make it the same as
 * @c SVN_INVALID_REVNUM.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_IGNORED_REVNUM</name></cpp:macro> <cpp:value>((svn_revnum_t) -1)</cpp:value></cpp:define>

<comment type="block">/** Convert NULL-terminated C string @a str to a revision number. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_STR_TO_REV</name><parameter_list>(<param><type><name>str</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((svn_revnum_t) atol(str))</cpp:value></cpp:define>

<comment type="block">/**
 * Parse NULL-terminated C string @a str as a revision number and
 * store its value in @a rev.  If @a endptr is non-NULL, then the
 * address of the first non-numeric character in @a str is stored in
 * it.  If there are no digits in @a str, then @a endptr is set (if
 * non-NULL), and the error @c SVN_ERR_REVNUM_PARSE_FAILURE error is
 * returned.  Negative numbers parsed from @a str are considered
 * invalid, and result in the same error.
 *
 * @since New in 1.5.
 */</comment>
<function_decl><type><name>svn_error_t</name> *</type>
<name>svn_revnum_parse</name><parameter_list>(<param><decl><type><name>svn_revnum_t</name> *</type><name>rev</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>str</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>endptr</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/** Originally intended to be used in printf()-style functions to format
 * revision numbers.  Deprecated due to incompatibilities with language
 * translation tools (e.g. gettext).
 *
 * New code should use a bare "%ld" format specifier for formatting revision
 * numbers.
 *
 * @deprecated Provided for backward compatibility with the 1.0 API.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_REVNUM_T_FMT</name></cpp:macro> <cpp:value>"ld"</cpp:value></cpp:define>


<comment type="block">/** The size of a file in the Subversion FS. */</comment>
<typedef>typedef <type><name>apr_int64_t</name></type> <name>svn_filesize_t</name>;</typedef>

<comment type="block">/** The 'official' invalid file size constant. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_INVALID_FILESIZE</name></cpp:macro> <cpp:value>((svn_filesize_t) -1)</cpp:value></cpp:define>

<comment type="block">/** In printf()-style functions, format file sizes using this. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_FILESIZE_T_FMT</name></cpp:macro> <cpp:value>APR_INT64_T_FMT</cpp:value></cpp:define>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>DOXYGEN_SHOULD_SKIP_THIS</name></cpp:ifndef>
<comment type="block">/* Parse a base-10 numeric string into a 64-bit unsigned numeric value. */</comment>
<comment type="block">/* NOTE: Private. For use by Subversion's own code only. See issue #1644. */</comment>
<comment type="block">/* FIXME: APR should supply a function to do this, such as "apr_atoui64". */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>svn__atoui64</name><parameter_list>(<param><type><name>X</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((apr_uint64_t) apr_atoi64(X))</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<comment type="block">/** YABT:  Yet Another Boolean Type */</comment>
<typedef>typedef <type><name>int</name></type> <name>svn_boolean_t</name>;</typedef>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>TRUE</name></cpp:ifndef>
<comment type="block">/** uhh... true */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TRUE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* TRUE */</comment>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>FALSE</name></cpp:ifndef>
<comment type="block">/** uhh... false */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FALSE</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* FALSE */</comment>


<comment type="block">/** An enum to indicate whether recursion is needed. */</comment>
<enum>enum <name>svn_recurse_kind</name>
<block>{
  <decl><name>svn_nonrecursive</name> <init>= <expr>1</expr></init></decl>,
  <decl><name>svn_recursive</name></decl>
}</block>;</enum>

<comment type="block">/** The concept of depth for directories.
 *
 * @note This is similar to, but not exactly the same as, the WebDAV
 * and LDAP concepts of depth.
 *
 * @since New in 1.5.
 */</comment>
<typedef>typedef <type><enum>enum
<block>{
  <comment type="block">/* The order of these depths is important: the higher the number,
     the deeper it descends.  This allows us to compare two depths
     numerically to decide which should govern. */</comment>

  <comment type="block">/* Depth undetermined or ignored. */</comment>
  <decl><name>svn_depth_unknown</name>    <init>= <expr>-2</expr></init></decl>,

  <comment type="block">/* Exclude (i.e., don't descend into) directory D. */</comment>
  <comment type="block">/* NOTE: In Subversion 1.5, svn_depth_exclude is *not* supported
     anywhere in the client-side (libsvn_wc/libsvn_client/etc) code;
     it is only supported as an argument to set_path functions in the
     ra and repos reporters.  (This will enable future versions of
     Subversion to run updates, etc, against 1.5 servers with proper
     svn_depth_exclude behavior, once we get a chance to implement
     client-side support for svn_depth_exclude.)
  */</comment>
  <decl><name>svn_depth_exclude</name>    <init>= <expr>-1</expr></init></decl>,

  <comment type="block">/* Just the named directory D, no entries.  Updates will not pull in
     any files or subdirectories not already present. */</comment>
  <decl><name>svn_depth_empty</name>      <init>=  <expr>0</expr></init></decl>,

  <comment type="block">/* D + its file children, but not subdirs.  Updates will pull in any
     files not already present, but not subdirectories. */</comment>
  <decl><name>svn_depth_files</name>      <init>=  <expr>1</expr></init></decl>,

  <comment type="block">/* D + immediate children (D and its entries).  Updates will pull in
     any files or subdirectories not already present; those
     subdirectories' this_dir entries will have depth-empty. */</comment>
  <decl><name>svn_depth_immediates</name> <init>=  <expr>2</expr></init></decl>,

  <comment type="block">/* D + all descendants (full recursion from D).  Updates will pull
     in any files or subdirectories not already present; those
     subdirectories' this_dir entries will have depth-infinity.
     Equivalent to the pre-1.5 default update behavior. */</comment>
  <decl><name>svn_depth_infinity</name>   <init>=  <expr>3</expr></init></decl>

}</block></enum></type> <name>svn_depth_t</name>;</typedef>


<comment type="block">/** Return a constant string expressing @a depth as an English word,
 * e.g., "infinity", "immediates", etc.  The string is not localized,
 * as it may be used for client&lt;-&gt;server communications.
 *
 * @since New in 1.5.
 */</comment>
<function_decl><type><specifier>const</specifier> <name>char</name> *</type>
<name>svn_depth_to_word</name><parameter_list>(<param><decl><type><name>svn_depth_t</name></type> <name>depth</name></decl></param>)</parameter_list>;</function_decl>


<comment type="block">/** Return the appropriate depth for @a depth_str.  @a word is as
 * returned from svn_depth_to_word().  If @a depth_str does not
 * represent a recognized depth, return @c svn_depth_unknown.
 *
 * @since New in 1.5.
 */</comment>
<function_decl><type><name>svn_depth_t</name></type>
<name>svn_depth_from_word</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>word</name></decl></param>)</parameter_list>;</function_decl>


<comment type="block">/* Return @c svn_depth_infinity if boolean @a recurse is TRUE, else
 * return @c svn_depth_files.
 *
 * @note New code should never need to use this, it is called only
 * from pre-depth APIs, for compatibility.
 *
 * @since New in 1.5.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_DEPTH_INFINITY_OR_FILES</name><parameter_list>(<param><type><name>recurse</name></type></param>)</parameter_list></cpp:macro> \
  <cpp:value>((recurse) ? svn_depth_infinity : svn_depth_files)</cpp:value></cpp:define>


<comment type="block">/* Return @c svn_depth_infinity if boolean @a recurse is TRUE, else
 * return @c svn_depth_immediates.
 *
 * @note New code should never need to use this, it is called only
 * from pre-depth APIs, for compatibility.
 *
 * @since New in 1.5.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_DEPTH_INFINITY_OR_IMMEDIATES</name><parameter_list>(<param><type><name>recurse</name></type></param>)</parameter_list></cpp:macro> \
  <cpp:value>((recurse) ? svn_depth_infinity : svn_depth_immediates)</cpp:value></cpp:define>


<comment type="block">/* Return @c svn_depth_infinity if boolean @a recurse is TRUE, else
 * return @c svn_depth_empty.
 *
 * @note New code should never need to use this, it is called only
 * from pre-depth APIs, for compatibility.
 *
 * @since New in 1.5.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_DEPTH_INFINITY_OR_EMPTY</name><parameter_list>(<param><type><name>recurse</name></type></param>)</parameter_list></cpp:macro> \
  <cpp:value>((recurse) ? svn_depth_infinity : svn_depth_empty)</cpp:value></cpp:define>


<comment type="block">/* Return a recursion boolean based on @a depth.
 *
 * Although much code has been converted to use depth, some code still
 * takes a recurse boolean.  In most cases, it makes sense to treat
 * unknown or infinite depth as recursive, and any other depth as
 * non-recursive (which in turn usually translates to @c svn_depth_files).
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_DEPTH_IS_RECURSIVE</name><parameter_list>(<param><type><name>depth</name></type></param>)</parameter_list></cpp:macro>                              \
  <cpp:value>(((depth) == svn_depth_infinity || (depth) == svn_depth_unknown) \
   ? TRUE : FALSE)</cpp:value></cpp:define>


<comment type="block">/**
 * It is sometimes convenient to indicate which parts of an @c svn_dirent_t
 * object you are actually interested in, so that calculating and sending
 * the data corresponding to the other fields can be avoided.  These values
 * can be used for that purpose.
 *
 * @defgroup svn_dirent_fields Dirent fields
 * @{
 */</comment>

<comment type="block">/** An indication that you are interested in the @c kind field */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_DIRENT_KIND</name></cpp:macro>        <cpp:value>0x00001</cpp:value></cpp:define>

<comment type="block">/** An indication that you are interested in the @c size field */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_DIRENT_SIZE</name></cpp:macro>        <cpp:value>0x00002</cpp:value></cpp:define>

<comment type="block">/** An indication that you are interested in the @c has_props field */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_DIRENT_HAS_PROPS</name></cpp:macro>   <cpp:value>0x00004</cpp:value></cpp:define>

<comment type="block">/** An indication that you are interested in the @c created_rev field */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_DIRENT_CREATED_REV</name></cpp:macro> <cpp:value>0x00008</cpp:value></cpp:define>

<comment type="block">/** An indication that you are interested in the @c time field */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_DIRENT_TIME</name></cpp:macro>        <cpp:value>0x00010</cpp:value></cpp:define>

<comment type="block">/** An indication that you are interested in the @c last_author field */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_DIRENT_LAST_AUTHOR</name></cpp:macro> <cpp:value>0x00020</cpp:value></cpp:define>

<comment type="block">/** A combination of all the dirent fields */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_DIRENT_ALL</name></cpp:macro> <cpp:value>~((apr_uint32_t ) 0)</cpp:value></cpp:define>

<comment type="block">/** @} */</comment>

<comment type="block">/** A general subversion directory entry. */</comment>
<typedef>typedef <type><struct>struct <name>svn_dirent_t</name>
<block>{
  <comment type="block">/** node kind */</comment>
  <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>

  <comment type="block">/** length of file text, or 0 for directories */</comment>
  <decl_stmt><decl><type><name>svn_filesize_t</name></type> <name>size</name></decl>;</decl_stmt>

  <comment type="block">/** does the node have props? */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>has_props</name></decl>;</decl_stmt>

  <comment type="block">/** last rev in which this node changed */</comment>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>created_rev</name></decl>;</decl_stmt>

  <comment type="block">/** time of created_rev (mod-time) */</comment>
  <decl_stmt><decl><type><name>apr_time_t</name></type> <name>time</name></decl>;</decl_stmt>

  <comment type="block">/** author of created_rev */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>last_author</name></decl>;</decl_stmt>

  <comment type="block">/* IMPORTANT: If you extend this struct, check svn_dirent_dup(). */</comment>
}</block></struct></type> <name>svn_dirent_t</name>;</typedef>


<comment type="block">/** Return a deep copy of @a dirent, allocated in @a pool.
 *
 * @since New in 1.4.
 */</comment>
<function_decl><type><name>svn_dirent_t</name> *</type><name>svn_dirent_dup</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>svn_dirent_t</name> *</type><name>dirent</name></decl></param>,
                             <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>

<escape char="0xc"/>

<comment type="block">/** Keyword substitution.
 *
 * All the keywords Subversion recognizes.
 *
 * Note that there is a better, more general proposal out there, which
 * would take care of both internationalization issues and custom
 * keywords (e.g., $NetBSD$).  See
 *
 * @verbatim
      http://subversion.tigris.org/servlets/ReadMsg?list=dev&amp;msgNo=8921
      =====
      From: "Jonathan M. Manning" &lt;jmanning@alisa-jon.net&gt;
      To: dev@subversion.tigris.org
      Date: Fri, 14 Dec 2001 11:56:54 -0500
      Message-ID: &lt;87970000.1008349014@bdldevel.bl.bdx.com&gt;
      Subject: Re: keywords @endverbatim
 *
 * and Eric Gillespie's support of same:
 *
 * @verbatim
      http://subversion.tigris.org/servlets/ReadMsg?list=dev&amp;msgNo=8757
      =====
      From: "Eric Gillespie, Jr." &lt;epg@pretzelnet.org&gt;
      To: dev@subversion.tigris.org
      Date: Wed, 12 Dec 2001 09:48:42 -0500
      Message-ID: &lt;87k7vsebp1.fsf@vger.pretzelnet.org&gt;
      Subject: Re: Customizable Keywords @endverbatim
 *
 * However, it is considerably more complex than the scheme below.
 * For now we're going with simplicity, hopefully the more general
 * solution can be done post-1.0.
 *
 * @defgroup svn_types_keywords Keyword definitions
 * @{
 */</comment>

<comment type="block">/** The maximum size of an expanded or un-expanded keyword. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_KEYWORD_MAX_LEN</name></cpp:macro>    <cpp:value>255</cpp:value></cpp:define>

<comment type="block">/** The most recent revision in which this file was changed. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_KEYWORD_REVISION_LONG</name></cpp:macro>    <cpp:value>"LastChangedRevision"</cpp:value></cpp:define>

<comment type="block">/** Short version of LastChangedRevision */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_KEYWORD_REVISION_SHORT</name></cpp:macro>   <cpp:value>"Rev"</cpp:value></cpp:define>

<comment type="block">/** Medium version of LastChangedRevision, matching the one CVS uses.
 * @since New in 1.1. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_KEYWORD_REVISION_MEDIUM</name></cpp:macro>  <cpp:value>"Revision"</cpp:value></cpp:define>

<comment type="block">/** The most recent date (repository time) when this file was changed. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_KEYWORD_DATE_LONG</name></cpp:macro>        <cpp:value>"LastChangedDate"</cpp:value></cpp:define>

<comment type="block">/** Short version of LastChangedDate */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_KEYWORD_DATE_SHORT</name></cpp:macro>       <cpp:value>"Date"</cpp:value></cpp:define>

<comment type="block">/** Who most recently committed to this file. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_KEYWORD_AUTHOR_LONG</name></cpp:macro>      <cpp:value>"LastChangedBy"</cpp:value></cpp:define>

<comment type="block">/** Short version of LastChangedBy */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_KEYWORD_AUTHOR_SHORT</name></cpp:macro>     <cpp:value>"Author"</cpp:value></cpp:define>

<comment type="block">/** The URL for the head revision of this file. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_KEYWORD_URL_LONG</name></cpp:macro>         <cpp:value>"HeadURL"</cpp:value></cpp:define>

<comment type="block">/** Short version of HeadURL */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_KEYWORD_URL_SHORT</name></cpp:macro>        <cpp:value>"URL"</cpp:value></cpp:define>

<comment type="block">/** A compressed combination of the other four keywords. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_KEYWORD_ID</name></cpp:macro>               <cpp:value>"Id"</cpp:value></cpp:define>

<comment type="block">/** @} */</comment>

<escape char="0xc"/>
<comment type="block">/** All information about a commit.
 *
 * @note Objects of this type should always be created using the
 * svn_create_commit_info() function.
 *
 * @since New in 1.3.
 */</comment>
<typedef>typedef <type><struct>struct <name>svn_commit_info_t</name>
<block>{
  <comment type="block">/** just-committed revision. */</comment>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>revision</name></decl>;</decl_stmt>

  <comment type="block">/** server-side date of the commit. */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>date</name></decl>;</decl_stmt>

  <comment type="block">/** author of the commit. */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>author</name></decl>;</decl_stmt>

  <comment type="block">/** error message from post-commit hook, or NULL. */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>post_commit_err</name></decl>;</decl_stmt>

}</block></struct></type> <name>svn_commit_info_t</name>;</typedef>

<escape char="0xc"/>
<comment type="block">/**
 * Allocate an object of type @c svn_commit_info_t in @a pool and
 * return it.
 *
 * The @c revision field of the new struct is set to @c
 * SVN_INVALID_REVNUM.  All other fields are initialized to @c NULL.
 *
 * @note Any object of the type @c svn_commit_info_t should
 * be created using this function.
 * This is to provide for extending the svn_commit_info_t in
 * the future.
 *
 * @since New in 1.3.
 */</comment>
<function_decl><type><name>svn_commit_info_t</name> *</type>
<name>svn_create_commit_info</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>

<escape char="0xc"/>
<comment type="block">/**
 * Return a deep copy @a src_commit_info allocated in @a pool.
 *
 * @since New in 1.4.
 */</comment>
<function_decl><type><name>svn_commit_info_t</name> *</type>
<name>svn_commit_info_dup</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>svn_commit_info_t</name> *</type><name>src_commit_info</name></decl></param>,
                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>

<escape char="0xc"/>
<comment type="block">/** A structure to represent a path that changed for a log entry. */</comment>
<typedef>typedef <type><struct>struct <name>svn_log_changed_path_t</name>
<block>{
  <comment type="block">/** 'A'dd, 'D'elete, 'R'eplace, 'M'odify */</comment>
  <decl_stmt><decl><type><name>char</name></type> <name>action</name></decl>;</decl_stmt>

  <comment type="block">/** Source path of copy (if any). */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copyfrom_path</name></decl>;</decl_stmt>

  <comment type="block">/** Source revision of copy (if any). */</comment>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>copyfrom_rev</name></decl>;</decl_stmt>

}</block></struct></type> <name>svn_log_changed_path_t</name>;</typedef>


<comment type="block">/**
 * Return a deep copy of @a changed_path, allocated in @a pool.
 *
 * @since New in 1.3.
 */</comment>
<function_decl><type><name>svn_log_changed_path_t</name> *</type>
<name>svn_log_changed_path_dup</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>svn_log_changed_path_t</name> *</type><name>changed_path</name></decl></param>,
                         <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * A structure to represent all the information about a particular log entry.
 *
 * @note To allow for extending the @c svn_log_entry_t structure in future
 * releases, always use svn_log_entry_create() to allocate the structure.
 */</comment>
<typedef>typedef <type><struct>struct <name>svn_log_entry_t</name>
<block>{
  <comment type="block">/** A hash containing as keys every path committed in @a revision; the
   * values are (@c svn_log_changed_path_t *) stuctures.
   *
   * ### The only reason @a changed_paths is not qualified with `const' is
   * that we usually want to loop over it, and apr_hash_first() doesn't
   * take a const hash, for various reasons.  I'm not sure that those
   * "various reasons" are actually even relevant anymore, and if
   * they're not, it might be nice to change apr_hash_first() so
   * read-only uses of hashes can be protected via the type system.
   */</comment>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>changed_paths</name></decl>;</decl_stmt>

  <comment type="block">/** The revision of the commit. */</comment>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>revision</name></decl>;</decl_stmt>

  <comment type="block">/** The hash of requested revision properties, which may be NULL if it
   * would contain no revprops. */</comment>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>revprops</name></decl>;</decl_stmt>

  <comment type="block">/**
   * Whether or not this message has children.
   *
   * When a log operation requests additional merge information, extra log
   * entries may be returned as a result of this entry.  The new entries, are
   * considered children of the original entry, and will follow it.  When
   * the HAS_CHILDREN flag is set, the receiver should increment its stack
   * depth, and wait until an entry is provided with SVN_INVALID_REVNUM which
   * indicates the end of the children.
   *
   * For log operations which do not request additional merge information, the
   * HAS_CHILDREN flag is always FALSE.
   *
   * For more information see:
   * http://subversion.tigris.org/merge-tracking/design.html#commutative-reporting
   */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>has_children</name></decl>;</decl_stmt>
}</block></struct></type> <name>svn_log_entry_t</name>;</typedef>

<comment type="block">/**
 * Returns an @c svn_log_entry_t, allocated in @a pool with all fields
 * initialized to NULL values.
 *
 * @note To allow for extending the @c svn_log_entry_t structure in future
 * releases, this function should always be used to allocate the structure.
 *
 * @since New in 1.5.
 */</comment>
<function_decl><type><name>svn_log_entry_t</name> *</type>
<name>svn_log_entry_create</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/** The callback invoked by log message loopers, such as
 * @c svn_ra_plugin_t.get_log() and svn_repos_get_logs().
 *
 * This function is invoked once on each log message, in the order
 * determined by the caller (see above-mentioned functions).
 *
 * @a baton is what you think it is, and @a log_entry contains relevent
 * information for the log message.  Any of @a log_entry-&gt;author,
 * @a log_entry-&gt;date, or @a log_entry-&gt;message may be @c NULL.
 *
 * If @a log_entry-&gt;date is neither NULL nor the empty string, it was
 * generated by svn_time_to_cstring() and can be converted to
 * @c apr_time_t with svn_time_from_cstring().
 *
 * If @a log_entry-&gt;changed_paths is non-@c NULL, then it contains as keys
 * every path committed in @a log_entry-&gt;revision; the values are
 * (@c svn_log_changed_path_t *) structures.
 *
 * If @a log_entry-&gt;has_children is @c TRUE, the message will be followed
 * immediately by any number of merged revisions (child messages), which are
 * terminated by an invocation with SVN_INVALID_REVNUM.  This usage may
 * be recursive.
 *
 * Use @a pool for temporary allocation.  If the caller is iterating
 * over log messages, invoking this receiver on each, we recommend the
 * standard pool loop recipe: create a subpool, pass it as @a pool to
 * each call, clear it after each iteration, destroy it after the loop
 * is done.  (For allocation that must last beyond the lifetime of a
 * given receiver call, use a pool in @a baton.)
 *
 * @since New in 1.5.
 */</comment>

<typedef>typedef <function_decl><type><name>svn_error_t</name> *</type>(*<name>svn_log_entry_receiver_t</name>)
  <parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>,
   <param><decl><type><name>svn_log_entry_t</name> *</type><name>log_entry</name></decl></param>,
   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl></typedef>

<comment type="block">/**
 * Similar to @c svn_log_entry_receiver_t, except this uses separate
 * parameters for each part of the log entry.
 *
 * @deprecated Provided for backward compatibility with the 1.4 API.
 */</comment>
<typedef>typedef <function_decl><type><name>svn_error_t</name> *</type>(*<name>svn_log_message_receiver_t</name>)
  <parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>,
   <param><decl><type><name>apr_hash_t</name> *</type><name>changed_paths</name></decl></param>,
   <param><decl><type><name>svn_revnum_t</name></type> <name>revision</name></decl></param>,
   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>author</name></decl></param>,
   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>date</name></decl></param>,  <comment type="block">/* use svn_time_from_cstring() if need apr_time_t */</comment>
   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>message</name></decl></param>,
   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl></typedef>

<escape char="0xc"/>
<comment type="block">/** Callback function type for commits.
 *
 * When a commit succeeds, an instance of this is invoked with the
 * @a commit_info, along with the @a baton closure.
 * @a pool can be used for temporary allocations.
 *
 * @since New in 1.4.
 */</comment>
<typedef>typedef <function_decl><type><name>svn_error_t</name> *</type>(*<name>svn_commit_callback2_t</name>)
  <parameter_list>(<param><decl><type><specifier>const</specifier> <name>svn_commit_info_t</name> *</type><name>commit_info</name></decl></param>,
   <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>,
   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl></typedef>

<comment type="block">/** Same as @c svn_commit_callback2_t, but uses individual
 * data elements instead of the @c svn_commit_info_t structure
 *
 * @deprecated Provided for backward compatibility with the 1.3 API.
 */</comment>
<typedef>typedef <function_decl><type><name>svn_error_t</name> *</type>(*<name>svn_commit_callback_t</name>)
  <parameter_list>(<param><decl><type><name>svn_revnum_t</name></type> <name>new_revision</name></decl></param>,
   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>date</name></decl></param>,
   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>author</name></decl></param>,
   <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list>;</function_decl></typedef>

<escape char="0xc"/>
<comment type="block">/** A buffer size that may be used when processing a stream of data.
 *
 * @note We don't use this constant any longer, since it is considered to be
 * unnecessarily large.
 *
 * @deprecated Provided for backwards compatibility with the 1.3 API.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_STREAM_CHUNK_SIZE</name></cpp:macro> <cpp:value>102400</cpp:value></cpp:define>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>DOXYGEN_SHOULD_SKIP_THIS</name></cpp:ifndef>
<comment type="block">/*
 * The maximum amount we (ideally) hold in memory at a time when
 * processing a stream of data.
 *
 * For example, when copying data from one stream to another, do it in
 * blocks of this size.
 *
 * NOTE: This is an internal macro, put here for convenience.
 * No public API may depend on the particular value of this macro.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN__STREAM_CHUNK_SIZE</name></cpp:macro> <cpp:value>16384</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/** The maximum amount we can ever hold in memory. */</comment>
<comment type="block">/* FIXME: Should this be the same as SVN_STREAM_CHUNK_SIZE? */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_MAX_OBJECT_SIZE</name></cpp:macro> <cpp:value>(((apr_size_t) -1) / 2)</cpp:value></cpp:define>


<escape char="0xc"/>
<comment type="block">/* ### Note: despite being about mime-TYPES, these probably don't
 * ### belong in svn_types.h.  However, no other header is more
 * ### appropriate, and didn't feel like creating svn_validate.h for
 * ### so little.
 */</comment>

<comment type="block">/** Validate @a mime_type.
 *
 * If @a mime_type does not contain a "/", or ends with non-alphanumeric
 * data, return @c SVN_ERR_BAD_MIME_TYPE, else return success.
 *
 * Use @a pool only to find error allocation.
 *
 * Goal: to match both "foo/bar" and "foo/bar; charset=blah", without
 * being too strict about it, but to disallow mime types that have
 * quotes, newlines, or other garbage on the end, such as might be
 * unsafe in an HTTP header.
 */</comment>
<function_decl><type><name>svn_error_t</name> *</type><name>svn_mime_type_validate</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>mime_type</name></decl></param>,
                                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>


<comment type="block">/** Return FALSE iff @a mime_type is a textual type.
 *
 * All mime types that start with "text/" are textual, plus some special
 * cases (for example, "image/x-xbitmap").
 */</comment>
<function_decl><type><name>svn_boolean_t</name></type> <name>svn_mime_type_is_binary</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>mime_type</name></decl></param>)</parameter_list>;</function_decl>


<escape char="0xc"/>
<comment type="block">/** A user defined callback that subversion will call with a user defined
 * baton to see if the current operation should be continued.  If the operation
 * should continue, the function should return @c SVN_NO_ERROR, if not, it
 * should return @c SVN_ERR_CANCELLED.
 */</comment>
<typedef>typedef <function_decl><type><name>svn_error_t</name> *</type>(*<name>svn_cancel_func_t</name>)<parameter_list>(<param><decl><type><name>void</name> *</type><name>cancel_baton</name></decl></param>)</parameter_list>;</function_decl></typedef>


<escape char="0xc"/>
<comment type="block">/**
 * A lock object, for client &amp; server to share.
 *
 * A lock represents the exclusive right to add, delete, or modify a
 * path.  A lock is created in a repository, wholly controlled by the
 * repository.  A "lock-token" is the lock's UUID, and can be used to
 * learn more about a lock's fields, and or/make use of the lock.
 * Because a lock is immutable, a client is free to not only cache the
 * lock-token, but the lock's fields too, for convenience.
 *
 * Note that the 'is_dav_comment' field is wholly ignored by every
 * library except for mod_dav_svn.  The field isn't even marshalled
 * over the network to the client.  Assuming lock structures are
 * created with apr_pcalloc(), a default value of 0 is universally safe.
 *
 * @note in the current implementation, only files are lockable.
 *
 * @since New in 1.2.
 */</comment>
<typedef>typedef <type><struct>struct <name>svn_lock_t</name>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>              <comment type="block">/**&lt; the path this lock applies to */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>token</name></decl>;</decl_stmt>             <comment type="block">/**&lt; unique URI representing lock */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>owner</name></decl>;</decl_stmt>             <comment type="block">/**&lt; the username which owns the lock */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>comment</name></decl>;</decl_stmt>           <comment type="block">/**&lt; (optional) description of lock  */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>is_dav_comment</name></decl>;</decl_stmt>  <comment type="block">/**&lt; was comment made by generic DAV client? */</comment>
  <decl_stmt><decl><type><name>apr_time_t</name></type> <name>creation_date</name></decl>;</decl_stmt>      <comment type="block">/**&lt; when lock was made */</comment>
  <decl_stmt><decl><type><name>apr_time_t</name></type> <name>expiration_date</name></decl>;</decl_stmt>    <comment type="block">/**&lt; (optional) when lock will expire;
                                      If value is 0, lock will never expire. */</comment>
}</block></struct></type> <name>svn_lock_t</name>;</typedef>

<comment type="block">/**
 * Returns an @c svn_lock_t, allocated in @a pool with all fields initialized
 * to NULL values.
 *
 * @note To allow for extending the @c svn_lock_t structure in the future
 * releases, this function should always be used to allocate the structure.
 *
 * @since New in 1.2.
 */</comment>
<function_decl><type><name>svn_lock_t</name> *</type>
<name>svn_lock_create</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Return a deep copy of @a lock, allocated in @a pool.
 *
 * @since New in 1.2.
 */</comment>
<function_decl><type><name>svn_lock_t</name> *</type>
<name>svn_lock_dup</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>svn_lock_t</name> *</type><name>lock</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Return a formatted Universal Unique IDentifier (UUID) string.
 *
 * @since New in 1.4.
 */</comment>
<function_decl><type><specifier>const</specifier> <name>char</name> *</type>
<name>svn_uuid_generate</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Mergeinfo representing a merge of a range of revisions.
 *
 * @since New in 1.5
 */</comment>
<typedef>typedef <type><struct>struct <name>svn_merge_range_t</name>
<block>{
  <comment type="block">/* If the 'start' field is less than the 'end' field then 'start' is
   * exclusive and 'end' inclusive of the range described.  If 'start'
   * is greater than 'end' then the opposite is true.  If 'start'
   * equals 'end' the meaning of the range is not defined.
   */</comment>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>start</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>end</name></decl>;</decl_stmt>

  <comment type="block">/* Whether this merge range should be inherited by treewise
     descendants of the path to which the range applies. */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>inheritable</name></decl>;</decl_stmt>
}</block></struct></type> <name>svn_merge_range_t</name>;</typedef>

<comment type="block">/**
 * Return a copy of @a range, allocated in @a pool.
 *
 * @since New in 1.5.
 */</comment>
<function_decl><type><name>svn_merge_range_t</name> *</type>
<name>svn_merge_range_dup</name><parameter_list>(<param><decl><type><name>svn_merge_range_t</name> *</type><name>range</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Returns true if the changeset committed in revision @a rev is one
 * of the changesets in the range @a range.
 *
 * @since New in 1.5.
 */</comment>
<function_decl><type><name>svn_boolean_t</name></type>
<name>svn_merge_range_contains_rev</name><parameter_list>(<param><decl><type><name>svn_merge_range_t</name> *</type><name>range</name></decl></param>, <param><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl></param>)</parameter_list>;</function_decl>


<escape char="0xc"/>
<comment type="block">/** @defgroup node_location_seg_reporting Node location segment reporting.
 *  @{ */</comment>

<comment type="block">/**
 * A representation of a segment of a object's version history with an
 * emphasis on the object's location in the repository as of various
 * revisions.
 *
 * @since New in 1.5.
 */</comment>
<typedef>typedef <type><struct>struct <name>svn_location_segment_t</name>
<block>{
  <comment type="block">/* The beginning (oldest) and ending (youngest) revisions for this
     segment. */</comment>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>range_start</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>range_end</name></decl>;</decl_stmt>

  <comment type="block">/* The absolute (sans leading slash) path for this segment.  May be
     NULL to indicate gaps in an object's history.  */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>

}</block></struct></type> <name>svn_location_segment_t</name>;</typedef>


<comment type="block">/**
 * A callback invoked by generators of @c svn_location_segment_t
 * objects, used to report information about a versioned object's
 * history in terms of its location in the repository filesystem over
 * time.
 */</comment>
<typedef>typedef <function_decl><type><name>svn_error_t</name> *</type>(*<name>svn_location_segment_receiver_t</name>)
  <parameter_list>(<param><decl><type><name>svn_location_segment_t</name> *</type><name>segment</name></decl></param>,
   <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>,
   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl></typedef>


<comment type="block">/**
 * Return a deep copy of @a segment, allocated in @a pool.
 *
 * @since New in 1.5.
 */</comment>
<function_decl><type><name>svn_location_segment_t</name> *</type>
<name>svn_location_segment_dup</name><parameter_list>(<param><decl><type><name>svn_location_segment_t</name> *</type><name>segment</name></decl></param>,
                         <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>
<comment type="block">/** @} */</comment>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
}</block></extern>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* __cplusplus */</comment>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* SVN_TYPES_H */</comment>
</unit>
