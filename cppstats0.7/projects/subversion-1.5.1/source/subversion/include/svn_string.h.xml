<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/subversion-1.5.1/source/subversion/include/svn_string.h"><comment type="block">/**
 * @copyright
 * ====================================================================
 * Copyright (c) 2000-2006 CollabNet.  All rights reserved.
 *
 * This software is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at http://subversion.tigris.org/license-1.html.
 * If newer versions of this license are posted there, you may use a
 * newer version instead, at your option.
 *
 * This software consists of voluntary contributions made by many
 * individuals.  For exact contribution history, see the revision
 * history and logs, available at http://subversion.tigris.org/.
 * ====================================================================
 * @endcopyright
 *
 * @file svn_string.h
 * @brief Counted-length strings for Subversion, plus some C string goodies.
 *
 * There are two string datatypes: @c svn_string_t and @c svn_stringbuf_t.
 * The former is a simple pointer/length pair useful for passing around
 * strings (or arbitrary bytes) with a counted length. @c svn_stringbuf_t is
 * buffered to enable efficient appending of strings without an allocation
 * and copy for each append operation.
 *
 * @c svn_string_t contains a &lt;tt&gt;const char *&lt;/tt&gt; for its data, so it is
 * most appropriate for constant data and for functions which expect constant,
 * counted data. Functions should generally use &lt;tt&gt;const @c svn_string_t
 * *&lt;/tt&gt; as their parameter to indicate they are expecting a constant,
 * counted string.
 *
 * @c svn_stringbuf_t uses a plain &lt;tt&gt;char *&lt;/tt&gt; for its data, so it is
 * most appropriate for modifiable data.
 *
 * &lt;h3&gt;Invariants&lt;/h3&gt;
 *
 *   1. Null termination:
 *
 *      Both structures maintain a significant invariant:
 *
 *         &lt;tt&gt;s-&gt;data[s-&gt;len] == '\\0'&lt;/tt&gt;
 *
 *      The functions defined within this header file will maintain
 *      the invariant (which does imply that memory is
 *      allocated/defined as @c len+1 bytes).  If code outside of the
 *      @c svn_string.h functions manually builds these structures,
 *      then they must enforce this invariant.
 *
 *      Note that an @c svn_string(buf)_t may contain binary data,
 *      which means that strlen(s-&gt;data) does not have to equal @c
 *      s-&gt;len. The NULL terminator is provided to make it easier to
 *      pass @c s-&gt;data to C string interfaces.
 *
 *
 *   2. Non-NULL input:
 *
 *      All the functions assume their input data is non-NULL,
 *      unless otherwise documented, and may seg fault if passed
 *      NULL.  The input data may *contain* null bytes, of course, just
 *      the data pointer itself must not be NULL.
 */</comment>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SVN_STRING_H</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_STRING_H</name></cpp:macro></cpp:define>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_tables.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_pools.h&gt;</cpp:file></cpp:include>       <comment type="block">/* APR memory pools for everyone. */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_strings.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_types.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
<extern>extern "C" <block>{
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* __cplusplus */</comment>

<comment type="block">/**
 * @defgroup svn_string String handling
 * @{
 */</comment>

<escape char="0xc"/>

<comment type="block">/** A simple counted string. */</comment>
<typedef>typedef <type><struct>struct <name>svn_string_t</name>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name></decl>;</decl_stmt> <comment type="block">/**&lt; pointer to the bytestring */</comment>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name></decl>;</decl_stmt>   <comment type="block">/**&lt; length of bytestring */</comment>
}</block></struct></type> <name>svn_string_t</name>;</typedef>

<comment type="block">/** A buffered string, capable of appending without an allocation and copy
 * for each append. */</comment>
<typedef>typedef <type><struct>struct <name>svn_stringbuf_t</name>
<block>{
  <comment type="block">/** a pool from which this string was originally allocated, and is not
   * necessarily specific to this string.  This is used only for allocating
   * more memory from when the string needs to grow.
   */</comment>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>

  <comment type="block">/** pointer to the bytestring */</comment>
  <decl_stmt><decl><type><name>char</name> *</type><name>data</name></decl>;</decl_stmt>

  <comment type="block">/** length of bytestring */</comment>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name></decl>;</decl_stmt>

  <comment type="block">/** total size of buffer allocated */</comment>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>blocksize</name></decl>;</decl_stmt>
}</block></struct></type> <name>svn_stringbuf_t</name>;</typedef>

<escape char="0xc"/>
<comment type="block">/** svn_string_t functions.
 *
 * @defgroup svn_string_svn_string_t svn_string_t functions
 * @{
 */</comment>

<comment type="block">/** Create a new bytestring containing a C string (NULL-terminated). */</comment>
<function_decl><type><name>svn_string_t</name> *</type><name>svn_string_create</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>cstring</name></decl></param>,
                                <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/** Create a new bytestring containing a generic string of bytes
 * (NOT NULL-terminated) */</comment>
<function_decl><type><name>svn_string_t</name> *</type><name>svn_string_ncreate</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>bytes</name></decl></param>,
                                 <param><decl><type><name>apr_size_t</name></type> <name>size</name></decl></param>,
                                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/** Create a new string with the contents of the given stringbuf */</comment>
<function_decl><type><name>svn_string_t</name> *</type><name>svn_string_create_from_buf</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>svn_stringbuf_t</name> *</type><name>strbuf</name></decl></param>,
                                         <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/** Create a new bytestring by formatting @a cstring (NULL-terminated)
 * from varargs, which are as appropriate for apr_psprintf().
 */</comment>
<function_decl><type><name>svn_string_t</name> *</type><name>svn_string_createf</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fmt</name></decl></param>,
                                 <param><decl><type>...</type></decl></param>)</parameter_list>
  __attribute__<parameter_list>(<param/></parameter_list>(format<parameter_list>(<param><decl><type><name>printf</name></type></decl></param>, <param/></parameter_list>2, 3</function_decl>)</block></extern>))<empty_stmt>;</empty_stmt>

<comment type="block">/** Create a new bytestring by formatting @a cstring (NULL-terminated)
 * from a @c va_list (see svn_stringbuf_createf()).
 */</comment>
<function_decl><type><name>svn_string_t</name> *</type><name>svn_string_createv</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fmt</name></decl></param>,
                                 <param><decl><type><name>va_list</name></type> <name>ap</name></decl></param>)</parameter_list>
  __attribute__<parameter_list>(<param/></parameter_list>(format<parameter_list>(<param><decl><type><name>printf</name></type></decl></param>, <param/></parameter_list>2, 0</function_decl>)))<empty_stmt>;</empty_stmt>

<comment type="block">/** Return TRUE if a bytestring is empty (has length zero). */</comment>
<function_decl><type><name>svn_boolean_t</name></type> <name>svn_string_isempty</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>str</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/** Return a duplicate of @a original_string. */</comment>
<function_decl><type><name>svn_string_t</name> *</type><name>svn_string_dup</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>original_string</name></decl></param>,
                             <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/** Return @c TRUE iff @a str1 and @a str2 have identical length and data. */</comment>
<function_decl><type><name>svn_boolean_t</name></type> <name>svn_string_compare</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>str1</name></decl></param>,
                                 <param><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>str2</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/** Return offset of first non-whitespace character in @a str, or return
 * @a str-&gt;len if none.
 */</comment>
<function_decl><type><name>apr_size_t</name></type> <name>svn_string_first_non_whitespace</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>str</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/** Return position of last occurrence of @a ch in @a str, or return
 * @a str-&gt;len if no occurrence.
 */</comment>
<function_decl><type><name>apr_size_t</name></type> <name>svn_string_find_char_backward</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>str</name></decl></param>, <param><decl><type><name>char</name></type> <name>ch</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/** @} */</comment>

<escape char="0xc"/>
<comment type="block">/** svn_stringbuf_t functions.
 *
 * @defgroup svn_string_svn_stringbuf_t svn_stringbuf_t functions
 * @{
 */</comment>

<comment type="block">/** Create a new bytestring containing a C string (NULL-terminated). */</comment>
<function_decl><type><name>svn_stringbuf_t</name> *</type><name>svn_stringbuf_create</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>cstring</name></decl></param>,
                                      <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>
<comment type="block">/** Create a new bytestring containing a generic string of bytes
 * (NON-NULL-terminated)
 */</comment>
<function_decl><type><name>svn_stringbuf_t</name> *</type><name>svn_stringbuf_ncreate</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>bytes</name></decl></param>,
                                       <param><decl><type><name>apr_size_t</name></type> <name>size</name></decl></param>,
                                       <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/** Create a new stringbuf with the contents of the given string */</comment>
<function_decl><type><name>svn_stringbuf_t</name> *</type><name>svn_stringbuf_create_from_string</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>str</name></decl></param>,
                                                  <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/** Create a new bytestring by formatting @a cstring (NULL-terminated)
 * from varargs, which are as appropriate for apr_psprintf().
 */</comment>
<function_decl><type><name>svn_stringbuf_t</name> *</type><name>svn_stringbuf_createf</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                                       <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fmt</name></decl></param>,
                                       <param><decl><type>...</type></decl></param>)</parameter_list>
  __attribute__<parameter_list>(<param/></parameter_list>(format<parameter_list>(<param><decl><type><name>printf</name></type></decl></param>, <param/></parameter_list>2, 3</function_decl>)))<empty_stmt>;</empty_stmt>

<comment type="block">/** Create a new bytestring by formatting @a cstring (NULL-terminated)
 * from a @c va_list (see svn_stringbuf_createf()).
 */</comment>
<function_decl><type><name>svn_stringbuf_t</name> *</type><name>svn_stringbuf_createv</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                                       <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fmt</name></decl></param>,
                                       <param><decl><type><name>va_list</name></type> <name>ap</name></decl></param>)</parameter_list>
  __attribute__<parameter_list>(<param/></parameter_list>(format<parameter_list>(<param><decl><type><name>printf</name></type></decl></param>, <param/></parameter_list>2, 0</function_decl>)))<empty_stmt>;</empty_stmt>

<comment type="block">/** Make sure that the string @a str has at least @a minimum_size bytes of
 * space available in the memory block.
 *
 * (@a minimum_size should include space for the terminating NULL character.)
 */</comment>
<function_decl><type><name>void</name></type> <name>svn_stringbuf_ensure</name><parameter_list>(<param><decl><type><name>svn_stringbuf_t</name> *</type><name>str</name></decl></param>,
                          <param><decl><type><name>apr_size_t</name></type> <name>minimum_size</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/** Set a bytestring @a str to @a value */</comment>
<function_decl><type><name>void</name></type> <name>svn_stringbuf_set</name><parameter_list>(<param><decl><type><name>svn_stringbuf_t</name> *</type><name>str</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>value</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/** Set a bytestring @a str to empty (0 length). */</comment>
<function_decl><type><name>void</name></type> <name>svn_stringbuf_setempty</name><parameter_list>(<param><decl><type><name>svn_stringbuf_t</name> *</type><name>str</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/** Return @c TRUE if a bytestring is empty (has length zero). */</comment>
<function_decl><type><name>svn_boolean_t</name></type> <name>svn_stringbuf_isempty</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>svn_stringbuf_t</name> *</type><name>str</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/** Chop @a nbytes bytes off end of @a str, but not more than @a str-&gt;len. */</comment>
<function_decl><type><name>void</name></type> <name>svn_stringbuf_chop</name><parameter_list>(<param><decl><type><name>svn_stringbuf_t</name> *</type><name>str</name></decl></param>, <param><decl><type><name>apr_size_t</name></type> <name>nbytes</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/** Fill bytestring @a str with character @a c. */</comment>
<function_decl><type><name>void</name></type> <name>svn_stringbuf_fillchar</name><parameter_list>(<param><decl><type><name>svn_stringbuf_t</name> *</type><name>str</name></decl></param>, <param><decl><type><name>unsigned</name> <name>char</name></type> <name>c</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/** Append an array of bytes onto @a targetstr.
 *
 * reallocs if necessary. @a targetstr is affected, nothing else is.
 */</comment>
<function_decl><type><name>void</name></type> <name>svn_stringbuf_appendbytes</name><parameter_list>(<param><decl><type><name>svn_stringbuf_t</name> *</type><name>targetstr</name></decl></param>,
                               <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>bytes</name></decl></param>,
                               <param><decl><type><name>apr_size_t</name></type> <name>count</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/** Append an @c svn_stringbuf_t onto @a targetstr.
 *
 * reallocs if necessary. @a targetstr is affected, nothing else is.
 */</comment>
<function_decl><type><name>void</name></type> <name>svn_stringbuf_appendstr</name><parameter_list>(<param><decl><type><name>svn_stringbuf_t</name> *</type><name>targetstr</name></decl></param>,
                             <param><decl><type><specifier>const</specifier> <name>svn_stringbuf_t</name> *</type><name>appendstr</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/** Append a C string onto @a targetstr.
 *
 * reallocs if necessary. @a targetstr is affected, nothing else is.
 */</comment>
<function_decl><type><name>void</name></type> <name>svn_stringbuf_appendcstr</name><parameter_list>(<param><decl><type><name>svn_stringbuf_t</name> *</type><name>targetstr</name></decl></param>,
                              <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>cstr</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/** Return a duplicate of @a original_string. */</comment>
<function_decl><type><name>svn_stringbuf_t</name> *</type><name>svn_stringbuf_dup</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>svn_stringbuf_t</name> *</type><name>original_string</name></decl></param>,
                                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>


<comment type="block">/** Return @c TRUE iff @a str1 and @a str2 have identical length and data. */</comment>
<function_decl><type><name>svn_boolean_t</name></type> <name>svn_stringbuf_compare</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>svn_stringbuf_t</name> *</type><name>str1</name></decl></param>,
                                    <param><decl><type><specifier>const</specifier> <name>svn_stringbuf_t</name> *</type><name>str2</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/** Return offset of first non-whitespace character in @a str, or return
 * @a str-&gt;len if none.
 */</comment>
<function_decl><type><name>apr_size_t</name></type> <name>svn_stringbuf_first_non_whitespace</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>svn_stringbuf_t</name> *</type><name>str</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/** Strip whitespace from both sides of @a str (modified in place). */</comment>
<function_decl><type><name>void</name></type> <name>svn_stringbuf_strip_whitespace</name><parameter_list>(<param><decl><type><name>svn_stringbuf_t</name> *</type><name>str</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/** Return position of last occurrence of @a ch in @a str, or return
 * @a str-&gt;len if no occurrence.
 */</comment>
<function_decl><type><name>apr_size_t</name></type> <name>svn_stringbuf_find_char_backward</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>svn_stringbuf_t</name> *</type><name>str</name></decl></param>,
                                            <param><decl><type><name>char</name></type> <name>ch</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/** Return @c TRUE iff @a str1 and @a str2 have identical length and data. */</comment>
<function_decl><type><name>svn_boolean_t</name></type> <name>svn_string_compare_stringbuf</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>str1</name></decl></param>,
                                           <param><decl><type><specifier>const</specifier> <name>svn_stringbuf_t</name> *</type><name>str2</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/** @} */</comment>

<escape char="0xc"/>
<comment type="block">/** C strings.
 *
 * @defgroup svn_string_cstrings c string functions
 * @{
 */</comment>

<comment type="block">/** Divide @a input into substrings along @a sep_chars boundaries, return an
 * array of copies of those substrings, allocating both the array and
 * the copies in @a pool.
 *
 * None of the elements added to the array contain any of the
 * characters in @a sep_chars, and none of the new elements are empty
 * (thus, it is possible that the returned array will have length
 * zero).
 *
 * If @a chop_whitespace is TRUE, then remove leading and trailing
 * whitespace from the returned strings.
 */</comment>
<function_decl><type><name>apr_array_header_t</name> *</type><name>svn_cstring_split</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>input</name></decl></param>,
                                      <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>sep_chars</name></decl></param>,
                                      <param><decl><type><name>svn_boolean_t</name></type> <name>chop_whitespace</name></decl></param>,
                                      <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/** Like svn_cstring_split(), but append to existing @a array instead of
 * creating a new one.  Allocate the copied substrings in @a pool
 * (i.e., caller decides whether or not to pass @a array-&gt;pool as @a pool).
 */</comment>
<function_decl><type><name>void</name></type> <name>svn_cstring_split_append</name><parameter_list>(<param><decl><type><name>apr_array_header_t</name> *</type><name>array</name></decl></param>,
                              <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>input</name></decl></param>,
                              <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>sep_chars</name></decl></param>,
                              <param><decl><type><name>svn_boolean_t</name></type> <name>chop_whitespace</name></decl></param>,
                              <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>


<comment type="block">/** Return @c TRUE iff @a str matches any of the elements of @a list, a list
 * of zero or more glob patterns.
 */</comment>
<function_decl><type><name>svn_boolean_t</name></type> <name>svn_cstring_match_glob_list</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>str</name></decl></param>,
                                          <param><decl><type><name>apr_array_header_t</name> *</type><name>list</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Return the number of line breaks in @a msg, allowing any kind of newline
 * termination (CR, LF, CRLF, or LFCR), even inconsistent.
 *
 * @since New in 1.2.
 */</comment>
<function_decl><type><name>int</name></type> <name>svn_cstring_count_newlines</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>msg</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Return a cstring which is the concatenation of @a strings (an array
 * of char *) each followed by @a separator (that is, @a separator
 * will also end the resulting string).  Allocate the result in @a pool.
 * If @a strings is empty, then return the empty string.
 *
 * @since New in 1.2.
 */</comment>
<function_decl><type><name>char</name> *</type>
<name>svn_cstring_join</name><parameter_list>(<param><decl><type><name>apr_array_header_t</name> *</type><name>strings</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>separator</name></decl></param>,
                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>

<comment type="block">/**
 * Compare two strings @a atr1 and @a atr2, treating case-equivalent
 * unaccented Latin (ASCII subset) letters as equal.
 *
 * @since New in 1.5.
 */</comment>
<function_decl><type><name>int</name></type> <name>svn_cstring_casecmp</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>str1</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>str2</name></decl></param>)</parameter_list>;</function_decl>


<comment type="block">/** @} */</comment>

<comment type="block">/** @} */</comment>

<escape char="0xc"/>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__cplusplus</name></cpp:ifdef>
}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* __cplusplus */</comment>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>  <comment type="block">/* SVN_STRING_H */</comment>
</unit>
