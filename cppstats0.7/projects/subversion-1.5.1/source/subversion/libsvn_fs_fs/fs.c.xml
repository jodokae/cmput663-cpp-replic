<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/subversion-1.5.1/source/subversion/libsvn_fs_fs/fs.c"><comment type="block">/* fs.c --- creating, opening and closing filesystems
 *
 * ====================================================================
 * Copyright (c) 2000-2007 CollabNet.  All rights reserved.
 *
 * This software is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at http://subversion.tigris.org/license-1.html.
 * If newer versions of this license are posted there, you may use a
 * newer version instead, at your option.
 *
 * This software consists of voluntary contributions made by many
 * individuals.  For exact contribution history, see the revision
 * history and logs, available at http://subversion.tigris.org/.
 * ====================================================================
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_general.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_pools.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_file_io.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_thread_mutex.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_fs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_delta.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_version.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_pools.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"err.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fs_fs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_private_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"private/svn_fs_util.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../libsvn_fs/fs-loader.h"</cpp:file></cpp:include>

<comment type="block">/* A prefix for the pool userdata variables used to hold
   per-filesystem shared data.  See fs_serialized_init. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_FSFS_SHARED_USERDATA_PREFIX</name></cpp:macro> <cpp:value>"svn-fsfs-shared-"</cpp:value></cpp:define>

<escape char="0xc"/>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>fs_serialized_init</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>common_pool</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>fs_fs_data_t</name> *</type><name>ffd</name> <init>= <expr><name><name>fs</name>-&gt;<name>fsap_data</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>key</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>fs_fs_shared_data_t</name> *</type><name>ffsd</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name></decl>;</decl_stmt>

  <comment type="block">/* Note that we are allocating a small amount of long-lived data for
     each separate repository opened during the lifetime of the
     svn_fs_initialize pool.  It's unlikely that anyone will notice
     the modest expenditure; the alternative is to allocate each structure
     in a subpool, add a reference-count, and add a serialized deconstructor
     to the FS vtable.  That's more machinery than it's worth.

     Using the uuid to obtain the lock creates a corner case if a
     caller uses svn_fs_set_uuid on the repository in a process where
     other threads might be using the same repository through another
     FS object.  The only real-world consumer of svn_fs_set_uuid is
     "svnadmin load", so this is a low-priority problem, and we don't
     know of a better way of associating such data with the
     repository. */</comment>

  <expr_stmt><expr><name>key</name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>SVN_FSFS_SHARED_USERDATA_PREFIX</name></expr></argument>, <argument><expr><name><name>ffd</name>-&gt;<name>uuid</name></name></expr></argument>,
                    <argument><expr>(<name>char</name> *) <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>status</name> = <call><name>apr_pool_userdata_get</name><argument_list>(<argument><expr>&amp;<name>val</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>common_pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>status</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_wrap_apr</name><argument_list>(<argument><expr><name>status</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't fetch FSFS shared data"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
  <expr_stmt><expr><name>ffsd</name> = <name>val</name></expr>;</expr_stmt>

  <if>if <condition>(<expr>!<name>ffsd</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>ffsd</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>common_pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>ffsd</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>ffsd</name>-&gt;<name>common_pool</name></name> = <name>common_pool</name></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAS_THREADS</name></expr></cpp:if>
      <comment type="block">/* POSIX fcntl locks are per-process, so we need a mutex for
         intra-process synchronization when grabbing the repository write
         lock. */</comment>
      <expr_stmt><expr><name>status</name> = <call><name>apr_thread_mutex_create</name><argument_list>(<argument><expr>&amp;<name><name>ffsd</name>-&gt;<name>fs_write_lock</name></name></expr></argument>,
                                       <argument><expr><name>APR_THREAD_MUTEX_DEFAULT</name></expr></argument>, <argument><expr><name>common_pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>status</name></expr>)</condition><then>
        <return>return <expr><call><name>svn_error_wrap_apr</name><argument_list>(<argument><expr><name>status</name></expr></argument>,
                                  <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't create FSFS write-lock mutex"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

      <comment type="block">/* We also need a mutex for synchronising access to the active
         transaction list and free transaction pointer. */</comment>
      <expr_stmt><expr><name>status</name> = <call><name>apr_thread_mutex_create</name><argument_list>(<argument><expr>&amp;<name><name>ffsd</name>-&gt;<name>txn_list_lock</name></name></expr></argument>,
                                       <argument><expr><name>APR_THREAD_MUTEX_DEFAULT</name></expr></argument>, <argument><expr><name>common_pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>status</name></expr>)</condition><then>
        <return>return <expr><call><name>svn_error_wrap_apr</name><argument_list>(<argument><expr><name>status</name></expr></argument>,
                                  <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't create FSFS txn list mutex"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

      <comment type="block">/* ... not to mention locking the txn-current file. */</comment>
      <expr_stmt><expr><name>status</name> = <call><name>apr_thread_mutex_create</name><argument_list>(<argument><expr>&amp;<name><name>ffsd</name>-&gt;<name>txn_current_lock</name></name></expr></argument>,
                                       <argument><expr><name>APR_THREAD_MUTEX_DEFAULT</name></expr></argument>, <argument><expr><name>common_pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>status</name></expr>)</condition><then>
        <return>return <expr><call><name>svn_error_wrap_apr</name><argument_list>(<argument><expr><name>status</name></expr></argument>,
                                  <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't create FSFS txn-current mutex"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

      <expr_stmt><expr><name>key</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>common_pool</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>status</name> = <call><name>apr_pool_userdata_set</name><argument_list>(<argument><expr><name>ffsd</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>common_pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>status</name></expr>)</condition><then>
        <return>return <expr><call><name>svn_error_wrap_apr</name><argument_list>(<argument><expr><name>status</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't store FSFS shared data"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
    }</block></then></if>

  <expr_stmt><expr><name><name>ffd</name>-&gt;<name>shared</name></name> = <name>ffsd</name></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<escape char="0xc"/>

<comment type="block">/* This function is provided for Subversion 1.0.x compatibility.  It
   has no effect for fsfs backed Subversion filesystems.  It conforms
   to the fs_library_vtable_t.bdb_set_errcall() API. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>fs_set_errcall</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
               <param><function_decl><type><name>void</name></type> (*<name>db_errcall_fcn</name>)<parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>errpfx</name></decl></param>, <param><decl><type><name>char</name> *</type><name>msg</name></decl></param>)</parameter_list></function_decl></param>)</parameter_list>
<block>{

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<escape char="0xc"/>

<comment type="block">/* The vtable associated with a specific open filesystem. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>fs_vtable_t</name></type> <name>fs_vtable</name> <init>= <expr><block>{
  <expr><name>svn_fs_fs__youngest_rev</name></expr>,
  <expr><name>svn_fs_fs__revision_prop</name></expr>,
  <expr><name>svn_fs_fs__revision_proplist</name></expr>,
  <expr><name>svn_fs_fs__change_rev_prop</name></expr>,
  <expr><name>svn_fs_fs__get_uuid</name></expr>,
  <expr><name>svn_fs_fs__set_uuid</name></expr>,
  <expr><name>svn_fs_fs__revision_root</name></expr>,
  <expr><name>svn_fs_fs__begin_txn</name></expr>,
  <expr><name>svn_fs_fs__open_txn</name></expr>,
  <expr><name>svn_fs_fs__purge_txn</name></expr>,
  <expr><name>svn_fs_fs__list_transactions</name></expr>,
  <expr><name>svn_fs_fs__deltify</name></expr>,
  <expr><name>svn_fs_fs__lock</name></expr>,
  <expr><name>svn_fs_fs__generate_lock_token</name></expr>,
  <expr><name>svn_fs_fs__unlock</name></expr>,
  <expr><name>svn_fs_fs__get_lock</name></expr>,
  <expr><name>svn_fs_fs__get_locks</name></expr>,
  <expr><name>fs_set_errcall</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<escape char="0xc"/>
<comment type="block">/* Creating a new filesystem. */</comment>

<comment type="block">/* Set up vtable and fsap_data fields in FS. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>initialize_fs_struct</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>fs_fs_data_t</name> *</type><name>ffd</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name><name>fs</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>ffd</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>fs</name>-&gt;<name>vtable</name></name> = &amp;<name>fs_vtable</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fs</name>-&gt;<name>fsap_data</name></name> = <name>ffd</name></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>ffd</name>-&gt;<name>rev_root_id_cache_pool</name></name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name><name>fs</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ffd</name>-&gt;<name>rev_root_id_cache</name></name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name><name>ffd</name>-&gt;<name>rev_root_id_cache_pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>ffd</name>-&gt;<name>rev_node_cache</name></name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name><name>fs</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ffd</name>-&gt;<name>rev_node_list</name>.<name>prev</name></name> = &amp;<name><name>ffd</name>-&gt;<name>rev_node_list</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ffd</name>-&gt;<name>rev_node_list</name>.<name>next</name></name> = &amp;<name><name>ffd</name>-&gt;<name>rev_node_list</name></name></expr>;</expr_stmt>
}</block></function>

<comment type="block">/* This implements the fs_library_vtable_t.create() API.  Create a new
   fsfs-backed Subversion filesystem at path PATH and link it into
   *FS.  Perform temporary allocations in POOL, and fs-global allocations
   in COMMON_POOL. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>fs_create</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
          <param><decl><type><name>apr_pool_t</name> *</type><name>common_pool</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs__check_fs</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>initialize_fs_struct</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__create</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>fs_serialized_init</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>common_pool</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<escape char="0xc"/>
<comment type="block">/* Gaining access to an existing filesystem.  */</comment>

<comment type="block">/* This implements the fs_library_vtable_t.open() API.  Open an FSFS
   Subversion filesystem located at PATH, set *FS to point to the
   correct vtable for the filesystem.  Use POOL for any temporary
   allocations, and COMMON_POOL for fs-global allocations. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>fs_open</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
        <param><decl><type><name>apr_pool_t</name> *</type><name>common_pool</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>initialize_fs_struct</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__open</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>fs_serialized_init</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>common_pool</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<escape char="0xc"/>

<comment type="block">/* This implements the fs_library_vtable_t.open_for_recovery() API. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>fs_open_for_recovery</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                     <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                     <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>common_pool</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* Recovery for FSFS is currently limited to recreating the current
     file from the latest revision. */</comment>

  <comment type="block">/* The only thing we have to watch out for is that the current file
     might not exist.  So we'll try to create it here unconditionally,
     and just ignore any errors that might indicate that it's already
     present. (We'll need it to exist later anyway as a source for the
     new file's permissions). */</comment>

  <comment type="block">/* Use a partly-filled fs pointer first to create current.  This will fail
     if current already exists, but we don't care about that. */</comment>
  <expr_stmt><expr><name><name>fs</name>-&gt;<name>path</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>fs</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><call><name>svn_io_file_create</name><argument_list>(<argument><expr><call><name>svn_fs_fs__path_current</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                                     <argument><expr>"0 1 1\n"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Now open the filesystem properly by calling the vtable method directly. */</comment>
  <return>return <expr><call><name>fs_open</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>common_pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<escape char="0xc"/>

<comment type="block">/* This implements the fs_library_vtable_t.uprade_fs() API. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>fs_upgrade</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
           <param><decl><type><name>apr_pool_t</name> *</type><name>common_pool</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs__check_fs</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>initialize_fs_struct</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__open</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>fs_serialized_init</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>common_pool</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>svn_fs_fs__upgrade</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<escape char="0xc"/>

<comment type="block">/* This implements the fs_library_vtable_t.hotcopy() API.  Copy a
   possibly live Subversion filesystem from SRC_PATH to DEST_PATH.
   The CLEAN_LOGS argument is ignored and included for Subversion
   1.0.x compatibility.  Perform all temporary allocations in POOL. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>fs_hotcopy</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>src_path</name></decl></param>,
           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dest_path</name></decl></param>,
           <param><decl><type><name>svn_boolean_t</name></type> <name>clean_logs</name></decl></param>,
           <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>svn_fs_fs__hotcopy</name><argument_list>(<argument><expr><name>src_path</name></expr></argument>, <argument><expr><name>dest_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<escape char="0xc"/>

<comment type="block">/* This function is included for Subversion 1.0.x compatibility.  It
   has no effect for fsfs backed Subversion filesystems.  It conforms
   to the fs_library_vtable_t.bdb_logfiles() API. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>fs_logfiles</name><parameter_list>(<param><decl><type><name>apr_array_header_t</name> **</type><name>logfiles</name></decl></param>,
            <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
            <param><decl><type><name>svn_boolean_t</name></type> <name>only_unused</name></decl></param>,
            <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* A no-op for FSFS. */</comment>
  <expr_stmt><expr>*<name>logfiles</name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>const <name>char</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>



<escape char="0xc"/>

<comment type="block">/* Delete the filesystem located at path PATH.  Perform any temporary
   allocations in POOL. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>fs_delete_fs</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
             <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* Remove everything. */</comment>
  <return>return <expr><call><name>svn_io_remove_dir2</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>svn_version_t</name> *</type>
<name>fs_version</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><name>SVN_VERSION_BODY</name></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type>
<name>fs_get_description</name><parameter_list>(<param><decl><type><name>void</name></type></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>_</name><argument_list>(<argument><expr>"Module for working with a plain file (FSFS) repository."</expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<escape char="0xc"/>
<comment type="block">/* Base FS library vtable, used by the FS loader library. */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>fs_library_vtable_t</name></type> <name>library_vtable</name> <init>= <expr><block>{
  <expr><name>fs_version</name></expr>,
  <expr><name>fs_create</name></expr>,
  <expr><name>fs_open</name></expr>,
  <expr><name>fs_open_for_recovery</name></expr>,
  <expr><name>fs_upgrade</name></expr>,
  <expr><name>fs_delete_fs</name></expr>,
  <expr><name>fs_hotcopy</name></expr>,
  <expr><name>fs_get_description</name></expr>,
  <expr><name>svn_fs_fs__recover</name></expr>,
  <expr><name>fs_logfiles</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__init</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>svn_version_t</name> *</type><name>loader_version</name></decl></param>,
                <param><decl><type><name>fs_library_vtable_t</name> **</type><name>vtable</name></decl></param>, <param><decl><type><name>apr_pool_t</name>*</type> <name>common_pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>svn_version_checklist_t</name></type> <name><name>checklist</name><index>[]</index></name> <init>=
    <expr><block>{
      <expr><block>{ <expr>"svn_subr"</expr>,  <expr><name>svn_subr_version</name></expr> }</block></expr>,
      <expr><block>{ <expr>"svn_delta"</expr>, <expr><name>svn_delta_version</name></expr> }</block></expr>,
      <expr><block>{ <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr> }</block></expr>
    }</block></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Simplified version check to make sure we can safely use the
     VTABLE parameter. The FS loader does a more exhaustive check. */</comment>
  <if>if <condition>(<expr><name><name>loader_version</name>-&gt;<name>major</name></name> != <name>SVN_VER_MAJOR</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_VERSION_MISMATCH</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Unsupported FS loader version (%d) for fsfs"</expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><name><name>loader_version</name>-&gt;<name>major</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_ver_check_list</name><argument_list>(<argument><expr><call><name>fs_version</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>checklist</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>vtable</name> = &amp;<name>library_vtable</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
</unit>
