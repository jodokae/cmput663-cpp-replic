<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/subversion-1.5.1/source/subversion/libsvn_fs_fs/dag.c"><comment type="block">/* dag.c : DAG-like interface filesystem, private to libsvn_fs
 *
 * ====================================================================
 * Copyright (c) 2000-2006 CollabNet.  All rights reserved.
 *
 * This software is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at http://subversion.tigris.org/license-1.html.
 * If newer versions of this license are posted there, you may use a
 * newer version instead, at your option.
 *
 * This software consists of voluntary contributions made by many
 * individuals.  For exact contribution history, see the revision
 * history and logs, available at http://subversion.tigris.org/.
 * ====================================================================
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_path.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_error.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_fs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_props.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_pools.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_md5.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dag.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"err.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"key-gen.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fs_fs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"id.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../libsvn_fs/fs-loader.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_private_config.h"</cpp:file></cpp:include>

<escape char="0xc"/>
<comment type="block">/* Initializing a filesystem.  */</comment>

<struct>struct <name>dag_node_t</name>
<block>{
  <comment type="block">/* The filesystem this dag node came from. */</comment>
  <decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl>;</decl_stmt>

  <comment type="block">/* The node revision ID for this dag node, allocated in POOL.  */</comment>
  <decl_stmt><decl><type><name>svn_fs_id_t</name> *</type><name>id</name></decl>;</decl_stmt>

  <comment type="block">/* In the special case that this node is the root of a transaction
     that has not yet been modified, the node revision ID for this dag
     node's predecessor; otherwise NULL. (Used in
     svn_fs_node_created_rev.) */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>fresh_root_predecessor_id</name></decl>;</decl_stmt>

  <comment type="block">/* The node's type (file, dir, etc.) */</comment>
  <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>

  <comment type="block">/* The node's NODE-REVISION, or NULL if we haven't read it in yet.
     This is allocated in this node's POOL.

     If you're willing to respect all the rules above, you can munge
     this yourself, but you're probably better off just calling
     `get_node_revision' and `set_node_revision', which take care of
     things for you.  */</comment>
  <decl_stmt><decl><type><name>node_revision_t</name> *</type><name>node_revision</name></decl>;</decl_stmt>

  <comment type="block">/* the path at which this node was created. */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>created_path</name></decl>;</decl_stmt>
}</block>;</struct>


<escape char="0xc"/>
<comment type="block">/* Trivial helper/accessor functions. */</comment>
<function><type><name>svn_node_kind_t</name></type> <name>svn_fs_fs__dag_node_kind</name><parameter_list>(<param><decl><type><name>dag_node_t</name> *</type><name>node</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><name><name>node</name>-&gt;<name>kind</name></name></expr>;</return>
}</block></function>


<function><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type>
<name>svn_fs_fs__dag_get_id</name><parameter_list>(<param><decl><type><name>dag_node_t</name> *</type><name>node</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><name><name>node</name>-&gt;<name>id</name></name></expr>;</return>
}</block></function>


<function><type><specifier>const</specifier> <name>char</name> *</type>
<name>svn_fs_fs__dag_get_created_path</name><parameter_list>(<param><decl><type><name>dag_node_t</name> *</type><name>node</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><name><name>node</name>-&gt;<name>created_path</name></name></expr>;</return>
}</block></function>


<function><type><name>svn_fs_t</name> *</type>
<name>svn_fs_fs__dag_get_fs</name><parameter_list>(<param><decl><type><name>dag_node_t</name> *</type><name>node</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><name><name>node</name>-&gt;<name>fs</name></name></expr>;</return>
}</block></function>


<comment type="block">/* Dup NODEREV and all associated data into POOL.
   Leaves the id and is_fresh_txn_root fields as zero bytes. */</comment>
<function><type><specifier>static</specifier> <name>node_revision_t</name> *</type>
<name>copy_node_revision</name><parameter_list>(<param><decl><type><name>node_revision_t</name> *</type><name>noderev</name></decl></param>,
                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>node_revision_t</name> *</type><name>nr</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>nr</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>nr</name>-&gt;<name>kind</name></name> = <name><name>noderev</name>-&gt;<name>kind</name></name></expr>;</expr_stmt>
  <if>if <condition>(<expr><name><name>noderev</name>-&gt;<name>predecessor_id</name></name></expr>)</condition><then>
    <expr_stmt><expr><name><name>nr</name>-&gt;<name>predecessor_id</name></name> = <call><name>svn_fs_fs__id_copy</name><argument_list>(<argument><expr><name><name>noderev</name>-&gt;<name>predecessor_id</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <expr_stmt><expr><name><name>nr</name>-&gt;<name>predecessor_count</name></name> = <name><name>noderev</name>-&gt;<name>predecessor_count</name></name></expr>;</expr_stmt>
  <if>if <condition>(<expr><name><name>noderev</name>-&gt;<name>copyfrom_path</name></name></expr>)</condition><then>
    <expr_stmt><expr><name><name>nr</name>-&gt;<name>copyfrom_path</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>noderev</name>-&gt;<name>copyfrom_path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <expr_stmt><expr><name><name>nr</name>-&gt;<name>copyfrom_rev</name></name> = <name><name>noderev</name>-&gt;<name>copyfrom_rev</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>nr</name>-&gt;<name>copyroot_path</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>noderev</name>-&gt;<name>copyroot_path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>nr</name>-&gt;<name>copyroot_rev</name></name> = <name><name>noderev</name>-&gt;<name>copyroot_rev</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>nr</name>-&gt;<name>predecessor_count</name></name> = <name><name>noderev</name>-&gt;<name>predecessor_count</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>nr</name>-&gt;<name>data_rep</name></name> = <call><name>svn_fs_fs__rep_copy</name><argument_list>(<argument><expr><name><name>noderev</name>-&gt;<name>data_rep</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>nr</name>-&gt;<name>prop_rep</name></name> = <call><name>svn_fs_fs__rep_copy</name><argument_list>(<argument><expr><name><name>noderev</name>-&gt;<name>prop_rep</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>nr</name>-&gt;<name>mergeinfo_count</name></name> = <name><name>noderev</name>-&gt;<name>mergeinfo_count</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>nr</name>-&gt;<name>has_mergeinfo</name></name> = <name><name>noderev</name>-&gt;<name>has_mergeinfo</name></name></expr>;</expr_stmt>

  <if>if <condition>(<expr><name><name>noderev</name>-&gt;<name>created_path</name></name></expr>)</condition><then>
    <expr_stmt><expr><name><name>nr</name>-&gt;<name>created_path</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>noderev</name>-&gt;<name>created_path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <return>return <expr><name>nr</name></expr>;</return>
}</block></function>


<comment type="block">/* Set *NODEREV_P to the cached node-revision for NODE in POOL.

   If you plan to change the contents of NODE, be careful!  We're
   handing you a pointer directly to our cached node-revision, not
   your own copy.  If you change it as part of some operation, but
   then some Berkeley DB function deadlocks or gets an error, you'll
   need to back out your changes, or else the cache will reflect
   changes that never got committed.  It's probably best not to change
   the structure at all.  */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>get_node_revision</name><parameter_list>(<param><decl><type><name>node_revision_t</name> **</type><name>noderev_p</name></decl></param>,
                  <param><decl><type><name>dag_node_t</name> *</type><name>node</name></decl></param>,
                  <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>node_revision_t</name> *</type><name>noderev</name></decl>;</decl_stmt>

  <comment type="block">/* If we've already got a copy, there's no need to read it in.  */</comment>
  <if>if <condition>(<expr>! <name><name>node</name>-&gt;<name>node_revision</name></name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__get_node_revision</name><argument_list>(<argument><expr>&amp;<name>noderev</name></expr></argument>, <argument><expr><name><name>node</name>-&gt;<name>fs</name></name></expr></argument>,
                                           <argument><expr><name><name>node</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>node</name>-&gt;<name>node_revision</name></name> = <name>noderev</name></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* Now NODE-&gt;node_revision is set.  */</comment>
  <expr_stmt><expr>*<name>noderev_p</name> = <name><name>node</name>-&gt;<name>node_revision</name></name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_boolean_t</name></type> <name>svn_fs_fs__dag_check_mutable</name><parameter_list>(<param><decl><type><name>dag_node_t</name> *</type><name>node</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr>(<call><name>svn_fs_fs__id_txn_id</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_id</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> != <name>NULL</name>)</expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__dag_get_node</name><parameter_list>(<param><decl><type><name>dag_node_t</name> **</type><name>node</name></decl></param>,
                        <param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                        <param><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>id</name></decl></param>,
                        <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>new_node</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>node_revision_t</name> *</type><name>noderev</name></decl>;</decl_stmt>

  <comment type="block">/* Construct the node. */</comment>
  <expr_stmt><expr><name>new_node</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>new_node</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>new_node</name>-&gt;<name>fs</name></name> = <name>fs</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>new_node</name>-&gt;<name>id</name></name> = <call><name>svn_fs_fs__id_copy</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Grab the contents so we can inspect the node's kind and created path. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_node_revision</name><argument_list>(<argument><expr>&amp;<name>noderev</name></expr></argument>, <argument><expr><name>new_node</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Initialize the KIND and CREATED_PATH attributes */</comment>
  <expr_stmt><expr><name><name>new_node</name>-&gt;<name>kind</name></name> = <name><name>noderev</name>-&gt;<name>kind</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>new_node</name>-&gt;<name>created_path</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>noderev</name>-&gt;<name>created_path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name><name>noderev</name>-&gt;<name>is_fresh_txn_root</name></name></expr>)</condition><then>
    <expr_stmt><expr><name><name>new_node</name>-&gt;<name>fresh_root_predecessor_id</name></name> = <name><name>noderev</name>-&gt;<name>predecessor_id</name></name></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name><name>new_node</name>-&gt;<name>fresh_root_predecessor_id</name></name> = <name>NULL</name></expr>;</expr_stmt></else></if>

  <comment type="block">/* Return a fresh new node */</comment>
  <expr_stmt><expr>*<name>node</name> = <name>new_node</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__dag_get_revision</name><parameter_list>(<param><decl><type><name>svn_revnum_t</name> *</type><name>rev</name></decl></param>,
                            <param><decl><type><name>dag_node_t</name> *</type><name>node</name></decl></param>,
                            <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* In the special case that this is an unmodified transaction root,
     we need to actually get the revision of the noderev's predecessor
     (the revision root); see Issue #2608. */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>correct_id</name> <init>= <expr><name><name>node</name>-&gt;<name>fresh_root_predecessor_id</name></name>
    ? <name><name>node</name>-&gt;<name>fresh_root_predecessor_id</name></name> : <name><name>node</name>-&gt;<name>id</name></name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Look up the committed revision from the Node-ID. */</comment>
  <expr_stmt><expr>*<name>rev</name> = <call><name>svn_fs_fs__id_rev</name><argument_list>(<argument><expr><name>correct_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__dag_get_predecessor_id</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> **</type><name>id_p</name></decl></param>,
                                  <param><decl><type><name>dag_node_t</name> *</type><name>node</name></decl></param>,
                                  <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>node_revision_t</name> *</type><name>noderev</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_node_revision</name><argument_list>(<argument><expr>&amp;<name>noderev</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>id_p</name> = <name><name>noderev</name>-&gt;<name>predecessor_id</name></name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__dag_get_predecessor_count</name><parameter_list>(<param><decl><type><name>int</name> *</type><name>count</name></decl></param>,
                                     <param><decl><type><name>dag_node_t</name> *</type><name>node</name></decl></param>,
                                     <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>node_revision_t</name> *</type><name>noderev</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_node_revision</name><argument_list>(<argument><expr>&amp;<name>noderev</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>count</name> = <name><name>noderev</name>-&gt;<name>predecessor_count</name></name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__dag_get_mergeinfo_count</name><parameter_list>(<param><decl><type><name>apr_int64_t</name> *</type><name>count</name></decl></param>,
                                   <param><decl><type><name>dag_node_t</name> *</type><name>node</name></decl></param>,
                                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>node_revision_t</name> *</type><name>noderev</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_node_revision</name><argument_list>(<argument><expr>&amp;<name>noderev</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>count</name> = <name><name>noderev</name>-&gt;<name>mergeinfo_count</name></name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__dag_has_mergeinfo</name><parameter_list>(<param><decl><type><name>svn_boolean_t</name> *</type><name>has_mergeinfo</name></decl></param>,
                             <param><decl><type><name>dag_node_t</name> *</type><name>node</name></decl></param>,
                             <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>node_revision_t</name> *</type><name>noderev</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_node_revision</name><argument_list>(<argument><expr>&amp;<name>noderev</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>has_mergeinfo</name> = <name><name>noderev</name>-&gt;<name>has_mergeinfo</name></name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__dag_has_descendants_with_mergeinfo</name><parameter_list>(<param><decl><type><name>svn_boolean_t</name> *</type><name>do_they</name></decl></param>,
                                              <param><decl><type><name>dag_node_t</name> *</type><name>node</name></decl></param>,
                                              <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>node_revision_t</name> *</type><name>noderev</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><name><name>node</name>-&gt;<name>kind</name></name> != <name>svn_node_dir</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr>*<name>do_they</name> = <name>FALSE</name></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_node_revision</name><argument_list>(<argument><expr>&amp;<name>noderev</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name><name>noderev</name>-&gt;<name>mergeinfo_count</name></name> &gt; 1</expr>)</condition><then>
    <expr_stmt><expr>*<name>do_they</name> = <name>TRUE</name></expr>;</expr_stmt></then>
  <else>else <if>if <condition>(<expr><name><name>noderev</name>-&gt;<name>mergeinfo_count</name></name> == 1 &amp;&amp; !<name><name>noderev</name>-&gt;<name>has_mergeinfo</name></name></expr>)</condition><then>
    <expr_stmt><expr>*<name>do_they</name> = <name>TRUE</name></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr>*<name>do_they</name> = <name>FALSE</name></expr>;</expr_stmt></else></if></else></if>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<escape char="0xc"/>
<comment type="block">/*** Directory node functions ***/</comment>

<comment type="block">/* Some of these are helpers for functions outside this section. */</comment>

<comment type="block">/* Set *ID_P to the node-id for entry NAME in PARENT.  If no such
   entry, set *ID_P to NULL but do not error.  The node-id is
   allocated in POOL. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>dir_entry_id_from_node</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> **</type><name>id_p</name></decl></param>,
                       <param><decl><type><name>dag_node_t</name> *</type><name>parent</name></decl></param>,
                       <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>,
                       <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>entries</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_dirent_t</name> *</type><name>dirent</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_dir_entries</name><argument_list>(<argument><expr>&amp;<name>entries</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>entries</name></expr>)</condition><then>
    <expr_stmt><expr><name>dirent</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>entries</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name>dirent</name> = <name>NULL</name></expr>;</expr_stmt></else></if>

  <expr_stmt><expr>*<name>id_p</name> = <name>dirent</name> ? <call><name>svn_fs_fs__id_copy</name><argument_list>(<argument><expr><name><name>dirent</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call> : <name>NULL</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Add or set in PARENT a directory entry NAME pointing to ID.
   Allocations are done in POOL.

   Assumptions:
   - PARENT is a mutable directory.
   - ID does not refer to an ancestor of parent
   - NAME is a single path component
*/</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>set_entry</name><parameter_list>(<param><decl><type><name>dag_node_t</name> *</type><name>parent</name></decl></param>,
          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>,
          <param><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>id</name></decl></param>,
          <param><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl></param>,
          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>,
          <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>node_revision_t</name> *</type><name>parent_noderev</name></decl>;</decl_stmt>

  <comment type="block">/* Get the parent's node-revision. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_node_revision</name><argument_list>(<argument><expr>&amp;<name>parent_noderev</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Set the new entry. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__set_entry</name><argument_list>(<argument><expr><name><name>parent</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>parent_noderev</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>id</name></expr></argument>,
                               <argument><expr><name>kind</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Make a new entry named NAME in PARENT.  If IS_DIR is true, then the
   node revision the new entry points to will be a directory, else it
   will be a file.  The new node will be allocated in POOL.  PARENT
   must be mutable, and must not have an entry named NAME.  */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>make_entry</name><parameter_list>(<param><decl><type><name>dag_node_t</name> **</type><name>child_p</name></decl></param>,
           <param><decl><type><name>dag_node_t</name> *</type><name>parent</name></decl></param>,
           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>parent_path</name></decl></param>,
           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>,
           <param><decl><type><name>svn_boolean_t</name></type> <name>is_dir</name></decl></param>,
           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>,
           <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>new_node_id</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>node_revision_t</name></type> <name>new_noderev</name></decl>, *<decl><type ref="prev"/><name>parent_noderev</name></decl>;</decl_stmt>

  <comment type="block">/* Make sure that NAME is a single path component. */</comment>
  <if>if <condition>(<expr>! <call><name>svn_path_is_single_path_component</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name>
      <argument_list>(<argument><expr><name>SVN_ERR_FS_NOT_SINGLE_PATH_COMPONENT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Attempted to create a node with an illegal name '%s'"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Make sure that parent is a directory */</comment>
  <if>if <condition>(<expr><name><name>parent</name>-&gt;<name>kind</name></name> != <name>svn_node_dir</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name>
      <argument_list>(<argument><expr><name>SVN_ERR_FS_NOT_DIRECTORY</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Attempted to create entry in non-directory parent"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Check that the parent is mutable. */</comment>
  <if>if <condition>(<expr>! <call><name>svn_fs_fs__dag_check_mutable</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name>
      <argument_list>(<argument><expr><name>SVN_ERR_FS_NOT_MUTABLE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Attempted to clone child of non-mutable node"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Create the new node's NODE-REVISION */</comment>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name>new_noderev</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>new_noderev</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>new_noderev</name>.<name>kind</name></name> = <name>is_dir</name> ? <name>svn_node_dir</name> : <name>svn_node_file</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>new_noderev</name>.<name>created_path</name></name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>parent_path</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_node_revision</name><argument_list>(<argument><expr>&amp;<name>parent_noderev</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>new_noderev</name>.<name>copyroot_path</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>,
                                          <argument><expr><name><name>parent_noderev</name>-&gt;<name>copyroot_path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>new_noderev</name>.<name>copyroot_rev</name></name> = <name><name>parent_noderev</name>-&gt;<name>copyroot_rev</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>new_noderev</name>.<name>copyfrom_rev</name></name> = <name>SVN_INVALID_REVNUM</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>new_noderev</name>.<name>copyfrom_path</name></name> = <name>NULL</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__create_node</name>
          <argument_list>(<argument><expr>&amp;<name>new_node_id</name></expr></argument>, <argument><expr><call><name>svn_fs_fs__dag_get_fs</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>new_noderev</name></expr></argument>,
           <argument><expr><call><name>svn_fs_fs__id_copy_id</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_id</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
           <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Create a new dag_node_t for our new node */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_node</name><argument_list>(<argument><expr><name>child_p</name></expr></argument>, <argument><expr><call><name>svn_fs_fs__dag_get_fs</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>,
                                  <argument><expr><name>new_node_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* We can safely call set_entry because we already know that
     PARENT is mutable, and we just created CHILD, so we know it has
     no ancestors (therefore, PARENT cannot be an ancestor of CHILD) */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>set_entry</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>svn_fs_fs__dag_get_id</name><argument_list>(<argument><expr>*<name>child_p</name></expr></argument>)</argument_list></call></expr></argument>,
                    <argument><expr><name><name>new_noderev</name>.<name>kind</name></name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__dag_dir_entries</name><parameter_list>(<param><decl><type><name>apr_hash_t</name> **</type><name>entries</name></decl></param>,
                           <param><decl><type><name>dag_node_t</name> *</type><name>node</name></decl></param>,
                           <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                           <param><decl><type><name>apr_pool_t</name> *</type><name>node_pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>node_revision_t</name> *</type><name>noderev</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_node_revision</name><argument_list>(<argument><expr>&amp;<name>noderev</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>node_pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name><name>noderev</name>-&gt;<name>kind</name></name> != <name>svn_node_dir</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_FS_NOT_DIRECTORY</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                            <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't get entries of non-directory"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <return>return <expr><call><name>svn_fs_fs__rep_contents_dir</name><argument_list>(<argument><expr><name>entries</name></expr></argument>, <argument><expr><name><name>node</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>noderev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__dag_set_entry</name><parameter_list>(<param><decl><type><name>dag_node_t</name> *</type><name>node</name></decl></param>,
                         <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>entry_name</name></decl></param>,
                         <param><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>id</name></decl></param>,
                         <param><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl></param>,
                         <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>,
                         <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* Check it's a directory. */</comment>
  <if>if <condition>(<expr><name><name>node</name>-&gt;<name>kind</name></name> != <name>svn_node_dir</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name>
      <argument_list>(<argument><expr><name>SVN_ERR_FS_NOT_DIRECTORY</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Attempted to set entry in non-directory node"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Check it's mutable. */</comment>
  <if>if <condition>(<expr>! <call><name>svn_fs_fs__dag_check_mutable</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name>
      <argument_list>(<argument><expr><name>SVN_ERR_FS_NOT_MUTABLE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Attempted to set entry in immutable node"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <return>return <expr><call><name>set_entry</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>entry_name</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>kind</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<escape char="0xc"/>
<comment type="block">/*** Proplists. ***/</comment>

<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__dag_get_proplist</name><parameter_list>(<param><decl><type><name>apr_hash_t</name> **</type><name>proplist_p</name></decl></param>,
                            <param><decl><type><name>dag_node_t</name> *</type><name>node</name></decl></param>,
                            <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>node_revision_t</name> *</type><name>noderev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>proplist</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_node_revision</name><argument_list>(<argument><expr>&amp;<name>noderev</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__get_proplist</name><argument_list>(<argument><expr>&amp;<name>proplist</name></expr></argument>, <argument><expr><name><name>node</name>-&gt;<name>fs</name></name></expr></argument>,
                                  <argument><expr><name>noderev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>proplist_p</name> = <name>proplist</name></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__dag_set_proplist</name><parameter_list>(<param><decl><type><name>dag_node_t</name> *</type><name>node</name></decl></param>,
                            <param><decl><type><name>apr_hash_t</name> *</type><name>proplist</name></decl></param>,
                            <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>node_revision_t</name> *</type><name>noderev</name></decl>;</decl_stmt>

  <comment type="block">/* Sanity check: this node better be mutable! */</comment>
  <if>if <condition>(<expr>! <call><name>svn_fs_fs__dag_check_mutable</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>idstr</name> <init>= <expr><call><name>svn_fs_fs__id_unparse</name><argument_list>(<argument><expr><name><name>node</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <return>return <expr><call><name>svn_error_createf</name>
        <argument_list>(<argument><expr><name>SVN_ERR_FS_NOT_MUTABLE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
         <argument><expr>"Can't set proplist on *immutable* node-revision %s"</expr></argument>,
         <argument><expr><name><name>idstr</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

  <comment type="block">/* Go get a fresh NODE-REVISION for this node. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_node_revision</name><argument_list>(<argument><expr>&amp;<name>noderev</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Set the new proplist. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__set_proplist</name><argument_list>(<argument><expr><name><name>node</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>noderev</name></expr></argument>, <argument><expr><name>proplist</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__dag_increment_mergeinfo_count</name><parameter_list>(<param><decl><type><name>dag_node_t</name> *</type><name>node</name></decl></param>,
                                         <param><decl><type><name>apr_int64_t</name></type> <name>increment</name></decl></param>,
                                         <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>node_revision_t</name> *</type><name>noderev</name></decl>;</decl_stmt>

  <comment type="block">/* Sanity check: this node better be mutable! */</comment>
  <if>if <condition>(<expr>! <call><name>svn_fs_fs__dag_check_mutable</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>idstr</name> <init>= <expr><call><name>svn_fs_fs__id_unparse</name><argument_list>(<argument><expr><name><name>node</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <return>return <expr><call><name>svn_error_createf</name>
        <argument_list>(<argument><expr><name>SVN_ERR_FS_NOT_MUTABLE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
         <argument><expr>"Can't increment mergeinfo count on *immutable* node-revision %s"</expr></argument>,
         <argument><expr><name><name>idstr</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

  <if>if <condition>(<expr><name>increment</name> == 0</expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <comment type="block">/* Go get a fresh NODE-REVISION for this node. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_node_revision</name><argument_list>(<argument><expr>&amp;<name>noderev</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>noderev</name>-&gt;<name>mergeinfo_count</name></name> += <name>increment</name></expr>;</expr_stmt>
  <if>if <condition>(<expr><name><name>noderev</name>-&gt;<name>mergeinfo_count</name></name> &lt; 0</expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>idstr</name> <init>= <expr><call><name>svn_fs_fs__id_unparse</name><argument_list>(<argument><expr><name><name>node</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <return>return <expr><call><name>svn_error_createf</name>
        <argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
         <argument><expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>,
                      <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't increment mergeinfo count on node-revision %%s "
                        "to negative value %%%s"</expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><name>APR_INT64_T_FMT</name></expr></argument>)</argument_list></call></expr></argument>,
         <argument><expr><name><name>idstr</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>noderev</name>-&gt;<name>mergeinfo_count</name></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>
  <if>if <condition>(<expr><name><name>noderev</name>-&gt;<name>mergeinfo_count</name></name> &gt; 1 &amp;&amp; <name><name>noderev</name>-&gt;<name>kind</name></name> == <name>svn_node_file</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>idstr</name> <init>= <expr><call><name>svn_fs_fs__id_unparse</name><argument_list>(<argument><expr><name><name>node</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <return>return <expr><call><name>svn_error_createf</name>
        <argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
         <argument><expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>,
                      <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't increment mergeinfo count on *file* "
                        "node-revision %%s to %%%s (&gt; 1)"</expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><name>APR_INT64_T_FMT</name></expr></argument>)</argument_list></call></expr></argument>,
         <argument><expr><name><name>idstr</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>noderev</name>-&gt;<name>mergeinfo_count</name></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

  <comment type="block">/* Flush it out. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__put_node_revision</name><argument_list>(<argument><expr><name><name>node</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name><name>noderev</name>-&gt;<name>id</name></name></expr></argument>,
                                       <argument><expr><name>noderev</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__dag_set_has_mergeinfo</name><parameter_list>(<param><decl><type><name>dag_node_t</name> *</type><name>node</name></decl></param>,
                                 <param><decl><type><name>svn_boolean_t</name></type> <name>has_mergeinfo</name></decl></param>,
                                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>node_revision_t</name> *</type><name>noderev</name></decl>;</decl_stmt>

  <comment type="block">/* Sanity check: this node better be mutable! */</comment>
  <if>if <condition>(<expr>! <call><name>svn_fs_fs__dag_check_mutable</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>idstr</name> <init>= <expr><call><name>svn_fs_fs__id_unparse</name><argument_list>(<argument><expr><name><name>node</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <return>return <expr><call><name>svn_error_createf</name>
        <argument_list>(<argument><expr><name>SVN_ERR_FS_NOT_MUTABLE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
         <argument><expr>"Can't set mergeinfo flag on *immutable* node-revision %s"</expr></argument>,
         <argument><expr><name><name>idstr</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

  <comment type="block">/* Go get a fresh NODE-REVISION for this node. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_node_revision</name><argument_list>(<argument><expr>&amp;<name>noderev</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>noderev</name>-&gt;<name>has_mergeinfo</name></name> = <name>has_mergeinfo</name></expr>;</expr_stmt>

  <comment type="block">/* Flush it out. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__put_node_revision</name><argument_list>(<argument><expr><name><name>node</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name><name>noderev</name>-&gt;<name>id</name></name></expr></argument>,
                                       <argument><expr><name>noderev</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<escape char="0xc"/>
<comment type="block">/*** Roots. ***/</comment>

<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__dag_revision_root</name><parameter_list>(<param><decl><type><name>dag_node_t</name> **</type><name>node_p</name></decl></param>,
                             <param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                             <param><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl></param>,
                             <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_fs_id_t</name> *</type><name>root_id</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__rev_get_root</name><argument_list>(<argument><expr>&amp;<name>root_id</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>svn_fs_fs__dag_get_node</name><argument_list>(<argument><expr><name>node_p</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>root_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__dag_txn_root</name><parameter_list>(<param><decl><type><name>dag_node_t</name> **</type><name>node_p</name></decl></param>,
                        <param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                        <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>,
                        <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>root_id</name></decl>, *<decl><type ref="prev"/><name>ignored</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__get_txn_ids</name><argument_list>(<argument><expr>&amp;<name>root_id</name></expr></argument>, <argument><expr>&amp;<name>ignored</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>svn_fs_fs__dag_get_node</name><argument_list>(<argument><expr><name>node_p</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>root_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__dag_txn_base_root</name><parameter_list>(<param><decl><type><name>dag_node_t</name> **</type><name>node_p</name></decl></param>,
                             <param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                             <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>,
                             <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>base_root_id</name></decl>, *<decl><type ref="prev"/><name>ignored</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__get_txn_ids</name><argument_list>(<argument><expr>&amp;<name>ignored</name></expr></argument>, <argument><expr>&amp;<name>base_root_id</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>svn_fs_fs__dag_get_node</name><argument_list>(<argument><expr><name>node_p</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>base_root_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__dag_clone_child</name><parameter_list>(<param><decl><type><name>dag_node_t</name> **</type><name>child_p</name></decl></param>,
                           <param><decl><type><name>dag_node_t</name> *</type><name>parent</name></decl></param>,
                           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>parent_path</name></decl></param>,
                           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>,
                           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copy_id</name></decl></param>,
                           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>,
                           <param><decl><type><name>svn_boolean_t</name></type> <name>is_parent_copyroot</name></decl></param>,
                           <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>cur_entry</name></decl>;</decl_stmt> <comment type="block">/* parent's current entry named NAME */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>new_node_id</name></decl>;</decl_stmt> <comment type="block">/* node id we'll put into NEW_NODE */</comment>
  <decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name> <init>= <expr><call><name>svn_fs_fs__dag_get_fs</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="block">/* First check that the parent is mutable. */</comment>
  <if>if <condition>(<expr>! <call><name>svn_fs_fs__dag_check_mutable</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name>
      <argument_list>(<argument><expr><name>SVN_ERR_FS_NOT_MUTABLE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr>"Attempted to clone child of non-mutable node"</expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Make sure that NAME is a single path component. */</comment>
  <if>if <condition>(<expr>! <call><name>svn_path_is_single_path_component</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name>
      <argument_list>(<argument><expr><name>SVN_ERR_FS_NOT_SINGLE_PATH_COMPONENT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr>"Attempted to make a child clone with an illegal name '%s'"</expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Find the node named NAME in PARENT's entries list if it exists. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_open</name><argument_list>(<argument><expr>&amp;<name>cur_entry</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check for mutability in the node we found.  If it's mutable, we
     don't need to clone it. */</comment>
  <if>if <condition>(<expr><call><name>svn_fs_fs__dag_check_mutable</name><argument_list>(<argument><expr><name>cur_entry</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <comment type="block">/* This has already been cloned */</comment>
      <expr_stmt><expr><name>new_node_id</name> = <name><name>cur_entry</name>-&gt;<name>id</name></name></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <decl_stmt><decl><type><name>node_revision_t</name> *</type><name>noderev</name></decl>, *<decl><type ref="prev"/><name>parent_noderev</name></decl>;</decl_stmt>

      <comment type="block">/* Go get a fresh NODE-REVISION for current child node. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_node_revision</name><argument_list>(<argument><expr>&amp;<name>noderev</name></expr></argument>, <argument><expr><name>cur_entry</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr><name>is_parent_copyroot</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_node_revision</name><argument_list>(<argument><expr>&amp;<name>parent_noderev</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>noderev</name>-&gt;<name>copyroot_rev</name></name> = <name><name>parent_noderev</name>-&gt;<name>copyroot_rev</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>noderev</name>-&gt;<name>copyroot_path</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>,
                                               <argument><expr><name><name>parent_noderev</name>-&gt;<name>copyroot_path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

      <expr_stmt><expr><name><name>noderev</name>-&gt;<name>copyfrom_path</name></name> = <name>NULL</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>noderev</name>-&gt;<name>copyfrom_rev</name></name> = <name>SVN_INVALID_REVNUM</name></expr>;</expr_stmt>

      <expr_stmt><expr><name><name>noderev</name>-&gt;<name>predecessor_id</name></name> = <call><name>svn_fs_fs__id_copy</name><argument_list>(<argument><expr><name><name>cur_entry</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name><name>noderev</name>-&gt;<name>predecessor_count</name></name> != -1</expr>)</condition><then>
        <expr_stmt><expr><name><name>noderev</name>-&gt;<name>predecessor_count</name></name>++</expr>;</expr_stmt></then></if>
      <expr_stmt><expr><name><name>noderev</name>-&gt;<name>created_path</name></name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>parent_path</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__create_successor</name><argument_list>(<argument><expr>&amp;<name>new_node_id</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>cur_entry</name>-&gt;<name>id</name></name></expr></argument>,
                                          <argument><expr><name>noderev</name></expr></argument>, <argument><expr><name>copy_id</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Replace the ID in the parent's ENTRY list with the ID which
         refers to the mutable clone of this child. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>set_entry</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>new_node_id</name></expr></argument>, <argument><expr><name><name>noderev</name>-&gt;<name>kind</name></name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>,
                        <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

  <comment type="block">/* Initialize the youngster. */</comment>
  <return>return <expr><call><name>svn_fs_fs__dag_get_node</name><argument_list>(<argument><expr><name>child_p</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>new_node_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>



<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__dag_clone_root</name><parameter_list>(<param><decl><type><name>dag_node_t</name> **</type><name>root_p</name></decl></param>,
                          <param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>,
                          <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>base_root_id</name></decl>, *<decl><type ref="prev"/><name>root_id</name></decl>;</decl_stmt>

  <comment type="block">/* Get the node ID's of the root directories of the transaction and
     its base revision.  */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__get_txn_ids</name><argument_list>(<argument><expr>&amp;<name>root_id</name></expr></argument>, <argument><expr>&amp;<name>base_root_id</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Oh, give me a clone...
     (If they're the same, we haven't cloned the transaction's root
     directory yet.)  */</comment>
  <if>if <condition>(<expr><call><name>svn_fs_fs__id_eq</name><argument_list>(<argument><expr><name>root_id</name></expr></argument>, <argument><expr><name>base_root_id</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* One way or another, root_id now identifies a cloned root node. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_node</name><argument_list>(<argument><expr><name>root_p</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>root_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/*
   * (Sung to the tune of "Home, Home on the Range", with thanks to
   * Randall Garrett and Isaac Asimov.)
   */</comment>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__dag_delete</name><parameter_list>(<param><decl><type><name>dag_node_t</name> *</type><name>parent</name></decl></param>,
                      <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>,
                      <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>,
                      <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>node_revision_t</name> *</type><name>parent_noderev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>entries</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name> <init>= <expr><name><name>parent</name>-&gt;<name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_dirent_t</name> *</type><name>dirent</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_id_t</name> *</type><name>id</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name></decl>;</decl_stmt>

  <comment type="block">/* Make sure parent is a directory. */</comment>
  <if>if <condition>(<expr><name><name>parent</name>-&gt;<name>kind</name></name> != <name>svn_node_dir</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name>
      <argument_list>(<argument><expr><name>SVN_ERR_FS_NOT_DIRECTORY</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr>"Attempted to delete entry '%s' from *non*-directory node"</expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Make sure parent is mutable. */</comment>
  <if>if <condition>(<expr>! <call><name>svn_fs_fs__dag_check_mutable</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name>
      <argument_list>(<argument><expr><name>SVN_ERR_FS_NOT_MUTABLE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr>"Attempted to delete entry '%s' from immutable directory node"</expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Make sure that NAME is a single path component. */</comment>
  <if>if <condition>(<expr>! <call><name>svn_path_is_single_path_component</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name>
      <argument_list>(<argument><expr><name>SVN_ERR_FS_NOT_SINGLE_PATH_COMPONENT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr>"Attempted to delete a node with an illegal name '%s'"</expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Get a fresh NODE-REVISION for the parent node. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_node_revision</name><argument_list>(<argument><expr>&amp;<name>parent_noderev</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>subpool</name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Get a dirent hash for this directory. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__rep_contents_dir</name><argument_list>(<argument><expr>&amp;<name>entries</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>parent_noderev</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Find name in the ENTRIES hash. */</comment>
  <expr_stmt><expr><name>dirent</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>entries</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If we never found ID in ENTRIES (perhaps because there are no
     ENTRIES, perhaps because ID just isn't in the existing ENTRIES
     ... it doesn't matter), return an error.  */</comment>
  <if>if <condition>(<expr>! <name>dirent</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name>
      <argument_list>(<argument><expr><name>SVN_ERR_FS_NO_SUCH_ENTRY</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr>"Delete failed--directory has no entry '%s'"</expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Copy the ID out of the subpool and release the rest of the
     directory listing. */</comment>
  <expr_stmt><expr><name>id</name> = <call><name>svn_fs_fs__id_copy</name><argument_list>(<argument><expr><name><name>dirent</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If mutable, remove it and any mutable children from db. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_delete_if_mutable</name><argument_list>(<argument><expr><name><name>parent</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Remove this entry from its parent's entries list. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__set_entry</name><argument_list>(<argument><expr><name><name>parent</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>parent_noderev</name></expr></argument>, <argument><expr><name>name</name></expr></argument>,
                               <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>svn_node_unknown</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__dag_remove_node</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                           <param><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>id</name></decl></param>,
                           <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>node</name></decl>;</decl_stmt>

  <comment type="block">/* Fetch the node. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_node</name><argument_list>(<argument><expr>&amp;<name>node</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If immutable, do nothing and return immediately. */</comment>
  <if>if <condition>(<expr>! <call><name>svn_fs_fs__dag_check_mutable</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_FS_NOT_MUTABLE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr>"Attempted removal of immutable node"</expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Delete the node revision. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__delete_node_revision</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__dag_delete_if_mutable</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                                 <param><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>id</name></decl></param>,
                                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>node</name></decl>;</decl_stmt>

  <comment type="block">/* Get the node. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_node</name><argument_list>(<argument><expr>&amp;<name>node</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If immutable, do nothing and return immediately. */</comment>
  <if>if <condition>(<expr>! <call><name>svn_fs_fs__dag_check_mutable</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <comment type="block">/* Else it's mutable.  Recurse on directories... */</comment>
  <if>if <condition>(<expr><name><name>node</name>-&gt;<name>kind</name></name> == <name>svn_node_dir</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>entries</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>

      <comment type="block">/* Loop over hash entries */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_dir_entries</name><argument_list>(<argument><expr>&amp;<name>entries</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>entries</name></expr>)</condition><then>
        <block>{
          <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>entries</name></expr></argument>)</argument_list></call></expr>;</init>
               <condition><expr><name>hi</name></expr>;</condition>
               <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
            <block>{
              <decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>
              <decl_stmt><decl><type><name>svn_fs_dirent_t</name> *</type><name>dirent</name></decl>;</decl_stmt>

              <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>dirent</name> = <name>val</name></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_delete_if_mutable</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>dirent</name>-&gt;<name>id</name></name></expr></argument>,
                                                       <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></for>
        }</block></then></if>
    }</block></then></if>

  <comment type="block">/* ... then delete the node itself, after deleting any mutable
     representations and strings it points to. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_remove_node</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__dag_make_file</name><parameter_list>(<param><decl><type><name>dag_node_t</name> **</type><name>child_p</name></decl></param>,
                         <param><decl><type><name>dag_node_t</name> *</type><name>parent</name></decl></param>,
                         <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>parent_path</name></decl></param>,
                         <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>,
                         <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>,
                         <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* Call our little helper function */</comment>
  <return>return <expr><call><name>make_entry</name><argument_list>(<argument><expr><name>child_p</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>parent_path</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__dag_make_dir</name><parameter_list>(<param><decl><type><name>dag_node_t</name> **</type><name>child_p</name></decl></param>,
                        <param><decl><type><name>dag_node_t</name> *</type><name>parent</name></decl></param>,
                        <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>parent_path</name></decl></param>,
                        <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>,
                        <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>,
                        <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* Call our little helper function */</comment>
  <return>return <expr><call><name>make_entry</name><argument_list>(<argument><expr><name>child_p</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>parent_path</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__dag_get_contents</name><parameter_list>(<param><decl><type><name>svn_stream_t</name> **</type><name>contents_p</name></decl></param>,
                            <param><decl><type><name>dag_node_t</name> *</type><name>file</name></decl></param>,
                            <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>node_revision_t</name> *</type><name>noderev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>contents</name></decl>;</decl_stmt>

  <comment type="block">/* Make sure our node is a file. */</comment>
  <if>if <condition>(<expr><name><name>file</name>-&gt;<name>kind</name></name> != <name>svn_node_file</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name>
      <argument_list>(<argument><expr><name>SVN_ERR_FS_NOT_FILE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr>"Attempted to get textual contents of a *non*-file node"</expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Go get a fresh node-revision for FILE. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_node_revision</name><argument_list>(<argument><expr>&amp;<name>noderev</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Get a stream to the contents. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__get_contents</name><argument_list>(<argument><expr>&amp;<name>contents</name></expr></argument>, <argument><expr><name><name>file</name>-&gt;<name>fs</name></name></expr></argument>,
                                  <argument><expr><name>noderev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>contents_p</name> = <name>contents</name></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__dag_get_file_delta_stream</name><parameter_list>(<param><decl><type><name>svn_txdelta_stream_t</name> **</type><name>stream_p</name></decl></param>,
                                     <param><decl><type><name>dag_node_t</name> *</type><name>source</name></decl></param>,
                                     <param><decl><type><name>dag_node_t</name> *</type><name>target</name></decl></param>,
                                     <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>node_revision_t</name> *</type><name>src_noderev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>node_revision_t</name> *</type><name>tgt_noderev</name></decl>;</decl_stmt>

  <comment type="block">/* Make sure our nodes are files. */</comment>
  <if>if <condition>(<expr>(<name>source</name> &amp;&amp; <name><name>source</name>-&gt;<name>kind</name></name> != <name>svn_node_file</name>)
      || <name><name>target</name>-&gt;<name>kind</name></name> != <name>svn_node_file</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name>
      <argument_list>(<argument><expr><name>SVN_ERR_FS_NOT_FILE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr>"Attempted to get textual contents of a *non*-file node"</expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Go get fresh node-revisions for the nodes. */</comment>
  <if>if <condition>(<expr><name>source</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_node_revision</name><argument_list>(<argument><expr>&amp;<name>src_noderev</name></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name>src_noderev</name> = <name>NULL</name></expr>;</expr_stmt></else></if>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_node_revision</name><argument_list>(<argument><expr>&amp;<name>tgt_noderev</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Get the delta stream. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__get_file_delta_stream</name><argument_list>(<argument><expr><name>stream_p</name></expr></argument>, <argument><expr><name><name>target</name>-&gt;<name>fs</name></name></expr></argument>,
                                           <argument><expr><name>src_noderev</name></expr></argument>, <argument><expr><name>tgt_noderev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__dag_file_length</name><parameter_list>(<param><decl><type><name>svn_filesize_t</name> *</type><name>length</name></decl></param>,
                           <param><decl><type><name>dag_node_t</name> *</type><name>file</name></decl></param>,
                           <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>node_revision_t</name> *</type><name>noderev</name></decl>;</decl_stmt>

  <comment type="block">/* Make sure our node is a file. */</comment>
  <if>if <condition>(<expr><name><name>file</name>-&gt;<name>kind</name></name> != <name>svn_node_file</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name>
      <argument_list>(<argument><expr><name>SVN_ERR_FS_NOT_FILE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr>"Attempted to get length of a *non*-file node"</expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Go get a fresh node-revision for FILE, and . */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_node_revision</name><argument_list>(<argument><expr>&amp;<name>noderev</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__file_length</name><argument_list>(<argument><expr><name>length</name></expr></argument>, <argument><expr><name>noderev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__dag_file_checksum</name><parameter_list>(<param><decl><type><name>unsigned</name> <name>char</name></type> <name><name>digest</name><index>[]</index></name></decl></param>,
                             <param><decl><type><name>dag_node_t</name> *</type><name>file</name></decl></param>,
                             <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>node_revision_t</name> *</type><name>noderev</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><name><name>file</name>-&gt;<name>kind</name></name> != <name>svn_node_file</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name>
      <argument_list>(<argument><expr><name>SVN_ERR_FS_NOT_FILE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr>"Attempted to get checksum of a *non*-file node"</expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_node_revision</name><argument_list>(<argument><expr>&amp;<name>noderev</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__file_checksum</name><argument_list>(<argument><expr><name>digest</name></expr></argument>, <argument><expr><name>noderev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__dag_get_edit_stream</name><parameter_list>(<param><decl><type><name>svn_stream_t</name> **</type><name>contents</name></decl></param>,
                               <param><decl><type><name>dag_node_t</name> *</type><name>file</name></decl></param>,
                               <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>node_revision_t</name> *</type><name>noderev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>ws</name></decl>;</decl_stmt>

  <comment type="block">/* Make sure our node is a file. */</comment>
  <if>if <condition>(<expr><name><name>file</name>-&gt;<name>kind</name></name> != <name>svn_node_file</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name>
      <argument_list>(<argument><expr><name>SVN_ERR_FS_NOT_FILE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr>"Attempted to set textual contents of a *non*-file node"</expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Make sure our node is mutable. */</comment>
  <if>if <condition>(<expr>! <call><name>svn_fs_fs__dag_check_mutable</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name>
      <argument_list>(<argument><expr><name>SVN_ERR_FS_NOT_MUTABLE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr>"Attempted to set textual contents of an immutable node"</expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Get the node revision. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_node_revision</name><argument_list>(<argument><expr>&amp;<name>noderev</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__set_contents</name><argument_list>(<argument><expr>&amp;<name>ws</name></expr></argument>, <argument><expr><name><name>file</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>noderev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>contents</name> = <name>ws</name></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>



<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__dag_finalize_edits</name><parameter_list>(<param><decl><type><name>dag_node_t</name> *</type><name>file</name></decl></param>,
                              <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>checksum</name></decl></param>,
                              <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>digest</name><index>[<expr><name>APR_MD5_DIGESTSIZE</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>hex</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>checksum</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_file_checksum</name><argument_list>(<argument><expr><name>digest</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>hex</name> = <call><name>svn_md5_digest_to_cstring</name><argument_list>(<argument><expr><name>digest</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>hex</name> &amp;&amp; <call><name>strcmp</name><argument_list>(<argument><expr><name>checksum</name></expr></argument>, <argument><expr><name>hex</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
        <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_CHECKSUM_MISMATCH</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                 <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Checksum mismatch, file '%s':\n"
                                   "   expected:  %s\n"
                                   "     actual:  %s\n"</expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><name><name>file</name>-&gt;<name>created_path</name></name></expr></argument>, <argument><expr><name>checksum</name></expr></argument>, <argument><expr><name>hex</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
    }</block></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>dag_node_t</name> *</type>
<name>svn_fs_fs__dag_dup</name><parameter_list>(<param><decl><type><name>dag_node_t</name> *</type><name>node</name></decl></param>,
                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* Allocate our new node. */</comment>
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>new_node</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>new_node</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>new_node</name>-&gt;<name>fs</name></name> = <name><name>node</name>-&gt;<name>fs</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>new_node</name>-&gt;<name>id</name></name> = <call><name>svn_fs_fs__id_copy</name><argument_list>(<argument><expr><name><name>node</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>new_node</name>-&gt;<name>kind</name></name> = <name><name>node</name>-&gt;<name>kind</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>new_node</name>-&gt;<name>created_path</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>node</name>-&gt;<name>created_path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Only copy cached node_revision_t for immutable nodes. */</comment>
  <if>if <condition>(<expr><name><name>node</name>-&gt;<name>node_revision</name></name> &amp;&amp; !<call><name>svn_fs_fs__dag_check_mutable</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name><name>new_node</name>-&gt;<name>node_revision</name></name> = <call><name>copy_node_revision</name><argument_list>(<argument><expr><name><name>node</name>-&gt;<name>node_revision</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>new_node</name>-&gt;<name>node_revision</name>-&gt;<name>id</name></name> =
          <call><name>svn_fs_fs__id_copy</name><argument_list>(<argument><expr><name><name>node</name>-&gt;<name>node_revision</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>new_node</name>-&gt;<name>node_revision</name>-&gt;<name>is_fresh_txn_root</name></name> =
          <name><name>node</name>-&gt;<name>node_revision</name>-&gt;<name>is_fresh_txn_root</name></name></expr>;</expr_stmt>
    }</block></then></if>
  <return>return <expr><name>new_node</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__dag_open</name><parameter_list>(<param><decl><type><name>dag_node_t</name> **</type><name>child_p</name></decl></param>,
                    <param><decl><type><name>dag_node_t</name> *</type><name>parent</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>,
                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>node_id</name></decl>;</decl_stmt>

  <comment type="block">/* Ensure that NAME exists in PARENT's entry list. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>dir_entry_id_from_node</name><argument_list>(<argument><expr>&amp;<name>node_id</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>! <name>node_id</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name>
      <argument_list>(<argument><expr><name>SVN_ERR_FS_NOT_FOUND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr>"Attempted to open non-existent child node '%s'"</expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Make sure that NAME is a single path component. */</comment>
  <if>if <condition>(<expr>! <call><name>svn_path_is_single_path_component</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name>
      <argument_list>(<argument><expr><name>SVN_ERR_FS_NOT_SINGLE_PATH_COMPONENT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr>"Attempted to open node with an illegal name '%s'"</expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Now get the node that was requested. */</comment>
  <return>return <expr><call><name>svn_fs_fs__dag_get_node</name><argument_list>(<argument><expr><name>child_p</name></expr></argument>, <argument><expr><call><name>svn_fs_fs__dag_get_fs</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><name>node_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__dag_copy</name><parameter_list>(<param><decl><type><name>dag_node_t</name> *</type><name>to_node</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>entry</name></decl></param>,
                    <param><decl><type><name>dag_node_t</name> *</type><name>from_node</name></decl></param>,
                    <param><decl><type><name>svn_boolean_t</name></type> <name>preserve_history</name></decl></param>,
                    <param><decl><type><name>svn_revnum_t</name></type> <name>from_rev</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>from_path</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>,
                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>id</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>preserve_history</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>node_revision_t</name> *</type><name>from_noderev</name></decl>, *<decl><type ref="prev"/><name>to_noderev</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copy_id</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>src_id</name> <init>= <expr><call><name>svn_fs_fs__dag_get_id</name><argument_list>(<argument><expr><name>from_node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name> <init>= <expr><call><name>svn_fs_fs__dag_get_fs</name><argument_list>(<argument><expr><name>from_node</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <comment type="block">/* Make a copy of the original node revision. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_node_revision</name><argument_list>(<argument><expr>&amp;<name>from_noderev</name></expr></argument>, <argument><expr><name>from_node</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>to_noderev</name> = <call><name>copy_node_revision</name><argument_list>(<argument><expr><name>from_noderev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Reserve a copy ID for this new copy. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__reserve_copy_id</name><argument_list>(<argument><expr>&amp;<name>copy_id</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Create a successor with its predecessor pointing at the copy
         source. */</comment>
      <expr_stmt><expr><name><name>to_noderev</name>-&gt;<name>predecessor_id</name></name> = <call><name>svn_fs_fs__id_copy</name><argument_list>(<argument><expr><name>src_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name><name>to_noderev</name>-&gt;<name>predecessor_count</name></name> != -1</expr>)</condition><then>
        <expr_stmt><expr><name><name>to_noderev</name>-&gt;<name>predecessor_count</name></name>++</expr>;</expr_stmt></then></if>
      <expr_stmt><expr><name><name>to_noderev</name>-&gt;<name>created_path</name></name> =
        <call><name>svn_path_join</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_created_path</name><argument_list>(<argument><expr><name>to_node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>entry</name></expr></argument>,
                      <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>to_noderev</name>-&gt;<name>copyfrom_path</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>from_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>to_noderev</name>-&gt;<name>copyfrom_rev</name></name> = <name>from_rev</name></expr>;</expr_stmt>

      <comment type="block">/* Set the copyroot equal to our own id. */</comment>
      <expr_stmt><expr><name><name>to_noderev</name>-&gt;<name>copyroot_path</name></name> = <name>NULL</name></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__create_successor</name><argument_list>(<argument><expr>&amp;<name>id</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>src_id</name></expr></argument>, <argument><expr><name>to_noderev</name></expr></argument>,
                                          <argument><expr><name>copy_id</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    }</block></then>
  <else>else  <comment type="block">/* don't preserve history */</comment>
    <block>{
      <expr_stmt><expr><name>id</name> = <call><name>svn_fs_fs__dag_get_id</name><argument_list>(<argument><expr><name>from_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

  <comment type="block">/* Set the entry in to_node to the new id. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_set_entry</name><argument_list>(<argument><expr><name>to_node</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name><name>from_node</name>-&gt;<name>kind</name></name></expr></argument>,
                                   <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<escape char="0xc"/>
<comment type="block">/*** Comparison. ***/</comment>

<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__dag_things_different</name><parameter_list>(<param><decl><type><name>svn_boolean_t</name> *</type><name>props_changed</name></decl></param>,
                                <param><decl><type><name>svn_boolean_t</name> *</type><name>contents_changed</name></decl></param>,
                                <param><decl><type><name>dag_node_t</name> *</type><name>node1</name></decl></param>,
                                <param><decl><type><name>dag_node_t</name> *</type><name>node2</name></decl></param>,
                                <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>node_revision_t</name> *</type><name>noderev1</name></decl>, *<decl><type ref="prev"/><name>noderev2</name></decl>;</decl_stmt>

  <comment type="block">/* If we have no place to store our results, don't bother doing
     anything. */</comment>
  <if>if <condition>(<expr>! <name>props_changed</name> &amp;&amp; ! <name>contents_changed</name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <comment type="block">/* The node revision skels for these two nodes. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_node_revision</name><argument_list>(<argument><expr>&amp;<name>noderev1</name></expr></argument>, <argument><expr><name>node1</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_node_revision</name><argument_list>(<argument><expr>&amp;<name>noderev2</name></expr></argument>, <argument><expr><name>node2</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Compare property keys. */</comment>
  <if>if <condition>(<expr><name>props_changed</name> != <name>NULL</name></expr>)</condition><then>
    <expr_stmt><expr>*<name>props_changed</name> = (! <call><name>svn_fs_fs__noderev_same_rep_key</name><argument_list>(<argument><expr><name><name>noderev1</name>-&gt;<name>prop_rep</name></name></expr></argument>,
                                                        <argument><expr><name><name>noderev2</name>-&gt;<name>prop_rep</name></name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt></then></if>

  <comment type="block">/* Compare contents keys. */</comment>
  <if>if <condition>(<expr><name>contents_changed</name> != <name>NULL</name></expr>)</condition><then>
    <expr_stmt><expr>*<name>contents_changed</name> =
      (! <call><name>svn_fs_fs__noderev_same_rep_key</name><argument_list>(<argument><expr><name><name>noderev1</name>-&gt;<name>data_rep</name></name></expr></argument>,
                                         <argument><expr><name><name>noderev2</name>-&gt;<name>data_rep</name></name></expr></argument>)</argument_list></call>)</expr>;</expr_stmt></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__dag_get_copyroot</name><parameter_list>(<param><decl><type><name>svn_revnum_t</name> *</type><name>rev</name></decl></param>,
                            <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>path</name></decl></param>,
                            <param><decl><type><name>dag_node_t</name> *</type><name>node</name></decl></param>,
                            <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>node_revision_t</name> *</type><name>noderev</name></decl>;</decl_stmt>

  <comment type="block">/* Go get a fresh node-revision for FILE. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_node_revision</name><argument_list>(<argument><expr>&amp;<name>noderev</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>rev</name> = <name><name>noderev</name>-&gt;<name>copyroot_rev</name></name></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>path</name> = <name><name>noderev</name>-&gt;<name>copyroot_path</name></name></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__dag_get_copyfrom_rev</name><parameter_list>(<param><decl><type><name>svn_revnum_t</name> *</type><name>rev</name></decl></param>,
                                <param><decl><type><name>dag_node_t</name> *</type><name>node</name></decl></param>,
                                <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>node_revision_t</name> *</type><name>noderev</name></decl>;</decl_stmt>

  <comment type="block">/* Go get a fresh node-revision for FILE. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_node_revision</name><argument_list>(<argument><expr>&amp;<name>noderev</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>rev</name> = <name><name>noderev</name>-&gt;<name>copyfrom_rev</name></name></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__dag_get_copyfrom_path</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>path</name></decl></param>,
                                 <param><decl><type><name>dag_node_t</name> *</type><name>node</name></decl></param>,
                                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>node_revision_t</name> *</type><name>noderev</name></decl>;</decl_stmt>

  <comment type="block">/* Go get a fresh node-revision for FILE. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_node_revision</name><argument_list>(<argument><expr>&amp;<name>noderev</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>path</name> = <name><name>noderev</name>-&gt;<name>copyfrom_path</name></name></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
</unit>
