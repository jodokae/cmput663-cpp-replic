<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/subversion-1.5.1/source/subversion/libsvn_fs_fs/fs_fs.c"><comment type="block">/* fs_fs.c --- filesystem operations specific to fs_fs
 *
 * ====================================================================
 * Copyright (c) 2000-2007 CollabNet.  All rights reserved.
 *
 * This software is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at http://subversion.tigris.org/license-1.html.
 * If newer versions of this license are posted there, you may use a
 * newer version instead, at your option.
 *
 * This software consists of voluntary contributions made by many
 * individuals.  For exact contribution history, see the revision
 * history and logs, available at http://subversion.tigris.org/.
 * ====================================================================
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_general.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_pools.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_file_io.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_uuid.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_lib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_md5.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_thread_mutex.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_pools.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_fs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_path.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_md5.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_props.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_sorts.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_time.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_mergeinfo.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"err.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"key-gen.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fs_fs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"id.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"private/svn_fs_util.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../libsvn_fs/fs-loader.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_private_config.h"</cpp:file></cpp:include>

<comment type="block">/* An arbitrary maximum path length, so clients can't run us out of memory
 * by giving us arbitrarily large paths. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FSFS_MAX_PATH_LEN</name></cpp:macro> <cpp:value>4096</cpp:value></cpp:define>

<comment type="block">/* The default maximum number of files per directory to store in the
   rev and revprops directory.  The number below is somewhat arbitrary,
   and can be overriden by defining the macro while compiling; the
   figure of 1000 is reasonable for VFAT filesystems, which are by far
   the worst performers in this area. */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>SVN_FS_FS_DEFAULT_MAX_FILES_PER_DIR</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_FS_FS_DEFAULT_MAX_FILES_PER_DIR</name></cpp:macro> <cpp:value>1000</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Following are defines that specify the textual elements of the
   native filesystem directories and revision files. */</comment>

<comment type="block">/* Headers used to describe node-revision in the revision file. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HEADER_ID</name></cpp:macro>          <cpp:value>"id"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HEADER_TYPE</name></cpp:macro>        <cpp:value>"type"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HEADER_COUNT</name></cpp:macro>       <cpp:value>"count"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HEADER_PROPS</name></cpp:macro>       <cpp:value>"props"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HEADER_TEXT</name></cpp:macro>        <cpp:value>"text"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HEADER_CPATH</name></cpp:macro>       <cpp:value>"cpath"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HEADER_PRED</name></cpp:macro>        <cpp:value>"pred"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HEADER_COPYFROM</name></cpp:macro>    <cpp:value>"copyfrom"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HEADER_COPYROOT</name></cpp:macro>    <cpp:value>"copyroot"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HEADER_FRESHTXNRT</name></cpp:macro>  <cpp:value>"is-fresh-txn-root"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HEADER_MINFO_HERE</name></cpp:macro>  <cpp:value>"minfo-here"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HEADER_MINFO_CNT</name></cpp:macro>   <cpp:value>"minfo-cnt"</cpp:value></cpp:define>

<comment type="block">/* Kinds that a change can be. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ACTION_MODIFY</name></cpp:macro>      <cpp:value>"modify"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ACTION_ADD</name></cpp:macro>         <cpp:value>"add"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ACTION_DELETE</name></cpp:macro>      <cpp:value>"delete"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ACTION_REPLACE</name></cpp:macro>     <cpp:value>"replace"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ACTION_RESET</name></cpp:macro>       <cpp:value>"reset"</cpp:value></cpp:define>

<comment type="block">/* True and False flags. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLAG_TRUE</name></cpp:macro>          <cpp:value>"true"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FLAG_FALSE</name></cpp:macro>         <cpp:value>"false"</cpp:value></cpp:define>

<comment type="block">/* Kinds that a node-rev can be. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>KIND_FILE</name></cpp:macro>          <cpp:value>"file"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>KIND_DIR</name></cpp:macro>           <cpp:value>"dir"</cpp:value></cpp:define>

<comment type="block">/* Kinds of representation. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REP_PLAIN</name></cpp:macro>          <cpp:value>"PLAIN"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REP_DELTA</name></cpp:macro>          <cpp:value>"DELTA"</cpp:value></cpp:define>

<comment type="block">/* Notes:

To avoid opening and closing the rev-files all the time, it would
probably be advantageous to keep each rev-file open for the
lifetime of the transaction object.  I'll leave that as a later
optimization for now.

I didn't keep track of pool lifetimes at all in this code.  There
are likely some errors because of that.

*/</comment>

<comment type="block">/* The vtable associated with an open transaction object. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>txn_vtable_t</name></type> <name>txn_vtable</name> <init>= <expr><block>{
  <expr><name>svn_fs_fs__commit_txn</name></expr>,
  <expr><name>svn_fs_fs__abort_txn</name></expr>,
  <expr><name>svn_fs_fs__txn_prop</name></expr>,
  <expr><name>svn_fs_fs__txn_proplist</name></expr>,
  <expr><name>svn_fs_fs__change_txn_prop</name></expr>,
  <expr><name>svn_fs_fs__txn_root</name></expr>,
  <expr><name>svn_fs_fs__change_txn_props</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Pathname helper functions */</comment>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type>
<name>path_format</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>svn_path_join</name><argument_list>(<argument><expr><name><name>fs</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>PATH_FORMAT</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>APR_INLINE</name> <specifier>const</specifier> <name>char</name> *</type>
<name>path_uuid</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>svn_path_join</name><argument_list>(<argument><expr><name><name>fs</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>PATH_UUID</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>const</specifier> <name>char</name> *</type>
<name>svn_fs_fs__path_current</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>svn_path_join</name><argument_list>(<argument><expr><name><name>fs</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>PATH_CURRENT</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>APR_INLINE</name> <specifier>const</specifier> <name>char</name> *</type>
<name>path_txn_current</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>svn_path_join</name><argument_list>(<argument><expr><name><name>fs</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>PATH_TXN_CURRENT</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>APR_INLINE</name> <specifier>const</specifier> <name>char</name> *</type>
<name>path_txn_current_lock</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>svn_path_join</name><argument_list>(<argument><expr><name><name>fs</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>PATH_TXN_CURRENT_LOCK</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>APR_INLINE</name> <specifier>const</specifier> <name>char</name> *</type>
<name>path_lock</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>svn_path_join</name><argument_list>(<argument><expr><name><name>fs</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>PATH_LOCK_FILE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type>
<name>path_rev_shard</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>, <param><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>fs_fs_data_t</name> *</type><name>ffd</name> <init>= <expr><name><name>fs</name>-&gt;<name>fsap_data</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>ffd</name>-&gt;<name>max_files_per_dir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>svn_path_join_many</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>fs</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>PATH_REVS_DIR</name></expr></argument>,
                            <argument><expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%ld"</expr></argument>,
                                               <argument><expr><name>rev</name> / <name><name>ffd</name>-&gt;<name>max_files_per_dir</name></name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>const</specifier> <name>char</name> *</type>
<name>svn_fs_fs__path_rev</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>, <param><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>fs_fs_data_t</name> *</type><name>ffd</name> <init>= <expr><name><name>fs</name>-&gt;<name>fsap_data</name></name></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name><name>ffd</name>-&gt;<name>max_files_per_dir</name></name></expr>)</condition><then>
    <block>{
      <return>return <expr><call><name>svn_path_join</name><argument_list>(<argument><expr><call><name>path_rev_shard</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%ld"</expr></argument>, <argument><expr><name>rev</name></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

  <return>return <expr><call><name>svn_path_join_many</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>fs</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>PATH_REVS_DIR</name></expr></argument>,
                            <argument><expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%ld"</expr></argument>, <argument><expr><name>rev</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type>
<name>path_revprops_shard</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>, <param><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>fs_fs_data_t</name> *</type><name>ffd</name> <init>= <expr><name><name>fs</name>-&gt;<name>fsap_data</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>ffd</name>-&gt;<name>max_files_per_dir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>svn_path_join_many</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>fs</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>PATH_REVPROPS_DIR</name></expr></argument>,
                            <argument><expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%ld"</expr></argument>,
                                               <argument><expr><name>rev</name> / <name><name>ffd</name>-&gt;<name>max_files_per_dir</name></name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type>
<name>path_revprops</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>, <param><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>fs_fs_data_t</name> *</type><name>ffd</name> <init>= <expr><name><name>fs</name>-&gt;<name>fsap_data</name></name></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name><name>ffd</name>-&gt;<name>max_files_per_dir</name></name></expr>)</condition><then>
    <block>{
      <return>return <expr><call><name>svn_path_join</name><argument_list>(<argument><expr><call><name>path_revprops_shard</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%ld"</expr></argument>, <argument><expr><name>rev</name></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

  <return>return <expr><call><name>svn_path_join_many</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>fs</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>PATH_REVPROPS_DIR</name></expr></argument>,
                            <argument><expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%ld"</expr></argument>, <argument><expr><name>rev</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>APR_INLINE</name> <specifier>const</specifier> <name>char</name> *</type>
<name>path_txn_dir</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>svn_path_join_many</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>fs</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>PATH_TXNS_DIR</name></expr></argument>,
                            <argument><expr><call><name>apr_pstrcat</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>PATH_EXT_TXN</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>APR_INLINE</name> <specifier>const</specifier> <name>char</name> *</type>
<name>path_txn_changes</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>svn_path_join</name><argument_list>(<argument><expr><call><name>path_txn_dir</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>PATH_CHANGES</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>APR_INLINE</name> <specifier>const</specifier> <name>char</name> *</type>
<name>path_txn_props</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>svn_path_join</name><argument_list>(<argument><expr><call><name>path_txn_dir</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>PATH_TXN_PROPS</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>APR_INLINE</name> <specifier>const</specifier> <name>char</name> *</type>
<name>path_txn_next_ids</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>svn_path_join</name><argument_list>(<argument><expr><call><name>path_txn_dir</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>PATH_NEXT_IDS</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>APR_INLINE</name> <specifier>const</specifier> <name>char</name> *</type>
<name>path_txn_proto_rev</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>fs_fs_data_t</name> *</type><name>ffd</name> <init>= <expr><name><name>fs</name>-&gt;<name>fsap_data</name></name></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name><name>ffd</name>-&gt;<name>format</name></name> &gt;= <name>SVN_FS_FS__MIN_PROTOREVS_DIR_FORMAT</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_path_join_many</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>fs</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>PATH_TXN_PROTOS_DIR</name></expr></argument>,
                              <argument><expr><call><name>apr_pstrcat</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>PATH_EXT_REV</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></then>
  <else>else
    <return>return <expr><call><name>svn_path_join</name><argument_list>(<argument><expr><call><name>path_txn_dir</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>PATH_REV</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>

<function><type><specifier>static</specifier> <name>APR_INLINE</name> <specifier>const</specifier> <name>char</name> *</type>
<name>path_txn_proto_rev_lock</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>fs_fs_data_t</name> *</type><name>ffd</name> <init>= <expr><name><name>fs</name>-&gt;<name>fsap_data</name></name></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name><name>ffd</name>-&gt;<name>format</name></name> &gt;= <name>SVN_FS_FS__MIN_PROTOREVS_DIR_FORMAT</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_path_join_many</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>fs</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>PATH_TXN_PROTOS_DIR</name></expr></argument>,
                              <argument><expr><call><name>apr_pstrcat</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>PATH_EXT_REV_LOCK</name></expr></argument>, 
                                          <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></then>
  <else>else
    <return>return <expr><call><name>svn_path_join</name><argument_list>(<argument><expr><call><name>path_txn_dir</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>PATH_REV_LOCK</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type>
<name>path_txn_node_rev</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>id</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name> <init>= <expr><call><name>svn_fs_fs__id_txn_id</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>node_id</name> <init>= <expr><call><name>svn_fs_fs__id_node_id</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copy_id</name> <init>= <expr><call><name>svn_fs_fs__id_copy_id</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name> <init>= <expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>PATH_PREFIX_NODE</name> "%s.%s"</expr></argument>,
                                  <argument><expr><name>node_id</name></expr></argument>, <argument><expr><name>copy_id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <return>return <expr><call><name>svn_path_join</name><argument_list>(<argument><expr><call><name>path_txn_dir</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>APR_INLINE</name> <specifier>const</specifier> <name>char</name> *</type>
<name>path_txn_node_props</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>id</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>apr_pstrcat</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><call><name>path_txn_node_rev</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>PATH_EXT_PROPS</name></expr></argument>,
                     <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>APR_INLINE</name> <specifier>const</specifier> <name>char</name> *</type>
<name>path_txn_node_children</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>id</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>apr_pstrcat</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><call><name>path_txn_node_rev</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                     <argument><expr><name>PATH_EXT_CHILDREN</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>APR_INLINE</name> <specifier>const</specifier> <name>char</name> *</type>
<name>path_node_origin</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>node_id</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>node_id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>node_id_minus_last_char</name> <init>=
    <expr>(<name>len</name> == 1) ? "0" : <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>node_id</name></expr></argument>, <argument><expr><name>len</name> - 1</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <return>return <expr><call><name>svn_path_join_many</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>fs</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>PATH_NODE_ORIGINS_DIR</name></expr></argument>,
                            <argument><expr><name>node_id_minus_last_char</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<escape char="0xc"/>
<comment type="block">/* Functions for working with shared transaction data. */</comment>

<comment type="block">/* Return the transaction object for transaction TXN_ID from the
   transaction list of filesystem FS (which must already be locked via the
   txn_list_lock mutex).  If the transaction does not exist in the list,
   then create a new transaction object and return it (if CREATE_NEW is
   true) or return NULL (otherwise). */</comment>
<function><type><specifier>static</specifier> <name>fs_fs_shared_txn_data_t</name> *</type>
<name>get_shared_txn</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>, <param><decl><type><name>svn_boolean_t</name></type> <name>create_new</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>fs_fs_data_t</name> *</type><name>ffd</name> <init>= <expr><name><name>fs</name>-&gt;<name>fsap_data</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>fs_fs_shared_data_t</name> *</type><name>ffsd</name> <init>= <expr><name><name>ffd</name>-&gt;<name>shared</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>fs_fs_shared_txn_data_t</name> *</type><name>txn</name></decl>;</decl_stmt>

  <for>for (<init><expr><name>txn</name> = <name><name>ffsd</name>-&gt;<name>txns</name></name></expr>;</init> <condition><expr><name>txn</name></expr>;</condition> <incr><expr><name>txn</name> = <name><name>txn</name>-&gt;<name>next</name></name></expr></incr>)
    <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>txn</name>-&gt;<name>txn_id</name></name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
      <break>break;</break></then></if></for>

  <if>if <condition>(<expr><name>txn</name> || !<name>create_new</name></expr>)</condition><then>
    <return>return <expr><name>txn</name></expr>;</return></then></if>

  <comment type="block">/* Use the transaction object from the (single-object) freelist,
     if one is available, or otherwise create a new object. */</comment>
  <if>if <condition>(<expr><name><name>ffsd</name>-&gt;<name>free_txn</name></name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>txn</name> = <name><name>ffsd</name>-&gt;<name>free_txn</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>ffsd</name>-&gt;<name>free_txn</name></name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name><name>ffsd</name>-&gt;<name>common_pool</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>txn</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>txn</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>txn</name>-&gt;<name>pool</name></name> = <name>subpool</name></expr>;</expr_stmt>
    }</block></else></if>

  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>txn_id</name></expr></argument>)</argument_list></call> &lt; <sizeof>sizeof<argument_list>(<argument><expr><name><name>txn</name>-&gt;<name>txn_id</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>txn</name>-&gt;<name>txn_id</name></name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>txn</name>-&gt;<name>being_written</name></name> = <name>FALSE</name></expr>;</expr_stmt>

  <comment type="block">/* Link this transaction into the head of the list.  We will typically
     be dealing with only one active transaction at a time, so it makes
     sense for searches through the transaction list to look at the
     newest transactions first.  */</comment>
  <expr_stmt><expr><name><name>txn</name>-&gt;<name>next</name></name> = <name><name>ffsd</name>-&gt;<name>txns</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ffsd</name>-&gt;<name>txns</name></name> = <name>txn</name></expr>;</expr_stmt>

  <return>return <expr><name>txn</name></expr>;</return>
}</block></function>

<comment type="block">/* Free the transaction object for transaction TXN_ID, and remove it
   from the transaction list of filesystem FS (which must already be
   locked via the txn_list_lock mutex).  Do nothing if the transaction
   does not exist. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>free_shared_txn</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>fs_fs_data_t</name> *</type><name>ffd</name> <init>= <expr><name><name>fs</name>-&gt;<name>fsap_data</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>fs_fs_shared_data_t</name> *</type><name>ffsd</name> <init>= <expr><name><name>ffd</name>-&gt;<name>shared</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>fs_fs_shared_txn_data_t</name> *</type><name>txn</name></decl>, *<decl><type ref="prev"/><name>prev</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

  <for>for (<init><expr><name>txn</name> = <name><name>ffsd</name>-&gt;<name>txns</name></name></expr>;</init> <condition><expr><name>txn</name></expr>;</condition> <incr><expr><name>prev</name> = <name>txn</name></expr>, <expr><name>txn</name> = <name><name>txn</name>-&gt;<name>next</name></name></expr></incr>)
    <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>txn</name>-&gt;<name>txn_id</name></name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
      <break>break;</break></then></if></for>

  <if>if <condition>(<expr>!<name>txn</name></expr>)</condition><then>
    <return>return;</return></then></if>

  <if>if <condition>(<expr><name>prev</name></expr>)</condition><then>
    <expr_stmt><expr><name><name>prev</name>-&gt;<name>next</name></name> = <name><name>txn</name>-&gt;<name>next</name></name></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name><name>ffsd</name>-&gt;<name>txns</name></name> = <name><name>txn</name>-&gt;<name>next</name></name></expr>;</expr_stmt></else></if>

  <comment type="block">/* As we typically will be dealing with one transaction after another,
     we will maintain a single-object free list so that we can hopefully
     keep reusing the same transaction object. */</comment>
  <if>if <condition>(<expr>!<name><name>ffsd</name>-&gt;<name>free_txn</name></name></expr>)</condition><then>
    <expr_stmt><expr><name><name>ffsd</name>-&gt;<name>free_txn</name></name> = <name>txn</name></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name><name>txn</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
}</block></function>


<comment type="block">/* Obtain a lock on the transaction list of filesystem FS, call BODY
   with FS, BATON, and POOL, and then unlock the transaction list.
   Return what BODY returned. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>with_txnlist_lock</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                  <param><function_decl><type><name>svn_error_t</name> *</type>(*<name>body</name>)<parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                                       <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>baton</name></decl></param>,
                                       <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list></function_decl></param>,
                  <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>,
                  <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAS_THREADS</name></expr></cpp:if>
  <decl_stmt><decl><type><name>fs_fs_data_t</name> *</type><name>ffd</name> <init>= <expr><name><name>fs</name>-&gt;<name>fsap_data</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>fs_fs_shared_data_t</name> *</type><name>ffsd</name> <init>= <expr><name><name>ffd</name>-&gt;<name>shared</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_status_t</name></type> <name>apr_err</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>apr_err</name> = <call><name>apr_thread_mutex_lock</name><argument_list>(<argument><expr><name><name>ffsd</name>-&gt;<name>txn_list_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>apr_err</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_wrap_apr</name><argument_list>(<argument><expr><name>apr_err</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't grab FSFS txn list mutex"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><name>err</name> = <call><name>body</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAS_THREADS</name></expr></cpp:if>
  <expr_stmt><expr><name>apr_err</name> = <call><name>apr_thread_mutex_unlock</name><argument_list>(<argument><expr><name><name>ffsd</name>-&gt;<name>txn_list_lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>apr_err</name> &amp;&amp; !<name>err</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_wrap_apr</name><argument_list>(<argument><expr><name>apr_err</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't ungrab FSFS txn list mutex"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <return>return <expr><name>err</name></expr>;</return>
}</block></function>


<comment type="block">/* Get a lock on empty file LOCK_FILENAME, creating it in POOL. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>get_lock_on_filesystem</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>lock_filename</name></decl></param>,
                       <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name> <init>= <expr><call><name>svn_io_file_lock2</name><argument_list>(<argument><expr><name>lock_filename</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>err</name> &amp;&amp; <call><name>APR_STATUS_IS_ENOENT</name><argument_list>(<argument><expr><name><name>err</name>-&gt;<name>apr_err</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <comment type="block">/* No lock file?  No big deal; these are just empty files
         anyway.  Create it and try again. */</comment>
      <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>err</name> = <name>NULL</name></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_create</name><argument_list>(<argument><expr><name>lock_filename</name></expr></argument>, <argument><expr>""</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_lock2</name><argument_list>(<argument><expr><name>lock_filename</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <return>return <expr><name>err</name></expr>;</return>
}</block></function>

<comment type="block">/* Obtain a write lock on the file LOCK_FILENAME (protecting with
   LOCK_MUTEX if APR is threaded) in a subpool of POOL, call BODY with
   BATON and that subpool, destroy the subpool (releasing the write
   lock) and return what BODY returned. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>with_some_lock</name><parameter_list>(<param><function_decl><type><name>svn_error_t</name> *</type>(*<name>body</name>)<parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>,
                                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list></function_decl></param>,
               <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>,
               <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>lock_filename</name></decl></param>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAS_THREADS</name></expr></cpp:if>
               <param><decl><type><name>apr_thread_mutex_t</name> *</type><name>lock_mutex</name></decl></param>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
               <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAS_THREADS</name></expr></cpp:if>
  <decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name></decl>;</decl_stmt>

  <comment type="block">/* POSIX fcntl locks are per-process, so we need to serialize locks
     within the process. */</comment>
  <expr_stmt><expr><name>status</name> = <call><name>apr_thread_mutex_lock</name><argument_list>(<argument><expr><name>lock_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>status</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_wrap_apr</name><argument_list>(<argument><expr><name>status</name></expr></argument>, 
                              <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't grab FSFS mutex for '%s'"</expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><name>lock_filename</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <expr_stmt><expr><name>err</name> = <call><name>get_lock_on_filesystem</name><argument_list>(<argument><expr><name>lock_filename</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr>!<name>err</name></expr>)</condition><then>
    <expr_stmt><expr><name>err</name> = <call><name>body</name><argument_list>(<argument><expr><name>baton</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAS_THREADS</name></expr></cpp:if>
  <expr_stmt><expr><name>status</name> = <call><name>apr_thread_mutex_unlock</name><argument_list>(<argument><expr><name>lock_mutex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>status</name> &amp;&amp; !<name>err</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_wrap_apr</name><argument_list>(<argument><expr><name>status</name></expr></argument>,
                              <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't ungrab FSFS mutex for '%s'"</expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><name>lock_filename</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <return>return <expr><name>err</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__with_write_lock</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                           <param><function_decl><type><name>svn_error_t</name> *</type>(*<name>body</name>)<parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>,
                                                <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list></function_decl></param>,
                           <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>,
                           <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAS_THREADS</name></expr></cpp:if>
  <decl_stmt><decl><type><name>fs_fs_data_t</name> *</type><name>ffd</name> <init>= <expr><name><name>fs</name>-&gt;<name>fsap_data</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>fs_fs_shared_data_t</name> *</type><name>ffsd</name> <init>= <expr><name><name>ffd</name>-&gt;<name>shared</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_thread_mutex_t</name> *</type><name>mutex</name> <init>= <expr><name><name>ffsd</name>-&gt;<name>fs_write_lock</name></name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <return>return <expr><call><name>with_some_lock</name><argument_list>(<argument><expr><name>body</name></expr></argument>, <argument><expr><name>baton</name></expr></argument>,
                        <argument><expr><call><name>path_lock</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAS_THREADS</name></expr></cpp:if>
                        <argument><expr><name>mutex</name></expr></argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                        <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Run BODY (with BATON and POOL) while the txn-current file
   of FS is locked. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>with_txn_current_lock</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                      <param><function_decl><type><name>svn_error_t</name> *</type>(*<name>body</name>)<parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>,
                                           <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list></function_decl></param>,
                      <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>,
                      <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAS_THREADS</name></expr></cpp:if>
  <decl_stmt><decl><type><name>fs_fs_data_t</name> *</type><name>ffd</name> <init>= <expr><name><name>fs</name>-&gt;<name>fsap_data</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>fs_fs_shared_data_t</name> *</type><name>ffsd</name> <init>= <expr><name><name>ffd</name>-&gt;<name>shared</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_thread_mutex_t</name> *</type><name>mutex</name> <init>= <expr><name><name>ffsd</name>-&gt;<name>txn_current_lock</name></name></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <return>return <expr><call><name>with_some_lock</name><argument_list>(<argument><expr><name>body</name></expr></argument>, <argument><expr><name>baton</name></expr></argument>,
                        <argument><expr><call><name>path_txn_current_lock</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>APR_HAS_THREADS</name></expr></cpp:if>
                        <argument><expr><name>mutex</name></expr></argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                        <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* A structure used by unlock_proto_rev() and unlock_proto_rev_body(),
   which see. */</comment>
<struct>struct <name>unlock_proto_rev_baton</name>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> *</type><name>lockcookie</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/* Callback used in the implementation of unlock_proto_rev(). */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>unlock_proto_rev_body</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> struct <name>unlock_proto_rev_baton</name> *</type><name>b</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name> <init>= <expr><name><name>b</name>-&gt;<name>txn_id</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>lockfile</name> <init>= <expr><name><name>b</name>-&gt;<name>lockcookie</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>fs_fs_shared_txn_data_t</name> *</type><name>txn</name> <init>= <expr><call><name>get_shared_txn</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_status_t</name></type> <name>apr_err</name></decl>;</decl_stmt>

  <if>if <condition>(<expr>!<name>txn</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't unlock unknown transaction '%s'"</expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><name>txn_id</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
  <if>if <condition>(<expr>!<name><name>txn</name>-&gt;<name>being_written</name></name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't unlock nonlocked transaction '%s'"</expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><name>txn_id</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><name>apr_err</name> = <call><name>apr_file_unlock</name><argument_list>(<argument><expr><name>lockfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>apr_err</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_wrap_apr</name>
      <argument_list>(<argument><expr><name>apr_err</name></expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't unlock prototype revision lockfile for transaction '%s'"</expr></argument>)</argument_list></call></expr></argument>,
       <argument><expr><name>txn_id</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
  <expr_stmt><expr><name>apr_err</name> = <call><name>apr_file_close</name><argument_list>(<argument><expr><name>lockfile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>apr_err</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_wrap_apr</name>
      <argument_list>(<argument><expr><name>apr_err</name></expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't close prototype revision lockfile for transaction '%s'"</expr></argument>)</argument_list></call></expr></argument>,
       <argument><expr><name>txn_id</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><name><name>txn</name>-&gt;<name>being_written</name></name> = <name>FALSE</name></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Unlock the prototype revision file for transaction TXN_ID in filesystem
   FS using cookie LOCKCOOKIE.  The original prototype revision file must
   have been closed _before_ calling this function.

   Perform temporary allocations in POOL. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>unlock_proto_rev</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>, <param><decl><type><name>void</name> *</type><name>lockcookie</name></decl></param>,
                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>unlock_proto_rev_baton</name></type> <name>b</name></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>b</name>.<name>txn_id</name></name> = <name>txn_id</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>b</name>.<name>lockcookie</name></name> = <name>lockcookie</name></expr>;</expr_stmt>
  <return>return <expr><call><name>with_txnlist_lock</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>unlock_proto_rev_body</name></expr></argument>, <argument><expr>&amp;<name>b</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Same as unlock_proto_rev(), but requires that the transaction list
   lock is already held. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>unlock_proto_rev_list_locked</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>,
                             <param><decl><type><name>void</name> *</type><name>lockcookie</name></decl></param>,
                             <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>unlock_proto_rev_baton</name></type> <name>b</name></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>b</name>.<name>txn_id</name></name> = <name>txn_id</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>b</name>.<name>lockcookie</name></name> = <name>lockcookie</name></expr>;</expr_stmt>
  <return>return <expr><call><name>unlock_proto_rev_body</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr>&amp;<name>b</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* A structure used by get_writable_proto_rev() and
   get_writable_proto_rev_body(), which see. */</comment>
<struct>struct <name>get_writable_proto_rev_baton</name>
<block>{
  <decl_stmt><decl><type><name>apr_file_t</name> **</type><name>file</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> **</type><name>lockcookie</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/* Callback used in the implementation of get_writable_proto_rev(). */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>get_writable_proto_rev_body</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> struct <name>get_writable_proto_rev_baton</name> *</type><name>b</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_file_t</name> **</type><name>file</name> <init>= <expr><name><name>b</name>-&gt;<name>file</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> **</type><name>lockcookie</name> <init>= <expr><name><name>b</name>-&gt;<name>lockcookie</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name> <init>= <expr><name><name>b</name>-&gt;<name>txn_id</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>fs_fs_shared_txn_data_t</name> *</type><name>txn</name> <init>= <expr><call><name>get_shared_txn</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="block">/* First, ensure that no thread in this process (including this one)
     is currently writing to this transaction's proto-rev file. */</comment>
  <if>if <condition>(<expr><name><name>txn</name>-&gt;<name>being_written</name></name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_FS_REP_BEING_WRITTEN</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Cannot write to the prototype revision file "
                               "of transaction '%s' because a previous "
                               "representation is currently being written by "
                               "this process"</expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><name>txn_id</name></expr></argument>)</argument_list></call></expr>;</return></then></if>


  <comment type="block">/* We know that no thread in this process is writing to the proto-rev
     file, and by extension, that no thread in this process is holding a
     lock on the prototype revision lock file.  It is therefore safe
     for us to attempt to lock this file, to see if any other process
     is holding a lock. */</comment>

  <block>{
    <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>lockfile</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_status_t</name></type> <name>apr_err</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>lockfile_path</name> <init>= <expr><call><name>path_txn_proto_rev_lock</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

    <comment type="block">/* Open the proto-rev lockfile, creating it if necessary, as it may
       not exist if the transaction dates from before the lockfiles were
       introduced.

       ### We'd also like to use something like svn_io_file_lock2(), but
           that forces us to create a subpool just to be able to unlock
           the file, which seems a waste. */</comment>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_open</name><argument_list>(<argument><expr>&amp;<name>lockfile</name></expr></argument>, <argument><expr><name>lockfile_path</name></expr></argument>,
                             <argument><expr><name>APR_WRITE</name> | <name>APR_CREATE</name></expr></argument>, <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>apr_err</name> = <call><name>apr_file_lock</name><argument_list>(<argument><expr><name>lockfile</name></expr></argument>,
                            <argument><expr><name>APR_FLOCK_EXCLUSIVE</name> | <name>APR_FLOCK_NONBLOCK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>apr_err</name></expr>)</condition><then>
      <block>{
        <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><call><name>svn_io_file_close</name><argument_list>(<argument><expr><name>lockfile</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <if>if <condition>(<expr><call><name>APR_STATUS_IS_EAGAIN</name><argument_list>(<argument><expr><name>apr_err</name></expr></argument>)</argument_list></call></expr>)</condition><then>
          <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_FS_REP_BEING_WRITTEN</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                   <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Cannot write to the prototype revision "
                                     "file of transaction '%s' because a "
                                     "previous representation is currently "
                                     "being written by another process"</expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr><name>txn_id</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

        <return>return <expr><call><name>svn_error_wrap_apr</name><argument_list>(<argument><expr><name>apr_err</name></expr></argument>,
                                  <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't get exclusive lock on file '%s'"</expr></argument>)</argument_list></call></expr></argument>,
                                  <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>lockfile_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
      }</block></then></if>

    <expr_stmt><expr>*<name>lockcookie</name> = <name>lockfile</name></expr>;</expr_stmt>
  }</block>

  <comment type="block">/* We've successfully locked the transaction; mark it as such. */</comment>
  <expr_stmt><expr><name><name>txn</name>-&gt;<name>being_written</name></name> = <name>TRUE</name></expr>;</expr_stmt>


  <comment type="block">/* Now open the prototype revision file and seek to the end. */</comment>
  <expr_stmt><expr><name>err</name> = <call><name>svn_io_file_open</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><call><name>path_txn_proto_rev</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                         <argument><expr><name>APR_WRITE</name> | <name>APR_BUFFERED</name></expr></argument>, <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* You might expect that we could dispense with the following seek
     and achieve the same thing by opening the file using APR_APPEND.
     Unfortunately, APR's buffered file implementation unconditionally
     places its initial file pointer at the start of the file (even for
     files opened with APR_APPEND), so we need this seek to reconcile
     the APR file pointer to the OS file pointer (since we need to be
     able to read the current file position later). */</comment>
  <if>if <condition>(<expr>!<name>err</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>apr_off_t</name></type> <name>offset</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>err</name> = <call><name>svn_io_file_seek</name><argument_list>(<argument><expr>*<name>file</name></expr></argument>, <argument><expr><name>APR_END</name></expr></argument>, <argument><expr>&amp;<name>offset</name></expr></argument>, <argument><expr>0</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><call><name>unlock_proto_rev_list_locked</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr>*<name>lockcookie</name></expr></argument>,
                                                   <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>lockcookie</name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></then></if>

  <return>return <expr><name>err</name></expr>;</return>
}</block></function>

<comment type="block">/* Get a handle to the prototype revision file for transaction TXN_ID in
   filesystem FS, and lock it for writing.  Return FILE, a file handle
   positioned at the end of the file, and LOCKCOOKIE, a cookie that
   should be passed to unlock_proto_rev() to unlock the file once FILE
   has been closed.

   If the prototype revision file is already locked, return error
   SVN_ERR_FS_REP_BEING_WRITTEN.

   Perform all allocations in POOL. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>get_writable_proto_rev</name><parameter_list>(<param><decl><type><name>apr_file_t</name> **</type><name>file</name></decl></param>,
                       <param><decl><type><name>void</name> **</type><name>lockcookie</name></decl></param>,
                       <param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>,
                       <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>get_writable_proto_rev_baton</name></type> <name>b</name></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>b</name>.<name>file</name></name> = <name>file</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>b</name>.<name>lockcookie</name></name> = <name>lockcookie</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>b</name>.<name>txn_id</name></name> = <name>txn_id</name></expr>;</expr_stmt>

  <return>return <expr><call><name>with_txnlist_lock</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>get_writable_proto_rev_body</name></expr></argument>, <argument><expr>&amp;<name>b</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Callback used in the implementation of purge_shared_txn(). */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>purge_shared_txn_body</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name> <init>= <expr>*(const <name>char</name> **)<name>baton</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>free_shared_txn</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Purge the shared data for transaction TXN_ID in filesystem FS.
   Perform all allocations in POOL. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>purge_shared_txn</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>with_txnlist_lock</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>purge_shared_txn_body</name></expr></argument>, <argument><expr>(<name>char</name> **) &amp;<name>txn_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
<escape char="0xc"/>


<comment type="block">/* Fetch the current offset of FILE into *OFFSET_P. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>get_file_offset</name><parameter_list>(<param><decl><type><name>apr_off_t</name> *</type><name>offset_p</name></decl></param>, <param><decl><type><name>apr_file_t</name> *</type><name>file</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_off_t</name></type> <name>offset</name></decl>;</decl_stmt>

  <comment type="block">/* Note that, for buffered files, one (possibly surprising) side-effect
     of this call is to flush any unwritten data to disk. */</comment>
  <expr_stmt><expr><name>offset</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_seek</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>APR_CUR</name></expr></argument>, <argument><expr>&amp;<name>offset</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>offset_p</name> = <name>offset</name></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Check that BUF, a buffer of text from format file PATH, contains
   only digits, raising error SVN_ERR_BAD_VERSION_FILE_FORMAT if not.

   Uses POOL for temporary allocation. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>check_format_file_buffer_numeric</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>buf</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name></decl>;</decl_stmt>

  <for>for (<init><expr><name>p</name> = <name>buf</name></expr>;</init> <condition><expr>*<name>p</name></expr>;</condition> <incr><expr><name>p</name>++</expr></incr>)
    <if>if <condition>(<expr>!<call><name>apr_isdigit</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_BAD_VERSION_FILE_FORMAT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
        <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Format file '%s' contains an unexpected non-digit"</expr></argument>)</argument_list></call></expr></argument>,
        <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if></for>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Read the format number and maximum number of files per directory
   from PATH and return them in *PFORMAT and *MAX_FILES_PER_DIR
   respectively.

   *MAX_FILES_PER_DIR is obtained from the 'layout' format option, and
   will be set to zero if a linear scheme should be used.

   Use POOL for temporary allocation. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>read_format</name><parameter_list>(<param><decl><type><name>int</name> *</type><name>pformat</name></decl></param>, <param><decl><type><name>int</name> *</type><name>max_files_per_dir</name></decl></param>,
            <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>file</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>80</expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>err</name> = <call><name>svn_io_file_open</name><argument_list>(<argument><expr>&amp;<name>file</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>APR_READ</name> | <name>APR_BUFFERED</name></expr></argument>,
                         <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>err</name> &amp;&amp; <call><name>APR_STATUS_IS_ENOENT</name><argument_list>(<argument><expr><name><name>err</name>-&gt;<name>apr_err</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <comment type="block">/* Treat an absent format file as format 1.  Do not try to
         create the format file on the fly, because the repository
         might be read-only for us, or this might be a read-only
         operation, and the spirit of FSFS is to make no changes
         whatseover in read-only operations.  See thread starting at
         http://subversion.tigris.org/servlets/ReadMsg?list=dev&amp;msgNo=97600
         for more. */</comment>
      <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>pformat</name> = 1</expr>;</expr_stmt>
      <expr_stmt><expr>*<name>max_files_per_dir</name> = 0</expr>;</expr_stmt>

      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>

  <expr_stmt><expr><name>len</name> = <sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
  <expr_stmt><expr><name>err</name> = <call><name>svn_io_read_length_line</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>err</name> &amp;&amp; <call><name>APR_STATUS_IS_EOF</name><argument_list>(<argument><expr><name><name>err</name>-&gt;<name>apr_err</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <comment type="block">/* Return a more useful error message. */</comment>
      <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_BAD_VERSION_FILE_FORMAT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                               <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't read first line of format file '%s'"</expr></argument>)</argument_list></call></expr></argument>,
                               <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check that the first line contains only digits. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>check_format_file_buffer_numeric</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>pformat</name> = <call><name>atoi</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Set the default values for anything that can be set via an option. */</comment>
  <expr_stmt><expr>*<name>max_files_per_dir</name> = 0</expr>;</expr_stmt>

  <comment type="block">/* Read any options. */</comment>
  <while>while <condition>(<expr>1</expr>)</condition>
    <block>{
      <expr_stmt><expr><name>len</name> = <sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
      <expr_stmt><expr><name>err</name> = <call><name>svn_io_read_length_line</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>err</name> &amp;&amp; <call><name>APR_STATUS_IS_EOF</name><argument_list>(<argument><expr><name><name>err</name>-&gt;<name>apr_err</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <comment type="block">/* No more options; that's okay. */</comment>
          <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>
        }</block></then></if>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr>*<name>pformat</name> &gt;= <name>SVN_FS_FS__MIN_LAYOUT_FORMAT_OPTION_FORMAT</name> &amp;&amp;
          <call><name>strncmp</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>"layout "</expr></argument>, <argument><expr>7</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
        <block>{
          <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>buf</name>+7</expr></argument>, <argument><expr>"linear"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
            <block>{
              <expr_stmt><expr>*<name>max_files_per_dir</name> = 0</expr>;</expr_stmt>
              <continue>continue;</continue>
            }</block></then></if>

          <if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>buf</name>+7</expr></argument>, <argument><expr>"sharded "</expr></argument>, <argument><expr>8</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
            <block>{
              <comment type="block">/* Check that the argument is numeric. */</comment>
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>check_format_file_buffer_numeric</name><argument_list>(<argument><expr><name>buf</name>+15</expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr>*<name>max_files_per_dir</name> = <call><name>atoi</name><argument_list>(<argument><expr><name>buf</name>+15</expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <continue>continue;</continue>
            }</block></then></if>
        }</block></then></if>

      <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_BAD_VERSION_FILE_FORMAT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
         <argument><expr><call><name>_</name><argument_list>(<argument><expr>"'%s' contains invalid filesystem format option '%s'"</expr></argument>)</argument_list></call></expr></argument>,
         <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></while>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_close</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Write the format number and maximum number of files per directory
   to a new format file in PATH, possibly expecting to overwrite a
   previously existing file.

   Use POOL for temporary allocation. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>write_format</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><name>int</name></type> <name>format</name></decl></param>, <param><decl><type><name>int</name></type> <name>max_files_per_dir</name></decl></param>,
             <param><decl><type><name>svn_boolean_t</name></type> <name>overwrite</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>contents</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name> <argument_list>(<argument><expr>1 &lt;= <name>format</name> &amp;&amp; <name>format</name> &lt;= <name>SVN_FS_FS__FORMAT_NUMBER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>format</name> &gt;= <name>SVN_FS_FS__MIN_LAYOUT_FORMAT_OPTION_FORMAT</name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr><name>max_files_per_dir</name></expr>)</condition><then>
        <expr_stmt><expr><name>contents</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>,
                                <argument><expr>"%d\n"
                                "layout sharded %d\n"</expr></argument>,
                                <argument><expr><name>format</name></expr></argument>, <argument><expr><name>max_files_per_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
      <else>else
        <expr_stmt><expr><name>contents</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>,
                                <argument><expr>"%d\n"
                                "layout linear"</expr></argument>,
                                <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
    }</block></then>
  <else>else
    <block>{
      <expr_stmt><expr><name>contents</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%d\n"</expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

  <comment type="block">/* svn_io_write_version_file() does a load of magic to allow it to
     replace version files that already exist.  We only need to do
     that when we're allowed to overwrite an existing file. */</comment>
  <if>if <condition>(<expr>! <name>overwrite</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* Create the file */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_create</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>contents</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>format_file</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path_tmp</name></decl>;</decl_stmt>
      
      <comment type="block">/* Create a temporary file to write the data to */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_open_unique_file2</name><argument_list>(<argument><expr>&amp;<name>format_file</name></expr></argument>, <argument><expr>&amp;<name>path_tmp</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr>".tmp"</expr></argument>,
                                       <argument><expr><name>svn_io_file_del_none</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* ...dump out our version number string... */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_write_full</name><argument_list>(<argument><expr><name>format_file</name></expr></argument>, <argument><expr><name>contents</name></expr></argument>,
                                     <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>contents</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* ...and close the file. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_close</name><argument_list>(<argument><expr><name>format_file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
      <comment type="block">/* make the destination writable, but only on Windows, because
         Windows does not let us replace read-only files. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_set_file_read_write</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* WIN32 */</comment>

      <comment type="block">/* rename the temp file as the real destination */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_rename</name><argument_list>(<argument><expr><name>path_tmp</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

  <comment type="block">/* And set the perms to make it read only */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_set_file_read_only</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Return the error SVN_ERR_FS_UNSUPPORTED_FORMAT if FS's format
   number is not the same as a format number supported by this
   Subversion. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>check_format</name><parameter_list>(<param><decl><type><name>int</name></type> <name>format</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* We support all formats from 1-current simultaneously */</comment>
  <if>if <condition>(<expr>1 &lt;= <name>format</name> &amp;&amp; <name>format</name> &lt;= <name>SVN_FS_FS__FORMAT_NUMBER</name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_FS_UNSUPPORTED_FORMAT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
     <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Expected FS format between '1' and '%d'; found format '%d'"</expr></argument>)</argument_list></call></expr></argument>,
     <argument><expr><name>SVN_FS_FS__FORMAT_NUMBER</name></expr></argument>, <argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>svn_boolean_t</name></type>
<name>svn_fs_fs__fs_supports_mergeinfo</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>fs_fs_data_t</name> *</type><name>ffd</name> <init>= <expr><name><name>fs</name>-&gt;<name>fsap_data</name></name></expr></init></decl>;</decl_stmt>
  <return>return <expr><name><name>ffd</name>-&gt;<name>format</name></name> &gt;= <name>SVN_FS_FS__MIN_MERGEINFO_FORMAT</name></expr>;</return>
}</block></function>

<function_decl><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>get_youngest</name><parameter_list>(<param><decl><type><name>svn_revnum_t</name> *</type><name>youngest_p</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fs_path</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>

<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__open</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>fs_fs_data_t</name> *</type><name>ffd</name> <init>= <expr><name><name>fs</name>-&gt;<name>fsap_data</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>uuid_file</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>format</name></decl>, <decl><type ref="prev"/><name>max_files_per_dir</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>APR_UUID_FORMATTED_LENGTH</name> + 2</expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>limit</name></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>fs</name>-&gt;<name>path</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>fs</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Read the FS format number. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>read_format</name><argument_list>(<argument><expr>&amp;<name>format</name></expr></argument>, <argument><expr>&amp;<name>max_files_per_dir</name></expr></argument>,
                      <argument><expr><call><name>path_format</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Now we've got a format number no matter what. */</comment>
  <expr_stmt><expr><name><name>ffd</name>-&gt;<name>format</name></name> = <name>format</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ffd</name>-&gt;<name>max_files_per_dir</name></name> = <name>max_files_per_dir</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>check_format</name><argument_list>(<argument><expr><name>format</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Read in and cache the repository uuid. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_open</name><argument_list>(<argument><expr>&amp;<name>uuid_file</name></expr></argument>, <argument><expr><call><name>path_uuid</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><name>APR_READ</name> | <name>APR_BUFFERED</name></expr></argument>, <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>limit</name> = <sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_read_length_line</name><argument_list>(<argument><expr><name>uuid_file</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr>&amp;<name>limit</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ffd</name>-&gt;<name>uuid</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>fs</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_close</name><argument_list>(<argument><expr><name>uuid_file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_youngest</name><argument_list>(<argument><expr>&amp;(<name><name>ffd</name>-&gt;<name>youngest_rev_cache</name></name>)</expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Wrapper around svn_io_file_create which ignores EEXIST. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>create_file_ignore_eexist</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>file</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>contents</name></decl></param>,
                          <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name> <init>= <expr><call><name>svn_io_file_create</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>contents</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>err</name> &amp;&amp; <call><name>APR_STATUS_IS_EEXIST</name><argument_list>(<argument><expr><name><name>err</name>-&gt;<name>apr_err</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>err</name> = <name>SVN_NO_ERROR</name></expr>;</expr_stmt>
    }</block></then></if>
  <return>return <expr><name>err</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>upgrade_body</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>format</name></decl>, <decl><type ref="prev"/><name>max_files_per_dir</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>format_path</name> <init>= <expr><call><name>path_format</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Read the FS format number and max-files-per-dir setting. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>read_format</name><argument_list>(<argument><expr>&amp;<name>format</name></expr></argument>, <argument><expr>&amp;<name>max_files_per_dir</name></expr></argument>, <argument><expr><name>format_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If we're already up-to-date, there's nothing to be done here. */</comment>
  <if>if <condition>(<expr><name>format</name> == <name>SVN_FS_FS__FORMAT_NUMBER</name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <comment type="block">/* If our filesystem predates the existance of the 'txn-current
     file', make that file and its corresponding lock file. */</comment>
  <if>if <condition>(<expr><name>format</name> &lt; <name>SVN_FS_FS__MIN_TXN_CURRENT_FORMAT</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>create_file_ignore_eexist</name><argument_list>(<argument><expr><call><name>path_txn_current</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"0\n"</expr></argument>,
                                        <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>create_file_ignore_eexist</name><argument_list>(<argument><expr><call><name>path_txn_current_lock</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>""</expr></argument>,
                                        <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* If our filesystem predates the existance of the 'txn-protorevs'
     dir, make that directory.  */</comment>
  <if>if <condition>(<expr><name>format</name> &lt; <name>SVN_FS_FS__MIN_PROTOREVS_DIR_FORMAT</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* We don't use path_txn_proto_rev() here because it expects
         we've already bumped our format. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_make_dir_recursively</name>
              <argument_list>(<argument><expr><call><name>svn_path_join</name><argument_list>(<argument><expr><name><name>fs</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>PATH_TXN_PROTOS_DIR</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* Bump the format file.  We pass 0 for the max_files_per_dir here
     so we don't have to fuss with sharding directories ourselves. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>write_format</name><argument_list>(<argument><expr><name>format_path</name></expr></argument>, <argument><expr><name>SVN_FS_FS__FORMAT_NUMBER</name></expr></argument>, <argument><expr>0</expr></argument>, 
                       <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__upgrade</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>svn_fs_fs__with_write_lock</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>upgrade_body</name></expr></argument>, <argument><expr>(<name>void</name> *)<name>fs</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<comment type="block">/* SVN_ERR-like macros for dealing with ESTALE
 *
 * In NFS v3 and under, the server doesn't track opened files.  If you
 * unlink(2) or rename(2) a file held open by another process *on the
 * same host*, that host's kernel typically renames the file to
 * .nfsXXXX and automatically deletes that when it's no longer open,
 * but this behavior is not required.
 *
 * For obvious reasons, this does not work *across hosts*.  No one
 * knows about the opened file; not the server, and not the deleting
 * client.  So the file vanishes, and the reader gets stale NFS file
 * handle.  We have this problem with revprops files, current, and
 * txn-current.
 *
 * Wrap opens and reads of such files with SVN_RETRY_ESTALE and closes
 * with SVN_IGNORE_ESTALE.  Call these macros within a loop of
 * SVN_ESTALE_RETRY_COUNT iterations (though, realistically, the
 * second try will succeed).  Make sure you put a break statement
 * after the close, at the end of your loop.  Immediately after your
 * loop, return err if err.
 *
 * You must initialize err to SVN_NO_ERROR, as these macros do not.
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_ESTALE_RETRY_COUNT</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ESTALE</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_RETRY_ESTALE</name><parameter_list>(<param><type><name>err</name></type></param>, <param><type><name>expr</name></type></param>)</parameter_list></cpp:macro>                   \
  <cpp:value>{                                                   \
    <comment type="block">/* Clear err here (svn_error_clear can safely be passed
     * SVN_NO_ERROR) rather than after finding ESTALE so we can return
     * the ESTALE error on the last iteration of the loop. */</comment> \
    svn_error_clear(err);                             \
    err = (expr);                                     \
    if (err)                                          \
      {                                               \
        if (APR_TO_OS_ERROR(err-&gt;apr_err) == ESTALE)  \
          continue;                                   \
        return err;                                   \
      }                                               \
  }</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_IGNORE_ESTALE</name><parameter_list>(<param><type><name>err</name></type></param>, <param><type><name>expr</name></type></param>)</parameter_list></cpp:macro>                  \
  <cpp:value>{                                                   \
    svn_error_clear(err);                             \
    err = (expr);                                     \
    if (err)                                          \
      {                                               \
        if (APR_TO_OS_ERROR(err-&gt;apr_err) != ESTALE)  \
          return err;                                 \
      }                                               \
  }</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_RETRY_ESTALE</name><parameter_list>(<param><type><name>err</name></type></param>, <param><type><name>expr</name></type></param>)</parameter_list></cpp:macro>  <cpp:value>SVN_ERR(expr)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_IGNORE_ESTALE</name><parameter_list>(<param><type><name>err</name></type></param>, <param><type><name>expr</name></type></param>)</parameter_list></cpp:macro> <cpp:value>SVN_ERR(expr)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* Long enough to hold: "&lt;svn_revnum_t&gt; &lt;node id&gt; &lt;copy id&gt;\0"
 * 19 bytes for svn_revnum_t (room for 32 or 64 bit values)
 * + 2 spaces
 * + 26 bytes for each id (these are actually unbounded, so we just
 *   have to pick something; 2^64 is 13 bytes in base-36)
 * + 1 terminating null
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CURRENT_BUF_LEN</name></cpp:macro> <cpp:value>48</cpp:value></cpp:define>

<comment type="block">/* Read the 'current' file FNAME and store the contents in *BUF.
   Allocations are performed in POOL. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>read_current</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fname</name></decl></param>, <param><decl><type><name>char</name> **</type><name>buf</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>revision_file</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name> <init>= <expr><name>SVN_NO_ERROR</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>iterpool</name></decl>;</decl_stmt>

  <expr_stmt><expr>*<name>buf</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>CURRENT_BUF_LEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>iterpool</name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>SVN_ESTALE_RETRY_COUNT</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>SVN_RETRY_ESTALE</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><call><name>svn_io_file_open</name><argument_list>(<argument><expr>&amp;<name>revision_file</name></expr></argument>, <argument><expr><name>fname</name></expr></argument>,
                                             <argument><expr><name>APR_READ</name> | <name>APR_BUFFERED</name></expr></argument>,
                                             <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>len</name> = <name>CURRENT_BUF_LEN</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_RETRY_ESTALE</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><call><name>svn_io_read_length_line</name><argument_list>(<argument><expr><name>revision_file</name></expr></argument>,
                                                    <argument><expr>*<name>buf</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_IGNORE_ESTALE</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><call><name>svn_io_file_close</name><argument_list>(<argument><expr><name>revision_file</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <break>break;</break>
    }</block></for>
  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>err</name></expr>;</return>
}</block></function>

<comment type="block">/* Find the youngest revision in a repository at path FS_PATH and
   return it in *YOUNGEST_P.  Perform temporary allocations in
   POOL. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>get_youngest</name><parameter_list>(<param><decl><type><name>svn_revnum_t</name> *</type><name>youngest_p</name></decl></param>,
             <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fs_path</name></decl></param>,
             <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>char</name> *</type><name>buf</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>read_current</name><argument_list>(<argument><expr><call><name>svn_path_join</name><argument_list>(<argument><expr><name>fs_path</name></expr></argument>, <argument><expr><name>PATH_CURRENT</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                       <argument><expr>&amp;<name>buf</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>youngest_p</name> = <call><name>SVN_STR_TO_REV</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__hotcopy</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>src_path</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dst_path</name></decl></param>,
                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>src_subdir</name></decl>, *<decl><type ref="prev"/><name>dst_subdir</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>youngest</name></decl>, <decl><type ref="prev"/><name>rev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>iterpool</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>format</name></decl>, <decl><type ref="prev"/><name>max_files_per_dir</name></decl>;</decl_stmt>

  <comment type="block">/* Check format to be sure we know how to hotcopy this FS. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>read_format</name><argument_list>(<argument><expr>&amp;<name>format</name></expr></argument>, <argument><expr>&amp;<name>max_files_per_dir</name></expr></argument>,
                      <argument><expr><call><name>svn_path_join</name><argument_list>(<argument><expr><name>src_path</name></expr></argument>, <argument><expr><name>PATH_FORMAT</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                      <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>check_format</name><argument_list>(<argument><expr><name>format</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Copy the current file. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_dir_file_copy</name><argument_list>(<argument><expr><name>src_path</name></expr></argument>, <argument><expr><name>dst_path</name></expr></argument>, <argument><expr><name>PATH_CURRENT</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Copy the uuid. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_dir_file_copy</name><argument_list>(<argument><expr><name>src_path</name></expr></argument>, <argument><expr><name>dst_path</name></expr></argument>, <argument><expr><name>PATH_UUID</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Find the youngest revision from this current file. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_youngest</name><argument_list>(<argument><expr>&amp;<name>youngest</name></expr></argument>, <argument><expr><name>dst_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Copy the necessary rev files. */</comment>
  <expr_stmt><expr><name>src_subdir</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>src_path</name></expr></argument>, <argument><expr><name>PATH_REVS_DIR</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>dst_subdir</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>dst_path</name></expr></argument>, <argument><expr><name>PATH_REVS_DIR</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_make_dir_recursively</name><argument_list>(<argument><expr><name>dst_subdir</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>iterpool</name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for (<init><expr><name>rev</name> = 0</expr>;</init> <condition><expr><name>rev</name> &lt;= <name>youngest</name></expr>;</condition> <incr><expr><name>rev</name>++</expr></incr>)
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>src_subdir_shard</name> <init>= <expr><name>src_subdir</name></expr></init>,
                 *<name>dst_subdir_shard</name> <init>= <expr><name>dst_subdir</name></expr></init></decl>;</decl_stmt>

      <if>if <condition>(<expr><name>max_files_per_dir</name></expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>shard</name> <init>= <expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>, <argument><expr>"%ld"</expr></argument>,
                                           <argument><expr><name>rev</name> / <name>max_files_per_dir</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>src_subdir_shard</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>src_subdir</name></expr></argument>, <argument><expr><name>shard</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>dst_subdir_shard</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>dst_subdir</name></expr></argument>, <argument><expr><name>shard</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <if>if <condition>(<expr><name>rev</name> % <name>max_files_per_dir</name> == 0</expr>)</condition><then>
            <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_dir_make</name><argument_list>(<argument><expr><name>dst_subdir_shard</name></expr></argument>, <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>,
                                    <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        }</block></then></if>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_dir_file_copy</name><argument_list>(<argument><expr><name>src_subdir_shard</name></expr></argument>, <argument><expr><name>dst_subdir_shard</name></expr></argument>,
                                   <argument><expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>, <argument><expr>"%ld"</expr></argument>, <argument><expr><name>rev</name></expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

  <comment type="block">/* Copy the necessary revprop files. */</comment>
  <expr_stmt><expr><name>src_subdir</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>src_path</name></expr></argument>, <argument><expr><name>PATH_REVPROPS_DIR</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>dst_subdir</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>dst_path</name></expr></argument>, <argument><expr><name>PATH_REVPROPS_DIR</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_make_dir_recursively</name><argument_list>(<argument><expr><name>dst_subdir</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <for>for (<init><expr><name>rev</name> = 0</expr>;</init> <condition><expr><name>rev</name> &lt;= <name>youngest</name></expr>;</condition> <incr><expr><name>rev</name>++</expr></incr>)
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>src_subdir_shard</name> <init>= <expr><name>src_subdir</name></expr></init>,
                 *<name>dst_subdir_shard</name> <init>= <expr><name>dst_subdir</name></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr><name>max_files_per_dir</name></expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>shard</name> <init>= <expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>, <argument><expr>"%ld"</expr></argument>,
                                           <argument><expr><name>rev</name> / <name>max_files_per_dir</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name>src_subdir_shard</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>src_subdir</name></expr></argument>, <argument><expr><name>shard</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>dst_subdir_shard</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>dst_subdir</name></expr></argument>, <argument><expr><name>shard</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <if>if <condition>(<expr><name>rev</name> % <name>max_files_per_dir</name> == 0</expr>)</condition><then>
            <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_dir_make</name><argument_list>(<argument><expr><name>dst_subdir_shard</name></expr></argument>, <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>,
                                    <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        }</block></then></if>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_dir_file_copy</name><argument_list>(<argument><expr><name>src_subdir_shard</name></expr></argument>, <argument><expr><name>dst_subdir_shard</name></expr></argument>,
                                   <argument><expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>, <argument><expr>"%ld"</expr></argument>, <argument><expr><name>rev</name></expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Make an empty transactions directory for now.  Eventually some
     method of copying in progress transactions will need to be
     developed.*/</comment>
  <expr_stmt><expr><name>dst_subdir</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>dst_path</name></expr></argument>, <argument><expr><name>PATH_TXNS_DIR</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_make_dir_recursively</name><argument_list>(<argument><expr><name>dst_subdir</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>format</name> &gt;= <name>SVN_FS_FS__MIN_PROTOREVS_DIR_FORMAT</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>dst_subdir</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>dst_path</name></expr></argument>, <argument><expr><name>PATH_TXN_PROTOS_DIR</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_make_dir_recursively</name><argument_list>(<argument><expr><name>dst_subdir</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* Now copy the locks tree. */</comment>
  <expr_stmt><expr><name>src_subdir</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>src_path</name></expr></argument>, <argument><expr><name>PATH_LOCKS_DIR</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_check_path</name><argument_list>(<argument><expr><name>src_subdir</name></expr></argument>, <argument><expr>&amp;<name>kind</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>kind</name> == <name>svn_node_dir</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_copy_dir_recursively</name><argument_list>(<argument><expr><name>src_subdir</name></expr></argument>, <argument><expr><name>dst_path</name></expr></argument>,
                                        <argument><expr><name>PATH_LOCKS_DIR</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                        <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* Now copy the node-origins cache tree. */</comment>
  <expr_stmt><expr><name>src_subdir</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>src_path</name></expr></argument>, <argument><expr><name>PATH_NODE_ORIGINS_DIR</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_check_path</name><argument_list>(<argument><expr><name>src_subdir</name></expr></argument>, <argument><expr>&amp;<name>kind</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>kind</name> == <name>svn_node_dir</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_copy_dir_recursively</name><argument_list>(<argument><expr><name>src_subdir</name></expr></argument>, <argument><expr><name>dst_path</name></expr></argument>,
                                        <argument><expr><name>PATH_NODE_ORIGINS_DIR</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                        <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* Copy the txn-current file. */</comment>
  <if>if <condition>(<expr><name>format</name> &gt;= <name>SVN_FS_FS__MIN_TXN_CURRENT_FORMAT</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_dir_file_copy</name><argument_list>(<argument><expr><name>src_path</name></expr></argument>, <argument><expr><name>dst_path</name></expr></argument>, <argument><expr><name>PATH_TXN_CURRENT</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* Hotcopied FS is complete. Stamp it with a format file. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>write_format</name><argument_list>(<argument><expr><call><name>svn_path_join</name><argument_list>(<argument><expr><name>dst_path</name></expr></argument>, <argument><expr><name>PATH_FORMAT</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                       <argument><expr><name>format</name></expr></argument>, <argument><expr><name>max_files_per_dir</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__youngest_rev</name><parameter_list>(<param><decl><type><name>svn_revnum_t</name> *</type><name>youngest_p</name></decl></param>,
                        <param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                        <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>fs_fs_data_t</name> *</type><name>ffd</name> <init>= <expr><name><name>fs</name>-&gt;<name>fsap_data</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_youngest</name><argument_list>(<argument><expr><name>youngest_p</name></expr></argument>, <argument><expr><name><name>fs</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ffd</name>-&gt;<name>youngest_rev_cache</name></name> = *<name>youngest_p</name></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* HEADER_CPATH lines need to be long enough to hold FSFS_MAX_PATH_LEN
 * bytes plus the stuff around them. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_HEADERS_STR_LEN</name></cpp:macro> <cpp:value>FSFS_MAX_PATH_LEN + sizeof(HEADER_CPATH ": \n") - 1</cpp:value></cpp:define>

<comment type="block">/* Given a revision file FILE that has been pre-positioned at the
   beginning of a Node-Rev header block, read in that header block and
   store it in the apr_hash_t HEADERS.  All allocations will be from
   POOL. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type> <name>read_header_block</name><parameter_list>(<param><decl><type><name>apr_hash_t</name> **</type><name>headers</name></decl></param>,
                                       <param><decl><type><name>apr_file_t</name> *</type><name>file</name></decl></param>,
                                       <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr>*<name>headers</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <while>while <condition>(<expr>1</expr>)</condition>
    <block>{
      <decl_stmt><decl><type><name>char</name></type> <name><name>header_str</name><index>[<expr><name>MAX_HEADERS_STR_LEN</name></expr>]</index></name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl>, *<decl><type ref="prev"/><name>value</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_size_t</name></type> <name>i</name> <init>= <expr>0</expr></init>, <name>header_len</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_size_t</name></type> <name>limit</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> *</type><name>local_name</name></decl>, *<decl><type ref="prev"/><name>local_value</name></decl>;</decl_stmt>

      <expr_stmt><expr><name>limit</name> = <sizeof>sizeof<argument_list>(<argument><expr><name>header_str</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_read_length_line</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>header_str</name></expr></argument>, <argument><expr>&amp;<name>limit</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>header_str</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
        <break>break;</break></then></if> <comment type="block">/* end of header block */</comment>

      <expr_stmt><expr><name>header_len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>header_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <while>while <condition>(<expr><name><name>header_str</name><index>[<expr><name>i</name></expr>]</index></name> != ':'</expr>)</condition>
        <block>{
          <if>if <condition>(<expr><name><name>header_str</name><index>[<expr><name>i</name></expr>]</index></name> == '\0'</expr>)</condition><then>
            <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                    <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Found malformed header in "
                                      "revision file"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
          <expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
        }</block></while>

      <comment type="block">/* Create a 'name' string and point to it. */</comment>
      <expr_stmt><expr><name><name>header_str</name><index>[<expr><name>i</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
      <expr_stmt><expr><name>name</name> = <name>header_str</name></expr>;</expr_stmt>

      <comment type="block">/* Skip over the NULL byte and the space following it. */</comment>
      <expr_stmt><expr><name>i</name> += 2</expr>;</expr_stmt>

      <if>if <condition>(<expr><name>i</name> &gt; <name>header_len</name></expr>)</condition><then>
        <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Found malformed header in "
                                  "revision file"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

      <expr_stmt><expr><name>value</name> = <name>header_str</name> + <name>i</name></expr>;</expr_stmt>

      <expr_stmt><expr><name>local_name</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>local_value</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr>*<name>headers</name></expr></argument>, <argument><expr><name>local_name</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>local_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></while>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Throw an error if the given revision is newer than the current
   youngest revision. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>ensure_revision_exists</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                       <param><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl></param>,
                       <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>fs_fs_data_t</name> *</type><name>ffd</name> <init>= <expr><name><name>fs</name>-&gt;<name>fsap_data</name></name></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr>! <call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name>rev</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_FS_NO_SUCH_REVISION</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Invalid revision number '%ld'"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rev</name></expr></argument>)</argument_list></call></expr>;</return></then></if>


  <comment type="block">/* Did the revision exist the last time we checked the current
     file? */</comment>
  <if>if <condition>(<expr><name>rev</name> &lt;= <name><name>ffd</name>-&gt;<name>youngest_rev_cache</name></name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_youngest</name><argument_list>(<argument><expr>&amp;(<name><name>ffd</name>-&gt;<name>youngest_rev_cache</name></name>)</expr></argument>, <argument><expr><name><name>fs</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check again. */</comment>
  <if>if <condition>(<expr><name>rev</name> &lt;= <name><name>ffd</name>-&gt;<name>youngest_rev_cache</name></name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_FS_NO_SUCH_REVISION</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                           <argument><expr><call><name>_</name><argument_list>(<argument><expr>"No such revision %ld"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rev</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Open the revision file for revision REV in filesystem FS and store
   the newly opened file in FILE.  Seek to location OFFSET before
   returning.  Perform temporary allocations in POOL. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>open_and_seek_revision</name><parameter_list>(<param><decl><type><name>apr_file_t</name> **</type><name>file</name></decl></param>,
                       <param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                       <param><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl></param>,
                       <param><decl><type><name>apr_off_t</name></type> <name>offset</name></decl></param>,
                       <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>rev_file</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>ensure_revision_exists</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_open</name><argument_list>(<argument><expr>&amp;<name>rev_file</name></expr></argument>, <argument><expr><call><name>svn_fs_fs__path_rev</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><name>APR_READ</name> | <name>APR_BUFFERED</name></expr></argument>, <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_seek</name><argument_list>(<argument><expr><name>rev_file</name></expr></argument>, <argument><expr><name>APR_SET</name></expr></argument>, <argument><expr>&amp;<name>offset</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>file</name> = <name>rev_file</name></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Open the representation for a node-revision in transaction TXN_ID
   in filesystem FS and store the newly opened file in FILE.  Seek to
   location OFFSET before returning.  Perform temporary allocations in
   POOL.  Only appropriate for file contents, nor props or directory
   contents. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>open_and_seek_transaction</name><parameter_list>(<param><decl><type><name>apr_file_t</name> **</type><name>file</name></decl></param>,
                          <param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>,
                          <param><decl><type><name>representation_t</name> *</type><name>rep</name></decl></param>,
                          <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>rev_file</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_off_t</name></type> <name>offset</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_open</name><argument_list>(<argument><expr>&amp;<name>rev_file</name></expr></argument>, <argument><expr><call><name>path_txn_proto_rev</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><name>APR_READ</name> | <name>APR_BUFFERED</name></expr></argument>, <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>offset</name> = <name><name>rep</name>-&gt;<name>offset</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_seek</name><argument_list>(<argument><expr><name>rev_file</name></expr></argument>, <argument><expr><name>APR_SET</name></expr></argument>, <argument><expr>&amp;<name>offset</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>file</name> = <name>rev_file</name></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Given a node-id ID, and a representation REP in filesystem FS, open
   the correct file and seek to the correction location.  Store this
   file in *FILE_P.  Perform any allocations in POOL. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>open_and_seek_representation</name><parameter_list>(<param><decl><type><name>apr_file_t</name> **</type><name>file_p</name></decl></param>,
                             <param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                             <param><decl><type><name>representation_t</name> *</type><name>rep</name></decl></param>,
                             <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>! <name><name>rep</name>-&gt;<name>txn_id</name></name></expr>)</condition><then>
    <return>return <expr><call><name>open_and_seek_revision</name><argument_list>(<argument><expr><name>file_p</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>rep</name>-&gt;<name>revision</name></name></expr></argument>, <argument><expr><name><name>rep</name>-&gt;<name>offset</name></name></expr></argument>,
                                  <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return></then>
  <else>else
    <return>return <expr><call><name>open_and_seek_transaction</name><argument_list>(<argument><expr><name>file_p</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>rep</name>-&gt;<name>txn_id</name></name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>

<comment type="block">/* Parse the description of a representation from STRING and store it
   into *REP_P.  If the representation is mutable (the revision is
   given as -1), then use TXN_ID for the representation's txn_id
   field.  If MUTABLE_REP_TRUNCATED is true, then this representation
   is for property or directory contents, and no information will be
   expected except the "-1" revision number for a mutable
   representation.  Allocate *REP_P in POOL. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>read_rep_offsets</name><parameter_list>(<param><decl><type><name>representation_t</name> **</type><name>rep_p</name></decl></param>,
                 <param><decl><type><name>char</name> *</type><name>string</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>,
                 <param><decl><type><name>svn_boolean_t</name></type> <name>mutable_rep_truncated</name></decl></param>,
                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>representation_t</name> *</type><name>rep</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>str</name></decl>, *<decl><type ref="prev"/><name>last_str</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>rep</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>rep</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>rep_p</name> = <name>rep</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>str</name> = <call><name>apr_strtok</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr>" "</expr></argument>, <argument><expr>&amp;<name>last_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>str</name> == <name>NULL</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                            <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Malformed text rep offset line in node-rev"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>


  <expr_stmt><expr><name><name>rep</name>-&gt;<name>revision</name></name> = <call><name>SVN_STR_TO_REV</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name><name>rep</name>-&gt;<name>revision</name></name> == <name>SVN_INVALID_REVNUM</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name><name>rep</name>-&gt;<name>txn_id</name></name> = <name>txn_id</name></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>mutable_rep_truncated</name></expr>)</condition><then>
        <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>
    }</block></then></if>

  <expr_stmt><expr><name>str</name> = <call><name>apr_strtok</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>" "</expr></argument>, <argument><expr>&amp;<name>last_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>str</name> == <name>NULL</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                            <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Malformed text rep offset line in node-rev"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><name><name>rep</name>-&gt;<name>offset</name></name> = <call><name>apr_atoi64</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>str</name> = <call><name>apr_strtok</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>" "</expr></argument>, <argument><expr>&amp;<name>last_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>str</name> == <name>NULL</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                            <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Malformed text rep offset line in node-rev"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><name><name>rep</name>-&gt;<name>size</name></name> = <call><name>apr_atoi64</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>str</name> = <call><name>apr_strtok</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>" "</expr></argument>, <argument><expr>&amp;<name>last_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>str</name> == <name>NULL</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                            <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Malformed text rep offset line in node-rev"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><name><name>rep</name>-&gt;<name>expanded_size</name></name> = <call><name>apr_atoi64</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Read in the MD5 hash. */</comment>
  <expr_stmt><expr><name>str</name> = <call><name>apr_strtok</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>" "</expr></argument>, <argument><expr>&amp;<name>last_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>(<name>str</name> == <name>NULL</name>) || (<call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> != (<name>APR_MD5_DIGESTSIZE</name> * 2))</expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                            <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Malformed text rep offset line in node-rev"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Parse the hex MD5 hash into digest form. */</comment>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>APR_MD5_DIGESTSIZE</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <if>if <condition>(<expr>(! <call><name>isxdigit</name><argument_list>(<argument><expr><name><name>str</name><index>[<expr><name>i</name> * 2</expr>]</index></name></expr></argument>)</argument_list></call>) || (! <call><name>isxdigit</name><argument_list>(<argument><expr><name><name>str</name><index>[<expr><name>i</name> * 2 + 1</expr>]</index></name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
        <return>return <expr><call><name>svn_error_create</name>
          <argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
           <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Malformed text rep offset line in node-rev"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

      <expr_stmt><expr><name><name>str</name><index>[<expr><name>i</name> * 2</expr>]</index></name> = <call><name>tolower</name><argument_list>(<argument><expr><name><name>str</name><index>[<expr><name>i</name> * 2</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>rep</name>-&gt;<name>checksum</name><index>[<expr><name>i</name></expr>]</index></name> = (<name><name>str</name><index>[<expr><name>i</name> * 2</expr>]</index></name> -
                          ((<name><name>str</name><index>[<expr><name>i</name> * 2</expr>]</index></name> &lt;= '9') ? '0' : ('a' - 10))) &lt;&lt; 4</expr>;</expr_stmt>

      <expr_stmt><expr><name><name>str</name><index>[<expr><name>i</name> * 2 + 1</expr>]</index></name> = <call><name>tolower</name><argument_list>(<argument><expr><name><name>str</name><index>[<expr><name>i</name> * 2 + 1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>rep</name>-&gt;<name>checksum</name><index>[<expr><name>i</name></expr>]</index></name> |= (<name><name>str</name><index>[<expr><name>i</name> * 2 + 1</expr>]</index></name> -
                           ((<name><name>str</name><index>[<expr><name>i</name> * 2 + 1</expr>]</index></name> &lt;= '9') ? '0' : ('a' - 10)))</expr>;</expr_stmt>
    }</block></for>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* See svn_fs_fs__get_node_revision, which wraps this and adds another
   error. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>get_node_revision_body</name><parameter_list>(<param><decl><type><name>node_revision_t</name> **</type><name>noderev_p</name></decl></param>,
                       <param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                       <param><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>id</name></decl></param>,
                       <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>revision_file</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>headers</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>node_revision_t</name> *</type><name>noderev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>value</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><call><name>svn_fs_fs__id_txn_id</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <comment type="block">/* This is a transaction node-rev. */</comment>
      <expr_stmt><expr><name>err</name> = <call><name>svn_io_file_open</name><argument_list>(<argument><expr>&amp;<name>revision_file</name></expr></argument>, <argument><expr><call><name>path_txn_node_rev</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><name>APR_READ</name> | <name>APR_BUFFERED</name></expr></argument>, <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <comment type="block">/* This is a revision node-rev. */</comment>
      <expr_stmt><expr><name>err</name> = <call><name>open_and_seek_revision</name><argument_list>(<argument><expr>&amp;<name>revision_file</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>,
                                   <argument><expr><call><name>svn_fs_fs__id_rev</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr><call><name>svn_fs_fs__id_offset</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

  <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr><call><name>APR_STATUS_IS_ENOENT</name><argument_list>(<argument><expr><name><name>err</name>-&gt;<name>apr_err</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><call><name>svn_fs_fs__err_dangling_id</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>

      <return>return <expr><name>err</name></expr>;</return>
    }</block></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>read_header_block</name><argument_list>(<argument><expr>&amp;<name>headers</name></expr></argument>, <argument><expr><name>revision_file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>noderev</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>noderev</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Read the node-rev id. */</comment>
  <expr_stmt><expr><name>value</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>headers</name></expr></argument>, <argument><expr><name>HEADER_ID</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>value</name> == <name>NULL</name></expr>)</condition><then>
      <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                              <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Missing id field in node-rev"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_close</name><argument_list>(<argument><expr><name>revision_file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>noderev</name>-&gt;<name>id</name></name> = <call><name>svn_fs_fs__id_parse</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Read the type. */</comment>
  <expr_stmt><expr><name>value</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>headers</name></expr></argument>, <argument><expr><name>HEADER_TYPE</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr>(<name>value</name> == <name>NULL</name>) ||
      (<call><name>strcmp</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>KIND_FILE</name></expr></argument>)</argument_list></call> != 0 &amp;&amp; <call><name>strcmp</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>KIND_DIR</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                            <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Missing kind field in node-rev"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><name><name>noderev</name>-&gt;<name>kind</name></name> = (<call><name>strcmp</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>KIND_FILE</name></expr></argument>)</argument_list></call> == 0) ? <name>svn_node_file</name>
    : <name>svn_node_dir</name></expr>;</expr_stmt>

  <comment type="block">/* Read the 'count' field. */</comment>
  <expr_stmt><expr><name>value</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>headers</name></expr></argument>, <argument><expr><name>HEADER_COUNT</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>noderev</name>-&gt;<name>predecessor_count</name></name> = (<name>value</name> == <name>NULL</name>) ? 0 : <call><name>atoi</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Get the properties location. */</comment>
  <expr_stmt><expr><name>value</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>headers</name></expr></argument>, <argument><expr><name>HEADER_PROPS</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>value</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>read_rep_offsets</name><argument_list>(<argument><expr>&amp;<name><name>noderev</name>-&gt;<name>prop_rep</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>,
                               <argument><expr><call><name>svn_fs_fs__id_txn_id</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* Get the data location. */</comment>
  <expr_stmt><expr><name>value</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>headers</name></expr></argument>, <argument><expr><name>HEADER_TEXT</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>value</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>read_rep_offsets</name><argument_list>(<argument><expr>&amp;<name><name>noderev</name>-&gt;<name>data_rep</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>,
                               <argument><expr><call><name>svn_fs_fs__id_txn_id</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></argument>,
                               <argument><expr>(<name><name>noderev</name>-&gt;<name>kind</name></name> == <name>svn_node_dir</name>)</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* Get the created path. */</comment>
  <expr_stmt><expr><name>value</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>headers</name></expr></argument>, <argument><expr><name>HEADER_CPATH</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>value</name> == <name>NULL</name></expr>)</condition><then>
    <block>{
      <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                              <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Missing cpath in node-rev"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then>
  <else>else
    <block>{
      <expr_stmt><expr><name><name>noderev</name>-&gt;<name>created_path</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

  <comment type="block">/* Get the predecessor ID. */</comment>
  <expr_stmt><expr><name>value</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>headers</name></expr></argument>, <argument><expr><name>HEADER_PRED</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>value</name></expr>)</condition><then>
    <expr_stmt><expr><name><name>noderev</name>-&gt;<name>predecessor_id</name></name> = <call><name>svn_fs_fs__id_parse</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>,
                                                  <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* Get the copyroot. */</comment>
  <expr_stmt><expr><name>value</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>headers</name></expr></argument>, <argument><expr><name>HEADER_COPYROOT</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>value</name> == <name>NULL</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name><name>noderev</name>-&gt;<name>copyroot_path</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>noderev</name>-&gt;<name>created_path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>noderev</name>-&gt;<name>copyroot_rev</name></name> = <call><name>svn_fs_fs__id_rev</name><argument_list>(<argument><expr><name><name>noderev</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <decl_stmt><decl><type><name>char</name> *</type><name>str</name></decl>, *<decl><type ref="prev"/><name>last_str</name></decl>;</decl_stmt>

      <expr_stmt><expr><name>str</name> = <call><name>apr_strtok</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr>" "</expr></argument>, <argument><expr>&amp;<name>last_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>str</name> == <name>NULL</name></expr>)</condition><then>
        <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Malformed copyroot line in node-rev"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

      <expr_stmt><expr><name><name>noderev</name>-&gt;<name>copyroot_rev</name></name> = <call><name>atoi</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr><name>last_str</name> == <name>NULL</name></expr>)</condition><then>
        <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Malformed copyroot line in node-rev"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
      <expr_stmt><expr><name><name>noderev</name>-&gt;<name>copyroot_path</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>last_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

  <comment type="block">/* Get the copyfrom. */</comment>
  <expr_stmt><expr><name>value</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>headers</name></expr></argument>, <argument><expr><name>HEADER_COPYFROM</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>value</name> == <name>NULL</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name><name>noderev</name>-&gt;<name>copyfrom_path</name></name> = <name>NULL</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>noderev</name>-&gt;<name>copyfrom_rev</name></name> = <name>SVN_INVALID_REVNUM</name></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <decl_stmt><decl><type><name>char</name> *</type><name>str</name></decl>, *<decl><type ref="prev"/><name>last_str</name></decl>;</decl_stmt>

      <expr_stmt><expr><name>str</name> = <call><name>apr_strtok</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr>" "</expr></argument>, <argument><expr>&amp;<name>last_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>str</name> == <name>NULL</name></expr>)</condition><then>
        <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Malformed copyfrom line in node-rev"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

      <expr_stmt><expr><name><name>noderev</name>-&gt;<name>copyfrom_rev</name></name> = <call><name>atoi</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr><name>last_str</name> == <name>NULL</name></expr>)</condition><then>
        <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Malformed copyfrom line in node-rev"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
      <expr_stmt><expr><name><name>noderev</name>-&gt;<name>copyfrom_path</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>last_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

  <comment type="block">/* Get whether this is a fresh txn root. */</comment>
  <expr_stmt><expr><name>value</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>headers</name></expr></argument>, <argument><expr><name>HEADER_FRESHTXNRT</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>noderev</name>-&gt;<name>is_fresh_txn_root</name></name> = (<name>value</name> != <name>NULL</name>)</expr>;</expr_stmt>

  <comment type="block">/* Get the mergeinfo count. */</comment>
  <expr_stmt><expr><name>value</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>headers</name></expr></argument>, <argument><expr><name>HEADER_MINFO_CNT</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>noderev</name>-&gt;<name>mergeinfo_count</name></name> = (<name>value</name> == <name>NULL</name>) ? 0 : <call><name>apr_atoi64</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Get whether *this* node has mergeinfo. */</comment>
  <expr_stmt><expr><name>value</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>headers</name></expr></argument>, <argument><expr><name>HEADER_MINFO_HERE</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>noderev</name>-&gt;<name>has_mergeinfo</name></name> = (<name>value</name> != <name>NULL</name>)</expr>;</expr_stmt>

  <expr_stmt><expr>*<name>noderev_p</name> = <name>noderev</name></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__get_node_revision</name><parameter_list>(<param><decl><type><name>node_revision_t</name> **</type><name>noderev_p</name></decl></param>,
                             <param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                             <param><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>id</name></decl></param>,
                             <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name> <init>= <expr><call><name>get_node_revision_body</name><argument_list>(<argument><expr><name>noderev_p</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>err</name> &amp;&amp; <name><name>err</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_FS_CORRUPT</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>id_string</name> <init>= <expr><call><name>svn_fs_fs__id_unparse</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>err</name></expr></argument>,
                               <argument><expr>"Corrupt node-revision '%s'"</expr></argument>,
                               <argument><expr><name><name>id_string</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>
  <return>return <expr><name>err</name></expr>;</return>
}</block></function>


<comment type="block">/* Return a formatted string that represents the location of
   representation REP.  If MUTABLE_REP_TRUNCATED is given, the rep is
   for props or dir contents, and only a "-1" revision number will be
   given for a mutable rep.  Perform the allocation from POOL.  */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type>
<name>representation_string</name><parameter_list>(<param><decl><type><name>representation_t</name> *</type><name>rep</name></decl></param>,
                      <param><decl><type><name>svn_boolean_t</name></type> <name>mutable_rep_truncated</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name><name>rep</name>-&gt;<name>txn_id</name></name> &amp;&amp; <name>mutable_rep_truncated</name></expr>)</condition><then>
    <return>return <expr>"-1"</expr>;</return></then>
  <else>else
    <return>return <expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%ld %" <name>APR_OFF_T_FMT</name> " %" <name>SVN_FILESIZE_T_FMT</name>
                        " %" <name>SVN_FILESIZE_T_FMT</name> " %s"</expr></argument>,
                        <argument><expr><name><name>rep</name>-&gt;<name>revision</name></name></expr></argument>, <argument><expr><name><name>rep</name>-&gt;<name>offset</name></name></expr></argument>, <argument><expr><name><name>rep</name>-&gt;<name>size</name></name></expr></argument>,
                        <argument><expr><name><name>rep</name>-&gt;<name>expanded_size</name></name></expr></argument>,
                        <argument><expr><call><name>svn_md5_digest_to_cstring_display</name><argument_list>(<argument><expr><name><name>rep</name>-&gt;<name>checksum</name></name></expr></argument>,
                                                          <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>

<comment type="block">/* Write the node-revision NODEREV into the file FILE.  Only write
   mergeinfo-related metadata if INCLUDE_MERGEINFO is true.  Temporary
   allocations are from POOL. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>write_noderev_txn</name><parameter_list>(<param><decl><type><name>apr_file_t</name> *</type><name>file</name></decl></param>,
                  <param><decl><type><name>node_revision_t</name> *</type><name>noderev</name></decl></param>,
                  <param><decl><type><name>svn_boolean_t</name></type> <name>include_mergeinfo</name></decl></param>,
                  <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>outfile</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>outfile</name> = <call><name>svn_stream_from_aprfile</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_printf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>HEADER_ID</name> ": %s\n"</expr></argument>,
                            <argument><expr><call><name>svn_fs_fs__id_unparse</name><argument_list>(<argument><expr><name><name>noderev</name>-&gt;<name>id</name></name></expr></argument>,
                                                  <argument><expr><name>pool</name></expr></argument>)</argument_list></call>-&gt;<name>data</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_printf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>HEADER_TYPE</name> ": %s\n"</expr></argument>,
                            <argument><expr>(<name><name>noderev</name>-&gt;<name>kind</name></name> == <name>svn_node_file</name>) ?
                            <name>KIND_FILE</name> : <name>KIND_DIR</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name><name>noderev</name>-&gt;<name>predecessor_id</name></name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_printf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>HEADER_PRED</name> ": %s\n"</expr></argument>,
                              <argument><expr><call><name>svn_fs_fs__id_unparse</name><argument_list>(<argument><expr><name><name>noderev</name>-&gt;<name>predecessor_id</name></name></expr></argument>,
                                                    <argument><expr><name>pool</name></expr></argument>)</argument_list></call>-&gt;<name>data</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_printf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>HEADER_COUNT</name> ": %d\n"</expr></argument>,
                            <argument><expr><name><name>noderev</name>-&gt;<name>predecessor_count</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name><name>noderev</name>-&gt;<name>data_rep</name></name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_printf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>HEADER_TEXT</name> ": %s\n"</expr></argument>,
                              <argument><expr><call><name>representation_string</name><argument_list>(<argument><expr><name><name>noderev</name>-&gt;<name>data_rep</name></name></expr></argument>,
                                                    <argument><expr>(<name><name>noderev</name>-&gt;<name>kind</name></name>
                                                     == <name>svn_node_dir</name>)</expr></argument>,
                                                    <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <if>if <condition>(<expr><name><name>noderev</name>-&gt;<name>prop_rep</name></name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_printf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>HEADER_PROPS</name> ": %s\n"</expr></argument>,
                              <argument><expr><call><name>representation_string</name><argument_list>(<argument><expr><name><name>noderev</name>-&gt;<name>prop_rep</name></name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>,
                                                    <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_printf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>HEADER_CPATH</name> ": %s\n"</expr></argument>,
                            <argument><expr><name><name>noderev</name>-&gt;<name>created_path</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name><name>noderev</name>-&gt;<name>copyfrom_path</name></name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_printf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>HEADER_COPYFROM</name> ": %ld"
                              " %s\n"</expr></argument>,
                              <argument><expr><name><name>noderev</name>-&gt;<name>copyfrom_rev</name></name></expr></argument>,
                              <argument><expr><name><name>noderev</name>-&gt;<name>copyfrom_path</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <if>if <condition>(<expr>(<name><name>noderev</name>-&gt;<name>copyroot_rev</name></name> != <call><name>svn_fs_fs__id_rev</name><argument_list>(<argument><expr><name><name>noderev</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call>) ||
      (<call><name>strcmp</name><argument_list>(<argument><expr><name><name>noderev</name>-&gt;<name>copyroot_path</name></name></expr></argument>, <argument><expr><name><name>noderev</name>-&gt;<name>created_path</name></name></expr></argument>)</argument_list></call> != 0)</expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_printf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>HEADER_COPYROOT</name> ": %ld"
                              " %s\n"</expr></argument>,
                              <argument><expr><name><name>noderev</name>-&gt;<name>copyroot_rev</name></name></expr></argument>,
                              <argument><expr><name><name>noderev</name>-&gt;<name>copyroot_path</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <if>if <condition>(<expr><name><name>noderev</name>-&gt;<name>is_fresh_txn_root</name></name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_printf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>HEADER_FRESHTXNRT</name> ": y\n"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <if>if <condition>(<expr><name>include_mergeinfo</name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr><name><name>noderev</name>-&gt;<name>mergeinfo_count</name></name> &gt; 0</expr>)</condition><then>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_printf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>HEADER_MINFO_CNT</name> ": %"
                                  <name>APR_INT64_T_FMT</name> "\n"</expr></argument>,
                                  <argument><expr><name><name>noderev</name>-&gt;<name>mergeinfo_count</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

      <if>if <condition>(<expr><name><name>noderev</name>-&gt;<name>has_mergeinfo</name></name></expr>)</condition><then>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_printf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>HEADER_MINFO_HERE</name> ": y\n"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_printf</name><argument_list>(<argument><expr><name>outfile</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"\n"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__put_node_revision</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                             <param><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>id</name></decl></param>,
                             <param><decl><type><name>node_revision_t</name> *</type><name>noderev</name></decl></param>,
                             <param><decl><type><name>svn_boolean_t</name></type> <name>fresh_txn_root</name></decl></param>,
                             <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>noderev_file</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name> <init>= <expr><call><name>svn_fs_fs__id_txn_id</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>noderev</name>-&gt;<name>is_fresh_txn_root</name></name> = <name>fresh_txn_root</name></expr>;</expr_stmt>

  <if>if <condition>(<expr>! <name>txn_id</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                            <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Attempted to write to non-transaction"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_open</name><argument_list>(<argument><expr>&amp;<name>noderev_file</name></expr></argument>, <argument><expr><call><name>path_txn_node_rev</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><name>APR_WRITE</name> | <name>APR_CREATE</name> | <name>APR_TRUNCATE</name>
                           | <name>APR_BUFFERED</name></expr></argument>, <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>write_noderev_txn</name><argument_list>(<argument><expr><name>noderev_file</name></expr></argument>, <argument><expr><name>noderev</name></expr></argument>,
                            <argument><expr><call><name>svn_fs_fs__fs_supports_mergeinfo</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_close</name><argument_list>(<argument><expr><name>noderev_file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* This structure is used to hold the information associated with a
   REP line. */</comment>
<struct>struct <name>rep_args</name>
<block>{
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>is_delta</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>is_delta_vs_empty</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>base_revision</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_off_t</name></type> <name>base_offset</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>base_length</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/* Read the next line from file FILE and parse it as a text
   representation entry.  Return the parsed entry in *REP_ARGS_P.
   Perform all allocations in POOL. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>read_rep_line</name><parameter_list>(<param><decl><type>struct <name>rep_args</name> **</type><name>rep_args_p</name></decl></param>,
              <param><decl><type><name>apr_file_t</name> *</type><name>file</name></decl></param>,
              <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr>160</expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>limit</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>rep_args</name> *</type><name>rep_args</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>str</name></decl>, *<decl><type ref="prev"/><name>last_str</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>limit</name> = <sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_read_length_line</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr>&amp;<name>limit</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>rep_args</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>rep_args</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>rep_args</name>-&gt;<name>is_delta</name></name> = <name>FALSE</name></expr>;</expr_stmt>

  <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>REP_PLAIN</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
    <block>{
      <expr_stmt><expr>*<name>rep_args_p</name> = <name>rep_args</name></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>

  <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>REP_DELTA</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
    <block>{
      <comment type="block">/* This is a delta against the empty stream. */</comment>
      <expr_stmt><expr><name><name>rep_args</name>-&gt;<name>is_delta</name></name> = <name>TRUE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>rep_args</name>-&gt;<name>is_delta_vs_empty</name></name> = <name>TRUE</name></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>rep_args_p</name> = <name>rep_args</name></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>

  <expr_stmt><expr><name><name>rep_args</name>-&gt;<name>is_delta</name></name> = <name>TRUE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>rep_args</name>-&gt;<name>is_delta_vs_empty</name></name> = <name>FALSE</name></expr>;</expr_stmt>

  <comment type="block">/* We have hopefully a DELTA vs. a non-empty base revision. */</comment>
  <expr_stmt><expr><name>str</name> = <call><name>apr_strtok</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr>" "</expr></argument>, <argument><expr>&amp;<name>last_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>! <name>str</name> || (<call><name>strcmp</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>REP_DELTA</name></expr></argument>)</argument_list></call> != 0)</expr>)</condition><then> <goto>goto <name>err</name>;</goto></then></if>

  <expr_stmt><expr><name>str</name> = <call><name>apr_strtok</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>" "</expr></argument>, <argument><expr>&amp;<name>last_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>! <name>str</name></expr>)</condition><then> <goto>goto <name>err</name>;</goto></then></if>
  <expr_stmt><expr><name><name>rep_args</name>-&gt;<name>base_revision</name></name> = <call><name>atol</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>str</name> = <call><name>apr_strtok</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>" "</expr></argument>, <argument><expr>&amp;<name>last_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>! <name>str</name></expr>)</condition><then> <goto>goto <name>err</name>;</goto></then></if>
  <expr_stmt><expr><name><name>rep_args</name>-&gt;<name>base_offset</name></name> = (<name>apr_off_t</name>) <call><name>apr_atoi64</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>str</name> = <call><name>apr_strtok</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>" "</expr></argument>, <argument><expr>&amp;<name>last_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>! <name>str</name></expr>)</condition><then> <goto>goto <name>err</name>;</goto></then></if>
  <expr_stmt><expr><name><name>rep_args</name>-&gt;<name>base_length</name></name> = (<name>apr_size_t</name>) <call><name>apr_atoi64</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>rep_args_p</name> = <name>rep_args</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>

 <label><name>err</name>:</label>
  <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                          <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Malformed representation header"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Given a revision file REV_FILE, find the Node-ID of the header
   located at OFFSET and store it in *ID_P.  Allocate temporary
   variables from POOL. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>get_fs_id_at_offset</name><parameter_list>(<param><decl><type><name>svn_fs_id_t</name> **</type><name>id_p</name></decl></param>,
                    <param><decl><type><name>apr_file_t</name> *</type><name>rev_file</name></decl></param>,
                    <param><decl><type><name>apr_off_t</name></type> <name>offset</name></decl></param>,
                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_fs_id_t</name> *</type><name>id</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>headers</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>node_id_str</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_seek</name><argument_list>(<argument><expr><name>rev_file</name></expr></argument>, <argument><expr><name>APR_SET</name></expr></argument>, <argument><expr>&amp;<name>offset</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>read_header_block</name><argument_list>(<argument><expr>&amp;<name>headers</name></expr></argument>, <argument><expr><name>rev_file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>node_id_str</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>headers</name></expr></argument>, <argument><expr><name>HEADER_ID</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>node_id_str</name> == <name>NULL</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                            <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Missing node-id in node-rev"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><name>id</name> = <call><name>svn_fs_fs__id_parse</name><argument_list>(<argument><expr><name>node_id_str</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>node_id_str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>id</name> == <name>NULL</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                            <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Corrupt node-id in node-rev"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr>*<name>id_p</name> = <name>id</name></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Given an open revision file REV_FILE, locate the trailer that
   specifies the offset to the root node-id and to the changed path
   information.  Store the root node offset in *ROOT_OFFSET and the
   changed path offset in *CHANGES_OFFSET.  If either of these
   pointers is NULL, do nothing with it. Allocate temporary variables
   from POOL. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>get_root_changes_offset</name><parameter_list>(<param><decl><type><name>apr_off_t</name> *</type><name>root_offset</name></decl></param>,
                        <param><decl><type><name>apr_off_t</name> *</type><name>changes_offset</name></decl></param>,
                        <param><decl><type><name>apr_file_t</name> *</type><name>rev_file</name></decl></param>,
                        <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_off_t</name></type> <name>offset</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>64</expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>num_bytes</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name></decl>;</decl_stmt>

  <comment type="block">/* We will assume that the last line containing the two offsets
     will never be longer than 64 characters. */</comment>
  <expr_stmt><expr><name>offset</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_seek</name><argument_list>(<argument><expr><name>rev_file</name></expr></argument>, <argument><expr><name>APR_END</name></expr></argument>, <argument><expr>&amp;<name>offset</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>offset</name> -= <sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_seek</name><argument_list>(<argument><expr><name>rev_file</name></expr></argument>, <argument><expr><name>APR_SET</name></expr></argument>, <argument><expr>&amp;<name>offset</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Read in this last block, from which we will identify the last line. */</comment>
  <expr_stmt><expr><name>len</name> = <sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_read</name><argument_list>(<argument><expr><name>rev_file</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* This cast should be safe since the maximum amount read, 64, will
     never be bigger than the size of an int. */</comment>
  <expr_stmt><expr><name>num_bytes</name> = (<name>int</name>) <name>len</name></expr>;</expr_stmt>

  <comment type="block">/* The last byte should be a newline. */</comment>
  <if>if <condition>(<expr><name><name>buf</name><index>[<expr><name>num_bytes</name> - 1</expr>]</index></name> != '\n'</expr>)</condition><then>
    <block>{
      <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                               <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Revision file lacks trailing newline"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

  <comment type="block">/* Look for the next previous newline. */</comment>
  <for>for (<init><expr><name>i</name> = <name>num_bytes</name> - 2</expr>;</init> <condition><expr><name>i</name> &gt;= 0</expr>;</condition> <incr><expr><name>i</name>--</expr></incr>)
    <block>{
      <if>if <condition>(<expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name> == '\n'</expr>)</condition><then> <break>break;</break></then></if>
    }</block></for>

  <if>if <condition>(<expr><name>i</name> &lt; 0</expr>)</condition><then>
    <block>{
      <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                               <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Final line in revision file longer than 64 "
                                 "characters"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

  <expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>

  <if>if <condition>(<expr><name>root_offset</name></expr>)</condition><then>
    <expr_stmt><expr>*<name>root_offset</name> = <call><name>apr_atoi64</name><argument_list>(<argument><expr>&amp;<name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* find the next space */</comment>
  <for>for ( <init>;</init> <condition><expr><name>i</name> &lt; (<name>num_bytes</name> - 2)</expr> ;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <if>if <condition>(<expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name> == ' '</expr>)</condition><then> <break>break;</break></then></if></for>

  <if>if <condition>(<expr><name>i</name> == (<name>num_bytes</name> - 2)</expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                            <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Final line in revision file missing space"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>

  <comment type="block">/* note that apr_atoi64() will stop reading as soon as it encounters
     the final newline. */</comment>
  <if>if <condition>(<expr><name>changes_offset</name></expr>)</condition><then>
    <expr_stmt><expr>*<name>changes_offset</name> = <call><name>apr_atoi64</name><argument_list>(<argument><expr>&amp;<name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__rev_get_root</name><parameter_list>(<param><decl><type><name>svn_fs_id_t</name> **</type><name>root_id_p</name></decl></param>,
                        <param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                        <param><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl></param>,
                        <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>fs_fs_data_t</name> *</type><name>ffd</name> <init>= <expr><name><name>fs</name>-&gt;<name>fsap_data</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>revision_file</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_off_t</name></type> <name>root_offset</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_id_t</name> *</type><name>root_id</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>rev_str</name> <init>= <expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%ld"</expr></argument>, <argument><expr><name>rev</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_id_t</name> *</type><name>cached_id</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>ensure_revision_exists</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Calculate an index into the revroot id cache */</comment>
  <expr_stmt><expr><name>cached_id</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name><name>ffd</name>-&gt;<name>rev_root_id_cache</name></name></expr></argument>,
                           <argument><expr><name>rev_str</name></expr></argument>,
                           <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>cached_id</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr>*<name>root_id_p</name> = <call><name>svn_fs_fs__id_copy</name><argument_list>(<argument><expr><name>cached_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>

  <expr_stmt><expr><name>err</name> = <call><name>svn_io_file_open</name><argument_list>(<argument><expr>&amp;<name>revision_file</name></expr></argument>, <argument><expr><call><name>svn_fs_fs__path_rev</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                         <argument><expr><name>APR_READ</name> | <name>APR_BUFFERED</name></expr></argument>, <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>err</name> &amp;&amp; <call><name>APR_STATUS_IS_ENOENT</name><argument_list>(<argument><expr><name><name>err</name>-&gt;<name>apr_err</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_FS_NO_SUCH_REVISION</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                               <argument><expr><call><name>_</name><argument_list>(<argument><expr>"No such revision %ld"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rev</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then>
  <else>else <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
    <return>return <expr><name>err</name></expr>;</return></then></if></else></if>


  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_root_changes_offset</name><argument_list>(<argument><expr>&amp;<name>root_offset</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>revision_file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_fs_id_at_offset</name><argument_list>(<argument><expr>&amp;<name>root_id</name></expr></argument>, <argument><expr><name>revision_file</name></expr></argument>, <argument><expr><name>root_offset</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_close</name><argument_list>(<argument><expr><name>revision_file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Make sure our cache size doesn't grow without bounds. */</comment>
  <if>if <condition>(<expr><call><name>apr_hash_count</name><argument_list>(<argument><expr><name><name>ffd</name>-&gt;<name>rev_root_id_cache</name></name></expr></argument>)</argument_list></call> &gt;= <name>NUM_RRI_CACHE_ENTRIES</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* In order to only use one pool for the whole cache, we need to
       * completely wipe it to expire entries! */</comment>
      <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name><name>ffd</name>-&gt;<name>rev_root_id_cache_pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>ffd</name>-&gt;<name>rev_root_id_cache</name></name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name><name>ffd</name>-&gt;<name>rev_root_id_cache_pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* Cache the answer, copying both the key and value into the cache's
     pool. */</comment>
  <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name><name>ffd</name>-&gt;<name>rev_root_id_cache</name></name></expr></argument>,
               <argument><expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>ffd</name>-&gt;<name>rev_root_id_cache_pool</name></name></expr></argument>, <argument><expr><name>rev_str</name></expr></argument>)</argument_list></call></expr></argument>,
               <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>,
               <argument><expr><call><name>svn_fs_fs__id_copy</name><argument_list>(<argument><expr><name>root_id</name></expr></argument>, <argument><expr><name><name>ffd</name>-&gt;<name>rev_root_id_cache_pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>root_id_p</name> = <name>root_id</name></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__set_revision_proplist</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                                 <param><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl></param>,
                                 <param><decl><type><name>apr_hash_t</name> *</type><name>proplist</name></decl></param>,
                                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>final_path</name> <init>= <expr><call><name>path_revprops</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>tmp_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>f</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>ensure_revision_exists</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_open_unique_file2</name>
          <argument_list>(<argument><expr>&amp;<name>f</name></expr></argument>, <argument><expr>&amp;<name>tmp_path</name></expr></argument>, <argument><expr><name>final_path</name></expr></argument>, <argument><expr>".tmp"</expr></argument>, <argument><expr><name>svn_io_file_del_none</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_hash_write</name><argument_list>(<argument><expr><name>proplist</name></expr></argument>, <argument><expr><name>f</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_close</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* We use the rev file of this revision as the perms reference,
     because when setting revprops for the first time, the revprop
     file won't exist and therefore can't serve as its own reference.
     (Whereas the rev file should already exist at this point.) */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__move_into_place</name><argument_list>(<argument><expr><name>tmp_path</name></expr></argument>, <argument><expr><name>final_path</name></expr></argument>,
                                     <argument><expr><call><name>svn_fs_fs__path_rev</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                                     <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__revision_proplist</name><parameter_list>(<param><decl><type><name>apr_hash_t</name> **</type><name>proplist_p</name></decl></param>,
                             <param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                             <param><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl></param>,
                             <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>revprop_file</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>proplist</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name> <init>= <expr><name>SVN_NO_ERROR</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>iterpool</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>ensure_revision_exists</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>proplist</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>iterpool</name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>SVN_ESTALE_RETRY_COUNT</name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Clear err here (svn_error_clear can safely be passed
       * SVN_NO_ERROR) rather than after finding ESTALE so we can
       * return the ESTALE error on the last iteration of the loop. */</comment>
      <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>err</name> = <call><name>svn_io_file_open</name><argument_list>(<argument><expr>&amp;<name>revprop_file</name></expr></argument>, <argument><expr><call><name>path_revprops</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><name>APR_READ</name> | <name>APR_BUFFERED</name></expr></argument>, <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>,
                             <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
        <block>{
          <if>if <condition>(<expr><call><name>APR_STATUS_IS_ENOENT</name><argument_list>(<argument><expr><name><name>err</name>-&gt;<name>apr_err</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <block>{
              <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_FS_NO_SUCH_REVISION</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"No such revision %ld"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>rev</name></expr></argument>)</argument_list></call></expr>;</return>
            }</block></then>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ESTALE</name></cpp:ifdef>
          <else>else <if>if <condition>(<expr><call><name>APR_TO_OS_ERROR</name><argument_list>(<argument><expr><name><name>err</name>-&gt;<name>apr_err</name></name></expr></argument>)</argument_list></call> == <name>ESTALE</name></expr>)</condition><then>
            <continue>continue;</continue></then></if></else></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
          <return>return <expr><name>err</name></expr>;</return>
        }</block></then></if>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_hash__clear</name><argument_list>(<argument><expr><name>proplist</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_RETRY_ESTALE</name><argument_list>(<argument><expr><name>err</name></expr></argument>,
                       <argument><expr><call><name>svn_hash_read2</name><argument_list>(<argument><expr><name>proplist</name></expr></argument>,
                                      <argument><expr><call><name>svn_stream_from_aprfile</name><argument_list>(<argument><expr><name>revprop_file</name></expr></argument>,
                                                              <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>,
                                      <argument><expr><name>SVN_HASH_TERMINATOR</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>SVN_IGNORE_ESTALE</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><call><name>svn_io_file_close</name><argument_list>(<argument><expr><name>revprop_file</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <break>break;</break>
    }</block></for>
  <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
    <return>return <expr><name>err</name></expr>;</return></then></if>
  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>proplist_p</name> = <name>proplist</name></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Represents where in the current svndiff data block each
   representation is. */</comment>
<struct>struct <name>rep_state</name>
<block>{
  <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>file</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_off_t</name></type> <name>start</name></decl>;</decl_stmt>  <comment type="block">/* The starting offset for the raw
                       svndiff/plaintext data minus header. */</comment>
  <decl_stmt><decl><type><name>apr_off_t</name></type> <name>off</name></decl>;</decl_stmt>    <comment type="block">/* The current offset into the file. */</comment>
  <decl_stmt><decl><type><name>apr_off_t</name></type> <name>end</name></decl>;</decl_stmt>    <comment type="block">/* The end offset of the raw data. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>ver</name></decl>;</decl_stmt>          <comment type="block">/* If a delta, what svndiff version? */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>chunk_index</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/* See create_rep_state, which wraps this and adds another error. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>create_rep_state_body</name><parameter_list>(<param><decl><type>struct <name>rep_state</name> **</type><name>rep_state</name></decl></param>,
                      <param><decl><type>struct <name>rep_args</name> **</type><name>rep_args</name></decl></param>,
                      <param><decl><type><name>representation_t</name> *</type><name>rep</name></decl></param>,
                      <param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                      <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>rep_state</name> *</type><name>rs</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>rs</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>rep_args</name> *</type><name>ra</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>buf</name><index>[<expr>4</expr>]</index></name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>open_and_seek_representation</name><argument_list>(<argument><expr>&amp;<name><name>rs</name>-&gt;<name>file</name></name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>read_rep_line</name><argument_list>(<argument><expr>&amp;<name>ra</name></expr></argument>, <argument><expr><name><name>rs</name>-&gt;<name>file</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_file_offset</name><argument_list>(<argument><expr>&amp;<name><name>rs</name>-&gt;<name>start</name></name></expr></argument>, <argument><expr><name><name>rs</name>-&gt;<name>file</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>rs</name>-&gt;<name>off</name></name> = <name><name>rs</name>-&gt;<name>start</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>rs</name>-&gt;<name>end</name></name> = <name><name>rs</name>-&gt;<name>start</name></name> + <name><name>rep</name>-&gt;<name>size</name></name></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>rep_state</name> = <name>rs</name></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>rep_args</name> = <name>ra</name></expr>;</expr_stmt>

  <if>if <condition>(<expr><name><name>ra</name>-&gt;<name>is_delta</name></name> == <name>FALSE</name></expr>)</condition><then>
    <comment type="block">/* This is a plaintext, so just return the current rep_state. */</comment>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <comment type="block">/* We are dealing with a delta, find out what version. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_read_full</name><argument_list>(<argument><expr><name><name>rs</name>-&gt;<name>file</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>! ((<name><name>buf</name><index>[<expr>0</expr>]</index></name> == 'S') &amp;&amp; (<name><name>buf</name><index>[<expr>1</expr>]</index></name> == 'V') &amp;&amp; (<name><name>buf</name><index>[<expr>2</expr>]</index></name> == 'N'))</expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name>
      <argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Malformed svndiff data in representation"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
  <expr_stmt><expr><name><name>rs</name>-&gt;<name>ver</name></name> = <name><name>buf</name><index>[<expr>3</expr>]</index></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>rs</name>-&gt;<name>chunk_index</name></name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>rs</name>-&gt;<name>off</name></name> += 4</expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Read the rep args for REP in filesystem FS and create a rep_state
   for reading the representation.  Return the rep_state in *REP_STATE
   and the rep args in *REP_ARGS, both allocated in POOL. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>create_rep_state</name><parameter_list>(<param><decl><type>struct <name>rep_state</name> **</type><name>rep_state</name></decl></param>,
                 <param><decl><type>struct <name>rep_args</name> **</type><name>rep_args</name></decl></param>,
                 <param><decl><type><name>representation_t</name> *</type><name>rep</name></decl></param>,
                 <param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name> <init>= <expr><call><name>create_rep_state_body</name><argument_list>(<argument><expr><name>rep_state</name></expr></argument>, <argument><expr><name>rep_args</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>err</name> &amp;&amp; <name><name>err</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_FS_CORRUPT</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* ### This always returns "-1" for transaction reps, because
         ### this particular bit of code doesn't know if the rep is
         ### stored in the protorev or in the mutable area (for props
         ### or dir contents).  It is pretty rare for FSFS to *read*
         ### from the protorev file, though, so this is probably OK.
         ### And anyone going to debug corruption errors is probably
         ### going to jump straight to this comment anyway! */</comment>
      <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>err</name></expr></argument>,
                               <argument><expr>"Corrupt representation '%s'"</expr></argument>,
                               <argument><expr><call><name>representation_string</name><argument_list>(<argument><expr><name>rep</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>
  <return>return <expr><name>err</name></expr>;</return>
}</block></function>

<comment type="block">/* Build an array of rep_state structures in *LIST giving the delta
   reps from first_rep to a plain-text or self-compressed rep.  Set
   *SRC_STATE to the plain-text rep we find at the end of the chain,
   or to NULL if the final delta representation is self-compressed.
   The representation to start from is designated by filesystem FS, id
   ID, and representation REP. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>build_rep_list</name><parameter_list>(<param><decl><type><name>apr_array_header_t</name> **</type><name>list</name></decl></param>,
               <param><decl><type>struct <name>rep_state</name> **</type><name>src_state</name></decl></param>,
               <param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
               <param><decl><type><name>representation_t</name> *</type><name>first_rep</name></decl></param>,
               <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>representation_t</name></type> <name>rep</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>rep_state</name> *</type><name>rs</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>rep_args</name> *</type><name>rep_args</name></decl>;</decl_stmt>

  <expr_stmt><expr>*<name>list</name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument>struct <expr><name>rep_state</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rep</name> = *<name>first_rep</name></expr>;</expr_stmt>

  <while>while <condition>(<expr>1</expr>)</condition>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>create_rep_state</name><argument_list>(<argument><expr>&amp;<name>rs</name></expr></argument>, <argument><expr>&amp;<name>rep_args</name></expr></argument>, <argument><expr>&amp;<name>rep</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name><name>rep_args</name>-&gt;<name>is_delta</name></name> == <name>FALSE</name></expr>)</condition><then>
        <block>{
          <comment type="block">/* This is a plaintext, so just return the current rep_state. */</comment>
          <expr_stmt><expr>*<name>src_state</name> = <name>rs</name></expr>;</expr_stmt>
          <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
        }</block></then></if>

      <comment type="block">/* Push this rep onto the list.  If it's self-compressed, we're done. */</comment>
      <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr>*<name>list</name></expr></argument>, <argument>struct <expr><name>rep_state</name> *</expr></argument>)</argument_list></call> = <name>rs</name></expr>;</expr_stmt>
      <if>if <condition>(<expr><name><name>rep_args</name>-&gt;<name>is_delta_vs_empty</name></name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr>*<name>src_state</name> = <name>NULL</name></expr>;</expr_stmt>
          <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
        }</block></then></if>

      <expr_stmt><expr><name><name>rep</name>.<name>revision</name></name> = <name><name>rep_args</name>-&gt;<name>base_revision</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>rep</name>.<name>offset</name></name> = <name><name>rep_args</name>-&gt;<name>base_offset</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>rep</name>.<name>size</name></name> = <name><name>rep_args</name>-&gt;<name>base_length</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>rep</name>.<name>txn_id</name></name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></while>
}</block></function>


<struct>struct <name>rep_read_baton</name>
<block>{
  <comment type="block">/* The FS from which we're reading. */</comment>
  <decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl>;</decl_stmt>

  <comment type="block">/* The state of all prior delta representations. */</comment>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>rs_list</name></decl>;</decl_stmt>

  <comment type="block">/* The plaintext state, if there is a plaintext. */</comment>
  <decl_stmt><decl><type>struct <name>rep_state</name> *</type><name>src_state</name></decl>;</decl_stmt>

  <comment type="block">/* The index of the current delta chunk, if we are reading a delta. */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>chunk_index</name></decl>;</decl_stmt>

  <comment type="block">/* The buffer where we store undeltified data. */</comment>
  <decl_stmt><decl><type><name>char</name> *</type><name>buf</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>buf_pos</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>buf_len</name></decl>;</decl_stmt>

  <comment type="block">/* An MD5 context for summing the data read in order to verify it. */</comment>
  <decl_stmt><decl><type>struct <name>apr_md5_ctx_t</name></type> <name>md5_context</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>checksum_finalized</name></decl>;</decl_stmt>

  <comment type="block">/* The stored checksum of the representation we are reading, its
     length, and the amount we've read so far.  Some of this
     information is redundant with rs_list and src_state, but it's
     convenient for the checksumming code to have it here. */</comment>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>checksum</name><index>[<expr><name>APR_MD5_DIGESTSIZE</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_filesize_t</name></type> <name>len</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_filesize_t</name></type> <name>off</name></decl>;</decl_stmt>

  <comment type="block">/* Used for temporary allocations during the read. */</comment>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>

  <comment type="block">/* Pool used to store file handles and other data that is persistant
     for the entire stream read. */</comment>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>filehandle_pool</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/* Create a rep_read_baton structure for node revision NODEREV in
   filesystem FS and store it in *RB_P.  Perform all allocations in
   POOL.  If rep is mutable, it must be for file contents. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>rep_read_get_baton</name><parameter_list>(<param><decl><type>struct <name>rep_read_baton</name> **</type><name>rb_p</name></decl></param>,
                   <param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                   <param><decl><type><name>representation_t</name> *</type><name>rep</name></decl></param>,
                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>rep_read_baton</name> *</type><name>b</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>b</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>b</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>b</name>-&gt;<name>fs</name></name> = <name>fs</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>b</name>-&gt;<name>chunk_index</name></name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>b</name>-&gt;<name>buf</name></name> = <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>apr_md5_init</name><argument_list>(<argument><expr>&amp;(<name><name>b</name>-&gt;<name>md5_context</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>b</name>-&gt;<name>checksum_finalized</name></name> = <name>FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>checksum</name></name></expr></argument>, <argument><expr><name><name>rep</name>-&gt;<name>checksum</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>b</name>-&gt;<name>checksum</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>b</name>-&gt;<name>len</name></name> = <name><name>rep</name>-&gt;<name>expanded_size</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>b</name>-&gt;<name>off</name></name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>b</name>-&gt;<name>pool</name></name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>b</name>-&gt;<name>filehandle_pool</name></name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>build_rep_list</name><argument_list>(<argument><expr>&amp;<name><name>b</name>-&gt;<name>rs_list</name></name></expr></argument>, <argument><expr>&amp;<name><name>b</name>-&gt;<name>src_state</name></name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>,
                         <argument><expr><name><name>b</name>-&gt;<name>filehandle_pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Save our output baton. */</comment>
  <expr_stmt><expr>*<name>rb_p</name> = <name>b</name></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Skip forwards to THIS_CHUNK in REP_STATE and then read the next delta
   window into *NWIN. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>read_window</name><parameter_list>(<param><decl><type><name>svn_txdelta_window_t</name> **</type><name>nwin</name></decl></param>, <param><decl><type><name>int</name></type> <name>this_chunk</name></decl></param>, <param><decl><type>struct <name>rep_state</name> *</type><name>rs</name></decl></param>,
            <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>stream</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>rs</name>-&gt;<name>chunk_index</name></name> &lt;= <name>this_chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Skip windows to reach the current chunk if we aren't there yet. */</comment>
  <while>while <condition>(<expr><name><name>rs</name>-&gt;<name>chunk_index</name></name> &lt; <name>this_chunk</name></expr>)</condition>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_txdelta_skip_svndiff_window</name><argument_list>(<argument><expr><name><name>rs</name>-&gt;<name>file</name></name></expr></argument>, <argument><expr><name><name>rs</name>-&gt;<name>ver</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>rs</name>-&gt;<name>chunk_index</name></name>++</expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_file_offset</name><argument_list>(<argument><expr>&amp;<name><name>rs</name>-&gt;<name>off</name></name></expr></argument>, <argument><expr><name><name>rs</name>-&gt;<name>file</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name><name>rs</name>-&gt;<name>off</name></name> &gt;= <name><name>rs</name>-&gt;<name>end</name></name></expr>)</condition><then>
        <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Reading one svndiff window read "
                                  "beyond the end of the "
                                  "representation"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
    }</block></while>

  <comment type="block">/* Read the next window. */</comment>
  <expr_stmt><expr><name>stream</name> = <call><name>svn_stream_from_aprfile</name><argument_list>(<argument><expr><name><name>rs</name>-&gt;<name>file</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_txdelta_read_svndiff_window</name><argument_list>(<argument><expr><name>nwin</name></expr></argument>, <argument><expr><name>stream</name></expr></argument>, <argument><expr><name><name>rs</name>-&gt;<name>ver</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>rs</name>-&gt;<name>chunk_index</name></name>++</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_file_offset</name><argument_list>(<argument><expr>&amp;<name><name>rs</name>-&gt;<name>off</name></name></expr></argument>, <argument><expr><name><name>rs</name>-&gt;<name>file</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name><name>rs</name>-&gt;<name>off</name></name> &gt; <name><name>rs</name>-&gt;<name>end</name></name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                            <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Reading one svndiff window read beyond "
                              "the end of the representation"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Get one delta window that is a result of combining all but the last deltas
   from the current desired representation identified in *RB, to its
   final base representation.  Store the window in *RESULT. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>get_combined_window</name><parameter_list>(<param><decl><type><name>svn_txdelta_window_t</name> **</type><name>result</name></decl></param>,
                    <param><decl><type>struct <name>rep_read_baton</name> *</type><name>rb</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>, *<decl><type ref="prev"/><name>new_pool</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_txdelta_window_t</name> *</type><name>window</name></decl>, *<decl><type ref="prev"/><name>nwin</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>rep_state</name> *</type><name>rs</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>rb</name>-&gt;<name>rs_list</name>-&gt;<name>nelts</name></name> &gt;= 2</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>pool</name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name><name>rb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Read the next window from the original rep. */</comment>
  <expr_stmt><expr><name>rs</name> = <call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name><name>rb</name>-&gt;<name>rs_list</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument>struct <expr><name>rep_state</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>read_window</name><argument_list>(<argument><expr>&amp;<name>window</name></expr></argument>, <argument><expr><name><name>rb</name>-&gt;<name>chunk_index</name></name></expr></argument>, <argument><expr><name>rs</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Combine in the windows from the other delta reps, if needed. */</comment>
  <for>for (<init><expr><name>i</name> = 1</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>rb</name>-&gt;<name>rs_list</name>-&gt;<name>nelts</name></name> - 1</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <if>if <condition>(<expr><name><name>window</name>-&gt;<name>src_ops</name></name> == 0</expr>)</condition><then>
        <break>break;</break></then></if>

      <expr_stmt><expr><name>rs</name> = <call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name><name>rb</name>-&gt;<name>rs_list</name></name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument>struct <expr><name>rep_state</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>read_window</name><argument_list>(<argument><expr>&amp;<name>nwin</name></expr></argument>, <argument><expr><name><name>rb</name>-&gt;<name>chunk_index</name></name></expr></argument>, <argument><expr><name>rs</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Combine this window with the current one.  Cycles pools so that we
         only need to hold three windows at a time. */</comment>
      <expr_stmt><expr><name>new_pool</name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name><name>rb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>window</name> = <call><name>svn_txdelta_compose_windows</name><argument_list>(<argument><expr><name>nwin</name></expr></argument>, <argument><expr><name>window</name></expr></argument>, <argument><expr><name>new_pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pool</name> = <name>new_pool</name></expr>;</expr_stmt>
    }</block></for>

  <expr_stmt><expr>*<name>result</name> = <name>window</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>rep_read_contents_close</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>rep_read_baton</name> *</type><name>rb</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name><name>rb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name><name>rb</name>-&gt;<name>filehandle_pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Return the next *LEN bytes of the rep and store them in *BUF. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>get_contents</name><parameter_list>(<param><decl><type>struct <name>rep_read_baton</name> *</type><name>rb</name></decl></param>,
             <param><decl><type><name>char</name> *</type><name>buf</name></decl></param>,
             <param><decl><type><name>apr_size_t</name> *</type><name>len</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>copy_len</name></decl>, <decl><type ref="prev"/><name>remaining</name> <init>= <expr>*<name>len</name></expr></init>, <name>tlen</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>sbuf</name></decl>, *<decl><type ref="prev"/><name>tbuf</name></decl>, *<decl><type ref="prev"/><name>cur</name> <init>= <expr><name>buf</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>rep_state</name> *</type><name>rs</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_txdelta_window_t</name> *</type><name>cwindow</name></decl>, *<decl><type ref="prev"/><name>lwindow</name></decl>;</decl_stmt>

  <comment type="block">/* Special case for when there are no delta reps, only a plain
     text. */</comment>
  <if>if <condition>(<expr><name><name>rb</name>-&gt;<name>rs_list</name>-&gt;<name>nelts</name></name> == 0</expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>copy_len</name> = <name>remaining</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>rs</name> = <name><name>rb</name>-&gt;<name>src_state</name></name></expr>;</expr_stmt>
      <if>if <condition>(<expr>((<name>apr_off_t</name>) <name>copy_len</name>) &gt; <name><name>rs</name>-&gt;<name>end</name></name> - <name><name>rs</name>-&gt;<name>off</name></name></expr>)</condition><then>
        <expr_stmt><expr><name>copy_len</name> = <call>(<name>apr_size_t</name>) <argument_list>(<argument><expr><name><name>rs</name>-&gt;<name>end</name></name> - <name><name>rs</name>-&gt;<name>off</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_read_full</name><argument_list>(<argument><expr><name><name>rs</name>-&gt;<name>file</name></name></expr></argument>, <argument><expr><name>cur</name></expr></argument>, <argument><expr><name>copy_len</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                    <argument><expr><name><name>rb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>rs</name>-&gt;<name>off</name></name> += <name>copy_len</name></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>len</name> = <name>copy_len</name></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>

  <while>while <condition>(<expr><name>remaining</name> &gt; 0</expr>)</condition>
    <block>{
      <comment type="block">/* If we have buffered data from a previous chunk, use that. */</comment>
      <if>if <condition>(<expr><name><name>rb</name>-&gt;<name>buf</name></name></expr>)</condition><then>
        <block>{
          <comment type="block">/* Determine how much to copy from the buffer. */</comment>
          <expr_stmt><expr><name>copy_len</name> = <name><name>rb</name>-&gt;<name>buf_len</name></name> - <name><name>rb</name>-&gt;<name>buf_pos</name></name></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>copy_len</name> &gt; <name>remaining</name></expr>)</condition><then>
            <expr_stmt><expr><name>copy_len</name> = <name>remaining</name></expr>;</expr_stmt></then></if>

          <comment type="block">/* Actually copy the data. */</comment>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>cur</name></expr></argument>, <argument><expr><name><name>rb</name>-&gt;<name>buf</name></name> + <name><name>rb</name>-&gt;<name>buf_pos</name></name></expr></argument>, <argument><expr><name>copy_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>rb</name>-&gt;<name>buf_pos</name></name> += <name>copy_len</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>cur</name> += <name>copy_len</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>remaining</name> -= <name>copy_len</name></expr>;</expr_stmt>

          <comment type="block">/* If the buffer is all used up, clear it and empty the
             local pool. */</comment>
          <if>if <condition>(<expr><name><name>rb</name>-&gt;<name>buf_pos</name></name> == <name><name>rb</name>-&gt;<name>buf_len</name></name></expr>)</condition><then>
            <block>{
              <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name><name>rb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>rb</name>-&gt;<name>buf</name></name> = <name>NULL</name></expr>;</expr_stmt>
            }</block></then></if>
        }</block></then>
      <else>else
        <block>{

          <expr_stmt><expr><name>rs</name> = <call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name><name>rb</name>-&gt;<name>rs_list</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument>struct <expr><name>rep_state</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name><name>rs</name>-&gt;<name>off</name></name> == <name><name>rs</name>-&gt;<name>end</name></name></expr>)</condition><then>
            <break>break;</break></then></if>

          <comment type="block">/* Get more buffered data by evaluating a chunk. */</comment>
          <if>if <condition>(<expr><name><name>rb</name>-&gt;<name>rs_list</name>-&gt;<name>nelts</name></name> &gt; 1</expr>)</condition><then>
            <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_combined_window</name><argument_list>(<argument><expr>&amp;<name>cwindow</name></expr></argument>, <argument><expr><name>rb</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
          <else>else
            <expr_stmt><expr><name>cwindow</name> = <name>NULL</name></expr>;</expr_stmt></else></if>
          <if>if <condition>(<expr>!<name>cwindow</name> || <name><name>cwindow</name>-&gt;<name>src_ops</name></name> &gt; 0</expr>)</condition><then>
            <block>{
              <expr_stmt><expr><name>rs</name> = <call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name><name>rb</name>-&gt;<name>rs_list</name></name></expr></argument>, <argument><expr><name><name>rb</name>-&gt;<name>rs_list</name>-&gt;<name>nelts</name></name> - 1</expr></argument>,
                                 <argument>struct <expr><name>rep_state</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <comment type="block">/* Read window from last representation in list. */</comment>
              <comment type="block">/* We apply this window directly instead of combining it with the
                 others.  We do this because vdelta is used for deltas against
                 the empty stream, which will trigger quadratic behaviour in
                 the delta combiner. */</comment>
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>read_window</name><argument_list>(<argument><expr>&amp;<name>lwindow</name></expr></argument>, <argument><expr><name><name>rb</name>-&gt;<name>chunk_index</name></name></expr></argument>, <argument><expr><name>rs</name></expr></argument>, <argument><expr><name><name>rb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

              <if>if <condition>(<expr><name><name>lwindow</name>-&gt;<name>src_ops</name></name> &gt; 0</expr>)</condition><then>
                <block>{
                  <if>if <condition>(<expr>! <name><name>rb</name>-&gt;<name>src_state</name></name></expr>)</condition><then>
                    <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                            <argument><expr><call><name>_</name><argument_list>(<argument><expr>"svndiff data requested "
                                              "non-existent source"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
                  <expr_stmt><expr><name>rs</name> = <name><name>rb</name>-&gt;<name>src_state</name></name></expr>;</expr_stmt>
                  <expr_stmt><expr><name>sbuf</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>rb</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>lwindow</name>-&gt;<name>sview_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <if>if <condition>(<expr>! ((<name><name>rs</name>-&gt;<name>start</name></name> + <name><name>lwindow</name>-&gt;<name>sview_offset</name></name>) &lt; <name><name>rs</name>-&gt;<name>end</name></name>)</expr>)</condition><then>
                    <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                            <argument><expr><call><name>_</name><argument_list>(<argument><expr>"svndiff requested position "
                                              "beyond end of stream"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
                  <if>if <condition>(<expr>(<name><name>rs</name>-&gt;<name>start</name></name> + <name><name>lwindow</name>-&gt;<name>sview_offset</name></name>) != <name><name>rs</name>-&gt;<name>off</name></name></expr>)</condition><then>
                    <block>{
                      <expr_stmt><expr><name><name>rs</name>-&gt;<name>off</name></name> = <name><name>rs</name>-&gt;<name>start</name></name> + <name><name>lwindow</name>-&gt;<name>sview_offset</name></name></expr>;</expr_stmt>
                      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_seek</name><argument_list>(<argument><expr><name><name>rs</name>-&gt;<name>file</name></name></expr></argument>, <argument><expr><name>APR_SET</name></expr></argument>, <argument><expr>&amp;<name><name>rs</name>-&gt;<name>off</name></name></expr></argument>,
                                               <argument><expr><name><name>rb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                    }</block></then></if>
                  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_read_full</name><argument_list>(<argument><expr><name><name>rs</name>-&gt;<name>file</name></name></expr></argument>, <argument><expr><name>sbuf</name></expr></argument>,
                                                <argument><expr><name><name>lwindow</name>-&gt;<name>sview_len</name></name></expr></argument>,
                                                <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name><name>rb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <expr_stmt><expr><name><name>rs</name>-&gt;<name>off</name></name> += <name><name>lwindow</name>-&gt;<name>sview_len</name></name></expr>;</expr_stmt>
                }</block></then>
              <else>else
                <expr_stmt><expr><name>sbuf</name> = <name>NULL</name></expr>;</expr_stmt></else></if>

              <comment type="block">/* Apply lwindow to source. */</comment>
              <expr_stmt><expr><name>tlen</name> = <name><name>lwindow</name>-&gt;<name>tview_len</name></name></expr>;</expr_stmt>
              <expr_stmt><expr><name>tbuf</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>rb</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>tlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>svn_txdelta_apply_instructions</name><argument_list>(<argument><expr><name>lwindow</name></expr></argument>, <argument><expr><name>sbuf</name></expr></argument>, <argument><expr><name>tbuf</name></expr></argument>,
                                             <argument><expr>&amp;<name>tlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <if>if <condition>(<expr><name>tlen</name> != <name><name>lwindow</name>-&gt;<name>tview_len</name></name></expr>)</condition><then>
                <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                        <argument><expr><call><name>_</name><argument_list>(<argument><expr>"svndiff window length is "
                                          "corrupt"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
              <expr_stmt><expr><name>sbuf</name> = <name>tbuf</name></expr>;</expr_stmt>
            }</block></then>
          <else>else
            <expr_stmt><expr><name>sbuf</name> = <name>NULL</name></expr>;</expr_stmt></else></if>

          <expr_stmt><expr><name><name>rb</name>-&gt;<name>chunk_index</name></name>++</expr>;</expr_stmt>

          <if>if <condition>(<expr><name>cwindow</name></expr>)</condition><then>
            <block>{
              <expr_stmt><expr><name><name>rb</name>-&gt;<name>buf_len</name></name> = <name><name>cwindow</name>-&gt;<name>tview_len</name></name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>rb</name>-&gt;<name>buf</name></name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>rb</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name><name>rb</name>-&gt;<name>buf_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><call><name>svn_txdelta_apply_instructions</name><argument_list>(<argument><expr><name>cwindow</name></expr></argument>, <argument><expr><name>sbuf</name></expr></argument>, <argument><expr><name><name>rb</name>-&gt;<name>buf</name></name></expr></argument>,
                                             <argument><expr>&amp;<name><name>rb</name>-&gt;<name>buf_len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <if>if <condition>(<expr><name><name>rb</name>-&gt;<name>buf_len</name></name> != <name><name>cwindow</name>-&gt;<name>tview_len</name></name></expr>)</condition><then>
                <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                        <argument><expr><call><name>_</name><argument_list>(<argument><expr>"svndiff window length is "
                                          "corrupt"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
            }</block></then>
          <else>else
            <block>{
              <expr_stmt><expr><name><name>rb</name>-&gt;<name>buf_len</name></name> = <name><name>lwindow</name>-&gt;<name>tview_len</name></name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>rb</name>-&gt;<name>buf</name></name> = <name>sbuf</name></expr>;</expr_stmt>
            }</block></else></if>

          <expr_stmt><expr><name><name>rb</name>-&gt;<name>buf_pos</name></name> = 0</expr>;</expr_stmt>
        }</block></else></if>
    }</block></while>

  <expr_stmt><expr>*<name>len</name> = <name>cur</name> - <name>buf</name></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* BATON is of type `rep_read_baton'; read the next *LEN bytes of the
   representation and store them in *BUF.  Sum as we read and verify
   the MD5 sum at the end. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>rep_read_contents</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>,
                  <param><decl><type><name>char</name> *</type><name>buf</name></decl></param>,
                  <param><decl><type><name>apr_size_t</name> *</type><name>len</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>rep_read_baton</name> *</type><name>rb</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Get the next block of data. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_contents</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Perform checksumming.  We want to check the checksum as soon as
     the last byte of data is read, in case the caller never performs
     a short read, but we don't want to finalize the MD5 context
     twice. */</comment>
  <if>if <condition>(<expr>!<name><name>rb</name>-&gt;<name>checksum_finalized</name></name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>apr_md5_update</name><argument_list>(<argument><expr>&amp;<name><name>rb</name>-&gt;<name>md5_context</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr>*<name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>rb</name>-&gt;<name>off</name></name> += *<name>len</name></expr>;</expr_stmt>
      <if>if <condition>(<expr><name><name>rb</name>-&gt;<name>off</name></name> == <name><name>rb</name>-&gt;<name>len</name></name></expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>checksum</name><index>[<expr><name>APR_MD5_DIGESTSIZE</name></expr>]</index></name></decl>;</decl_stmt>

          <expr_stmt><expr><name><name>rb</name>-&gt;<name>checksum_finalized</name></name> = <name>TRUE</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>apr_md5_final</name><argument_list>(<argument><expr><name>checksum</name></expr></argument>, <argument><expr>&amp;<name><name>rb</name>-&gt;<name>md5_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr>! <call><name>svn_md5_digests_match</name><argument_list>(<argument><expr><name>checksum</name></expr></argument>, <argument><expr><name><name>rb</name>-&gt;<name>checksum</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <return>return <expr><call><name>svn_error_createf</name>
              <argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
               <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Checksum mismatch while reading representation:\n"
                 "   expected:  %s\n"
                 "     actual:  %s\n"</expr></argument>)</argument_list></call></expr></argument>,
               <argument><expr><call><name>svn_md5_digest_to_cstring_display</name><argument_list>(<argument><expr><name><name>rb</name>-&gt;<name>checksum</name></name></expr></argument>, <argument><expr><name><name>rb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>,
               <argument><expr><call><name>svn_md5_digest_to_cstring_display</name><argument_list>(<argument><expr><name>checksum</name></expr></argument>, <argument><expr><name><name>rb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
        }</block></then></if>
    }</block></then></if>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Return a stream in *CONTENTS_P that will read the contents of a
   representation stored at the location given by REP.  Appropriate
   for any kind of immutable representation, but only for file
   contents (not props or directory contents) in mutable
   representations.

   If REP is NULL, the representation is assumed to be empty, and the
   empty stream is returned.
*/</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>read_representation</name><parameter_list>(<param><decl><type><name>svn_stream_t</name> **</type><name>contents_p</name></decl></param>,
                    <param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                    <param><decl><type><name>representation_t</name> *</type><name>rep</name></decl></param>,
                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>rep_read_baton</name> *</type><name>rb</name></decl>;</decl_stmt>

  <if>if <condition>(<expr>! <name>rep</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr>*<name>contents_p</name> = <call><name>svn_stream_empty</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>rep_read_get_baton</name><argument_list>(<argument><expr>&amp;<name>rb</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>contents_p</name> = <call><name>svn_stream_create</name><argument_list>(<argument><expr><name>rb</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>svn_stream_set_read</name><argument_list>(<argument><expr>*<name>contents_p</name></expr></argument>, <argument><expr><name>rep_read_contents</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>svn_stream_set_close</name><argument_list>(<argument><expr>*<name>contents_p</name></expr></argument>, <argument><expr><name>rep_read_contents_close</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__get_contents</name><parameter_list>(<param><decl><type><name>svn_stream_t</name> **</type><name>contents_p</name></decl></param>,
                        <param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                        <param><decl><type><name>node_revision_t</name> *</type><name>noderev</name></decl></param>,
                        <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>read_representation</name><argument_list>(<argument><expr><name>contents_p</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>noderev</name>-&gt;<name>data_rep</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Baton used when reading delta windows. */</comment>
<struct>struct <name>delta_read_baton</name>
<block>{
  <decl_stmt><decl><type>struct <name>rep_state</name> *</type><name>rs</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>checksum</name><index>[<expr><name>APR_MD5_DIGESTSIZE</name></expr>]</index></name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/* This implements the svn_txdelta_next_window_fn_t interface. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>delta_read_next_window</name><parameter_list>(<param><decl><type><name>svn_txdelta_window_t</name> **</type><name>window</name></decl></param>, <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>,
                       <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>delta_read_baton</name> *</type><name>drb</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name><name>drb</name>-&gt;<name>rs</name>-&gt;<name>off</name></name> == <name><name>drb</name>-&gt;<name>rs</name>-&gt;<name>end</name></name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr>*<name>window</name> = <name>NULL</name></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>read_window</name><argument_list>(<argument><expr><name>window</name></expr></argument>, <argument><expr><name><name>drb</name>-&gt;<name>rs</name>-&gt;<name>chunk_index</name></name></expr></argument>, <argument><expr><name><name>drb</name>-&gt;<name>rs</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* This implements the svn_txdelta_md5_digest_fn_t interface. */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>unsigned</name> <name>char</name> *</type>
<name>delta_read_md5_digest</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>delta_read_baton</name> *</type><name>drb</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>

  <return>return <expr><name><name>drb</name>-&gt;<name>checksum</name></name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__get_file_delta_stream</name><parameter_list>(<param><decl><type><name>svn_txdelta_stream_t</name> **</type><name>stream_p</name></decl></param>,
                                 <param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                                 <param><decl><type><name>node_revision_t</name> *</type><name>source</name></decl></param>,
                                 <param><decl><type><name>node_revision_t</name> *</type><name>target</name></decl></param>,
                                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>source_stream</name></decl>, *<decl><type ref="prev"/><name>target_stream</name></decl>;</decl_stmt>

  <comment type="block">/* Try a shortcut: if the target is stored as a delta against the source,
     then just use that delta. */</comment>
  <if>if <condition>(<expr><name>source</name> &amp;&amp; <name><name>source</name>-&gt;<name>data_rep</name></name> &amp;&amp; <name><name>target</name>-&gt;<name>data_rep</name></name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type>struct <name>rep_state</name> *</type><name>rep_state</name></decl>;</decl_stmt>
      <decl_stmt><decl><type>struct <name>rep_args</name> *</type><name>rep_args</name></decl>;</decl_stmt>

      <comment type="block">/* Read target's base rep if any. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>create_rep_state</name><argument_list>(<argument><expr>&amp;<name>rep_state</name></expr></argument>, <argument><expr>&amp;<name>rep_args</name></expr></argument>, <argument><expr><name><name>target</name>-&gt;<name>data_rep</name></name></expr></argument>,
                               <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <comment type="block">/* If that matches source, then use this delta as is. */</comment>
      <if>if <condition>(<expr><name><name>rep_args</name>-&gt;<name>is_delta</name></name>
          &amp;&amp; (<name><name>rep_args</name>-&gt;<name>is_delta_vs_empty</name></name>
              || (<name><name>rep_args</name>-&gt;<name>base_revision</name></name> == <name><name>source</name>-&gt;<name>data_rep</name>-&gt;<name>revision</name></name>
                  &amp;&amp; <name><name>rep_args</name>-&gt;<name>base_offset</name></name> == <name><name>source</name>-&gt;<name>data_rep</name>-&gt;<name>offset</name></name>))</expr>)</condition><then>
        <block>{
          <comment type="block">/* Create the delta read baton. */</comment>
          <decl_stmt><decl><type>struct <name>delta_read_baton</name> *</type><name>drb</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>drb</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr><name><name>drb</name>-&gt;<name>rs</name></name> = <name>rep_state</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>drb</name>-&gt;<name>checksum</name></name></expr></argument>, <argument><expr><name><name>target</name>-&gt;<name>data_rep</name>-&gt;<name>checksum</name></name></expr></argument>,
                 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>drb</name>-&gt;<name>checksum</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr>*<name>stream_p</name> = <call><name>svn_txdelta_stream_create</name><argument_list>(<argument><expr><name>drb</name></expr></argument>, <argument><expr><name>delta_read_next_window</name></expr></argument>,
                                                <argument><expr><name>delta_read_md5_digest</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
        }</block></then>
      <else>else
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_close</name><argument_list>(<argument><expr><name><name>rep_state</name>-&gt;<name>file</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
    }</block></then></if>

  <comment type="block">/* Read both fulltexts and construct a delta. */</comment>
  <if>if <condition>(<expr><name>source</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>read_representation</name><argument_list>(<argument><expr>&amp;<name>source_stream</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>source</name>-&gt;<name>data_rep</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name>source_stream</name> = <call><name>svn_stream_empty</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>read_representation</name><argument_list>(<argument><expr>&amp;<name>target_stream</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>target</name>-&gt;<name>data_rep</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_txdelta</name><argument_list>(<argument><expr><name>stream_p</name></expr></argument>, <argument><expr><name>source_stream</name></expr></argument>, <argument><expr><name>target_stream</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Fetch the contents of a directory into ENTRIES.  Values are stored
   as filename to string mappings; further conversion is necessary to
   convert them into svn_fs_dirent_t values. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>get_dir_contents</name><parameter_list>(<param><decl><type><name>apr_hash_t</name> *</type><name>entries</name></decl></param>,
                 <param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                 <param><decl><type><name>node_revision_t</name> *</type><name>noderev</name></decl></param>,
                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>contents</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><name><name>noderev</name>-&gt;<name>data_rep</name></name> &amp;&amp; <name><name>noderev</name>-&gt;<name>data_rep</name>-&gt;<name>txn_id</name></name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>dir_file</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>filename</name> <init>= <expr><call><name>path_txn_node_children</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>noderev</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <comment type="block">/* The representation is mutable.  Read the old directory
         contents from the mutable children file, followed by the
         changes we've made in this transaction. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_open</name><argument_list>(<argument><expr>&amp;<name>dir_file</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>APR_READ</name> | <name>APR_BUFFERED</name></expr></argument>,
                               <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>contents</name> = <call><name>svn_stream_from_aprfile</name><argument_list>(<argument><expr><name>dir_file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_hash_read2</name><argument_list>(<argument><expr><name>entries</name></expr></argument>, <argument><expr><name>contents</name></expr></argument>, <argument><expr><name>SVN_HASH_TERMINATOR</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_hash_read_incremental</name><argument_list>(<argument><expr><name>entries</name></expr></argument>, <argument><expr><name>contents</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_close</name><argument_list>(<argument><expr><name>dir_file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else <if>if <condition>(<expr><name><name>noderev</name>-&gt;<name>data_rep</name></name></expr>)</condition><then>
    <block>{
      <comment type="block">/* The representation is immutable.  Read it normally. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>read_representation</name><argument_list>(<argument><expr>&amp;<name>contents</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>noderev</name>-&gt;<name>data_rep</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_hash_read2</name><argument_list>(<argument><expr><name>entries</name></expr></argument>, <argument><expr><name>contents</name></expr></argument>, <argument><expr><name>SVN_HASH_TERMINATOR</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_close</name><argument_list>(<argument><expr><name>contents</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if></else></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Return a copy of the directory hash ENTRIES in POOL. */</comment>
<function><type><specifier>static</specifier> <name>apr_hash_t</name> *</type>
<name>copy_dir_entries</name><parameter_list>(<param><decl><type><name>apr_hash_t</name> *</type><name>entries</name></decl></param>,
                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>new_entries</name> <init>= <expr><call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>

  <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>entries</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>hi</name></expr>;</condition> <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
    <block>{
      <decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_fs_dirent_t</name> *</type><name>dirent</name></decl>, *<decl><type ref="prev"/><name>new_dirent</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>dirent</name> = <name>val</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>new_dirent</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>new_dirent</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>new_dirent</name>-&gt;<name>name</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>dirent</name>-&gt;<name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>new_dirent</name>-&gt;<name>kind</name></name> = <name><name>dirent</name>-&gt;<name>kind</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>new_dirent</name>-&gt;<name>id</name></name> = <call><name>svn_fs_fs__id_copy</name><argument_list>(<argument><expr><name><name>dirent</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>new_entries</name></expr></argument>, <argument><expr><name><name>new_dirent</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>,
                   <argument><expr><name>new_dirent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
  <return>return <expr><name>new_entries</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__rep_contents_dir</name><parameter_list>(<param><decl><type><name>apr_hash_t</name> **</type><name>entries_p</name></decl></param>,
                            <param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                            <param><decl><type><name>node_revision_t</name> *</type><name>noderev</name></decl></param>,
                            <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>fs_fs_data_t</name> *</type><name>ffd</name> <init>= <expr><name><name>fs</name>-&gt;<name>fsap_data</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>unparsed_entries</name></decl>, *<decl><type ref="prev"/><name>parsed_entries</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>hid</name></decl>;</decl_stmt>

  <comment type="block">/* Calculate an index into the dir entries cache.  This should be
     completely ignored if this is a mutable noderev. */</comment>
  <expr_stmt><expr><name>hid</name> = <call><name>DIR_CACHE_ENTRIES_MASK</name><argument_list>(<argument><expr><call><name>svn_fs_fs__id_rev</name><argument_list>(<argument><expr><name><name>noderev</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If we have this directory cached, return it. */</comment>
  <if>if <condition>(<expr>! <call><name>svn_fs_fs__id_txn_id</name><argument_list>(<argument><expr><name><name>noderev</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call> &amp;&amp;
      <name><name>ffd</name>-&gt;<name>dir_cache_id</name><index>[<expr><name>hid</name></expr>]</index></name> &amp;&amp; <call><name>svn_fs_fs__id_eq</name><argument_list>(<argument><expr><name><name>ffd</name>-&gt;<name>dir_cache_id</name><index>[<expr><name>hid</name></expr>]</index></name></expr></argument>,
                                                 <argument><expr><name><name>noderev</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <expr_stmt><expr>*<name>entries_p</name> = <call><name>copy_dir_entries</name><argument_list>(<argument><expr><name><name>ffd</name>-&gt;<name>dir_cache</name><index>[<expr><name>hid</name></expr>]</index></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>

  <comment type="block">/* Read in the directory hash. */</comment>
  <expr_stmt><expr><name>unparsed_entries</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_dir_contents</name><argument_list>(<argument><expr><name>unparsed_entries</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>noderev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>parsed_entries</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Translate the string dir entries into real entries. */</comment>
  <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>unparsed_entries</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>hi</name></expr>;</condition> <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> *</type><name>str_val</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> *</type><name>str</name></decl>, *<decl><type ref="prev"/><name>last_str</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_fs_dirent_t</name> *</type><name>dirent</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>dirent</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>str_val</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>*((<name>char</name> **)<name>val</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>dirent</name>-&gt;<name>name</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>str</name> = <call><name>apr_strtok</name><argument_list>(<argument><expr><name>str_val</name></expr></argument>, <argument><expr>" "</expr></argument>, <argument><expr>&amp;<name>last_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>str</name> == <name>NULL</name></expr>)</condition><then>
        <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Directory entry corrupt"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

      <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>KIND_FILE</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name><name>dirent</name>-&gt;<name>kind</name></name> = <name>svn_node_file</name></expr>;</expr_stmt>
        }</block></then>
      <else>else <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>KIND_DIR</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name><name>dirent</name>-&gt;<name>kind</name></name> = <name>svn_node_dir</name></expr>;</expr_stmt>
        }</block></then>
      <else>else
        <block>{
          <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                  <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Directory entry corrupt"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></else></if></else></if>

      <expr_stmt><expr><name>str</name> = <call><name>apr_strtok</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>" "</expr></argument>, <argument><expr>&amp;<name>last_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>str</name> == <name>NULL</name></expr>)</condition><then>
        <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Directory entry corrupt"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

      <expr_stmt><expr><name><name>dirent</name>-&gt;<name>id</name></name> = <call><name>svn_fs_fs__id_parse</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>parsed_entries</name></expr></argument>, <argument><expr><name><name>dirent</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>dirent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

  <comment type="block">/* If this is an immutable directory, let's cache the contents. */</comment>
  <if>if <condition>(<expr>! <call><name>svn_fs_fs__id_txn_id</name><argument_list>(<argument><expr><name><name>noderev</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <comment type="block">/* Start by NULLing the ID field, so that we never leave the
         cache in an illegal state. */</comment>
      <expr_stmt><expr><name><name>ffd</name>-&gt;<name>dir_cache_id</name><index>[<expr><name>hid</name></expr>]</index></name> = <name>NULL</name></expr>;</expr_stmt>

      <if>if <condition>(<expr><name><name>ffd</name>-&gt;<name>dir_cache_pool</name><index>[<expr><name>hid</name></expr>]</index></name></expr>)</condition><then>
        <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name><name>ffd</name>-&gt;<name>dir_cache_pool</name><index>[<expr><name>hid</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
      <else>else
        <expr_stmt><expr><name><name>ffd</name>-&gt;<name>dir_cache_pool</name><index>[<expr><name>hid</name></expr>]</index></name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name><name>fs</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

      <expr_stmt><expr><name><name>ffd</name>-&gt;<name>dir_cache</name><index>[<expr><name>hid</name></expr>]</index></name> = <call><name>copy_dir_entries</name><argument_list>(<argument><expr><name>parsed_entries</name></expr></argument>,
                                             <argument><expr><name><name>ffd</name>-&gt;<name>dir_cache_pool</name><index>[<expr><name>hid</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>ffd</name>-&gt;<name>dir_cache_id</name><index>[<expr><name>hid</name></expr>]</index></name> = <call><name>svn_fs_fs__id_copy</name><argument_list>(<argument><expr><name><name>noderev</name>-&gt;<name>id</name></name></expr></argument>,
                                                  <argument><expr><name><name>ffd</name>-&gt;<name>dir_cache_pool</name><index>[<expr><name>hid</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <expr_stmt><expr>*<name>entries_p</name> = <name>parsed_entries</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__get_proplist</name><parameter_list>(<param><decl><type><name>apr_hash_t</name> **</type><name>proplist_p</name></decl></param>,
                        <param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                        <param><decl><type><name>node_revision_t</name> *</type><name>noderev</name></decl></param>,
                        <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>proplist</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>stream</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>proplist</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name><name>noderev</name>-&gt;<name>prop_rep</name></name> &amp;&amp; <name><name>noderev</name>-&gt;<name>prop_rep</name>-&gt;<name>txn_id</name></name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>props_file</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>filename</name> <init>= <expr><call><name>path_txn_node_props</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>noderev</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_open</name><argument_list>(<argument><expr>&amp;<name>props_file</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>,
                               <argument><expr><name>APR_READ</name> | <name>APR_BUFFERED</name></expr></argument>, <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>,
                               <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>stream</name> = <call><name>svn_stream_from_aprfile</name><argument_list>(<argument><expr><name>props_file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_hash_read2</name><argument_list>(<argument><expr><name>proplist</name></expr></argument>, <argument><expr><name>stream</name></expr></argument>, <argument><expr><name>SVN_HASH_TERMINATOR</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_close</name><argument_list>(<argument><expr><name>props_file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else <if>if <condition>(<expr><name><name>noderev</name>-&gt;<name>prop_rep</name></name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>read_representation</name><argument_list>(<argument><expr>&amp;<name>stream</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>noderev</name>-&gt;<name>prop_rep</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_hash_read2</name><argument_list>(<argument><expr><name>proplist</name></expr></argument>, <argument><expr><name>stream</name></expr></argument>, <argument><expr><name>SVN_HASH_TERMINATOR</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_close</name><argument_list>(<argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if></else></if>

  <expr_stmt><expr>*<name>proplist_p</name> = <name>proplist</name></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__file_length</name><parameter_list>(<param><decl><type><name>svn_filesize_t</name> *</type><name>length</name></decl></param>,
                       <param><decl><type><name>node_revision_t</name> *</type><name>noderev</name></decl></param>,
                       <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name><name>noderev</name>-&gt;<name>data_rep</name></name></expr>)</condition><then>
    <expr_stmt><expr>*<name>length</name> = <name><name>noderev</name>-&gt;<name>data_rep</name>-&gt;<name>expanded_size</name></name></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr>*<name>length</name> = 0</expr>;</expr_stmt></else></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>svn_boolean_t</name></type>
<name>svn_fs_fs__noderev_same_rep_key</name><parameter_list>(<param><decl><type><name>representation_t</name> *</type><name>a</name></decl></param>,
                                <param><decl><type><name>representation_t</name> *</type><name>b</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>a</name> == <name>b</name></expr>)</condition><then>
    <return>return <expr><name>TRUE</name></expr>;</return></then></if>

  <if>if <condition>(<expr><name>a</name> &amp;&amp; (! <name>b</name>)</expr>)</condition><then>
    <return>return <expr><name>FALSE</name></expr>;</return></then></if>

  <if>if <condition>(<expr><name>b</name> &amp;&amp; (! <name>a</name>)</expr>)</condition><then>
    <return>return <expr><name>FALSE</name></expr>;</return></then></if>

  <if>if <condition>(<expr><name><name>a</name>-&gt;<name>offset</name></name> != <name><name>b</name>-&gt;<name>offset</name></name></expr>)</condition><then>
    <return>return <expr><name>FALSE</name></expr>;</return></then></if>

  <if>if <condition>(<expr><name><name>a</name>-&gt;<name>revision</name></name> != <name><name>b</name>-&gt;<name>revision</name></name></expr>)</condition><then>
    <return>return <expr><name>FALSE</name></expr>;</return></then></if>

  <return>return <expr><name>TRUE</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__file_checksum</name><parameter_list>(<param><decl><type><name>unsigned</name> <name>char</name></type> <name><name>digest</name><index>[]</index></name></decl></param>,
                         <param><decl><type><name>node_revision_t</name> *</type><name>noderev</name></decl></param>,
                         <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name><name>noderev</name>-&gt;<name>data_rep</name></name></expr>)</condition><then>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>digest</name></expr></argument>, <argument><expr><name><name>noderev</name>-&gt;<name>data_rep</name>-&gt;<name>checksum</name></name></expr></argument>, <argument><expr><name>APR_MD5_DIGESTSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>digest</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>APR_MD5_DIGESTSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>representation_t</name> *</type>
<name>svn_fs_fs__rep_copy</name><parameter_list>(<param><decl><type><name>representation_t</name> *</type><name>rep</name></decl></param>,
                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>representation_t</name> *</type><name>rep_new</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>rep</name> == <name>NULL</name></expr>)</condition><then>
    <return>return <expr><name>NULL</name></expr>;</return></then></if>

  <expr_stmt><expr><name>rep_new</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>rep_new</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>rep_new</name></expr></argument>, <argument><expr><name>rep</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>rep_new</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>rep_new</name></expr>;</return>
}</block></function>

<comment type="block">/* Merge the internal-use-only CHANGE into a hash of public-FS
   svn_fs_path_change_t CHANGES, collapsing multiple changes into a
   single summarical (is that real word?) change per path.  Also keep
   the COPYFROM_HASH up to date with new adds and replaces.  */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>fold_change</name><parameter_list>(<param><decl><type><name>apr_hash_t</name> *</type><name>changes</name></decl></param>,
            <param><decl><type><specifier>const</specifier> <name>change_t</name> *</type><name>change</name></decl></param>,
            <param><decl><type><name>apr_hash_t</name> *</type><name>copyfrom_hash</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name> <init>= <expr><call><name>apr_hash_pool_get</name><argument_list>(<argument><expr><name>changes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>copyfrom_pool</name> <init>= <expr><call><name>apr_hash_pool_get</name><argument_list>(<argument><expr><name>copyfrom_hash</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_path_change_t</name> *</type><name>old_change</name></decl>, *<decl><type ref="prev"/><name>new_change</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>, *<decl><type ref="prev"/><name>copyfrom_string</name></decl>, *<decl><type ref="prev"/><name>copyfrom_path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr>(<name>old_change</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>changes</name></expr></argument>, <argument><expr><name><name>change</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
    <block>{
      <comment type="block">/* This path already exists in the hash, so we have to merge
         this change into the already existing one. */</comment>

      <comment type="block">/* Get the existing copyfrom entry for this path. */</comment>
      <expr_stmt><expr><name>copyfrom_string</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>copyfrom_hash</name></expr></argument>, <argument><expr><name><name>change</name>-&gt;<name>path</name></name></expr></argument>,
                                     <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* If this entry existed in the copyfrom hash, we don't need to
         copy it. */</comment>
      <if>if <condition>(<expr><name>copyfrom_string</name></expr>)</condition><then>
        <expr_stmt><expr><name>copyfrom_path</name> = <name><name>change</name>-&gt;<name>path</name></name></expr>;</expr_stmt></then></if>

      <comment type="block">/* Since the path already exists in the hash, we don't have to
         dup the allocation for the path itself. */</comment>
      <expr_stmt><expr><name>path</name> = <name><name>change</name>-&gt;<name>path</name></name></expr>;</expr_stmt>
      <comment type="block">/* Sanity check:  only allow NULL node revision ID in the
         `reset' case. */</comment>
      <if>if <condition>(<expr>(! <name><name>change</name>-&gt;<name>noderev_id</name></name>) &amp;&amp; (<name><name>change</name>-&gt;<name>kind</name></name> != <name>svn_fs_path_change_reset</name>)</expr>)</condition><then>
        <return>return <expr><call><name>svn_error_create</name>
          <argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
           <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Missing required node revision ID"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

      <comment type="block">/* Sanity check: we should be talking about the same node
         revision ID as our last change except where the last change
         was a deletion. */</comment>
      <if>if <condition>(<expr><name><name>change</name>-&gt;<name>noderev_id</name></name>
          &amp;&amp; (! <call><name>svn_fs_fs__id_eq</name><argument_list>(<argument><expr><name><name>old_change</name>-&gt;<name>node_rev_id</name></name></expr></argument>, <argument><expr><name><name>change</name>-&gt;<name>noderev_id</name></name></expr></argument>)</argument_list></call>)
          &amp;&amp; (<name><name>old_change</name>-&gt;<name>change_kind</name></name> != <name>svn_fs_path_change_delete</name>)</expr>)</condition><then>
        <return>return <expr><call><name>svn_error_create</name>
          <argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
           <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Invalid change ordering: new node revision ID "
             "without delete"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

      <comment type="block">/* Sanity check: an add, replacement, or reset must be the first
         thing to follow a deletion. */</comment>
      <if>if <condition>(<expr>(<name><name>old_change</name>-&gt;<name>change_kind</name></name> == <name>svn_fs_path_change_delete</name>)
          &amp;&amp; (! ((<name><name>change</name>-&gt;<name>kind</name></name> == <name>svn_fs_path_change_replace</name>)
                 || (<name><name>change</name>-&gt;<name>kind</name></name> == <name>svn_fs_path_change_reset</name>)
                 || (<name><name>change</name>-&gt;<name>kind</name></name> == <name>svn_fs_path_change_add</name>)))</expr>)</condition><then>
        <return>return <expr><call><name>svn_error_create</name>
          <argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
           <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Invalid change ordering: non-add change on deleted path"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

      <comment type="block">/* Now, merge that change in. */</comment>
      <switch>switch <condition>(<expr><name><name>change</name>-&gt;<name>kind</name></name></expr>)</condition>
        <block>{
        <case>case <expr><name>svn_fs_path_change_reset</name></expr>:
          <comment type="block">/* A reset here will simply remove the path change from the
             hash. */</comment>
          <expr_stmt><expr><name>old_change</name> = <name>NULL</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>copyfrom_string</name> = <name>NULL</name></expr>;</expr_stmt>
          <break>break;</break>

        </case><case>case <expr><name>svn_fs_path_change_delete</name></expr>:
          <if>if <condition>(<expr><name><name>old_change</name>-&gt;<name>change_kind</name></name> == <name>svn_fs_path_change_add</name></expr>)</condition><then>
            <block>{
              <comment type="block">/* If the path was introduced in this transaction via an
                 add, and we are deleting it, just remove the path
                 altogether. */</comment>
              <expr_stmt><expr><name>old_change</name> = <name>NULL</name></expr>;</expr_stmt>
            }</block></then>
          <else>else
            <block>{
              <comment type="block">/* A deletion overrules all previous changes. */</comment>
              <expr_stmt><expr><name><name>old_change</name>-&gt;<name>change_kind</name></name> = <name>svn_fs_path_change_delete</name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>old_change</name>-&gt;<name>text_mod</name></name> = <name><name>change</name>-&gt;<name>text_mod</name></name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>old_change</name>-&gt;<name>prop_mod</name></name> = <name><name>change</name>-&gt;<name>prop_mod</name></name></expr>;</expr_stmt>
            }</block></else></if>
          <expr_stmt><expr><name>copyfrom_string</name> = <name>NULL</name></expr>;</expr_stmt>
          <break>break;</break>

        </case><case>case <expr><name>svn_fs_path_change_add</name></expr>:
        </case><case>case <expr><name>svn_fs_path_change_replace</name></expr>:
          <comment type="block">/* An add at this point must be following a previous delete,
             so treat it just like a replace. */</comment>
          <expr_stmt><expr><name><name>old_change</name>-&gt;<name>change_kind</name></name> = <name>svn_fs_path_change_replace</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>old_change</name>-&gt;<name>node_rev_id</name></name> = <call><name>svn_fs_fs__id_copy</name><argument_list>(<argument><expr><name><name>change</name>-&gt;<name>noderev_id</name></name></expr></argument>,
                                                       <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>old_change</name>-&gt;<name>text_mod</name></name> = <name><name>change</name>-&gt;<name>text_mod</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>old_change</name>-&gt;<name>prop_mod</name></name> = <name><name>change</name>-&gt;<name>prop_mod</name></name></expr>;</expr_stmt>
          <if>if <condition>(<expr><name><name>change</name>-&gt;<name>copyfrom_rev</name></name> == <name>SVN_INVALID_REVNUM</name></expr>)</condition><then>
            <expr_stmt><expr><name>copyfrom_string</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>copyfrom_pool</name></expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
          <else>else
            <block>{
              <expr_stmt><expr><name>copyfrom_string</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>copyfrom_pool</name></expr></argument>,
                                             <argument><expr>"%ld %s"</expr></argument>,
                                             <argument><expr><name><name>change</name>-&gt;<name>copyfrom_rev</name></name></expr></argument>,
                                             <argument><expr><name><name>change</name>-&gt;<name>copyfrom_path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
          <break>break;</break>

        </case><case>case <expr><name>svn_fs_path_change_modify</name></expr>:
        </case><default>default:
          <if>if <condition>(<expr><name><name>change</name>-&gt;<name>text_mod</name></name></expr>)</condition><then>
            <expr_stmt><expr><name><name>old_change</name>-&gt;<name>text_mod</name></name> = <name>TRUE</name></expr>;</expr_stmt></then></if>
          <if>if <condition>(<expr><name><name>change</name>-&gt;<name>prop_mod</name></name></expr>)</condition><then>
            <expr_stmt><expr><name><name>old_change</name>-&gt;<name>prop_mod</name></name> = <name>TRUE</name></expr>;</expr_stmt></then></if>
          <break>break;</break>
        </default>}</block></switch>

      <comment type="block">/* Point our new_change to our (possibly modified) old_change. */</comment>
      <expr_stmt><expr><name>new_change</name> = <name>old_change</name></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <comment type="block">/* This change is new to the hash, so make a new public change
         structure from the internal one (in the hash's pool), and dup
         the path into the hash's pool, too. */</comment>
      <expr_stmt><expr><name>new_change</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>new_change</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>new_change</name>-&gt;<name>node_rev_id</name></name> = <call><name>svn_fs_fs__id_copy</name><argument_list>(<argument><expr><name><name>change</name>-&gt;<name>noderev_id</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>new_change</name>-&gt;<name>change_kind</name></name> = <name><name>change</name>-&gt;<name>kind</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>new_change</name>-&gt;<name>text_mod</name></name> = <name><name>change</name>-&gt;<name>text_mod</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>new_change</name>-&gt;<name>prop_mod</name></name> = <name><name>change</name>-&gt;<name>prop_mod</name></name></expr>;</expr_stmt>
      <if>if <condition>(<expr><name><name>change</name>-&gt;<name>copyfrom_rev</name></name> != <name>SVN_INVALID_REVNUM</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>copyfrom_string</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>copyfrom_pool</name></expr></argument>, <argument><expr>"%ld %s"</expr></argument>,
                                         <argument><expr><name><name>change</name>-&gt;<name>copyfrom_rev</name></name></expr></argument>,
                                         <argument><expr><name><name>change</name>-&gt;<name>copyfrom_path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then>
      <else>else
        <expr_stmt><expr><name>copyfrom_string</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>copyfrom_pool</name></expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
      <expr_stmt><expr><name>path</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>change</name>-&gt;<name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

  <comment type="block">/* Add (or update) this path. */</comment>
  <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>changes</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>new_change</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If copyfrom_path is non-NULL, the key is already present in the
     hash, so we don't need to duplicate it in the copyfrom pool. */</comment>
  <if>if <condition>(<expr>! <name>copyfrom_path</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* If copyfrom_string is NULL, the hash entry will be deleted,
         so we don't need to duplicate the key in the copyfrom
         pool. */</comment>
      <expr_stmt><expr><name>copyfrom_path</name> = <name>copyfrom_string</name> ? <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>copyfrom_pool</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call>
        : <name>path</name></expr>;</expr_stmt>
    }</block></then></if>

  <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>copyfrom_hash</name></expr></argument>, <argument><expr><name>copyfrom_path</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>,
               <argument><expr><name>copyfrom_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* The 256 is an arbitrary size large enough to hold the node id and the
 * various flags. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_CHANGE_LINE_LEN</name></cpp:macro> <cpp:value>FSFS_MAX_PATH_LEN + 256</cpp:value></cpp:define>

<comment type="block">/* Read the next entry in the changes record from file FILE and store
   the resulting change in *CHANGE_P.  If there is no next record,
   store NULL there.  Perform all allocations from POOL. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>read_change</name><parameter_list>(<param><decl><type><name>change_t</name> **</type><name>change_p</name></decl></param>,
            <param><decl><type><name>apr_file_t</name> *</type><name>file</name></decl></param>,
            <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>MAX_CHANGE_LINE_LEN</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>change_t</name> *</type><name>change</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>str</name></decl>, *<decl><type ref="prev"/><name>last_str</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>

  <comment type="block">/* Default return value. */</comment>
  <expr_stmt><expr>*<name>change_p</name> = <name>NULL</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>err</name> = <call><name>svn_io_read_length_line</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check for a blank line. */</comment>
  <if>if <condition>(<expr><name>err</name> || (<name>len</name> == 0)</expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr><name>err</name> &amp;&amp; <call><name>APR_STATUS_IS_EOF</name><argument_list>(<argument><expr><name><name>err</name>-&gt;<name>apr_err</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
        }</block></then></if>
      <if>if <condition>(<expr>(<name>len</name> == 0) &amp;&amp; (! <name>err</name>)</expr>)</condition><then>
        <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>
      <return>return <expr><name>err</name></expr>;</return>
    }</block></then></if>

  <expr_stmt><expr><name>change</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>change</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Get the node-id of the change. */</comment>
  <expr_stmt><expr><name>str</name> = <call><name>apr_strtok</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>" "</expr></argument>, <argument><expr>&amp;<name>last_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>str</name> == <name>NULL</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                            <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Invalid changes line in rev-file"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><name><name>change</name>-&gt;<name>noderev_id</name></name> = <call><name>svn_fs_fs__id_parse</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Get the change type. */</comment>
  <expr_stmt><expr><name>str</name> = <call><name>apr_strtok</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>" "</expr></argument>, <argument><expr>&amp;<name>last_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>str</name> == <name>NULL</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                            <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Invalid changes line in rev-file"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>ACTION_MODIFY</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name><name>change</name>-&gt;<name>kind</name></name> = <name>svn_fs_path_change_modify</name></expr>;</expr_stmt>
    }</block></then>
  <else>else <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>ACTION_ADD</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name><name>change</name>-&gt;<name>kind</name></name> = <name>svn_fs_path_change_add</name></expr>;</expr_stmt>
    }</block></then>
  <else>else <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>ACTION_DELETE</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name><name>change</name>-&gt;<name>kind</name></name> = <name>svn_fs_path_change_delete</name></expr>;</expr_stmt>
    }</block></then>
  <else>else <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>ACTION_REPLACE</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name><name>change</name>-&gt;<name>kind</name></name> = <name>svn_fs_path_change_replace</name></expr>;</expr_stmt>
    }</block></then>
  <else>else <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>ACTION_RESET</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name><name>change</name>-&gt;<name>kind</name></name> = <name>svn_fs_path_change_reset</name></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                              <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Invalid change kind in rev file"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></else></if></else></if></else></if></else></if></else></if>

  <comment type="block">/* Get the text-mod flag. */</comment>
  <expr_stmt><expr><name>str</name> = <call><name>apr_strtok</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>" "</expr></argument>, <argument><expr>&amp;<name>last_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>str</name> == <name>NULL</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                            <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Invalid changes line in rev-file"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>FLAG_TRUE</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name><name>change</name>-&gt;<name>text_mod</name></name> = <name>TRUE</name></expr>;</expr_stmt>
    }</block></then>
  <else>else <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>FLAG_FALSE</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name><name>change</name>-&gt;<name>text_mod</name></name> = <name>FALSE</name></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                              <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Invalid text-mod flag in rev-file"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></else></if></else></if>

  <comment type="block">/* Get the prop-mod flag. */</comment>
  <expr_stmt><expr><name>str</name> = <call><name>apr_strtok</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>" "</expr></argument>, <argument><expr>&amp;<name>last_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>str</name> == <name>NULL</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                            <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Invalid changes line in rev-file"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>FLAG_TRUE</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name><name>change</name>-&gt;<name>prop_mod</name></name> = <name>TRUE</name></expr>;</expr_stmt>
    }</block></then>
  <else>else <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>FLAG_FALSE</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name><name>change</name>-&gt;<name>prop_mod</name></name> = <name>FALSE</name></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                              <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Invalid prop-mod flag in rev-file"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></else></if></else></if>

  <comment type="block">/* Get the changed path. */</comment>
  <expr_stmt><expr><name><name>change</name>-&gt;<name>path</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>last_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


  <comment type="block">/* Read the next line, the copyfrom line. */</comment>
  <expr_stmt><expr><name>len</name> = <sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_read_length_line</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>len</name> == 0</expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name><name>change</name>-&gt;<name>copyfrom_rev</name></name> = <name>SVN_INVALID_REVNUM</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>change</name>-&gt;<name>copyfrom_path</name></name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <expr_stmt><expr><name>str</name> = <call><name>apr_strtok</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>" "</expr></argument>, <argument><expr>&amp;<name>last_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr>! <name>str</name></expr>)</condition><then>
        <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Invalid changes line in rev-file"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
      <expr_stmt><expr><name><name>change</name>-&gt;<name>copyfrom_rev</name></name> = <call><name>atol</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr>! <name>last_str</name></expr>)</condition><then>
        <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Invalid changes line in rev-file"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

      <expr_stmt><expr><name><name>change</name>-&gt;<name>copyfrom_path</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>last_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

  <expr_stmt><expr>*<name>change_p</name> = <name>change</name></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Fetch all the changed path entries from FILE and store then in
   *CHANGED_PATHS.  Folding is done to remove redundant or unnecessary
   *data.  Store a hash of paths to copyfrom revisions/paths in
   COPYFROM_HASH if it is non-NULL.  If PREFOLDED is true, assume that
   the changed-path entries have already been folded (by
   write_final_changed_path_info) and may be out of order, so we shouldn't
   remove children of replaced or deleted directories.  Do all
   allocations in POOL. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>fetch_all_changes</name><parameter_list>(<param><decl><type><name>apr_hash_t</name> *</type><name>changed_paths</name></decl></param>,
                  <param><decl><type><name>apr_hash_t</name> *</type><name>copyfrom_hash</name></decl></param>,
                  <param><decl><type><name>apr_file_t</name> *</type><name>file</name></decl></param>,
                  <param><decl><type><name>svn_boolean_t</name></type> <name>prefolded</name></decl></param>,
                  <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>change_t</name> *</type><name>change</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>iterpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>my_hash</name></decl>;</decl_stmt>

  <comment type="block">/* If we are passed a NULL copyfrom hash, manufacture one for the
     duration of this call. */</comment>
  <expr_stmt><expr><name>my_hash</name> = <name>copyfrom_hash</name> ? <name>copyfrom_hash</name> : <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Read in the changes one by one, folding them into our local hash
     as necessary. */</comment>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>read_change</name><argument_list>(<argument><expr>&amp;<name>change</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <while>while <condition>(<expr><name>change</name></expr>)</condition>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>fold_change</name><argument_list>(<argument><expr><name>changed_paths</name></expr></argument>, <argument><expr><name>change</name></expr></argument>, <argument><expr><name>my_hash</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Now, if our change was a deletion or replacement, we have to
         blow away any changes thus far on paths that are (or, were)
         children of this path.
         ### i won't bother with another iteration pool here -- at
         most we talking about a few extra dups of paths into what
         is already a temporary subpool.
      */</comment>

      <if>if <condition>(<expr>((<name><name>change</name>-&gt;<name>kind</name></name> == <name>svn_fs_path_change_delete</name>)
           || (<name><name>change</name>-&gt;<name>kind</name></name> == <name>svn_fs_path_change_replace</name>))
          &amp;&amp; ! <name>prefolded</name></expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>

          <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>, <argument><expr><name>changed_paths</name></expr></argument>)</argument_list></call></expr>;</init>
               <condition><expr><name>hi</name></expr>;</condition>
               <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
            <block>{
              <comment type="block">/* KEY is the path. */</comment>
              <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>hashkey</name></decl>;</decl_stmt>
              <decl_stmt><decl><type><name>apr_ssize_t</name></type> <name>klen</name></decl>;</decl_stmt>
              <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>hashkey</name></expr></argument>, <argument><expr>&amp;<name>klen</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

              <comment type="block">/* If we come across our own path, ignore it. */</comment>
              <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>change</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>hashkey</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
                <continue>continue;</continue></then></if>

              <comment type="block">/* If we come across a child of our path, remove it. */</comment>
              <if>if <condition>(<expr><call><name>svn_path_is_child</name><argument_list>(<argument><expr><name><name>change</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>hashkey</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>changed_paths</name></expr></argument>, <argument><expr><name>hashkey</name></expr></argument>, <argument><expr><name>klen</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
            }</block></for>
        }</block></then></if>

      <comment type="block">/* Clear the per-iteration subpool. */</comment>
      <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>read_change</name><argument_list>(<argument><expr>&amp;<name>change</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></while>

  <comment type="block">/* Destroy the per-iteration subpool. */</comment>
  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__txn_changes_fetch</name><parameter_list>(<param><decl><type><name>apr_hash_t</name> **</type><name>changed_paths_p</name></decl></param>,
                             <param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                             <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>,
                             <param><decl><type><name>apr_hash_t</name> *</type><name>copyfrom_cache</name></decl></param>,
                             <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>file</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>changed_paths</name> <init>= <expr><call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_open</name><argument_list>(<argument><expr>&amp;<name>file</name></expr></argument>, <argument><expr><call><name>path_txn_changes</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><name>APR_READ</name> | <name>APR_BUFFERED</name></expr></argument>, <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>fetch_all_changes</name><argument_list>(<argument><expr><name>changed_paths</name></expr></argument>, <argument><expr><name>copyfrom_cache</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                            <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_close</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>changed_paths_p</name> = <name>changed_paths</name></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__paths_changed</name><parameter_list>(<param><decl><type><name>apr_hash_t</name> **</type><name>changed_paths_p</name></decl></param>,
                         <param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                         <param><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl></param>,
                         <param><decl><type><name>apr_hash_t</name> *</type><name>copyfrom_cache</name></decl></param>,
                         <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_off_t</name></type> <name>changes_offset</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>changed_paths</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>revision_file</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>ensure_revision_exists</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_open</name><argument_list>(<argument><expr>&amp;<name>revision_file</name></expr></argument>, <argument><expr><call><name>svn_fs_fs__path_rev</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><name>APR_READ</name> | <name>APR_BUFFERED</name></expr></argument>, <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_root_changes_offset</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>changes_offset</name></expr></argument>, <argument><expr><name>revision_file</name></expr></argument>,
                                  <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_seek</name><argument_list>(<argument><expr><name>revision_file</name></expr></argument>, <argument><expr><name>APR_SET</name></expr></argument>, <argument><expr>&amp;<name>changes_offset</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>changed_paths</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>fetch_all_changes</name><argument_list>(<argument><expr><name>changed_paths</name></expr></argument>, <argument><expr><name>copyfrom_cache</name></expr></argument>, <argument><expr><name>revision_file</name></expr></argument>,
                            <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Close the revision file. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_close</name><argument_list>(<argument><expr><name>revision_file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>changed_paths_p</name> = <name>changed_paths</name></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Copy a revision node-rev SRC into the current transaction TXN_ID in
   the filesystem FS.  This is only used to create the root of a transaction.
   Allocations are from POOL.  */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>create_new_txn_noderev_from_rev</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                                <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>,
                                <param><decl><type><name>svn_fs_id_t</name> *</type><name>src</name></decl></param>,
                                <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>node_revision_t</name> *</type><name>noderev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>node_id</name></decl>, *<decl><type ref="prev"/><name>copy_id</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__get_node_revision</name><argument_list>(<argument><expr>&amp;<name>noderev</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><call><name>svn_fs_fs__id_txn_id</name><argument_list>(<argument><expr><name><name>noderev</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                            <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Copying from transactions not allowed"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><name><name>noderev</name>-&gt;<name>predecessor_id</name></name> = <name><name>noderev</name>-&gt;<name>id</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>noderev</name>-&gt;<name>predecessor_count</name></name>++</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>noderev</name>-&gt;<name>copyfrom_path</name></name> = <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>noderev</name>-&gt;<name>copyfrom_rev</name></name> = <name>SVN_INVALID_REVNUM</name></expr>;</expr_stmt>

  <comment type="block">/* For the transaction root, the copyroot never changes. */</comment>

  <expr_stmt><expr><name>node_id</name> = <call><name>svn_fs_fs__id_node_id</name><argument_list>(<argument><expr><name><name>noderev</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>copy_id</name> = <call><name>svn_fs_fs__id_copy_id</name><argument_list>(<argument><expr><name><name>noderev</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>noderev</name>-&gt;<name>id</name></name> = <call><name>svn_fs_fs__id_txn_create</name><argument_list>(<argument><expr><name>node_id</name></expr></argument>, <argument><expr><name>copy_id</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__put_node_revision</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>noderev</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>noderev</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* A structure used by get_and_increment_txn_key_body(). */</comment>
<struct>struct <name>get_and_increment_txn_key_baton</name> <block>{
  <decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>txn_id</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/* Callback used in the implementation of create_txn_dir().  This gets
   the current base 36 value in PATH_TXN_CURRENT and increments it.
   It returns the original value by the baton. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>get_and_increment_txn_key_body</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>get_and_increment_txn_key_baton</name> *</type><name>cb</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_current_filename</name> <init>= <expr><call><name>path_txn_current</name><argument_list>(<argument><expr><name><name>cb</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>txn_current_file</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>tmp_filename</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>next_txn_id</name><index>[<expr><name>MAX_KEY_SIZE</name>+3</expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name> <init>= <expr><name>SVN_NO_ERROR</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>iterpool</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>cb</name>-&gt;<name>txn_id</name></name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>cb</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>MAX_KEY_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>iterpool</name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name>SVN_ESTALE_RETRY_COUNT</name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>)
    <block>{
      <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>SVN_RETRY_ESTALE</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><call><name>svn_io_file_open</name><argument_list>(<argument><expr>&amp;<name>txn_current_file</name></expr></argument>,
                                             <argument><expr><name>txn_current_filename</name></expr></argument>,
                                             <argument><expr><name>APR_READ</name> | <name>APR_BUFFERED</name></expr></argument>,
                                             <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>len</name> = <name>MAX_KEY_SIZE</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_RETRY_ESTALE</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><call><name>svn_io_read_length_line</name><argument_list>(<argument><expr><name>txn_current_file</name></expr></argument>,
                                                    <argument><expr><name><name>cb</name>-&gt;<name>txn_id</name></name></expr></argument>,
                                                    <argument><expr>&amp;<name>len</name></expr></argument>,
                                                    <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_IGNORE_ESTALE</name><argument_list>(<argument><expr><name>err</name></expr></argument>, <argument><expr><call><name>svn_io_file_close</name><argument_list>(<argument><expr><name>txn_current_file</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <break>break;</break>
    }</block></for>
  <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
    <return>return <expr><name>err</name></expr>;</return></then></if>

  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Increment the key and add a trailing \n to the string so the
     txn-current file has a newline in it. */</comment>
  <expr_stmt><expr><call><name>svn_fs_fs__next_key</name><argument_list>(<argument><expr><name><name>cb</name>-&gt;<name>txn_id</name></name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr><name>next_txn_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>next_txn_id</name><index>[<expr><name>len</name></expr>]</index></name> = '\n'</expr>;</expr_stmt>
  <expr_stmt><expr>++<name>len</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>next_txn_id</name><index>[<expr><name>len</name></expr>]</index></name> = '\0'</expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_open_unique_file2</name><argument_list>(<argument><expr>&amp;<name>txn_current_file</name></expr></argument>, <argument><expr>&amp;<name>tmp_filename</name></expr></argument>,
                                   <argument><expr><name>txn_current_filename</name></expr></argument>, <argument><expr>".tmp"</expr></argument>,
                                   <argument><expr><name>svn_io_file_del_none</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_write_full</name><argument_list>(<argument><expr><name>txn_current_file</name></expr></argument>,
                                 <argument><expr><name>next_txn_id</name></expr></argument>,
                                 <argument><expr><name>len</name></expr></argument>,
                                 <argument><expr><name>NULL</name></expr></argument>,
                                 <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_flush_to_disk</name><argument_list>(<argument><expr><name>txn_current_file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_close</name><argument_list>(<argument><expr><name>txn_current_file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__move_into_place</name><argument_list>(<argument><expr><name>tmp_filename</name></expr></argument>, <argument><expr><name>txn_current_filename</name></expr></argument>,
                                     <argument><expr><name>txn_current_filename</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>err</name></expr>;</return>
}</block></function>

<comment type="block">/* Create a unique directory for a transaction in FS based on revision
   REV.  Return the ID for this transaction in *ID_P.  Use a sequence
   value in the transaction ID to prevent reuse of transaction IDs. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>create_txn_dir</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>id_p</name></decl></param>, <param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>, <param><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl></param>,
               <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>get_and_increment_txn_key_baton</name></type> <name>cb</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_dir</name></decl>;</decl_stmt>

  <comment type="block">/* Get the current transaction sequence value, which is a base-36
     number, from the txn-current file, and write an
     incremented value back out to the file.  Place the revision
     number the transaction is based off into the transaction id. */</comment>
  <expr_stmt><expr><name><name>cb</name>.<name>pool</name></name> = <name>pool</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cb</name>.<name>fs</name></name> = <name>fs</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>with_txn_current_lock</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,
                                <argument><expr><name>get_and_increment_txn_key_body</name></expr></argument>,
                                <argument><expr>&amp;<name>cb</name></expr></argument>,
                                <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>id_p</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%ld-%s"</expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name><name>cb</name>.<name>txn_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>txn_dir</name> = <call><name>svn_path_join_many</name><argument_list>(<argument><expr><name>pool</name></expr></argument>,
                               <argument><expr><name><name>fs</name>-&gt;<name>path</name></name></expr></argument>,
                               <argument><expr><name>PATH_TXNS_DIR</name></expr></argument>,
                               <argument><expr><call><name>apr_pstrcat</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>*<name>id_p</name></expr></argument>, <argument><expr><name>PATH_EXT_TXN</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>,
                               <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_dir_make</name><argument_list>(<argument><expr><name>txn_dir</name></expr></argument>, <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Create a unique directory for a transaction in FS based on revision
   REV.  Return the ID for this transaction in *ID_P.  This
   implementation is used in svn 1.4 and earlier repositories and is
   kept in 1.5 and greater to support the --pre-1.4-compatible and
   --pre-1.5-compatible repository creation options.  Reused
   transaction IDs are possible with this implementation. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>create_txn_dir_pre_1_5</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>id_p</name></decl></param>, <param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>, <param><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl></param>,
                       <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>unique_path</name></decl>, *<decl><type ref="prev"/><name>prefix</name></decl>;</decl_stmt>

  <comment type="block">/* Try to create directories named "&lt;txndir&gt;/&lt;rev&gt;-&lt;uniqueifier&gt;.txn". */</comment>
  <expr_stmt><expr><name>prefix</name> = <call><name>svn_path_join_many</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>fs</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>PATH_TXNS_DIR</name></expr></argument>,
                              <argument><expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%ld"</expr></argument>, <argument><expr><name>rev</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>subpool</name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for (<init><expr><name>i</name> = 1</expr>;</init> <condition><expr><name>i</name> &lt;= 99999</expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>unique_path</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>, <argument><expr>"%s-%u" <name>PATH_EXT_TXN</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>err</name> = <call><name>svn_io_dir_make</name><argument_list>(<argument><expr><name>unique_path</name></expr></argument>, <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr>! <name>err</name></expr>)</condition><then>
        <block>{
          <comment type="block">/* We succeeded.  Return the basename minus the ".txn" extension. */</comment>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name> <init>= <expr><call><name>svn_path_basename</name><argument_list>(<argument><expr><name>unique_path</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
          <expr_stmt><expr>*<name>id_p</name> = <call><name>apr_pstrndup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>name</name></expr></argument>,
                               <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call> - <call><name>strlen</name><argument_list>(<argument><expr><name>PATH_EXT_TXN</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
        }</block></then></if>
      <if>if <condition>(<expr>! <call><name>APR_STATUS_IS_EEXIST</name><argument_list>(<argument><expr><name><name>err</name>-&gt;<name>apr_err</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <return>return <expr><name>err</name></expr>;</return></then></if>
      <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

  <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_IO_UNIQUE_NAMES_EXHAUSTED</name></expr></argument>,
                           <argument><expr><name>NULL</name></expr></argument>,
                           <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Unable to create transaction directory "
                             "in '%s' for revision %ld"</expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><name><name>fs</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>rev</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__create_txn</name><parameter_list>(<param><decl><type><name>svn_fs_txn_t</name> **</type><name>txn_p</name></decl></param>,
                      <param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                      <param><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl></param>,
                      <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>fs_fs_data_t</name> *</type><name>ffd</name> <init>= <expr><name><name>fs</name>-&gt;<name>fsap_data</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_txn_t</name> *</type><name>txn</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_id_t</name> *</type><name>root_id</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>txn</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>txn</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Get the txn_id. */</comment>
  <if>if <condition>(<expr><name><name>ffd</name>-&gt;<name>format</name></name> &gt;= <name>SVN_FS_FS__MIN_TXN_CURRENT_FORMAT</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>create_txn_dir</name><argument_list>(<argument><expr>&amp;<name><name>txn</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>create_txn_dir_pre_1_5</name><argument_list>(<argument><expr>&amp;<name><name>txn</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

  <expr_stmt><expr><name><name>txn</name>-&gt;<name>fs</name></name> = <name>fs</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>txn</name>-&gt;<name>base_rev</name></name> = <name>rev</name></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>txn</name>-&gt;<name>vtable</name></name> = &amp;<name>txn_vtable</name></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>txn_p</name> = <name>txn</name></expr>;</expr_stmt>

  <comment type="block">/* Create a new root node for this transaction. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__rev_get_root</name><argument_list>(<argument><expr>&amp;<name>root_id</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>create_new_txn_noderev_from_rev</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>txn</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>root_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Create an empty rev file. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_create</name><argument_list>(<argument><expr><call><name>path_txn_proto_rev</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>txn</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>""</expr></argument>,
                             <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Create an empty rev-lock file. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_create</name><argument_list>(<argument><expr><call><name>path_txn_proto_rev_lock</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>txn</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>""</expr></argument>,
                             <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Create an empty changes file. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_create</name><argument_list>(<argument><expr><call><name>path_txn_changes</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>txn</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>""</expr></argument>,
                             <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Create the next-ids file. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_create</name><argument_list>(<argument><expr><call><name>path_txn_next_ids</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>txn</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>"0 0\n"</expr></argument>,
                             <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Store the property list for transaction TXN_ID in PROPLIST.
   Perform temporary allocations in POOL. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>get_txn_proplist</name><parameter_list>(<param><decl><type><name>apr_hash_t</name> *</type><name>proplist</name></decl></param>,
                 <param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>,
                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>txn_prop_file</name></decl>;</decl_stmt>

  <comment type="block">/* Open the transaction properties file. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_open</name><argument_list>(<argument><expr>&amp;<name>txn_prop_file</name></expr></argument>, <argument><expr><call><name>path_txn_props</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><name>APR_READ</name> | <name>APR_BUFFERED</name></expr></argument>,
                           <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Read in the property list. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_hash_read2</name><argument_list>(<argument><expr><name>proplist</name></expr></argument>,
                         <argument><expr><call><name>svn_stream_from_aprfile</name><argument_list>(<argument><expr><name>txn_prop_file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                         <argument><expr><name>SVN_HASH_TERMINATOR</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_close</name><argument_list>(<argument><expr><name>txn_prop_file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__change_txn_prop</name><parameter_list>(<param><decl><type><name>svn_fs_txn_t</name> *</type><name>txn</name></decl></param>,
                           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>,
                           <param><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>value</name></decl></param>,
                           <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>props</name> <init>= <expr><call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>svn_prop_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_prop_t</name></type> <name>prop</name></decl>;</decl_stmt>
  
  <expr_stmt><expr><name><name>prop</name>.<name>name</name></name> = <name>name</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>prop</name>.<name>value</name></name> = <name>value</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>props</name></expr></argument>, <argument><expr><name>svn_prop_t</name></expr></argument>)</argument_list></call> = <name>prop</name></expr>;</expr_stmt>
  
  <return>return <expr><call><name>svn_fs_fs__change_txn_props</name><argument_list>(<argument><expr><name>txn</name></expr></argument>, <argument><expr><name>props</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__change_txn_props</name><parameter_list>(<param><decl><type><name>svn_fs_txn_t</name> *</type><name>txn</name></decl></param>,
                            <param><decl><type><name>apr_array_header_t</name> *</type><name>props</name></decl></param>,
                            <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>txn_prop_file</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>txn_prop</name> <init>= <expr><call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>err</name> = <call><name>get_txn_proplist</name><argument_list>(<argument><expr><name>txn_prop</name></expr></argument>, <argument><expr><name><name>txn</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name><name>txn</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* Here - and here only - we need to deal with the possibility that the
     transaction property file doesn't yet exist.  The rest of the
     implementation assumes that the file exists, but we're called to set the
     initial transaction properties as the transaction is being created. */</comment>
  <if>if <condition>(<expr><name>err</name> &amp;&amp; (<call><name>APR_STATUS_IS_ENOENT</name><argument_list>(<argument><expr><name><name>err</name>-&gt;<name>apr_err</name></name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
    <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
    <return>return <expr><name>err</name></expr>;</return></then></if></else></if>

  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>props</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <decl_stmt><decl><type><name>svn_prop_t</name> *</type><name>prop</name> <init>= <expr>&amp;<call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>props</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>svn_prop_t</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>txn_prop</name></expr></argument>, <argument><expr><name><name>prop</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name><name>prop</name>-&gt;<name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

  <comment type="block">/* Create a new version of the file and write out the new props. */</comment>
  <comment type="block">/* Open the transaction properties file. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_open</name><argument_list>(<argument><expr>&amp;<name>txn_prop_file</name></expr></argument>,
                           <argument><expr><call><name>path_txn_props</name><argument_list>(<argument><expr><name><name>txn</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name><name>txn</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><name>APR_WRITE</name> | <name>APR_CREATE</name> | <name>APR_TRUNCATE</name>
                           | <name>APR_BUFFERED</name></expr></argument>, <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_hash_write</name><argument_list>(<argument><expr><name>txn_prop</name></expr></argument>, <argument><expr><name>txn_prop_file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_close</name><argument_list>(<argument><expr><name>txn_prop_file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__get_txn</name><parameter_list>(<param><decl><type><name>transaction_t</name> **</type><name>txn_p</name></decl></param>,
                   <param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>,
                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>transaction_t</name> *</type><name>txn</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>node_revision_t</name> *</type><name>noderev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_id_t</name> *</type><name>root_id</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>txn</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>txn</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>txn</name>-&gt;<name>proplist</name></name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_txn_proplist</name><argument_list>(<argument><expr><name><name>txn</name>-&gt;<name>proplist</name></name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>root_id</name> = <call><name>svn_fs_fs__id_txn_create</name><argument_list>(<argument><expr>"0"</expr></argument>, <argument><expr>"0"</expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__get_node_revision</name><argument_list>(<argument><expr>&amp;<name>noderev</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>root_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>txn</name>-&gt;<name>root_id</name></name> = <call><name>svn_fs_fs__id_copy</name><argument_list>(<argument><expr><name><name>noderev</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>txn</name>-&gt;<name>base_id</name></name> = <call><name>svn_fs_fs__id_copy</name><argument_list>(<argument><expr><name><name>noderev</name>-&gt;<name>predecessor_id</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>txn</name>-&gt;<name>copies</name></name> = <name>NULL</name></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>txn_p</name> = <name>txn</name></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Write out the currently available next node_id NODE_ID and copy_id
   COPY_ID for transaction TXN_ID in filesystem FS.  Perform temporary
   allocations in POOL. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>write_next_ids</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
               <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>,
               <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>node_id</name></decl></param>,
               <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copy_id</name></decl></param>,
               <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>file</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>out_stream</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_open</name><argument_list>(<argument><expr>&amp;<name>file</name></expr></argument>, <argument><expr><call><name>path_txn_next_ids</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><name>APR_WRITE</name> | <name>APR_TRUNCATE</name></expr></argument>,
                           <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>out_stream</name> = <call><name>svn_stream_from_aprfile</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_printf</name><argument_list>(<argument><expr><name>out_stream</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"%s %s\n"</expr></argument>, <argument><expr><name>node_id</name></expr></argument>, <argument><expr><name>copy_id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_close</name><argument_list>(<argument><expr><name>out_stream</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_close</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Find out what the next unique node-id and copy-id are for
   transaction TXN_ID in filesystem FS.  Store the results in *NODE_ID
   and *COPY_ID.  Perform all allocations in POOL. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>read_next_ids</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>node_id</name></decl></param>,
              <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>copy_id</name></decl></param>,
              <param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
              <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>,
              <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>file</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><name>MAX_KEY_SIZE</name>*2+3</expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>limit</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>str</name></decl>, *<decl><type ref="prev"/><name>last_str</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_open</name><argument_list>(<argument><expr>&amp;<name>file</name></expr></argument>, <argument><expr><call><name>path_txn_next_ids</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><name>APR_READ</name> | <name>APR_BUFFERED</name></expr></argument>, <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>limit</name> = <sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_read_length_line</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr>&amp;<name>limit</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_close</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Parse this into two separate strings. */</comment>

  <expr_stmt><expr><name>str</name> = <call><name>apr_strtok</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>" "</expr></argument>, <argument><expr>&amp;<name>last_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>! <name>str</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                            <argument><expr><call><name>_</name><argument_list>(<argument><expr>"next-id file corrupt"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr>*<name>node_id</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>str</name> = <call><name>apr_strtok</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>" "</expr></argument>, <argument><expr>&amp;<name>last_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>! <name>str</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                            <argument><expr><call><name>_</name><argument_list>(<argument><expr>"next-id file corrupt"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr>*<name>copy_id</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Get a new and unique to this transaction node-id for transaction
   TXN_ID in filesystem FS.  Store the new node-id in *NODE_ID_P.
   Perform all allocations in POOL. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>get_new_txn_node_id</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>node_id_p</name></decl></param>,
                    <param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>,
                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>cur_node_id</name></decl>, *<decl><type ref="prev"/><name>cur_copy_id</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>node_id</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name></decl>;</decl_stmt>

  <comment type="block">/* First read in the current next-ids file. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>read_next_ids</name><argument_list>(<argument><expr>&amp;<name>cur_node_id</name></expr></argument>, <argument><expr>&amp;<name>cur_copy_id</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>node_id</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>cur_node_id</name></expr></argument>)</argument_list></call> + 2</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>cur_node_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_fs_fs__next_key</name><argument_list>(<argument><expr><name>cur_node_id</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr><name>node_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>write_next_ids</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>node_id</name></expr></argument>, <argument><expr><name>cur_copy_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>node_id_p</name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"_"</expr></argument>, <argument><expr><name>cur_node_id</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__create_node</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> **</type><name>id_p</name></decl></param>,
                       <param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                       <param><decl><type><name>node_revision_t</name> *</type><name>noderev</name></decl></param>,
                       <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copy_id</name></decl></param>,
                       <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>,
                       <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>node_id</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>id</name></decl>;</decl_stmt>

  <comment type="block">/* Get a new node-id for this node. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_new_txn_node_id</name><argument_list>(<argument><expr>&amp;<name>node_id</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>id</name> = <call><name>svn_fs_fs__id_txn_create</name><argument_list>(<argument><expr><name>node_id</name></expr></argument>, <argument><expr><name>copy_id</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>noderev</name>-&gt;<name>id</name></name> = <name>id</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__put_node_revision</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>noderev</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>noderev</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>id_p</name> = <name>id</name></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__purge_txn</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                     <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>,
                     <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>fs_fs_data_t</name> *</type><name>ffd</name> <init>= <expr><name><name>fs</name>-&gt;<name>fsap_data</name></name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Remove the shared transaction object associated with this transaction. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>purge_shared_txn</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* Remove the directory associated with this transaction. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_remove_dir2</name><argument_list>(<argument><expr><call><name>path_txn_dir</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                             <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name><name>ffd</name>-&gt;<name>format</name></name> &gt;= <name>SVN_FS_FS__MIN_PROTOREVS_DIR_FORMAT</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* Delete protorev and its lock, which aren't in the txn
         directory.  It's OK if they don't exist (for example, if this
         is post-commit and the proto-rev has been moved into
         place). */</comment>
      <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name> <init>= <expr><call><name>svn_io_remove_file</name><argument_list>(<argument><expr><call><name>path_txn_proto_rev</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>,
                                                               <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>err</name> &amp;&amp; <call><name>APR_STATUS_IS_ENOENT</name><argument_list>(<argument><expr><name><name>err</name>-&gt;<name>apr_err</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>err</name> = <name>NULL</name></expr>;</expr_stmt>
        }</block></then></if>
      <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
        <return>return <expr><name>err</name></expr>;</return></then></if>

      <expr_stmt><expr><name>err</name> = <call><name>svn_io_remove_file</name><argument_list>(<argument><expr><call><name>path_txn_proto_rev_lock</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, 
                               <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>err</name> &amp;&amp; <call><name>APR_STATUS_IS_ENOENT</name><argument_list>(<argument><expr><name><name>err</name>-&gt;<name>apr_err</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>err</name> = <name>NULL</name></expr>;</expr_stmt>
        }</block></then></if>
      <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
        <return>return <expr><name>err</name></expr>;</return></then></if>
    }</block></then></if>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__abort_txn</name><parameter_list>(<param><decl><type><name>svn_fs_txn_t</name> *</type><name>txn</name></decl></param>,
                     <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>fs_fs_data_t</name> *</type><name>ffd</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs__check_fs</name><argument_list>(<argument><expr><name><name>txn</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Clean out the directory cache. */</comment>
  <expr_stmt><expr><name>ffd</name> = <name><name>txn</name>-&gt;<name>fs</name>-&gt;<name>fsap_data</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr>&amp;<name><name>ffd</name>-&gt;<name>dir_cache_id</name></name></expr></argument>, <argument><expr>0</expr></argument>,
         <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>svn_fs_id_t</name> *</expr></argument>)</argument_list></sizeof> * <name>NUM_DIR_CACHE_ENTRIES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Now, purge the transaction. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR_W</name><argument_list>(<argument><expr><call><name>svn_fs_fs__purge_txn</name><argument_list>(<argument><expr><name><name>txn</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name><name>txn</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
            <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Transaction cleanup failed"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type>
<name>unparse_dir_entry</name><parameter_list>(<param><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>id</name></decl></param>,
                  <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%s %s"</expr></argument>,
                      <argument><expr>(<name>kind</name> == <name>svn_node_file</name>) ? <name>KIND_FILE</name> : <name>KIND_DIR</name></expr></argument>,
                      <argument><expr><call><name>svn_fs_fs__id_unparse</name><argument_list>(<argument><expr><name>id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call>-&gt;<name>data</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Given a hash ENTRIES of dirent structions, return a hash in
   *STR_ENTRIES_P, that has svn_string_t as the values in the format
   specified by the fs_fs directory contents file.  Perform
   allocations in POOL. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>unparse_dir_entries</name><parameter_list>(<param><decl><type><name>apr_hash_t</name> **</type><name>str_entries_p</name></decl></param>,
                    <param><decl><type><name>apr_hash_t</name> *</type><name>entries</name></decl></param>,
                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>

  <expr_stmt><expr>*<name>str_entries_p</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>entries</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>hi</name></expr>;</condition> <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_ssize_t</name></type> <name>klen</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_fs_dirent_t</name> *</type><name>dirent</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>new_val</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr>&amp;<name>klen</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>dirent</name> = <name>val</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>new_val</name> = <call><name>unparse_dir_entry</name><argument_list>(<argument><expr><name><name>dirent</name>-&gt;<name>kind</name></name></expr></argument>, <argument><expr><name><name>dirent</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr>*<name>str_entries_p</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>klen</name></expr></argument>,
                   <argument><expr><call><name>svn_string_create</name><argument_list>(<argument><expr><name>new_val</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__set_entry</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                     <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>,
                     <param><decl><type><name>node_revision_t</name> *</type><name>parent_noderev</name></decl></param>,
                     <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>,
                     <param><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>id</name></decl></param>,
                     <param><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl></param>,
                     <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>representation_t</name> *</type><name>rep</name> <init>= <expr><name><name>parent_noderev</name>-&gt;<name>data_rep</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>filename</name> <init>= <expr><call><name>path_txn_node_children</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>parent_noderev</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>file</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>out</name></decl>;</decl_stmt>

  <if>if <condition>(<expr>!<name>rep</name> || !<name><name>rep</name>-&gt;<name>txn_id</name></name></expr>)</condition><then>
    <block>{
      <block>{
        <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>entries</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

        <comment type="block">/* Before we can modify the directory, we need to dump its old
           contents into a mutable representation file. */</comment>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__rep_contents_dir</name><argument_list>(<argument><expr>&amp;<name>entries</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>parent_noderev</name></expr></argument>,
                                            <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>unparse_dir_entries</name><argument_list>(<argument><expr>&amp;<name>entries</name></expr></argument>, <argument><expr><name>entries</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_open</name><argument_list>(<argument><expr>&amp;<name>file</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>,
                                 <argument><expr><name>APR_WRITE</name> | <name>APR_CREATE</name> | <name>APR_BUFFERED</name></expr></argument>,
                                 <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>out</name> = <call><name>svn_stream_from_aprfile</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_hash_write2</name><argument_list>(<argument><expr><name>entries</name></expr></argument>, <argument><expr><name>out</name></expr></argument>, <argument><expr><name>SVN_HASH_TERMINATOR</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block>

      <comment type="block">/* Mark the node-rev's data rep as mutable. */</comment>
      <expr_stmt><expr><name>rep</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>rep</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>rep</name>-&gt;<name>revision</name></name> = <name>SVN_INVALID_REVNUM</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>rep</name>-&gt;<name>txn_id</name></name> = <name>txn_id</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>parent_noderev</name>-&gt;<name>data_rep</name></name> = <name>rep</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__put_node_revision</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>parent_noderev</name>-&gt;<name>id</name></name></expr></argument>,
                                           <argument><expr><name>parent_noderev</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <comment type="block">/* The directory rep is already mutable, so just open it for append. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_open</name><argument_list>(<argument><expr>&amp;<name>file</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>APR_WRITE</name> | <name>APR_APPEND</name></expr></argument>,
                               <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>out</name> = <call><name>svn_stream_from_aprfile</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

  <comment type="block">/* Append an incremental hash entry for the entry change. */</comment>
  <if>if <condition>(<expr><name>id</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>val</name> <init>= <expr><call><name>unparse_dir_entry</name><argument_list>(<argument><expr><name>kind</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_printf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"K %" <name>APR_SIZE_T_FMT</name> "\n%s\n"
                                "V %" <name>APR_SIZE_T_FMT</name> "\n%s\n"</expr></argument>,
                                <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>,
                                <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_printf</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"D %" <name>APR_SIZE_T_FMT</name> "\n%s\n"</expr></argument>,
                                <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_close</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Write a single change entry, path PATH, change CHANGE, and copyfrom
   string COPYFROM, into the file specified by FILE.  All temporary
   allocations are in POOL. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>write_change_entry</name><parameter_list>(<param><decl><type><name>apr_file_t</name> *</type><name>file</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                   <param><decl><type><name>svn_fs_path_change_t</name> *</type><name>change</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copyfrom</name></decl></param>,
                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>idstr</name></decl>, *<decl><type ref="prev"/><name>buf</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>change_string</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

  <switch>switch <condition>(<expr><name><name>change</name>-&gt;<name>change_kind</name></name></expr>)</condition>
    <block>{
    <case>case <expr><name>svn_fs_path_change_modify</name></expr>:
      <expr_stmt><expr><name>change_string</name> = <name>ACTION_MODIFY</name></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr><name>svn_fs_path_change_add</name></expr>:
      <expr_stmt><expr><name>change_string</name> = <name>ACTION_ADD</name></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr><name>svn_fs_path_change_delete</name></expr>:
      <expr_stmt><expr><name>change_string</name> = <name>ACTION_DELETE</name></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr><name>svn_fs_path_change_replace</name></expr>:
      <expr_stmt><expr><name>change_string</name> = <name>ACTION_REPLACE</name></expr>;</expr_stmt>
      <break>break;</break>
    </case><case>case <expr><name>svn_fs_path_change_reset</name></expr>:
      <expr_stmt><expr><name>change_string</name> = <name>ACTION_RESET</name></expr>;</expr_stmt>
      <break>break;</break>
    </case><default>default:
      <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                              <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Invalid change type"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    </default>}</block></switch>

  <if>if <condition>(<expr><name><name>change</name>-&gt;<name>node_rev_id</name></name></expr>)</condition><then>
    <expr_stmt><expr><name>idstr</name> = <call><name>svn_fs_fs__id_unparse</name><argument_list>(<argument><expr><name><name>change</name>-&gt;<name>node_rev_id</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call>-&gt;<name>data</name></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name>idstr</name> = <name>ACTION_RESET</name></expr>;</expr_stmt></else></if>

  <expr_stmt><expr><name>buf</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%s %s %s %s %s\n"</expr></argument>,
                     <argument><expr><name>idstr</name></expr></argument>, <argument><expr><name>change_string</name></expr></argument>,
                     <argument><expr><name><name>change</name>-&gt;<name>text_mod</name></name> ? <name>FLAG_TRUE</name> : <name>FLAG_FALSE</name></expr></argument>,
                     <argument><expr><name><name>change</name>-&gt;<name>prop_mod</name></name> ? <name>FLAG_TRUE</name> : <name>FLAG_FALSE</name></expr></argument>,
                     <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_write_full</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>copyfrom</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_write_full</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>copyfrom</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>copyfrom</name></expr></argument>)</argument_list></call></expr></argument>,
                                     <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_write_full</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr>"\n"</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__add_change</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                      <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>,
                      <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                      <param><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>id</name></decl></param>,
                      <param><decl><type><name>svn_fs_path_change_kind_t</name></type> <name>change_kind</name></decl></param>,
                      <param><decl><type><name>svn_boolean_t</name></type> <name>text_mod</name></decl></param>,
                      <param><decl><type><name>svn_boolean_t</name></type> <name>prop_mod</name></decl></param>,
                      <param><decl><type><name>svn_revnum_t</name></type> <name>copyfrom_rev</name></decl></param>,
                      <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copyfrom_path</name></decl></param>,
                      <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>file</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copyfrom</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_path_change_t</name> *</type><name>change</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>change</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_open</name><argument_list>(<argument><expr>&amp;<name>file</name></expr></argument>, <argument><expr><call><name>path_txn_changes</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                           <argument><expr><name>APR_APPEND</name> | <name>APR_WRITE</name> | <name>APR_CREATE</name>
                           | <name>APR_BUFFERED</name></expr></argument>, <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>copyfrom_rev</name> != <name>SVN_INVALID_REVNUM</name></expr>)</condition><then>
    <expr_stmt><expr><name>copyfrom</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%ld %s"</expr></argument>, <argument><expr><name>copyfrom_rev</name></expr></argument>, <argument><expr><name>copyfrom_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name>copyfrom</name> = ""</expr>;</expr_stmt></else></if>

  <expr_stmt><expr><name><name>change</name>-&gt;<name>node_rev_id</name></name> = <name>id</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>change</name>-&gt;<name>change_kind</name></name> = <name>change_kind</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>change</name>-&gt;<name>text_mod</name></name> = <name>text_mod</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>change</name>-&gt;<name>prop_mod</name></name> = <name>prop_mod</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>write_change_entry</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>change</name></expr></argument>, <argument><expr><name>copyfrom</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_close</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* This baton is used by the representation writing streams.  It keeps
   track of the checksum information as well as the total size of the
   representation so far. */</comment>
<struct>struct <name>rep_write_baton</name>
<block>{
  <comment type="block">/* The FS we are writing to. */</comment>
  <decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl>;</decl_stmt>

  <comment type="block">/* Actual file to which we are writing. */</comment>
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>rep_stream</name></decl>;</decl_stmt>

  <comment type="block">/* A stream from the delta combiner.  Data written here gets
     deltified, then eventually written to rep_stream. */</comment>
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>delta_stream</name></decl>;</decl_stmt>

  <comment type="block">/* Where is this representation header stored. */</comment>
  <decl_stmt><decl><type><name>apr_off_t</name></type> <name>rep_offset</name></decl>;</decl_stmt>

  <comment type="block">/* Start of the actual data. */</comment>
  <decl_stmt><decl><type><name>apr_off_t</name></type> <name>delta_start</name></decl>;</decl_stmt>

  <comment type="block">/* How many bytes have been written to this rep already. */</comment>
  <decl_stmt><decl><type><name>svn_filesize_t</name></type> <name>rep_size</name></decl>;</decl_stmt>

  <comment type="block">/* The node revision for which we're writing out info. */</comment>
  <decl_stmt><decl><type><name>node_revision_t</name> *</type><name>noderev</name></decl>;</decl_stmt>

  <comment type="block">/* Actual output file. */</comment>
  <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>file</name></decl>;</decl_stmt>
  <comment type="block">/* Lock 'cookie' used to unlock the output file once we've finished
     writing to it. */</comment>
  <decl_stmt><decl><type><name>void</name> *</type><name>lockcookie</name></decl>;</decl_stmt>

  <decl_stmt><decl><type>struct <name>apr_md5_ctx_t</name></type> <name>md5_context</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>parent_pool</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/* Handler for the write method of the representation writable stream.
   BATON is a rep_write_baton, DATA is the data to write, and *LEN is
   the length of this data. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>rep_write_contents</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name></decl></param>,
                   <param><decl><type><name>apr_size_t</name> *</type><name>len</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>rep_write_baton</name> *</type><name>b</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>apr_md5_update</name><argument_list>(<argument><expr>&amp;<name><name>b</name>-&gt;<name>md5_context</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr>*<name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>b</name>-&gt;<name>rep_size</name></name> += *<name>len</name></expr>;</expr_stmt>

  <comment type="block">/* If we are writing a delta, use that stream. */</comment>
  <if>if <condition>(<expr><name><name>b</name>-&gt;<name>delta_stream</name></name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_write</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>delta_stream</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_write</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>rep_stream</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Given a node-revision NODEREV in filesystem FS, return the
   representation in *REP to use as the base for a text representation
   delta.  Perform temporary allocations in *POOL. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>choose_delta_base</name><parameter_list>(<param><decl><type><name>representation_t</name> **</type><name>rep</name></decl></param>,
                  <param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                  <param><decl><type><name>node_revision_t</name> *</type><name>noderev</name></decl></param>,
                  <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>count</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>node_revision_t</name> *</type><name>base</name></decl>;</decl_stmt>

  <comment type="block">/* If we have no predecessors, then use the empty stream as a
     base. */</comment>
  <if>if <condition>(<expr>! <name><name>noderev</name>-&gt;<name>predecessor_count</name></name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr>*<name>rep</name> = <name>NULL</name></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>

  <comment type="block">/* Flip the rightmost '1' bit of the predecessor count to determine
     which file rev (counting from 0) we want to use.  (To see why
     count &amp; (count - 1) unsets the rightmost set bit, think about how
     you decrement a binary number.) */</comment>
  <expr_stmt><expr><name>count</name> = <name><name>noderev</name>-&gt;<name>predecessor_count</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>count</name> = <name>count</name> &amp; (<name>count</name> - 1)</expr>;</expr_stmt>

  <comment type="block">/* Walk back a number of predecessors equal to the difference
     between count and the original predecessor count.  (For example,
     if noderev has ten predecessors and we want the eighth file rev,
     walk back two predecessors.) */</comment>
  <expr_stmt><expr><name>base</name> = <name>noderev</name></expr>;</expr_stmt>
  <while>while <condition>(<expr>(<name>count</name>++) &lt; <name><name>noderev</name>-&gt;<name>predecessor_count</name></name></expr>)</condition>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__get_node_revision</name><argument_list>(<argument><expr>&amp;<name>base</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>,
                                         <argument><expr><name><name>base</name>-&gt;<name>predecessor_id</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></while>

  <expr_stmt><expr>*<name>rep</name> = <name><name>base</name>-&gt;<name>data_rep</name></name></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Get a rep_write_baton and store it in *WB_P for the representation
   indicated by NODEREV in filesystem FS.  Perform allocations in
   POOL.  Only appropriate for file contents, not for props or
   directory contents. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>rep_write_get_baton</name><parameter_list>(<param><decl><type>struct <name>rep_write_baton</name> **</type><name>wb_p</name></decl></param>,
                    <param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                    <param><decl><type><name>node_revision_t</name> *</type><name>noderev</name></decl></param>,
                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>rep_write_baton</name> *</type><name>b</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>file</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>representation_t</name> *</type><name>base_rep</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>source</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>header</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_txdelta_window_handler_t</name></type> <name>wh</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> *</type><name>whb</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>fs_fs_data_t</name> *</type><name>ffd</name> <init>= <expr><name><name>fs</name>-&gt;<name>fsap_data</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>b</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>b</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>apr_md5_init</name><argument_list>(<argument><expr>&amp;(<name><name>b</name>-&gt;<name>md5_context</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>b</name>-&gt;<name>fs</name></name> = <name>fs</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>b</name>-&gt;<name>parent_pool</name></name> = <name>pool</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>b</name>-&gt;<name>pool</name></name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>b</name>-&gt;<name>rep_size</name></name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>b</name>-&gt;<name>noderev</name></name> = <name>noderev</name></expr>;</expr_stmt>

  <comment type="block">/* Open the prototype rev file and seek to its end. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_writable_proto_rev</name><argument_list>(<argument><expr>&amp;<name>file</name></expr></argument>, <argument><expr>&amp;<name><name>b</name>-&gt;<name>lockcookie</name></name></expr></argument>,
                                 <argument><expr><name>fs</name></expr></argument>, <argument><expr><call><name>svn_fs_fs__id_txn_id</name><argument_list>(<argument><expr><name><name>noderev</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr><name><name>b</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>b</name>-&gt;<name>file</name></name> = <name>file</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>b</name>-&gt;<name>rep_stream</name></name> = <call><name>svn_stream_from_aprfile</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_file_offset</name><argument_list>(<argument><expr>&amp;<name><name>b</name>-&gt;<name>rep_offset</name></name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Get the base for this delta. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>choose_delta_base</name><argument_list>(<argument><expr>&amp;<name>base_rep</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>noderev</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>read_representation</name><argument_list>(<argument><expr>&amp;<name>source</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>base_rep</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Write out the rep header. */</comment>
  <if>if <condition>(<expr><name>base_rep</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>header</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>REP_DELTA</name> " %ld %" <name>APR_OFF_T_FMT</name> " %"
                            <name>SVN_FILESIZE_T_FMT</name> "\n"</expr></argument>,
                            <argument><expr><name><name>base_rep</name>-&gt;<name>revision</name></name></expr></argument>, <argument><expr><name><name>base_rep</name>-&gt;<name>offset</name></name></expr></argument>,
                            <argument><expr><name><name>base_rep</name>-&gt;<name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <expr_stmt><expr><name>header</name> = <name>REP_DELTA</name> "\n"</expr>;</expr_stmt>
    }</block></else></if>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_write_full</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>header</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>header</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                 <argument><expr><name><name>b</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Now determine the offset of the actual svndiff data. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_file_offset</name><argument_list>(<argument><expr>&amp;<name><name>b</name>-&gt;<name>delta_start</name></name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Prepare to write the svndiff data. */</comment>
  <if>if <condition>(<expr><name><name>ffd</name>-&gt;<name>format</name></name> &gt;= <name>SVN_FS_FS__MIN_SVNDIFF1_FORMAT</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>svn_txdelta_to_svndiff2</name><argument_list>(<argument><expr>&amp;<name>wh</name></expr></argument>, <argument><expr>&amp;<name>whb</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>rep_stream</name></name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><call><name>svn_txdelta_to_svndiff2</name><argument_list>(<argument><expr>&amp;<name>wh</name></expr></argument>, <argument><expr>&amp;<name>whb</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>rep_stream</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

  <expr_stmt><expr><name><name>b</name>-&gt;<name>delta_stream</name></name> = <call><name>svn_txdelta_target_push</name><argument_list>(<argument><expr><name>wh</name></expr></argument>, <argument><expr><name>whb</name></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>wb_p</name> = <name>b</name></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Close handler for the representation write stream.  BATON is a
   rep_write_baton.  Writes out a new node-rev that correctly
   references the representation we just finished writing. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>rep_write_contents_close</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>rep_write_baton</name> *</type><name>b</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>representation_t</name> *</type><name>rep</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_off_t</name></type> <name>offset</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>rep</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>parent_pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>rep</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>rep</name>-&gt;<name>offset</name></name> = <name><name>b</name>-&gt;<name>rep_offset</name></name></expr>;</expr_stmt>

  <comment type="block">/* Close our delta stream so the last bits of svndiff are written
     out. */</comment>
  <if>if <condition>(<expr><name><name>b</name>-&gt;<name>delta_stream</name></name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_close</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>delta_stream</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* Determine the length of the svndiff data. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_file_offset</name><argument_list>(<argument><expr>&amp;<name>offset</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>file</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>rep</name>-&gt;<name>size</name></name> = <name>offset</name> - <name><name>b</name>-&gt;<name>delta_start</name></name></expr>;</expr_stmt>

  <comment type="block">/* Fill in the rest of the representation field. */</comment>
  <expr_stmt><expr><name><name>rep</name>-&gt;<name>expanded_size</name></name> = <name><name>b</name>-&gt;<name>rep_size</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>rep</name>-&gt;<name>txn_id</name></name> = <call><name>svn_fs_fs__id_txn_id</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>noderev</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>rep</name>-&gt;<name>revision</name></name> = <name>SVN_INVALID_REVNUM</name></expr>;</expr_stmt>

  <comment type="block">/* Finalize the MD5 checksum. */</comment>
  <expr_stmt><expr><call><name>apr_md5_final</name><argument_list>(<argument><expr><name><name>rep</name>-&gt;<name>checksum</name></name></expr></argument>, <argument><expr>&amp;<name><name>b</name>-&gt;<name>md5_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Write out our cosmetic end marker. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_printf</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>rep_stream</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr>"ENDREP\n"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>b</name>-&gt;<name>noderev</name>-&gt;<name>data_rep</name></name> = <name>rep</name></expr>;</expr_stmt>

  <comment type="block">/* Write out the new node-rev information. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__put_node_revision</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>noderev</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>noderev</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                                       <argument><expr><name><name>b</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_close</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>file</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>unlock_proto_rev</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name><name>rep</name>-&gt;<name>txn_id</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>lockcookie</name></name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Store a writable stream in *CONTENTS_P that will receive all data
   written and store it as the file data representation referenced by
   NODEREV in filesystem FS.  Perform temporary allocations in
   POOL.  Only appropriate for file data, not props or directory
   contents. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>set_representation</name><parameter_list>(<param><decl><type><name>svn_stream_t</name> **</type><name>contents_p</name></decl></param>,
                   <param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                   <param><decl><type><name>node_revision_t</name> *</type><name>noderev</name></decl></param>,
                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>rep_write_baton</name> *</type><name>wb</name></decl>;</decl_stmt>

  <if>if <condition>(<expr>! <call><name>svn_fs_fs__id_txn_id</name><argument_list>(<argument><expr><name><name>noderev</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                            <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Attempted to write to non-transaction"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>rep_write_get_baton</name><argument_list>(<argument><expr>&amp;<name>wb</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>noderev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>contents_p</name> = <call><name>svn_stream_create</name><argument_list>(<argument><expr><name>wb</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_stream_set_write</name><argument_list>(<argument><expr>*<name>contents_p</name></expr></argument>, <argument><expr><name>rep_write_contents</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_stream_set_close</name><argument_list>(<argument><expr>*<name>contents_p</name></expr></argument>, <argument><expr><name>rep_write_contents_close</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__set_contents</name><parameter_list>(<param><decl><type><name>svn_stream_t</name> **</type><name>stream</name></decl></param>,
                        <param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                        <param><decl><type><name>node_revision_t</name> *</type><name>noderev</name></decl></param>,
                        <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name><name>noderev</name>-&gt;<name>kind</name></name> != <name>svn_node_file</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_FS_NOT_FILE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                            <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't set text contents of a directory"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <return>return <expr><call><name>set_representation</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>noderev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__create_successor</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> **</type><name>new_id_p</name></decl></param>,
                            <param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                            <param><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>old_idp</name></decl></param>,
                            <param><decl><type><name>node_revision_t</name> *</type><name>new_noderev</name></decl></param>,
                            <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copy_id</name></decl></param>,
                            <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>,
                            <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>id</name></decl>;</decl_stmt>

  <if>if <condition>(<expr>! <name>copy_id</name></expr>)</condition><then>
    <expr_stmt><expr><name>copy_id</name> = <call><name>svn_fs_fs__id_copy_id</name><argument_list>(<argument><expr><name>old_idp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <expr_stmt><expr><name>id</name> = <call><name>svn_fs_fs__id_txn_create</name><argument_list>(<argument><expr><call><name>svn_fs_fs__id_node_id</name><argument_list>(<argument><expr><name>old_idp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>copy_id</name></expr></argument>,
                                <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>new_noderev</name>-&gt;<name>id</name></name> = <name>id</name></expr>;</expr_stmt>

  <if>if <condition>(<expr>! <name><name>new_noderev</name>-&gt;<name>copyroot_path</name></name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name><name>new_noderev</name>-&gt;<name>copyroot_path</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>,
                                               <argument><expr><name><name>new_noderev</name>-&gt;<name>created_path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>new_noderev</name>-&gt;<name>copyroot_rev</name></name> = <call><name>svn_fs_fs__id_rev</name><argument_list>(<argument><expr><name><name>new_noderev</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__put_node_revision</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>new_noderev</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>new_noderev</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                                       <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>new_id_p</name> = <name>id</name></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__set_proplist</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                        <param><decl><type><name>node_revision_t</name> *</type><name>noderev</name></decl></param>,
                        <param><decl><type><name>apr_hash_t</name> *</type><name>proplist</name></decl></param>,
                        <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>filename</name> <init>= <expr><call><name>path_txn_node_props</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>noderev</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>file</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>out</name></decl>;</decl_stmt>

  <comment type="block">/* Dump the property list to the mutable property file. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_open</name><argument_list>(<argument><expr>&amp;<name>file</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>,
                           <argument><expr><name>APR_WRITE</name> | <name>APR_CREATE</name> | <name>APR_TRUNCATE</name>
                           | <name>APR_BUFFERED</name></expr></argument>, <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>out</name> = <call><name>svn_stream_from_aprfile</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_hash_write2</name><argument_list>(<argument><expr><name>proplist</name></expr></argument>, <argument><expr><name>out</name></expr></argument>, <argument><expr><name>SVN_HASH_TERMINATOR</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_close</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Mark the node-rev's prop rep as mutable, if not already done. */</comment>
  <if>if <condition>(<expr>!<name><name>noderev</name>-&gt;<name>prop_rep</name></name> || !<name><name>noderev</name>-&gt;<name>prop_rep</name>-&gt;<name>txn_id</name></name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name><name>noderev</name>-&gt;<name>prop_rep</name></name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name><name>noderev</name>-&gt;<name>prop_rep</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>noderev</name>-&gt;<name>prop_rep</name>-&gt;<name>txn_id</name></name> = <call><name>svn_fs_fs__id_txn_id</name><argument_list>(<argument><expr><name><name>noderev</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__put_node_revision</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>noderev</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>noderev</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Read the 'current' file for filesystem FS and store the next
   available node id in *NODE_ID, and the next available copy id in
   *COPY_ID.  Allocations are performed from POOL. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>get_next_revision_ids</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>node_id</name></decl></param>,
                      <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>copy_id</name></decl></param>,
                      <param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                      <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>char</name> *</type><name>buf</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>str</name></decl>, *<decl><type ref="prev"/><name>last_str</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>read_current</name><argument_list>(<argument><expr><call><name>svn_fs_fs__path_current</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>buf</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>str</name> = <call><name>apr_strtok</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>" "</expr></argument>, <argument><expr>&amp;<name>last_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>! <name>str</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                            <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Corrupt current file"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><name>str</name> = <call><name>apr_strtok</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>" "</expr></argument>, <argument><expr>&amp;<name>last_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>! <name>str</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                            <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Corrupt current file"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr>*<name>node_id</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>str</name> = <call><name>apr_strtok</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>" "</expr></argument>, <argument><expr>&amp;<name>last_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>! <name>str</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                            <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Corrupt current file"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr>*<name>copy_id</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* This baton is used by the stream created for write_hash_rep. */</comment>
<struct>struct <name>write_hash_baton</name>
<block>{
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>stream</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>size</name></decl>;</decl_stmt>

  <decl_stmt><decl><type>struct <name>apr_md5_ctx_t</name></type> <name>md5_context</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/* The handler for the write_hash_rep stream.  BATON is a
   write_hash_baton, DATA has the data to write and *LEN is the number
   of bytes to write. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>write_hash_handler</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name></decl></param>,
                   <param><decl><type><name>apr_size_t</name> *</type><name>len</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>write_hash_baton</name> *</type><name>whb</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>apr_md5_update</name><argument_list>(<argument><expr>&amp;<name><name>whb</name>-&gt;<name>md5_context</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr>*<name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_write</name><argument_list>(<argument><expr><name><name>whb</name>-&gt;<name>stream</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>whb</name>-&gt;<name>size</name></name> += *<name>len</name></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Write out the hash HASH as a text representation to file FILE.  In
   the process, record the total size of the dump in *SIZE, and the
   md5 digest in CHECKSUM.  Perform temporary allocations in POOL. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>write_hash_rep</name><parameter_list>(<param><decl><type><name>svn_filesize_t</name> *</type><name>size</name></decl></param>,
               <param><decl><type><name>unsigned</name> <name>char</name></type> <name><name>checksum</name><index>[<expr><name>APR_MD5_DIGESTSIZE</name></expr>]</index></name></decl></param>,
               <param><decl><type><name>apr_file_t</name> *</type><name>file</name></decl></param>,
               <param><decl><type><name>apr_hash_t</name> *</type><name>hash</name></decl></param>,
               <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>stream</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>write_hash_baton</name> *</type><name>whb</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>whb</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>whb</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>whb</name>-&gt;<name>stream</name></name> = <call><name>svn_stream_from_aprfile</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>whb</name>-&gt;<name>size</name></name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>apr_md5_init</name><argument_list>(<argument><expr>&amp;(<name><name>whb</name>-&gt;<name>md5_context</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>stream</name> = <call><name>svn_stream_create</name><argument_list>(<argument><expr><name>whb</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_stream_set_write</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><name>write_hash_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_printf</name><argument_list>(<argument><expr><name><name>whb</name>-&gt;<name>stream</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"PLAIN\n"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_hash_write2</name><argument_list>(<argument><expr><name>hash</name></expr></argument>, <argument><expr><name>stream</name></expr></argument>, <argument><expr><name>SVN_HASH_TERMINATOR</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Store the results. */</comment>
  <expr_stmt><expr><call><name>apr_md5_final</name><argument_list>(<argument><expr><name>checksum</name></expr></argument>, <argument><expr>&amp;<name><name>whb</name>-&gt;<name>md5_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>size</name> = <name><name>whb</name>-&gt;<name>size</name></name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_printf</name><argument_list>(<argument><expr><name><name>whb</name>-&gt;<name>stream</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr>"ENDREP\n"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Copy a node-revision specified by id ID in fileystem FS from a
   transaction into the permanent rev-file FILE.  Return the offset of
   the new node-revision in *OFFSET.  If this is a directory, all
   children are copied as well.  START_NODE_ID and START_COPY_ID are
   the first available node and copy ids for this filesystem, for older
   FS formats. Temporary allocations are from POOL. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>write_final_rev</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> **</type><name>new_id_p</name></decl></param>,
                <param><decl><type><name>apr_file_t</name> *</type><name>file</name></decl></param>,
                <param><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl></param>,
                <param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>id</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>start_node_id</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>start_copy_id</name></decl></param>,
                <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>node_revision_t</name> *</type><name>noderev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_off_t</name></type> <name>my_offset</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>my_node_id_buf</name><index>[<expr><name>MAX_KEY_SIZE</name> + 2</expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>my_copy_id_buf</name><index>[<expr><name>MAX_KEY_SIZE</name> + 2</expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>new_id</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>node_id</name></decl>, *<decl><type ref="prev"/><name>copy_id</name></decl>, *<decl><type ref="prev"/><name>my_node_id</name></decl>, *<decl><type ref="prev"/><name>my_copy_id</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>fs_fs_data_t</name> *</type><name>ffd</name> <init>= <expr><name><name>fs</name>-&gt;<name>fsap_data</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr>*<name>new_id_p</name> = <name>NULL</name></expr>;</expr_stmt>

  <comment type="block">/* Check to see if this is a transaction node. */</comment>
  <if>if <condition>(<expr>! <call><name>svn_fs_fs__id_txn_id</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__get_node_revision</name><argument_list>(<argument><expr>&amp;<name>noderev</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name><name>noderev</name>-&gt;<name>kind</name></name> == <name>svn_node_dir</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>entries</name></decl>, *<decl><type ref="prev"/><name>str_entries</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_fs_dirent_t</name> *</type><name>dirent</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>

      <comment type="block">/* This is a directory.  Write out all the children first. */</comment>
      <expr_stmt><expr><name>subpool</name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__rep_contents_dir</name><argument_list>(<argument><expr>&amp;<name>entries</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>noderev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>entries</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>hi</name></expr>;</condition> <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
        <block>{
          <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>dirent</name> = <name>val</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>write_final_rev</name><argument_list>(<argument><expr>&amp;<name>new_id</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name><name>dirent</name>-&gt;<name>id</name></name></expr></argument>,
                                  <argument><expr><name>start_node_id</name></expr></argument>, <argument><expr><name>start_copy_id</name></expr></argument>,
                                  <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>new_id</name> &amp;&amp; (<call><name>svn_fs_fs__id_rev</name><argument_list>(<argument><expr><name>new_id</name></expr></argument>)</argument_list></call> == <name>rev</name>)</expr>)</condition><then>
            <expr_stmt><expr><name><name>dirent</name>-&gt;<name>id</name></name> = <call><name>svn_fs_fs__id_copy</name><argument_list>(<argument><expr><name>new_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        }</block></for>
      <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr><name><name>noderev</name>-&gt;<name>data_rep</name></name> &amp;&amp; <name><name>noderev</name>-&gt;<name>data_rep</name>-&gt;<name>txn_id</name></name></expr>)</condition><then>
        <block>{
          <comment type="block">/* Write out the contents of this directory as a text rep. */</comment>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>unparse_dir_entries</name><argument_list>(<argument><expr>&amp;<name>str_entries</name></expr></argument>, <argument><expr><name>entries</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <expr_stmt><expr><name><name>noderev</name>-&gt;<name>data_rep</name>-&gt;<name>txn_id</name></name> = <name>NULL</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>noderev</name>-&gt;<name>data_rep</name>-&gt;<name>revision</name></name> = <name>rev</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_file_offset</name><argument_list>(<argument><expr>&amp;<name><name>noderev</name>-&gt;<name>data_rep</name>-&gt;<name>offset</name></name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>write_hash_rep</name><argument_list>(<argument><expr>&amp;<name><name>noderev</name>-&gt;<name>data_rep</name>-&gt;<name>size</name></name></expr></argument>,
                                 <argument><expr><name><name>noderev</name>-&gt;<name>data_rep</name>-&gt;<name>checksum</name></name></expr></argument>, <argument><expr><name>file</name></expr></argument>,
                                 <argument><expr><name>str_entries</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>noderev</name>-&gt;<name>data_rep</name>-&gt;<name>expanded_size</name></name> = <name><name>noderev</name>-&gt;<name>data_rep</name>-&gt;<name>size</name></name></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then>
  <else>else
    <block>{
      <comment type="block">/* This is a file.  We should make sure the data rep, if it
         exists in a "this" state, gets rewritten to our new revision
         num. */</comment>

      <if>if <condition>(<expr><name><name>noderev</name>-&gt;<name>data_rep</name></name> &amp;&amp; <name><name>noderev</name>-&gt;<name>data_rep</name>-&gt;<name>txn_id</name></name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name><name>noderev</name>-&gt;<name>data_rep</name>-&gt;<name>txn_id</name></name> = <name>NULL</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>noderev</name>-&gt;<name>data_rep</name>-&gt;<name>revision</name></name> = <name>rev</name></expr>;</expr_stmt>
        }</block></then></if>
    }</block></else></if>

  <comment type="block">/* Fix up the property reps. */</comment>
  <if>if <condition>(<expr><name><name>noderev</name>-&gt;<name>prop_rep</name></name> &amp;&amp; <name><name>noderev</name>-&gt;<name>prop_rep</name>-&gt;<name>txn_id</name></name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>proplist</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__get_proplist</name><argument_list>(<argument><expr>&amp;<name>proplist</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>noderev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_file_offset</name><argument_list>(<argument><expr>&amp;<name><name>noderev</name>-&gt;<name>prop_rep</name>-&gt;<name>offset</name></name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>write_hash_rep</name><argument_list>(<argument><expr>&amp;<name><name>noderev</name>-&gt;<name>prop_rep</name>-&gt;<name>size</name></name></expr></argument>,
                             <argument><expr><name><name>noderev</name>-&gt;<name>prop_rep</name>-&gt;<name>checksum</name></name></expr></argument>, <argument><expr><name>file</name></expr></argument>,
                             <argument><expr><name>proplist</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name><name>noderev</name>-&gt;<name>prop_rep</name>-&gt;<name>txn_id</name></name> = <name>NULL</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>noderev</name>-&gt;<name>prop_rep</name>-&gt;<name>revision</name></name> = <name>rev</name></expr>;</expr_stmt>
    }</block></then></if>


  <comment type="block">/* Convert our temporary ID into a permanent revision one. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_file_offset</name><argument_list>(<argument><expr>&amp;<name>my_offset</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>node_id</name> = <call><name>svn_fs_fs__id_node_id</name><argument_list>(<argument><expr><name><name>noderev</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>*<name>node_id</name> == '_'</expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr><name><name>ffd</name>-&gt;<name>format</name></name> &gt;= <name>SVN_FS_FS__MIN_NO_GLOBAL_IDS_FORMAT</name></expr>)</condition><then>
        <expr_stmt><expr><name>my_node_id</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%s-%ld"</expr></argument>, <argument><expr><name>node_id</name> + 1</expr></argument>, <argument><expr><name>rev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
      <else>else
        <block>{
          <expr_stmt><expr><call><name>svn_fs_fs__add_keys</name><argument_list>(<argument><expr><name>start_node_id</name></expr></argument>, <argument><expr><name>node_id</name> + 1</expr></argument>, <argument><expr><name>my_node_id_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>my_node_id</name> = <name>my_node_id_buf</name></expr>;</expr_stmt>
        }</block></else></if>
    }</block></then>
  <else>else
    <expr_stmt><expr><name>my_node_id</name> = <name>node_id</name></expr>;</expr_stmt></else></if>

  <expr_stmt><expr><name>copy_id</name> = <call><name>svn_fs_fs__id_copy_id</name><argument_list>(<argument><expr><name><name>noderev</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>*<name>copy_id</name> == '_'</expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr><name><name>ffd</name>-&gt;<name>format</name></name> &gt;= <name>SVN_FS_FS__MIN_NO_GLOBAL_IDS_FORMAT</name></expr>)</condition><then>
        <expr_stmt><expr><name>my_copy_id</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%s-%ld"</expr></argument>, <argument><expr><name>copy_id</name> + 1</expr></argument>, <argument><expr><name>rev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
      <else>else
        <block>{
          <expr_stmt><expr><call><name>svn_fs_fs__add_keys</name><argument_list>(<argument><expr><name>start_copy_id</name></expr></argument>, <argument><expr><name>copy_id</name> + 1</expr></argument>, <argument><expr><name>my_copy_id_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>my_copy_id</name> = <name>my_copy_id_buf</name></expr>;</expr_stmt>
        }</block></else></if>
    }</block></then>
  <else>else
    <expr_stmt><expr><name>my_copy_id</name> = <name>copy_id</name></expr>;</expr_stmt></else></if>

  <if>if <condition>(<expr><name><name>noderev</name>-&gt;<name>copyroot_rev</name></name> == <name>SVN_INVALID_REVNUM</name></expr>)</condition><then>
    <expr_stmt><expr><name><name>noderev</name>-&gt;<name>copyroot_rev</name></name> = <name>rev</name></expr>;</expr_stmt></then></if>

  <expr_stmt><expr><name>new_id</name> = <call><name>svn_fs_fs__id_rev_create</name><argument_list>(<argument><expr><name>my_node_id</name></expr></argument>, <argument><expr><name>my_copy_id</name></expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name>my_offset</name></expr></argument>,
                                    <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>noderev</name>-&gt;<name>id</name></name> = <name>new_id</name></expr>;</expr_stmt>

  <comment type="block">/* Write out our new node-revision. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>write_noderev_txn</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>noderev</name></expr></argument>,
                            <argument><expr><call><name>svn_fs_fs__fs_supports_mergeinfo</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Return our ID that references the revision file. */</comment>
  <expr_stmt><expr>*<name>new_id_p</name> = <name><name>noderev</name>-&gt;<name>id</name></name></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Write the changed path info from transaction TXN_ID in filesystem
   FS to the permanent rev-file FILE.  *OFFSET_P is set the to offset
   in the file of the beginning of this information.  Perform
   temporary allocations in POOL. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>write_final_changed_path_info</name><parameter_list>(<param><decl><type><name>apr_off_t</name> *</type><name>offset_p</name></decl></param>,
                              <param><decl><type><name>apr_file_t</name> *</type><name>file</name></decl></param>,
                              <param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                              <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>,
                              <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copyfrom</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>changed_paths</name></decl>, *<decl><type ref="prev"/><name>copyfrom_cache</name> <init>= <expr><call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_off_t</name></type> <name>offset</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>iterpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_file_offset</name><argument_list>(<argument><expr>&amp;<name>offset</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__txn_changes_fetch</name><argument_list>(<argument><expr>&amp;<name>changed_paths</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>,
                                       <argument><expr><name>copyfrom_cache</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Iterate through the changed paths one at a time, and convert the
     temporary node-id into a permanent one for each change entry. */</comment>
  <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>changed_paths</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>hi</name></expr>;</condition> <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
    <block>{
      <decl_stmt><decl><type><name>node_revision_t</name> *</type><name>noderev</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>id</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_fs_path_change_t</name> *</type><name>change</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>change</name> = <name>val</name></expr>;</expr_stmt>

      <expr_stmt><expr><name>id</name> = <name><name>change</name>-&gt;<name>node_rev_id</name></name></expr>;</expr_stmt>

      <comment type="block">/* If this was a delete of a mutable node, then it is OK to
         leave the change entry pointing to the non-existent temporary
         node, since it will never be used. */</comment>
      <if>if <condition>(<expr>(<name><name>change</name>-&gt;<name>change_kind</name></name> != <name>svn_fs_path_change_delete</name>) &amp;&amp;
          (! <call><name>svn_fs_fs__id_txn_id</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__get_node_revision</name><argument_list>(<argument><expr>&amp;<name>noderev</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* noderev has the permanent node-id at this point, so we just
             substitute it for the temporary one. */</comment>
          <expr_stmt><expr><name><name>change</name>-&gt;<name>node_rev_id</name></name> = <name><name>noderev</name>-&gt;<name>id</name></name></expr>;</expr_stmt>
        }</block></then></if>

      <comment type="block">/* Find the cached copyfrom information. */</comment>
      <expr_stmt><expr><name>copyfrom</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>copyfrom_cache</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Write out the new entry into the final rev-file. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>write_change_entry</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>change</name></expr></argument>, <argument><expr><name>copyfrom</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>offset_p</name> = <name>offset</name></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__dup_perms</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>filename</name></decl></param>,
                     <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>perms_reference</name></decl></param>,
                     <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
  <decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_finfo_t</name></type> <name>finfo</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>filename_apr</name></decl>, *<decl><type ref="prev"/><name>perms_reference_apr</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_path_cstring_from_utf8</name><argument_list>(<argument><expr>&amp;<name>filename_apr</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_path_cstring_from_utf8</name><argument_list>(<argument><expr>&amp;<name>perms_reference_apr</name></expr></argument>, <argument><expr><name>perms_reference</name></expr></argument>,
                                     <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>status</name> = <call><name>apr_stat</name><argument_list>(<argument><expr>&amp;<name>finfo</name></expr></argument>, <argument><expr><name>perms_reference_apr</name></expr></argument>, <argument><expr><name>APR_FINFO_PROT</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>status</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_wrap_apr</name><argument_list>(<argument><expr><name>status</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't stat '%s'"</expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>perms_reference</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
  <expr_stmt><expr><name>status</name> = <call><name>apr_file_perms_set</name><argument_list>(<argument><expr><name>filename_apr</name></expr></argument>, <argument><expr><name><name>finfo</name>.<name>protection</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>status</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_wrap_apr</name><argument_list>(<argument><expr><name>status</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't chmod '%s'"</expr></argument>)</argument_list></call></expr></argument>,
                              <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__move_into_place</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>old_filename</name></decl></param>,
                           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>new_filename</name></decl></param>,
                           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>perms_reference</name></decl></param>,
                           <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dup_perms</name><argument_list>(<argument><expr><name>old_filename</name></expr></argument>, <argument><expr><name>perms_reference</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Move the file into place. */</comment>
  <expr_stmt><expr><name>err</name> = <call><name>svn_io_file_rename</name><argument_list>(<argument><expr><name>old_filename</name></expr></argument>, <argument><expr><name>new_filename</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>err</name> &amp;&amp; <call><name>APR_STATUS_IS_EXDEV</name><argument_list>(<argument><expr><name><name>err</name>-&gt;<name>apr_err</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>file</name></decl>;</decl_stmt>

      <comment type="block">/* Can't rename across devices; fall back to copying. */</comment>
      <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>err</name> = <name>SVN_NO_ERROR</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_copy_file</name><argument_list>(<argument><expr><name>old_filename</name></expr></argument>, <argument><expr><name>new_filename</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Flush the target of the copy to disk. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_open</name><argument_list>(<argument><expr>&amp;<name>file</name></expr></argument>, <argument><expr><name>new_filename</name></expr></argument>, <argument><expr><name>APR_READ</name></expr></argument>,
                               <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_flush_to_disk</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_close</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>
  <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
    <return>return <expr><name>err</name></expr>;</return></then></if>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__linux__</name></cpp:ifdef>
  <block>{
    <comment type="block">/* Linux has the unusual feature that fsync() on a file is not
       enough to ensure that a file's directory entries have been
       flushed to disk; you have to fsync the directory as well.
       On other operating systems, we'd only be asking for trouble
       by trying to open and fsync a directory. */</comment>
    <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dirname</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>file</name></decl>;</decl_stmt>

    <expr_stmt><expr><name>dirname</name> = <call><name>svn_path_dirname</name><argument_list>(<argument><expr><name>new_filename</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_open</name><argument_list>(<argument><expr>&amp;<name>file</name></expr></argument>, <argument><expr><name>dirname</name></expr></argument>, <argument><expr><name>APR_READ</name></expr></argument>, <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>,
                             <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_flush_to_disk</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_close</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Atomically update the current file to hold the specifed REV,
   NEXT_NODE_ID, and NEXT_COPY_ID.  (The two next-ID parameters are
   ignored and may be NULL if the FS format does not use them.)
   Perform temporary allocations in POOL. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>write_current</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>, <param><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>next_node_id</name></decl></param>,
              <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>next_copy_id</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>char</name> *</type><name>buf</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>tmp_name</name></decl>, *<decl><type ref="prev"/><name>name</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>file</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>fs_fs_data_t</name> *</type><name>ffd</name> <init>= <expr><name><name>fs</name>-&gt;<name>fsap_data</name></name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Now we can just write out this line. */</comment>
  <if>if <condition>(<expr><name><name>ffd</name>-&gt;<name>format</name></name> &gt;= <name>SVN_FS_FS__MIN_NO_GLOBAL_IDS_FORMAT</name></expr>)</condition><then>
    <expr_stmt><expr><name>buf</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%ld\n"</expr></argument>, <argument><expr><name>rev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name>buf</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%ld %s %s\n"</expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name>next_node_id</name></expr></argument>, <argument><expr><name>next_copy_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

  <expr_stmt><expr><name>name</name> = <call><name>svn_fs_fs__path_current</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_open_unique_file2</name><argument_list>(<argument><expr>&amp;<name>file</name></expr></argument>, <argument><expr>&amp;<name>tmp_name</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr>".tmp"</expr></argument>,
                                   <argument><expr><name>svn_io_file_del_none</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_write_full</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_flush_to_disk</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_close</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__move_into_place</name><argument_list>(<argument><expr><name>tmp_name</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Update the current file to hold the correct next node and copy_ids
   from transaction TXN_ID in filesystem FS.  The current revision is
   set to REV.  Perform temporary allocations in POOL. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>write_final_current</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>,
                    <param><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>start_node_id</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>start_copy_id</name></decl></param>,
                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_node_id</name></decl>, *<decl><type ref="prev"/><name>txn_copy_id</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>new_node_id</name><index>[<expr><name>MAX_KEY_SIZE</name> + 2</expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>new_copy_id</name><index>[<expr><name>MAX_KEY_SIZE</name> + 2</expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>fs_fs_data_t</name> *</type><name>ffd</name> <init>= <expr><name><name>fs</name>-&gt;<name>fsap_data</name></name></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name><name>ffd</name>-&gt;<name>format</name></name> &gt;= <name>SVN_FS_FS__MIN_NO_GLOBAL_IDS_FORMAT</name></expr>)</condition><then>
    <return>return <expr><call><name>write_current</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* To find the next available ids, we add the id that used to be in
     the current file, to the next ids from the transaction file. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>read_next_ids</name><argument_list>(<argument><expr>&amp;<name>txn_node_id</name></expr></argument>, <argument><expr>&amp;<name>txn_copy_id</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>svn_fs_fs__add_keys</name><argument_list>(<argument><expr><name>start_node_id</name></expr></argument>, <argument><expr><name>txn_node_id</name></expr></argument>, <argument><expr><name>new_node_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_fs_fs__add_keys</name><argument_list>(<argument><expr><name>start_copy_id</name></expr></argument>, <argument><expr><name>txn_copy_id</name></expr></argument>, <argument><expr><name>new_copy_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><call><name>write_current</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name>new_node_id</name></expr></argument>, <argument><expr><name>new_copy_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Verify that the user registed with FS has all the locks necessary to
   permit all the changes associate with TXN_NAME.
   The FS write lock is assumed to be held by the caller. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>verify_locks</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
             <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_name</name></decl></param>,
             <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>changes</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>changed_paths</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>last_recursed</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <comment type="block">/* Fetch the changes for this transaction. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__txn_changes_fetch</name><argument_list>(<argument><expr>&amp;<name>changes</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_name</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Make an array of the changed paths, and sort them depth-first-ily.  */</comment>
  <expr_stmt><expr><name>changed_paths</name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><call><name>apr_hash_count</name><argument_list>(<argument><expr><name>changes</name></expr></argument>)</argument_list></call> + 1</expr></argument>,
                                 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>const <name>char</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>changes</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>hi</name></expr>;</condition> <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>changed_paths</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call> = <name>key</name></expr>;</expr_stmt>
    }</block></for>
  <expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name><name>changed_paths</name>-&gt;<name>elts</name></name></expr></argument>, <argument><expr><name><name>changed_paths</name>-&gt;<name>nelts</name></name></expr></argument>,
        <argument><expr><name><name>changed_paths</name>-&gt;<name>elt_size</name></name></expr></argument>, <argument><expr><name>svn_sort_compare_paths</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Now, traverse the array of changed paths, verify locks.  Note
     that if we need to do a recursive verification a path, we'll skip
     over children of that path when we get to them. */</comment>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>changed_paths</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_fs_path_change_t</name> *</type><name>change</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>recurse</name> <init>= <expr><name>TRUE</name></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>path</name> = <call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>changed_paths</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* If this path has already been verified as part of a recursive
         check of one of its parents, no need to do it again.  */</comment>
      <if>if <condition>(<expr><name>last_recursed</name>
          &amp;&amp; <call><name>svn_path_is_child</name><argument_list>(<argument><expr><name><name>last_recursed</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <continue>continue;</continue></then></if>

      <comment type="block">/* Fetch the change associated with our path.  */</comment>
      <expr_stmt><expr><name>change</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>changes</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* What does it mean to succeed at lock verification for a given
         path?  For an existing file or directory getting modified
         (text, props), it means we hold the lock on the file or
         directory.  For paths being added or removed, we need to hold
         the locks for that path and any children of that path.

         WHEW!  We have no reliable way to determine the node kind
         of deleted items, but fortunately we are going to do a
         recursive check on deleted paths regardless of their kind.  */</comment>
      <if>if <condition>(<expr><name><name>change</name>-&gt;<name>change_kind</name></name> == <name>svn_fs_path_change_modify</name></expr>)</condition><then>
        <expr_stmt><expr><name>recurse</name> = <name>FALSE</name></expr>;</expr_stmt></then></if>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__allow_locked_operation</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>recurse</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>,
                                                <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* If we just did a recursive check, remember the path we
         checked (so children can be skipped).  */</comment>
      <if>if <condition>(<expr><name>recurse</name></expr>)</condition><then>
        <block>{
          <if>if <condition>(<expr>! <name>last_recursed</name></expr>)</condition><then>
            <expr_stmt><expr><name>last_recursed</name> = <call><name>svn_stringbuf_create</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
          <else>else
            <expr_stmt><expr><call><name>svn_stringbuf_set</name><argument_list>(<argument><expr><name>last_recursed</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
        }</block></then></if>
    }</block></for>
  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Baton used for commit_body below. */</comment>
<struct>struct <name>commit_baton</name> <block>{
  <decl_stmt><decl><type><name>svn_revnum_t</name> *</type><name>new_rev_p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_txn_t</name> *</type><name>txn</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/* The work-horse for svn_fs_fs__commit, called with the FS write lock.
   This implements the svn_fs_fs__with_write_lock() 'body' callback
   type.  BATON is a 'struct commit_baton *'. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>commit_body</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>commit_baton</name> *</type><name>cb</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>fs_fs_data_t</name> *</type><name>ffd</name> <init>= <expr><name><name>cb</name>-&gt;<name>fs</name>-&gt;<name>fsap_data</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>old_rev_filename</name></decl>, *<decl><type ref="prev"/><name>rev_filename</name></decl>, *<decl><type ref="prev"/><name>proto_filename</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>revprop_filename</name></decl>, *<decl><type ref="prev"/><name>final_revprop</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>root_id</name></decl>, *<decl><type ref="prev"/><name>new_root_id</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>start_node_id</name> <init>= <expr><name>NULL</name></expr></init>, *<name>start_copy_id</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>old_rev</name></decl>, <decl><type ref="prev"/><name>new_rev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>proto_file</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> *</type><name>proto_file_lockcookie</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_off_t</name></type> <name>changed_path_offset</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>buf</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>txnprops</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_string_t</name></type> <name>date</name></decl>;</decl_stmt>

  <comment type="block">/* Get the current youngest revision. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__youngest_rev</name><argument_list>(<argument><expr>&amp;<name>old_rev</name></expr></argument>, <argument><expr><name><name>cb</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check to make sure this transaction is based off the most recent
     revision. */</comment>
  <if>if <condition>(<expr><name><name>cb</name>-&gt;<name>txn</name>-&gt;<name>base_rev</name></name> != <name>old_rev</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_FS_TXN_OUT_OF_DATE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                            <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Transaction out of date"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Locks may have been added (or stolen) between the calling of
     previous svn_fs.h functions and svn_fs_commit_txn(), so we need
     to re-examine every changed-path in the txn and re-verify all
     discovered locks. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>verify_locks</name><argument_list>(<argument><expr><name><name>cb</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name><name>cb</name>-&gt;<name>txn</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Get the next node_id and copy_id to use. */</comment>
  <if>if <condition>(<expr><name><name>ffd</name>-&gt;<name>format</name></name> &lt; <name>SVN_FS_FS__MIN_NO_GLOBAL_IDS_FORMAT</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_next_revision_ids</name><argument_list>(<argument><expr>&amp;<name>start_node_id</name></expr></argument>, <argument><expr>&amp;<name>start_copy_id</name></expr></argument>, <argument><expr><name><name>cb</name>-&gt;<name>fs</name></name></expr></argument>,
                                  <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* We are going to be one better than this puny old revision. */</comment>
  <expr_stmt><expr><name>new_rev</name> = <name>old_rev</name> + 1</expr>;</expr_stmt>

  <comment type="block">/* Get a write handle on the proto revision file. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_writable_proto_rev</name><argument_list>(<argument><expr>&amp;<name>proto_file</name></expr></argument>, <argument><expr>&amp;<name>proto_file_lockcookie</name></expr></argument>,
                                 <argument><expr><name><name>cb</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name><name>cb</name>-&gt;<name>txn</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Write out all the node-revisions and directory contents. */</comment>
  <expr_stmt><expr><name>root_id</name> = <call><name>svn_fs_fs__id_txn_create</name><argument_list>(<argument><expr>"0"</expr></argument>, <argument><expr>"0"</expr></argument>, <argument><expr><name><name>cb</name>-&gt;<name>txn</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>write_final_rev</name><argument_list>(<argument><expr>&amp;<name>new_root_id</name></expr></argument>, <argument><expr><name>proto_file</name></expr></argument>, <argument><expr><name>new_rev</name></expr></argument>, <argument><expr><name><name>cb</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>root_id</name></expr></argument>,
                          <argument><expr><name>start_node_id</name></expr></argument>, <argument><expr><name>start_copy_id</name></expr></argument>,
                          <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Write the changed-path information. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>write_final_changed_path_info</name><argument_list>(<argument><expr>&amp;<name>changed_path_offset</name></expr></argument>, <argument><expr><name>proto_file</name></expr></argument>,
                                        <argument><expr><name><name>cb</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name><name>cb</name>-&gt;<name>txn</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Write the final line. */</comment>
  <expr_stmt><expr><name>buf</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"\n%" <name>APR_OFF_T_FMT</name> " %" <name>APR_OFF_T_FMT</name> "\n"</expr></argument>,
                     <argument><expr><call><name>svn_fs_fs__id_offset</name><argument_list>(<argument><expr><name>new_root_id</name></expr></argument>)</argument_list></call></expr></argument>,
                     <argument><expr><name>changed_path_offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_write_full</name><argument_list>(<argument><expr><name>proto_file</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                 <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_flush_to_disk</name><argument_list>(<argument><expr><name>proto_file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_close</name><argument_list>(<argument><expr><name>proto_file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* We don't unlock the prototype revision file immediately to avoid a
     race with another caller writing to the prototype revision file
     before we commit it. */</comment>

  <comment type="block">/* Remove any temporary txn props representing 'flags'. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__txn_proplist</name><argument_list>(<argument><expr>&amp;<name>txnprops</name></expr></argument>, <argument><expr><name><name>cb</name>-&gt;<name>txn</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>txnprops</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>props</name> <init>= <expr><call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>3</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>svn_prop_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_prop_t</name></type> <name>prop</name></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>prop</name>.<name>value</name></name> = <name>NULL</name></expr>;</expr_stmt>

      <if>if <condition>(<expr><call><name>apr_hash_get</name><argument_list>(<argument><expr><name>txnprops</name></expr></argument>, <argument><expr><name>SVN_FS__PROP_TXN_CHECK_OOD</name></expr></argument>,
                       <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name><name>prop</name>.<name>name</name></name> = <name>SVN_FS__PROP_TXN_CHECK_OOD</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>props</name></expr></argument>, <argument><expr><name>svn_prop_t</name></expr></argument>)</argument_list></call> = <name>prop</name></expr>;</expr_stmt>
        }</block></then></if>
      
      <if>if <condition>(<expr><call><name>apr_hash_get</name><argument_list>(<argument><expr><name>txnprops</name></expr></argument>, <argument><expr><name>SVN_FS__PROP_TXN_CHECK_LOCKS</name></expr></argument>,
                       <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name><name>prop</name>.<name>name</name></name> = <name>SVN_FS__PROP_TXN_CHECK_LOCKS</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>props</name></expr></argument>, <argument><expr><name>svn_prop_t</name></expr></argument>)</argument_list></call> = <name>prop</name></expr>;</expr_stmt>
        }</block></then></if>          
      
      <if>if <condition>(<expr>! <call><name>apr_is_empty_array</name><argument_list>(<argument><expr><name>props</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__change_txn_props</name><argument_list>(<argument><expr><name><name>cb</name>-&gt;<name>txn</name></name></expr></argument>, <argument><expr><name>props</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then></if>
  
  <comment type="block">/* Create the shard for the rev and revprop file, if we're sharding and
     this is the first revision of a new shard.  We don't care if this
     fails because the shard already existed for some reason. */</comment>
  <if>if <condition>(<expr><name><name>ffd</name>-&gt;<name>max_files_per_dir</name></name> &amp;&amp; <name>new_rev</name> % <name><name>ffd</name>-&gt;<name>max_files_per_dir</name></name> == 0</expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>err</name> = <call><name>svn_io_dir_make</name><argument_list>(<argument><expr><call><name>path_rev_shard</name><argument_list>(<argument><expr><name><name>cb</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>new_rev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>err</name> &amp;&amp; <call><name>APR_STATUS_IS_EEXIST</name><argument_list>(<argument><expr><name><name>err</name>-&gt;<name>apr_err</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
      <else>else
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
      <expr_stmt><expr><name>err</name> = <call><name>svn_io_dir_make</name><argument_list>(<argument><expr><call><name>path_revprops_shard</name><argument_list>(<argument><expr><name><name>cb</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>new_rev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                            <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>err</name> &amp;&amp; <call><name>APR_STATUS_IS_EEXIST</name><argument_list>(<argument><expr><name><name>err</name>-&gt;<name>apr_err</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
      <else>else
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
    }</block></then></if>

  <comment type="block">/* Move the finished rev file into place. */</comment>
  <expr_stmt><expr><name>old_rev_filename</name> = <call><name>svn_fs_fs__path_rev</name><argument_list>(<argument><expr><name><name>cb</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>old_rev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>rev_filename</name> = <call><name>svn_fs_fs__path_rev</name><argument_list>(<argument><expr><name><name>cb</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>new_rev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>proto_filename</name> = <call><name>path_txn_proto_rev</name><argument_list>(<argument><expr><name><name>cb</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name><name>cb</name>-&gt;<name>txn</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__move_into_place</name><argument_list>(<argument><expr><name>proto_filename</name></expr></argument>, <argument><expr><name>rev_filename</name></expr></argument>,
                                     <argument><expr><name>old_rev_filename</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Now that we've moved the prototype revision file out of the way,
     we can unlock it (since further attempts to write to the file
     will fail as it no longer exists).  We must do this so that we can
     remove the transaction directory later. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>unlock_proto_rev</name><argument_list>(<argument><expr><name><name>cb</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name><name>cb</name>-&gt;<name>txn</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>proto_file_lockcookie</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Update commit time to ensure that svn:date revprops remain ordered. */</comment>
  <expr_stmt><expr><name><name>date</name>.<name>data</name></name> = <call><name>svn_time_to_cstring</name><argument_list>(<argument><expr><call><name>apr_time_now</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>date</name>.<name>len</name></name> = <call><name>strlen</name><argument_list>(<argument><expr><name><name>date</name>.<name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__change_txn_prop</name><argument_list>(<argument><expr><name><name>cb</name>-&gt;<name>txn</name></name></expr></argument>, <argument><expr><name>SVN_PROP_REVISION_DATE</name></expr></argument>,
                                     <argument><expr>&amp;<name>date</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Move the revprops file into place. */</comment>
  <expr_stmt><expr><name>revprop_filename</name> = <call><name>path_txn_props</name><argument_list>(<argument><expr><name><name>cb</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name><name>cb</name>-&gt;<name>txn</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>final_revprop</name> = <call><name>path_revprops</name><argument_list>(<argument><expr><name><name>cb</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>new_rev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__move_into_place</name><argument_list>(<argument><expr><name>revprop_filename</name></expr></argument>, <argument><expr><name>final_revprop</name></expr></argument>,
                                     <argument><expr><name>old_rev_filename</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Update the 'current' file. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>write_final_current</name><argument_list>(<argument><expr><name><name>cb</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name><name>cb</name>-&gt;<name>txn</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>new_rev</name></expr></argument>, <argument><expr><name>start_node_id</name></expr></argument>,
                              <argument><expr><name>start_copy_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>ffd</name>-&gt;<name>youngest_rev_cache</name></name> = <name>new_rev</name></expr>;</expr_stmt>

  <comment type="block">/* Remove this transaction directory. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__purge_txn</name><argument_list>(<argument><expr><name><name>cb</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name><name>cb</name>-&gt;<name>txn</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name><name>cb</name>-&gt;<name>new_rev_p</name></name> = <name>new_rev</name></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__commit</name><parameter_list>(<param><decl><type><name>svn_revnum_t</name> *</type><name>new_rev_p</name></decl></param>,
                  <param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                  <param><decl><type><name>svn_fs_txn_t</name> *</type><name>txn</name></decl></param>,
                  <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>commit_baton</name></type> <name>cb</name></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>cb</name>.<name>new_rev_p</name></name> = <name>new_rev_p</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cb</name>.<name>fs</name></name> = <name>fs</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cb</name>.<name>txn</name></name> = <name>txn</name></expr>;</expr_stmt>
  <return>return <expr><call><name>svn_fs_fs__with_write_lock</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>commit_body</name></expr></argument>, <argument><expr>&amp;<name>cb</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__reserve_copy_id</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>copy_id_p</name></decl></param>,
                           <param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>,
                           <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>cur_node_id</name></decl>, *<decl><type ref="prev"/><name>cur_copy_id</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>copy_id</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name></decl>;</decl_stmt>

  <comment type="block">/* First read in the current next-ids file. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>read_next_ids</name><argument_list>(<argument><expr>&amp;<name>cur_node_id</name></expr></argument>, <argument><expr>&amp;<name>cur_copy_id</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>copy_id</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>cur_copy_id</name></expr></argument>)</argument_list></call> + 2</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>cur_copy_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_fs_fs__next_key</name><argument_list>(<argument><expr><name>cur_copy_id</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr><name>copy_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>write_next_ids</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>cur_node_id</name></expr></argument>, <argument><expr><name>copy_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>copy_id_p</name> = <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"_"</expr></argument>, <argument><expr><name>cur_copy_id</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Write out the zeroth revision for filesystem FS. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>write_revision_zero</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>proplist</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_string_t</name></type> <name>date</name></decl>;</decl_stmt>

  <comment type="block">/* Write out a rev file for revision 0. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_create</name><argument_list>(<argument><expr><call><name>svn_fs_fs__path_rev</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name><name>fs</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr>"PLAIN\nEND\nENDREP\n"
                             "id: 0.0.r0/17\n"
                             "type: dir\n"
                             "count: 0\n"
                             "text: 0 0 4 4 "
                             "2d2977d1c96f487abe4a1e202dd03b4e\n"
                             "cpath: /\n"
                             "\n\n17 107\n"</expr></argument>, <argument><expr><name><name>fs</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Set a date on revision 0. */</comment>
  <expr_stmt><expr><name><name>date</name>.<name>data</name></name> = <call><name>svn_time_to_cstring</name><argument_list>(<argument><expr><call><name>apr_time_now</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name><name>fs</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>date</name>.<name>len</name></name> = <call><name>strlen</name><argument_list>(<argument><expr><name><name>date</name>.<name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>proplist</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name><name>fs</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>proplist</name></expr></argument>, <argument><expr><name>SVN_PROP_REVISION_DATE</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr>&amp;<name>date</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>svn_fs_fs__set_revision_proplist</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>proplist</name></expr></argument>, <argument><expr><name><name>fs</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__create</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                  <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                  <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>format</name> <init>= <expr><name>SVN_FS_FS__FORMAT_NUMBER</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>fs_fs_data_t</name> *</type><name>ffd</name> <init>= <expr><name><name>fs</name>-&gt;<name>fsap_data</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>fs</name>-&gt;<name>path</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* See if we had an explicitly requested pre-1.4- or pre-1.5-compatible.  */</comment>
  <if>if <condition>(<expr><name><name>fs</name>-&gt;<name>config</name></name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr><call><name>apr_hash_get</name><argument_list>(<argument><expr><name><name>fs</name>-&gt;<name>config</name></name></expr></argument>, <argument><expr><name>SVN_FS_CONFIG_PRE_1_4_COMPATIBLE</name></expr></argument>,
                                   <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><name>format</name> = 1</expr>;</expr_stmt></then>
      <else>else <if>if <condition>(<expr><call><name>apr_hash_get</name><argument_list>(<argument><expr><name><name>fs</name>-&gt;<name>config</name></name></expr></argument>, <argument><expr><name>SVN_FS_CONFIG_PRE_1_5_COMPATIBLE</name></expr></argument>,
                                        <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><name>format</name> = 2</expr>;</expr_stmt></then></if></else></if>
    }</block></then></if>
  <expr_stmt><expr><name><name>ffd</name>-&gt;<name>format</name></name> = <name>format</name></expr>;</expr_stmt>

  <comment type="block">/* Override the default linear layout if this is a new-enough format. */</comment>
  <if>if <condition>(<expr><name>format</name> &gt;= <name>SVN_FS_FS__MIN_LAYOUT_FORMAT_OPTION_FORMAT</name></expr>)</condition><then>
    <expr_stmt><expr><name><name>ffd</name>-&gt;<name>max_files_per_dir</name></name> = <name>SVN_FS_FS_DEFAULT_MAX_FILES_PER_DIR</name></expr>;</expr_stmt></then></if>

  <if>if <condition>(<expr><name><name>ffd</name>-&gt;<name>max_files_per_dir</name></name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_make_dir_recursively</name><argument_list>(<argument><expr><call><name>path_rev_shard</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                                          <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_make_dir_recursively</name><argument_list>(<argument><expr><call><name>path_revprops_shard</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                                          <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_make_dir_recursively</name><argument_list>(<argument><expr><call><name>svn_path_join</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>PATH_REVS_DIR</name></expr></argument>,
                                                        <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                                          <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_make_dir_recursively</name><argument_list>(<argument><expr><call><name>svn_path_join</name><argument_list>(<argument><expr><name>path</name></expr></argument>,
                                                        <argument><expr><name>PATH_REVPROPS_DIR</name></expr></argument>,
                                                        <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                                          <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_make_dir_recursively</name><argument_list>(<argument><expr><call><name>svn_path_join</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>PATH_TXNS_DIR</name></expr></argument>,
                                                    <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                                      <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>format</name> &gt;= <name>SVN_FS_FS__MIN_PROTOREVS_DIR_FORMAT</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_make_dir_recursively</name><argument_list>(<argument><expr><call><name>svn_path_join</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>PATH_TXN_PROTOS_DIR</name></expr></argument>,
                                                      <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                                        <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_create</name><argument_list>(<argument><expr><call><name>svn_fs_fs__path_current</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr>(<name>format</name> &gt;= <name>SVN_FS_FS__MIN_NO_GLOBAL_IDS_FORMAT</name>
                              ? "0\n" : "0 1 1\n")</expr></argument>,
                             <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_create</name><argument_list>(<argument><expr><call><name>path_lock</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>""</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__set_uuid</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><call><name>svn_uuid_generate</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>write_revision_zero</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Create the txn-current file if the repository supports
     the transaction sequence file. */</comment>
  <if>if <condition>(<expr><name>format</name> &gt;= <name>SVN_FS_FS__MIN_TXN_CURRENT_FORMAT</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_create</name><argument_list>(<argument><expr><call><name>path_txn_current</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr>"0\n"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_create</name><argument_list>(<argument><expr><call><name>path_txn_current_lock</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                                 <argument><expr>""</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* This filesystem is ready.  Stamp it with a format number. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>write_format</name><argument_list>(<argument><expr><call><name>path_format</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                       <argument><expr><name><name>ffd</name>-&gt;<name>format</name></name></expr></argument>, <argument><expr><name><name>ffd</name>-&gt;<name>max_files_per_dir</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>ffd</name>-&gt;<name>youngest_rev_cache</name></name> = 0</expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Part of the recovery procedure.  Return the largest revision *REV in
   filesystem FS.  Use POOL for temporary allocation. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>recover_get_largest_revision</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>, <param><decl><type><name>svn_revnum_t</name> *</type><name>rev</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* Discovering the largest revision in the filesystem would be an
     expensive operation if we did a readdir() or searched linearly,
     so we'll do a form of binary search.  left is a revision that we
     know exists, right a revision that we know does not exist. */</comment>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>iterpool</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>left</name></decl>, <decl><type ref="prev"/><name>right</name> <init>= <expr>1</expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>iterpool</name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* Keep doubling right, until we find a revision that doesn't exist. */</comment>
  <while>while <condition>(<expr>1</expr>)</condition>
    <block>{
      <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_check_path</name><argument_list>(<argument><expr><call><name>svn_fs_fs__path_rev</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>right</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr>&amp;<name>kind</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr><name>kind</name> == <name>svn_node_none</name></expr>)</condition><then>
        <break>break;</break></then></if>

      <expr_stmt><expr><name>right</name> &lt;&lt;= 1</expr>;</expr_stmt>
    }</block></while>

  <expr_stmt><expr><name>left</name> = <name>right</name> &gt;&gt; 1</expr>;</expr_stmt>

  <comment type="block">/* We know that left exists and right doesn't.  Do a normal bsearch to find
     the last revision. */</comment>
  <while>while <condition>(<expr><name>left</name> + 1 &lt; <name>right</name></expr>)</condition>
    <block>{
      <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>probe</name> <init>= <expr><name>left</name> + ((<name>right</name> - <name>left</name>) / 2)</expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_check_path</name><argument_list>(<argument><expr><call><name>svn_fs_fs__path_rev</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>probe</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr>&amp;<name>kind</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr><name>kind</name> == <name>svn_node_none</name></expr>)</condition><then>
        <expr_stmt><expr><name>right</name> = <name>probe</name></expr>;</expr_stmt></then>
      <else>else
        <expr_stmt><expr><name>left</name> = <name>probe</name></expr>;</expr_stmt></else></if>
    }</block></while>

  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* left is now the largest revision that exists. */</comment>
  <expr_stmt><expr>*<name>rev</name> = <name>left</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* A baton for reading a fixed amount from an open file.  For
   recover_find_max_ids() below. */</comment>
<struct>struct <name>recover_read_from_file_baton</name>
<block>{
  <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>file</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>remaining</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/* A stream read handler used by recover_find_max_ids() below.
   Read and return at most BATON-&gt;REMAINING bytes from the stream,
   returning nothing after that to indicate EOF. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>read_handler_recover</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>char</name> *</type><name>buffer</name></decl></param>, <param><decl><type><name>apr_size_t</name> *</type><name>len</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>recover_read_from_file_baton</name> *</type><name>b</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>bytes_to_read</name> <init>= <expr>*<name>len</name></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name><name>b</name>-&gt;<name>remaining</name></name> == 0</expr>)</condition><then>
    <block>{
      <comment type="block">/* Return a successful read of zero bytes to signal EOF. */</comment>
      <expr_stmt><expr>*<name>len</name> = 0</expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>

  <if>if <condition>(<expr><name>bytes_to_read</name> &gt; <name><name>b</name>-&gt;<name>remaining</name></name></expr>)</condition><then>
    <expr_stmt><expr><name>bytes_to_read</name> = <name><name>b</name>-&gt;<name>remaining</name></name></expr>;</expr_stmt></then></if>
  <expr_stmt><expr><name><name>b</name>-&gt;<name>remaining</name></name> -= <name>bytes_to_read</name></expr>;</expr_stmt>

  <return>return <expr><call><name>svn_io_file_read_full</name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>file</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>bytes_to_read</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>b</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Part of the recovery procedure.  Read the directory noderev at offset
   OFFSET of file REV_FILE (the revision file of revision REV of
   filesystem FS), and set MAX_NODE_ID and MAX_COPY_ID to be the node-id
   and copy-id of that node, if greater than the current value stored
   in either.  Recurse into any child directories that were modified in
   this revision.

   MAX_NODE_ID and MAX_COPY_ID must be arrays of at least MAX_KEY_SIZE.

   Perform temporary allocation in POOL. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>recover_find_max_ids</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>, <param><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl></param>,
                     <param><decl><type><name>apr_file_t</name> *</type><name>rev_file</name></decl></param>, <param><decl><type><name>apr_off_t</name></type> <name>offset</name></decl></param>,
                     <param><decl><type><name>char</name> *</type><name>max_node_id</name></decl></param>, <param><decl><type><name>char</name> *</type><name>max_copy_id</name></decl></param>,
                     <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>headers</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>value</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>node_revision_t</name></type> <name>noderev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>rep_args</name> *</type><name>ra</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>recover_read_from_file_baton</name></type> <name>baton</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>stream</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>entries</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>iterpool</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_seek</name><argument_list>(<argument><expr><name>rev_file</name></expr></argument>, <argument><expr><name>APR_SET</name></expr></argument>, <argument><expr>&amp;<name>offset</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>read_header_block</name><argument_list>(<argument><expr>&amp;<name>headers</name></expr></argument>, <argument><expr><name>rev_file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* We're going to populate a skeletal noderev - just the id and data_rep. */</comment>
  <expr_stmt><expr><name>value</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>headers</name></expr></argument>, <argument><expr><name>HEADER_ID</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>noderev</name>.<name>id</name></name> = <call><name>svn_fs_fs__id_parse</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check that this is a directory.  It should be. */</comment>
  <expr_stmt><expr><name>value</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>headers</name></expr></argument>, <argument><expr><name>HEADER_TYPE</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>value</name> == <name>NULL</name> || <call><name>strcmp</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>KIND_DIR</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                            <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Recovery encountered a non-directory node"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Get the data location.  No data location indicates an empty directory. */</comment>
  <expr_stmt><expr><name>value</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>headers</name></expr></argument>, <argument><expr><name>HEADER_TEXT</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<name>value</name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>read_rep_offsets</name><argument_list>(<argument><expr>&amp;<name><name>noderev</name>.<name>data_rep</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If the directory's data representation wasn't changed in this revision,
     we've already scanned the directory's contents for noderevs, so we don't
     need to again.  This will occur if a property is changed on a directory
     without changing the directory's contents. */</comment>
  <if>if <condition>(<expr><name><name>noderev</name>.<name>data_rep</name>-&gt;<name>revision</name></name> != <name>rev</name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <comment type="block">/* We could use get_dir_contents(), but this is much cheaper.  It does
     rely on directory entries being stored as PLAIN reps, though. */</comment>
  <expr_stmt><expr><name>offset</name> = <name><name>noderev</name>.<name>data_rep</name>-&gt;<name>offset</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_seek</name><argument_list>(<argument><expr><name>rev_file</name></expr></argument>, <argument><expr><name>APR_SET</name></expr></argument>, <argument><expr>&amp;<name>offset</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>read_rep_line</name><argument_list>(<argument><expr>&amp;<name>ra</name></expr></argument>, <argument><expr><name>rev_file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name><name>ra</name>-&gt;<name>is_delta</name></name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                            <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Recovery encountered a deltified directory "
                              "representation"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Now create a stream that's allowed to read only as much data as is
     stored in the representation. */</comment>
  <expr_stmt><expr><name><name>baton</name>.<name>file</name></name> = <name>rev_file</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>baton</name>.<name>pool</name></name> = <name>pool</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>baton</name>.<name>remaining</name></name> = <name><name>noderev</name>.<name>data_rep</name>-&gt;<name>expanded_size</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>stream</name> = <call><name>svn_stream_create</name><argument_list>(<argument><expr>&amp;<name>baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_stream_set_read</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><name>read_handler_recover</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Now read the entries from that stream. */</comment>
  <expr_stmt><expr><name>entries</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_hash_read2</name><argument_list>(<argument><expr><name>entries</name></expr></argument>, <argument><expr><name>stream</name></expr></argument>, <argument><expr><name>SVN_HASH_TERMINATOR</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_close</name><argument_list>(<argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Now check each of the entries in our directory to find new node and
     copy ids, and recurse into new subdirectories. */</comment>
  <expr_stmt><expr><name>iterpool</name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>entries</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>hi</name></expr>;</condition> <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
    <block>{
      <decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> *</type><name>str_val</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> *</type><name>str</name></decl>, *<decl><type ref="prev"/><name>last_str</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_fs_id_t</name> *</type><name>id</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>node_id</name></decl>, *<decl><type ref="prev"/><name>copy_id</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_off_t</name></type> <name>child_dir_offset</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>str_val</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>, <argument><expr>*((<name>char</name> **)<name>val</name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>str</name> = <call><name>apr_strtok</name><argument_list>(<argument><expr><name>str_val</name></expr></argument>, <argument><expr>" "</expr></argument>, <argument><expr>&amp;<name>last_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>str</name> == <name>NULL</name></expr>)</condition><then>
        <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Directory entry corrupt"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

      <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>KIND_FILE</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
        <expr_stmt><expr><name>kind</name> = <name>svn_node_file</name></expr>;</expr_stmt></then>
      <else>else <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>KIND_DIR</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
        <expr_stmt><expr><name>kind</name> = <name>svn_node_dir</name></expr>;</expr_stmt></then>
      <else>else
        <block>{
          <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                  <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Directory entry corrupt"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></else></if></else></if>

      <expr_stmt><expr><name>str</name> = <call><name>apr_strtok</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr>" "</expr></argument>, <argument><expr>&amp;<name>last_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>str</name> == <name>NULL</name></expr>)</condition><then>
        <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Directory entry corrupt"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

      <expr_stmt><expr><name>id</name> = <call><name>svn_fs_fs__id_parse</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr><call><name>svn_fs_fs__id_rev</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call> != <name>rev</name></expr>)</condition><then>
        <block>{
          <comment type="block">/* If the node wasn't modified in this revision, we've already
             checked the node and copy id. */</comment>
          <continue>continue;</continue>
        }</block></then></if>

      <expr_stmt><expr><name>node_id</name> = <call><name>svn_fs_fs__id_node_id</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>copy_id</name> = <call><name>svn_fs_fs__id_copy_id</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr><call><name>svn_fs_fs__key_compare</name><argument_list>(<argument><expr><name>node_id</name></expr></argument>, <argument><expr><name>max_node_id</name></expr></argument>)</argument_list></call> &gt; 0</expr>)</condition><then>
        <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>max_node_id</name></expr></argument>, <argument><expr><name>node_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
      <if>if <condition>(<expr><call><name>svn_fs_fs__key_compare</name><argument_list>(<argument><expr><name>copy_id</name></expr></argument>, <argument><expr><name>max_copy_id</name></expr></argument>)</argument_list></call> &gt; 0</expr>)</condition><then>
        <expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>max_copy_id</name></expr></argument>, <argument><expr><name>copy_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

      <if>if <condition>(<expr><name>kind</name> == <name>svn_node_file</name></expr>)</condition><then>
        <continue>continue;</continue></then></if>

      <expr_stmt><expr><name>child_dir_offset</name> = <call><name>svn_fs_fs__id_offset</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>recover_find_max_ids</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name>rev_file</name></expr></argument>, <argument><expr><name>child_dir_offset</name></expr></argument>,
                                   <argument><expr><name>max_node_id</name></expr></argument>, <argument><expr><name>max_copy_id</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Baton used for recover_body below. */</comment>
<struct>struct <name>recover_baton</name> <block>{
  <decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_cancel_func_t</name></type> <name>cancel_func</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> *</type><name>cancel_baton</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/* The work-horse for svn_fs_fs__recover, called with the FS
   write lock.  This implements the svn_fs_fs__with_write_lock()
   'body' callback type.  BATON is a 'struct recover_baton *'. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>recover_body</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>recover_baton</name> *</type><name>b</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name> <init>= <expr><name><name>b</name>-&gt;<name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>fs_fs_data_t</name> *</type><name>ffd</name> <init>= <expr><name><name>fs</name>-&gt;<name>fsap_data</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>max_rev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>next_node_id_buf</name><index>[<expr><name>MAX_KEY_SIZE</name></expr>]</index></name></decl>, <decl><type ref="prev"/><name><name>next_copy_id_buf</name><index>[<expr><name>MAX_KEY_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>next_node_id</name> <init>= <expr><name>NULL</name></expr></init>, *<name>next_copy_id</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* First, we need to know the largest revision in the filesystem. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>recover_get_largest_revision</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr>&amp;<name>max_rev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* We only need to search for maximum IDs for old FS formats which
     se global ID counters. */</comment>
  <if>if <condition>(<expr><name><name>ffd</name>-&gt;<name>format</name></name> &lt; <name>SVN_FS_FS__MIN_NO_GLOBAL_IDS_FORMAT</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* Next we need to find the maximum node id and copy id in use across the
         filesystem.  Unfortunately, the only way we can get this information
         is to scan all the noderevs of all the revisions and keep track as
         we go along. */</comment>
      <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>iterpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name></type> <name><name>max_node_id</name><index>[<expr><name>MAX_KEY_SIZE</name></expr>]</index></name> <init>= <expr>"0"</expr></init>, <name><name>max_copy_id</name><index>[<expr><name>MAX_KEY_SIZE</name></expr>]</index></name> <init>= <expr>"0"</expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name></decl>;</decl_stmt>

      <for>for (<init><expr><name>rev</name> = 0</expr>;</init> <condition><expr><name>rev</name> &lt;= <name>max_rev</name></expr>;</condition> <incr><expr><name>rev</name>++</expr></incr>)
        <block>{
          <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>rev_file</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>apr_off_t</name></type> <name>root_offset</name></decl>;</decl_stmt>

          <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <if>if <condition>(<expr><name><name>b</name>-&gt;<name>cancel_func</name></name></expr>)</condition><then>
            <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>b</name>-&gt;<name>cancel_func</name></name><argument_list>(<argument><expr><name><name>b</name>-&gt;<name>cancel_baton</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_open</name><argument_list>(<argument><expr>&amp;<name>rev_file</name></expr></argument>,
                                   <argument><expr><call><name>svn_fs_fs__path_rev</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr><name>APR_READ</name> | <name>APR_BUFFERED</name></expr></argument>, <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>,
                                   <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_root_changes_offset</name><argument_list>(<argument><expr>&amp;<name>root_offset</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>rev_file</name></expr></argument>,
                                          <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>recover_find_max_ids</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name>rev_file</name></expr></argument>, <argument><expr><name>root_offset</name></expr></argument>,
                                       <argument><expr><name>max_node_id</name></expr></argument>, <argument><expr><name>max_copy_id</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></for>
      <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Now that we finally have the maximum revision, node-id and copy-id, we
         can bump the two ids to get the next of each. */</comment>
      <expr_stmt><expr><name>len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>max_node_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>svn_fs_fs__next_key</name><argument_list>(<argument><expr><name>max_node_id</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr><name>next_node_id_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>next_node_id</name> = <name>next_node_id_buf</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>max_copy_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>svn_fs_fs__next_key</name><argument_list>(<argument><expr><name>max_copy_id</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>, <argument><expr><name>next_copy_id_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>next_copy_id</name> = <name>next_copy_id_buf</name></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* Now store the discovered youngest revision, and the next IDs if
     relevant, in a new current file. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>write_current</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>max_rev</name></expr></argument>, <argument><expr><name>next_node_id</name></expr></argument>, <argument><expr><name>next_copy_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* This implements the fs_library_vtable_t.recover() API. */</comment>
<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__recover</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                   <param><decl><type><name>svn_cancel_func_t</name></type> <name>cancel_func</name></decl></param>, <param><decl><type><name>void</name> *</type><name>cancel_baton</name></decl></param>,
                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>recover_baton</name></type> <name>b</name></decl>;</decl_stmt>

  <comment type="block">/* We have no way to take out an exclusive lock in FSFS, so we're
     restricted as to the types of recovery we can do.  Luckily,
     we just want to recreate the current file, and we can do that just
     by blocking other writers. */</comment>
  <expr_stmt><expr><name><name>b</name>.<name>fs</name></name> = <name>fs</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>b</name>.<name>cancel_func</name></name> = <name>cancel_func</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>b</name>.<name>cancel_baton</name></name> = <name>cancel_baton</name></expr>;</expr_stmt>
  <return>return <expr><call><name>svn_fs_fs__with_write_lock</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>recover_body</name></expr></argument>, <argument><expr>&amp;<name>b</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__get_uuid</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>uuid_p</name></decl></param>,
                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>fs_fs_data_t</name> *</type><name>ffd</name> <init>= <expr><name><name>fs</name>-&gt;<name>fsap_data</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr>*<name>uuid_p</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>ffd</name>-&gt;<name>uuid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__set_uuid</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>uuid</name></decl></param>,
                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>uuid_file</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>tmp_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>uuid_path</name> <init>= <expr><call><name>path_uuid</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>fs_fs_data_t</name> *</type><name>ffd</name> <init>= <expr><name><name>fs</name>-&gt;<name>fsap_data</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_open_unique_file2</name><argument_list>(<argument><expr>&amp;<name>uuid_file</name></expr></argument>, <argument><expr>&amp;<name>tmp_path</name></expr></argument>, <argument><expr><name>uuid_path</name></expr></argument>,
                                    <argument><expr>".tmp"</expr></argument>, <argument><expr><name>svn_io_file_del_none</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr>! <name>uuid</name></expr>)</condition><then>
    <expr_stmt><expr><name>uuid</name> = <call><name>svn_uuid_generate</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_write_full</name><argument_list>(<argument><expr><name>uuid_file</name></expr></argument>, <argument><expr><name>uuid</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>uuid</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                 <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_write_full</name><argument_list>(<argument><expr><name>uuid_file</name></expr></argument>, <argument><expr>"\n"</expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_close</name><argument_list>(<argument><expr><name>uuid_file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* We use the permissions of the 'current' file, because the 'uuid'
     file does not exist during repository creation. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__move_into_place</name><argument_list>(<argument><expr><name>tmp_path</name></expr></argument>, <argument><expr><name>uuid_path</name></expr></argument>,
                                     <argument><expr><call><name>svn_fs_fs__path_current</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>ffd</name>-&gt;<name>uuid</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>fs</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>uuid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/** Node origin lazy cache. */</comment>

<comment type="block">/* If directory PATH does not exist, create it and give it the same
   permissions as FS-&gt;path.*/</comment>
<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__ensure_dir_exists</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                             <param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                             <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name> <init>= <expr><call><name>svn_io_dir_make</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>err</name> &amp;&amp; <call><name>APR_STATUS_IS_EEXIST</name><argument_list>(<argument><expr><name><name>err</name>-&gt;<name>apr_err</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* We successfully created a new directory.  Dup the permissions
     from FS-&gt;path. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dup_perms</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>fs</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Set *NODE_ORIGINS to a hash mapping 'const char *' node IDs to
   'svn_string_t *' node revision IDs.  Use POOL for allocations. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>get_node_origins_from_file</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                           <param><decl><type><name>apr_hash_t</name> **</type><name>node_origins</name></decl></param>,
                           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>node_origins_file</name></decl></param>,
                           <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>fd</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>stream</name></decl>;</decl_stmt>

  <expr_stmt><expr>*<name>node_origins</name> = <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>err</name> = <call><name>svn_io_file_open</name><argument_list>(<argument><expr>&amp;<name>fd</name></expr></argument>, <argument><expr><name>node_origins_file</name></expr></argument>,
                         <argument><expr><name>APR_READ</name></expr></argument>, <argument><expr><name>APR_OS_DEFAULT</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>err</name> &amp;&amp; <call><name>APR_STATUS_IS_ENOENT</name><argument_list>(<argument><expr><name><name>err</name>-&gt;<name>apr_err</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>stream</name> = <call><name>svn_stream_from_aprfile2</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>node_origins</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_hash_read2</name><argument_list>(<argument><expr>*<name>node_origins</name></expr></argument>, <argument><expr><name>stream</name></expr></argument>, <argument><expr><name>SVN_HASH_TERMINATOR</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>svn_stream_close</name><argument_list>(<argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__get_node_origin</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> **</type><name>origin_id</name></decl></param>,
                           <param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>node_id</name></decl></param>,
                           <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>node_origins</name></decl>;</decl_stmt>

  <expr_stmt><expr>*<name>origin_id</name> = <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_node_origins_from_file</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr>&amp;<name>node_origins</name></expr></argument>, 
                                     <argument><expr><call><name>path_node_origin</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>node_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, 
                                     <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>node_origins</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>origin_id_str</name> <init>=
        <expr><call><name>apr_hash_get</name><argument_list>(<argument><expr><name>node_origins</name></expr></argument>, <argument><expr><name>node_id</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <if>if <condition>(<expr><name>origin_id_str</name></expr>)</condition><then>
        <expr_stmt><expr>*<name>origin_id</name> = <call><name>svn_fs_fs__id_parse</name><argument_list>(<argument><expr><name><name>origin_id_str</name>-&gt;<name>data</name></name></expr></argument>,
                                         <argument><expr><name><name>origin_id_str</name>-&gt;<name>len</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></then></if>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Helper for svn_fs_fs__set_node_origin.  Takes a NODE_ID/NODE_REV_ID
   pair and adds it to the NODE_ORIGINS_PATH file.  */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>set_node_origins_for_file</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>node_origins_path</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>node_id</name></decl></param>,
                          <param><decl><type><name>svn_string_t</name> *</type><name>node_rev_id</name></decl></param>,
                          <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>fd</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path_tmp</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>stream</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>origins_hash</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>old_node_rev_id</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__ensure_dir_exists</name><argument_list>(<argument><expr><call><name>svn_path_join</name><argument_list>(<argument><expr><name><name>fs</name>-&gt;<name>path</name></name></expr></argument>,
                                                     <argument><expr><name>PATH_NODE_ORIGINS_DIR</name></expr></argument>,
                                                     <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                                       <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Read the previously existing origins (if any), and merge our
     update with it. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_node_origins_from_file</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr>&amp;<name>origins_hash</name></expr></argument>,
                                     <argument><expr><name>node_origins_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>! <name>origins_hash</name></expr>)</condition><then>
    <expr_stmt><expr><name>origins_hash</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <expr_stmt><expr><name>old_node_rev_id</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>origins_hash</name></expr></argument>, <argument><expr><name>node_id</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>old_node_rev_id</name> &amp;&amp; !<call><name>svn_string_compare</name><argument_list>(<argument><expr><name>node_rev_id</name></expr></argument>, <argument><expr><name>old_node_rev_id</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Node origin for '%s' exists with a different "
                               "value (%s) than what we were about to store "
                               "(%s)"</expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><name>node_id</name></expr></argument>, <argument><expr><name><name>old_node_rev_id</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>node_rev_id</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>origins_hash</name></expr></argument>, <argument><expr><name>node_id</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>node_rev_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Sure, there's a race condition here.  Two processes could be
     trying to add different cache elements to the same file at the
     same time, and the entries added by the first one to write will
     be lost.  But this is just a cache of reconstructible data, so
     we'll accept this problem in return for not having to deal with
     locking overhead. */</comment>

  <comment type="block">/* Create a temporary file, write out our hash, and close the file. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_open_unique_file2</name><argument_list>(<argument><expr>&amp;<name>fd</name></expr></argument>, <argument><expr>&amp;<name>path_tmp</name></expr></argument>, <argument><expr><name>node_origins_path</name></expr></argument>, <argument><expr>".tmp"</expr></argument>,
                                   <argument><expr><name>svn_io_file_del_none</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>stream</name> = <call><name>svn_stream_from_aprfile2</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_hash_write2</name><argument_list>(<argument><expr><name>origins_hash</name></expr></argument>, <argument><expr><name>stream</name></expr></argument>, <argument><expr><name>SVN_HASH_TERMINATOR</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_close</name><argument_list>(<argument><expr><name>stream</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Rename the temp file as the real destination */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_file_rename</name><argument_list>(<argument><expr><name>path_tmp</name></expr></argument>, <argument><expr><name>node_origins_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__set_node_origin</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>node_id</name></decl></param>,
                           <param><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>node_rev_id</name></decl></param>,
                           <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>filename</name> <init>= <expr><call><name>path_node_origin</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>node_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>err</name> = <call><name>set_node_origins_for_file</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>,
                                  <argument><expr><name>node_id</name></expr></argument>,
                                  <argument><expr><call><name>svn_fs_fs__id_unparse</name><argument_list>(<argument><expr><name>node_rev_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                                  <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>err</name> &amp;&amp; <call><name>APR_STATUS_IS_EACCES</name><argument_list>(<argument><expr><name><name>err</name>-&gt;<name>apr_err</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <comment type="block">/* It's just a cache; stop trying if I can't write. */</comment>
      <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>err</name> = <name>NULL</name></expr>;</expr_stmt>
    }</block></then></if>
  <return>return <expr><name>err</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__list_transactions</name><parameter_list>(<param><decl><type><name>apr_array_header_t</name> **</type><name>names_p</name></decl></param>,
                             <param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                             <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_dir</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>dirents</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>names</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>ext_len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>PATH_EXT_TXN</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>names</name> = <call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>const <name>char</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Get the transactions directory. */</comment>
  <expr_stmt><expr><name>txn_dir</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name><name>fs</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>PATH_TXNS_DIR</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Now find a listing of this directory. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_get_dirents2</name><argument_list>(<argument><expr>&amp;<name>dirents</name></expr></argument>, <argument><expr><name>txn_dir</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Loop through all the entries and return anything that ends with '.txn'. */</comment>
  <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>dirents</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>hi</name></expr>;</condition> <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl>, *<decl><type ref="prev"/><name>id</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_ssize_t</name></type> <name>klen</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr>&amp;<name>klen</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>name</name> = <name>key</name></expr>;</expr_stmt>

      <comment type="block">/* The name must end with ".txn" to be considered a transaction. */</comment>
      <if>if <condition>(<expr>(<name>apr_size_t</name>) <name>klen</name> &lt;= <name>ext_len</name>
          || (<call><name>strcmp</name><argument_list>(<argument><expr><name>name</name> + <name>klen</name> - <name>ext_len</name></expr></argument>, <argument><expr><name>PATH_EXT_TXN</name></expr></argument>)</argument_list></call>) != 0</expr>)</condition><then>
        <continue>continue;</continue></then></if>

      <comment type="block">/* Truncate the ".txn" extension and store the ID. */</comment>
      <expr_stmt><expr><name>id</name> = <call><name>apr_pstrndup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call> - <name>ext_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>names</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call> = <name>id</name></expr>;</expr_stmt>
    }</block></for>

  <expr_stmt><expr>*<name>names_p</name> = <name>names</name></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__open_txn</name><parameter_list>(<param><decl><type><name>svn_fs_txn_t</name> **</type><name>txn_p</name></decl></param>,
                    <param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>,
                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_fs_txn_t</name> *</type><name>txn</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>transaction_t</name> *</type><name>local_txn</name></decl>;</decl_stmt>

  <comment type="block">/* First check to see if the directory exists. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_check_path</name><argument_list>(<argument><expr><call><name>path_txn_dir</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr>&amp;<name>kind</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Did we find it? */</comment>
  <if>if <condition>(<expr><name>kind</name> != <name>svn_node_dir</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_FS_NO_SUCH_TRANSACTION</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                            <argument><expr><call><name>_</name><argument_list>(<argument><expr>"No such transaction"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><name>txn</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>txn</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Read in the root node of this transaction. */</comment>
  <expr_stmt><expr><name><name>txn</name>-&gt;<name>id</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>txn</name>-&gt;<name>fs</name></name> = <name>fs</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__get_txn</name><argument_list>(<argument><expr>&amp;<name>local_txn</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>txn</name>-&gt;<name>base_rev</name></name> = <call><name>svn_fs_fs__id_rev</name><argument_list>(<argument><expr><name><name>local_txn</name>-&gt;<name>base_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>txn</name>-&gt;<name>vtable</name></name> = &amp;<name>txn_vtable</name></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>txn_p</name> = <name>txn</name></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__txn_proplist</name><parameter_list>(<param><decl><type><name>apr_hash_t</name> **</type><name>table_p</name></decl></param>,
                        <param><decl><type><name>svn_fs_txn_t</name> *</type><name>txn</name></decl></param>,
                        <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>proplist</name> <init>= <expr><call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_txn_proplist</name><argument_list>(<argument><expr><name>proplist</name></expr></argument>, <argument><expr><name><name>txn</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name><name>txn</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>table_p</name> = <name>proplist</name></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__delete_node_revision</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                                <param><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>id</name></decl></param>,
                                <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>node_revision_t</name> *</type><name>noderev</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__get_node_revision</name><argument_list>(<argument><expr>&amp;<name>noderev</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Delete any mutable property representation. */</comment>
  <if>if <condition>(<expr><name><name>noderev</name>-&gt;<name>prop_rep</name></name> &amp;&amp; <name><name>noderev</name>-&gt;<name>prop_rep</name>-&gt;<name>txn_id</name></name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_remove_file</name><argument_list>(<argument><expr><call><name>path_txn_node_props</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* Delete any mutable data representation. */</comment>
  <if>if <condition>(<expr><name><name>noderev</name>-&gt;<name>data_rep</name></name> &amp;&amp; <name><name>noderev</name>-&gt;<name>data_rep</name>-&gt;<name>txn_id</name></name>
      &amp;&amp; <name><name>noderev</name>-&gt;<name>kind</name></name> == <name>svn_node_dir</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_io_remove_file</name><argument_list>(<argument><expr><call><name>path_txn_node_children</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <return>return <expr><call><name>svn_io_remove_file</name><argument_list>(<argument><expr><call><name>path_txn_node_rev</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<escape char="0xc"/>
<comment type="block">/*** Revisions ***/</comment>

<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__revision_prop</name><parameter_list>(<param><decl><type><name>svn_string_t</name> **</type><name>value_p</name></decl></param>,
                         <param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                         <param><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl></param>,
                         <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>propname</name></decl></param>,
                         <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>table</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs__check_fs</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__revision_proplist</name><argument_list>(<argument><expr>&amp;<name>table</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>value_p</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>propname</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Baton used for change_rev_prop_body below. */</comment>
<struct>struct <name>change_rev_prop_baton</name> <block>{
  <decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>value</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/* The work-horse for svn_fs_fs__change_rev_prop, called with the FS
   write lock.  This implements the svn_fs_fs__with_write_lock()
   'body' callback type.  BATON is a 'struct change_rev_prop_baton *'. */</comment>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>change_rev_prop_body</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>change_rev_prop_baton</name> *</type><name>cb</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>table</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__revision_proplist</name><argument_list>(<argument><expr>&amp;<name>table</name></expr></argument>, <argument><expr><name><name>cb</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name><name>cb</name>-&gt;<name>rev</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name><name>cb</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name><name>cb</name>-&gt;<name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__set_revision_proplist</name><argument_list>(<argument><expr><name><name>cb</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name><name>cb</name>-&gt;<name>rev</name></name></expr></argument>, <argument><expr><name>table</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__change_rev_prop</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                           <param><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl></param>,
                           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>,
                           <param><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>value</name></decl></param>,
                           <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>change_rev_prop_baton</name></type> <name>cb</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs__check_fs</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>cb</name>.<name>fs</name></name> = <name>fs</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cb</name>.<name>rev</name></name> = <name>rev</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cb</name>.<name>name</name></name> = <name>name</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>cb</name>.<name>value</name></name> = <name>value</name></expr>;</expr_stmt>

  <return>return <expr><call><name>svn_fs_fs__with_write_lock</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>change_rev_prop_body</name></expr></argument>, <argument><expr>&amp;<name>cb</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<escape char="0xc"/>
<comment type="block">/*** Transactions ***/</comment>

<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__get_txn_ids</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> **</type><name>root_id_p</name></decl></param>,
                       <param><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> **</type><name>base_root_id_p</name></decl></param>,
                       <param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                       <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_name</name></decl></param>,
                       <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>transaction_t</name> *</type><name>txn</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__get_txn</name><argument_list>(<argument><expr>&amp;<name>txn</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_name</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>root_id_p</name> = <name><name>txn</name>-&gt;<name>root_id</name></name></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>base_root_id_p</name> = <name><name>txn</name>-&gt;<name>base_id</name></name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<escape char="0xc"/>
<comment type="block">/* Generic transaction operations.  */</comment>

<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__txn_prop</name><parameter_list>(<param><decl><type><name>svn_string_t</name> **</type><name>value_p</name></decl></param>,
                    <param><decl><type><name>svn_fs_txn_t</name> *</type><name>txn</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>propname</name></decl></param>,
                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>table</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name> <init>= <expr><name><name>txn</name>-&gt;<name>fs</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs__check_fs</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__txn_proplist</name><argument_list>(<argument><expr>&amp;<name>table</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>value_p</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>table</name></expr></argument>, <argument><expr><name>propname</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__begin_txn</name><parameter_list>(<param><decl><type><name>svn_fs_txn_t</name> **</type><name>txn_p</name></decl></param>,
                     <param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                     <param><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl></param>,
                     <param><decl><type><name>apr_uint32_t</name></type> <name>flags</name></decl></param>,
                     <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_string_t</name></type> <name>date</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_prop_t</name></type> <name>prop</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>props</name> <init>= <expr><call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>3</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>svn_prop_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs__check_fs</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__create_txn</name><argument_list>(<argument><expr><name>txn_p</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Put a datestamp on the newly created txn, so we always know
     exactly how old it is.  (This will help sysadmins identify
     long-abandoned txns that may need to be manually removed.)  When
     a txn is promoted to a revision, this property will be
     automatically overwritten with a revision datestamp. */</comment>
  <expr_stmt><expr><name><name>date</name>.<name>data</name></name> = <call><name>svn_time_to_cstring</name><argument_list>(<argument><expr><call><name>apr_time_now</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>date</name>.<name>len</name></name> = <call><name>strlen</name><argument_list>(<argument><expr><name><name>date</name>.<name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>prop</name>.<name>name</name></name> = <name>SVN_PROP_REVISION_DATE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>prop</name>.<name>value</name></name> = &amp;<name>date</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>props</name></expr></argument>, <argument><expr><name>svn_prop_t</name></expr></argument>)</argument_list></call> = <name>prop</name></expr>;</expr_stmt>

  <comment type="block">/* Set temporary txn props that represent the requested 'flags'
     behaviors. */</comment>
  <if>if <condition>(<expr><name>flags</name> &amp; <name>SVN_FS_TXN_CHECK_OOD</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name><name>prop</name>.<name>name</name></name> = <name>SVN_FS__PROP_TXN_CHECK_OOD</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>prop</name>.<name>value</name></name> = <call><name>svn_string_create</name><argument_list>(<argument><expr>"true"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>props</name></expr></argument>, <argument><expr><name>svn_prop_t</name></expr></argument>)</argument_list></call> = <name>prop</name></expr>;</expr_stmt>
    }</block></then></if>

  <if>if <condition>(<expr><name>flags</name> &amp; <name>SVN_FS_TXN_CHECK_LOCKS</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name><name>prop</name>.<name>name</name></name> = <name>SVN_FS__PROP_TXN_CHECK_LOCKS</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>prop</name>.<name>value</name></name> = <call><name>svn_string_create</name><argument_list>(<argument><expr>"true"</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>props</name></expr></argument>, <argument><expr><name>svn_prop_t</name></expr></argument>)</argument_list></call> = <name>prop</name></expr>;</expr_stmt>
    }</block></then></if>

  <return>return <expr><call><name>svn_fs_fs__change_txn_props</name><argument_list>(<argument><expr>*<name>txn_p</name></expr></argument>, <argument><expr><name>props</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>
</unit>
