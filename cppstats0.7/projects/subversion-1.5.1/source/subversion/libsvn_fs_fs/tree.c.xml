<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/subversion-1.5.1/source/subversion/libsvn_fs_fs/tree.c"><comment type="block">/* tree.c : tree-like filesystem, built on DAG filesystem
 *
 * ====================================================================
 * Copyright (c) 2000-2007 CollabNet.  All rights reserved.
 *
 * This software is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at http://subversion.tigris.org/license-1.html.
 * If newer versions of this license are posted there, you may use a
 * newer version instead, at your option.
 *
 * This software consists of voluntary contributions made by many
 * individuals.  For exact contribution history, see the revision
 * history and logs, available at http://subversion.tigris.org/.
 * ====================================================================
 */</comment>


<comment type="block">/* The job of this layer is to take a filesystem with lots of node
   sharing going on --- the real DAG filesystem as it appears in the
   database --- and make it look and act like an ordinary tree
   filesystem, with no sharing.

   We do just-in-time cloning: you can walk from some unfinished
   transaction's root down into directories and files shared with
   committed revisions; as soon as you try to change something, the
   appropriate nodes get cloned (and parent directory entries updated)
   invisibly, behind your back.  Any other references you have to
   nodes that have been cloned by other changes, even made by other
   processes, are automatically updated to point to the right clones.  */</comment>


<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_pools.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_hash.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_private_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_pools.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_error.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_path.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_md5.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_mergeinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_fs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"err.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"key-gen.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"dag.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fs_fs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"id.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"private/svn_mergeinfo_private.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"private/svn_fs_util.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../libsvn_fs/fs-loader.h"</cpp:file></cpp:include>


<comment type="block">/* ### I believe this constant will become internal to reps-strings.c.
   ### see the comment in window_consumer() for more information. */</comment>

<comment type="block">/* ### the comment also seems to need tweaking: the log file stuff
   ### is no longer an issue... */</comment>
<comment type="block">/* Data written to the filesystem through the svn_fs_apply_textdelta()
   interface is cached in memory until the end of the data stream, or
   until a size trigger is hit.  Define that trigger here (in bytes).
   Setting the value to 0 will result in no filesystem buffering at
   all.  The value only really matters when dealing with file contents
   bigger than the value itself.  Above that point, large values here
   allow the filesystem to buffer more data in memory before flushing
   to the database, which increases memory usage but greatly decreases
   the amount of disk access (and log-file generation) in database.
   Smaller values will limit your overall memory consumption, but can
   drastically hurt throughput by necessitating more write operations
   to the database (which also generates more log-files).  */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_BUFFER_SIZE</name></cpp:macro>          <cpp:value>512000</cpp:value></cpp:define>

<comment type="block">/* The maximum number of cache items to maintain in the node cache. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TXN_NODE_CACHE_MAX_KEYS</name></cpp:macro>        <cpp:value>32</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REV_NODE_CACHE_MAX_KEYS</name></cpp:macro>        <cpp:value>128</cpp:value></cpp:define>


<escape char="0xc"/>
<comment type="block">/* The root structures.

   Why do they contain different data?  Well, transactions are mutable
   enough that it isn't safe to cache the DAG node for the root
   directory or the hash of copyfrom data: somebody else might modify
   them concurrently on disk!  (Why is the DAG node cache safer than
   the root DAG node?  When cloning transaction DAG nodes in and out
   of the cache, all of the possibly-mutable data from the
   node_revision_t inside the dag_node_t is dropped.)  Additionally,
   revisions are immutable enough that their DAG node cache can be
   kept in the FS object and shared among multiple revision root
   objects.
*/</comment>
<typedef>typedef <type><struct>struct
<block>{
  <comment type="block">/* A dag node for the revision's root directory. */</comment>
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>root_dir</name></decl>;</decl_stmt>

  <comment type="block">/* Cache structure for mapping const char * PATH to const char
     *COPYFROM_STRING, so that paths_changed can remember all the
     copyfrom information in the changes file.
     COPYFROM_STRING has the format "REV PATH", or is the empty string if
     the path was added without history. */</comment>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>copyfrom_cache</name></decl>;</decl_stmt>

}</block></struct></type> <name>fs_rev_root_data_t</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
  <comment type="block">/* Dummy entry for circular LRU cache, and associated hash table. */</comment>
  <decl_stmt><decl><type><name>dag_node_cache_t</name></type> <name>txn_node_list</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>txn_node_cache</name></decl>;</decl_stmt>
}</block></struct></type> <name>fs_txn_root_data_t</name>;</typedef>

<comment type="block">/* Declared here to resolve the circular dependencies. */</comment>
<function_decl><type><specifier>static</specifier> <name>svn_error_t</name> *</type> <name>get_dag</name><parameter_list>(<param><decl><type><name>dag_node_t</name> **</type><name>dag_node_p</name></decl></param>, <param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
                             <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>svn_fs_root_t</name> *</type><name>make_revision_root</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>, <param><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl></param>,
                                         <param><decl><type><name>dag_node_t</name> *</type><name>root_dir</name></decl></param>,
                                         <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>svn_fs_root_t</name> *</type><name>make_txn_root</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn</name></decl></param>,
                                    <param><decl><type><name>svn_revnum_t</name></type> <name>base_rev</name></decl></param>, <param><decl><type><name>apr_uint32_t</name></type> <name>flags</name></decl></param>,
                                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>

<escape char="0xc"/>
<comment type="block">/*** Node Caching ***/</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>locate_cache</name><parameter_list>(<param><decl><type><name>dag_node_cache_t</name> **</type><name>node_list</name></decl></param>,
             <param><decl><type><name>apr_hash_t</name> **</type><name>node_cache</name></decl></param>,
             <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>key</name></decl></param>,
             <param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
             <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
             <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name><name>root</name>-&gt;<name>is_txn_root</name></name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>fs_txn_root_data_t</name> *</type><name>frd</name> <init>= <expr><name><name>root</name>-&gt;<name>fsap_data</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr>*<name>node_list</name> = &amp;<name><name>frd</name>-&gt;<name>txn_node_list</name></name></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>node_cache</name> = <name><name>frd</name>-&gt;<name>txn_node_cache</name></name></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>key</name> = <name>path</name></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <decl_stmt><decl><type><name>fs_fs_data_t</name> *</type><name>ffd</name> <init>= <expr><name><name>root</name>-&gt;<name>fs</name>-&gt;<name>fsap_data</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr>*<name>node_list</name> = &amp;<name><name>ffd</name>-&gt;<name>rev_node_list</name></name></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>node_cache</name> = <name><name>ffd</name>-&gt;<name>rev_node_cache</name></name></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>key</name> = <call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"%ld%s"</expr></argument>,
                          <argument><expr><name><name>root</name>-&gt;<name>rev</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
}</block></function>

<comment type="block">/* Return NODE for PATH from ROOT's node cache, or NULL if the node
   isn't cached. */</comment>
<function><type><specifier>static</specifier> <name>dag_node_t</name> *</type>
<name>dag_node_cache_get</name><parameter_list>(<param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>dag_node_cache_t</name> *</type><name>item</name></decl>, *<decl><type ref="prev"/><name>node_list</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>node_cache</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>key</name></decl>;</decl_stmt>

  <comment type="block">/* Assert valid input. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>*<name>path</name> == '/'</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>locate_cache</name><argument_list>(<argument><expr>&amp;<name>node_list</name></expr></argument>, <argument><expr>&amp;<name>node_cache</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>,
               <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Look in the cache for our desired item. */</comment>
  <expr_stmt><expr><name>item</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>node_cache</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>item</name> &amp;&amp; <name><name>item</name>-&gt;<name>node</name></name></expr>)</condition><then>
    <block>{
      <comment type="block">/* Move this cache item to the front of the LRU list. */</comment>
      <expr_stmt><expr><name><name>item</name>-&gt;<name>prev</name>-&gt;<name>next</name></name> = <name><name>item</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>item</name>-&gt;<name>next</name>-&gt;<name>prev</name></name> = <name><name>item</name>-&gt;<name>prev</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>item</name>-&gt;<name>prev</name></name> = <name>node_list</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>item</name>-&gt;<name>next</name></name> = <name><name>node_list</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>item</name>-&gt;<name>prev</name>-&gt;<name>next</name></name> = <name>item</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>item</name>-&gt;<name>next</name>-&gt;<name>prev</name></name> = <name>item</name></expr>;</expr_stmt>

      <comment type="block">/* Return the cached node. */</comment>
      <return>return <expr><call><name>svn_fs_fs__dag_dup</name><argument_list>(<argument><expr><name><name>item</name>-&gt;<name>node</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

  <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>


<comment type="block">/* Add the NODE for PATH to ROOT's node cache. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dag_node_cache_set</name><parameter_list>(<param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                   <param><decl><type><name>dag_node_t</name> *</type><name>node</name></decl></param>,
                   <param><decl><type><name>apr_pool_t</name> *</type><name>temp_pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>dag_node_cache_t</name> *</type><name>item</name></decl>, *<decl><type ref="prev"/><name>node_list</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>node_cache</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>key</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>max_keys</name> <init>= <expr><name><name>root</name>-&gt;<name>is_txn_root</name></name>
      ? <name>TXN_NODE_CACHE_MAX_KEYS</name> : <name>REV_NODE_CACHE_MAX_KEYS</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* The pool passed to this function can *only* be used for
     short-term calculations, not for the actual cache value!

     To ensure that our cache values live as long as the svn_fs_root_t
     in which they are ultimately stored, and to allow us to free()
     them individually without harming the rest, they are each
     allocated from a subpool of ROOT's pool.  We'll keep one subpool
     around for each cache slot -- as we start expiring stuff
     to make room for more entries, we'll re-use the expired thing's
     pool. */</comment>

  <comment type="block">/* Assert valid input and state. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>*<name>path</name> == '/'</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>locate_cache</name><argument_list>(<argument><expr>&amp;<name>node_list</name></expr></argument>, <argument><expr>&amp;<name>node_cache</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>,
               <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>temp_pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If we have an existing entry for this path, reuse it. */</comment>
  <expr_stmt><expr><name>item</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>node_cache</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Otherwise, if the cache is full, reuse the tail of the LRU list. */</comment>
  <if>if <condition>(<expr>!<name>item</name> &amp;&amp; <call><name>apr_hash_count</name><argument_list>(<argument><expr><name>node_cache</name></expr></argument>)</argument_list></call> == <name>max_keys</name></expr>)</condition><then>
    <expr_stmt><expr><name>item</name> = <name><name>node_list</name>-&gt;<name>prev</name></name></expr>;</expr_stmt></then></if>

  <if>if <condition>(<expr><name>item</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* Remove the existing item from the cache and reuse its pool. */</comment>
      <expr_stmt><expr><name><name>item</name>-&gt;<name>prev</name>-&gt;<name>next</name></name> = <name><name>item</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>item</name>-&gt;<name>next</name>-&gt;<name>prev</name></name> = <name><name>item</name>-&gt;<name>prev</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>node_cache</name></expr></argument>, <argument><expr><name><name>item</name>-&gt;<name>key</name></name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>pool</name> = <name><name>item</name>-&gt;<name>pool</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <comment type="block">/* Allocate a new pool. */</comment>
      <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>parent_pool</name> <init>= <expr><name><name>root</name>-&gt;<name>is_txn_root</name></name> ? <name><name>root</name>-&gt;<name>pool</name></name> : <name><name>root</name>-&gt;<name>fs</name>-&gt;<name>pool</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>pool</name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name>parent_pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

  <comment type="block">/* Create and fill in the cache item. */</comment>
  <expr_stmt><expr><name>item</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>item</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>item</name>-&gt;<name>key</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>item</name>-&gt;<name>node</name></name> = <call><name>svn_fs_fs__dag_dup</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>item</name>-&gt;<name>pool</name></name> = <name>pool</name></expr>;</expr_stmt>

  <comment type="block">/* Link it into the head of the LRU list and hash table. */</comment>
  <expr_stmt><expr><name><name>item</name>-&gt;<name>prev</name></name> = <name>node_list</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>item</name>-&gt;<name>next</name></name> = <name><name>node_list</name>-&gt;<name>next</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>item</name>-&gt;<name>prev</name>-&gt;<name>next</name></name> = <name>item</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>item</name>-&gt;<name>next</name>-&gt;<name>prev</name></name> = <name>item</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>node_cache</name></expr></argument>, <argument><expr><name><name>item</name>-&gt;<name>key</name></name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<comment type="block">/* Invalidate cache entries for PATH and any of its children. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dag_node_cache_invalidate</name><parameter_list>(<param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
                          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>fs_txn_root_data_t</name> *</type><name>frd</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>key</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dag_node_cache_t</name> *</type><name>item</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>root</name>-&gt;<name>is_txn_root</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>frd</name> = <name><name>root</name>-&gt;<name>fsap_data</name></name></expr>;</expr_stmt>

  <for>for (<init><expr><name>item</name> = <name><name>frd</name>-&gt;<name>txn_node_list</name>.<name>next</name></name></expr>;</init>
       <condition><expr><name>item</name> != &amp;<name><name>frd</name>-&gt;<name>txn_node_list</name></name></expr>;</condition>
       <incr><expr><name>item</name> = <name><name>item</name>-&gt;<name>next</name></name></expr></incr>)
    <block>{
      <expr_stmt><expr><name>key</name> = <name><name>item</name>-&gt;<name>key</name></name></expr>;</expr_stmt>
      <if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> == 0 &amp;&amp; (<name><name>key</name><index>[<expr><name>len</name></expr>]</index></name> == '/' || !<name><name>key</name><index>[<expr><name>len</name></expr>]</index></name>)</expr>)</condition><then>
        <expr_stmt><expr><name><name>item</name>-&gt;<name>node</name></name> = <name>NULL</name></expr>;</expr_stmt></then></if>
    }</block></for>
}</block></function>


<escape char="0xc"/>
<comment type="block">/* Creating transaction and revision root nodes.  */</comment>

<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__txn_root</name><parameter_list>(<param><decl><type><name>svn_fs_root_t</name> **</type><name>root_p</name></decl></param>,
                    <param><decl><type><name>svn_fs_txn_t</name> *</type><name>txn</name></decl></param>,
                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_uint32_t</name></type> <name>flags</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>txnprops</name></decl>;</decl_stmt>

  <comment type="block">/* Look for the temporary txn props representing 'flags'. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__txn_proplist</name><argument_list>(<argument><expr>&amp;<name>txnprops</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>txnprops</name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr><call><name>apr_hash_get</name><argument_list>(<argument><expr><name>txnprops</name></expr></argument>, <argument><expr><name>SVN_FS__PROP_TXN_CHECK_OOD</name></expr></argument>,
                       <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><name>flags</name> |= <name>SVN_FS_TXN_CHECK_OOD</name></expr>;</expr_stmt></then></if>

      <if>if <condition>(<expr><call><name>apr_hash_get</name><argument_list>(<argument><expr><name>txnprops</name></expr></argument>, <argument><expr><name>SVN_FS__PROP_TXN_CHECK_LOCKS</name></expr></argument>,
                       <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><name>flags</name> |= <name>SVN_FS_TXN_CHECK_LOCKS</name></expr>;</expr_stmt></then></if>
    }</block></then></if>

  <expr_stmt><expr><name>root</name> = <call><name>make_txn_root</name><argument_list>(<argument><expr><name><name>txn</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name><name>txn</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name><name>txn</name>-&gt;<name>base_rev</name></name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>root_p</name> = <name>root</name></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__revision_root</name><parameter_list>(<param><decl><type><name>svn_fs_root_t</name> **</type><name>root_p</name></decl></param>,
                         <param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                         <param><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl></param>,
                         <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>root_dir</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs__check_fs</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_revision_root</name><argument_list>(<argument><expr>&amp;<name>root_dir</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>root_p</name> = <call><name>make_revision_root</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>rev</name></expr></argument>, <argument><expr><name>root_dir</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<escape char="0xc"/>
<comment type="block">/* Getting dag nodes for roots.  */</comment>


<comment type="block">/* Set *NODE_P to a freshly opened dag node referring to the root
   directory of ROOT, allocating from POOL.  */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>root_node</name><parameter_list>(<param><decl><type><name>dag_node_t</name> **</type><name>node_p</name></decl></param>,
          <param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
          <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name><name>root</name>-&gt;<name>is_txn_root</name></name></expr>)</condition><then>
    <block>{
      <comment type="block">/* It's a transaction root.  Open a fresh copy.  */</comment>
      <return>return <expr><call><name>svn_fs_fs__dag_txn_root</name><argument_list>(<argument><expr><name>node_p</name></expr></argument>, <argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name><name>root</name>-&gt;<name>txn</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then>
  <else>else
    <block>{
      <comment type="block">/* It's a revision root, so we already have its root directory
         opened.  */</comment>
      <decl_stmt><decl><type><name>fs_rev_root_data_t</name> *</type><name>frd</name> <init>= <expr><name><name>root</name>-&gt;<name>fsap_data</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr>*<name>node_p</name> = <call><name>svn_fs_fs__dag_dup</name><argument_list>(<argument><expr><name><name>frd</name>-&gt;<name>root_dir</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></else></if>
}</block></function>


<comment type="block">/* Set *NODE_P to a mutable root directory for ROOT, cloning if
   necessary, allocating in POOL.  ROOT must be a transaction root.
   Use ERROR_PATH in error messages.  */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>mutable_root_node</name><parameter_list>(<param><decl><type><name>dag_node_t</name> **</type><name>node_p</name></decl></param>,
                  <param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
                  <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>error_path</name></decl></param>,
                  <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name><name>root</name>-&gt;<name>is_txn_root</name></name></expr>)</condition><then>
    <return>return <expr><call><name>svn_fs_fs__dag_clone_root</name><argument_list>(<argument><expr><name>node_p</name></expr></argument>, <argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name><name>root</name>-&gt;<name>txn</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return></then>
  <else>else
    <comment type="block">/* If it's not a transaction root, we can't change its contents.  */</comment>
    <return>return <expr><call><name>SVN_FS__ERR_NOT_MUTABLE</name><argument_list>(<argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name><name>root</name>-&gt;<name>rev</name></name></expr></argument>, <argument><expr><name>error_path</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>


<escape char="0xc"/>
<comment type="block">/* Traversing directory paths.  */</comment>

<typedef>typedef <type><enum>enum <name>copy_id_inherit_t</name>
<block>{
  <decl><name>copy_id_inherit_unknown</name> <init>= <expr>0</expr></init></decl>,
  <decl><name>copy_id_inherit_self</name></decl>,
  <decl><name>copy_id_inherit_parent</name></decl>,
  <decl><name>copy_id_inherit_new</name></decl>

}</block></enum></type> <name>copy_id_inherit_t</name>;</typedef>

<comment type="block">/* A linked list representing the path from a node up to a root
   directory.  We use this for cloning, and for operations that need
   to deal with both a node and its parent directory.  For example, a
   `delete' operation needs to know that the node actually exists, but
   also needs to change the parent directory.  */</comment>
<typedef>typedef <type><struct>struct <name>parent_path_t</name>
<block>{

  <comment type="block">/* A node along the path.  This could be the final node, one of its
     parents, or the root.  Every parent path ends with an element for
     the root directory.  */</comment>
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>node</name></decl>;</decl_stmt>

  <comment type="block">/* The name NODE has in its parent directory.  This is zero for the
     root directory, which (obviously) has no name in its parent.  */</comment>
  <decl_stmt><decl><type><name>char</name> *</type><name>entry</name></decl>;</decl_stmt>

  <comment type="block">/* The parent of NODE, or zero if NODE is the root directory.  */</comment>
  <decl_stmt><decl><type>struct <name>parent_path_t</name> *</type><name>parent</name></decl>;</decl_stmt>

  <comment type="block">/* The copy ID inheritence style. */</comment>
  <decl_stmt><decl><type><name>copy_id_inherit_t</name></type> <name>copy_inherit</name></decl>;</decl_stmt>

  <comment type="block">/* If copy ID inheritence style is copy_id_inherit_new, this is the
     path which should be implicitly copied; otherwise, this is NULL. */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copy_src_path</name></decl>;</decl_stmt>

}</block></struct></type> <name>parent_path_t</name>;</typedef>

<comment type="block">/* Return a text string describing the absolute path of parent_path
   PARENT_PATH.  It will be allocated in POOL. */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type>
<name>parent_path_path</name><parameter_list>(<param><decl><type><name>parent_path_t</name> *</type><name>parent_path</name></decl></param>,
                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path_so_far</name> <init>= <expr>"/"</expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name><name>parent_path</name>-&gt;<name>parent</name></name></expr>)</condition><then>
    <expr_stmt><expr><name>path_so_far</name> = <call><name>parent_path_path</name><argument_list>(<argument><expr><name><name>parent_path</name>-&gt;<name>parent</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <return>return <expr><name><name>parent_path</name>-&gt;<name>entry</name></name>
    ? <call><name>svn_path_join</name><argument_list>(<argument><expr><name>path_so_far</name></expr></argument>, <argument><expr><name><name>parent_path</name>-&gt;<name>entry</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call>
    : <name>path_so_far</name></expr>;</return>
}</block></function>


<comment type="block">/* Return the FS path for the parent path chain object CHILD relative
   to its ANCESTOR in the same chain, allocated in POOL.  */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type>
<name>parent_path_relpath</name><parameter_list>(<param><decl><type><name>parent_path_t</name> *</type><name>child</name></decl></param>,
                    <param><decl><type><name>parent_path_t</name> *</type><name>ancestor</name></decl></param>,
                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path_so_far</name> <init>= <expr>""</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>parent_path_t</name> *</type><name>this_node</name> <init>= <expr><name>child</name></expr></init></decl>;</decl_stmt>
  <while>while <condition>(<expr><name>this_node</name> != <name>ancestor</name></expr>)</condition>
    <block>{
      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>this_node</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>path_so_far</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name><name>this_node</name>-&gt;<name>entry</name></name></expr></argument>, <argument><expr><name>path_so_far</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>this_node</name> = <name><name>this_node</name>-&gt;<name>parent</name></name></expr>;</expr_stmt>
    }</block></while>
  <return>return <expr><name>path_so_far</name></expr>;</return>
}</block></function>



<comment type="block">/* Choose a copy ID inheritance method *INHERIT_P to be used in the
   event that immutable node CHILD in FS needs to be made mutable.  If
   the inheritance method is copy_id_inherit_new, also return a
   *COPY_SRC_PATH on which to base the new copy ID (else return NULL
   for that path).  CHILD must have a parent (it cannot be the root
   node).  TXN_ID is the transaction in which these items might be
   mutable.  Allocations are taken from POOL. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>get_copy_inheritance</name><parameter_list>(<param><decl><type><name>copy_id_inherit_t</name> *</type><name>inherit_p</name></decl></param>,
                     <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>copy_src_path</name></decl></param>,
                     <param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                     <param><decl><type><name>parent_path_t</name> *</type><name>child</name></decl></param>,
                     <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>,
                     <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>child_id</name></decl>, *<decl><type ref="prev"/><name>parent_id</name></decl>, *<decl><type ref="prev"/><name>copyroot_id</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>child_copy_id</name></decl>, *<decl><type ref="prev"/><name>parent_copy_id</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>id_path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>copyroot_root</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>copyroot_node</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>copyroot_rev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copyroot_path</name></decl>;</decl_stmt>

  <comment type="block">/* Make some assertions about the function input. */</comment>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>child</name> &amp;&amp; <name><name>child</name>-&gt;<name>parent</name></name> &amp;&amp; <name>txn_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Initialize some convenience variables. */</comment>
  <expr_stmt><expr><name>child_id</name> = <call><name>svn_fs_fs__dag_get_id</name><argument_list>(<argument><expr><name><name>child</name>-&gt;<name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>parent_id</name> = <call><name>svn_fs_fs__dag_get_id</name><argument_list>(<argument><expr><name><name>child</name>-&gt;<name>parent</name>-&gt;<name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>child_copy_id</name> = <call><name>svn_fs_fs__id_copy_id</name><argument_list>(<argument><expr><name>child_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>parent_copy_id</name> = <call><name>svn_fs_fs__id_copy_id</name><argument_list>(<argument><expr><name>parent_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If this child is already mutable, we have nothing to do. */</comment>
  <if>if <condition>(<expr><call><name>svn_fs_fs__id_txn_id</name><argument_list>(<argument><expr><name>child_id</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <expr_stmt><expr>*<name>inherit_p</name> = <name>copy_id_inherit_self</name></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>copy_src_path</name> = <name>NULL</name></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>

  <comment type="block">/* From this point on, we'll assume that the child will just take
     its copy ID from its parent. */</comment>
  <expr_stmt><expr>*<name>inherit_p</name> = <name>copy_id_inherit_parent</name></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>copy_src_path</name> = <name>NULL</name></expr>;</expr_stmt>

  <comment type="block">/* Special case: if the child's copy ID is '0', use the parent's
     copy ID. */</comment>
  <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>child_copy_id</name></expr></argument>, <argument><expr>"0"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <comment type="block">/* Compare the copy IDs of the child and its parent.  If they are
     the same, then the child is already on the same branch as the
     parent, and should use the same mutability copy ID that the
     parent will use. */</comment>
  <if>if <condition>(<expr><call><name>svn_fs_fs__key_compare</name><argument_list>(<argument><expr><name>child_copy_id</name></expr></argument>, <argument><expr><name>parent_copy_id</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <comment type="block">/* If the child is on the same branch that the parent is on, the
     child should just use the same copy ID that the parent would use.
     Else, the child needs to generate a new copy ID to use should it
     need to be made mutable.  We will claim that child is on the same
     branch as its parent if the child itself is not a branch point,
     or if it is a branch point that we are accessing via its original
     copy destination path. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_copyroot</name><argument_list>(<argument><expr>&amp;<name>copyroot_rev</name></expr></argument>, <argument><expr>&amp;<name>copyroot_path</name></expr></argument>,
                                      <argument><expr><name><name>child</name>-&gt;<name>node</name></name></expr></argument>,<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__revision_root</name><argument_list>(<argument><expr>&amp;<name>copyroot_root</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>copyroot_rev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_dag</name><argument_list>(<argument><expr>&amp;<name>copyroot_node</name></expr></argument>, <argument><expr><name>copyroot_root</name></expr></argument>, <argument><expr><name>copyroot_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>copyroot_id</name> = <call><name>svn_fs_fs__dag_get_id</name><argument_list>(<argument><expr><name>copyroot_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><call><name>svn_fs_fs__id_compare</name><argument_list>(<argument><expr><name>copyroot_id</name></expr></argument>, <argument><expr><name>child_id</name></expr></argument>)</argument_list></call> == -1</expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <comment type="block">/* Determine if we are looking at the child via its original path or
     as a subtree item of a copied tree. */</comment>
  <expr_stmt><expr><name>id_path</name> = <call><name>svn_fs_fs__dag_get_created_path</name><argument_list>(<argument><expr><name><name>child</name>-&gt;<name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>id_path</name></expr></argument>, <argument><expr><call><name>parent_path_path</name><argument_list>(<argument><expr><name>child</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
    <block>{
      <expr_stmt><expr>*<name>inherit_p</name> = <name>copy_id_inherit_self</name></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>

  <comment type="block">/* We are pretty sure that the child node is an unedited nested
     branched node.  When it needs to be made mutable, it should claim
     a new copy ID. */</comment>
  <expr_stmt><expr>*<name>inherit_p</name> = <name>copy_id_inherit_new</name></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>copy_src_path</name> = <name>id_path</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Allocate a new parent_path_t node from POOL, referring to NODE,
   ENTRY, PARENT, and COPY_ID.  */</comment>
<function><type><specifier>static</specifier> <name>parent_path_t</name> *</type>
<name>make_parent_path</name><parameter_list>(<param><decl><type><name>dag_node_t</name> *</type><name>node</name></decl></param>,
                 <param><decl><type><name>char</name> *</type><name>entry</name></decl></param>,
                 <param><decl><type><name>parent_path_t</name> *</type><name>parent</name></decl></param>,
                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>parent_path_t</name> *</type><name>parent_path</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>parent_path</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>parent_path</name>-&gt;<name>node</name></name> = <name>node</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>parent_path</name>-&gt;<name>entry</name></name> = <name>entry</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>parent_path</name>-&gt;<name>parent</name></name> = <name>parent</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>parent_path</name>-&gt;<name>copy_inherit</name></name> = <name>copy_id_inherit_unknown</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>parent_path</name>-&gt;<name>copy_src_path</name></name> = <name>NULL</name></expr>;</expr_stmt>
  <return>return <expr><name>parent_path</name></expr>;</return>
}</block></function>


<comment type="block">/* Flags for open_path.  */</comment>
<typedef>typedef <type><enum>enum <name>open_path_flags_t</name> <block>{

  <comment type="block">/* The last component of the PATH need not exist.  (All parent
     directories must exist, as usual.)  If the last component doesn't
     exist, simply leave the `node' member of the bottom parent_path
     component zero.  */</comment>
  <decl><name>open_path_last_optional</name> <init>= <expr>1</expr></init></decl>

}</block></enum></type> <name>open_path_flags_t</name>;</typedef>


<comment type="block">/* Open the node identified by PATH in ROOT, allocating in POOL.  Set
   *PARENT_PATH_P to a path from the node up to ROOT.  The resulting
   **PARENT_PATH_P value is guaranteed to contain at least one
   *element, for the root directory.

   If resulting *PARENT_PATH_P will eventually be made mutable and
   modified, or if copy ID inheritance information is otherwise
   needed, TXN_ID should be the ID of the mutability transaction.  If
   TXN_ID is NULL, no copy ID in heritance information will be
   calculated for the *PARENT_PATH_P chain.

   If FLAGS &amp; open_path_last_optional is zero, return the error
   SVN_ERR_FS_NOT_FOUND if the node PATH refers to does not exist.  If
   non-zero, require all the parent directories to exist as normal,
   but if the final path component doesn't exist, simply return a path
   whose bottom `node' member is zero.  This option is useful for
   callers that create new nodes --- we find the parent directory for
   them, and tell them whether the entry exists already.

   NOTE: Public interfaces which only *read* from the filesystem
   should not call this function directly, but should instead use
   get_dag().
*/</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>open_path</name><parameter_list>(<param><decl><type><name>parent_path_t</name> **</type><name>parent_path_p</name></decl></param>,
          <param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
          <param><decl><type><name>int</name></type> <name>flags</name></decl></param>,
          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>,
          <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name> <init>= <expr><name><name>root</name>-&gt;<name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>id</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>here</name></decl>;</decl_stmt> <comment type="block">/* The directory we're currently looking at.  */</comment>
  <decl_stmt><decl><type><name>parent_path_t</name> *</type><name>parent_path</name></decl>;</decl_stmt> <comment type="block">/* The path from HERE up to the root.  */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>rest</name></decl>;</decl_stmt> <comment type="block">/* The portion of PATH we haven't traversed yet.  */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>canon_path</name> <init>= <expr><call><name>svn_fs__canonicalize_abspath</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path_so_far</name> <init>= <expr>"/"</expr></init></decl>;</decl_stmt>

  <comment type="block">/* Make a parent_path item for the root node, using its own current
     copy id.  */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>root_node</name><argument_list>(<argument><expr>&amp;<name>here</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>id</name> = <call><name>svn_fs_fs__dag_get_id</name><argument_list>(<argument><expr><name>here</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>parent_path</name> = <call><name>make_parent_path</name><argument_list>(<argument><expr><name>here</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>parent_path</name>-&gt;<name>copy_inherit</name></name> = <name>copy_id_inherit_self</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>rest</name> = <name>canon_path</name> + 1</expr>;</expr_stmt> <comment type="block">/* skip the leading '/', it saves in iteration */</comment>

  <comment type="block">/* Whenever we are at the top of this loop:
     - HERE is our current directory,
     - ID is the node revision ID of HERE,
     - REST is the path we're going to find in HERE, and
     - PARENT_PATH includes HERE and all its parents.  */</comment>
  <for>for (<init>;</init><condition>;</condition><incr/>)
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>next</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> *</type><name>entry</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>child</name></decl>;</decl_stmt>

      <comment type="block">/* Parse out the next entry from the path.  */</comment>
      <expr_stmt><expr><name>entry</name> = <call><name>svn_fs__next_entry_name</name><argument_list>(<argument><expr>&amp;<name>next</name></expr></argument>, <argument><expr><name>rest</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Calculate the path traversed thus far. */</comment>
      <expr_stmt><expr><name>path_so_far</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>path_so_far</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr>*<name>entry</name> == '\0'</expr>)</condition><then>
        <block>{
          <comment type="block">/* Given the behavior of svn_fs__next_entry_name(), this
             happens when the path either starts or ends with a slash.
             In either case, we stay put: the current directory stays
             the same, and we add nothing to the parent path. */</comment>
          <expr_stmt><expr><name>child</name> = <name>here</name></expr>;</expr_stmt>
        }</block></then>
      <else>else
        <block>{
          <decl_stmt><decl><type><name>copy_id_inherit_t</name></type> <name>inherit</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copy_path</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name> <init>= <expr><name>SVN_NO_ERROR</name></expr></init></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>cached_node</name></decl>;</decl_stmt>

          <comment type="block">/* If we found a directory entry, follow it.  First, we
             check our node cache, and, failing that, we hit the DAG
             layer. */</comment>
          <expr_stmt><expr><name>cached_node</name> = <call><name>dag_node_cache_get</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path_so_far</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>cached_node</name></expr>)</condition><then>
            <expr_stmt><expr><name>child</name> = <name>cached_node</name></expr>;</expr_stmt></then>
          <else>else
            <expr_stmt><expr><name>err</name> = <call><name>svn_fs_fs__dag_open</name><argument_list>(<argument><expr>&amp;<name>child</name></expr></argument>, <argument><expr><name>here</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

          <comment type="block">/* "file not found" requires special handling.  */</comment>
          <if>if <condition>(<expr><name>err</name> &amp;&amp; <name><name>err</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_FS_NOT_FOUND</name></expr>)</condition><then>
            <block>{
              <comment type="block">/* If this was the last path component, and the caller
                 said it was optional, then don't return an error;
                 just put a NULL node pointer in the path.  */</comment>

              <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

              <if>if <condition>(<expr>(<name>flags</name> &amp; <name>open_path_last_optional</name>)
                  &amp;&amp; (! <name>next</name> || *<name>next</name> == '\0')</expr>)</condition><then>
                <block>{
                  <expr_stmt><expr><name>parent_path</name> = <call><name>make_parent_path</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>parent_path</name></expr></argument>,
                                                 <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <break>break;</break>
                }</block></then>
              <else>else
                <block>{
                  <comment type="block">/* Build a better error message than svn_fs_fs__dag_open
                     can provide, giving the root and full path name.  */</comment>
                  <return>return <expr><call><name>SVN_FS__NOT_FOUND</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return>
                }</block></else></if>
            }</block></then></if>

          <comment type="block">/* Other errors we return normally.  */</comment>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <comment type="block">/* Now, make a parent_path item for CHILD. */</comment>
          <expr_stmt><expr><name>parent_path</name> = <call><name>make_parent_path</name><argument_list>(<argument><expr><name>child</name></expr></argument>, <argument><expr><name>entry</name></expr></argument>, <argument><expr><name>parent_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>txn_id</name></expr>)</condition><then>
            <block>{
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_copy_inheritance</name><argument_list>(<argument><expr>&amp;<name>inherit</name></expr></argument>, <argument><expr>&amp;<name>copy_path</name></expr></argument>,
                                           <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>parent_path</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>parent_path</name>-&gt;<name>copy_inherit</name></name> = <name>inherit</name></expr>;</expr_stmt>
              <expr_stmt><expr><name><name>parent_path</name>-&gt;<name>copy_src_path</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>copy_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>

          <comment type="block">/* Cache the node we found (if it wasn't already cached). */</comment>
          <if>if <condition>(<expr>! <name>cached_node</name></expr>)</condition><then>
            <expr_stmt><expr><call><name>dag_node_cache_set</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path_so_far</name></expr></argument>, <argument><expr><name>child</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        }</block></else></if>

      <comment type="block">/* Are we finished traversing the path?  */</comment>
      <if>if <condition>(<expr>! <name>next</name></expr>)</condition><then>
        <break>break;</break></then></if>

      <comment type="block">/* The path isn't finished yet; we'd better be in a directory.  */</comment>
      <if>if <condition>(<expr><call><name>svn_fs_fs__dag_node_kind</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call> != <name>svn_node_dir</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>SVN_ERR_W</name><argument_list>(<argument><expr><call><name>SVN_FS__ERR_NOT_DIRECTORY</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>path_so_far</name></expr></argument>)</argument_list></call></expr></argument>,
                  <argument><expr><call><name>apr_psprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Failure opening '%s'"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

      <expr_stmt><expr><name>rest</name> = <name>next</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>here</name> = <name>child</name></expr>;</expr_stmt>
    }</block></for>

  <expr_stmt><expr>*<name>parent_path_p</name> = <name>parent_path</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Make the node referred to by PARENT_PATH mutable, if it isn't
   already, allocating from POOL.  ROOT must be the root from which
   PARENT_PATH descends.  Clone any parent directories as needed.
   Adjust the dag nodes in PARENT_PATH to refer to the clones.  Use
   ERROR_PATH in error messages.  */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>make_path_mutable</name><parameter_list>(<param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
                  <param><decl><type><name>parent_path_t</name> *</type><name>parent_path</name></decl></param>,
                  <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>error_path</name></decl></param>,
                  <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>clone</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name> <init>= <expr><name><name>root</name>-&gt;<name>txn</name></name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Is the node mutable already?  */</comment>
  <if>if <condition>(<expr><call><name>svn_fs_fs__dag_check_mutable</name><argument_list>(<argument><expr><name><name>parent_path</name>-&gt;<name>node</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <comment type="block">/* Are we trying to clone the root, or somebody's child node?  */</comment>
  <if>if <condition>(<expr><name><name>parent_path</name>-&gt;<name>parent</name></name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>parent_id</name></decl>, *<decl><type ref="prev"/><name>child_id</name></decl>, *<decl><type ref="prev"/><name>copyroot_id</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copy_id</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>copy_id_inherit_t</name></type> <name>inherit</name> <init>= <expr><name><name>parent_path</name>-&gt;<name>copy_inherit</name></name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>clone_path</name></decl>, *<decl><type ref="prev"/><name>copyroot_path</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>copyroot_rev</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>is_parent_copyroot</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>copyroot_root</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>copyroot_node</name></decl>;</decl_stmt>

      <comment type="block">/* We're trying to clone somebody's child.  Make sure our parent
         is mutable.  */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>make_path_mutable</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>parent_path</name>-&gt;<name>parent</name></name></expr></argument>,
                                <argument><expr><name>error_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <switch>switch <condition>(<expr><name>inherit</name></expr>)</condition>
        <block>{
        <case>case <expr><name>copy_id_inherit_parent</name></expr>:
          <expr_stmt><expr><name>parent_id</name> = <call><name>svn_fs_fs__dag_get_id</name><argument_list>(<argument><expr><name><name>parent_path</name>-&gt;<name>parent</name>-&gt;<name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>copy_id</name> = <call><name>svn_fs_fs__id_copy_id</name><argument_list>(<argument><expr><name>parent_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>

        </case><case>case <expr><name>copy_id_inherit_new</name></expr>:
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__reserve_copy_id</name><argument_list>(<argument><expr>&amp;<name>copy_id</name></expr></argument>, <argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>,
                                             <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <break>break;</break>

        </case><case>case <expr><name>copy_id_inherit_self</name></expr>:
          <expr_stmt><expr><name>copy_id</name> = <name>NULL</name></expr>;</expr_stmt>
          <break>break;</break>

        </case><case>case <expr><name>copy_id_inherit_unknown</name></expr>:
        </case><default>default:
          <expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt> <comment type="block">/* uh-oh -- somebody didn't calculate copy-ID
                      inheritance data. */</comment>
        </default>}</block></switch>

      <comment type="block">/* Determine what copyroot our new child node should use. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_copyroot</name><argument_list>(<argument><expr>&amp;<name>copyroot_rev</name></expr></argument>, <argument><expr>&amp;<name>copyroot_path</name></expr></argument>,
                                          <argument><expr><name><name>parent_path</name>-&gt;<name>node</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__revision_root</name><argument_list>(<argument><expr>&amp;<name>copyroot_root</name></expr></argument>, <argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>,
                                       <argument><expr><name>copyroot_rev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_dag</name><argument_list>(<argument><expr>&amp;<name>copyroot_node</name></expr></argument>, <argument><expr><name>copyroot_root</name></expr></argument>, <argument><expr><name>copyroot_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>child_id</name> = <call><name>svn_fs_fs__dag_get_id</name><argument_list>(<argument><expr><name><name>parent_path</name>-&gt;<name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>copyroot_id</name> = <call><name>svn_fs_fs__dag_get_id</name><argument_list>(<argument><expr><name>copyroot_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>svn_fs_fs__id_node_id</name><argument_list>(<argument><expr><name>child_id</name></expr></argument>)</argument_list></call></expr></argument>,
                 <argument><expr><call><name>svn_fs_fs__id_node_id</name><argument_list>(<argument><expr><name>copyroot_id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
        <expr_stmt><expr><name>is_parent_copyroot</name> = <name>TRUE</name></expr>;</expr_stmt></then></if>

      <comment type="block">/* Now make this node mutable.  */</comment>
      <expr_stmt><expr><name>clone_path</name> = <call><name>parent_path_path</name><argument_list>(<argument><expr><name><name>parent_path</name>-&gt;<name>parent</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_clone_child</name><argument_list>(<argument><expr>&amp;<name>clone</name></expr></argument>,
                                         <argument><expr><name><name>parent_path</name>-&gt;<name>parent</name>-&gt;<name>node</name></name></expr></argument>,
                                         <argument><expr><name>clone_path</name></expr></argument>,
                                         <argument><expr><name><name>parent_path</name>-&gt;<name>entry</name></name></expr></argument>,
                                         <argument><expr><name>copy_id</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>,
                                         <argument><expr><name>is_parent_copyroot</name></expr></argument>,
                                         <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Update the path cache. */</comment>
      <expr_stmt><expr><call><name>dag_node_cache_set</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><call><name>parent_path_path</name><argument_list>(<argument><expr><name>parent_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>clone</name></expr></argument>,
                         <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <comment type="block">/* We're trying to clone the root directory.  */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>mutable_root_node</name><argument_list>(<argument><expr>&amp;<name>clone</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>error_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

  <comment type="block">/* Update the PARENT_PATH link to refer to the clone.  */</comment>
  <expr_stmt><expr><name><name>parent_path</name>-&gt;<name>node</name></name> = <name>clone</name></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Open the node identified by PATH in ROOT.  Set DAG_NODE_P to the
 *node we find, allocated in POOL.  Return the error
 *SVN_ERR_FS_NOT_FOUND if this node doesn't exist. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>get_dag</name><parameter_list>(<param><decl><type><name>dag_node_t</name> **</type><name>dag_node_p</name></decl></param>,
        <param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
        <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
        <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>parent_path_t</name> *</type><name>parent_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>node</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Canonicalize the input PATH. */</comment>
  <expr_stmt><expr><name>path</name> = <call><name>svn_fs__canonicalize_abspath</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If ROOT is a revision root, we'll look for the DAG in our cache. */</comment>
  <expr_stmt><expr><name>node</name> = <call><name>dag_node_cache_get</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>! <name>node</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* Call open_path with no flags, as we want this to return an error
         if the node for which we are searching doesn't exist. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>open_path</name><argument_list>(<argument><expr>&amp;<name>parent_path</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>node</name> = <name><name>parent_path</name>-&gt;<name>node</name></name></expr>;</expr_stmt>

      <comment type="block">/* No need to cache our find -- open_path() will do that for us. */</comment>
    }</block></then></if>

  <expr_stmt><expr>*<name>dag_node_p</name> = <name>node</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<escape char="0xc"/>
<comment type="block">/* Populating the `changes' table. */</comment>

<comment type="block">/* Add a change to the changes table in FS, keyed on transaction id
   TXN_ID, and indicated that a change of kind CHANGE_KIND occurred on
   PATH (whose node revision id is--or was, in the case of a
   deletion--NODEREV_ID), and optionally that TEXT_MODs or PROP_MODs
   occurred.  If the change resulted from a copy, COPYFROM_REV and
   COPYFROM_PATH specify under which revision and path the node was
   copied from.  If this was not part of a copy, COPYFROM_REV should
   be SVN_INVALID_REVNUM.  Do all this as part of POOL.  */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>add_change</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>,
           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
           <param><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>noderev_id</name></decl></param>,
           <param><decl><type><name>svn_fs_path_change_kind_t</name></type> <name>change_kind</name></decl></param>,
           <param><decl><type><name>svn_boolean_t</name></type> <name>text_mod</name></decl></param>,
           <param><decl><type><name>svn_boolean_t</name></type> <name>prop_mod</name></decl></param>,
           <param><decl><type><name>svn_revnum_t</name></type> <name>copyfrom_rev</name></decl></param>,
           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copyfrom_path</name></decl></param>,
           <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__add_change</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>,
                                <argument><expr><call><name>svn_fs__canonicalize_abspath</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><name>noderev_id</name></expr></argument>, <argument><expr><name>change_kind</name></expr></argument>, <argument><expr><name>text_mod</name></expr></argument>, <argument><expr><name>prop_mod</name></expr></argument>,
                                <argument><expr><name>copyfrom_rev</name></expr></argument>, <argument><expr><name>copyfrom_path</name></expr></argument>,
                                <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<escape char="0xc"/>
<comment type="block">/* Generic node operations.  */</comment>

<comment type="block">/* Get the id of a node referenced by path PATH in ROOT.  Return the
   id in *ID_P allocated in POOL. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>fs_node_id</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> **</type><name>id_p</name></decl></param>,
           <param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
           <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>(! <name><name>root</name>-&gt;<name>is_txn_root</name></name>)
      &amp;&amp; (<name><name>path</name><index>[<expr>0</expr>]</index></name> == '\0' || ((<name><name>path</name><index>[<expr>0</expr>]</index></name> == '/') &amp;&amp; (<name><name>path</name><index>[<expr>1</expr>]</index></name> == '\0')))</expr>)</condition><then>
    <block>{
      <comment type="block">/* Optimize the case where we don't need any db access at all.
         The root directory ("" or "/") node is stored in the
         svn_fs_root_t object, and never changes when it's a revision
         root, so we can just reach in and grab it directly. */</comment>
      <decl_stmt><decl><type><name>fs_rev_root_data_t</name> *</type><name>frd</name> <init>= <expr><name><name>root</name>-&gt;<name>fsap_data</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr>*<name>id_p</name> = <call><name>svn_fs_fs__id_copy</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_id</name><argument_list>(<argument><expr><name><name>frd</name>-&gt;<name>root_dir</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>node</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_dag</name><argument_list>(<argument><expr>&amp;<name>node</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>id_p</name> = <call><name>svn_fs_fs__id_copy</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_id</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__node_created_rev</name><parameter_list>(<param><decl><type><name>svn_revnum_t</name> *</type><name>revision</name></decl></param>,
                            <param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
                            <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                            <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>node</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_dag</name><argument_list>(<argument><expr>&amp;<name>node</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_revision</name><argument_list>(<argument><expr><name>revision</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Set *CREATED_PATH to the path at which PATH under ROOT was created.
   Return a string allocated in POOL. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>fs_node_created_path</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>created_path</name></decl></param>,
                     <param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
                     <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                     <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>node</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_dag</name><argument_list>(<argument><expr>&amp;<name>node</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>created_path</name> = <call><name>svn_fs_fs__dag_get_created_path</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Set *KIND_P to the type of node located at PATH under ROOT.
   Perform temporary allocations in POOL. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>node_kind</name><parameter_list>(<param><decl><type><name>svn_node_kind_t</name> *</type><name>kind_p</name></decl></param>,
          <param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
          <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
          <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>node_id</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>node</name></decl>;</decl_stmt>

  <comment type="block">/* Get the node id. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>fs_node_id</name><argument_list>(<argument><expr>&amp;<name>node_id</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Use the node id to get the real kind. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_node</name><argument_list>(<argument><expr>&amp;<name>node</name></expr></argument>, <argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>node_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>kind_p</name> = <call><name>svn_fs_fs__dag_node_kind</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Set *KIND_P to the type of node present at PATH under ROOT.  If
   PATH does not exist under ROOT, set *KIND_P to svn_node_none.  Use
   POOL for temporary allocation. */</comment>
<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__check_path</name><parameter_list>(<param><decl><type><name>svn_node_kind_t</name> *</type><name>kind_p</name></decl></param>,
                      <param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
                      <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                      <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name> <init>= <expr><call><name>node_kind</name><argument_list>(<argument><expr><name>kind_p</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <if>if <condition>(<expr><name>err</name> &amp;&amp; 
      ((<name><name>err</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_FS_NOT_FOUND</name>)
       || (<name><name>err</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_FS_NOT_DIRECTORY</name>))</expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>kind_p</name> = <name>svn_node_none</name></expr>;</expr_stmt>
    }</block></then>
  <else>else <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
    <block>{
      <return>return <expr><name>err</name></expr>;</return>
    }</block></then></if></else></if>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Set *VALUE_P to the value of the property named PROPNAME of PATH in
   ROOT.  If the node has no property by that name, set *VALUE_P to
   zero.  Allocate the result in POOL. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>fs_node_prop</name><parameter_list>(<param><decl><type><name>svn_string_t</name> **</type><name>value_p</name></decl></param>,
             <param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
             <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
             <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>propname</name></decl></param>,
             <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>node</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>proplist</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_dag</name><argument_list>(<argument><expr>&amp;<name>node</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_proplist</name><argument_list>(<argument><expr>&amp;<name>proplist</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>value_p</name> = <name>NULL</name></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>proplist</name></expr>)</condition><then>
    <expr_stmt><expr>*<name>value_p</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>proplist</name></expr></argument>, <argument><expr><name>propname</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Set *TABLE_P to the entire property list of PATH under ROOT, as an
   APR hash table allocated in POOL.  The resulting property table
   maps property names to pointers to svn_string_t objects containing
   the property value. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>fs_node_proplist</name><parameter_list>(<param><decl><type><name>apr_hash_t</name> **</type><name>table_p</name></decl></param>,
                 <param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>table</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>node</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_dag</name><argument_list>(<argument><expr>&amp;<name>node</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_proplist</name><argument_list>(<argument><expr>&amp;<name>table</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>table_p</name> = <name>table</name> ? <name>table</name> : <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>increment_mergeinfo_up_tree</name><parameter_list>(<param><decl><type><name>parent_path_t</name> *</type><name>pp</name></decl></param>,
                            <param><decl><type><name>apr_int64_t</name></type> <name>increment</name></decl></param>,
                            <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <for>for (<init>;</init> <condition><expr><name>pp</name></expr>;</condition> <incr><expr><name>pp</name> = <name><name>pp</name>-&gt;<name>parent</name></name></expr></incr>)
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_increment_mergeinfo_count</name><argument_list>(<argument><expr><name><name>pp</name>-&gt;<name>node</name></name></expr></argument>,
                                                     <argument><expr><name>increment</name></expr></argument>,
                                                     <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></for>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Change, add, or delete a node's property value.  The affected node
   is PATH under ROOT, the property value to modify is NAME, and VALUE
   points to either a string value to set the new contents to, or NULL
   if the property should be deleted.  Perform temporary allocations
   in POOL. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>fs_change_node_prop</name><parameter_list>(<param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>value</name></decl></param>,
                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>parent_path_t</name> *</type><name>parent_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>proplist</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl>;</decl_stmt>

  <if>if <condition>(<expr>! <name><name>root</name>-&gt;<name>is_txn_root</name></name></expr>)</condition><then>
    <return>return <expr><call><name>SVN_FS__NOT_TXN</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
  <expr_stmt><expr><name>txn_id</name> = <name><name>root</name>-&gt;<name>txn</name></name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>open_path</name><argument_list>(<argument><expr>&amp;<name>parent_path</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check (non-recursively) to see if path is locked; if so, check
     that we can use it. */</comment>
  <if>if <condition>(<expr><name><name>root</name>-&gt;<name>txn_flags</name></name> &amp; <name>SVN_FS_TXN_CHECK_LOCKS</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__allow_locked_operation</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                                              <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>make_path_mutable</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>parent_path</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_proplist</name><argument_list>(<argument><expr>&amp;<name>proplist</name></expr></argument>, <argument><expr><name><name>parent_path</name>-&gt;<name>node</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If there's no proplist, but we're just deleting a property, exit now. */</comment>
  <if>if <condition>(<expr>(! <name>proplist</name>) &amp;&amp; (! <name>value</name>)</expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <comment type="block">/* Now, if there's no proplist, we know we need to make one. */</comment>
  <if>if <condition>(<expr>! <name>proplist</name></expr>)</condition><then>
    <expr_stmt><expr><name>proplist</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <if>if <condition>(<expr><call><name>svn_fs_fs__fs_supports_mergeinfo</name><argument_list>(<argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>)</argument_list></call> 
      &amp;&amp; <call><name>strcmp</name> <argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>SVN_PROP_MERGEINFO</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>apr_int64_t</name></type> <name>increment</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>had_mergeinfo</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_has_mergeinfo</name><argument_list>(<argument><expr>&amp;<name>had_mergeinfo</name></expr></argument>, <argument><expr><name><name>parent_path</name>-&gt;<name>node</name></name></expr></argument>,
                                           <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr><name>value</name> &amp;&amp; !<name>had_mergeinfo</name></expr>)</condition><then>
        <expr_stmt><expr><name>increment</name> = 1</expr>;</expr_stmt></then>
      <else>else <if>if <condition>(<expr>!<name>value</name> &amp;&amp; <name>had_mergeinfo</name></expr>)</condition><then>
        <expr_stmt><expr><name>increment</name> = -1</expr>;</expr_stmt></then></if></else></if>

      <if>if <condition>(<expr><name>increment</name> != 0</expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>increment_mergeinfo_up_tree</name><argument_list>(<argument><expr><name>parent_path</name></expr></argument>, <argument><expr><name>increment</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_set_has_mergeinfo</name><argument_list>(<argument><expr><name><name>parent_path</name>-&gt;<name>node</name></name></expr></argument>,
                                                   <argument><expr>(<name>value</name> != <name>NULL</name>)</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>

  <comment type="block">/* Set the property. */</comment>
  <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>proplist</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Overwrite the node's proplist. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_set_proplist</name><argument_list>(<argument><expr><name><name>parent_path</name>-&gt;<name>node</name></name></expr></argument>, <argument><expr><name>proplist</name></expr></argument>,
                                      <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Make a record of this modification in the changes table. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>add_change</name><argument_list>(<argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
                     <argument><expr><call><name>svn_fs_fs__dag_get_id</name><argument_list>(<argument><expr><name><name>parent_path</name>-&gt;<name>node</name></name></expr></argument>)</argument_list></call></expr></argument>,
                     <argument><expr><name>svn_fs_path_change_modify</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>SVN_INVALID_REVNUM</name></expr></argument>,
                     <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Determine if the properties of two path/root combinations are
   different.  Set *CHANGED_P to TRUE if the properties at PATH1 under
   ROOT1 differ from those at PATH2 under ROOT2, or FALSE otherwise.
   Both roots must be in the same filesystem. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>fs_props_changed</name><parameter_list>(<param><decl><type><name>svn_boolean_t</name> *</type><name>changed_p</name></decl></param>,
                 <param><decl><type><name>svn_fs_root_t</name> *</type><name>root1</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path1</name></decl></param>,
                 <param><decl><type><name>svn_fs_root_t</name> *</type><name>root2</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path2</name></decl></param>,
                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>node1</name></decl>, *<decl><type ref="prev"/><name>node2</name></decl>;</decl_stmt>

  <comment type="block">/* Check that roots are in the same fs. */</comment>
  <if>if <condition>(<expr><name><name>root1</name>-&gt;<name>fs</name></name> != <name><name>root2</name>-&gt;<name>fs</name></name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name>
      <argument_list>(<argument><expr><name>SVN_ERR_FS_GENERAL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Cannot compare property value between two different filesystems"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_dag</name><argument_list>(<argument><expr>&amp;<name>node1</name></expr></argument>, <argument><expr><name>root1</name></expr></argument>, <argument><expr><name>path1</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_dag</name><argument_list>(<argument><expr>&amp;<name>node2</name></expr></argument>, <argument><expr><name>root2</name></expr></argument>, <argument><expr><name>path2</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_things_different</name><argument_list>(<argument><expr><name>changed_p</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                          <argument><expr><name>node1</name></expr></argument>, <argument><expr><name>node2</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<escape char="0xc"/>
<comment type="block">/* Merges and commits. */</comment>

<comment type="block">/* Set ARGS-&gt;node to the root node of ARGS-&gt;root.  */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>get_root</name><parameter_list>(<param><decl><type><name>dag_node_t</name> **</type><name>node</name></decl></param>, <param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_dag</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr>""</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>update_ancestry</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>source_id</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>target_id</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>target_path</name></decl></param>,
                <param><decl><type><name>int</name></type> <name>source_pred_count</name></decl></param>,
                <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>node_revision_t</name> *</type><name>noderev</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><call><name>svn_fs_fs__id_txn_id</name><argument_list>(<argument><expr><name>target_id</name></expr></argument>)</argument_list></call> == <name>NULL</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name>
      <argument_list>(<argument><expr><name>SVN_ERR_FS_NOT_MUTABLE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Unexpected immutable node at '%s'"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>target_path</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__get_node_revision</name><argument_list>(<argument><expr>&amp;<name>noderev</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>target_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>noderev</name>-&gt;<name>predecessor_id</name></name> = <name>source_id</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>noderev</name>-&gt;<name>predecessor_count</name></name> = <name>source_pred_count</name></expr>;</expr_stmt>
  <if>if <condition>(<expr><name><name>noderev</name>-&gt;<name>predecessor_count</name></name> != -1</expr>)</condition><then>
    <expr_stmt><expr><name><name>noderev</name>-&gt;<name>predecessor_count</name></name>++</expr>;</expr_stmt></then></if>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__put_node_revision</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>target_id</name></expr></argument>, <argument><expr><name>noderev</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Set the contents of CONFLICT_PATH to PATH, and return an
   SVN_ERR_FS_CONFLICT error that indicates that there was a conflict
   at PATH.  Perform all allocations in POOL (except the allocation of
   CONFLICT_PATH, which should be handled outside this function).  */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>conflict_err</name><parameter_list>(<param><decl><type><name>svn_stringbuf_t</name> *</type><name>conflict_path</name></decl></param>,
             <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>svn_stringbuf_set</name><argument_list>(<argument><expr><name>conflict_path</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_FS_CONFLICT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                           <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Conflict at '%s'"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<comment type="block">/* Merge changes between ANCESTOR and SOURCE into TARGET.  ANCESTOR
 * and TARGET must be distinct node revisions.  TARGET_PATH should
 * correspond to TARGET's full path in its filesystem, and is used for
 * reporting conflict location.
 *
 * SOURCE, TARGET, and ANCESTOR are generally directories; this
 * function recursively merges the directories' contents.  If any are
 * files, this function simply returns an error whenever SOURCE,
 * TARGET, and ANCESTOR are all distinct node revisions.
 *
 * If there are differences between ANCESTOR and SOURCE that conflict
 * with changes between ANCESTOR and TARGET, this function returns an
 * SVN_ERR_FS_CONFLICT error, and updates CONFLICT_P to the name of the
 * conflicting node in TARGET, with TARGET_PATH prepended as a path.
 *
 * If there are no conflicting differences, CONFLICT_P is updated to
 * the empty string.
 *
 * CONFLICT_P must point to a valid svn_stringbuf_t.
 *
 * Do any necessary temporary allocation in POOL.
 */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>merge</name><parameter_list>(<param><decl><type><name>svn_stringbuf_t</name> *</type><name>conflict_p</name></decl></param>,
      <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>target_path</name></decl></param>,
      <param><decl><type><name>dag_node_t</name> *</type><name>target</name></decl></param>,
      <param><decl><type><name>dag_node_t</name> *</type><name>source</name></decl></param>,
      <param><decl><type><name>dag_node_t</name> *</type><name>ancestor</name></decl></param>,
      <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name></decl></param>,
      <param><decl><type><name>apr_int64_t</name> *</type><name>mergeinfo_increment_out</name></decl></param>,
      <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>source_id</name></decl>, *<decl><type ref="prev"/><name>target_id</name></decl>, *<decl><type ref="prev"/><name>ancestor_id</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>s_entries</name></decl>, *<decl><type ref="prev"/><name>t_entries</name></decl>, *<decl><type ref="prev"/><name>a_entries</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>iterpool</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>pred_count</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_int64_t</name></type> <name>mergeinfo_increment</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

  <comment type="block">/* Make sure everyone comes from the same filesystem. */</comment>
  <expr_stmt><expr><name>fs</name> = <call><name>svn_fs_fs__dag_get_fs</name><argument_list>(<argument><expr><name>ancestor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>(<name>fs</name> != <call><name>svn_fs_fs__dag_get_fs</name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call>)
      || (<name>fs</name> != <call><name>svn_fs_fs__dag_get_fs</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
    <block>{
      <return>return <expr><call><name>svn_error_create</name>
        <argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
         <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Bad merge; ancestor, source, and target not all in same fs"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

  <comment type="block">/* We have the same fs, now check it. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs__check_fs</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>source_id</name>   = <call><name>svn_fs_fs__dag_get_id</name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>target_id</name>   = <call><name>svn_fs_fs__dag_get_id</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>ancestor_id</name> = <call><name>svn_fs_fs__dag_get_id</name><argument_list>(<argument><expr><name>ancestor</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* It's improper to call this function with ancestor == target. */</comment>
  <if>if <condition>(<expr><call><name>svn_fs_fs__id_eq</name><argument_list>(<argument><expr><name>ancestor_id</name></expr></argument>, <argument><expr><name>target_id</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>id_str</name> <init>= <expr><call><name>svn_fs_fs__id_unparse</name><argument_list>(<argument><expr><name>target_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <return>return <expr><call><name>svn_error_createf</name>
        <argument_list>(<argument><expr><name>SVN_ERR_FS_GENERAL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
         <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Bad merge; target '%s' has id '%s', same as ancestor"</expr></argument>)</argument_list></call></expr></argument>,
         <argument><expr><name>target_path</name></expr></argument>, <argument><expr><name><name>id_str</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

  <expr_stmt><expr><call><name>svn_stringbuf_setempty</name><argument_list>(<argument><expr><name>conflict_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Base cases:
   * Either no change made in source, or same change as made in target.
   * Both mean nothing to merge here.
   */</comment>
  <if>if <condition>(<expr><call><name>svn_fs_fs__id_eq</name><argument_list>(<argument><expr><name>ancestor_id</name></expr></argument>, <argument><expr><name>source_id</name></expr></argument>)</argument_list></call>
      || (<call><name>svn_fs_fs__id_eq</name><argument_list>(<argument><expr><name>source_id</name></expr></argument>, <argument><expr><name>target_id</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <comment type="block">/* Else proceed, knowing all three are distinct node revisions.
   *
   * How to merge from this point:
   *
   * if (not all 3 are directories)
   *   {
   *     early exit with conflict;
   *   }
   *
   * // Property changes may only be made to up-to-date
   * // directories, because once the client commits the prop
   * // change, it bumps the directory's revision, and therefore
   * // must be able to depend on there being no other changes to
   * // that directory in the repository.
   * if (target's property list differs from ancestor's)
   *    conflict;
   *
   * For each entry NAME in the directory ANCESTOR:
   *
   *   Let ANCESTOR-ENTRY, SOURCE-ENTRY, and TARGET-ENTRY be the IDs of
   *   the name within ANCESTOR, SOURCE, and TARGET respectively.
   *   (Possibly null if NAME does not exist in SOURCE or TARGET.)
   *
   *   If ANCESTOR-ENTRY == SOURCE-ENTRY, then:
   *     No changes were made to this entry while the transaction was in
   *     progress, so do nothing to the target.
   *
   *   Else if ANCESTOR-ENTRY == TARGET-ENTRY, then:
   *     A change was made to this entry while the transaction was in
   *     process, but the transaction did not touch this entry.  Replace
   *     TARGET-ENTRY with SOURCE-ENTRY.
   *
   *   Else:
   *     Changes were made to this entry both within the transaction and
   *     to the repository while the transaction was in progress.  They
   *     must be merged or declared to be in conflict.
   *
   *     If SOURCE-ENTRY and TARGET-ENTRY are both null, that's a
   *     double delete; flag a conflict.
   *
   *     If any of the three entries is of type file, declare a conflict.
   *
   *     If either SOURCE-ENTRY or TARGET-ENTRY is not a direct
   *     modification of ANCESTOR-ENTRY (determine by comparing the
   *     node-id fields), declare a conflict.  A replacement is
   *     incompatible with a modification or other replacement--even
   *     an identical replacement.
   *
   *     Direct modifications were made to the directory ANCESTOR-ENTRY
   *     in both SOURCE and TARGET.  Recursively merge these
   *     modifications.
   *
   * For each leftover entry NAME in the directory SOURCE:
   *
   *   If NAME exists in TARGET, declare a conflict.  Even if SOURCE and
   *   TARGET are adding exactly the same thing, two additions are not
   *   auto-mergeable with each other.
   *
   *   Add NAME to TARGET with the entry from SOURCE.
   *
   * Now that we are done merging the changes from SOURCE into the
   * directory TARGET, update TARGET's predecessor to be SOURCE.
   */</comment>

  <if>if <condition>(<expr>(<call><name>svn_fs_fs__dag_node_kind</name><argument_list>(<argument><expr><name>source</name></expr></argument>)</argument_list></call> != <name>svn_node_dir</name>)
      || (<call><name>svn_fs_fs__dag_node_kind</name><argument_list>(<argument><expr><name>target</name></expr></argument>)</argument_list></call> != <name>svn_node_dir</name>)
      || (<call><name>svn_fs_fs__dag_node_kind</name><argument_list>(<argument><expr><name>ancestor</name></expr></argument>)</argument_list></call> != <name>svn_node_dir</name>)</expr>)</condition><then>
    <block>{
      <return>return <expr><call><name>conflict_err</name><argument_list>(<argument><expr><name>conflict_p</name></expr></argument>, <argument><expr><name>target_path</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>


  <comment type="block">/* Possible early merge failure: if target and ancestor have
     different property lists, then the merge should fail.
     Propchanges can *only* be committed on an up-to-date directory.
     ### TODO: see issue #418 about the inelegance of this.

     Another possible, similar, early merge failure: if source and
     ancestor have different property lists (meaning someone else
     changed directory properties while our commit transaction was
     happening), the merge should fail.  See issue #2751.
  */</comment>
  <block>{
    <decl_stmt><decl><type><name>node_revision_t</name> *</type><name>tgt_nr</name></decl>, *<decl><type ref="prev"/><name>anc_nr</name></decl>, *<decl><type ref="prev"/><name>src_nr</name></decl>;</decl_stmt>

    <comment type="block">/* Get node revisions for our id's. */</comment>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__get_node_revision</name><argument_list>(<argument><expr>&amp;<name>tgt_nr</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>target_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__get_node_revision</name><argument_list>(<argument><expr>&amp;<name>anc_nr</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>ancestor_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__get_node_revision</name><argument_list>(<argument><expr>&amp;<name>src_nr</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>source_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Now compare the prop-keys of the skels.  Note that just because
       the keys are different -doesn't- mean the proplists have
       different contents.  But merge() isn't concerned with contents;
       it doesn't do a brute-force comparison on textual contents, so
       it won't do that here either.  Checking to see if the propkey
       atoms are `equal' is enough. */</comment>
    <if>if <condition>(<expr>! <call><name>svn_fs_fs__noderev_same_rep_key</name><argument_list>(<argument><expr><name><name>tgt_nr</name>-&gt;<name>prop_rep</name></name></expr></argument>, <argument><expr><name><name>anc_nr</name>-&gt;<name>prop_rep</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <return>return <expr><call><name>conflict_err</name><argument_list>(<argument><expr><name>conflict_p</name></expr></argument>, <argument><expr><name>target_path</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
    <if>if <condition>(<expr>! <call><name>svn_fs_fs__noderev_same_rep_key</name><argument_list>(<argument><expr><name><name>src_nr</name>-&gt;<name>prop_rep</name></name></expr></argument>, <argument><expr><name><name>anc_nr</name>-&gt;<name>prop_rep</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
      <return>return <expr><call><name>conflict_err</name><argument_list>(<argument><expr><name>conflict_p</name></expr></argument>, <argument><expr><name>target_path</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
  }</block>

  <comment type="block">/* ### todo: it would be more efficient to simply check for a NULL
     entries hash where necessary below than to allocate an empty hash
     here, but another day, another day... */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_dir_entries</name><argument_list>(<argument><expr>&amp;<name>s_entries</name></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_dir_entries</name><argument_list>(<argument><expr>&amp;<name>t_entries</name></expr></argument>, <argument><expr><name>target</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_dir_entries</name><argument_list>(<argument><expr>&amp;<name>a_entries</name></expr></argument>, <argument><expr><name>ancestor</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* for each entry E in a_entries... */</comment>
  <expr_stmt><expr><name>iterpool</name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>a_entries</name></expr></argument>)</argument_list></call></expr>;</init>
       <condition><expr><name>hi</name></expr>;</condition>
       <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
    <block>{
      <decl_stmt><decl><type><name>svn_fs_dirent_t</name> *</type><name>s_entry</name></decl>, *<decl><type ref="prev"/><name>t_entry</name></decl>, *<decl><type ref="prev"/><name>a_entry</name></decl>;</decl_stmt>

      <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_ssize_t</name></type> <name>klen</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* KEY will be the entry name in ancestor, VAL the dirent */</comment>
      <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr>&amp;<name>klen</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>a_entry</name> = <name>val</name></expr>;</expr_stmt>

      <expr_stmt><expr><name>s_entry</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>s_entries</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>klen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>t_entry</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>t_entries</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>klen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* No changes were made to this entry while the transaction was
         in progress, so do nothing to the target. */</comment>
      <if>if <condition>(<expr><name>s_entry</name> &amp;&amp; <call><name>svn_fs_fs__id_eq</name><argument_list>(<argument><expr><name><name>a_entry</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name><name>s_entry</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <goto>goto <name>end</name>;</goto></then>

      <comment type="block">/* A change was made to this entry while the transaction was in
         process, but the transaction did not touch this entry. */</comment>
      <else>else <if>if <condition>(<expr><name>t_entry</name> &amp;&amp; <call><name>svn_fs_fs__id_eq</name><argument_list>(<argument><expr><name><name>a_entry</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name><name>t_entry</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>t_ent_node</name></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_node</name><argument_list>(<argument><expr>&amp;<name>t_ent_node</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>,
                                          <argument><expr><name><name>t_entry</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><call><name>svn_fs_fs__fs_supports_mergeinfo</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <block>{
              <decl_stmt><decl><type><name>apr_int64_t</name></type> <name>mergeinfo_start</name></decl>;</decl_stmt>
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_mergeinfo_count</name><argument_list>(<argument><expr>&amp;<name>mergeinfo_start</name></expr></argument>,
                                                         <argument><expr><name>t_ent_node</name></expr></argument>,
                                                         <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
              <expr_stmt><expr><name>mergeinfo_increment</name> -= <name>mergeinfo_start</name></expr>;</expr_stmt>
            }</block></then></if>

          <if>if <condition>(<expr><name>s_entry</name></expr>)</condition><then>
            <block>{
              <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>s_ent_node</name></decl>;</decl_stmt>
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_node</name><argument_list>(<argument><expr>&amp;<name>s_ent_node</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>,
                                              <argument><expr><name><name>s_entry</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

              <if>if <condition>(<expr><call><name>svn_fs_fs__fs_supports_mergeinfo</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>)</condition><then>
                <block>{
                  <decl_stmt><decl><type><name>apr_int64_t</name></type> <name>mergeinfo_end</name></decl>;</decl_stmt>
                  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_mergeinfo_count</name><argument_list>(<argument><expr>&amp;<name>mergeinfo_end</name></expr></argument>,
                                                             <argument><expr><name>s_ent_node</name></expr></argument>,
                                                             <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
                  <expr_stmt><expr><name>mergeinfo_increment</name> += <name>mergeinfo_end</name></expr>;</expr_stmt>
                }</block></then></if>

              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_set_entry</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>key</name></expr></argument>,
                                               <argument><expr><name><name>s_entry</name>-&gt;<name>id</name></name></expr></argument>,
                                               <argument><expr><name><name>s_entry</name>-&gt;<name>kind</name></name></expr></argument>,
                                               <argument><expr><name>txn_id</name></expr></argument>,
                                               <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then>
          <else>else
            <block>{
              <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_delete</name><argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></else></if>
        }</block></then>

      <comment type="block">/* Changes were made to this entry both within the transaction
         and to the repository while the transaction was in progress.
         They must be merged or declared to be in conflict. */</comment>
      <else>else
        <block>{
          <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>s_ent_node</name></decl>, *<decl><type ref="prev"/><name>t_ent_node</name></decl>, *<decl><type ref="prev"/><name>a_ent_node</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>new_tpath</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>apr_int64_t</name></type> <name>sub_mergeinfo_increment</name></decl>;</decl_stmt>

          <comment type="block">/* If SOURCE-ENTRY and TARGET-ENTRY are both null, that's a
             double delete; flag a conflict. */</comment>
          <if>if <condition>(<expr><name>s_entry</name> == <name>NULL</name> || <name>t_entry</name> == <name>NULL</name></expr>)</condition><then>
            <return>return <expr><call><name>conflict_err</name><argument_list>(<argument><expr><name>conflict_p</name></expr></argument>,
                                <argument><expr><call><name>svn_path_join</name><argument_list>(<argument><expr><name>target_path</name></expr></argument>,
                                              <argument><expr><name><name>a_entry</name>-&gt;<name>name</name></name></expr></argument>,
                                              <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

          <comment type="block">/* If any of the three entries is of type file, flag a conflict. */</comment>
          <if>if <condition>(<expr><name><name>s_entry</name>-&gt;<name>kind</name></name> == <name>svn_node_file</name>
              || <name><name>t_entry</name>-&gt;<name>kind</name></name> == <name>svn_node_file</name>
              || <name><name>a_entry</name>-&gt;<name>kind</name></name> == <name>svn_node_file</name></expr>)</condition><then>
            <return>return <expr><call><name>conflict_err</name><argument_list>(<argument><expr><name>conflict_p</name></expr></argument>,
                                <argument><expr><call><name>svn_path_join</name><argument_list>(<argument><expr><name>target_path</name></expr></argument>,
                                              <argument><expr><name><name>a_entry</name>-&gt;<name>name</name></name></expr></argument>,
                                              <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

          <comment type="block">/* If either SOURCE-ENTRY or TARGET-ENTRY is not a direct
             modification of ANCESTOR-ENTRY, declare a conflict. */</comment>
          <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>svn_fs_fs__id_node_id</name><argument_list>(<argument><expr><name><name>s_entry</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr></argument>,
                     <argument><expr><call><name>svn_fs_fs__id_node_id</name><argument_list>(<argument><expr><name><name>a_entry</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> != 0
              || <call><name>strcmp</name><argument_list>(<argument><expr><call><name>svn_fs_fs__id_copy_id</name><argument_list>(<argument><expr><name><name>s_entry</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><call><name>svn_fs_fs__id_copy_id</name><argument_list>(<argument><expr><name><name>a_entry</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> != 0
              || <call><name>strcmp</name><argument_list>(<argument><expr><call><name>svn_fs_fs__id_node_id</name><argument_list>(<argument><expr><name><name>t_entry</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><call><name>svn_fs_fs__id_node_id</name><argument_list>(<argument><expr><name><name>a_entry</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> != 0
              || <call><name>strcmp</name><argument_list>(<argument><expr><call><name>svn_fs_fs__id_copy_id</name><argument_list>(<argument><expr><name><name>t_entry</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr></argument>,
                        <argument><expr><call><name>svn_fs_fs__id_copy_id</name><argument_list>(<argument><expr><name><name>a_entry</name>-&gt;<name>id</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
            <return>return <expr><call><name>conflict_err</name><argument_list>(<argument><expr><name>conflict_p</name></expr></argument>,
                                <argument><expr><call><name>svn_path_join</name><argument_list>(<argument><expr><name>target_path</name></expr></argument>,
                                              <argument><expr><name><name>a_entry</name>-&gt;<name>name</name></name></expr></argument>,
                                              <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

          <comment type="block">/* Direct modifications were made to the directory
             ANCESTOR-ENTRY in both SOURCE and TARGET.  Recursively
             merge these modifications. */</comment>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_node</name><argument_list>(<argument><expr>&amp;<name>s_ent_node</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>,
                                          <argument><expr><name><name>s_entry</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_node</name><argument_list>(<argument><expr>&amp;<name>t_ent_node</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>,
                                          <argument><expr><name><name>t_entry</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_node</name><argument_list>(<argument><expr>&amp;<name>a_ent_node</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>,
                                          <argument><expr><name><name>a_entry</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>new_tpath</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>target_path</name></expr></argument>, <argument><expr><name><name>t_entry</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>merge</name><argument_list>(<argument><expr><name>conflict_p</name></expr></argument>, <argument><expr><name>new_tpath</name></expr></argument>,
                        <argument><expr><name>t_ent_node</name></expr></argument>, <argument><expr><name>s_ent_node</name></expr></argument>, <argument><expr><name>a_ent_node</name></expr></argument>,
                        <argument><expr><name>txn_id</name></expr></argument>,
                        <argument><expr>&amp;<name>sub_mergeinfo_increment</name></expr></argument>,
                        <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><call><name>svn_fs_fs__fs_supports_mergeinfo</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><name>mergeinfo_increment</name> += <name>sub_mergeinfo_increment</name></expr>;</expr_stmt></then></if>
        }</block></else></if></else></if>

      <comment type="block">/* We've taken care of any possible implications E could have.
         Remove it from source_entries, so it's easy later to loop
         over all the source entries that didn't exist in
         ancestor_entries. */</comment>
    <label><name>end</name>:</label>
      <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>s_entries</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>klen</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

  <comment type="block">/* For each entry E in source but not in ancestor */</comment>
  <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>s_entries</name></expr></argument>)</argument_list></call></expr>;</init>
       <condition><expr><name>hi</name></expr>;</condition>
       <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
    <block>{
      <decl_stmt><decl><type><name>svn_fs_dirent_t</name> *</type><name>s_entry</name></decl>, *<decl><type ref="prev"/><name>t_entry</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_ssize_t</name></type> <name>klen</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>s_ent_node</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr>&amp;<name>klen</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>s_entry</name> = <name>val</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>t_entry</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>t_entries</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>klen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* If NAME exists in TARGET, declare a conflict. */</comment>
      <if>if <condition>(<expr><name>t_entry</name></expr>)</condition><then>
        <return>return <expr><call><name>conflict_err</name><argument_list>(<argument><expr><name>conflict_p</name></expr></argument>,
                            <argument><expr><call><name>svn_path_join</name><argument_list>(<argument><expr><name>target_path</name></expr></argument>,
                                          <argument><expr><name><name>t_entry</name>-&gt;<name>name</name></name></expr></argument>,
                                          <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_node</name><argument_list>(<argument><expr>&amp;<name>s_ent_node</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>,
                                      <argument><expr><name><name>s_entry</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><call><name>svn_fs_fs__fs_supports_mergeinfo</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><name>apr_int64_t</name></type> <name>mergeinfo_s</name></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_mergeinfo_count</name><argument_list>(<argument><expr>&amp;<name>mergeinfo_s</name></expr></argument>,
                                                     <argument><expr><name>s_ent_node</name></expr></argument>,
                                                     <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>mergeinfo_increment</name> += <name>mergeinfo_s</name></expr>;</expr_stmt>
        }</block></then></if>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_set_entry</name>
              <argument_list>(<argument><expr><name>target</name></expr></argument>, <argument><expr><name><name>s_entry</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name><name>s_entry</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name><name>s_entry</name>-&gt;<name>kind</name></name></expr></argument>,
               <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>
  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_predecessor_count</name><argument_list>(<argument><expr>&amp;<name>pred_count</name></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>update_ancestry</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>source_id</name></expr></argument>, <argument><expr><name>target_id</name></expr></argument>, <argument><expr><name>target_path</name></expr></argument>,
                          <argument><expr><name>pred_count</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><call><name>svn_fs_fs__fs_supports_mergeinfo</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_increment_mergeinfo_count</name><argument_list>(<argument><expr><name>target</name></expr></argument>,
                                                     <argument><expr><name>mergeinfo_increment</name></expr></argument>,
                                                     <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <if>if <condition>(<expr><name>mergeinfo_increment_out</name></expr>)</condition><then>
    <expr_stmt><expr>*<name>mergeinfo_increment_out</name> = <name>mergeinfo_increment</name></expr>;</expr_stmt></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Merge changes between an ancestor and BATON-&gt;source_node into
   BATON-&gt;txn.  The ancestor is either BATON-&gt;ancestor_node, or if
   that is null, BATON-&gt;txn's base node.

   If the merge is successful, BATON-&gt;txn's base will become
   BATON-&gt;source_node, and its root node will have a new ID, a
   successor of BATON-&gt;source_node. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>merge_changes</name><parameter_list>(<param><decl><type><name>dag_node_t</name> *</type><name>ancestor_node</name></decl></param>,
              <param><decl><type><name>dag_node_t</name> *</type><name>source_node</name></decl></param>,
              <param><decl><type><name>svn_fs_txn_t</name> *</type><name>txn</name></decl></param>,
              <param><decl><type><name>svn_stringbuf_t</name> *</type><name>conflict</name></decl></param>,
              <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>txn_root_node</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>source_id</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name> <init>= <expr><name><name>txn</name>-&gt;<name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name> <init>= <expr><name><name>txn</name>-&gt;<name>id</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>source_id</name> = <call><name>svn_fs_fs__dag_get_id</name><argument_list>(<argument><expr><name>source_node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_txn_root</name><argument_list>(<argument><expr>&amp;<name>txn_root_node</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>ancestor_node</name> == <name>NULL</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_txn_base_root</name><argument_list>(<argument><expr>&amp;<name>ancestor_node</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>,
                                           <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <if>if <condition>(<expr><call><name>svn_fs_fs__id_eq</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_id</name><argument_list>(<argument><expr><name>ancestor_node</name></expr></argument>)</argument_list></call></expr></argument>,
                       <argument><expr><call><name>svn_fs_fs__dag_get_id</name><argument_list>(<argument><expr><name>txn_root_node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <comment type="block">/* If no changes have been made in TXN since its current base,
         then it can't conflict with any changes since that base.  So
         we just set *both* its base and root to source, making TXN
         in effect a repeat of source. */</comment>

      <comment type="block">/* ### kff todo: this would, of course, be a mighty silly thing
         for the caller to do, and we might want to consider whether
         this response is really appropriate. */</comment>
      <expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>merge</name><argument_list>(<argument><expr><name>conflict</name></expr></argument>, <argument><expr>"/"</expr></argument>, <argument><expr><name>txn_root_node</name></expr></argument>,
                  <argument><expr><name>source_node</name></expr></argument>, <argument><expr><name>ancestor_node</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__commit_txn</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>conflict_p</name></decl></param>,
                      <param><decl><type><name>svn_revnum_t</name> *</type><name>new_rev_p</name></decl></param>,
                      <param><decl><type><name>svn_fs_txn_t</name> *</type><name>txn</name></decl></param>,
                      <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* How do commits work in Subversion?
   *
   * When you're ready to commit, here's what you have:
   *
   *    1. A transaction, with a mutable tree hanging off it.
   *    2. A base revision, against which TXN_TREE was made.
   *    3. A latest revision, which may be newer than the base rev.
   *
   * The problem is that if latest != base, then one can't simply
   * attach the txn root as the root of the new revision, because that
   * would lose all the changes between base and latest.  It is also
   * not acceptable to insist that base == latest; in a busy
   * repository, commits happen too fast to insist that everyone keep
   * their entire tree up-to-date at all times.  Non-overlapping
   * changes should not interfere with each other.
   *
   * The solution is to merge the changes between base and latest into
   * the txn tree [see the function merge()].  The txn tree is the
   * only one of the three trees that is mutable, so it has to be the
   * one to adjust.
   *
   * You might have to adjust it more than once, if a new latest
   * revision gets committed while you were merging in the previous
   * one.  For example:
   *
   *    1. Jane starts txn T, based at revision 6.
   *    2. Someone commits (or already committed) revision 7.
   *    3. Jane's starts merging the changes between 6 and 7 into T.
   *    4. Meanwhile, someone commits revision 8.
   *    5. Jane finishes the 6--&gt;7 merge.  T could now be committed
   *       against a latest revision of 7, if only that were still the
   *       latest.  Unfortunately, 8 is now the latest, so...
   *    6. Jane starts merging the changes between 7 and 8 into T.
   *    7. Meanwhile, no one commits any new revisions.  Whew.
   *    8. Jane commits T, creating revision 9, whose tree is exactly
   *       T's tree, except immutable now.
   *
   * Lather, rinse, repeat.
   */</comment>

  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>new_rev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name> <init>= <expr><name><name>txn</name>-&gt;<name>fs</name></name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Initialize output params. */</comment>
  <expr_stmt><expr><name>new_rev</name> = <name>SVN_INVALID_REVNUM</name></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>conflict_p</name></expr>)</condition><then>
    <expr_stmt><expr>*<name>conflict_p</name> = <name>NULL</name></expr>;</expr_stmt></then></if>

  <while>while <condition>(<expr>1729</expr>)</condition>
    <block>{
      <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>youngish_rev</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>youngish_root</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>youngish_root_node</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>conflict</name> <init>= <expr><call><name>svn_stringbuf_create</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <comment type="block">/* Get the *current* youngest revision, in one short-lived
         Berkeley transaction.  (We don't want the revisions table
         locked while we do the main merge.)  We call it "youngish"
         because new revisions might get committed after we've
         obtained it. */</comment>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__youngest_rev</name><argument_list>(<argument><expr>&amp;<name>youngish_rev</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__revision_root</name><argument_list>(<argument><expr>&amp;<name>youngish_root</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>youngish_rev</name></expr></argument>,
                                       <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Get the dag node for the youngest revision, also in one
         Berkeley transaction.  Later we'll use it as the SOURCE
         argument to a merge, and if the merge succeeds, this youngest
         root node will become the new base root for the svn txn that
         was the target of the merge (but note that the youngest rev
         may have changed by then -- that's why we're careful to get
         this root in its own bdb txn here). */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_root</name><argument_list>(<argument><expr>&amp;<name>youngish_root_node</name></expr></argument>, <argument><expr><name>youngish_root</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Try to merge.  If the merge succeeds, the base root node of
         TARGET's txn will become the same as youngish_root_node, so
         any future merges will only be between that node and whatever
         the root node of the youngest rev is by then. */</comment>
      <expr_stmt><expr><name>err</name> = <call><name>merge_changes</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>youngish_root_node</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>, <argument><expr><name>conflict</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
        <block>{
          <if>if <condition>(<expr>(<name><name>err</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_FS_CONFLICT</name>) &amp;&amp; <name>conflict_p</name></expr>)</condition><then>
            <expr_stmt><expr>*<name>conflict_p</name> = <name><name>conflict</name>-&gt;<name>data</name></name></expr>;</expr_stmt></then></if>
          <return>return <expr><name>err</name></expr>;</return>
        }</block></then></if>
      <expr_stmt><expr><name><name>txn</name>-&gt;<name>base_rev</name></name> = <name>youngish_rev</name></expr>;</expr_stmt>

      <comment type="block">/* Try to commit. */</comment>
      <expr_stmt><expr><name>err</name> = <call><name>svn_fs_fs__commit</name><argument_list>(<argument><expr>&amp;<name>new_rev</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>err</name> &amp;&amp; (<name><name>err</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_FS_TXN_OUT_OF_DATE</name>)</expr>)</condition><then>
        <block>{
          <comment type="block">/* Did someone else finish committing a new revision while we
             were in mid-merge or mid-commit?  If so, we'll need to
             loop again to merge the new changes in, then try to
             commit again.  Or if that's not what happened, then just
             return the error. */</comment>
          <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>youngest_rev</name></decl>;</decl_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__youngest_rev</name><argument_list>(<argument><expr>&amp;<name>youngest_rev</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>youngest_rev</name> == <name>youngish_rev</name></expr>)</condition><then>
            <return>return <expr><name>err</name></expr>;</return></then>
          <else>else
            <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
        }</block></then>
      <else>else <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
        <block>{
          <return>return <expr><name>err</name></expr>;</return>
        }</block></then>
      <else>else
        <block>{
          <comment type="block">/* Set the return value -- our brand spankin' new revision! */</comment>
          <expr_stmt><expr>*<name>new_rev_p</name> = <name>new_rev</name></expr>;</expr_stmt>
          <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
        }</block></else></if></else></if>
    }</block></while>

  <comment type="block">/* NOTREACHED */</comment>
}</block></function>


<comment type="block">/* Merge changes between two nodes into a third node.  Given nodes
   SOURCE_PATH under SOURCE_ROOT, TARGET_PATH under TARGET_ROOT and
   ANCESTOR_PATH under ANCESTOR_ROOT, modify target to contain all the
   changes between the ancestor and source.  If there are conflicts,
   return SVN_ERR_FS_CONFLICT and set *CONFLICT_P to a textual
   description of the offending changes.  Perform any temporary
   allocations in POOL. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>fs_merge</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>conflict_p</name></decl></param>,
         <param><decl><type><name>svn_fs_root_t</name> *</type><name>source_root</name></decl></param>,
         <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>source_path</name></decl></param>,
         <param><decl><type><name>svn_fs_root_t</name> *</type><name>target_root</name></decl></param>,
         <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>target_path</name></decl></param>,
         <param><decl><type><name>svn_fs_root_t</name> *</type><name>ancestor_root</name></decl></param>,
         <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ancestor_path</name></decl></param>,
         <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>source</name></decl>, *<decl><type ref="prev"/><name>ancestor</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_txn_t</name> *</type><name>txn</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>conflict</name> <init>= <expr><call><name>svn_stringbuf_create</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr>! <name><name>target_root</name>-&gt;<name>is_txn_root</name></name></expr>)</condition><then>
    <return>return <expr><call><name>SVN_FS__NOT_TXN</name><argument_list>(<argument><expr><name>target_root</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Paranoia. */</comment>
  <if>if <condition>(<expr>(<name><name>source_root</name>-&gt;<name>fs</name></name> != <name><name>ancestor_root</name>-&gt;<name>fs</name></name>)
      || (<name><name>target_root</name>-&gt;<name>fs</name></name> != <name><name>ancestor_root</name>-&gt;<name>fs</name></name>)</expr>)</condition><then>
    <block>{
      <return>return <expr><call><name>svn_error_create</name>
        <argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
         <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Bad merge; ancestor, source, and target not all in same fs"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then></if>

  <comment type="block">/* ### kff todo: is there any compelling reason to get the nodes in
     one db transaction?  Right now we don't; txn_body_get_root() gets
     one node at a time.  This will probably need to change:

     Jim Blandy &lt;jimb@zwingli.cygnus.com&gt; writes:
     &gt; svn_fs_merge needs to be a single transaction, to protect it against
     &gt; people deleting parents of nodes it's working on, etc.
  */</comment>

  <comment type="block">/* Get the ancestor node. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_root</name><argument_list>(<argument><expr>&amp;<name>ancestor</name></expr></argument>, <argument><expr><name>ancestor_root</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Get the source node. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_root</name><argument_list>(<argument><expr>&amp;<name>source</name></expr></argument>, <argument><expr><name>source_root</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Open a txn for the txn root into which we're merging. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__open_txn</name><argument_list>(<argument><expr>&amp;<name>txn</name></expr></argument>, <argument><expr><name><name>ancestor_root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name><name>target_root</name>-&gt;<name>txn</name></name></expr></argument>,
                              <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Merge changes between ANCESTOR and SOURCE into TXN. */</comment>
  <expr_stmt><expr><name>err</name> = <call><name>merge_changes</name><argument_list>(<argument><expr><name>ancestor</name></expr></argument>, <argument><expr><name>source</name></expr></argument>, <argument><expr><name>txn</name></expr></argument>, <argument><expr><name>conflict</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>err</name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr>(<name><name>err</name>-&gt;<name>apr_err</name></name> == <name>SVN_ERR_FS_CONFLICT</name>) &amp;&amp; <name>conflict_p</name></expr>)</condition><then>
        <expr_stmt><expr>*<name>conflict_p</name> = <name><name>conflict</name>-&gt;<name>data</name></name></expr>;</expr_stmt></then></if>
      <return>return <expr><name>err</name></expr>;</return>
    }</block></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_fs_fs__deltify</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                   <param><decl><type><name>svn_revnum_t</name></type> <name>revision</name></decl></param>,
                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* Deltify is a no-op for fs_fs. */</comment>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<escape char="0xc"/>
<comment type="block">/* Directories.  */</comment>

<comment type="block">/* Set *TABLE_P to a newly allocated APR hash table containing the
   entries of the directory at PATH in ROOT.  The keys of the table
   are entry names, as byte strings, excluding the final null
   character; the table's values are pointers to svn_fs_dirent_t
   structures.  Allocate the table and its contents in POOL. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>fs_dir_entries</name><parameter_list>(<param><decl><type><name>apr_hash_t</name> **</type><name>table_p</name></decl></param>,
               <param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
               <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
               <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>node</name></decl>;</decl_stmt>

  <comment type="block">/* Get the entries for this path in the caller's pool. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_dag</name><argument_list>(<argument><expr>&amp;<name>node</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_dir_entries</name><argument_list>(<argument><expr><name>table_p</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Create a new directory named PATH in ROOT.  The new directory has
   no entries, and no properties.  ROOT must be the root of a
   transaction, not a revision.  Do any necessary temporary allocation
   in POOL.  */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>fs_make_dir</name><parameter_list>(<param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
            <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
            <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>parent_path_t</name> *</type><name>parent_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>sub_dir</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name> <init>= <expr><name><name>root</name>-&gt;<name>txn</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>open_path</name><argument_list>(<argument><expr>&amp;<name>parent_path</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>open_path_last_optional</name></expr></argument>,
                    <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check (recursively) to see if some lock is 'reserving' a path at
     that location, or even some child-path; if so, check that we can
     use it. */</comment>
  <if>if <condition>(<expr><name><name>root</name>-&gt;<name>txn_flags</name></name> &amp; <name>SVN_FS_TXN_CHECK_LOCKS</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__allow_locked_operation</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                                              <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* If there's already a sub-directory by that name, complain.  This
     also catches the case of trying to make a subdirectory named `/'.  */</comment>
  <if>if <condition>(<expr><name><name>parent_path</name>-&gt;<name>node</name></name></expr>)</condition><then>
    <return>return <expr><call><name>SVN_FS__ALREADY_EXISTS</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Create the subdirectory.  */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>make_path_mutable</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>parent_path</name>-&gt;<name>parent</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_make_dir</name><argument_list>(<argument><expr>&amp;<name>sub_dir</name></expr></argument>,
                                  <argument><expr><name><name>parent_path</name>-&gt;<name>parent</name>-&gt;<name>node</name></name></expr></argument>,
                                  <argument><expr><call><name>parent_path_path</name><argument_list>(<argument><expr><name><name>parent_path</name>-&gt;<name>parent</name></name></expr></argument>,
                                                   <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                                  <argument><expr><name><name>parent_path</name>-&gt;<name>entry</name></name></expr></argument>,
                                  <argument><expr><name>txn_id</name></expr></argument>,
                                  <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Add this directory to the path cache. */</comment>
  <expr_stmt><expr><call><name>dag_node_cache_set</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><call><name>parent_path_path</name><argument_list>(<argument><expr><name>parent_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>sub_dir</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Make a record of this modification in the changes table. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>add_change</name><argument_list>(<argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>svn_fs_fs__dag_get_id</name><argument_list>(<argument><expr><name>sub_dir</name></expr></argument>)</argument_list></call></expr></argument>,
                     <argument><expr><name>svn_fs_path_change_add</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>SVN_INVALID_REVNUM</name></expr></argument>,
                     <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Delete the node at PATH under ROOT.  ROOT must be a transaction
   root.  Perform temporary allocations in POOL. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>fs_delete_node</name><parameter_list>(<param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
               <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
               <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>parent_path_t</name> *</type><name>parent_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name> <init>= <expr><name><name>root</name>-&gt;<name>txn</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_int64_t</name></type> <name>mergeinfo_count</name></decl>;</decl_stmt>

  <if>if <condition>(<expr>! <name><name>root</name>-&gt;<name>is_txn_root</name></name></expr>)</condition><then>
    <return>return <expr><call><name>SVN_FS__NOT_TXN</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>open_path</name><argument_list>(<argument><expr>&amp;<name>parent_path</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* We can't remove the root of the filesystem.  */</comment>
  <if>if <condition>(<expr>! <name><name>parent_path</name>-&gt;<name>parent</name></name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_FS_ROOT_DIR</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                            <argument><expr><call><name>_</name><argument_list>(<argument><expr>"The root directory cannot be deleted"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Check to see if path (or any child thereof) is locked; if so,
     check that we can use the existing lock(s). */</comment>
  <if>if <condition>(<expr><name><name>root</name>-&gt;<name>txn_flags</name></name> &amp; <name>SVN_FS_TXN_CHECK_LOCKS</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__allow_locked_operation</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                                              <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* Make the parent directory mutable, and do the deletion.  */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>make_path_mutable</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>parent_path</name>-&gt;<name>parent</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><call><name>svn_fs_fs__fs_supports_mergeinfo</name><argument_list>(<argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_mergeinfo_count</name><argument_list>(<argument><expr>&amp;<name>mergeinfo_count</name></expr></argument>,
                                               <argument><expr><name><name>parent_path</name>-&gt;<name>node</name></name></expr></argument>,
                                               <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_delete</name><argument_list>(<argument><expr><name><name>parent_path</name>-&gt;<name>parent</name>-&gt;<name>node</name></name></expr></argument>,
                                <argument><expr><name><name>parent_path</name>-&gt;<name>entry</name></name></expr></argument>,
                                <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Remove this node and any children from the path cache. */</comment>
  <expr_stmt><expr><call><name>dag_node_cache_invalidate</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><call><name>parent_path_path</name><argument_list>(<argument><expr><name>parent_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Update mergeinfo counts for parents */</comment>
  <if>if <condition>(<expr><call><name>svn_fs_fs__fs_supports_mergeinfo</name><argument_list>(<argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>)</argument_list></call> &amp;&amp; <name>mergeinfo_count</name> &gt; 0</expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>increment_mergeinfo_up_tree</name><argument_list>(<argument><expr><name><name>parent_path</name>-&gt;<name>parent</name></name></expr></argument>,
                                        <argument><expr>-<name>mergeinfo_count</name></expr></argument>,
                                        <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* Make a record of this modification in the changes table. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>add_change</name><argument_list>(<argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
                     <argument><expr><call><name>svn_fs_fs__dag_get_id</name><argument_list>(<argument><expr><name><name>parent_path</name>-&gt;<name>node</name></name></expr></argument>)</argument_list></call></expr></argument>,
                     <argument><expr><name>svn_fs_path_change_delete</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                     <argument><expr><name>SVN_INVALID_REVNUM</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Set *SAME_P to TRUE if FS1 and FS2 have the same UUID, else set to FALSE.
   Use POOL for temporary allocation only.
   Note: this code is duplicated between libsvn_fs_fs and libsvn_fs_base. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>fs_same_p</name><parameter_list>(<param><decl><type><name>svn_boolean_t</name> *</type><name>same_p</name></decl></param>,
          <param><decl><type><name>svn_fs_t</name> *</type><name>fs1</name></decl></param>,
          <param><decl><type><name>svn_fs_t</name> *</type><name>fs2</name></decl></param>,
          <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>uuid1</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>uuid2</name></decl>;</decl_stmt>

  <comment type="block">/* Random thought: if fetching UUIDs to compare filesystems is too
     expensive, one solution would be to cache the UUID in each fs
     object (copying the UUID into fs-&gt;pool, of course). */</comment>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>fs1</name>-&gt;<name>vtable</name>-&gt;<name>get_uuid</name></name><argument_list>(<argument><expr><name>fs1</name></expr></argument>, <argument><expr>&amp;<name>uuid1</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>fs2</name>-&gt;<name>vtable</name>-&gt;<name>get_uuid</name></name><argument_list>(<argument><expr><name>fs2</name></expr></argument>, <argument><expr>&amp;<name>uuid2</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>same_p</name> = ! <call><name>strcmp</name><argument_list>(<argument><expr><name>uuid1</name></expr></argument>, <argument><expr><name>uuid2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Copy the node at FROM_PATH under FROM_ROOT to TO_PATH under
   TO_ROOT.  If PRESERVE_HISTORY is set, then the copy is recorded in
   the copies table.  Perform temporary allocations in POOL. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>copy_helper</name><parameter_list>(<param><decl><type><name>svn_fs_root_t</name> *</type><name>from_root</name></decl></param>,
            <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>from_path</name></decl></param>,
            <param><decl><type><name>svn_fs_root_t</name> *</type><name>to_root</name></decl></param>,
            <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>to_path</name></decl></param>,
            <param><decl><type><name>svn_boolean_t</name></type> <name>preserve_history</name></decl></param>,
            <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>from_node</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>parent_path_t</name> *</type><name>to_parent_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name> <init>= <expr><name><name>to_root</name>-&gt;<name>txn</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>same_p</name></decl>;</decl_stmt>

  <comment type="block">/* Use an error check, not an assert, because even the caller cannot
     guarantee that a filesystem's UUID has not changed "on the fly". */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>fs_same_p</name><argument_list>(<argument><expr>&amp;<name>same_p</name></expr></argument>, <argument><expr><name><name>from_root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name><name>to_root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>! <name>same_p</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name>
      <argument_list>(<argument><expr><name>SVN_ERR_UNSUPPORTED_FEATURE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Cannot copy between two different filesystems ('%s' and '%s')"</expr></argument>)</argument_list></call></expr></argument>,
       <argument><expr><name><name>from_root</name>-&gt;<name>fs</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name><name>to_root</name>-&gt;<name>fs</name>-&gt;<name>path</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <if>if <condition>(<expr><name><name>from_root</name>-&gt;<name>is_txn_root</name></name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name>
      <argument_list>(<argument><expr><name>SVN_ERR_UNSUPPORTED_FEATURE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Copy from mutable tree not currently supported"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Get the NODE for FROM_PATH in FROM_ROOT.*/</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_dag</name><argument_list>(<argument><expr>&amp;<name>from_node</name></expr></argument>, <argument><expr><name>from_root</name></expr></argument>, <argument><expr><name>from_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Build up the parent path from TO_PATH in TO_ROOT.  If the last
     component does not exist, it's not that big a deal.  We'll just
     make one there. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>open_path</name><argument_list>(<argument><expr>&amp;<name>to_parent_path</name></expr></argument>, <argument><expr><name>to_root</name></expr></argument>, <argument><expr><name>to_path</name></expr></argument>,
                    <argument><expr><name>open_path_last_optional</name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check to see if path (or any child thereof) is locked; if so,
     check that we can use the existing lock(s). */</comment>
  <if>if <condition>(<expr><name><name>to_root</name>-&gt;<name>txn_flags</name></name> &amp; <name>SVN_FS_TXN_CHECK_LOCKS</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__allow_locked_operation</name><argument_list>(<argument><expr><name>to_path</name></expr></argument>, <argument><expr><name><name>to_root</name>-&gt;<name>fs</name></name></expr></argument>,
                                              <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* If the destination node already exists as the same node as the
     source (in other words, this operation would result in nothing
     happening at all), just do nothing an return successfully,
     proud that you saved yourself from a tiresome task. */</comment>
  <if>if <condition>(<expr><name><name>to_parent_path</name>-&gt;<name>node</name></name> &amp;&amp;
      <call><name>svn_fs_fs__id_eq</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_id</name><argument_list>(<argument><expr><name>from_node</name></expr></argument>)</argument_list></call></expr></argument>,
                       <argument><expr><call><name>svn_fs_fs__dag_get_id</name><argument_list>(<argument><expr><name><name>to_parent_path</name>-&gt;<name>node</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <if>if <condition>(<expr>! <name><name>from_root</name>-&gt;<name>is_txn_root</name></name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>svn_fs_path_change_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>new_node</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>from_canonpath</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_int64_t</name></type> <name>mergeinfo_start</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_int64_t</name></type> <name>mergeinfo_end</name></decl>;</decl_stmt>

      <comment type="block">/* If TO_PATH already existed prior to the copy, note that this
         operation is a replacement, not an addition. */</comment>
      <if>if <condition>(<expr><name><name>to_parent_path</name>-&gt;<name>node</name></name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name>kind</name> = <name>svn_fs_path_change_replace</name></expr>;</expr_stmt>
          <if>if <condition>(<expr><call><name>svn_fs_fs__fs_supports_mergeinfo</name><argument_list>(<argument><expr><name><name>to_root</name>-&gt;<name>fs</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_mergeinfo_count</name><argument_list>(<argument><expr>&amp;<name>mergeinfo_start</name></expr></argument>,
                                                       <argument><expr><name><name>to_parent_path</name>-&gt;<name>node</name></name></expr></argument>,
                                                       <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
        }</block></then>
      <else>else
        <block>{
          <expr_stmt><expr><name>kind</name> = <name>svn_fs_path_change_add</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>mergeinfo_start</name> = 0</expr>;</expr_stmt>
        }</block></else></if>

      <if>if <condition>(<expr><call><name>svn_fs_fs__fs_supports_mergeinfo</name><argument_list>(<argument><expr><name><name>to_root</name>-&gt;<name>fs</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_mergeinfo_count</name><argument_list>(<argument><expr>&amp;<name>mergeinfo_end</name></expr></argument>,
                                                   <argument><expr><name>from_node</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

      <comment type="block">/* Make sure the target node's parents are mutable.  */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>make_path_mutable</name><argument_list>(<argument><expr><name>to_root</name></expr></argument>, <argument><expr><name><name>to_parent_path</name>-&gt;<name>parent</name></name></expr></argument>,
                                <argument><expr><name>to_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Canonicalize the copyfrom path. */</comment>
      <expr_stmt><expr><name>from_canonpath</name> = <call><name>svn_fs__canonicalize_abspath</name><argument_list>(<argument><expr><name>from_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_copy</name><argument_list>(<argument><expr><name><name>to_parent_path</name>-&gt;<name>parent</name>-&gt;<name>node</name></name></expr></argument>,
                                  <argument><expr><name><name>to_parent_path</name>-&gt;<name>entry</name></name></expr></argument>,
                                  <argument><expr><name>from_node</name></expr></argument>,
                                  <argument><expr><name>preserve_history</name></expr></argument>,
                                  <argument><expr><name><name>from_root</name>-&gt;<name>rev</name></name></expr></argument>,
                                  <argument><expr><name>from_canonpath</name></expr></argument>,
                                  <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr><name>kind</name> == <name>svn_fs_path_change_replace</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>dag_node_cache_invalidate</name><argument_list>(<argument><expr><name>to_root</name></expr></argument>, <argument><expr><call><name>parent_path_path</name><argument_list>(<argument><expr><name>to_parent_path</name></expr></argument>,
                                                            <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

      <if>if <condition>(<expr><call><name>svn_fs_fs__fs_supports_mergeinfo</name><argument_list>(<argument><expr><name><name>to_root</name>-&gt;<name>fs</name></name></expr></argument>)</argument_list></call>
          &amp;&amp; <name>mergeinfo_start</name> != <name>mergeinfo_end</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>increment_mergeinfo_up_tree</name><argument_list>(<argument><expr><name><name>to_parent_path</name>-&gt;<name>parent</name></name></expr></argument>,
                                            <argument><expr><name>mergeinfo_end</name> - <name>mergeinfo_start</name></expr></argument>,
                                            <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

      <comment type="block">/* Make a record of this modification in the changes table. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_dag</name><argument_list>(<argument><expr>&amp;<name>new_node</name></expr></argument>, <argument><expr><name>to_root</name></expr></argument>, <argument><expr><name>to_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>add_change</name><argument_list>(<argument><expr><name><name>to_root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>to_path</name></expr></argument>,
                         <argument><expr><call><name>svn_fs_fs__dag_get_id</name><argument_list>(<argument><expr><name>new_node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>kind</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                         <argument><expr><name><name>from_root</name>-&gt;<name>rev</name></name></expr></argument>, <argument><expr><name>from_canonpath</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <comment type="block">/* See IZ Issue #436 */</comment>
      <comment type="block">/* Copying from transaction roots not currently available.

         ### cmpilato todo someday: make this not so. :-) Note that
         when copying from mutable trees, you have to make sure that
         you aren't creating a cyclic graph filesystem, and a simple
         referencing operation won't cut it.  Currently, we should not
         be able to reach this clause, and the interface reports that
         this only works from immutable trees anyway, but JimB has
         stated that this requirement need not be necessary in the
         future. */</comment>

      <expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Create a copy of FROM_PATH in FROM_ROOT named TO_PATH in TO_ROOT.
   If FROM_PATH is a directory, copy it recursively.  Temporary
   allocations are from POOL.*/</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>fs_copy</name><parameter_list>(<param><decl><type><name>svn_fs_root_t</name> *</type><name>from_root</name></decl></param>,
        <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>from_path</name></decl></param>,
        <param><decl><type><name>svn_fs_root_t</name> *</type><name>to_root</name></decl></param>,
        <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>to_path</name></decl></param>,
        <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>copy_helper</name><argument_list>(<argument><expr><name>from_root</name></expr></argument>, <argument><expr><name>from_path</name></expr></argument>, <argument><expr><name>to_root</name></expr></argument>, <argument><expr><name>to_path</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<comment type="block">/* Create a copy of FROM_PATH in FROM_ROOT named TO_PATH in TO_ROOT.
   If FROM_PATH is a directory, copy it recursively.  No history is
   preserved.  Temporary allocations are from POOL. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>fs_revision_link</name><parameter_list>(<param><decl><type><name>svn_fs_root_t</name> *</type><name>from_root</name></decl></param>,
                 <param><decl><type><name>svn_fs_root_t</name> *</type><name>to_root</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>! <name><name>to_root</name>-&gt;<name>is_txn_root</name></name></expr>)</condition><then>
    <return>return <expr><call><name>SVN_FS__NOT_TXN</name><argument_list>(<argument><expr><name>to_root</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <return>return <expr><call><name>copy_helper</name><argument_list>(<argument><expr><name>from_root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>to_root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<comment type="block">/* Discover the copy ancestry of PATH under ROOT.  Return a relevant
   ancestor/revision combination in *PATH_P and *REV_P.  Temporary
   allocations are in POOL. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>fs_copied_from</name><parameter_list>(<param><decl><type><name>svn_revnum_t</name> *</type><name>rev_p</name></decl></param>,
               <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>path_p</name></decl></param>,
               <param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
               <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
               <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>node</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copyfrom_path</name></decl>, *<decl><type ref="prev"/><name>copyfrom_str</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>copyfrom_rev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>str</name></decl>, *<decl><type ref="prev"/><name>last_str</name></decl>, *<decl><type ref="prev"/><name>buf</name></decl>;</decl_stmt>

  <comment type="block">/* Check to see if there is a cached version of this copyfrom
     entry. */</comment>
  <if>if <condition>(<expr>! <name><name>root</name>-&gt;<name>is_txn_root</name></name></expr>)</condition><then> <block>{
    <decl_stmt><decl><type><name>fs_rev_root_data_t</name> *</type><name>frd</name> <init>= <expr><name><name>root</name>-&gt;<name>fsap_data</name></name></expr></init></decl>;</decl_stmt>
    <expr_stmt><expr><name>copyfrom_str</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name><name>frd</name>-&gt;<name>copyfrom_cache</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  }</block></then></if>

  <if>if <condition>(<expr><name>copyfrom_str</name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>copyfrom_str</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
        <block>{
          <comment type="block">/* We have a cached entry that says there is no copyfrom
             here. */</comment>
          <expr_stmt><expr><name>copyfrom_rev</name> = <name>SVN_INVALID_REVNUM</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>copyfrom_path</name> = <name>NULL</name></expr>;</expr_stmt>
        }</block></then>
      <else>else
        <block>{
          <comment type="block">/* Parse the copyfrom string for our cached entry. */</comment>
          <expr_stmt><expr><name>buf</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>copyfrom_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>str</name> = <call><name>apr_strtok</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr>" "</expr></argument>, <argument><expr>&amp;<name>last_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>copyfrom_rev</name> = <call><name>atol</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>copyfrom_path</name> = <name>last_str</name></expr>;</expr_stmt>
        }</block></else></if>
    }</block></then>
  <else>else
    <block>{
      <comment type="block">/* There is no cached entry, look it up the old-fashioned
         way. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_dag</name><argument_list>(<argument><expr>&amp;<name>node</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_copyfrom_rev</name><argument_list>(<argument><expr>&amp;<name>copyfrom_rev</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_copyfrom_path</name><argument_list>(<argument><expr>&amp;<name>copyfrom_path</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

  <expr_stmt><expr>*<name>rev_p</name>  = <name>copyfrom_rev</name></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>path_p</name> = <name>copyfrom_path</name></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<escape char="0xc"/>
<comment type="block">/* Files.  */</comment>

<comment type="block">/* Create the empty file PATH under ROOT.  Temporary allocations are
   in POOL. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>fs_make_file</name><parameter_list>(<param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
             <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
             <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>parent_path_t</name> *</type><name>parent_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>child</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name> <init>= <expr><name><name>root</name>-&gt;<name>txn</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>open_path</name><argument_list>(<argument><expr>&amp;<name>parent_path</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>open_path_last_optional</name></expr></argument>,
                    <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If there's already a file by that name, complain.
     This also catches the case of trying to make a file named `/'.  */</comment>
  <if>if <condition>(<expr><name><name>parent_path</name>-&gt;<name>node</name></name></expr>)</condition><then>
    <return>return <expr><call><name>SVN_FS__ALREADY_EXISTS</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Check (non-recursively) to see if path is locked;  if so, check
     that we can use it. */</comment>
  <if>if <condition>(<expr><name><name>root</name>-&gt;<name>txn_flags</name></name> &amp; <name>SVN_FS_TXN_CHECK_LOCKS</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__allow_locked_operation</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>,
                                              <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* Create the file.  */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>make_path_mutable</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>parent_path</name>-&gt;<name>parent</name></name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_make_file</name><argument_list>(<argument><expr>&amp;<name>child</name></expr></argument>,
                                   <argument><expr><name><name>parent_path</name>-&gt;<name>parent</name>-&gt;<name>node</name></name></expr></argument>,
                                   <argument><expr><call><name>parent_path_path</name><argument_list>(<argument><expr><name><name>parent_path</name>-&gt;<name>parent</name></name></expr></argument>,
                                                    <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                                   <argument><expr><name><name>parent_path</name>-&gt;<name>entry</name></name></expr></argument>,
                                   <argument><expr><name>txn_id</name></expr></argument>,
                                   <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Add this file to the path cache. */</comment>
  <expr_stmt><expr><call><name>dag_node_cache_set</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><call><name>parent_path_path</name><argument_list>(<argument><expr><name>parent_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>child</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Make a record of this modification in the changes table. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>add_change</name><argument_list>(<argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>svn_fs_fs__dag_get_id</name><argument_list>(<argument><expr><name>child</name></expr></argument>)</argument_list></call></expr></argument>,
                     <argument><expr><name>svn_fs_path_change_add</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>SVN_INVALID_REVNUM</name></expr></argument>,
                     <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Set *LENGTH_P to the size of the file PATH under ROOT.  Temporary
   allocations are in POOL. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>fs_file_length</name><parameter_list>(<param><decl><type><name>svn_filesize_t</name> *</type><name>length_p</name></decl></param>,
               <param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
               <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
               <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>file</name></decl>;</decl_stmt>

  <comment type="block">/* First create a dag_node_t from the root/path pair. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_dag</name><argument_list>(<argument><expr>&amp;<name>file</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Now fetch its length */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_file_length</name><argument_list>(<argument><expr><name>length_p</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Set DIGEST to the MD5 checksum of PATH under ROOT.  Temporary
   allocations are from POOL. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>fs_file_md5_checksum</name><parameter_list>(<param><decl><type><name>unsigned</name> <name>char</name></type> <name><name>digest</name><index>[]</index></name></decl></param>,
                     <param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
                     <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                     <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>file</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_dag</name><argument_list>(<argument><expr>&amp;<name>file</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>svn_fs_fs__dag_file_checksum</name><argument_list>(<argument><expr><name>digest</name></expr></argument>, <argument><expr><name>file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<comment type="block">/* --- Machinery for svn_fs_file_contents() ---  */</comment>

<comment type="block">/* Set *CONTENTS to a readable stream that will return the contents of
   PATH under ROOT.  The stream is allocated in POOL. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>fs_file_contents</name><parameter_list>(<param><decl><type><name>svn_stream_t</name> **</type><name>contents</name></decl></param>,
                 <param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>node</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>file_stream</name></decl>;</decl_stmt>

  <comment type="block">/* First create a dag_node_t from the root/path pair. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_dag</name><argument_list>(<argument><expr>&amp;<name>node</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Then create a readable stream from the dag_node_t. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_contents</name><argument_list>(<argument><expr>&amp;<name>file_stream</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>contents</name> = <name>file_stream</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* --- End machinery for svn_fs_file_contents() ---  */</comment>



<comment type="block">/* --- Machinery for svn_fs_apply_textdelta() ---  */</comment>


<comment type="block">/* Local baton type for all the helper functions below. */</comment>
<typedef>typedef <type><struct>struct <name>txdelta_baton_t</name>
<block>{
  <comment type="block">/* This is the custom-built window consumer given to us by the delta
     library;  it uniquely knows how to read data from our designated
     "source" stream, interpret the window, and write data to our
     designated "target" stream (in this case, our repos file.) */</comment>
  <decl_stmt><decl><type><name>svn_txdelta_window_handler_t</name></type> <name>interpreter</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> *</type><name>interpreter_baton</name></decl>;</decl_stmt>

  <comment type="block">/* The original file info */</comment>
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>

  <comment type="block">/* Derived from the file info */</comment>
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>node</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>source_stream</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>target_stream</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>string_stream</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>target_string</name></decl>;</decl_stmt>

  <comment type="block">/* Hex MD5 digest for the base text against which a delta is to be
     applied, and for the resultant fulltext, respectively.  Either or
     both may be null, in which case ignored. */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>base_checksum</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>result_checksum</name></decl>;</decl_stmt>

  <comment type="block">/* Pool used by db txns */</comment>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>

}</block></struct></type> <name>txdelta_baton_t</name>;</typedef>


<comment type="block">/* ### see comment in window_consumer() regarding this function. */</comment>

<comment type="block">/* Helper function of generic type `svn_write_fn_t'.  Implements a
   writable stream which appends to an svn_stringbuf_t. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>write_to_string</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name></decl></param>, <param><decl><type><name>apr_size_t</name> *</type><name>len</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>txdelta_baton_t</name> *</type><name>tb</name> <init>= <expr>(<name>txdelta_baton_t</name> *) <name>baton</name></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>svn_stringbuf_appendbytes</name><argument_list>(<argument><expr><name><name>tb</name>-&gt;<name>target_string</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr>*<name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>



<comment type="block">/* The main window handler returned by svn_fs_apply_textdelta. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>window_consumer</name><parameter_list>(<param><decl><type><name>svn_txdelta_window_t</name> *</type><name>window</name></decl></param>, <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>txdelta_baton_t</name> *</type><name>tb</name> <init>= <expr>(<name>txdelta_baton_t</name> *) <name>baton</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Send the window right through to the custom window interpreter.
     In theory, the interpreter will then write more data to
     cb-&gt;target_string. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>tb</name>-&gt;<name>interpreter</name></name><argument_list>(<argument><expr><name>window</name></expr></argument>, <argument><expr><name><name>tb</name>-&gt;<name>interpreter_baton</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* ### the write_to_string() callback for the txdelta's output stream
     ### should be doing all the flush determination logic, not here.
     ### in a drastic case, a window could generate a LOT more than the
     ### maximum buffer size. we want to flush to the underlying target
     ### stream much sooner (e.g. also in a streamy fashion). also, by
     ### moving this logic inside the stream, the stream becomes nice
     ### and encapsulated: it holds all the logic about buffering and
     ### flushing.
     ###
     ### further: I believe the buffering should be removed from tree.c
     ### the buffering should go into the target_stream itself, which
     ### is defined by reps-string.c. Specifically, I think the
     ### rep_write_contents() function will handle the buffering and
     ### the spill to the underlying DB. by locating it there, then
     ### anybody who gets a writable stream for FS content can take
     ### advantage of the buffering capability. this will be important
     ### when we export an FS API function for writing a fulltext into
     ### the FS, rather than forcing that fulltext thru apply_textdelta.
  */</comment>

  <comment type="block">/* Check to see if we need to purge the portion of the contents that
     have been written thus far. */</comment>
  <if>if <condition>(<expr>(! <name>window</name>) || (<name><name>tb</name>-&gt;<name>target_string</name>-&gt;<name>len</name></name> &gt; <name>WRITE_BUFFER_SIZE</name>)</expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name> <init>= <expr><name><name>tb</name>-&gt;<name>target_string</name>-&gt;<name>len</name></name></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_write</name><argument_list>(<argument><expr><name><name>tb</name>-&gt;<name>target_stream</name></name></expr></argument>,
                               <argument><expr><name><name>tb</name>-&gt;<name>target_string</name>-&gt;<name>data</name></name></expr></argument>,
                               <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>svn_stringbuf_set</name><argument_list>(<argument><expr><name><name>tb</name>-&gt;<name>target_string</name></name></expr></argument>, <argument><expr>""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* Is the window NULL?  If so, we're done. */</comment>
  <if>if <condition>(<expr>! <name>window</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* Close the internal-use stream.  ### This used to be inside of
         txn_body_fulltext_finalize_edits(), but that invoked a nested
         Berkeley DB transaction -- scandalous! */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_close</name><argument_list>(<argument><expr><name><name>tb</name>-&gt;<name>target_stream</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_finalize_edits</name><argument_list>(<argument><expr><name><name>tb</name>-&gt;<name>node</name></name></expr></argument>, <argument><expr><name><name>tb</name>-&gt;<name>result_checksum</name></name></expr></argument>,
                                            <argument><expr><name><name>tb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Helper function for fs_apply_textdelta.  BATON is of type
   txdelta_baton_t. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>apply_textdelta</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>txdelta_baton_t</name> *</type><name>tb</name> <init>= <expr>(<name>txdelta_baton_t</name> *) <name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>parent_path_t</name> *</type><name>parent_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name> <init>= <expr><name><name>tb</name>-&gt;<name>root</name>-&gt;<name>txn</name></name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Call open_path with no flags, as we want this to return an error
     if the node for which we are searching doesn't exist. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>open_path</name><argument_list>(<argument><expr>&amp;<name>parent_path</name></expr></argument>, <argument><expr><name><name>tb</name>-&gt;<name>root</name></name></expr></argument>, <argument><expr><name><name>tb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check (non-recursively) to see if path is locked; if so, check
     that we can use it. */</comment>
  <if>if <condition>(<expr><name><name>tb</name>-&gt;<name>root</name>-&gt;<name>txn_flags</name></name> &amp; <name>SVN_FS_TXN_CHECK_LOCKS</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__allow_locked_operation</name><argument_list>(<argument><expr><name><name>tb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name><name>tb</name>-&gt;<name>root</name>-&gt;<name>fs</name></name></expr></argument>,
                                              <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* Now, make sure this path is mutable. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>make_path_mutable</name><argument_list>(<argument><expr><name><name>tb</name>-&gt;<name>root</name></name></expr></argument>, <argument><expr><name>parent_path</name></expr></argument>, <argument><expr><name><name>tb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>tb</name>-&gt;<name>node</name></name> = <name><name>parent_path</name>-&gt;<name>node</name></name></expr>;</expr_stmt>

  <if>if <condition>(<expr><name><name>tb</name>-&gt;<name>base_checksum</name></name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>digest</name><index>[<expr><name>APR_MD5_DIGESTSIZE</name></expr>]</index></name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>hex</name></decl>;</decl_stmt>

      <comment type="block">/* Until we finalize the node, its data_key points to the old
         contents, in other words, the base text. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_file_checksum</name><argument_list>(<argument><expr><name>digest</name></expr></argument>, <argument><expr><name><name>tb</name>-&gt;<name>node</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>hex</name> = <call><name>svn_md5_digest_to_cstring</name><argument_list>(<argument><expr><name>digest</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>hex</name> &amp;&amp; (<call><name>strcmp</name><argument_list>(<argument><expr><name><name>tb</name>-&gt;<name>base_checksum</name></name></expr></argument>, <argument><expr><name>hex</name></expr></argument>)</argument_list></call> != 0)</expr>)</condition><then>
        <return>return <expr><call><name>svn_error_createf</name>
          <argument_list>(<argument><expr><name>SVN_ERR_CHECKSUM_MISMATCH</name></expr></argument>,
           <argument><expr><name>NULL</name></expr></argument>,
           <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Base checksum mismatch on '%s':\n"
             "   expected:  %s\n"
             "     actual:  %s\n"</expr></argument>)</argument_list></call></expr></argument>,
           <argument><expr><name><name>tb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name><name>tb</name>-&gt;<name>base_checksum</name></name></expr></argument>, <argument><expr><name>hex</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
    }</block></then></if>

  <comment type="block">/* Make a readable "source" stream out of the current contents of
     ROOT/PATH; obviously, this must done in the context of a db_txn.
     The stream is returned in tb-&gt;source_stream. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_contents</name><argument_list>(<argument><expr>&amp;(<name><name>tb</name>-&gt;<name>source_stream</name></name>)</expr></argument>,
                                      <argument><expr><name><name>tb</name>-&gt;<name>node</name></name></expr></argument>, <argument><expr><name><name>tb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Make a writable "target" stream */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_edit_stream</name><argument_list>(<argument><expr>&amp;(<name><name>tb</name>-&gt;<name>target_stream</name></name>)</expr></argument>, <argument><expr><name><name>tb</name>-&gt;<name>node</name></name></expr></argument>,
                                         <argument><expr><name><name>tb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Make a writable "string" stream which writes data to
     tb-&gt;target_string. */</comment>
  <expr_stmt><expr><name><name>tb</name>-&gt;<name>target_string</name></name> = <call><name>svn_stringbuf_create</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr><name><name>tb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>tb</name>-&gt;<name>string_stream</name></name> = <call><name>svn_stream_create</name><argument_list>(<argument><expr><name>tb</name></expr></argument>, <argument><expr><name><name>tb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_stream_set_write</name><argument_list>(<argument><expr><name><name>tb</name>-&gt;<name>string_stream</name></name></expr></argument>, <argument><expr><name>write_to_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Now, create a custom window handler that uses our two streams. */</comment>
  <expr_stmt><expr><call><name>svn_txdelta_apply</name><argument_list>(<argument><expr><name><name>tb</name>-&gt;<name>source_stream</name></name></expr></argument>,
                    <argument><expr><name><name>tb</name>-&gt;<name>string_stream</name></name></expr></argument>,
                    <argument><expr><name>NULL</name></expr></argument>,
                    <argument><expr><name><name>tb</name>-&gt;<name>path</name></name></expr></argument>,
                    <argument><expr><name><name>tb</name>-&gt;<name>pool</name></name></expr></argument>,
                    <argument><expr>&amp;(<name><name>tb</name>-&gt;<name>interpreter</name></name>)</expr></argument>,
                    <argument><expr>&amp;(<name><name>tb</name>-&gt;<name>interpreter_baton</name></name>)</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Make a record of this modification in the changes table. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>add_change</name><argument_list>(<argument><expr><name><name>tb</name>-&gt;<name>root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name><name>tb</name>-&gt;<name>path</name></name></expr></argument>,
                     <argument><expr><call><name>svn_fs_fs__dag_get_id</name><argument_list>(<argument><expr><name><name>tb</name>-&gt;<name>node</name></name></expr></argument>)</argument_list></call></expr></argument>,
                     <argument><expr><name>svn_fs_path_change_modify</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>SVN_INVALID_REVNUM</name></expr></argument>,
                     <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Set *CONTENTS_P and *CONTENTS_BATON_P to a window handler and baton
   that will accept text delta windows to modify the contents of PATH
   under ROOT.  Allocations are in POOL. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>fs_apply_textdelta</name><parameter_list>(<param><decl><type><name>svn_txdelta_window_handler_t</name> *</type><name>contents_p</name></decl></param>,
                   <param><decl><type><name>void</name> **</type><name>contents_baton_p</name></decl></param>,
                   <param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>base_checksum</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>result_checksum</name></decl></param>,
                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>txdelta_baton_t</name> *</type><name>tb</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>tb</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>tb</name>-&gt;<name>root</name></name> = <name>root</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>tb</name>-&gt;<name>path</name></name> = <name>path</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>tb</name>-&gt;<name>pool</name></name> = <name>pool</name></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>base_checksum</name></expr>)</condition><then>
    <expr_stmt><expr><name><name>tb</name>-&gt;<name>base_checksum</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>base_checksum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name><name>tb</name>-&gt;<name>base_checksum</name></name> = <name>NULL</name></expr>;</expr_stmt></else></if>

  <if>if <condition>(<expr><name>result_checksum</name></expr>)</condition><then>
    <expr_stmt><expr><name><name>tb</name>-&gt;<name>result_checksum</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>result_checksum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name><name>tb</name>-&gt;<name>result_checksum</name></name> = <name>NULL</name></expr>;</expr_stmt></else></if>


  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>apply_textdelta</name><argument_list>(<argument><expr><name>tb</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>contents_p</name> = <name>window_consumer</name></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>contents_baton_p</name> = <name>tb</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* --- End machinery for svn_fs_apply_textdelta() ---  */</comment>

<comment type="block">/* --- Machinery for svn_fs_apply_text() ---  */</comment>

<comment type="block">/* Baton for svn_fs_apply_text(). */</comment>
<struct>struct <name>text_baton_t</name>
<block>{
  <comment type="block">/* The original file info */</comment>
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>

  <comment type="block">/* Derived from the file info */</comment>
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>node</name></decl>;</decl_stmt>

  <comment type="block">/* The returned stream that will accept the file's new contents. */</comment>
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>stream</name></decl>;</decl_stmt>

  <comment type="block">/* The actual fs stream that the returned stream will write to. */</comment>
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>file_stream</name></decl>;</decl_stmt>

  <comment type="block">/* Hex MD5 digest for the final fulltext written to the file.  May
     be null, in which case ignored. */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>result_checksum</name></decl>;</decl_stmt>

  <comment type="block">/* Pool used by db txns */</comment>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>
}</block>;</struct>


<comment type="block">/* A wrapper around svn_fs_fs__dag_finalize_edits, but for
 * fulltext data, not text deltas.  Closes BATON-&gt;file_stream.
 *
 * Note: If you're confused about how this function relates to another
 * of similar name, think of it this way:
 *
 * svn_fs_apply_textdelta() ==&gt; ... ==&gt; txn_body_txdelta_finalize_edits()
 * svn_fs_apply_text()      ==&gt; ... ==&gt; txn_body_fulltext_finalize_edits()
 */</comment>

<comment type="block">/* Write function for the publically returned stream. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>text_stream_writer</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name></decl></param>,
                   <param><decl><type><name>apr_size_t</name> *</type><name>len</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>text_baton_t</name> *</type><name>tb</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Psst, here's some data.  Pass it on to the -real- file stream. */</comment>
  <return>return <expr><call><name>svn_stream_write</name><argument_list>(<argument><expr><name><name>tb</name>-&gt;<name>file_stream</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* Close function for the publically returned stream. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>text_stream_closer</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>text_baton_t</name> *</type><name>tb</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Close the internal-use stream.  ### This used to be inside of
     txn_body_fulltext_finalize_edits(), but that invoked a nested
     Berkeley DB transaction -- scandalous! */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_close</name><argument_list>(<argument><expr><name><name>tb</name>-&gt;<name>file_stream</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Need to tell fs that we're done sending text */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_finalize_edits</name><argument_list>(<argument><expr><name><name>tb</name>-&gt;<name>node</name></name></expr></argument>, <argument><expr><name><name>tb</name>-&gt;<name>result_checksum</name></name></expr></argument>,
                                        <argument><expr><name><name>tb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Helper function for fs_apply_text.  BATON is of type
   text_baton_t. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>apply_text</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>text_baton_t</name> *</type><name>tb</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>parent_path_t</name> *</type><name>parent_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn_id</name> <init>= <expr><name><name>tb</name>-&gt;<name>root</name>-&gt;<name>txn</name></name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Call open_path with no flags, as we want this to return an error
     if the node for which we are searching doesn't exist. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>open_path</name><argument_list>(<argument><expr>&amp;<name>parent_path</name></expr></argument>, <argument><expr><name><name>tb</name>-&gt;<name>root</name></name></expr></argument>, <argument><expr><name><name>tb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check (non-recursively) to see if path is locked; if so, check
     that we can use it. */</comment>
  <if>if <condition>(<expr><name><name>tb</name>-&gt;<name>root</name>-&gt;<name>txn_flags</name></name> &amp; <name>SVN_FS_TXN_CHECK_LOCKS</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__allow_locked_operation</name><argument_list>(<argument><expr><name><name>tb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name><name>tb</name>-&gt;<name>root</name>-&gt;<name>fs</name></name></expr></argument>,
                                              <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* Now, make sure this path is mutable. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>make_path_mutable</name><argument_list>(<argument><expr><name><name>tb</name>-&gt;<name>root</name></name></expr></argument>, <argument><expr><name>parent_path</name></expr></argument>, <argument><expr><name><name>tb</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>tb</name>-&gt;<name>node</name></name> = <name><name>parent_path</name>-&gt;<name>node</name></name></expr>;</expr_stmt>

  <comment type="block">/* Make a writable stream for replacing the file's text. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_edit_stream</name><argument_list>(<argument><expr>&amp;(<name><name>tb</name>-&gt;<name>file_stream</name></name>)</expr></argument>, <argument><expr><name><name>tb</name>-&gt;<name>node</name></name></expr></argument>,
                                         <argument><expr><name><name>tb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Create a 'returnable' stream which writes to the file_stream. */</comment>
  <expr_stmt><expr><name><name>tb</name>-&gt;<name>stream</name></name> = <call><name>svn_stream_create</name><argument_list>(<argument><expr><name>tb</name></expr></argument>, <argument><expr><name><name>tb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_stream_set_write</name><argument_list>(<argument><expr><name><name>tb</name>-&gt;<name>stream</name></name></expr></argument>, <argument><expr><name>text_stream_writer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_stream_set_close</name><argument_list>(<argument><expr><name><name>tb</name>-&gt;<name>stream</name></name></expr></argument>, <argument><expr><name>text_stream_closer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Make a record of this modification in the changes table. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>add_change</name><argument_list>(<argument><expr><name><name>tb</name>-&gt;<name>root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name>txn_id</name></expr></argument>, <argument><expr><name><name>tb</name>-&gt;<name>path</name></name></expr></argument>,
                     <argument><expr><call><name>svn_fs_fs__dag_get_id</name><argument_list>(<argument><expr><name><name>tb</name>-&gt;<name>node</name></name></expr></argument>)</argument_list></call></expr></argument>,
                     <argument><expr><name>svn_fs_path_change_modify</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>SVN_INVALID_REVNUM</name></expr></argument>,
                     <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Return a writable stream that will set the contents of PATH under
   ROOT.  RESULT_CHECKSUM is the MD5 checksum of the final result.
   Temporary allocations are in POOL. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>fs_apply_text</name><parameter_list>(<param><decl><type><name>svn_stream_t</name> **</type><name>contents_p</name></decl></param>,
              <param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
              <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
              <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>result_checksum</name></decl></param>,
              <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>text_baton_t</name> *</type><name>tb</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>tb</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>tb</name>-&gt;<name>root</name></name> = <name>root</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>tb</name>-&gt;<name>path</name></name> = <name>path</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>tb</name>-&gt;<name>pool</name></name> = <name>pool</name></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>result_checksum</name></expr>)</condition><then>
    <expr_stmt><expr><name><name>tb</name>-&gt;<name>result_checksum</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>result_checksum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name><name>tb</name>-&gt;<name>result_checksum</name></name> = <name>NULL</name></expr>;</expr_stmt></else></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>apply_text</name><argument_list>(<argument><expr><name>tb</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>contents_p</name> = <name><name>tb</name>-&gt;<name>stream</name></name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* --- End machinery for svn_fs_apply_text() ---  */</comment>


<comment type="block">/* Check if the contents of PATH1 under ROOT1 are different from the
   contents of PATH2 under ROOT2.  If they are different set
   *CHANGED_P to TRUE, otherwise set it to FALSE. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>fs_contents_changed</name><parameter_list>(<param><decl><type><name>svn_boolean_t</name> *</type><name>changed_p</name></decl></param>,
                    <param><decl><type><name>svn_fs_root_t</name> *</type><name>root1</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path1</name></decl></param>,
                    <param><decl><type><name>svn_fs_root_t</name> *</type><name>root2</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path2</name></decl></param>,
                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>node1</name></decl>, *<decl><type ref="prev"/><name>node2</name></decl>;</decl_stmt>

  <comment type="block">/* Check that roots are in the same fs. */</comment>
  <if>if <condition>(<expr><name><name>root1</name>-&gt;<name>fs</name></name> != <name><name>root2</name>-&gt;<name>fs</name></name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name>
      <argument_list>(<argument><expr><name>SVN_ERR_FS_GENERAL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Cannot compare file contents between two different filesystems"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Check that both paths are files. */</comment>
  <block>{
    <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__check_path</name><argument_list>(<argument><expr>&amp;<name>kind</name></expr></argument>, <argument><expr><name>root1</name></expr></argument>, <argument><expr><name>path1</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>kind</name> != <name>svn_node_file</name></expr>)</condition><then>
      <return>return <expr><call><name>svn_error_createf</name>
        <argument_list>(<argument><expr><name>SVN_ERR_FS_GENERAL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"'%s' is not a file"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>path1</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__check_path</name><argument_list>(<argument><expr>&amp;<name>kind</name></expr></argument>, <argument><expr><name>root2</name></expr></argument>, <argument><expr><name>path2</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if>if <condition>(<expr><name>kind</name> != <name>svn_node_file</name></expr>)</condition><then>
      <return>return <expr><call><name>svn_error_createf</name>
        <argument_list>(<argument><expr><name>SVN_ERR_FS_GENERAL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr>"'%s' is not a file"</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>path2</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
  }</block>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_dag</name><argument_list>(<argument><expr>&amp;<name>node1</name></expr></argument>, <argument><expr><name>root1</name></expr></argument>, <argument><expr><name>path1</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_dag</name><argument_list>(<argument><expr>&amp;<name>node2</name></expr></argument>, <argument><expr><name>root2</name></expr></argument>, <argument><expr><name>path2</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_things_different</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>changed_p</name></expr></argument>,
                                          <argument><expr><name>node1</name></expr></argument>, <argument><expr><name>node2</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<escape char="0xc"/>
<comment type="block">/* Public interface to computing file text deltas.  */</comment>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>fs_get_file_delta_stream</name><parameter_list>(<param><decl><type><name>svn_txdelta_stream_t</name> **</type><name>stream_p</name></decl></param>,
                         <param><decl><type><name>svn_fs_root_t</name> *</type><name>source_root</name></decl></param>,
                         <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>source_path</name></decl></param>,
                         <param><decl><type><name>svn_fs_root_t</name> *</type><name>target_root</name></decl></param>,
                         <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>target_path</name></decl></param>,
                         <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>source_node</name></decl>, *<decl><type ref="prev"/><name>target_node</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>source_root</name> &amp;&amp; <name>source_path</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_dag</name><argument_list>(<argument><expr>&amp;<name>source_node</name></expr></argument>, <argument><expr><name>source_root</name></expr></argument>, <argument><expr><name>source_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name>source_node</name> = <name>NULL</name></expr>;</expr_stmt></else></if>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_dag</name><argument_list>(<argument><expr>&amp;<name>target_node</name></expr></argument>, <argument><expr><name>target_root</name></expr></argument>, <argument><expr><name>target_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Create a delta stream that turns the source into the target.  */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_file_delta_stream</name><argument_list>(<argument><expr><name>stream_p</name></expr></argument>, <argument><expr><name>source_node</name></expr></argument>,
                                               <argument><expr><name>target_node</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<escape char="0xc"/>
<comment type="block">/* Finding Changes */</comment>

<comment type="block">/* Set *CHANGED_PATHS_P to a newly allocated hash containing
   descriptions of the paths changed under ROOT.  The hash is keyed
   with const char * paths an dhas svn_fs_path_change_t * values.  Use
   POOL for all allocations. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>fs_paths_changed</name><parameter_list>(<param><decl><type><name>apr_hash_t</name> **</type><name>changed_paths_p</name></decl></param>,
                 <param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name><name>root</name>-&gt;<name>is_txn_root</name></name></expr>)</condition><then>
    <return>return <expr><call><name>svn_fs_fs__txn_changes_fetch</name><argument_list>(<argument><expr><name>changed_paths_p</name></expr></argument>, <argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name><name>root</name>-&gt;<name>txn</name></name></expr></argument>,
                                        <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return></then>
  <else>else
    <block>{
      <decl_stmt><decl><type><name>fs_rev_root_data_t</name> *</type><name>frd</name> <init>= <expr><name><name>root</name>-&gt;<name>fsap_data</name></name></expr></init></decl>;</decl_stmt>
      <return>return <expr><call><name>svn_fs_fs__paths_changed</name><argument_list>(<argument><expr><name>changed_paths_p</name></expr></argument>, <argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>, <argument><expr><name><name>root</name>-&gt;<name>rev</name></name></expr></argument>,
                                      <argument><expr><name><name>frd</name>-&gt;<name>copyfrom_cache</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
    }</block></else></if>
}</block></function>


<escape char="0xc"/>
<comment type="block">/* Our coolio opaque history object. */</comment>
<typedef>typedef <type><struct>struct
<block>{
  <comment type="block">/* filesystem object */</comment>
  <decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl>;</decl_stmt>

  <comment type="block">/* path and revision of historical location */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>revision</name></decl>;</decl_stmt>

  <comment type="block">/* internal-use hints about where to resume the history search. */</comment>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path_hint</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>rev_hint</name></decl>;</decl_stmt>

  <comment type="block">/* FALSE until the first call to svn_fs_history_prev(). */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>is_interesting</name></decl>;</decl_stmt>
}</block></struct></type> <name>fs_history_data_t</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>svn_fs_history_t</name> *</type>
<name>assemble_history</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                 <param><decl><type><name>svn_revnum_t</name></type> <name>revision</name></decl></param>,
                 <param><decl><type><name>svn_boolean_t</name></type> <name>is_interesting</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path_hint</name></decl></param>,
                 <param><decl><type><name>svn_revnum_t</name></type> <name>rev_hint</name></decl></param>,
                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>;</function_decl>


<comment type="block">/* Set *HISTORY_P to an opaque node history object which represents
   PATH under ROOT.  ROOT must be a revision root.  Use POOL for all
   allocations. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>fs_node_history</name><parameter_list>(<param><decl><type><name>svn_fs_history_t</name> **</type><name>history_p</name></decl></param>,
                <param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>

  <comment type="block">/* We require a revision root. */</comment>
  <if>if <condition>(<expr><name><name>root</name>-&gt;<name>is_txn_root</name></name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_FS_NOT_REVISION_ROOT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* And we require that the path exist in the root. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__check_path</name><argument_list>(<argument><expr>&amp;<name>kind</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>kind</name> == <name>svn_node_none</name></expr>)</condition><then>
    <return>return <expr><call><name>SVN_FS__NOT_FOUND</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Okay, all seems well.  Build our history object and return it. */</comment>
  <expr_stmt><expr>*<name>history_p</name> = <call><name>assemble_history</name><argument_list>(<argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>,
                                <argument><expr><call><name>svn_fs__canonicalize_abspath</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                                <argument><expr><name><name>root</name>-&gt;<name>rev</name></name></expr></argument>, <argument><expr><name>FALSE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                <argument><expr><name>SVN_INVALID_REVNUM</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Find the youngest copyroot for path PARENT_PATH or its parents in
   filesystem FS, and store the copyroot in *REV_P and *PATH_P.
   Perform all allocations in POOL. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>find_youngest_copyroot</name><parameter_list>(<param><decl><type><name>svn_revnum_t</name> *</type><name>rev_p</name></decl></param>,
                       <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>path_p</name></decl></param>,
                       <param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                       <param><decl><type><name>parent_path_t</name> *</type><name>parent_path</name></decl></param>,
                       <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>rev_mine</name></decl>, <decl><type ref="prev"/><name>rev_parent</name> <init>= <expr>-1</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path_mine</name></decl>, *<decl><type ref="prev"/><name>path_parent</name></decl>;</decl_stmt>

  <comment type="block">/* First find our parent's youngest copyroot. */</comment>
  <if>if <condition>(<expr><name><name>parent_path</name>-&gt;<name>parent</name></name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>find_youngest_copyroot</name><argument_list>(<argument><expr>&amp;<name>rev_parent</name></expr></argument>, <argument><expr>&amp;<name>path_parent</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>,
                                   <argument><expr><name><name>parent_path</name>-&gt;<name>parent</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* Find our copyroot. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_copyroot</name><argument_list>(<argument><expr>&amp;<name>rev_mine</name></expr></argument>, <argument><expr>&amp;<name>path_mine</name></expr></argument>,
                                      <argument><expr><name><name>parent_path</name>-&gt;<name>node</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If a parent and child were copied to in the same revision, prefer
     the child copy target, since it is the copy relevant to the
     history of the child. */</comment>
  <if>if <condition>(<expr><name>rev_mine</name> &gt;= <name>rev_parent</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr>*<name>rev_p</name> = <name>rev_mine</name></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>path_p</name> = <name>path_mine</name></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <expr_stmt><expr>*<name>rev_p</name> = <name>rev_parent</name></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>path_p</name> = <name>path_parent</name></expr>;</expr_stmt>
    }</block></else></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type><name>fs_closest_copy</name><parameter_list>(<param><decl><type><name>svn_fs_root_t</name> **</type><name>root_p</name></decl></param>,
                                    <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>path_p</name></decl></param>,
                                    <param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
                                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name> <init>= <expr><name><name>root</name>-&gt;<name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>parent_path_t</name> *</type><name>parent_path</name></decl>, *<decl><type ref="prev"/><name>copy_dst_parent_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>copy_dst_rev</name></decl>, <decl><type ref="prev"/><name>created_rev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copy_dst_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>copy_dst_root</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>copy_dst_node</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_node_kind_t</name></type> <name>kind</name></decl>;</decl_stmt>

  <comment type="block">/* Initialize return values. */</comment>
  <expr_stmt><expr>*<name>root_p</name> = <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>path_p</name> = <name>NULL</name></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>open_path</name><argument_list>(<argument><expr>&amp;<name>parent_path</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Find the youngest copyroot in the path of this node-rev, which
     will indicate the target of the innermost copy affecting the
     node-rev. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>find_youngest_copyroot</name><argument_list>(<argument><expr>&amp;<name>copy_dst_rev</name></expr></argument>, <argument><expr>&amp;<name>copy_dst_path</name></expr></argument>,
                                 <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>parent_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>copy_dst_rev</name> == 0</expr>)</condition><then>  <comment type="block">/* There are no copies affecting this node-rev. */</comment>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <comment type="block">/* It is possible that this node was created from scratch at some
     revision between COPY_DST_REV and REV.  Make sure that PATH
     exists as of COPY_DST_REV and is related to this node-rev. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__revision_root</name><argument_list>(<argument><expr>&amp;<name>copy_dst_root</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>copy_dst_rev</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__check_path</name><argument_list>(<argument><expr>&amp;<name>kind</name></expr></argument>, <argument><expr><name>copy_dst_root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>kind</name> == <name>svn_node_none</name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>open_path</name><argument_list>(<argument><expr>&amp;<name>copy_dst_parent_path</name></expr></argument>, <argument><expr><name>copy_dst_root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
                    <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>copy_dst_node</name> = <name><name>copy_dst_parent_path</name>-&gt;<name>node</name></name></expr>;</expr_stmt>
  <if>if <condition>(<expr>! <call><name>svn_fs_fs__id_check_related</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_id</name><argument_list>(<argument><expr><name>copy_dst_node</name></expr></argument>)</argument_list></call></expr></argument>,
                                    <argument><expr><call><name>svn_fs_fs__dag_get_id</name><argument_list>(<argument><expr><name><name>parent_path</name>-&gt;<name>node</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <comment type="block">/* One final check must be done here.  If you copy a directory and
     create a new entity somewhere beneath that directory in the same
     txn, then we can't claim that the copy affected the new entity.
     For example, if you do:

        copy dir1 dir2
        create dir2/new-thing
        commit

     then dir2/new-thing was not affected by the copy of dir1 to dir2.
     We detect this situation by asking if PATH@COPY_DST_REV's
     created-rev is COPY_DST_REV, and that node-revision has no
     predecessors, then there is no relevant closest copy.
  */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_revision</name><argument_list>(<argument><expr>&amp;<name>created_rev</name></expr></argument>, <argument><expr><name>copy_dst_node</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>created_rev</name> == <name>copy_dst_rev</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>pred</name></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_predecessor_id</name><argument_list>(<argument><expr>&amp;<name>pred</name></expr></argument>, <argument><expr><name>copy_dst_node</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr>! <name>pred</name></expr>)</condition><then>
        <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>
    }</block></then></if>

  <comment type="block">/* The copy destination checks out.  Return it. */</comment>
  <expr_stmt><expr>*<name>root_p</name> = <name>copy_dst_root</name></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>path_p</name> = <name>copy_dst_path</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Set *PREV_PATH and *PREV_REV to the path and revision which
   represent the location at which PATH in FS was located immediately
   prior to REVISION iff there was a copy operation (to PATH or one of
   its parent directories) between that previous location and
   PATH@REVISION.

   If there was no such copy operation in that portion of PATH's
   history, set *PREV_PATH to NULL and *PREV_REV to SVN_INVALID_REVNUM.  */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>prev_location</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>prev_path</name></decl></param>,
              <param><decl><type><name>svn_revnum_t</name> *</type><name>prev_rev</name></decl></param>,
              <param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
              <param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
              <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
              <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copy_path</name></decl>, *<decl><type ref="prev"/><name>copy_src_path</name></decl>, *<decl><type ref="prev"/><name>remainder</name> <init>= <expr>""</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>copy_root</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>copy_src_rev</name></decl>;</decl_stmt>

  <comment type="block">/* Ask about the most recent copy which affected PATH@REVISION.  If
     there was no such copy, we're done.  */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>fs_closest_copy</name><argument_list>(<argument><expr>&amp;<name>copy_root</name></expr></argument>, <argument><expr>&amp;<name>copy_path</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>! <name>copy_root</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr>*<name>prev_rev</name> = <name>SVN_INVALID_REVNUM</name></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>prev_path</name> = <name>NULL</name></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>

  <comment type="block">/* Ultimately, it's not the path of the closest copy's source that
     we care about -- it's our own path's location in the copy source
     revision.  So we'll tack the relative path that expresses the
     difference between the copy destination and our path in the copy
     revision onto the copy source path to determine this information.

     In other words, if our path is "/branches/my-branch/foo/bar", and
     we know that the closest relevant copy was a copy of "/trunk" to
     "/branches/my-branch", then that relative path under the copy
     destination is "/foo/bar".  Tacking that onto the copy source
     path tells us that our path was located at "/trunk/foo/bar"
     before the copy.
  */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>fs_copied_from</name><argument_list>(<argument><expr>&amp;<name>copy_src_rev</name></expr></argument>, <argument><expr>&amp;<name>copy_src_path</name></expr></argument>,
                         <argument><expr><name>copy_root</name></expr></argument>, <argument><expr><name>copy_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>copy_path</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call> != 0</expr>)</condition><then>
    <expr_stmt><expr><name>remainder</name> = <call><name>svn_path_is_child</name><argument_list>(<argument><expr><name>copy_path</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <expr_stmt><expr>*<name>prev_path</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>copy_src_path</name></expr></argument>, <argument><expr><name>remainder</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>prev_rev</name> = <name>copy_src_rev</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>fs_node_origin_rev</name><parameter_list>(<param><decl><type><name>svn_revnum_t</name> *</type><name>revision</name></decl></param>,
                   <param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
                   <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name> <init>= <expr><name><name>root</name>-&gt;<name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>given_noderev_id</name></decl>, *<decl><type ref="prev"/><name>cached_origin_id</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>node_id</name></decl>, *<decl><type ref="prev"/><name>dash</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>path</name> = <call><name>svn_fs__canonicalize_abspath</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Check the cache first. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>fs_node_id</name><argument_list>(<argument><expr>&amp;<name>given_noderev_id</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>node_id</name> = <call><name>svn_fs_fs__id_node_id</name><argument_list>(<argument><expr><name>given_noderev_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Is it a brand new uncommitted node? */</comment>
  <if>if <condition>(<expr><name><name>node_id</name><index>[<expr>0</expr>]</index></name> == '_'</expr>)</condition><then>
    <block>{
      <expr_stmt><expr>*<name>revision</name> = <name>SVN_INVALID_REVNUM</name></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>

  <comment type="block">/* Maybe this is a new-style node ID that just has the revision
     sitting right in it. */</comment>
  <expr_stmt><expr><name>dash</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>node_id</name></expr></argument>, <argument><expr>'-'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>dash</name> &amp;&amp; *(<name>dash</name>+1)</expr>)</condition><then>
    <block>{
      <expr_stmt><expr>*<name>revision</name> = <call><name>SVN_STR_TO_REV</name><argument_list>(<argument><expr><name>dash</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>

  <comment type="block">/* OK, it's an old-style ID?  Maybe it's cached. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__get_node_origin</name><argument_list>(<argument><expr>&amp;<name>cached_origin_id</name></expr></argument>,
                                     <argument><expr><name>fs</name></expr></argument>,
                                     <argument><expr><name>node_id</name></expr></argument>,
                                     <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>cached_origin_id</name> != <name>NULL</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr>*<name>revision</name> = <call><name>svn_fs_fs__id_rev</name><argument_list>(<argument><expr><name>cached_origin_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>

  <block>{
    <comment type="block">/* Ah well, the answer isn't in the ID itself or in the cache.
       Let's actually calculate it, then. */</comment>
    <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>curroot</name> <init>= <expr><name>root</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>predidpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>lastpath</name> <init>= <expr><call><name>svn_stringbuf_create</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>lastrev</name> <init>= <expr><name>SVN_INVALID_REVNUM</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>node</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>pred_id</name></decl>;</decl_stmt>

    <comment type="block">/* Walk the closest-copy chain back to the first copy in our history.

       NOTE: We merely *assume* that this is faster than walking the
       predecessor chain, because we *assume* that copies of parent
       directories happen less often than modifications to a given item. */</comment>
    <while>while <condition>(<expr>1</expr>)</condition>
      <block>{
        <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>currev</name></decl>;</decl_stmt>
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>curpath</name> <init>= <expr><name><name>lastpath</name>-&gt;<name>data</name></name></expr></init></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Get a root pointing to LASTREV.  (The first time around,
           LASTREV is invalid, but that's cool because CURROOT is
           already initialized.)  */</comment>
        <if>if <condition>(<expr><call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name>lastrev</name></expr></argument>)</argument_list></call></expr>)</condition><then>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__revision_root</name><argument_list>(<argument><expr>&amp;<name>curroot</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>lastrev</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

        <comment type="block">/* Find the previous location using the closest-copy shortcut. */</comment>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>prev_location</name><argument_list>(<argument><expr>&amp;<name>curpath</name></expr></argument>, <argument><expr>&amp;<name>currev</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>curroot</name></expr></argument>, <argument><expr><name>curpath</name></expr></argument>,
                              <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr>! <name>curpath</name></expr>)</condition><then>
          <break>break;</break></then></if>

        <comment type="block">/* Update our LASTPATH and LASTREV variables (which survive
           SUBPOOL). */</comment>
        <expr_stmt><expr><call><name>svn_stringbuf_set</name><argument_list>(<argument><expr><name>lastpath</name></expr></argument>, <argument><expr><name>curpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>lastrev</name> = <name>currev</name></expr>;</expr_stmt>
      }</block></while>

    <comment type="block">/* Walk the predecessor links back to origin. */</comment>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>fs_node_id</name><argument_list>(<argument><expr>&amp;<name>pred_id</name></expr></argument>, <argument><expr><name>curroot</name></expr></argument>, <argument><expr><name><name>lastpath</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name>predidpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <while>while <condition>(<expr><name>pred_id</name></expr>)</condition>
      <block>{
        <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_node</name><argument_list>(<argument><expr>&amp;<name>node</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>pred_id</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>predidpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_predecessor_id</name><argument_list>(<argument><expr>&amp;<name>pred_id</name></expr></argument>, <argument><expr><name>node</name></expr></argument>,
                                                  <argument><expr><name>predidpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      }</block></while>

    <comment type="block">/* When we get here, NODE should be the first node-revision in our
       chain. */</comment>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_revision</name><argument_list>(<argument><expr><name>revision</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* Wow, I don't want to have to do all that again.  Let's cache
       the result. */</comment>
    <if>if <condition>(<expr><name><name>node_id</name><index>[<expr>0</expr>]</index></name> != '_'</expr>)</condition><then>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__set_node_origin</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>node_id</name></expr></argument>,
                                         <argument><expr><call><name>svn_fs_fs__dag_get_id</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

    <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>predidpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
  }</block>
}</block></function>


<struct>struct <name>history_prev_args</name>
<block>{
  <decl_stmt><decl><type><name>svn_fs_history_t</name> **</type><name>prev_history_p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_history_t</name> *</type><name>history</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>cross_copies</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>
}</block>;</struct>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>history_prev</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>history_prev_args</name> *</type><name>args</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_history_t</name> **</type><name>prev_history</name> <init>= <expr><name><name>args</name>-&gt;<name>prev_history_p</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_history_t</name> *</type><name>history</name> <init>= <expr><name><name>args</name>-&gt;<name>history</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>fs_history_data_t</name> *</type><name>fhd</name> <init>= <expr><name><name>history</name>-&gt;<name>fsap_data</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>commit_path</name></decl>, *<decl><type ref="prev"/><name>src_path</name></decl>, *<decl><type ref="prev"/><name>path</name> <init>= <expr><name><name>fhd</name>-&gt;<name>path</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>commit_rev</name></decl>, <decl><type ref="prev"/><name>src_rev</name></decl>, <decl><type ref="prev"/><name>dst_rev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>revision</name> <init>= <expr><name><name>fhd</name>-&gt;<name>revision</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>retpool</name> <init>= <expr><name><name>args</name>-&gt;<name>pool</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name> <init>= <expr><name><name>fhd</name>-&gt;<name>fs</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>parent_path_t</name> *</type><name>parent_path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>node</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>node_id</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>reported</name> <init>= <expr><name><name>fhd</name>-&gt;<name>is_interesting</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>retry</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_revnum_t</name></type> <name>copyroot_rev</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copyroot_path</name></decl>;</decl_stmt>

  <comment type="block">/* Initialize our return value. */</comment>
  <expr_stmt><expr>*<name>prev_history</name> = <name>NULL</name></expr>;</expr_stmt>

  <comment type="block">/* If our last history report left us hints about where to pickup
     the chase, then our last report was on the destination of a
     copy.  If we are crossing copies, start from those locations,
     otherwise, we're all done here.  */</comment>
  <if>if <condition>(<expr><name><name>fhd</name>-&gt;<name>path_hint</name></name> &amp;&amp; <call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name><name>fhd</name>-&gt;<name>rev_hint</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>reported</name> = <name>FALSE</name></expr>;</expr_stmt>
      <if>if <condition>(<expr>! <name><name>args</name>-&gt;<name>cross_copies</name></name></expr>)</condition><then>
        <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>
      <expr_stmt><expr><name>path</name> = <name><name>fhd</name>-&gt;<name>path_hint</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name>revision</name> = <name><name>fhd</name>-&gt;<name>rev_hint</name></name></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* Construct a ROOT for the current revision. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__revision_root</name><argument_list>(<argument><expr>&amp;<name>root</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>revision</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Open PATH/REVISION, and get its node and a bunch of other
     goodies.  */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>open_path</name><argument_list>(<argument><expr>&amp;<name>parent_path</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>node</name> = <name><name>parent_path</name>-&gt;<name>node</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name>node_id</name> = <call><name>svn_fs_fs__dag_get_id</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>commit_path</name> = <call><name>svn_fs_fs__dag_get_created_path</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_revision</name><argument_list>(<argument><expr>&amp;<name>commit_rev</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* The Subversion filesystem is written in such a way that a given
     line of history may have at most one interesting history point
     per filesystem revision.  Either that node was edited (and
     possibly copied), or it was copied but not edited.  And a copy
     source cannot be from the same revision as its destination.  So,
     if our history revision matches its node's commit revision, we
     know that ... */</comment>
  <if>if <condition>(<expr><name>revision</name> == <name>commit_rev</name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr>! <name>reported</name></expr>)</condition><then>
        <block>{
          <comment type="block">/* ... we either have not yet reported on this revision (and
             need now to do so) ... */</comment>
          <expr_stmt><expr>*<name>prev_history</name> = <call><name>assemble_history</name><argument_list>(<argument><expr><name>fs</name></expr></argument>,
                                           <argument><expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>retpool</name></expr></argument>, <argument><expr><name>commit_path</name></expr></argument>)</argument_list></call></expr></argument>,
                                           <argument><expr><name>commit_rev</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                           <argument><expr><name>SVN_INVALID_REVNUM</name></expr></argument>, <argument><expr><name>retpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
        }</block></then>
      <else>else
        <block>{
          <comment type="block">/* ... or we *have* reported on this revision, and must now
             progress toward this node's predecessor (unless there is
             no predecessor, in which case we're all done!). */</comment>
          <decl_stmt><decl><type><specifier>const</specifier> <name>svn_fs_id_t</name> *</type><name>pred_id</name></decl>;</decl_stmt>

          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_predecessor_id</name><argument_list>(<argument><expr>&amp;<name>pred_id</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr>! <name>pred_id</name></expr>)</condition><then>
            <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

          <comment type="block">/* Replace NODE and friends with the information from its
             predecessor. */</comment>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_node</name><argument_list>(<argument><expr>&amp;<name>node</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>pred_id</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>node_id</name> = <call><name>svn_fs_fs__dag_get_id</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>commit_path</name> = <call><name>svn_fs_fs__dag_get_created_path</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_revision</name><argument_list>(<argument><expr>&amp;<name>commit_rev</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></else></if>
    }</block></then></if>

  <comment type="block">/* Find the youngest copyroot in the path of this node, including
     itself. */</comment>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>find_youngest_copyroot</name><argument_list>(<argument><expr>&amp;<name>copyroot_rev</name></expr></argument>, <argument><expr>&amp;<name>copyroot_path</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>,
                                 <argument><expr><name>parent_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Initialize some state variables. */</comment>
  <expr_stmt><expr><name>src_path</name> = <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>src_rev</name> = <name>SVN_INVALID_REVNUM</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>dst_rev</name> = <name>SVN_INVALID_REVNUM</name></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>copyroot_rev</name> &gt; <name>commit_rev</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>remainder</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>copy_dst</name></decl>, *<decl><type ref="prev"/><name>copy_src</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>copyroot_root</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__revision_root</name><argument_list>(<argument><expr>&amp;<name>copyroot_root</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><name>copyroot_rev</name></expr></argument>,
                                       <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_dag</name><argument_list>(<argument><expr>&amp;<name>node</name></expr></argument>, <argument><expr><name>copyroot_root</name></expr></argument>, <argument><expr><name>copyroot_path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>copy_dst</name> = <call><name>svn_fs_fs__dag_get_created_path</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* If our current path was the very destination of the copy,
         then our new current path will be the copy source.  If our
         current path was instead the *child* of the destination of
         the copy, then figure out its previous location by taking its
         path relative to the copy destination and appending that to
         the copy source.  Finally, if our current path doesn't meet
         one of these other criteria ... ### for now just fallback to
         the old copy hunt algorithm. */</comment>
      <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>copy_dst</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
        <expr_stmt><expr><name>remainder</name> = ""</expr>;</expr_stmt></then>
      <else>else
        <expr_stmt><expr><name>remainder</name> = <call><name>svn_path_is_child</name><argument_list>(<argument><expr><name>copy_dst</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

      <if>if <condition>(<expr><name>remainder</name></expr>)</condition><then>
        <block>{
          <comment type="block">/* If we get here, then our current path is the destination
             of, or the child of the destination of, a copy.  Fill
             in the return values and get outta here.  */</comment>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_copyfrom_rev</name><argument_list>(<argument><expr>&amp;<name>src_rev</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_copyfrom_path</name><argument_list>(<argument><expr>&amp;<name>copy_src</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <expr_stmt><expr><name>dst_rev</name> = <name>copyroot_rev</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>src_path</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>copy_src</name></expr></argument>, <argument><expr><name>remainder</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>
    }</block></then></if>

  <comment type="block">/* If we calculated a copy source path and revision, we'll make a
     'copy-style' history object. */</comment>
  <if>if <condition>(<expr><name>src_path</name> &amp;&amp; <call><name>SVN_IS_VALID_REVNUM</name><argument_list>(<argument><expr><name>src_rev</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <comment type="block">/* It's possible for us to find a copy location that is the same
         as the history point we've just reported.  If that happens,
         we simply need to take another trip through this history
         search. */</comment>
      <if>if <condition>(<expr>(<name>dst_rev</name> == <name>revision</name>) &amp;&amp; <name>reported</name></expr>)</condition><then>
        <expr_stmt><expr><name>retry</name> = <name>TRUE</name></expr>;</expr_stmt></then></if>

      <expr_stmt><expr>*<name>prev_history</name> = <call><name>assemble_history</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>retpool</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>,
                                       <argument><expr><name>dst_rev</name></expr></argument>, <argument><expr><name>retry</name> ? <name>FALSE</name> : <name>TRUE</name></expr></argument>,
                                       <argument><expr><name>src_path</name></expr></argument>, <argument><expr><name>src_rev</name></expr></argument>, <argument><expr><name>retpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <expr_stmt><expr>*<name>prev_history</name> = <call><name>assemble_history</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>retpool</name></expr></argument>, <argument><expr><name>commit_path</name></expr></argument>)</argument_list></call></expr></argument>,
                                       <argument><expr><name>commit_rev</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                                       <argument><expr><name>SVN_INVALID_REVNUM</name></expr></argument>, <argument><expr><name>retpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></else></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Implement svn_fs_history_prev, set *PREV_HISTORY_P to a new
   svn_fs_history_t object that represents the predecessory of
   HISTORY.  If CROSS_COPIES is true, *PREV_HISTORY_P may be related
   only through a copy operation.  Perform all allocations in POOL. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>fs_history_prev</name><parameter_list>(<param><decl><type><name>svn_fs_history_t</name> **</type><name>prev_history_p</name></decl></param>,
                <param><decl><type><name>svn_fs_history_t</name> *</type><name>history</name></decl></param>,
                <param><decl><type><name>svn_boolean_t</name></type> <name>cross_copies</name></decl></param>,
                <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_fs_history_t</name> *</type><name>prev_history</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>fs_history_data_t</name> *</type><name>fhd</name> <init>= <expr><name><name>history</name>-&gt;<name>fsap_data</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_t</name> *</type><name>fs</name> <init>= <expr><name><name>fhd</name>-&gt;<name>fs</name></name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Special case: the root directory changes in every single
     revision, no exceptions.  And, the root can't be the target (or
     child of a target -- duh) of a copy.  So, if that's our path,
     then we need only decrement our revision by 1, and there you go. */</comment>
  <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>fhd</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr>"/"</expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr>! <name><name>fhd</name>-&gt;<name>is_interesting</name></name></expr>)</condition><then>
        <expr_stmt><expr><name>prev_history</name> = <call><name>assemble_history</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr>"/"</expr></argument>, <argument><expr><name><name>fhd</name>-&gt;<name>revision</name></name></expr></argument>,
                                        <argument><expr>1</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>SVN_INVALID_REVNUM</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
      <else>else <if>if <condition>(<expr><name><name>fhd</name>-&gt;<name>revision</name></name> &gt; 0</expr>)</condition><then>
        <expr_stmt><expr><name>prev_history</name> = <call><name>assemble_history</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr>"/"</expr></argument>, <argument><expr><name><name>fhd</name>-&gt;<name>revision</name></name> - 1</expr></argument>,
                                        <argument><expr>1</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>SVN_INVALID_REVNUM</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if>
    }</block></then>
  <else>else
    <block>{
      <decl_stmt><decl><type>struct <name>history_prev_args</name></type> <name>args</name></decl>;</decl_stmt>
      <expr_stmt><expr><name>prev_history</name> = <name>history</name></expr>;</expr_stmt>

      <while>while <condition>(<expr>1</expr>)</condition>
        <block>{
          <expr_stmt><expr><name><name>args</name>.<name>prev_history_p</name></name> = &amp;<name>prev_history</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>args</name>.<name>history</name></name> = <name>prev_history</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>args</name>.<name>cross_copies</name></name> = <name>cross_copies</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>args</name>.<name>pool</name></name> = <name>pool</name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>history_prev</name><argument_list>(<argument><expr>&amp;<name>args</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <if>if <condition>(<expr>! <name>prev_history</name></expr>)</condition><then>
            <break>break;</break></then></if>
          <expr_stmt><expr><name>fhd</name> = <name><name>prev_history</name>-&gt;<name>fsap_data</name></name></expr>;</expr_stmt>
          <if>if <condition>(<expr><name><name>fhd</name>-&gt;<name>is_interesting</name></name></expr>)</condition><then>
            <break>break;</break></then></if>
        }</block></while>
    }</block></else></if>

  <expr_stmt><expr>*<name>prev_history_p</name> = <name>prev_history</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Set *PATH and *REVISION to the path and revision for the HISTORY
   object.  Use POOL for all allocations. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>fs_history_location</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>path</name></decl></param>,
                    <param><decl><type><name>svn_revnum_t</name> *</type><name>revision</name></decl></param>,
                    <param><decl><type><name>svn_fs_history_t</name> *</type><name>history</name></decl></param>,
                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>fs_history_data_t</name> *</type><name>fhd</name> <init>= <expr><name><name>history</name>-&gt;<name>fsap_data</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr>*<name>path</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>fhd</name>-&gt;<name>path</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>revision</name> = <name><name>fhd</name>-&gt;<name>revision</name></name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>history_vtable_t</name></type> <name>history_vtable</name> <init>= <expr><block>{
  <expr><name>fs_history_prev</name></expr>,
  <expr><name>fs_history_location</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Return a new history object (marked as "interesting") for PATH and
   REVISION, allocated in POOL, and with its members set to the values
   of the parameters provided.  Note that PATH and PATH_HINT are not
   duped into POOL -- it is the responsibility of the caller to ensure
   that this happens. */</comment>
<function><type><specifier>static</specifier> <name>svn_fs_history_t</name> *</type>
<name>assemble_history</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                 <param><decl><type><name>svn_revnum_t</name></type> <name>revision</name></decl></param>,
                 <param><decl><type><name>svn_boolean_t</name></type> <name>is_interesting</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path_hint</name></decl></param>,
                 <param><decl><type><name>svn_revnum_t</name></type> <name>rev_hint</name></decl></param>,
                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_fs_history_t</name> *</type><name>history</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>history</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>fs_history_data_t</name> *</type><name>fhd</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>fhd</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><name><name>fhd</name>-&gt;<name>path</name></name> = <name>path</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fhd</name>-&gt;<name>revision</name></name> = <name>revision</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fhd</name>-&gt;<name>is_interesting</name></name> = <name>is_interesting</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fhd</name>-&gt;<name>path_hint</name></name> = <name>path_hint</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fhd</name>-&gt;<name>rev_hint</name></name> = <name>rev_hint</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>fhd</name>-&gt;<name>fs</name></name> = <name>fs</name></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>history</name>-&gt;<name>vtable</name></name> = &amp;<name>history_vtable</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>history</name>-&gt;<name>fsap_data</name></name> = <name>fhd</name></expr>;</expr_stmt>
  <return>return <expr><name>history</name></expr>;</return>
}</block></function>

<escape char="0xc"/>
<comment type="block">/* mergeinfo queries */</comment>

<comment type="block">/* DIR_DAG is a directory DAG node which has mergeinfo in its
   descendants.  This function iterates over its children.  For each
   child with immediate mergeinfo, it adds its mergeinfo to
   RESULT_CATALOG.  appropriate arguments.  For each child with
   descendants with mergeinfo, it recurses.  Note that it does *not*
   call the action on the path for DIR_DAG itself.

   POOL is used for temporary allocations, including the mergeinfo
   hashes passed to actions; RESULT_POOL is used for the mergeinfo added
   to RESULT_CATALOG.
 */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>crawl_directory_dag_for_mergeinfo</name><parameter_list>(<param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
                                  <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>this_path</name></decl></param>,
                                  <param><decl><type><name>dag_node_t</name> *</type><name>dir_dag</name></decl></param>,
                                  <param><decl><type><name>svn_mergeinfo_catalog_t</name></type> <name>result_catalog</name></decl></param>,
                                  <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                                  <param><decl><type><name>apr_pool_t</name> *</type><name>result_pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>entries</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>iterpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_dir_entries</name><argument_list>(<argument><expr>&amp;<name>entries</name></expr></argument>, <argument><expr><name>dir_dag</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>entries</name></expr></argument>)</argument_list></call></expr>;</init>
       <condition><expr><name>hi</name></expr>;</condition>
       <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
    <block>{
      <decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_fs_dirent_t</name> *</type><name>dirent</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>kid_path</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>kid_dag</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>has_mergeinfo</name></decl>, <decl><type ref="prev"/><name>go_down</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>dirent</name> = <name>val</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>kid_path</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr><name>this_path</name></expr></argument>, <argument><expr><name><name>dirent</name>-&gt;<name>name</name></name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_dag</name><argument_list>(<argument><expr>&amp;<name>kid_dag</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>kid_path</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_has_mergeinfo</name><argument_list>(<argument><expr>&amp;<name>has_mergeinfo</name></expr></argument>, <argument><expr><name>kid_dag</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_has_descendants_with_mergeinfo</name><argument_list>(<argument><expr>&amp;<name>go_down</name></expr></argument>, <argument><expr><name>kid_dag</name></expr></argument>,
                                                            <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr><name>has_mergeinfo</name></expr>)</condition><then>
        <block>{
          <comment type="block">/* Save this partisular node's mergeinfo. */</comment>
          <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>proplist</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>svn_mergeinfo_t</name></type> <name>kid_mergeinfo</name></decl>;</decl_stmt>
          <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>mergeinfo_string</name></decl>;</decl_stmt>

          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_proplist</name><argument_list>(<argument><expr>&amp;<name>proplist</name></expr></argument>, <argument><expr><name>kid_dag</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>mergeinfo_string</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>proplist</name></expr></argument>, <argument><expr><name>SVN_PROP_MERGEINFO</name></expr></argument>,
                                          <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr>!<name>mergeinfo_string</name></expr>)</condition><then>
            <block>{
              <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>idstr</name> <init>= <expr><call><name>svn_fs_fs__id_unparse</name><argument_list>(<argument><expr><name><name>dirent</name>-&gt;<name>id</name></name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
              <return>return <expr><call><name>svn_error_createf</name>
                <argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                 <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Node-revision #'%s' claims to have mergeinfo but doesn't"</expr></argument>)</argument_list></call></expr></argument>,
                 <argument><expr><name><name>idstr</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call></expr>;</return>
            }</block></then></if>

          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo_parse</name><argument_list>(<argument><expr>&amp;<name>kid_mergeinfo</name></expr></argument>,
                                      <argument><expr><name><name>mergeinfo_string</name>-&gt;<name>data</name></name></expr></argument>,
                                      <argument><expr><name>result_pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>result_catalog</name></expr></argument>, 
                       <argument><expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>result_pool</name></expr></argument>, <argument><expr><name>kid_path</name></expr></argument>)</argument_list></call></expr></argument>,
                       <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>,
                       <argument><expr><name>kid_mergeinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

      <if>if <condition>(<expr><name>go_down</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>crawl_directory_dag_for_mergeinfo</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                                  <argument><expr><name>kid_path</name></expr></argument>,
                                                  <argument><expr><name>kid_dag</name></expr></argument>,
                                                  <argument><expr><name>result_catalog</name></expr></argument>,
                                                  <argument><expr><name>iterpool</name></expr></argument>,
                                                  <argument><expr><name>result_pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></for>

  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Helper for get_mergeinfo_for_path() that will append PATH_PIECE
   (which may contain slashes) to each path that exists in the
   mergeinfo INPUT, and return a new mergeinfo in *OUTPUT.  Deep
   copies the values.  Perform all allocations in POOL. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>append_to_merged_froms</name><parameter_list>(<param><decl><type><name>svn_mergeinfo_t</name> *</type><name>output</name></decl></param>,
                       <param><decl><type><name>svn_mergeinfo_t</name></type> <name>input</name></decl></param>,
                       <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path_piece</name></decl></param>,
                       <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>
  <expr_stmt><expr>*<name>output</name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>hi</name></expr>;</condition> <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>char</name> *</type><name>newpath</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>newpath</name> = <call><name>svn_path_join</name><argument_list>(<argument><expr>(const <name>char</name> *) <name>key</name></expr></argument>, <argument><expr><name>path_piece</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr>*<name>output</name></expr></argument>, <argument><expr><name>newpath</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, 
                   <argument><expr><call><name>svn_rangelist_dup</name><argument_list>(<argument><expr>(<name>apr_array_header_t</name> *) <name>val</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Calculates the mergeinfo for PATH under REV_ROOT using inheritance
   type INHERIT.  Returns it in *MERGEINFO, or NULL if there is none.
   The result is allocated in RESULT_POOL; POOL is used for temporary
   allocations.
 */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>get_mergeinfo_for_path</name><parameter_list>(<param><decl><type><name>svn_mergeinfo_t</name> *</type><name>mergeinfo</name></decl></param>,
                       <param><decl><type><name>svn_fs_root_t</name> *</type><name>rev_root</name></decl></param>,
                       <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                       <param><decl><type><name>svn_mergeinfo_inheritance_t</name></type> <name>inherit</name></decl></param>,
                       <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                       <param><decl><type><name>apr_pool_t</name> *</type><name>result_pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>parent_path_t</name> *</type><name>parent_path</name></decl>, *<decl><type ref="prev"/><name>nearest_ancestor</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>proplist</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_string_t</name> *</type><name>mergeinfo_string</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>iterpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr>*<name>mergeinfo</name> = <name>NULL</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>path</name> = <call><name>svn_fs__canonicalize_abspath</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>open_path</name><argument_list>(<argument><expr>&amp;<name>parent_path</name></expr></argument>, <argument><expr><name>rev_root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>inherit</name> == <name>svn_mergeinfo_nearest_ancestor</name> &amp;&amp; ! <name><name>parent_path</name>-&gt;<name>parent</name></name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <if>if <condition>(<expr><name>inherit</name> == <name>svn_mergeinfo_nearest_ancestor</name></expr>)</condition><then>
    <expr_stmt><expr><name>nearest_ancestor</name> = <name><name>parent_path</name>-&gt;<name>parent</name></name></expr>;</expr_stmt></then>
  <else>else
    <expr_stmt><expr><name>nearest_ancestor</name> = <name>parent_path</name></expr>;</expr_stmt></else></if>

  <while>while <condition>(<expr><name>TRUE</name></expr>)</condition>
    <block>{
      <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>has_mergeinfo</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_has_mergeinfo</name><argument_list>(<argument><expr>&amp;<name>has_mergeinfo</name></expr></argument>, 
                                           <argument><expr><name><name>nearest_ancestor</name>-&gt;<name>node</name></name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>has_mergeinfo</name></expr>)</condition><then>
        <break>break;</break></then></if>

      <comment type="block">/* No need to loop if we're looking for explicit mergeinfo. */</comment>
      <if>if <condition>(<expr><name>inherit</name> == <name>svn_mergeinfo_explicit</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
        }</block></then></if>
      
      <expr_stmt><expr><name>nearest_ancestor</name> = <name><name>nearest_ancestor</name>-&gt;<name>parent</name></name></expr>;</expr_stmt>

      <comment type="block">/* Run out?  There's no mergeinfo. */</comment>
      <if>if <condition>(<expr>!<name>nearest_ancestor</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
        }</block></then></if>
    }</block></while>
  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_get_proplist</name><argument_list>(<argument><expr>&amp;<name>proplist</name></expr></argument>, <argument><expr><name><name>nearest_ancestor</name>-&gt;<name>node</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>mergeinfo_string</name> = <call><name>apr_hash_get</name><argument_list>(<argument><expr><name>proplist</name></expr></argument>, <argument><expr><name>SVN_PROP_MERGEINFO</name></expr></argument>,
                                  <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr>!<name>mergeinfo_string</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name>
      <argument_list>(<argument><expr><name>SVN_ERR_FS_CORRUPT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Node-revision '%s@%ld' claims to have mergeinfo but doesn't"</expr></argument>)</argument_list></call></expr></argument>,
       <argument><expr><call><name>parent_path_path</name><argument_list>(<argument><expr><name>nearest_ancestor</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>rev_root</name>-&gt;<name>rev</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <if>if <condition>(<expr><name>nearest_ancestor</name> == <name>parent_path</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* We can return this directly. */</comment>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo_parse</name><argument_list>(<argument><expr><name>mergeinfo</name></expr></argument>,
                                  <argument><expr><name><name>mergeinfo_string</name>-&gt;<name>data</name></name></expr></argument>,
                                  <argument><expr><name>result_pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then>
  <else>else
    <block>{
      <decl_stmt><decl><type><name>svn_mergeinfo_t</name></type> <name>temp_mergeinfo</name></decl>;</decl_stmt>

      <comment type="block">/* We're inheriting this, so we need to (a) remove
         non-inheritable ranges and (b) add the rest of the path to
         the merged-from paths.
       */</comment>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo_parse</name><argument_list>(<argument><expr>&amp;<name>temp_mergeinfo</name></expr></argument>,
                                  <argument><expr><name><name>mergeinfo_string</name>-&gt;<name>data</name></name></expr></argument>,
                                  <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_mergeinfo_inheritable</name><argument_list>(<argument><expr>&amp;<name>temp_mergeinfo</name></expr></argument>,
                                        <argument><expr><name>temp_mergeinfo</name></expr></argument>,
                                        <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>SVN_INVALID_REVNUM</name></expr></argument>,
                                        <argument><expr><name>SVN_INVALID_REVNUM</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>append_to_merged_froms</name><argument_list>(<argument><expr><name>mergeinfo</name></expr></argument>,
                                     <argument><expr><name>temp_mergeinfo</name></expr></argument>,
                                     <argument><expr><call><name>parent_path_relpath</name><argument_list>(<argument><expr><name>parent_path</name></expr></argument>,
                                                         <argument><expr><name>nearest_ancestor</name></expr></argument>,
                                                         <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>,
                                     <argument><expr><name>result_pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></else></if>
}</block></function>

<comment type="block">/* Adds mergeinfo for each descendant of PATH (but not PATH itself)
   under ROOT to RESULT_CATALOG.  Returned values are allocated in
   RESULT_POOL; temporary values in POOL. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>add_descendant_mergeinfo</name><parameter_list>(<param><decl><type><name>svn_mergeinfo_catalog_t</name></type> <name>result_catalog</name></decl></param>,
                         <param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
                         <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                         <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                         <param><decl><type><name>apr_pool_t</name> *</type><name>result_pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>dag_node_t</name> *</type><name>this_dag</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>go_down</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_dag</name><argument_list>(<argument><expr>&amp;<name>this_dag</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_fs_fs__dag_has_descendants_with_mergeinfo</name><argument_list>(<argument><expr>&amp;<name>go_down</name></expr></argument>,
                                                        <argument><expr><name>this_dag</name></expr></argument>,
                                                        <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>go_down</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>crawl_directory_dag_for_mergeinfo</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
                                              <argument><expr><name>path</name></expr></argument>,
                                              <argument><expr><name>this_dag</name></expr></argument>,
                                              <argument><expr><name>result_catalog</name></expr></argument>,
                                              <argument><expr><name>pool</name></expr></argument>,
                                              <argument><expr><name>result_pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Get the mergeinfo for a set of paths, returned in
   *MERGEINFO_CATALOG.  Returned values are allocated in POOL, while
   temporary values are allocated in a sub-pool. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>get_mergeinfos_for_paths</name><parameter_list>(<param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
                         <param><decl><type><name>svn_mergeinfo_catalog_t</name> *</type><name>mergeinfo_catalog</name></decl></param>,
                         <param><decl><type><specifier>const</specifier> <name>apr_array_header_t</name> *</type><name>paths</name></decl></param>,
                         <param><decl><type><name>svn_mergeinfo_inheritance_t</name></type> <name>inherit</name></decl></param>,
                         <param><decl><type><name>svn_boolean_t</name></type> <name>include_descendants</name></decl></param>,
                         <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_mergeinfo_catalog_t</name></type> <name>result_catalog</name> <init>= <expr><call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>iterpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>paths</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <decl_stmt><decl><type><name>svn_mergeinfo_t</name></type> <name>path_mergeinfo</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name> <init>= <expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>paths</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>svn_pool_clear</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_mergeinfo_for_path</name><argument_list>(<argument><expr>&amp;<name>path_mergeinfo</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
                                     <argument><expr><name>inherit</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>path_mergeinfo</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>result_catalog</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>,
                     <argument><expr><name>path_mergeinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
      <if>if <condition>(<expr><name>include_descendants</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>add_descendant_mergeinfo</name><argument_list>(<argument><expr><name>result_catalog</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>iterpool</name></expr></argument>,
                                         <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></for>
  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>iterpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>mergeinfo_catalog</name> = <name>result_catalog</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<comment type="block">/* Implements svn_fs_get_mergeinfo. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>fs_get_mergeinfo</name><parameter_list>(<param><decl><type><name>svn_mergeinfo_catalog_t</name> *</type><name>catalog</name></decl></param>,
                 <param><decl><type><name>svn_fs_root_t</name> *</type><name>root</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>apr_array_header_t</name> *</type><name>paths</name></decl></param>,
                 <param><decl><type><name>svn_mergeinfo_inheritance_t</name></type> <name>inherit</name></decl></param>,
                 <param><decl><type><name>svn_boolean_t</name></type> <name>include_descendants</name></decl></param>,
                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>fs_fs_data_t</name> *</type><name>ffd</name> <init>= <expr><name><name>root</name>-&gt;<name>fs</name>-&gt;<name>fsap_data</name></name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* We require a revision root. */</comment>
  <if>if <condition>(<expr><name><name>root</name>-&gt;<name>is_txn_root</name></name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>SVN_ERR_FS_NOT_REVISION_ROOT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* We have to actually be able to find the mergeinfo metadata! */</comment>
  <if>if <condition>(<expr>! <call><name>svn_fs_fs__fs_supports_mergeinfo</name><argument_list>(<argument><expr><name><name>root</name>-&gt;<name>fs</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name>
      <argument_list>(<argument><expr><name>SVN_ERR_UNSUPPORTED_FEATURE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
       <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Querying mergeinfo requires version %d of the FSFS filesystem "
         "schema; filesystem '%s' uses only version %d"</expr></argument>)</argument_list></call></expr></argument>,
       <argument><expr><name>SVN_FS_FS__MIN_MERGEINFO_FORMAT</name></expr></argument>, <argument><expr><name><name>root</name>-&gt;<name>fs</name>-&gt;<name>path</name></name></expr></argument>, <argument><expr><name><name>ffd</name>-&gt;<name>format</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* Retrieve a path -&gt; mergeinfo hash mapping. */</comment>
  <return>return <expr><call><name>get_mergeinfos_for_paths</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>paths</name></expr></argument>,
                                  <argument><expr><name>inherit</name></expr></argument>, <argument><expr><name>include_descendants</name></expr></argument>,
                                  <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* The vtable associated with root objects. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>root_vtable_t</name></type> <name>root_vtable</name> <init>= <expr><block>{
  <expr><name>fs_paths_changed</name></expr>,
  <expr><name>svn_fs_fs__check_path</name></expr>,
  <expr><name>fs_node_history</name></expr>,
  <expr><name>fs_node_id</name></expr>,
  <expr><name>svn_fs_fs__node_created_rev</name></expr>,
  <expr><name>fs_node_origin_rev</name></expr>,
  <expr><name>fs_node_created_path</name></expr>,
  <expr><name>fs_delete_node</name></expr>,
  <expr><name>fs_copied_from</name></expr>,
  <expr><name>fs_closest_copy</name></expr>,
  <expr><name>fs_node_prop</name></expr>,
  <expr><name>fs_node_proplist</name></expr>,
  <expr><name>fs_change_node_prop</name></expr>,
  <expr><name>fs_props_changed</name></expr>,
  <expr><name>fs_dir_entries</name></expr>,
  <expr><name>fs_make_dir</name></expr>,
  <expr><name>fs_copy</name></expr>,
  <expr><name>fs_revision_link</name></expr>,
  <expr><name>fs_file_length</name></expr>,
  <expr><name>fs_file_md5_checksum</name></expr>,
  <expr><name>fs_file_contents</name></expr>,
  <expr><name>fs_make_file</name></expr>,
  <expr><name>fs_apply_textdelta</name></expr>,
  <expr><name>fs_apply_text</name></expr>,
  <expr><name>fs_contents_changed</name></expr>,
  <expr><name>fs_get_file_delta_stream</name></expr>,
  <expr><name>fs_merge</name></expr>,
  <expr><name>fs_get_mergeinfo</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Construct a new root object in FS, allocated from POOL.  */</comment>
<function><type><specifier>static</specifier> <name>svn_fs_root_t</name> *</type>
<name>make_root</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
          <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* We create a subpool for each root object to allow us to implement
     svn_fs_close_root.  */</comment>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>root</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>root</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>root</name>-&gt;<name>fs</name></name> = <name>fs</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>root</name>-&gt;<name>pool</name></name> = <name>subpool</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>root</name>-&gt;<name>vtable</name></name> = &amp;<name>root_vtable</name></expr>;</expr_stmt>

  <return>return <expr><name>root</name></expr>;</return>
}</block></function>


<comment type="block">/* Construct a root object referring to the root of REVISION in FS,
   whose root directory is ROOT_DIR.  Create the new root in POOL.  */</comment>
<function><type><specifier>static</specifier> <name>svn_fs_root_t</name> *</type>
<name>make_revision_root</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
                   <param><decl><type><name>svn_revnum_t</name></type> <name>rev</name></decl></param>,
                   <param><decl><type><name>dag_node_t</name> *</type><name>root_dir</name></decl></param>,
                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>root</name> <init>= <expr><call><name>make_root</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>fs_rev_root_data_t</name> *</type><name>frd</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name><name>root</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>frd</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>root</name>-&gt;<name>is_txn_root</name></name> = <name>FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>root</name>-&gt;<name>rev</name></name> = <name>rev</name></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>frd</name>-&gt;<name>root_dir</name></name> = <name>root_dir</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>frd</name>-&gt;<name>copyfrom_cache</name></name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name><name>root</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>root</name>-&gt;<name>fsap_data</name></name> = <name>frd</name></expr>;</expr_stmt>

  <return>return <expr><name>root</name></expr>;</return>
}</block></function>


<comment type="block">/* Construct a root object referring to the root of the transaction
   named TXN and based on revision BASE_REV in FS, with FLAGS to
   describe transaction's behavior.  Create the new root in POOL.  */</comment>
<function><type><specifier>static</specifier> <name>svn_fs_root_t</name> *</type>
<name>make_txn_root</name><parameter_list>(<param><decl><type><name>svn_fs_t</name> *</type><name>fs</name></decl></param>,
              <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>txn</name></decl></param>,
              <param><decl><type><name>svn_revnum_t</name></type> <name>base_rev</name></decl></param>,
              <param><decl><type><name>apr_uint32_t</name></type> <name>flags</name></decl></param>,
              <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_fs_root_t</name> *</type><name>root</name> <init>= <expr><call><name>make_root</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>fs_txn_root_data_t</name> *</type><name>frd</name> <init>= <expr><call><name>apr_pcalloc</name><argument_list>(<argument><expr><name><name>root</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>frd</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>root</name>-&gt;<name>is_txn_root</name></name> = <name>TRUE</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>root</name>-&gt;<name>txn</name></name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name><name>root</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>txn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>root</name>-&gt;<name>txn_flags</name></name> = <name>flags</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>root</name>-&gt;<name>rev</name></name> = <name>base_rev</name></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>frd</name>-&gt;<name>txn_node_cache</name></name> = <call><name>apr_hash_make</name><argument_list>(<argument><expr><name><name>root</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>frd</name>-&gt;<name>txn_node_list</name>.<name>prev</name></name> = &amp;<name><name>frd</name>-&gt;<name>txn_node_list</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>frd</name>-&gt;<name>txn_node_list</name>.<name>next</name></name> = &amp;<name><name>frd</name>-&gt;<name>txn_node_list</name></name></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>root</name>-&gt;<name>fsap_data</name></name> = <name>frd</name></expr>;</expr_stmt>

  <return>return <expr><name>root</name></expr>;</return>
}</block></function>
</unit>
