<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/subversion-1.5.1/source/subversion/libsvn_subr/path.c"><comment type="block">/*
 * paths.c:   a path manipulation library using svn_stringbuf_t
 *
 * ====================================================================
 * Copyright (c) 2000-2007 CollabNet.  All rights reserved.
 *
 * This software is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at http://subversion.tigris.org/license-1.html.
 * If newer versions of this license are posted there, you may use a
 * newer version instead, at your option.
 *
 * This software consists of voluntary contributions made by many
 * individuals.  For exact contribution history, see the revision
 * history and logs, available at http://subversion.tigris.org/.
 * ====================================================================
 */</comment>


<escape char="0xc"/>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_file_info.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_lib.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_string.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_path.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_private_config.h"</cpp:file></cpp:include>         <comment type="block">/* for SVN_PATH_LOCAL_SEPARATOR */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_utf.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_io.h"</cpp:file></cpp:include>                     <comment type="block">/* for svn_io_stat() */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_ctype.h"</cpp:file></cpp:include>


<comment type="block">/* The canonical empty path.  Can this be changed?  Well, change the empty
   test below and the path library will work, not so sure about the fs/wc
   libraries. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_EMPTY_PATH</name></cpp:macro> <cpp:value>""</cpp:value></cpp:define>

<comment type="block">/* TRUE if s is the canonical empty path, FALSE otherwise */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_PATH_IS_EMPTY</name><parameter_list>(<param><type><name>s</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((s)[0] == '\0')</cpp:value></cpp:define>

<comment type="block">/* TRUE if s,n is the platform's empty path ("."), FALSE otherwise. Can
   this be changed?  Well, the path library will work, not so sure about
   the OS! */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SVN_PATH_IS_PLATFORM_EMPTY</name><parameter_list>(<param><type><name>s</name></type></param>,<param><type><name>n</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((n) == 1 &amp;&amp; (s)[0] == '.')</cpp:value></cpp:define>

<escape char="0xc"/>
<function><type><specifier>const</specifier> <name>char</name> *</type>
<name>svn_path_internal_style</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>'/' != <name>SVN_PATH_LOCAL_SEPARATOR</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>char</name> *</type><name>p</name> <init>= <expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>path</name> = <name>p</name></expr>;</expr_stmt>

      <comment type="block">/* Convert all local-style separators to the canonical ones. */</comment>
      <for>for (<init>;</init> <condition><expr>*<name>p</name> != '\0'</expr>;</condition> <incr><expr>++<name>p</name></expr></incr>)
        <if>if <condition>(<expr>*<name>p</name> == <name>SVN_PATH_LOCAL_SEPARATOR</name></expr>)</condition><then>
          <expr_stmt><expr>*<name>p</name> = '/'</expr>;</expr_stmt></then></if></for>
    }</block></then></if>

  <return>return <expr><call><name>svn_path_canonicalize</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
  <comment type="block">/* FIXME: Should also remove trailing /.'s, if the style says so. */</comment>
}</block></function>


<function><type><specifier>const</specifier> <name>char</name> *</type>
<name>svn_path_local_style</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><name>path</name> = <call><name>svn_path_canonicalize</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <comment type="block">/* FIXME: Should also remove trailing /.'s, if the style says so. */</comment>

  <comment type="block">/* Internally, Subversion represents the current directory with the
     empty string.  But users like to see "." . */</comment>
  <if>if <condition>(<expr><call><name>SVN_PATH_IS_EMPTY</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr>"."</expr>;</return></then></if>

  <comment type="block">/* If PATH is a URL, the "local style" is the same as the input. */</comment>
  <if>if <condition>(<expr><call><name>svn_path_is_url</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <if>if <condition>(<expr>'/' != <name>SVN_PATH_LOCAL_SEPARATOR</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>char</name> *</type><name>p</name> <init>= <expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name>path</name> = <name>p</name></expr>;</expr_stmt>

      <comment type="block">/* Convert all canonical separators to the local-style ones. */</comment>
      <for>for (<init>;</init> <condition><expr>*<name>p</name> != '\0'</expr>;</condition> <incr><expr>++<name>p</name></expr></incr>)
        <if>if <condition>(<expr>*<name>p</name> == '/'</expr>)</condition><then>
          <expr_stmt><expr>*<name>p</name> = <name>SVN_PATH_LOCAL_SEPARATOR</name></expr>;</expr_stmt></then></if></for>
    }</block></then></if>

  <return>return <expr><name>path</name></expr>;</return>
}</block></function>


<escape char="0xc"/>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>NDEBUG</name></cpp:ifndef>
<function><type><specifier>static</specifier> <name>svn_boolean_t</name></type>
<name>is_canonical</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
             <param><decl><type><name>apr_size_t</name></type> <name>len</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr>(! <call><name>SVN_PATH_IS_PLATFORM_EMPTY</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call>
          &amp;&amp; (<call><name>svn_dirent_is_root</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call> ||
              (<name>len</name> &lt;= 1 || <name><name>path</name><index>[<expr><name>len</name>-1</expr>]</index></name> != '/')))</expr>;</return>
}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<function><type><name>char</name> *</type><name>svn_path_join</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>base</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>component</name></decl></param>,
                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>blen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>clen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>component</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>path</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>is_canonical</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>blen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>is_canonical</name><argument_list>(<argument><expr><name>component</name></expr></argument>, <argument><expr><name>clen</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If the component is absolute, then return it.  */</comment>
  <if>if <condition>(<expr>*<name>component</name> == '/'</expr>)</condition><then>
    <return>return <expr><call><name>apr_pmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>component</name></expr></argument>, <argument><expr><name>clen</name> + 1</expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* If either is empty return the other */</comment>
  <if>if <condition>(<expr><call><name>SVN_PATH_IS_EMPTY</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>apr_pmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>component</name></expr></argument>, <argument><expr><name>clen</name> + 1</expr></argument>)</argument_list></call></expr>;</return></then></if>
  <if>if <condition>(<expr><call><name>SVN_PATH_IS_EMPTY</name><argument_list>(<argument><expr><name>component</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><call><name>apr_pmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>blen</name> + 1</expr></argument>)</argument_list></call></expr>;</return></then></if>

  <if>if <condition>(<expr><name>blen</name> == 1 &amp;&amp; <name><name>base</name><index>[<expr>0</expr>]</index></name> == '/'</expr>)</condition><then>
    <expr_stmt><expr><name>blen</name> = 0</expr>;</expr_stmt></then></if> <comment type="block">/* Ignore base, just return separator + component */</comment>

  <comment type="block">/* Construct the new, combined path. */</comment>
  <expr_stmt><expr><name>path</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>blen</name> + 1 + <name>clen</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>blen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>path</name><index>[<expr><name>blen</name></expr>]</index></name> = '/'</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>path</name> + <name>blen</name> + 1</expr></argument>, <argument><expr><name>component</name></expr></argument>, <argument><expr><name>clen</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>path</name></expr>;</return>
}</block></function>

<function><type><name>char</name> *</type><name>svn_path_join_many</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>base</name></decl></param>, <param><decl><type>...</type></decl></param>)</parameter_list>
<block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_SAVED_LENGTHS</name></cpp:macro> <cpp:value>10</cpp:value></cpp:define>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name><name>saved_lengths</name><index>[<expr><name>MAX_SAVED_LENGTHS</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>total_len</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>nargs</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>va_list</name></type> <name>va</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>s</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>base_is_empty</name> <init>= <expr><name>FALSE</name></expr></init>, <name>base_is_root</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>base_arg</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>total_len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>is_canonical</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>total_len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>total_len</name> == 1 &amp;&amp; *<name>base</name> == '/'</expr>)</condition><then>
    <expr_stmt><expr><name>base_is_root</name> = <name>TRUE</name></expr>;</expr_stmt></then>
  <else>else <if>if <condition>(<expr><call><name>SVN_PATH_IS_EMPTY</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>total_len</name> = <sizeof>sizeof<argument_list>(<argument><expr><name>SVN_EMPTY_PATH</name></expr></argument>)</argument_list></sizeof> - 1</expr>;</expr_stmt>
      <expr_stmt><expr><name>base_is_empty</name> = <name>TRUE</name></expr>;</expr_stmt>
    }</block></then></if></else></if>

  <expr_stmt><expr><name><name>saved_lengths</name><index>[<expr>0</expr>]</index></name> = <name>total_len</name></expr>;</expr_stmt>

  <comment type="block">/* Compute the length of the resulting string. */</comment>

  <expr_stmt><expr><name>nargs</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>va</name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while <condition>(<expr>(<name>s</name> = <call><name>va_arg</name><argument_list>(<argument><expr><name>va</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition>
    <block>{
      <expr_stmt><expr><name>len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>is_canonical</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr><call><name>SVN_PATH_IS_EMPTY</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <continue>continue;</continue></then></if>

      <if>if <condition>(<expr><name>nargs</name>++ &lt; <name>MAX_SAVED_LENGTHS</name></expr>)</condition><then>
        <expr_stmt><expr><name><name>saved_lengths</name><index>[<expr><name>nargs</name></expr>]</index></name> = <name>len</name></expr>;</expr_stmt></then></if>

      <if>if <condition>(<expr>*<name>s</name> == '/'</expr>)</condition><then>
        <block>{
          <comment type="block">/* an absolute path. skip all components to this point and reset
             the total length. */</comment>
          <expr_stmt><expr><name>total_len</name> = <name>len</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>base_arg</name> = <name>nargs</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>base_is_root</name> = <name>len</name> == 1</expr>;</expr_stmt>
          <expr_stmt><expr><name>base_is_empty</name> = <name>FALSE</name></expr>;</expr_stmt>
        }</block></then>
      <else>else <if>if <condition>(<expr><name>nargs</name> == <name>base_arg</name>
               || (<name>nargs</name> == <name>base_arg</name> + 1 &amp;&amp; <name>base_is_root</name>)
               || <name>base_is_empty</name></expr>)</condition><then>
        <block>{
          <comment type="block">/* if we have skipped everything up to this arg, then the base
             and all prior components are empty. just set the length to
             this component; do not add a separator.  If the base is empty
             we can now ignore it. */</comment>
          <if>if <condition>(<expr><name>base_is_empty</name></expr>)</condition><then>
            <block>{
              <expr_stmt><expr><name>base_is_empty</name> = <name>FALSE</name></expr>;</expr_stmt>
              <expr_stmt><expr><name>total_len</name> = 0</expr>;</expr_stmt>
            }</block></then></if>
          <expr_stmt><expr><name>total_len</name> += <name>len</name></expr>;</expr_stmt>
        }</block></then>
      <else>else
        <block>{
          <expr_stmt><expr><name>total_len</name> += 1 + <name>len</name></expr>;</expr_stmt>
        }</block></else></if></else></if>
    }</block></while>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* base == "/" and no further components. just return that. */</comment>
  <if>if <condition>(<expr><name>base_is_root</name> &amp;&amp; <name>total_len</name> == 1</expr>)</condition><then>
    <return>return <expr><call><name>apr_pmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>"/"</expr></argument>, <argument><expr>2</expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* we got the total size. allocate it, with room for a NULL character. */</comment>
  <expr_stmt><expr><name>path</name> = <name>p</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>total_len</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* if we aren't supposed to skip forward to an absolute component, and if
     this is not an empty base that we are skipping, then copy the base
     into the output. */</comment>
  <if>if <condition>(<expr><name>base_arg</name> == 0 &amp;&amp; ! (<call><name>SVN_PATH_IS_EMPTY</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call> &amp;&amp; ! <name>base_is_empty</name>)</expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr><call><name>SVN_PATH_IS_EMPTY</name><argument_list>(<argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>SVN_EMPTY_PATH</name></expr></argument>, <argument><expr><name>len</name> = <name><name>saved_lengths</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
      <else>else
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>len</name> = <name><name>saved_lengths</name><index>[<expr>0</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
      <expr_stmt><expr><name>p</name> += <name>len</name></expr>;</expr_stmt>
    }</block></then></if>

  <expr_stmt><expr><name>nargs</name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>va</name></expr></argument>, <argument><expr><name>base</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while <condition>(<expr>(<name>s</name> = <call><name>va_arg</name><argument_list>(<argument><expr><name>va</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition>
    <block>{
      <if>if <condition>(<expr><call><name>SVN_PATH_IS_EMPTY</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <continue>continue;</continue></then></if>

      <if>if <condition>(<expr>++<name>nargs</name> &lt; <name>base_arg</name></expr>)</condition><then>
        <continue>continue;</continue></then></if>

      <if>if <condition>(<expr><name>nargs</name> &lt; <name>MAX_SAVED_LENGTHS</name></expr>)</condition><then>
        <expr_stmt><expr><name>len</name> = <name><name>saved_lengths</name><index>[<expr><name>nargs</name></expr>]</index></name></expr>;</expr_stmt></then>
      <else>else
        <expr_stmt><expr><name>len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

      <comment type="block">/* insert a separator if we aren't copying in the first component
         (which can happen when base_arg is set). also, don't put in a slash
         if the prior character is a slash (occurs when prior component
         is "/"). */</comment>
      <if>if <condition>(<expr><name>p</name> != <name>path</name> &amp;&amp; <name><name>p</name><index>[<expr>-1</expr>]</index></name> != '/'</expr>)</condition><then>
        <expr_stmt><expr>*<name>p</name>++ = '/'</expr>;</expr_stmt></then></if>

      <comment type="block">/* copy the new component and advance the pointer */</comment>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name> += <name>len</name></expr>;</expr_stmt>
    }</block></while>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>va</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr>*<name>p</name> = '\0'</expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call>(<name>apr_size_t</name>)<argument_list>(<argument><expr><name>p</name> - <name>path</name></expr></argument>)</argument_list></call> == <name>total_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>path</name></expr>;</return>
}</block></function>


<escape char="0xc"/>
<function><type><name>apr_size_t</name></type>
<name>svn_path_component_count</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>count</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>is_canonical</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <while>while <condition>(<expr>*<name>path</name></expr>)</condition>
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>start</name></decl>;</decl_stmt>

      <while>while <condition>(<expr>*<name>path</name> == '/'</expr>)</condition>
        <expr_stmt><expr>++<name>path</name></expr>;</expr_stmt></while>

      <expr_stmt><expr><name>start</name> = <name>path</name></expr>;</expr_stmt>

      <while>while <condition>(<expr>*<name>path</name> &amp;&amp; *<name>path</name> != '/'</expr>)</condition>
        <expr_stmt><expr>++<name>path</name></expr>;</expr_stmt></while>

      <if>if <condition>(<expr><name>path</name> != <name>start</name></expr>)</condition><then>
        <expr_stmt><expr>++<name>count</name></expr>;</expr_stmt></then></if>
    }</block></while>

  <return>return <expr><name>count</name></expr>;</return>
}</block></function>


<comment type="block">/* Return the length of substring necessary to encompass the entire
 * previous path segment in PATH, which should be a LEN byte string.
 *
 * A trailing slash will not be included in the returned length except
 * in the case in which PATH is absolute and there are no more
 * previous segments.
 */</comment>
<function><type><specifier>static</specifier> <name>apr_size_t</name></type>
<name>previous_segment</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                 <param><decl><type><name>apr_size_t</name></type> <name>len</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name>len</name> == 0</expr>)</condition><then>
    <return>return <expr>0</expr>;</return></then></if>

  <while>while <condition>(<expr><name>len</name> &gt; 0 &amp;&amp; <name><name>path</name><index>[<expr>--<name>len</name></expr>]</index></name> != '/'</expr>)</condition>
    <empty_stmt>;</empty_stmt></while>

  <if>if <condition>(<expr><name>len</name> == 0 &amp;&amp; <name><name>path</name><index>[<expr>0</expr>]</index></name> == '/'</expr>)</condition><then>
    <return>return <expr>1</expr>;</return></then>
  <else>else
    <return>return <expr><name>len</name></expr>;</return></else></if>
}</block></function>


<function><type><name>void</name></type>
<name>svn_path_add_component</name><parameter_list>(<param><decl><type><name>svn_stringbuf_t</name> *</type><name>path</name></decl></param>,
                       <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>component</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>component</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>is_canonical</name><argument_list>(<argument><expr><name><name>path</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>path</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>is_canonical</name><argument_list>(<argument><expr><name>component</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Append a dir separator, but only if this path is neither empty
     nor consists of a single dir separator already. */</comment>
  <if>if <condition>(<expr>(! <call><name>SVN_PATH_IS_EMPTY</name><argument_list>(<argument><expr><name><name>path</name>-&gt;<name>data</name></name></expr></argument>)</argument_list></call>)
      &amp;&amp; (! ((<name><name>path</name>-&gt;<name>len</name></name> == 1) &amp;&amp; (*(<name><name>path</name>-&gt;<name>data</name></name>) == '/')))</expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>char</name></type> <name>dirsep</name> <init>= <expr>'/'</expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>svn_stringbuf_appendbytes</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>&amp;<name>dirsep</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dirsep</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <expr_stmt><expr><call><name>svn_stringbuf_appendbytes</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>component</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<function><type><name>void</name></type>
<name>svn_path_remove_component</name><parameter_list>(<param><decl><type><name>svn_stringbuf_t</name> *</type><name>path</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>is_canonical</name><argument_list>(<argument><expr><name><name>path</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>path</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>path</name>-&gt;<name>len</name></name> = <call><name>previous_segment</name><argument_list>(<argument><expr><name><name>path</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>path</name>-&gt;<name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>path</name>-&gt;<name>data</name><index>[<expr><name><name>path</name>-&gt;<name>len</name></name></expr>]</index></name> = '\0'</expr>;</expr_stmt>
}</block></function>


<function><type><name>void</name></type>
<name>svn_path_remove_components</name><parameter_list>(<param><decl><type><name>svn_stringbuf_t</name> *</type><name>path</name></decl></param>, <param><decl><type><name>apr_size_t</name></type> <name>n</name></decl></param>)</parameter_list>
<block>{
  <while>while <condition>(<expr><name>n</name> &gt; 0</expr>)</condition>
    <block>{
      <expr_stmt><expr><call><name>svn_path_remove_component</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>n</name>--</expr>;</expr_stmt>
    }</block></while>
}</block></function>


<function><type><name>char</name> *</type>
<name>svn_path_dirname</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>is_canonical</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>previous_segment</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><name>char</name> *</type>
<name>svn_path_basename</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>start</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>is_canonical</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>len</name> == 1 &amp;&amp; <name><name>path</name><index>[<expr>0</expr>]</index></name> == '/'</expr>)</condition><then>
    <expr_stmt><expr><name>start</name> = 0</expr>;</expr_stmt></then>
  <else>else
    <block>{
      <expr_stmt><expr><name>start</name> = <name>len</name></expr>;</expr_stmt>
      <while>while <condition>(<expr><name>start</name> &gt; 0 &amp;&amp; <name><name>path</name><index>[<expr><name>start</name> - 1</expr>]</index></name> != '/'</expr>)</condition>
        <expr_stmt><expr>--<name>start</name></expr>;</expr_stmt></while>
    }</block></else></if>

  <return>return <expr><call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>path</name> + <name>start</name></expr></argument>, <argument><expr><name>len</name> - <name>start</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><name>void</name></type>
<name>svn_path_split</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
               <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>dirpath</name></decl></param>,
               <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>base_name</name></decl></param>,
               <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>dirpath</name> != <name>base_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>dirpath</name></expr>)</condition><then>
    <expr_stmt><expr>*<name>dirpath</name> = <call><name>svn_path_dirname</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <if>if <condition>(<expr><name>base_name</name></expr>)</condition><then>
    <expr_stmt><expr>*<name>base_name</name> = <call><name>svn_path_basename</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></function>


<function><type><name>int</name></type>
<name>svn_path_is_empty</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* assert (is_canonical (path, strlen (path))); ### Expensive strlen */</comment>

  <if>if <condition>(<expr><call><name>SVN_PATH_IS_EMPTY</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr>1</expr>;</return></then></if>

  <return>return <expr>0</expr>;</return>
}</block></function>


<comment type="block">/* We decided against using apr_filepath_root here because of the negative
   performance impact (creating a pool and converting strings ). */</comment>
<function><type><name>svn_boolean_t</name></type>
<name>svn_dirent_is_root</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>dirent</name></decl></param>, <param><decl><type><name>apr_size_t</name></type> <name>len</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* directory is root if it's equal to '/' */</comment>
  <if>if <condition>(<expr><name>len</name> == 1 &amp;&amp; <name><name>dirent</name><index>[<expr>0</expr>]</index></name> == '/'</expr>)</condition><then>
    <return>return <expr><name>TRUE</name></expr>;</return></then></if>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <comment type="block">/* On Windows and Cygwin, 'H:' or 'H:/' (where 'H' is any letter)
     are also root directories */</comment>
  <if>if <condition>(<expr>(<name>len</name> == 2 || <name>len</name> == 3) &amp;&amp;
      (<name><name>dirent</name><index>[<expr>1</expr>]</index></name> == ':') &amp;&amp;
      ((<name><name>dirent</name><index>[<expr>0</expr>]</index></name> &gt;= 'A' &amp;&amp; <name><name>dirent</name><index>[<expr>0</expr>]</index></name> &lt;= 'Z') ||
       (<name><name>dirent</name><index>[<expr>0</expr>]</index></name> &gt;= 'a' &amp;&amp; <name><name>dirent</name><index>[<expr>0</expr>]</index></name> &lt;= 'z')) &amp;&amp;
      (<name>len</name> == 2 || (<name><name>dirent</name><index>[<expr>2</expr>]</index></name> == '/' &amp;&amp; <name>len</name> == 3))</expr>)</condition><then>
    <return>return <expr><name>TRUE</name></expr>;</return></then></if>

  <comment type="block">/* On Windows and Cygwin, both //drive and //drive//share are root
     directories */</comment>
  <if>if <condition>(<expr><name>len</name> &gt;= 2 &amp;&amp; <name><name>dirent</name><index>[<expr>0</expr>]</index></name> == '/' &amp;&amp; <name><name>dirent</name><index>[<expr>1</expr>]</index></name> == '/'
      &amp;&amp; <name><name>dirent</name><index>[<expr><name>len</name> - 1</expr>]</index></name> != '/'</expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>int</name></type> <name>segments</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
      <for>for (<init><expr><name>i</name> = <name>len</name></expr>;</init> <condition><expr><name>i</name> &gt;= 2</expr>;</condition> <incr><expr><name>i</name>--</expr></incr>)
        <block>{
          <if>if <condition>(<expr><name><name>dirent</name><index>[<expr><name>i</name></expr>]</index></name> == '/'</expr>)</condition><then>
            <block>{
              <expr_stmt><expr><name>segments</name> ++</expr>;</expr_stmt>
              <if>if <condition>(<expr><name>segments</name> &gt; 1</expr>)</condition><then>
                <return>return <expr><name>FALSE</name></expr>;</return></then></if>
            }</block></then></if>
        }</block></for>
      <return>return <expr>(<name>segments</name> &lt;= 1)</expr>;</return>
    }</block></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* WIN32 or Cygwin */</comment>

  <return>return <expr><name>FALSE</name></expr>;</return>
}</block></function>


<function><type><name>int</name></type>
<name>svn_path_compare_paths</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path1</name></decl></param>,
                       <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path2</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>path1_len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>path1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>path2_len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>path2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>min_len</name> <init>= <expr>((<name>path1_len</name> &lt; <name>path2_len</name>) ? <name>path1_len</name> : <name>path2_len</name>)</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>is_canonical</name><argument_list>(<argument><expr><name>path1</name></expr></argument>, <argument><expr><name>path1_len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><call><name>is_canonical</name><argument_list>(<argument><expr><name>path2</name></expr></argument>, <argument><expr><name>path2_len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Skip past common prefix. */</comment>
  <while>while <condition>(<expr><name>i</name> &lt; <name>min_len</name> &amp;&amp; <name><name>path1</name><index>[<expr><name>i</name></expr>]</index></name> == <name><name>path2</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
    <expr_stmt><expr>++<name>i</name></expr>;</expr_stmt></while>

  <comment type="block">/* Are the paths exactly the same? */</comment>
  <if>if <condition>(<expr>(<name>path1_len</name> == <name>path2_len</name>) &amp;&amp; (<name>i</name> &gt;= <name>min_len</name>)</expr>)</condition><then>
    <return>return <expr>0</expr>;</return></then></if>

  <comment type="block">/* Children of paths are greater than their parents, but less than
     greater siblings of their parents. */</comment>
  <if>if <condition>(<expr>(<name><name>path1</name><index>[<expr><name>i</name></expr>]</index></name> == '/') &amp;&amp; (<name><name>path2</name><index>[<expr><name>i</name></expr>]</index></name> == 0)</expr>)</condition><then>
    <return>return <expr>1</expr>;</return></then></if>
  <if>if <condition>(<expr>(<name><name>path2</name><index>[<expr><name>i</name></expr>]</index></name> == '/') &amp;&amp; (<name><name>path1</name><index>[<expr><name>i</name></expr>]</index></name> == 0)</expr>)</condition><then>
    <return>return <expr>-1</expr>;</return></then></if>
  <if>if <condition>(<expr><name><name>path1</name><index>[<expr><name>i</name></expr>]</index></name> == '/'</expr>)</condition><then>
    <return>return <expr>-1</expr>;</return></then></if>
  <if>if <condition>(<expr><name><name>path2</name><index>[<expr><name>i</name></expr>]</index></name> == '/'</expr>)</condition><then>
    <return>return <expr>1</expr>;</return></then></if>

  <comment type="block">/* Common prefix was skipped above, next character is compared to
     determine order.  We need to use an unsigned comparison, though,
     so a "next character" of NULL (0x00) sorts numerically
     smallest. */</comment>
  <return>return <expr><call>(<name>unsigned</name> <name>char</name>)<argument_list>(<argument><expr><name><name>path1</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> &lt; <call>(<name>unsigned</name> <name>char</name>)<argument_list>(<argument><expr><name><name>path2</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> ? -1 : 1</expr>;</return>
}</block></function>


<comment type="block">/* Return the string length of the longest common ancestor of PATH1 and PATH2.
 *
 * This function handles everything except the URL-handling logic
 * of svn_path_get_longest_ancestor, and assumes that PATH1 and
 * PATH2 are *not* URLs.
 *
 * If the two paths do not share a common ancestor, return 0.
 *
 * New strings are allocated in POOL.
 */</comment>
<function><type><specifier>static</specifier> <name>apr_size_t</name></type>
<name>get_path_ancestor_length</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path1</name></decl></param>,
                         <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path2</name></decl></param>,
                         <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>path1_len</name></decl>, <decl><type ref="prev"/><name>path2_len</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>last_dirsep</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>path1_len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>path1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>path2_len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>path2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><call><name>SVN_PATH_IS_EMPTY</name><argument_list>(<argument><expr><name>path1</name></expr></argument>)</argument_list></call> || <call><name>SVN_PATH_IS_EMPTY</name><argument_list>(<argument><expr><name>path2</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr>0</expr>;</return></then></if>

  <while>while <condition>(<expr><name><name>path1</name><index>[<expr><name>i</name></expr>]</index></name> == <name><name>path2</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
    <block>{
      <comment type="block">/* Keep track of the last directory separator we hit. */</comment>
      <if>if <condition>(<expr><name><name>path1</name><index>[<expr><name>i</name></expr>]</index></name> == '/'</expr>)</condition><then>
        <expr_stmt><expr><name>last_dirsep</name> = <name>i</name></expr>;</expr_stmt></then></if>

      <expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>

      <comment type="block">/* If we get to the end of either path, break out. */</comment>
      <if>if <condition>(<expr>(<name>i</name> == <name>path1_len</name>) || (<name>i</name> == <name>path2_len</name>)</expr>)</condition><then>
        <break>break;</break></then></if>
    }</block></while>

  <comment type="block">/* two special cases:
     1. '/' is the longest common ancestor of '/' and '/foo'
     2. '/' is the longest common ancestor of '/rif' and '/raf' */</comment>
  <if>if <condition>(<expr><name>i</name> == 1 &amp;&amp; <name><name>path1</name><index>[<expr>0</expr>]</index></name> == '/' &amp;&amp; <name><name>path2</name><index>[<expr>0</expr>]</index></name> == '/'</expr>)</condition><then>
    <return>return <expr>1</expr>;</return></then></if>

  <comment type="block">/* last_dirsep is now the offset of the last directory separator we
     crossed before reaching a non-matching byte.  i is the offset of
     that non-matching byte. */</comment>
  <if>if <condition>(<expr>((<name>i</name> == <name>path1_len</name>) &amp;&amp; (<name><name>path2</name><index>[<expr><name>i</name></expr>]</index></name> == '/'))
           || ((<name>i</name> == <name>path2_len</name>) &amp;&amp; (<name><name>path1</name><index>[<expr><name>i</name></expr>]</index></name> == '/'))
           || ((<name>i</name> == <name>path1_len</name>) &amp;&amp; (<name>i</name> == <name>path2_len</name>))</expr>)</condition><then>
    <return>return <expr><name>i</name></expr>;</return></then>
  <else>else
    <if>if <condition>(<expr><name>last_dirsep</name> == 0 &amp;&amp; <name><name>path1</name><index>[<expr>0</expr>]</index></name> == '/' &amp;&amp; <name><name>path2</name><index>[<expr>0</expr>]</index></name> == '/'</expr>)</condition><then>
      <return>return <expr>1</expr>;</return></then></if></else></if>
    <return>return <expr><name>last_dirsep</name></expr>;</return>
}</block></function>


<function><type><name>char</name> *</type>
<name>svn_path_get_longest_ancestor</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path1</name></decl></param>,
                              <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path2</name></decl></param>,
                              <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>path1_is_url</name></decl>, <decl><type ref="prev"/><name>path2_is_url</name></decl>;</decl_stmt>
  <expr_stmt><expr><name>path1_is_url</name> = <call><name>svn_path_is_url</name><argument_list>(<argument><expr><name>path1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>path2_is_url</name> = <call><name>svn_path_is_url</name><argument_list>(<argument><expr><name>path2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name>path1_is_url</name> &amp;&amp; <name>path2_is_url</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>apr_size_t</name></type> <name>path_ancestor_len</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_size_t</name></type> <name>i</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

      <comment type="block">/* Find ':' */</comment>
      <while>while <condition>(<expr>1</expr>)</condition>
        <block>{
          <comment type="block">/* No shared protocol =&gt; no common prefix */</comment>
          <if>if <condition>(<expr><name><name>path1</name><index>[<expr><name>i</name></expr>]</index></name> != <name><name>path2</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then>
            <return>return <expr><call><name>apr_pmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>SVN_EMPTY_PATH</name></expr></argument>,
                               <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SVN_EMPTY_PATH</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return></then></if>

          <if>if <condition>(<expr><name><name>path1</name><index>[<expr><name>i</name></expr>]</index></name> == ':'</expr>)</condition><then>
            <break>break;</break></then></if>

          <comment type="block">/* They're both URLs, so EOS can't come before ':' */</comment>
          <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr>(<name><name>path1</name><index>[<expr><name>i</name></expr>]</index></name> != '\0') &amp;&amp; (<name><name>path2</name><index>[<expr><name>i</name></expr>]</index></name> != '\0')</expr></argument>)</argument_list></call></expr>;</expr_stmt>

          <expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
        }</block></while>

      <expr_stmt><expr><name>i</name> += 3</expr>;</expr_stmt>  <comment type="block">/* Advance past '://' */</comment>

      <expr_stmt><expr><name>path_ancestor_len</name> = <call><name>get_path_ancestor_length</name><argument_list>(<argument><expr><name>path1</name> + <name>i</name></expr></argument>, <argument><expr><name>path2</name> + <name>i</name></expr></argument>,
                                                   <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr><name>path_ancestor_len</name> == 0 ||
          (<name>path_ancestor_len</name> == 1 &amp;&amp; (<name>path1</name> + <name>i</name>)<index>[<expr>0</expr>]</index> == '/')</expr>)</condition><then>
        <return>return <expr><call><name>apr_pmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>SVN_EMPTY_PATH</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SVN_EMPTY_PATH</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return></then>
      <else>else
        <return>return <expr><call><name>apr_pstrndup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>path1</name></expr></argument>, <argument><expr><name>path_ancestor_len</name> + <name>i</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
    }</block></then>

  <else>else <if>if <condition>(<expr>(! <name>path1_is_url</name>) &amp;&amp; (! <name>path2_is_url</name>)</expr>)</condition><then>
    <block>{
      <return>return <expr><call><name>apr_pstrndup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>path1</name></expr></argument>,
                          <argument><expr><call><name>get_path_ancestor_length</name><argument_list>(<argument><expr><name>path1</name></expr></argument>, <argument><expr><name>path2</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></then>

  <else>else
    <block>{
      <comment type="block">/* A URL and a non-URL =&gt; no common prefix */</comment>
      <return>return <expr><call><name>apr_pmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>SVN_EMPTY_PATH</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SVN_EMPTY_PATH</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
    }</block></else></if></else></if>
}</block></function>


<function><type><specifier>const</specifier> <name>char</name> *</type>
<name>svn_path_is_child</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path1</name></decl></param>,
                  <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path2</name></decl></param>,
                  <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>i</name></decl>;</decl_stmt>

  <comment type="block">/* assert (is_canonical (path1, strlen (path1)));  ### Expensive strlen */</comment>
  <comment type="block">/* assert (is_canonical (path2, strlen (path2)));  ### Expensive strlen */</comment>

  <comment type="block">/* Allow "" and "foo" to be parent/child */</comment>
  <if>if <condition>(<expr><call><name>SVN_PATH_IS_EMPTY</name><argument_list>(<argument><expr><name>path1</name></expr></argument>)</argument_list></call></expr>)</condition><then>               <comment type="block">/* "" is the parent  */</comment>
    <block>{
      <if>if <condition>(<expr><call><name>SVN_PATH_IS_EMPTY</name><argument_list>(<argument><expr><name>path2</name></expr></argument>)</argument_list></call>            <comment type="block">/* "" not a child    */</comment>
          || <name><name>path2</name><index>[<expr>0</expr>]</index></name> == '/'</expr>)</condition><then>                  <comment type="block">/* "/foo" not a child */</comment>
        <return>return <expr><name>NULL</name></expr>;</return></then>
      <else>else
        <comment type="block">/* everything else is child */</comment>
        <return>return <expr><name>pool</name> ? <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>path2</name></expr></argument>)</argument_list></call> : <name>path2</name></expr>;</return></else></if>
    }</block></then></if>

  <comment type="block">/* Reach the end of at least one of the paths.  How should we handle
     things like path1:"foo///bar" and path2:"foo/bar/baz"?  It doesn't
     appear to arise in the current Subversion code, it's not clear to me
     if they should be parent/child or not. */</comment>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name><name>path1</name><index>[<expr><name>i</name></expr>]</index></name> &amp;&amp; <name><name>path2</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <if>if <condition>(<expr><name><name>path1</name><index>[<expr><name>i</name></expr>]</index></name> != <name><name>path2</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then>
      <return>return <expr><name>NULL</name></expr>;</return></then></if></for>

  <comment type="block">/* There are two cases that are parent/child
          ...      path1[i] == '\0'
          .../foo  path2[i] == '/'
      or
          /        path1[i] == '\0'
          /foo     path2[i] != '/'
  */</comment>
  <if>if <condition>(<expr><name><name>path1</name><index>[<expr><name>i</name></expr>]</index></name> == '\0' &amp;&amp; <name><name>path2</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><then>
    <block>{
      <if>if <condition>(<expr><name><name>path2</name><index>[<expr><name>i</name></expr>]</index></name> == '/'</expr>)</condition><then>
        <return>return <expr><name>pool</name> ? <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>path2</name> + <name>i</name> + 1</expr></argument>)</argument_list></call> : <name>path2</name> + <name>i</name> + 1</expr>;</return></then>
      <else>else <if>if <condition>(<expr><name>i</name> == 1 &amp;&amp; <name><name>path1</name><index>[<expr>0</expr>]</index></name> == '/'</expr>)</condition><then>
        <return>return <expr><name>pool</name> ? <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>path2</name> + 1</expr></argument>)</argument_list></call> : <name>path2</name> + 1</expr>;</return></then></if></else></if>
    }</block></then></if>

  <comment type="block">/* Otherwise, path2 isn't a child. */</comment>
  <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>


<function><type><name>svn_boolean_t</name></type>
<name>svn_path_is_ancestor</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path1</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path2</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>path1_len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>path1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="block">/* If path1 is empty and path2 is not absoulte, then path1 is an ancestor. */</comment>
  <if>if <condition>(<expr><call><name>SVN_PATH_IS_EMPTY</name><argument_list>(<argument><expr><name>path1</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr>*<name>path2</name> != '/'</expr>;</return></then></if>

  <comment type="block">/* If path1 is a prefix of path2, then:
     - If path1 ends in a path separator,
     - If the paths are of the same length
     OR
     - path2 starts a new path component after the common prefix,
     then path1 is an ancestor. */</comment>
  <if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>path1</name></expr></argument>, <argument><expr><name>path2</name></expr></argument>, <argument><expr><name>path1_len</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
    <return>return <expr><name><name>path1</name><index>[<expr><name>path1_len</name> - 1</expr>]</index></name> == '/'
      || (<name><name>path2</name><index>[<expr><name>path1_len</name></expr>]</index></name> == '/' || <name><name>path2</name><index>[<expr><name>path1_len</name></expr>]</index></name> == '\0')</expr>;</return></then></if>

  <return>return <expr><name>FALSE</name></expr>;</return>
}</block></function>


<function><type><name>apr_array_header_t</name> *</type>
<name>svn_path_decompose</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                   <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>oldi</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>apr_array_header_t</name> *</type><name>components</name> <init>=
    <expr><call><name>apr_array_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>const <name>char</name> *</expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="block">/* assert (is_canonical (path, strlen (path)));  ### Expensive strlen */</comment>

  <if>if <condition>(<expr><call><name>SVN_PATH_IS_EMPTY</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>components</name></expr>;</return></then></if>  <comment type="block">/* ### Should we return a "" component? */</comment>

  <comment type="block">/* If PATH is absolute, store the '/' as the first component. */</comment>
  <expr_stmt><expr><name>i</name> = <name>oldi</name> = 0</expr>;</expr_stmt>
  <if>if <condition>(<expr><name><name>path</name><index>[<expr><name>i</name></expr>]</index></name> == '/'</expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>char</name></type> <name>dirsep</name> <init>= <expr>'/'</expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>components</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call>
        = <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr>&amp;<name>dirsep</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>dirsep</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
      <expr_stmt><expr><name>oldi</name>++</expr>;</expr_stmt>
      <if>if <condition>(<expr><name><name>path</name><index>[<expr><name>i</name></expr>]</index></name> == '\0'</expr>)</condition><then> <comment type="block">/* path is a single '/' */</comment>
        <return>return <expr><name>components</name></expr>;</return></then></if>
    }</block></then></if>

  <do>do
    <block>{
      <if>if <condition>(<expr>(<name><name>path</name><index>[<expr><name>i</name></expr>]</index></name> == '/') || (<name><name>path</name><index>[<expr><name>i</name></expr>]</index></name> == '\0')</expr>)</condition><then>
        <block>{
          <if>if <condition>(<expr><call><name>SVN_PATH_IS_PLATFORM_EMPTY</name><argument_list>(<argument><expr><name>path</name> + <name>oldi</name></expr></argument>, <argument><expr><name>i</name> - <name>oldi</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>components</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call> = <name>SVN_EMPTY_PATH</name></expr>;</expr_stmt></then>
          <else>else
            <expr_stmt><expr><call><name>APR_ARRAY_PUSH</name><argument_list>(<argument><expr><name>components</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call>
              = <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>path</name> + <name>oldi</name></expr></argument>, <argument><expr><name>i</name> - <name>oldi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>

          <expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
          <expr_stmt><expr><name>oldi</name> = <name>i</name></expr>;</expr_stmt>  <comment type="block">/* skipping past the dirsep */</comment>
          <continue>continue;</continue>
        }</block></then></if>
      <expr_stmt><expr><name>i</name>++</expr>;</expr_stmt>
    }</block>
  while <condition>(<expr><name><name>path</name><index>[<expr><name>i</name>-1</expr>]</index></name></expr>)</condition>;</do>

  <return>return <expr><name>components</name></expr>;</return>
}</block></function>


<function><type><specifier>const</specifier> <name>char</name> *</type>
<name>svn_path_compose</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>apr_array_header_t</name> *</type><name>components</name></decl></param>,
                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_size_t</name> *</type><name>lengths</name> <init>= <expr><call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name><name>components</name>-&gt;<name>nelts</name></name>*<sizeof>sizeof<argument_list>(<argument><expr>*<name>lengths</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>max_length</name> <init>= <expr><name><name>components</name>-&gt;<name>nelts</name></name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>path</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>p</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

  <comment type="block">/* Get the length of each component so a total length can be
     calculated. */</comment>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>components</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>)
    <block>{
      <decl_stmt><decl><type><name>apr_size_t</name></type> <name>l</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>components</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><name><name>lengths</name><index>[<expr><name>i</name></expr>]</index></name> = <name>l</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>max_length</name> += <name>l</name></expr>;</expr_stmt>
    }</block></for>

  <expr_stmt><expr><name>path</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>max_length</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>p</name> = <name>path</name></expr>;</expr_stmt>

  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name>i</name> &lt; <name><name>components</name>-&gt;<name>nelts</name></name></expr>;</condition> <incr><expr>++<name>i</name></expr></incr>)
    <block>{
      <comment type="block">/* Append a '/' to the path.  Handle the case with an absolute
         path where a '/' appears in the first component.  Only append
         a '/' if the component is the second component that does not
         follow a "/" first component; or it is the third or later
         component. */</comment>
      <if>if <condition>(<expr><name>i</name> &gt; 1 ||
          (<name>i</name> == 1 &amp;&amp; <call><name>strcmp</name><argument_list>(<argument><expr>"/"</expr></argument>, <argument><expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>components</name></expr></argument>,
                                               <argument><expr>0</expr></argument>,
                                               <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> != 0)</expr>)</condition><then>
        <block>{
          <expr_stmt><expr>*<name>p</name>++ = '/'</expr>;</expr_stmt>
        }</block></then></if>

      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><call><name>APR_ARRAY_IDX</name><argument_list>(<argument><expr><name>components</name></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>lengths</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>p</name> += <name><name>lengths</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
    }</block></for>

  <expr_stmt><expr>*<name>p</name> = '\0'</expr>;</expr_stmt>

  <return>return <expr><name>path</name></expr>;</return>
}</block></function>


<function><type><name>svn_boolean_t</name></type>
<name>svn_path_is_single_path_component</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* assert (is_canonical (name, strlen (name)));  ### Expensive strlen */</comment>

  <comment type="block">/* Can't be empty or `..'  */</comment>
  <if>if <condition>(<expr><call><name>SVN_PATH_IS_EMPTY</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call>
      || (<name><name>name</name><index>[<expr>0</expr>]</index></name> == '.' &amp;&amp; <name><name>name</name><index>[<expr>1</expr>]</index></name> == '.' &amp;&amp; <name><name>name</name><index>[<expr>2</expr>]</index></name> == '\0')</expr>)</condition><then>
    <return>return <expr><name>FALSE</name></expr>;</return></then></if>

  <comment type="block">/* Slashes are bad, m'kay... */</comment>
  <if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr>'/'</expr></argument>)</argument_list></call> != <name>NULL</name></expr>)</condition><then>
    <return>return <expr><name>FALSE</name></expr>;</return></then></if>

  <comment type="block">/* It is valid.  */</comment>
  <return>return <expr><name>TRUE</name></expr>;</return>
}</block></function>


<function><type><name>svn_boolean_t</name></type>
<name>svn_path_is_backpath_present</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr>! <call><name>strcmp</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>".."</expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>TRUE</name></expr>;</return></then></if>

  <if>if <condition>(<expr>! <call><name>strncmp</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>"../"</expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>TRUE</name></expr>;</return></then></if>

  <if>if <condition>(<expr><call><name>strstr</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>"/../"</expr></argument>)</argument_list></call> != <name>NULL</name></expr>)</condition><then>
    <return>return <expr><name>TRUE</name></expr>;</return></then></if>

  <if>if <condition>(<expr><name>len</name> &gt;= 3
      &amp;&amp; (! <call><name>strncmp</name><argument_list>(<argument><expr><name>path</name> + <name>len</name> - 3</expr></argument>, <argument><expr>"/.."</expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call>)</expr>)</condition><then>
    <return>return <expr><name>TRUE</name></expr>;</return></then></if>

  <return>return <expr><name>FALSE</name></expr>;</return>
}</block></function>

<escape char="0xc"/>
<comment type="block">/*** URI Stuff ***/</comment>

<comment type="block">/* Examine PATH as a potential URI, and return a substring of PATH
   that immediately follows the (scheme):// portion of the URI, or
   NULL if PATH doesn't appear to be a valid URI.  The returned value
   is not alloced -- it shares memory with PATH. */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type>
<name>skip_uri_scheme</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>j</name></decl>;</decl_stmt>

  <comment type="block">/* A scheme is terminated by a : and cannot contain any /'s. */</comment>
  <for>for (<init><expr><name>j</name> = 0</expr>;</init> <condition><expr><name><name>path</name><index>[<expr><name>j</name></expr>]</index></name> &amp;&amp; <name><name>path</name><index>[<expr><name>j</name></expr>]</index></name> != ':'</expr>;</condition> <incr><expr>++<name>j</name></expr></incr>)
    <if>if <condition>(<expr><name><name>path</name><index>[<expr><name>j</name></expr>]</index></name> == '/'</expr>)</condition><then>
      <return>return <expr><name>NULL</name></expr>;</return></then></if></for>

  <if>if <condition>(<expr><name>j</name> &gt; 0 &amp;&amp; <name><name>path</name><index>[<expr><name>j</name></expr>]</index></name> == ':' &amp;&amp; <name><name>path</name><index>[<expr><name>j</name>+1</expr>]</index></name> == '/' &amp;&amp; <name><name>path</name><index>[<expr><name>j</name>+2</expr>]</index></name> == '/'</expr>)</condition><then>
    <return>return <expr><name>path</name> + <name>j</name> + 3</expr>;</return></then></if>

  <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>


<function><type><name>svn_boolean_t</name></type>
<name>svn_path_is_url</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* ### This function is reaaaaaaaaaaaaaally stupid right now.
     We're just going to look for:

        (scheme)://(optional_stuff)

     Where (scheme) has no ':' or '/' characters.

     Someday it might be nice to have an actual URI parser here.
  */</comment>
  <return>return <expr><call><name>skip_uri_scheme</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call> ? <name>TRUE</name> : <name>FALSE</name></expr>;</return>
}</block></function>



<comment type="block">/* Here is the BNF for path components in a URI. "pchar" is a
   character in a path component.

      pchar       = unreserved | escaped |
                    ":" | "@" | "&amp;" | "=" | "+" | "$" | ","
      unreserved  = alphanum | mark
      mark        = "-" | "_" | "." | "!" | "~" | "*" | "'" | "(" | ")"

   Note that "escaped" doesn't really apply to what users can put in
   their paths, so that really means the set of characters is:

      alphanum | mark | ":" | "@" | "&amp;" | "=" | "+" | "$" | ","
*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>uri_char_validity</name><index>[<expr>256</expr>]</index></name> <init>= <expr><block>{
  <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,   <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
  <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,   <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
  <expr>0</expr>, <expr>1</expr>, <expr>0</expr>, <expr>0</expr>, <expr>1</expr>, <expr>0</expr>, <expr>1</expr>, <expr>1</expr>,   <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
  <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,   <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>0</expr>, <expr>0</expr>, <expr>1</expr>, <expr>0</expr>, <expr>0</expr>,

  <comment type="block">/* 64 */</comment>
  <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,   <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
  <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,   <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>1</expr>,
  <expr>0</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,   <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
  <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,   <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>1</expr>, <expr>0</expr>,

  <comment type="block">/* 128 */</comment>
  <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,   <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
  <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,   <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
  <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,   <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
  <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,   <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,

  <comment type="block">/* 192 */</comment>
  <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,   <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
  <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,   <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
  <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,   <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
  <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,   <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
}</block></expr></init></decl>;</decl_stmt>


<function><type><name>svn_boolean_t</name></type>
<name>svn_path_is_uri_safe</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>i</name></decl>;</decl_stmt>

  <comment type="block">/* Skip the URI scheme. */</comment>
  <expr_stmt><expr><name>path</name> = <call><name>skip_uri_scheme</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* No scheme?  Get outta here. */</comment>
  <if>if <condition>(<expr>! <name>path</name></expr>)</condition><then>
    <return>return <expr><name>FALSE</name></expr>;</return></then></if>

  <comment type="block">/* Skip to the first slash that's after the URI scheme. */</comment>
  <expr_stmt><expr><name>path</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>'/'</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If there's no first slash, then there's only a host portion;
     therefore there couldn't be any uri-unsafe characters after the
     host... so return true. */</comment>
  <if>if <condition>(<expr><name>path</name> == <name>NULL</name></expr>)</condition><then>
    <return>return <expr><name>TRUE</name></expr>;</return></then></if>

  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name><name>path</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <comment type="block">/* Allow '%XX' (where each X is a hex digit) */</comment>
      <if>if <condition>(<expr><name><name>path</name><index>[<expr><name>i</name></expr>]</index></name> == '%'</expr>)</condition><then>
        <block>{
          <if>if <condition>(<expr><call><name>apr_isxdigit</name><argument_list>(<argument><expr><name><name>path</name><index>[<expr><name>i</name> + 1</expr>]</index></name></expr></argument>)</argument_list></call> &amp;&amp; <call><name>apr_isxdigit</name><argument_list>(<argument><expr><name><name>path</name><index>[<expr><name>i</name> + 2</expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <block>{
              <expr_stmt><expr><name>i</name> += 2</expr>;</expr_stmt>
              <continue>continue;</continue>
            }</block></then></if>
          <return>return <expr><name>FALSE</name></expr>;</return>
        }</block></then>
      <else>else <if>if <condition>(<expr>! <name><name>uri_char_validity</name><index>[<expr>((<name>unsigned</name> <name>char</name>)<name><name>path</name><index>[<expr><name>i</name></expr>]</index></name>)</expr>]</index></name></expr>)</condition><then>
        <block>{
          <return>return <expr><name>FALSE</name></expr>;</return>
        }</block></then></if></else></if>
    }</block></for>

  <return>return <expr><name>TRUE</name></expr>;</return>
}</block></function>


<comment type="block">/* URI-encode each character c in PATH for which TABLE[c] is 0.
   If no encoding was needed, return PATH, else return a new string allocated
   in POOL. */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type>
<name>uri_escape</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name></type> <name><name>table</name><index>[]</index></name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>retstr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>copied</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>retstr</name> = <call><name>svn_stringbuf_create</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name><name>path</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <expr_stmt><expr><name>c</name> = (<name>unsigned</name> <name>char</name>)<name><name>path</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
      <if>if <condition>(<expr><name><name>table</name><index>[<expr><name>c</name></expr>]</index></name></expr>)</condition><then>
        <continue>continue;</continue></then></if>

      <comment type="block">/* If we got here, we're looking at a character that isn't
         supported by the (or at least, our) URI encoding scheme.  We
         need to escape this character.  */</comment>

      <comment type="block">/* First things first, copy all the good stuff that we haven't
         yet copied into our output buffer. */</comment>
      <if>if <condition>(<expr><name>i</name> - <name>copied</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>svn_stringbuf_appendbytes</name><argument_list>(<argument><expr><name>retstr</name></expr></argument>, <argument><expr><name>path</name> + <name>copied</name></expr></argument>,
                                  <argument><expr><name>i</name> - <name>copied</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

      <comment type="block">/* Now, sprintf() in our escaped character, making sure our
         buffer is big enough to hold the '%' and two digits.  We cast
         the C to unsigned char here because the 'X' format character
         will be tempted to treat it as an unsigned int...which causes
         problem when messing with 0x80-0xFF chars.  We also need space
         for a null as sprintf will write one. */</comment>
      <expr_stmt><expr><call><name>svn_stringbuf_ensure</name><argument_list>(<argument><expr><name>retstr</name></expr></argument>, <argument><expr><name><name>retstr</name>-&gt;<name>len</name></name> + 4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name><name>retstr</name>-&gt;<name>data</name></name> + <name><name>retstr</name>-&gt;<name>len</name></name></expr></argument>, <argument><expr>"%%%02X"</expr></argument>, <argument><expr>(<name>unsigned</name> <name>char</name>)<name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>retstr</name>-&gt;<name>len</name></name> += 3</expr>;</expr_stmt>

      <comment type="block">/* Finally, update our copy counter. */</comment>
      <expr_stmt><expr><name>copied</name> = <name>i</name> + 1</expr>;</expr_stmt>
    }</block></for>

  <comment type="block">/* If we didn't encode anything, we don't need to duplicate the string. */</comment>
  <if>if <condition>(<expr><name><name>retstr</name>-&gt;<name>len</name></name> == 0</expr>)</condition><then>
    <return>return <expr><name>path</name></expr>;</return></then></if>

  <comment type="block">/* Anything left to copy? */</comment>
  <if>if <condition>(<expr><name>i</name> - <name>copied</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>svn_stringbuf_appendbytes</name><argument_list>(<argument><expr><name>retstr</name></expr></argument>, <argument><expr><name>path</name> + <name>copied</name></expr></argument>, <argument><expr><name>i</name> - <name>copied</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* retstr is null-terminated either by sprintf or the svn_stringbuf
     functions. */</comment>

  <return>return <expr><name><name>retstr</name>-&gt;<name>data</name></name></expr>;</return>
}</block></function>


<function><type><specifier>const</specifier> <name>char</name> *</type>
<name>svn_path_uri_encode</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>ret</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>ret</name> = <call><name>uri_escape</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>uri_char_validity</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Our interface guarantees a copy. */</comment>
  <if>if <condition>(<expr><name>ret</name> == <name>path</name></expr>)</condition><then>
    <return>return <expr><call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</return></then>
  <else>else
    <return>return <expr><name>ret</name></expr>;</return></else></if>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>iri_escape_chars</name><index>[<expr>256</expr>]</index></name> <init>= <expr><block>{
  <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,  <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
  <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,  <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
  <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,  <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
  <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,  <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
  <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,  <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
  <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,  <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
  <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,  <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
  <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,  <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,

  <comment type="block">/* 128 */</comment>
  <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,  <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
  <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,  <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
  <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,  <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
  <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,  <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
  <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,  <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
  <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,  <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
  <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,  <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,
  <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>,  <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>const</specifier> <name>char</name> *</type>
<name>svn_path_uri_from_iri</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>iri</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>uri_escape</name><argument_list>(<argument><expr><name>iri</name></expr></argument>, <argument><expr><name>iri_escape_chars</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>uri_autoescape_chars</name><index>[<expr>256</expr>]</index></name> <init>= <expr><block>{
  <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,  <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
  <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,  <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
  <expr>0</expr>, <expr>1</expr>, <expr>0</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,  <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
  <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,  <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>0</expr>, <expr>1</expr>, <expr>0</expr>, <expr>1</expr>,

  <comment type="block">/* 64 */</comment>
  <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,  <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
  <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,  <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>0</expr>, <expr>1</expr>, <expr>0</expr>, <expr>1</expr>,
  <expr>0</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,  <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
  <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,  <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>0</expr>, <expr>0</expr>, <expr>0</expr>, <expr>1</expr>, <expr>1</expr>,

  <comment type="block">/* 128 */</comment>
  <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,  <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
  <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,  <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
  <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,  <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
  <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,  <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,

  <comment type="block">/* 192 */</comment>
  <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,  <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
  <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,  <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
  <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,  <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
  <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,  <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>, <expr>1</expr>,
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>const</specifier> <name>char</name> *</type>
<name>svn_path_uri_autoescape</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>uri</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>uri_escape</name><argument_list>(<argument><expr><name>uri</name></expr></argument>, <argument><expr><name>uri_autoescape_chars</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>const</specifier> <name>char</name> *</type>
<name>svn_path_uri_decode</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>retstr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>i</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>query_start</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><name>retstr</name> = <call><name>svn_stringbuf_create</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* avoid repeated realloc */</comment>
  <expr_stmt><expr><call><name>svn_stringbuf_ensure</name><argument_list>(<argument><expr><name>retstr</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>retstr</name>-&gt;<name>len</name></name> = 0</expr>;</expr_stmt>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name><name>path</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <decl_stmt><decl><type><name>char</name></type> <name>c</name> <init>= <expr><name><name>path</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

      <if>if <condition>(<expr><name>c</name> == '?'</expr>)</condition><then>
        <block>{
          <comment type="block">/* Mark the start of the query string, if it exists. */</comment>
          <expr_stmt><expr><name>query_start</name> = <name>TRUE</name></expr>;</expr_stmt>
        }</block></then>
      <else>else <if>if <condition>(<expr><name>c</name> == '+' &amp;&amp; <name>query_start</name></expr>)</condition><then>
        <block>{
          <comment type="block">/* Only do this if we are into the query string.
           * RFC 2396, section 3.3  */</comment>
          <expr_stmt><expr><name>c</name> = ' '</expr>;</expr_stmt>
        }</block></then>
      <else>else <if>if <condition>(<expr><name>c</name> == '%' &amp;&amp; <call><name>apr_isxdigit</name><argument_list>(<argument><expr><name><name>path</name><index>[<expr><name>i</name> + 1</expr>]</index></name></expr></argument>)</argument_list></call>
               &amp;&amp; <call><name>apr_isxdigit</name><argument_list>(<argument><expr><name><name>path</name><index>[<expr><name>i</name>+2</expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <decl_stmt><decl><type><name>char</name></type> <name><name>digitz</name><index>[<expr>3</expr>]</index></name></decl>;</decl_stmt>
          <expr_stmt><expr><name><name>digitz</name><index>[<expr>0</expr>]</index></name> = <name><name>path</name><index>[<expr>++<name>i</name></expr>]</index></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>digitz</name><index>[<expr>1</expr>]</index></name> = <name><name>path</name><index>[<expr>++<name>i</name></expr>]</index></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>digitz</name><index>[<expr>2</expr>]</index></name> = '\0'</expr>;</expr_stmt>
          <expr_stmt><expr><name>c</name> = <call>(<name>char</name>)<argument_list>(<argument><expr><call><name>strtol</name><argument_list>(<argument><expr><name>digitz</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>16</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if></else></if></else></if>

      <expr_stmt><expr><name><name>retstr</name>-&gt;<name>data</name><index>[<expr><name><name>retstr</name>-&gt;<name>len</name></name>++</expr>]</index></name> = <name>c</name></expr>;</expr_stmt>
    }</block></for>

  <comment type="block">/* Null-terminate this bad-boy. */</comment>
  <expr_stmt><expr><name><name>retstr</name>-&gt;<name>data</name><index>[<expr><name><name>retstr</name>-&gt;<name>len</name></name></expr>]</index></name> = 0</expr>;</expr_stmt>

  <return>return <expr><name><name>retstr</name>-&gt;<name>data</name></name></expr>;</return>
}</block></function>


<function><type><specifier>const</specifier> <name>char</name> *</type>
<name>svn_path_url_add_component</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>url</name></decl></param>,
                           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>component</name></decl></param>,
                           <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* URL can have trailing '/' */</comment>
  <expr_stmt><expr><name>url</name> = <call><name>svn_path_canonicalize</name><argument_list>(<argument><expr><name>url</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><call><name>svn_path_join</name><argument_list>(<argument><expr><name>url</name></expr></argument>, <argument><expr><call><name>svn_path_uri_encode</name><argument_list>(<argument><expr><name>component</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_path_get_absolute</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>pabsolute</name></decl></param>,
                      <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>relative</name></decl></param>,
                      <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>char</name> *</type><name>buffer</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_status_t</name></type> <name>apr_err</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path_apr</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><call><name>svn_path_is_url</name><argument_list>(<argument><expr><name>relative</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <expr_stmt><expr>*<name>pabsolute</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>relative</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_path_cstring_from_utf8</name><argument_list>(<argument><expr>&amp;<name>path_apr</name></expr></argument>, <argument><expr><name>relative</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>apr_err</name> = <call><name>apr_filepath_merge</name><argument_list>(<argument><expr>&amp;<name>buffer</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                               <argument><expr><name>path_apr</name></expr></argument>,
                               <argument><expr><name>APR_FILEPATH_NOTRELATIVE</name>
                               | <name>APR_FILEPATH_TRUENAME</name></expr></argument>,
                               <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>apr_err</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_BAD_FILENAME</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                             <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Couldn't determine absolute path of '%s'"</expr></argument>)</argument_list></call></expr></argument>,
                             <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>relative</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_path_cstring_to_utf8</name><argument_list>(<argument><expr><name>pabsolute</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>pabsolute</name> = <call><name>svn_path_canonicalize</name><argument_list>(<argument><expr>*<name>pabsolute</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_path_split_if_file</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                       <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>pdirectory</name></decl></param>,
                       <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>pfile</name></decl></param>,
                       <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_finfo_t</name></type> <name>finfo</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>

  <comment type="block">/* assert (is_canonical (path, strlen (path)));  ### Expensive strlen */</comment>

  <expr_stmt><expr><name>err</name> = <call><name>svn_io_stat</name><argument_list>(<argument><expr>&amp;<name>finfo</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>APR_FINFO_TYPE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>err</name> &amp;&amp; ! <call><name>APR_STATUS_IS_ENOENT</name><argument_list>(<argument><expr><name><name>err</name>-&gt;<name>apr_err</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>err</name></expr>;</return></then></if>

  <if>if <condition>(<expr><name>err</name> || <name><name>finfo</name>.<name>filetype</name></name> == <name>APR_REG</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>svn_path_split</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pdirectory</name></expr></argument>, <argument><expr><name>pfile</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then>
  <else>else <if>if <condition>(<expr><name><name>finfo</name>.<name>filetype</name></name> == <name>APR_DIR</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr>*<name>pdirectory</name> = <name>path</name></expr>;</expr_stmt>
      <expr_stmt><expr>*<name>pfile</name> = <name>SVN_EMPTY_PATH</name></expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>SVN_ERR_BAD_FILENAME</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
                               <argument><expr><call><name>_</name><argument_list>(<argument><expr>"'%s' is neither a file nor a directory name"</expr></argument>)</argument_list></call></expr></argument>,
                               <argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
    }</block></else></if></else></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<escape char="0xc"/>
<function><type><specifier>const</specifier> <name>char</name> *</type>
<name>svn_path_canonicalize</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>char</name> *</type><name>canon</name></decl>, *<decl><type ref="prev"/><name>dst</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>src</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>seglen</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>canon_segments</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>uri</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>dst</name> = <name>canon</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Copy over the URI scheme if present. */</comment>
  <expr_stmt><expr><name>src</name> = <call><name>skip_uri_scheme</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>src</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>uri</name> = <name>TRUE</name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>src</name> - <name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>dst</name> += (<name>src</name> - <name>path</name>)</expr>;</expr_stmt>
    }</block></then>
  <else>else
    <block>{
      <expr_stmt><expr><name>uri</name> = <name>FALSE</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>src</name> = <name>path</name></expr>;</expr_stmt>
    }</block></else></if>

  <comment type="block">/* If this is an absolute path, then just copy over the initial
     separator character. */</comment>
  <if>if <condition>(<expr>*<name>src</name> == '/'</expr>)</condition><then>
    <block>{
      <expr_stmt><expr>*(<name>dst</name>++) = *(<name>src</name>++)</expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
      <comment type="block">/* On Windows permit two leading separator characters which means an
       * UNC path.  However, a double slash in a URI after the scheme is never
       * valid. */</comment>
      <if>if <condition>(<expr>!<name>uri</name> &amp;&amp; *<name>src</name> == '/'</expr>)</condition><then>
        <expr_stmt><expr>*(<name>dst</name>++) = *(<name>src</name>++)</expr>;</expr_stmt></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* WIN32 or Cygwin */</comment>

    }</block></then></if>

  <while>while <condition>(<expr>*<name>src</name></expr>)</condition>
    <block>{
      <comment type="block">/* Parse each segment, find the closing '/' */</comment>
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>next</name> <init>= <expr><name>src</name></expr></init></decl>;</decl_stmt>
      <while>while <condition>(<expr>*<name>next</name> &amp;&amp; (*<name>next</name> != '/')</expr>)</condition>
        <expr_stmt><expr>++<name>next</name></expr>;</expr_stmt></while>

      <expr_stmt><expr><name>seglen</name> = <name>next</name> - <name>src</name></expr>;</expr_stmt>

      <if>if <condition>(<expr><name>seglen</name> == 0 || (<name>seglen</name> == 1 &amp;&amp; <name><name>src</name><index>[<expr>0</expr>]</index></name> == '.')</expr>)</condition><then>
        <block>{
          <comment type="block">/* Noop segment, so do nothing. */</comment>
        }</block></then>
      <else>else
        <block>{
          <comment type="block">/* An actual segment, append it to the destination path */</comment>
          <if>if <condition>(<expr>*<name>next</name></expr>)</condition><then>
            <expr_stmt><expr><name>seglen</name>++</expr>;</expr_stmt></then></if>
          <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dst</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>seglen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>dst</name> += <name>seglen</name></expr>;</expr_stmt>
          <expr_stmt><expr><name>canon_segments</name>++</expr>;</expr_stmt>
        }</block></else></if>

      <comment type="block">/* Skip over trailing slash to the next segment. */</comment>
      <expr_stmt><expr><name>src</name> = <name>next</name></expr>;</expr_stmt>
      <if>if <condition>(<expr>*<name>src</name></expr>)</condition><then>
        <expr_stmt><expr><name>src</name>++</expr>;</expr_stmt></then></if>
    }</block></while>

  <comment type="block">/* Remove the trailing slash. */</comment>
  <if>if <condition>(<expr>(<name>canon_segments</name> &gt; 0 || <name>uri</name>) &amp;&amp; *(<name>dst</name> - 1) == '/'</expr>)</condition><then>
    <expr_stmt><expr><name>dst</name>--</expr>;</expr_stmt></then></if>

  <expr_stmt><expr>*<name>dst</name> = '\0'</expr>;</expr_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call> || <call><name>defined</name><argument_list>(<argument><expr><name>__CYGWIN__</name></expr></argument>)</argument_list></call></expr></cpp:if>
  <comment type="block">/* Skip leading double slashes when there are less than 2
   * canon segments. UNC paths *MUST* have two segments. */</comment>
  <if>if <condition>(<expr><name>canon_segments</name> &lt; 2 &amp;&amp; <name><name>canon</name><index>[<expr>0</expr>]</index></name> == '/' &amp;&amp; <name><name>canon</name><index>[<expr>1</expr>]</index></name> == '/'</expr>)</condition><then>
    <return>return <expr><name>canon</name> + 1</expr>;</return></then></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* WIN32 or Cygwin */</comment>

  <return>return <expr><name>canon</name></expr>;</return>
}</block></function>


<function><type><name>svn_boolean_t</name></type>
<name>svn_path_is_canonical</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr>(<call><name>strcmp</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>svn_path_canonicalize</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> == 0)</expr>;</return>
}</block></function>


<escape char="0xc"/>
<comment type="block">/** Get APR's internal path encoding. */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>get_path_encoding</name><parameter_list>(<param><decl><type><name>svn_boolean_t</name> *</type><name>path_is_utf8</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_status_t</name></type> <name>apr_err</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>encoding_style</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>apr_err</name> = <call><name>apr_filepath_encoding</name><argument_list>(<argument><expr>&amp;<name>encoding_style</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>apr_err</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_wrap_apr</name><argument_list>(<argument><expr><name>apr_err</name></expr></argument>,
                              <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Can't determine the native path encoding"</expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <comment type="block">/* ### What to do about APR_FILEPATH_ENCODING_UNKNOWN?
     Well, for now we'll just punt to the svn_utf_ functions;
     those will at least do the ASCII-subset check. */</comment>
  <expr_stmt><expr>*<name>path_is_utf8</name> = (<name>encoding_style</name> == <name>APR_FILEPATH_ENCODING_UTF8</name>)</expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_path_cstring_from_utf8</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>path_apr</name></decl></param>,
                           <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path_utf8</name></decl></param>,
                           <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>path_is_utf8</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_path_encoding</name><argument_list>(<argument><expr>&amp;<name>path_is_utf8</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>path_is_utf8</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr>*<name>path_apr</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>path_utf8</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then>
  <else>else
    <return>return <expr><call><name>svn_utf_cstring_from_utf8</name><argument_list>(<argument><expr><name>path_apr</name></expr></argument>, <argument><expr><name>path_utf8</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_path_cstring_to_utf8</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>path_utf8</name></decl></param>,
                         <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path_apr</name></decl></param>,
                         <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>path_is_utf8</name></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>get_path_encoding</name><argument_list>(<argument><expr>&amp;<name>path_is_utf8</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>path_is_utf8</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr>*<name>path_utf8</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>path_apr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
    }</block></then>
  <else>else
    <return>return <expr><call><name>svn_utf_cstring_to_utf8</name><argument_list>(<argument><expr><name>path_utf8</name></expr></argument>, <argument><expr><name>path_apr</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>


<comment type="block">/* Return a copy of PATH, allocated from POOL, for which control
   characters have been escaped using the form \NNN (where NNN is the
   octal representation of the byte's ordinal value).  */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> *</type>
<name>illegal_path_escape</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>retstr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>copied</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>c</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>retstr</name> = <call><name>svn_stringbuf_create</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <for>for (<init><expr><name>i</name> = 0</expr>;</init> <condition><expr><name><name>path</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name>++</expr></incr>)
    <block>{
      <expr_stmt><expr><name>c</name> = (<name>unsigned</name> <name>char</name>)<name><name>path</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
      <if>if <condition>(<expr>! <call><name>svn_ctype_iscntrl</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <continue>continue;</continue></then></if>

      <comment type="block">/* If we got here, we're looking at a character that isn't
         supported by the (or at least, our) URI encoding scheme.  We
         need to escape this character.  */</comment>

      <comment type="block">/* First things first, copy all the good stuff that we haven't
         yet copied into our output buffer. */</comment>
      <if>if <condition>(<expr><name>i</name> - <name>copied</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>svn_stringbuf_appendbytes</name><argument_list>(<argument><expr><name>retstr</name></expr></argument>, <argument><expr><name>path</name> + <name>copied</name></expr></argument>,
                                  <argument><expr><name>i</name> - <name>copied</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

      <comment type="block">/* Now, sprintf() in our escaped character, making sure our
         buffer is big enough to hold the '%' and two digits.  We cast
         the C to unsigned char here because the 'X' format character
         will be tempted to treat it as an unsigned int...which causes
         problem when messing with 0x80-0xFF chars.  We also need space
         for a null as sprintf will write one. */</comment>
      <comment type="block">/*### The backslash separator doesn't work too great with Windows,
         but it's what we'll use for consistency with invalid utf8
         formatting (until someone has a better idea) */</comment>
      <expr_stmt><expr><call><name>svn_stringbuf_ensure</name><argument_list>(<argument><expr><name>retstr</name></expr></argument>, <argument><expr><name><name>retstr</name>-&gt;<name>len</name></name> + 4</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name><name>retstr</name>-&gt;<name>data</name></name> + <name><name>retstr</name>-&gt;<name>len</name></name></expr></argument>, <argument><expr>"\\%03o"</expr></argument>, <argument><expr>(<name>unsigned</name> <name>char</name>)<name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>retstr</name>-&gt;<name>len</name></name> += 4</expr>;</expr_stmt>

      <comment type="block">/* Finally, update our copy counter. */</comment>
      <expr_stmt><expr><name>copied</name> = <name>i</name> + 1</expr>;</expr_stmt>
    }</block></for>

  <comment type="block">/* If we didn't encode anything, we don't need to duplicate the string. */</comment>
  <if>if <condition>(<expr><name><name>retstr</name>-&gt;<name>len</name></name> == 0</expr>)</condition><then>
    <return>return <expr><name>path</name></expr>;</return></then></if>

  <comment type="block">/* Anything left to copy? */</comment>
  <if>if <condition>(<expr><name>i</name> - <name>copied</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>svn_stringbuf_appendbytes</name><argument_list>(<argument><expr><name>retstr</name></expr></argument>, <argument><expr><name>path</name> + <name>copied</name></expr></argument>, <argument><expr><name>i</name> - <name>copied</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <comment type="block">/* retstr is null-terminated either by sprintf or the svn_stringbuf
     functions. */</comment>

  <return>return <expr><name><name>retstr</name>-&gt;<name>data</name></name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_path_check_valid</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>c</name></decl>;</decl_stmt>

  <for>for (<init><expr><name>c</name> = <name>path</name></expr>;</init> <condition><expr>*<name>c</name></expr>;</condition> <incr><expr><name>c</name>++</expr></incr>)
    <block>{
      <if>if <condition>(<expr><call><name>svn_ctype_iscntrl</name><argument_list>(<argument><expr>*<name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <return>return <expr><call><name>svn_error_createf</name>
            <argument_list>(<argument><expr><name>SVN_ERR_FS_PATH_SYNTAX</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
             <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Invalid control character '0x%02x' in path '%s'"</expr></argument>)</argument_list></call></expr></argument>,
             <argument><expr>*<name>c</name></expr></argument>,
             <argument><expr><call><name>illegal_path_escape</name><argument_list>(<argument><expr><call><name>svn_path_local_style</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
        }</block></then></if>
    }</block></for>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>void</name></type>
<name>svn_path_splitext</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>path_root</name></decl></param>,
                  <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>path_ext</name></decl></param>,
                  <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>path</name></decl></param>,
                  <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>last_dot</name></decl>, *<decl><type ref="prev"/><name>last_slash</name></decl>;</decl_stmt>

  <comment type="block">/* Easy out -- why do all the work when there's no way to report it? */</comment>
  <if>if <condition>(<expr>! (<name>path_root</name> || <name>path_ext</name>)</expr>)</condition><then>
    <return>return;</return></then></if>

  <comment type="block">/* Do we even have a period in this thing?  And if so, is there
     anything after it?  We look for the "rightmost" period in the
     string. */</comment>
  <expr_stmt><expr><name>last_dot</name> = <call><name>strrchr</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>'.'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>last_dot</name> &amp;&amp; (<name>last_dot</name> + 1 != '\0')</expr>)</condition><then>
    <block>{
      <comment type="block">/* If we have a period, we need to make sure it occurs in the
         final path component -- that there's no path separator
         between the last period and the end of the PATH -- otherwise,
         it doesn't count.  Also, we want to make sure that our period
         isn't the first character of the last component. */</comment>
      <expr_stmt><expr><name>last_slash</name> = <call><name>strrchr</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr>'/'</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr>(<name>last_slash</name> &amp;&amp; (<name>last_dot</name> &gt; (<name>last_slash</name> + 1)))
          || ((! <name>last_slash</name>) &amp;&amp; (<name>last_dot</name> &gt; <name>path</name>))</expr>)</condition><then>
        <block>{
          <if>if <condition>(<expr><name>path_root</name></expr>)</condition><then>
            <expr_stmt><expr>*<name>path_root</name> = <call><name>apr_pstrmemdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>path</name></expr></argument>,
                                        <argument><expr>(<name>last_dot</name> - <name>path</name> + 1) * <sizeof>sizeof<argument_list>(<argument><expr>*<name>path</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
          <if>if <condition>(<expr><name>path_ext</name></expr>)</condition><then>
            <expr_stmt><expr>*<name>path_ext</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>last_dot</name> + 1</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
          <return>return;</return>
        }</block></then></if>
    }</block></then></if>
  <comment type="block">/* If we get here, we never found a suitable separator character, so
     there's no split. */</comment>
  <if>if <condition>(<expr><name>path_root</name></expr>)</condition><then>
    <expr_stmt><expr>*<name>path_root</name> = <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <if>if <condition>(<expr><name>path_ext</name></expr>)</condition><then>
    <expr_stmt><expr>*<name>path_ext</name> = ""</expr>;</expr_stmt></then></if>
}</block></function>
</unit>
