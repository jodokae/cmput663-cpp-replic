<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/subversion-1.5.1/source/subversion/libsvn_subr/stream.c"><comment type="block">/*
 * stream.c:   svn_stream operations
 *
 * ====================================================================
 * Copyright (c) 2000-2004, 2006 CollabNet.  All rights reserved.
 *
 * This software is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at http://subversion.tigris.org/license-1.html.
 * If newer versions of this license are posted there, you may use a
 * newer version instead, at your option.
 *
 * This software consists of voluntary contributions made by many
 * individuals.  For exact contribution history, see the revision
 * history and logs, available at http://subversion.tigris.org/.
 * ====================================================================
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_private_config.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_pools.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_strings.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_file_io.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_errno.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_md5.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;zlib.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_pools.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_io.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_error.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_string.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_utf.h"</cpp:file></cpp:include>


<struct>struct <name>svn_stream_t</name> <block>{
  <decl_stmt><decl><type><name>void</name> *</type><name>baton</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_read_fn_t</name></type> <name>read_fn</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_write_fn_t</name></type> <name>write_fn</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_close_fn_t</name></type> <name>close_fn</name></decl>;</decl_stmt>
}</block>;</struct>


<escape char="0xc"/>
<comment type="block">/*** Generic streams. ***/</comment>

<function><type><name>svn_stream_t</name> *</type>
<name>svn_stream_create</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>stream</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>stream</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>stream</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>stream</name>-&gt;<name>baton</name></name> = <name>baton</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>stream</name>-&gt;<name>read_fn</name></name> = <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>stream</name>-&gt;<name>write_fn</name></name> = <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>stream</name>-&gt;<name>close_fn</name></name> = <name>NULL</name></expr>;</expr_stmt>
  <return>return <expr><name>stream</name></expr>;</return>
}</block></function>


<function><type><name>void</name></type>
<name>svn_stream_set_baton</name><parameter_list>(<param><decl><type><name>svn_stream_t</name> *</type><name>stream</name></decl></param>, <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><name><name>stream</name>-&gt;<name>baton</name></name> = <name>baton</name></expr>;</expr_stmt>
}</block></function>


<function><type><name>void</name></type>
<name>svn_stream_set_read</name><parameter_list>(<param><decl><type><name>svn_stream_t</name> *</type><name>stream</name></decl></param>, <param><decl><type><name>svn_read_fn_t</name></type> <name>read_fn</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><name><name>stream</name>-&gt;<name>read_fn</name></name> = <name>read_fn</name></expr>;</expr_stmt>
}</block></function>


<function><type><name>void</name></type>
<name>svn_stream_set_write</name><parameter_list>(<param><decl><type><name>svn_stream_t</name> *</type><name>stream</name></decl></param>, <param><decl><type><name>svn_write_fn_t</name></type> <name>write_fn</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><name><name>stream</name>-&gt;<name>write_fn</name></name> = <name>write_fn</name></expr>;</expr_stmt>
}</block></function>


<function><type><name>void</name></type>
<name>svn_stream_set_close</name><parameter_list>(<param><decl><type><name>svn_stream_t</name> *</type><name>stream</name></decl></param>, <param><decl><type><name>svn_close_fn_t</name></type> <name>close_fn</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><name><name>stream</name>-&gt;<name>close_fn</name></name> = <name>close_fn</name></expr>;</expr_stmt>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_stream_read</name><parameter_list>(<param><decl><type><name>svn_stream_t</name> *</type><name>stream</name></decl></param>, <param><decl><type><name>char</name> *</type><name>buffer</name></decl></param>, <param><decl><type><name>apr_size_t</name> *</type><name>len</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>stream</name>-&gt;<name>read_fn</name></name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name><name>stream</name>-&gt;<name>read_fn</name></name><argument_list>(<argument><expr><name><name>stream</name>-&gt;<name>baton</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_stream_write</name><parameter_list>(<param><decl><type><name>svn_stream_t</name> *</type><name>stream</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name></decl></param>, <param><decl><type><name>apr_size_t</name> *</type><name>len</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>stream</name>-&gt;<name>write_fn</name></name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name><name>stream</name>-&gt;<name>write_fn</name></name><argument_list>(<argument><expr><name><name>stream</name>-&gt;<name>baton</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_stream_close</name><parameter_list>(<param><decl><type><name>svn_stream_t</name> *</type><name>stream</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr><name><name>stream</name>-&gt;<name>close_fn</name></name> == <name>NULL</name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>
  <return>return <expr><call><name><name>stream</name>-&gt;<name>close_fn</name></name><argument_list>(<argument><expr><name><name>stream</name>-&gt;<name>baton</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_stream_printf</name><parameter_list>(<param><decl><type><name>svn_stream_t</name> *</type><name>stream</name></decl></param>,
                  <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                  <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fmt</name></decl></param>,
                  <param><decl><type>...</type></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>message</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>message</name> = <call><name>apr_pvsprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><call><name>svn_stream_write</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_stream_printf_from_utf8</name><parameter_list>(<param><decl><type><name>svn_stream_t</name> *</type><name>stream</name></decl></param>,
                            <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>encoding</name></decl></param>,
                            <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                            <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>fmt</name></decl></param>,
                            <param><decl><type>...</type></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>message</name></decl>, *<decl><type ref="prev"/><name>translated</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>message</name> = <call><name>apr_pvsprintf</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_utf_cstring_from_utf8_ex2</name><argument_list>(<argument><expr>&amp;<name>translated</name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><name>encoding</name></expr></argument>,
                                        <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>len</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>translated</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><call><name>svn_stream_write</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><name>translated</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_stream_readline</name><parameter_list>(<param><decl><type><name>svn_stream_t</name> *</type><name>stream</name></decl></param>,
                    <param><decl><type><name>svn_stringbuf_t</name> **</type><name>stringbuf</name></decl></param>,
                    <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>eol</name></decl></param>,
                    <param><decl><type><name>svn_boolean_t</name> *</type><name>eof</name></decl></param>,
                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>numbytes</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>match</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>str</name> <init>= <expr><call><name>svn_stringbuf_create</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Since we're reading one character at a time, let's at least
     optimize for the 90% case.  90% of the time, we can avoid the
     stringbuf ever having to realloc() itself if we start it out at
     80 chars.  */</comment>
  <expr_stmt><expr><call><name>svn_stringbuf_ensure</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr>80</expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>match</name> = <name>eol</name></expr>;</expr_stmt>
  <while>while <condition>(<expr>*<name>match</name></expr>)</condition>
    <block>{
      <expr_stmt><expr><name>numbytes</name> = 1</expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_read</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr>&amp;<name>c</name></expr></argument>, <argument><expr>&amp;<name>numbytes</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>numbytes</name> != 1</expr>)</condition><then>
        <block>{
          <comment type="block">/* a 'short' read means the stream has run out. */</comment>
          <expr_stmt><expr>*<name>eof</name> = <name>TRUE</name></expr>;</expr_stmt>
          <expr_stmt><expr>*<name>stringbuf</name> = <name>str</name></expr>;</expr_stmt>
          <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
        }</block></then></if>

      <if>if <condition>(<expr><name>c</name> == *<name>match</name></expr>)</condition><then>
        <expr_stmt><expr><name>match</name>++</expr>;</expr_stmt></then>
      <else>else
        <expr_stmt><expr><name>match</name> = <name>eol</name></expr>;</expr_stmt></else></if>

      <expr_stmt><expr><call><name>svn_stringbuf_appendbytes</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr>&amp;<name>c</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></while>

  <expr_stmt><expr>*<name>eof</name> = <name>FALSE</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_stringbuf_chop</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>match</name> - <name>eol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr>*<name>stringbuf</name> = <name>str</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type><name>svn_stream_copy2</name><parameter_list>(<param><decl><type><name>svn_stream_t</name> *</type><name>from</name></decl></param>, <param><decl><type><name>svn_stream_t</name> *</type><name>to</name></decl></param>,
                              <param><decl><type><name>svn_cancel_func_t</name></type> <name>cancel_func</name></decl></param>,
                              <param><decl><type><name>void</name> *</type><name>cancel_baton</name></decl></param>,
                              <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>char</name> *</type><name>buf</name> <init>= <expr><call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>SVN__STREAM_CHUNK_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name></decl>;</decl_stmt>

  <comment type="block">/* Read and write chunks until we get a short read, indicating the
     end of the stream.  (We can't get a short write without an
     associated error.) */</comment>
  <while>while <condition>(<expr>1</expr>)</condition>
    <block>{
      <expr_stmt><expr><name>len</name> = <name>SVN__STREAM_CHUNK_SIZE</name></expr>;</expr_stmt>

      <if>if <condition>(<expr><name>cancel_func</name></expr>)</condition><then>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>cancel_func</name><argument_list>(<argument><expr><name>cancel_baton</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_read</name><argument_list>(<argument><expr><name>from</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>len</name> &gt; 0</expr>)</condition><then>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_write</name><argument_list>(<argument><expr><name>to</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
      <if>if <condition>(<expr><name>len</name> != <name>SVN__STREAM_CHUNK_SIZE</name></expr>)</condition><then>
        <break>break;</break></then></if>
    }</block></while>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type><name>svn_stream_copy</name><parameter_list>(<param><decl><type><name>svn_stream_t</name> *</type><name>from</name></decl></param>, <param><decl><type><name>svn_stream_t</name> *</type><name>to</name></decl></param>,
                             <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>svn_stream_copy2</name><argument_list>(<argument><expr><name>from</name></expr></argument>, <argument><expr><name>to</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><name>svn_error_t</name> *</type>
<name>svn_stream_contents_same</name><parameter_list>(<param><decl><type><name>svn_boolean_t</name> *</type><name>same</name></decl></param>,
                         <param><decl><type><name>svn_stream_t</name> *</type><name>stream1</name></decl></param>,
                         <param><decl><type><name>svn_stream_t</name> *</type><name>stream2</name></decl></param>,
                         <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>char</name> *</type><name>buf1</name> <init>= <expr><call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>SVN__STREAM_CHUNK_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name> *</type><name>buf2</name> <init>= <expr><call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>SVN__STREAM_CHUNK_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>bytes_read1</name> <init>= <expr><name>SVN__STREAM_CHUNK_SIZE</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>bytes_read2</name> <init>= <expr><name>SVN__STREAM_CHUNK_SIZE</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr>*<name>same</name> = <name>TRUE</name></expr>;</expr_stmt>  <comment type="block">/* assume TRUE, until disproved below */</comment>
  <while>while <condition>(<expr><name>bytes_read1</name> == <name>SVN__STREAM_CHUNK_SIZE</name>
         &amp;&amp; <name>bytes_read2</name> == <name>SVN__STREAM_CHUNK_SIZE</name></expr>)</condition>
    <block>{
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_read</name><argument_list>(<argument><expr><name>stream1</name></expr></argument>, <argument><expr><name>buf1</name></expr></argument>, <argument><expr>&amp;<name>bytes_read1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_read</name><argument_list>(<argument><expr><name>stream2</name></expr></argument>, <argument><expr><name>buf2</name></expr></argument>, <argument><expr>&amp;<name>bytes_read2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr>(<name>bytes_read1</name> != <name>bytes_read2</name>)
          || (<call><name>memcmp</name><argument_list>(<argument><expr><name>buf1</name></expr></argument>, <argument><expr><name>buf2</name></expr></argument>, <argument><expr><name>bytes_read1</name></expr></argument>)</argument_list></call>)</expr>)</condition><then>
        <block>{
          <expr_stmt><expr>*<name>same</name> = <name>FALSE</name></expr>;</expr_stmt>
          <break>break;</break>
        }</block></then></if>
    }</block></while>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<escape char="0xc"/>
<comment type="block">/*** Generic readable empty stream ***/</comment>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>read_handler_empty</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>char</name> *</type><name>buffer</name></decl></param>, <param><decl><type><name>apr_size_t</name> *</type><name>len</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr>*<name>len</name> = 0</expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>write_handler_empty</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name></decl></param>, <param><decl><type><name>apr_size_t</name> *</type><name>len</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><name>svn_stream_t</name> *</type>
<name>svn_stream_empty</name><parameter_list>(<param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>stream</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>stream</name> = <call><name>svn_stream_create</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_stream_set_read</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><name>read_handler_empty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_stream_set_write</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><name>write_handler_empty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>stream</name></expr>;</return>
}</block></function>



<escape char="0xc"/>
<comment type="block">/*** Ownership detaching stream ***/</comment>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>read_handler_disown</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>char</name> *</type><name>buffer</name></decl></param>, <param><decl><type><name>apr_size_t</name> *</type><name>len</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>svn_stream_read</name><argument_list>(<argument><expr>(<name>svn_stream_t</name> *)<name>baton</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>write_handler_disown</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>buffer</name></decl></param>, <param><decl><type><name>apr_size_t</name> *</type><name>len</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>svn_stream_write</name><argument_list>(<argument><expr>(<name>svn_stream_t</name> *)<name>baton</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><name>svn_stream_t</name> *</type>
<name>svn_stream_disown</name><parameter_list>(<param><decl><type><name>svn_stream_t</name> *</type><name>stream</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>s</name> <init>= <expr><call><name>svn_stream_create</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>svn_stream_set_read</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>read_handler_disown</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_stream_set_write</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>write_handler_disown</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>s</name></expr>;</return>
}</block></function>


<escape char="0xc"/>
<comment type="block">/*** Generic stream for APR files ***/</comment>
<struct>struct <name>baton_apr</name> <block>{
  <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>file</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>
}</block>;</struct>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>read_handler_apr</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>char</name> *</type><name>buffer</name></decl></param>, <param><decl><type><name>apr_size_t</name> *</type><name>len</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>baton_apr</name> *</type><name>btn</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>err</name> = <call><name>svn_io_file_read_full</name><argument_list>(<argument><expr><name><name>btn</name>-&gt;<name>file</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr>*<name>len</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>btn</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>err</name> &amp;&amp; <call><name>APR_STATUS_IS_EOF</name><argument_list>(<argument><expr><name><name>err</name>-&gt;<name>apr_err</name></name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><call><name>svn_error_clear</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>err</name> = <name>SVN_NO_ERROR</name></expr>;</expr_stmt>
    }</block></then></if>

  <return>return <expr><name>err</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>write_handler_apr</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name></decl></param>, <param><decl><type><name>apr_size_t</name> *</type><name>len</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>baton_apr</name> *</type><name>btn</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>

  <return>return <expr><call><name>svn_io_file_write_full</name><argument_list>(<argument><expr><name><name>btn</name>-&gt;<name>file</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr>*<name>len</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name><name>btn</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>close_handler_apr</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>baton_apr</name> *</type><name>btn</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>

  <return>return <expr><call><name>svn_io_file_close</name><argument_list>(<argument><expr><name><name>btn</name>-&gt;<name>file</name></name></expr></argument>, <argument><expr><name><name>btn</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><name>svn_stream_t</name> *</type>
<name>svn_stream_from_aprfile2</name><parameter_list>(<param><decl><type><name>apr_file_t</name> *</type><name>file</name></decl></param>,
                         <param><decl><type><name>svn_boolean_t</name></type> <name>disown</name></decl></param>,
                         <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>baton_apr</name> *</type><name>baton</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>stream</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>file</name> == <name>NULL</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_stream_empty</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><name>baton</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>baton</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>baton</name>-&gt;<name>file</name></name> = <name>file</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>baton</name>-&gt;<name>pool</name></name> = <name>pool</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>stream</name> = <call><name>svn_stream_create</name><argument_list>(<argument><expr><name>baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_stream_set_read</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><name>read_handler_apr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_stream_set_write</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><name>write_handler_apr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr>! <name>disown</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>svn_stream_set_close</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><name>close_handler_apr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <return>return <expr><name>stream</name></expr>;</return>
}</block></function>

<function><type><name>svn_stream_t</name> *</type>
<name>svn_stream_from_aprfile</name><parameter_list>(<param><decl><type><name>apr_file_t</name> *</type><name>file</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <return>return <expr><call><name>svn_stream_from_aprfile2</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><name>TRUE</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<escape char="0xc"/>
<comment type="block">/* Compressed stream support */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZBUFFER_SIZE</name></cpp:macro> <cpp:value>4096</cpp:value></cpp:define>       <comment type="block">/* The size of the buffer the
                                   compressed stream uses to read from
                                   the substream. Basically an
                                   arbitrary value, picked to be about
                                   page-sized. */</comment>

<struct>struct <name>zbaton</name> <block>{
  <decl_stmt><decl><type><name>z_stream</name> *</type><name>in</name></decl>;</decl_stmt>                 <comment type="block">/* compressed stream for reading */</comment>
  <decl_stmt><decl><type><name>z_stream</name> *</type><name>out</name></decl>;</decl_stmt>                <comment type="block">/* compressed stream for writing */</comment>
  <decl_stmt><decl><type><name>svn_read_fn_t</name></type> <name>read</name></decl>;</decl_stmt>           <comment type="block">/* substream's read function */</comment>
  <decl_stmt><decl><type><name>svn_write_fn_t</name></type> <name>write</name></decl>;</decl_stmt>         <comment type="block">/* substream's write function */</comment>
  <decl_stmt><decl><type><name>svn_close_fn_t</name></type> <name>close</name></decl>;</decl_stmt>         <comment type="block">/* substream's close function */</comment>
  <decl_stmt><decl><type><name>void</name> *</type><name>read_buffer</name></decl>;</decl_stmt>            <comment type="block">/* buffer   used   for  reading   from
                                   substream */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>read_flush</name></decl>;</decl_stmt>               <comment type="block">/* what flush mode to use while
                                   reading */</comment>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>             <comment type="block">/* The pool this baton is allocated
                                   on */</comment>
  <decl_stmt><decl><type><name>void</name> *</type><name>subbaton</name></decl>;</decl_stmt>               <comment type="block">/* The substream's baton */</comment>
}</block>;</struct>

<comment type="block">/* zlib alloc function. opaque is the pool we need. */</comment>
<function><type><specifier>static</specifier> <name>voidpf</name></type>
<name>zalloc</name><parameter_list>(<param><decl><type><name>voidpf</name></type> <name>opaque</name></decl></param>, <param><decl><type><name>uInt</name></type> <name>items</name></decl></param>, <param><decl><type><name>uInt</name></type> <name>size</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name> <init>= <expr><name>opaque</name></expr></init></decl>;</decl_stmt>

  <return>return <expr><call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>items</name> * <name>size</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>

<comment type="block">/* zlib free function */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>zfree</name><parameter_list>(<param><decl><type><name>voidpf</name></type> <name>opaque</name></decl></param>, <param><decl><type><name>voidpf</name></type> <name>address</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* Empty, since we allocate on the pool */</comment>
}</block></function>

<comment type="block">/* Converts a zlib error to an svn_error_t. zerr is the error code,
   function is the function name, and stream is the z_stream we are
   using.  */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>zerr_to_svn_error</name><parameter_list>(<param><decl><type><name>int</name></type> <name>zerr</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>function</name></decl></param>, <param><decl><type><name>z_stream</name> *</type><name>stream</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_status_t</name></type> <name>status</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>message</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>zerr</name> == <name>Z_OK</name></expr>)</condition><then>
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></then></if>

  <switch>switch <condition>(<expr><name>zerr</name></expr>)</condition>
    <block>{
    <case>case <expr><name>Z_STREAM_ERROR</name></expr>:
      <expr_stmt><expr><name>status</name> = <name>SVN_ERR_STREAM_MALFORMED_DATA</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>message</name> = "stream error"</expr>;</expr_stmt>
      <break>break;</break>

    </case><case>case <expr><name>Z_MEM_ERROR</name></expr>:
      <expr_stmt><expr><name>status</name> = <name>APR_ENOMEM</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>message</name> = "out of memory"</expr>;</expr_stmt>
      <break>break;</break>

    </case><case>case <expr><name>Z_BUF_ERROR</name></expr>:
      <expr_stmt><expr><name>status</name> = <name>APR_ENOMEM</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>message</name> = "buffer error"</expr>;</expr_stmt>
      <break>break;</break>

    </case><case>case <expr><name>Z_VERSION_ERROR</name></expr>:
      <expr_stmt><expr><name>status</name> = <name>SVN_ERR_STREAM_UNRECOGNIZED_DATA</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>message</name> = "version error"</expr>;</expr_stmt>
      <break>break;</break>

    </case><case>case <expr><name>Z_DATA_ERROR</name></expr>:
      <expr_stmt><expr><name>status</name> = <name>SVN_ERR_STREAM_MALFORMED_DATA</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>message</name> = "corrupted data"</expr>;</expr_stmt>
      <break>break;</break>

    </case><default>default:
      <expr_stmt><expr><name>status</name> = <name>SVN_ERR_STREAM_UNRECOGNIZED_DATA</name></expr>;</expr_stmt>
      <expr_stmt><expr><name>message</name> = "error"</expr>;</expr_stmt>
      <break>break;</break>
    </default>}</block></switch>

  <if>if <condition>(<expr><name><name>stream</name>-&gt;<name>msg</name></name> != <name>NULL</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>status</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>"zlib (%s): %s: %s"</expr></argument>, <argument><expr><name>function</name></expr></argument>,
                             <argument><expr><name>message</name></expr></argument>, <argument><expr><name><name>stream</name>-&gt;<name>msg</name></name></expr></argument>)</argument_list></call></expr>;</return></then>
  <else>else
    <return>return <expr><call><name>svn_error_createf</name><argument_list>(<argument><expr><name>status</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>"zlib (%s): %s"</expr></argument>, <argument><expr><name>function</name></expr></argument>,
                             <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</return></else></if>
}</block></function>

<comment type="block">/* Helper function to figure out the sync mode */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>read_helper_gz</name><parameter_list>(<param><decl><type><name>svn_read_fn_t</name></type> <name>read_fn</name></decl></param>,
               <param><decl><type><name>void</name> *</type><name>baton</name></decl></param>,
               <param><decl><type><name>char</name> *</type><name>buffer</name></decl></param>,
               <param><decl><type><name>uInt</name> *</type><name>len</name></decl></param>, <param><decl><type><name>int</name> *</type><name>zflush</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>uInt</name></type> <name>orig_len</name> <init>= <expr>*<name>len</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* There's no reason this value should grow bigger than the range of
     uInt, but Subversion's API requires apr_size_t. */</comment>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>apr_len</name> <init>= <expr>(<name>apr_size_t</name>) *<name>len</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call>(*<name>read_fn</name>)<argument_list>(<argument><expr><name>baton</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr>&amp;<name>apr_len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Type cast back to uInt type that zlib uses.  On LP64 platforms
     apr_size_t will be bigger than uInt. */</comment>
  <expr_stmt><expr>*<name>len</name> = (<name>uInt</name>) <name>apr_len</name></expr>;</expr_stmt>

  <comment type="block">/* I wanted to use Z_FINISH here, but we need to know our buffer is
     big enough */</comment>
  <expr_stmt><expr>*<name>zflush</name> = (*<name>len</name>) &lt; <name>orig_len</name> ? <name>Z_SYNC_FLUSH</name> : <name>Z_SYNC_FLUSH</name></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Handle reading from a compressed stream */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>read_handler_gz</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>char</name> *</type><name>buffer</name></decl></param>, <param><decl><type><name>apr_size_t</name> *</type><name>len</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>zbaton</name> *</type><name>btn</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>zerr</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><name><name>btn</name>-&gt;<name>in</name></name> == <name>NULL</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name><name>btn</name>-&gt;<name>in</name></name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>btn</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>z_stream</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>btn</name>-&gt;<name>in</name>-&gt;<name>zalloc</name></name> = <name>zalloc</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>btn</name>-&gt;<name>in</name>-&gt;<name>zfree</name></name> = <name>zfree</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>btn</name>-&gt;<name>in</name>-&gt;<name>opaque</name></name> = <name><name>btn</name>-&gt;<name>pool</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>btn</name>-&gt;<name>read_buffer</name></name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>btn</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>ZBUFFER_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>btn</name>-&gt;<name>in</name>-&gt;<name>next_in</name></name> = <name><name>btn</name>-&gt;<name>read_buffer</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>btn</name>-&gt;<name>in</name>-&gt;<name>avail_in</name></name> = <name>ZBUFFER_SIZE</name></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>read_helper_gz</name><argument_list>(<argument><expr><name><name>btn</name>-&gt;<name>read</name></name></expr></argument>, <argument><expr><name><name>btn</name>-&gt;<name>subbaton</name></name></expr></argument>, <argument><expr><name><name>btn</name>-&gt;<name>read_buffer</name></name></expr></argument>,
                             <argument><expr>&amp;<name><name>btn</name>-&gt;<name>in</name>-&gt;<name>avail_in</name></name></expr></argument>, <argument><expr>&amp;<name><name>btn</name>-&gt;<name>read_flush</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>zerr</name> = <call><name>inflateInit</name><argument_list>(<argument><expr><name><name>btn</name>-&gt;<name>in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>zerr_to_svn_error</name><argument_list>(<argument><expr><name>zerr</name></expr></argument>, <argument><expr>"inflateInit"</expr></argument>, <argument><expr><name><name>btn</name>-&gt;<name>in</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <expr_stmt><expr><name><name>btn</name>-&gt;<name>in</name>-&gt;<name>next_out</name></name> = (<name>Bytef</name> *) <name>buffer</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>btn</name>-&gt;<name>in</name>-&gt;<name>avail_out</name></name> = *<name>len</name></expr>;</expr_stmt>

  <while>while <condition>(<expr><name><name>btn</name>-&gt;<name>in</name>-&gt;<name>avail_out</name></name> &gt; 0</expr>)</condition>
    <block>{
      <if>if <condition>(<expr><name><name>btn</name>-&gt;<name>in</name>-&gt;<name>avail_in</name></name> &lt;= 0</expr>)</condition><then>
        <block>{
          <expr_stmt><expr><name><name>btn</name>-&gt;<name>in</name>-&gt;<name>avail_in</name></name> = <name>ZBUFFER_SIZE</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>btn</name>-&gt;<name>in</name>-&gt;<name>next_in</name></name> = <name><name>btn</name>-&gt;<name>read_buffer</name></name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>read_helper_gz</name><argument_list>(<argument><expr><name><name>btn</name>-&gt;<name>read</name></name></expr></argument>, <argument><expr><name><name>btn</name>-&gt;<name>subbaton</name></name></expr></argument>, <argument><expr><name><name>btn</name>-&gt;<name>read_buffer</name></name></expr></argument>,
                                 <argument><expr>&amp;<name><name>btn</name>-&gt;<name>in</name>-&gt;<name>avail_in</name></name></expr></argument>, <argument><expr>&amp;<name><name>btn</name>-&gt;<name>read_flush</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block></then></if>

      <expr_stmt><expr><name>zerr</name> = <call><name>inflate</name><argument_list>(<argument><expr><name><name>btn</name>-&gt;<name>in</name></name></expr></argument>, <argument><expr><name><name>btn</name>-&gt;<name>read_flush</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>zerr</name> == <name>Z_STREAM_END</name></expr>)</condition><then>
        <break>break;</break></then>
      <else>else <if>if <condition>(<expr><name>zerr</name> != <name>Z_OK</name></expr>)</condition><then>
        <return>return <expr><call><name>zerr_to_svn_error</name><argument_list>(<argument><expr><name>zerr</name></expr></argument>, <argument><expr>"inflate"</expr></argument>, <argument><expr><name><name>btn</name>-&gt;<name>in</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if></else></if>
    }</block></while>

  <expr_stmt><expr>*<name>len</name> -= <name><name>btn</name>-&gt;<name>in</name>-&gt;<name>avail_out</name></name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Compress data and write it to the substream */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>write_handler_gz</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>buffer</name></decl></param>, <param><decl><type><name>apr_size_t</name> *</type><name>len</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>zbaton</name> *</type><name>btn</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>void</name> *</type><name>write_buf</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>buf_size</name></decl>, <decl><type ref="prev"/><name>write_len</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>zerr</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><name><name>btn</name>-&gt;<name>out</name></name> == <name>NULL</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name><name>btn</name>-&gt;<name>out</name></name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>btn</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>z_stream</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>btn</name>-&gt;<name>out</name>-&gt;<name>zalloc</name></name> = <name>zalloc</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>btn</name>-&gt;<name>out</name>-&gt;<name>zfree</name></name> = <name>zfree</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>btn</name>-&gt;<name>out</name>-&gt;<name>opaque</name></name> =  <name><name>btn</name>-&gt;<name>pool</name></name></expr>;</expr_stmt>

      <expr_stmt><expr><name>zerr</name> = <call><name>deflateInit</name><argument_list>(<argument><expr><name><name>btn</name>-&gt;<name>out</name></name></expr></argument>, <argument><expr><name>Z_DEFAULT_COMPRESSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>zerr_to_svn_error</name><argument_list>(<argument><expr><name>zerr</name></expr></argument>, <argument><expr>"deflateInit"</expr></argument>, <argument><expr><name><name>btn</name>-&gt;<name>out</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* The largest buffer we should need is 0.1% larger than the
     compressed data, + 12 bytes. This info comes from zlib.h.  */</comment>
  <expr_stmt><expr><name>buf_size</name> = *<name>len</name> + (*<name>len</name> / 1000) + 13</expr>;</expr_stmt>
  <expr_stmt><expr><name>subpool</name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name><name>btn</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>write_buf</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>, <argument><expr><name>buf_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>btn</name>-&gt;<name>out</name>-&gt;<name>next_in</name></name> = (<name>Bytef</name> *) <name>buffer</name></expr>;</expr_stmt>  <comment type="block">/* Casting away const! */</comment>
  <expr_stmt><expr><name><name>btn</name>-&gt;<name>out</name>-&gt;<name>avail_in</name></name> = *<name>len</name></expr>;</expr_stmt>

  <while>while <condition>(<expr><name><name>btn</name>-&gt;<name>out</name>-&gt;<name>avail_in</name></name> &gt; 0</expr>)</condition>
    <block>{
      <expr_stmt><expr><name><name>btn</name>-&gt;<name>out</name>-&gt;<name>next_out</name></name> = <name>write_buf</name></expr>;</expr_stmt>
      <expr_stmt><expr><name><name>btn</name>-&gt;<name>out</name>-&gt;<name>avail_out</name></name> = <name>buf_size</name></expr>;</expr_stmt>

      <expr_stmt><expr><name>zerr</name> = <call><name>deflate</name><argument_list>(<argument><expr><name><name>btn</name>-&gt;<name>out</name></name></expr></argument>, <argument><expr><name>Z_NO_FLUSH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>zerr_to_svn_error</name><argument_list>(<argument><expr><name>zerr</name></expr></argument>, <argument><expr>"deflate"</expr></argument>, <argument><expr><name><name>btn</name>-&gt;<name>out</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><name>write_len</name> = <name>buf_size</name> - <name><name>btn</name>-&gt;<name>out</name>-&gt;<name>avail_out</name></name></expr>;</expr_stmt>
      <if>if <condition>(<expr><name>write_len</name> &gt; 0</expr>)</condition><then>
        <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>btn</name>-&gt;<name>write</name></name><argument_list>(<argument><expr><name><name>btn</name>-&gt;<name>subbaton</name></name></expr></argument>, <argument><expr><name>write_buf</name></expr></argument>, <argument><expr>&amp;<name>write_len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
    }</block></while>

  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<comment type="block">/* Handle flushing and closing the stream */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>close_handler_gz</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>zbaton</name> *</type><name>btn</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>zerr</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><name><name>btn</name>-&gt;<name>in</name></name> != <name>NULL</name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>zerr</name> = <call><name>inflateEnd</name><argument_list>(<argument><expr><name><name>btn</name>-&gt;<name>in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>zerr_to_svn_error</name><argument_list>(<argument><expr><name>zerr</name></expr></argument>, <argument><expr>"inflateEnd"</expr></argument>, <argument><expr><name><name>btn</name>-&gt;<name>in</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <if>if <condition>(<expr><name><name>btn</name>-&gt;<name>out</name></name> != <name>NULL</name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>void</name> *</type><name>buf</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_size_t</name></type> <name>write_len</name></decl>;</decl_stmt>

      <expr_stmt><expr><name>buf</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>btn</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>ZBUFFER_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <while>while <condition>(<expr><name>TRUE</name></expr>)</condition>
        <block>{
          <expr_stmt><expr><name><name>btn</name>-&gt;<name>out</name>-&gt;<name>next_out</name></name> = <name>buf</name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>btn</name>-&gt;<name>out</name>-&gt;<name>avail_out</name></name> = <name>ZBUFFER_SIZE</name></expr>;</expr_stmt>

          <expr_stmt><expr><name>zerr</name> = <call><name>deflate</name><argument_list>(<argument><expr><name><name>btn</name>-&gt;<name>out</name></name></expr></argument>, <argument><expr><name>Z_FINISH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>zerr</name> != <name>Z_STREAM_END</name> &amp;&amp; <name>zerr</name> != <name>Z_OK</name></expr>)</condition><then>
            <return>return <expr><call><name>zerr_to_svn_error</name><argument_list>(<argument><expr><name>zerr</name></expr></argument>, <argument><expr>"deflate"</expr></argument>, <argument><expr><name><name>btn</name>-&gt;<name>out</name></name></expr></argument>)</argument_list></call></expr>;</return></then></if>
          <expr_stmt><expr><name>write_len</name> = <name>ZBUFFER_SIZE</name> - <name><name>btn</name>-&gt;<name>out</name>-&gt;<name>avail_out</name></name></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>write_len</name> &gt; 0</expr>)</condition><then>
            <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name><name>btn</name>-&gt;<name>write</name></name><argument_list>(<argument><expr><name><name>btn</name>-&gt;<name>subbaton</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr>&amp;<name>write_len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
          <if>if <condition>(<expr><name>zerr</name> == <name>Z_STREAM_END</name></expr>)</condition><then>
            <break>break;</break></then></if>
        }</block></while>

      <expr_stmt><expr><name>zerr</name> = <call><name>deflateEnd</name><argument_list>(<argument><expr><name><name>btn</name>-&gt;<name>out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>zerr_to_svn_error</name><argument_list>(<argument><expr><name>zerr</name></expr></argument>, <argument><expr>"deflateEnd"</expr></argument>, <argument><expr><name><name>btn</name>-&gt;<name>out</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <if>if <condition>(<expr><name><name>btn</name>-&gt;<name>close</name></name> != <name>NULL</name></expr>)</condition><then>
    <return>return <expr><call><name><name>btn</name>-&gt;<name>close</name></name><argument_list>(<argument><expr><name><name>btn</name>-&gt;<name>subbaton</name></name></expr></argument>)</argument_list></call></expr>;</return></then>
  <else>else
    <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return></else></if>
}</block></function>


<function><type><name>svn_stream_t</name> *</type>
<name>svn_stream_compressed</name><parameter_list>(<param><decl><type><name>svn_stream_t</name> *</type><name>stream</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>svn_stream_t</name> *</type><name>zstream</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>zbaton</name> *</type><name>baton</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>stream</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>baton</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>baton</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>baton</name>-&gt;<name>in</name></name> = <name><name>baton</name>-&gt;<name>out</name></name> = <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>baton</name>-&gt;<name>read</name></name> = <name><name>stream</name>-&gt;<name>read_fn</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>baton</name>-&gt;<name>write</name></name> = <name><name>stream</name>-&gt;<name>write_fn</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>baton</name>-&gt;<name>close</name></name> = <name><name>stream</name>-&gt;<name>close_fn</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>baton</name>-&gt;<name>subbaton</name></name> = <name><name>stream</name>-&gt;<name>baton</name></name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>baton</name>-&gt;<name>pool</name></name> = <name>pool</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>baton</name>-&gt;<name>read_buffer</name></name> = <name>NULL</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>baton</name>-&gt;<name>read_flush</name></name> = <name>Z_SYNC_FLUSH</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>zstream</name> = <call><name>svn_stream_create</name><argument_list>(<argument><expr><name>baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_stream_set_read</name><argument_list>(<argument><expr><name>zstream</name></expr></argument>, <argument><expr><name>read_handler_gz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_stream_set_write</name><argument_list>(<argument><expr><name>zstream</name></expr></argument>, <argument><expr><name>write_handler_gz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_stream_set_close</name><argument_list>(<argument><expr><name>zstream</name></expr></argument>, <argument><expr><name>close_handler_gz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>zstream</name></expr>;</return>
}</block></function>

<escape char="0xc"/>
<comment type="block">/* MD5 checked stream support */</comment>

<struct>struct <name>md5_stream_baton</name>
<block>{
  <decl_stmt><decl><type><name>apr_md5_ctx_t</name></type> <name>read_ctx</name></decl>, <decl><type ref="prev"/><name>write_ctx</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> **</type><name>read_digest</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> **</type><name>write_digest</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>read_digest_buf</name><index>[<expr><name>APR_MD5_DIGESTSIZE</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>write_digest_buf</name><index>[<expr><name>APR_MD5_DIGESTSIZE</name></expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>proxy</name></decl>;</decl_stmt>

  <comment type="block">/* True if more data should be read when closing the stream. */</comment>
  <decl_stmt><decl><type><name>svn_boolean_t</name></type> <name>read_more</name></decl>;</decl_stmt>

  <comment type="block">/* Pool to allocate read buffer from. */</comment>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>read_handler_md5</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>char</name> *</type><name>buffer</name></decl></param>, <param><decl><type><name>apr_size_t</name> *</type><name>len</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>md5_stream_baton</name> *</type><name>btn</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>saved_len</name> <init>= <expr>*<name>len</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>svn_stream_read</name><argument_list>(<argument><expr><name><name>btn</name>-&gt;<name>proxy</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <if>if <condition>(<expr><name><name>btn</name>-&gt;<name>read_digest</name></name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>apr_status_t</name></type> <name>apr_err</name> <init>= <expr><call><name>apr_md5_update</name><argument_list>(<argument><expr>&amp;<name><name>btn</name>-&gt;<name>read_ctx</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr>*<name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <if>if <condition>(<expr><name>apr_err</name></expr>)</condition><then>
        <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>apr_err</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
    }</block></then></if>

  <if>if <condition>(<expr><name>saved_len</name> != *<name>len</name></expr>)</condition><then>
    <expr_stmt><expr><name><name>btn</name>-&gt;<name>read_more</name></name> = <name>FALSE</name></expr>;</expr_stmt></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>write_handler_md5</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>buffer</name></decl></param>, <param><decl><type><name>apr_size_t</name> *</type><name>len</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>md5_stream_baton</name> *</type><name>btn</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>

  <if>if <condition>(<expr><name><name>btn</name>-&gt;<name>write_digest</name></name> &amp;&amp; *<name>len</name> &gt; 0</expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>apr_status_t</name></type> <name>apr_err</name> <init>= <expr><call><name>apr_md5_update</name><argument_list>(<argument><expr>&amp;<name><name>btn</name>-&gt;<name>write_ctx</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr>*<name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <if>if <condition>(<expr><name>apr_err</name></expr>)</condition><then>
        <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>apr_err</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></then></if>
    }</block></then></if>

  <return>return <expr><call><name>svn_stream_write</name><argument_list>(<argument><expr><name><name>btn</name>-&gt;<name>proxy</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>close_handler_md5</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>md5_stream_baton</name> *</type><name>btn</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* If we're supposed to drain the stream, do so before finalizing the
     checksum. */</comment>
  <if>if <condition>(<expr><name><name>btn</name>-&gt;<name>read_more</name></name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>char</name> *</type><name>buf</name> <init>= <expr><call><name>apr_palloc</name><argument_list>(<argument><expr><name><name>btn</name>-&gt;<name>pool</name></name></expr></argument>, <argument><expr><name>SVN__STREAM_CHUNK_SIZE</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name> <init>= <expr><name>SVN__STREAM_CHUNK_SIZE</name></expr></init></decl>;</decl_stmt>

      <do>do
        <block>{
          <expr_stmt><expr><call><name>SVN_ERR</name><argument_list>(<argument><expr><call><name>read_handler_md5</name><argument_list>(<argument><expr><name>baton</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        }</block>
      while <condition>(<expr><name><name>btn</name>-&gt;<name>read_more</name></name></expr>)</condition>;</do>
    }</block></then></if>

  <if>if <condition>(<expr><name><name>btn</name>-&gt;<name>read_digest</name></name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>apr_status_t</name></type> <name>apr_err</name>
        <init>= <expr><call><name>apr_md5_final</name><argument_list>(<argument><expr><name><name>btn</name>-&gt;<name>read_digest_buf</name></name></expr></argument>, <argument><expr>&amp;<name><name>btn</name>-&gt;<name>read_ctx</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <if>if <condition>(<expr><name>apr_err</name></expr>)</condition><then>
        <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>apr_err</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

      <expr_stmt><expr>*<name><name>btn</name>-&gt;<name>read_digest</name></name> = <name><name>btn</name>-&gt;<name>read_digest_buf</name></name></expr>;</expr_stmt>
    }</block></then></if>

  <if>if <condition>(<expr><name><name>btn</name>-&gt;<name>write_digest</name></name></expr>)</condition><then>
    <block>{
      <decl_stmt><decl><type><name>apr_status_t</name></type> <name>apr_err</name>
        <init>= <expr><call><name>apr_md5_final</name><argument_list>(<argument><expr><name><name>btn</name>-&gt;<name>write_digest_buf</name></name></expr></argument>, <argument><expr>&amp;<name><name>btn</name>-&gt;<name>write_ctx</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <if>if <condition>(<expr><name>apr_err</name></expr>)</condition><then>
        <return>return <expr><call><name>svn_error_create</name><argument_list>(<argument><expr><name>apr_err</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

      <expr_stmt><expr>*<name><name>btn</name>-&gt;<name>write_digest</name></name> = <name><name>btn</name>-&gt;<name>write_digest_buf</name></name></expr>;</expr_stmt>
    }</block></then></if>

  <return>return <expr><call><name>svn_stream_close</name><argument_list>(<argument><expr><name><name>btn</name>-&gt;<name>proxy</name></name></expr></argument>)</argument_list></call></expr>;</return>
}</block></function>


<function><type><name>svn_stream_t</name> *</type>
<name>svn_stream_checksummed</name><parameter_list>(<param><decl><type><name>svn_stream_t</name> *</type><name>stream</name></decl></param>,
                       <param><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> **</type><name>read_digest</name></decl></param>,
                       <param><decl><type><specifier>const</specifier> <name>unsigned</name> <name>char</name> **</type><name>write_digest</name></decl></param>,
                       <param><decl><type><name>svn_boolean_t</name></type> <name>read_all</name></decl></param>,
                       <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>s</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>md5_stream_baton</name> *</type><name>baton</name></decl>;</decl_stmt>

  <if>if <condition>(<expr>! <name>read_digest</name> &amp;&amp; ! <name>write_digest</name></expr>)</condition><then>
    <return>return <expr><name>stream</name></expr>;</return></then></if>

  <expr_stmt><expr><name>baton</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>baton</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>apr_md5_init</name><argument_list>(<argument><expr>&amp;<name><name>baton</name>-&gt;<name>read_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>apr_md5_init</name><argument_list>(<argument><expr>&amp;<name><name>baton</name>-&gt;<name>write_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>baton</name>-&gt;<name>read_digest</name></name> = <name>read_digest</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>baton</name>-&gt;<name>write_digest</name></name> = <name>write_digest</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>baton</name>-&gt;<name>proxy</name></name> = <name>stream</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>baton</name>-&gt;<name>read_more</name></name> = <name>read_all</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>baton</name>-&gt;<name>pool</name></name> = <name>pool</name></expr>;</expr_stmt>

  <expr_stmt><expr><name>s</name> = <call><name>svn_stream_create</name><argument_list>(<argument><expr><name>baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_stream_set_read</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>read_handler_md5</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_stream_set_write</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>write_handler_md5</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_stream_set_close</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>close_handler_md5</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>s</name></expr>;</return>
}</block></function>



<escape char="0xc"/>
<comment type="block">/* Miscellaneous stream functions. */</comment>
<struct>struct <name>string_stream_baton</name>
<block>{
  <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>str</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>amt_read</name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>read_handler_string</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><name>char</name> *</type><name>buffer</name></decl></param>, <param><decl><type><name>apr_size_t</name> *</type><name>len</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>string_stream_baton</name> *</type><name>btn</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>left_to_read</name> <init>= <expr><name><name>btn</name>-&gt;<name>str</name>-&gt;<name>len</name></name> - <name><name>btn</name>-&gt;<name>amt_read</name></name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr>*<name>len</name> = (*<name>len</name> &gt; <name>left_to_read</name>) ? <name>left_to_read</name> : *<name>len</name></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name><name>btn</name>-&gt;<name>str</name>-&gt;<name>data</name></name> + <name><name>btn</name>-&gt;<name>amt_read</name></name></expr></argument>, <argument><expr>*<name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>btn</name>-&gt;<name>amt_read</name></name> += *<name>len</name></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>write_handler_string</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name></decl></param>, <param><decl><type><name>apr_size_t</name> *</type><name>len</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>string_stream_baton</name> *</type><name>btn</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>svn_stringbuf_appendbytes</name><argument_list>(<argument><expr><name><name>btn</name>-&gt;<name>str</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr>*<name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>

<function><type><name>svn_stream_t</name> *</type>
<name>svn_stream_from_stringbuf</name><parameter_list>(<param><decl><type><name>svn_stringbuf_t</name> *</type><name>str</name></decl></param>,
                          <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>stream</name></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>string_stream_baton</name> *</type><name>baton</name></decl>;</decl_stmt>

  <if>if <condition>(<expr>! <name>str</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_stream_empty</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr><name>baton</name> = <call><name>apr_palloc</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>baton</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>baton</name>-&gt;<name>str</name></name> = <name>str</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>baton</name>-&gt;<name>amt_read</name></name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name>stream</name> = <call><name>svn_stream_create</name><argument_list>(<argument><expr><name>baton</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_stream_set_read</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><name>read_handler_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_stream_set_write</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><name>write_handler_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>stream</name></expr>;</return>
}</block></function>


<function><type><name>svn_error_t</name> *</type>
<name>svn_stream_for_stdout</name><parameter_list>(<param><decl><type><name>svn_stream_t</name> **</type><name>out</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_file_t</name> *</type><name>stdout_file</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_status_t</name></type> <name>apr_err</name></decl>;</decl_stmt>

  <expr_stmt><expr><name>apr_err</name> = <call><name>apr_file_open_stdout</name><argument_list>(<argument><expr>&amp;<name>stdout_file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>apr_err</name></expr>)</condition><then>
    <return>return <expr><call><name>svn_error_wrap_apr</name><argument_list>(<argument><expr><name>apr_err</name></expr></argument>, <argument><expr>"Can't open stdout"</expr></argument>)</argument_list></call></expr>;</return></then></if>

  <expr_stmt><expr>*<name>out</name> = <call><name>svn_stream_from_aprfile</name><argument_list>(<argument><expr><name>stdout_file</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>
</unit>
