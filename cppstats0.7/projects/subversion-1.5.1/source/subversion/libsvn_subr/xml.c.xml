<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/subversion-1.5.1/source/subversion/libsvn_subr/xml.c"><comment type="block">/*
 * xml.c:  xml helper code shared among the Subversion libraries.
 *
 * ====================================================================
 * Copyright (c) 2000-2006 CollabNet.  All rights reserved.
 *
 * This software is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at http://subversion.tigris.org/license-1.html.
 * If newer versions of this license are posted there, you may use a
 * newer version instead, at your option.
 *
 * This software consists of voluntary contributions made by many
 * individuals.  For exact contribution history, see the revision
 * history and logs, available at http://subversion.tigris.org/.
 * ====================================================================
 */</comment>


<escape char="0xc"/>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_private_config.h"</cpp:file></cpp:include>         <comment type="block">/* for SVN_HAVE_OLD_EXPAT */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_pools.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_xml.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_error.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_ctype.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utf_impl.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SVN_HAVE_OLD_EXPAT</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;xmlparse.h&gt;</cpp:file></cpp:include>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;expat.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>XML_UNICODE</name></cpp:ifdef>
<cpp:error>#<cpp:directive>error</cpp:directive> Expat is unusable -- it has been compiled for wide characters</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* The private internals for a parser object. */</comment>
<struct>struct <name>svn_xml_parser_t</name>
<block>{
  <comment type="block">/** the expat parser */</comment>
  <decl_stmt><decl><type><name>XML_Parser</name></type> <name>parser</name></decl>;</decl_stmt>

  <comment type="block">/** the SVN callbacks to call from the Expat callbacks */</comment>
  <decl_stmt><decl><type><name>svn_xml_start_elem</name></type> <name>start_handler</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_xml_end_elem</name></type> <name>end_handler</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_xml_char_data</name></type> <name>data_handler</name></decl>;</decl_stmt>

  <comment type="block">/** the user's baton for private data */</comment>
  <decl_stmt><decl><type><name>void</name> *</type><name>baton</name></decl>;</decl_stmt>

  <comment type="block">/** if non-@c NULL, an error happened while parsing */</comment>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>error</name></decl>;</decl_stmt>

  <comment type="block">/** where this object is allocated, so we can free it easily */</comment>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>

}</block>;</struct>

<escape char="0xc"/>
<comment type="block">/*** XML character validation ***/</comment>

<function><type><name>svn_boolean_t</name></type>
<name>svn_xml_is_xml_safe</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name></decl></param>, <param><decl><type><name>apr_size_t</name></type> <name>len</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>end</name> <init>= <expr><name>data</name> + <name>len</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name></decl>;</decl_stmt>

  <if>if <condition>(<expr>! <call><name>svn_utf__is_valid</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>)</condition><then>
    <return>return <expr><name>FALSE</name></expr>;</return></then></if>

  <for>for (<init><expr><name>p</name> = <name>data</name></expr>;</init> <condition><expr><name>p</name> &lt; <name>end</name></expr>;</condition> <incr><expr><name>p</name>++</expr></incr>)
    <block>{
      <decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name>c</name> <init>= <expr>*<name>p</name></expr></init></decl>;</decl_stmt>

      <if>if <condition>(<expr><call><name>svn_ctype_iscntrl</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <if>if <condition>(<expr>(<name>c</name> != <name>SVN_CTYPE_ASCII_TAB</name>)
              &amp;&amp; (<name>c</name> != <name>SVN_CTYPE_ASCII_LINEFEED</name>)
              &amp;&amp; (<name>c</name> != <name>SVN_CTYPE_ASCII_CARRIAGERETURN</name>)
              &amp;&amp; (<name>c</name> != <name>SVN_CTYPE_ASCII_DELETE</name>)</expr>)</condition><then>
            <return>return <expr><name>FALSE</name></expr>;</return></then></if>
        }</block></then></if>
    }</block></for>
  <return>return <expr><name>TRUE</name></expr>;</return>
}</block></function>




<escape char="0xc"/>
<comment type="block">/*** XML escaping. ***/</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>xml_escape_cdata</name><parameter_list>(<param><decl><type><name>svn_stringbuf_t</name> **</type><name>outstr</name></decl></param>,
                 <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name></decl></param>,
                 <param><decl><type><name>apr_size_t</name></type> <name>len</name></decl></param>,
                 <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>end</name> <init>= <expr><name>data</name> + <name>len</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name> <init>= <expr><name>data</name></expr></init>, *<name>q</name></decl>;</decl_stmt>

  <if>if <condition>(<expr>*<name>outstr</name> == <name>NULL</name></expr>)</condition><then>
    <expr_stmt><expr>*<name>outstr</name> = <call><name>svn_stringbuf_create</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <while>while <condition>(<expr>1</expr>)</condition>
    <block>{
      <comment type="block">/* Find a character which needs to be quoted and append bytes up
         to that point.  Strictly speaking, '&gt;' only needs to be
         quoted if it follows "]]", but it's easier to quote it all
         the time.

         So, why are we escaping '\r' here?  Well, according to the
         XML spec, '\r\n' gets converted to '\n' during XML parsing.
         Also, any '\r' not followed by '\n' is converted to '\n'.  By
         golly, if we say we want to escape a '\r', we want to make
         sure it remains a '\r'!  */</comment>
      <expr_stmt><expr><name>q</name> = <name>p</name></expr>;</expr_stmt>
      <while>while <condition>(<expr><name>q</name> &lt; <name>end</name> &amp;&amp; *<name>q</name> != '&amp;' &amp;&amp; *<name>q</name> != '&lt;' &amp;&amp; *<name>q</name> != '&gt;' &amp;&amp; *<name>q</name> != '\r'</expr>)</condition>
        <expr_stmt><expr><name>q</name>++</expr>;</expr_stmt></while>
      <expr_stmt><expr><call><name>svn_stringbuf_appendbytes</name><argument_list>(<argument><expr>*<name>outstr</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>q</name> - <name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* We may already be a winner.  */</comment>
      <if>if <condition>(<expr><name>q</name> == <name>end</name></expr>)</condition><then>
        <break>break;</break></then></if>

      <comment type="block">/* Append the entity reference for the character.  */</comment>
      <if>if <condition>(<expr>*<name>q</name> == '&amp;'</expr>)</condition><then>
        <expr_stmt><expr><call><name>svn_stringbuf_appendcstr</name><argument_list>(<argument><expr>*<name>outstr</name></expr></argument>, <argument><expr>"&amp;amp;"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
      <else>else <if>if <condition>(<expr>*<name>q</name> == '&lt;'</expr>)</condition><then>
        <expr_stmt><expr><call><name>svn_stringbuf_appendcstr</name><argument_list>(<argument><expr>*<name>outstr</name></expr></argument>, <argument><expr>"&amp;lt;"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
      <else>else <if>if <condition>(<expr>*<name>q</name> == '&gt;'</expr>)</condition><then>
        <expr_stmt><expr><call><name>svn_stringbuf_appendcstr</name><argument_list>(<argument><expr>*<name>outstr</name></expr></argument>, <argument><expr>"&amp;gt;"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
      <else>else <if>if <condition>(<expr>*<name>q</name> == '\r'</expr>)</condition><then>
        <expr_stmt><expr><call><name>svn_stringbuf_appendcstr</name><argument_list>(<argument><expr>*<name>outstr</name></expr></argument>, <argument><expr>"&amp;#13;"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if></else></if></else></if>

      <expr_stmt><expr><name>p</name> = <name>q</name> + 1</expr>;</expr_stmt>
    }</block></while>
}</block></function>

<comment type="block">/* Essentially the same as xml_escape_cdata, with the addition of
   whitespace and quote characters. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>xml_escape_attr</name><parameter_list>(<param><decl><type><name>svn_stringbuf_t</name> **</type><name>outstr</name></decl></param>,
                <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name></decl></param>,
                <param><decl><type><name>apr_size_t</name></type> <name>len</name></decl></param>,
                <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>end</name> <init>= <expr><name>data</name> + <name>len</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name> <init>= <expr><name>data</name></expr></init>, *<name>q</name></decl>;</decl_stmt>

  <if>if <condition>(<expr>*<name>outstr</name> == <name>NULL</name></expr>)</condition><then>
    <expr_stmt><expr>*<name>outstr</name> = <call><name>svn_stringbuf_create</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <while>while <condition>(<expr>1</expr>)</condition>
    <block>{
      <comment type="block">/* Find a character which needs to be quoted and append bytes up
         to that point. */</comment>
      <expr_stmt><expr><name>q</name> = <name>p</name></expr>;</expr_stmt>
      <while>while <condition>(<expr><name>q</name> &lt; <name>end</name> &amp;&amp; *<name>q</name> != '&amp;' &amp;&amp; *<name>q</name> != '&lt;' &amp;&amp; *<name>q</name> != '&gt;'
             &amp;&amp; *<name>q</name> != '"' &amp;&amp; *<name>q</name> != '\'' &amp;&amp; *<name>q</name> != '\r'
             &amp;&amp; *<name>q</name> != '\n' &amp;&amp; *<name>q</name> != '\t'</expr>)</condition>
        <expr_stmt><expr><name>q</name>++</expr>;</expr_stmt></while>
      <expr_stmt><expr><call><name>svn_stringbuf_appendbytes</name><argument_list>(<argument><expr>*<name>outstr</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>q</name> - <name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* We may already be a winner.  */</comment>
      <if>if <condition>(<expr><name>q</name> == <name>end</name></expr>)</condition><then>
        <break>break;</break></then></if>

      <comment type="block">/* Append the entity reference for the character.  */</comment>
      <if>if <condition>(<expr>*<name>q</name> == '&amp;'</expr>)</condition><then>
        <expr_stmt><expr><call><name>svn_stringbuf_appendcstr</name><argument_list>(<argument><expr>*<name>outstr</name></expr></argument>, <argument><expr>"&amp;amp;"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
      <else>else <if>if <condition>(<expr>*<name>q</name> == '&lt;'</expr>)</condition><then>
        <expr_stmt><expr><call><name>svn_stringbuf_appendcstr</name><argument_list>(<argument><expr>*<name>outstr</name></expr></argument>, <argument><expr>"&amp;lt;"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
      <else>else <if>if <condition>(<expr>*<name>q</name> == '&gt;'</expr>)</condition><then>
        <expr_stmt><expr><call><name>svn_stringbuf_appendcstr</name><argument_list>(<argument><expr>*<name>outstr</name></expr></argument>, <argument><expr>"&amp;gt;"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
      <else>else <if>if <condition>(<expr>*<name>q</name> == '"'</expr>)</condition><then>
        <expr_stmt><expr><call><name>svn_stringbuf_appendcstr</name><argument_list>(<argument><expr>*<name>outstr</name></expr></argument>, <argument><expr>"&amp;quot;"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
      <else>else <if>if <condition>(<expr>*<name>q</name> == '\''</expr>)</condition><then>
        <expr_stmt><expr><call><name>svn_stringbuf_appendcstr</name><argument_list>(<argument><expr>*<name>outstr</name></expr></argument>, <argument><expr>"&amp;apos;"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
      <else>else <if>if <condition>(<expr>*<name>q</name> == '\r'</expr>)</condition><then>
        <expr_stmt><expr><call><name>svn_stringbuf_appendcstr</name><argument_list>(<argument><expr>*<name>outstr</name></expr></argument>, <argument><expr>"&amp;#13;"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
      <else>else <if>if <condition>(<expr>*<name>q</name> == '\n'</expr>)</condition><then>
        <expr_stmt><expr><call><name>svn_stringbuf_appendcstr</name><argument_list>(<argument><expr>*<name>outstr</name></expr></argument>, <argument><expr>"&amp;#10;"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then>
      <else>else <if>if <condition>(<expr>*<name>q</name> == '\t'</expr>)</condition><then>
        <expr_stmt><expr><call><name>svn_stringbuf_appendcstr</name><argument_list>(<argument><expr>*<name>outstr</name></expr></argument>, <argument><expr>"&amp;#9;"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if></else></if></else></if></else></if></else></if></else></if></else></if></else></if>

      <expr_stmt><expr><name>p</name> = <name>q</name> + 1</expr>;</expr_stmt>
    }</block></while>
}</block></function>


<function><type><name>void</name></type>
<name>svn_xml_escape_cdata_stringbuf</name><parameter_list>(<param><decl><type><name>svn_stringbuf_t</name> **</type><name>outstr</name></decl></param>,
                               <param><decl><type><specifier>const</specifier> <name>svn_stringbuf_t</name> *</type><name>string</name></decl></param>,
                               <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>xml_escape_cdata</name><argument_list>(<argument><expr><name>outstr</name></expr></argument>, <argument><expr><name><name>string</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>string</name>-&gt;<name>len</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<function><type><name>void</name></type>
<name>svn_xml_escape_cdata_string</name><parameter_list>(<param><decl><type><name>svn_stringbuf_t</name> **</type><name>outstr</name></decl></param>,
                            <param><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>string</name></decl></param>,
                            <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>xml_escape_cdata</name><argument_list>(<argument><expr><name>outstr</name></expr></argument>, <argument><expr><name><name>string</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>string</name>-&gt;<name>len</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<function><type><name>void</name></type>
<name>svn_xml_escape_cdata_cstring</name><parameter_list>(<param><decl><type><name>svn_stringbuf_t</name> **</type><name>outstr</name></decl></param>,
                             <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>string</name></decl></param>,
                             <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>xml_escape_cdata</name><argument_list>(<argument><expr><name>outstr</name></expr></argument>, <argument><expr><name>string</name></expr></argument>, <argument><expr>(<name>apr_size_t</name>) <call><name>strlen</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<function><type><name>void</name></type>
<name>svn_xml_escape_attr_stringbuf</name><parameter_list>(<param><decl><type><name>svn_stringbuf_t</name> **</type><name>outstr</name></decl></param>,
                              <param><decl><type><specifier>const</specifier> <name>svn_stringbuf_t</name> *</type><name>string</name></decl></param>,
                              <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>xml_escape_attr</name><argument_list>(<argument><expr><name>outstr</name></expr></argument>, <argument><expr><name><name>string</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>string</name>-&gt;<name>len</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<function><type><name>void</name></type>
<name>svn_xml_escape_attr_string</name><parameter_list>(<param><decl><type><name>svn_stringbuf_t</name> **</type><name>outstr</name></decl></param>,
                           <param><decl><type><specifier>const</specifier> <name>svn_string_t</name> *</type><name>string</name></decl></param>,
                           <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>xml_escape_attr</name><argument_list>(<argument><expr><name>outstr</name></expr></argument>, <argument><expr><name><name>string</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>string</name>-&gt;<name>len</name></name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<function><type><name>void</name></type>
<name>svn_xml_escape_attr_cstring</name><parameter_list>(<param><decl><type><name>svn_stringbuf_t</name> **</type><name>outstr</name></decl></param>,
                            <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>string</name></decl></param>,
                            <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>xml_escape_attr</name><argument_list>(<argument><expr><name>outstr</name></expr></argument>, <argument><expr><name>string</name></expr></argument>, <argument><expr>(<name>apr_size_t</name>) <call><name>strlen</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<function><type><specifier>const</specifier> <name>char</name> *</type>
<name>svn_xml_fuzzy_escape</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>string</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>end</name> <init>= <expr><name>string</name> + <call><name>strlen</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name> <init>= <expr><name>string</name></expr></init>, *<name>q</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>outstr</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>escaped_char</name><index>[<expr>6</expr>]</index></name></decl>;</decl_stmt>   <comment type="block">/* ? \ u u u \0 */</comment>

  <for>for (<init><expr><name>q</name> = <name>p</name></expr>;</init> <condition><expr><name>q</name> &lt; <name>end</name></expr>;</condition> <incr><expr><name>q</name>++</expr></incr>)
    <block>{
      <if>if <condition>(<expr><call><name>svn_ctype_iscntrl</name><argument_list>(<argument><expr>*<name>q</name></expr></argument>)</argument_list></call>
          &amp;&amp; ! ((*<name>q</name> == '\n') || (*<name>q</name> == '\r') || (*<name>q</name> == '\t'))</expr>)</condition><then>
        <break>break;</break></then></if>
    }</block></for>

  <comment type="block">/* Return original string if no unsafe characters found. */</comment>
  <if>if <condition>(<expr><name>q</name> == <name>end</name></expr>)</condition><then>
    <return>return <expr><name>string</name></expr>;</return></then></if>

  <expr_stmt><expr><name>outstr</name> = <call><name>svn_stringbuf_create</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <while>while <condition>(<expr>1</expr>)</condition>
    <block>{
      <expr_stmt><expr><name>q</name> = <name>p</name></expr>;</expr_stmt>

      <comment type="block">/* Traverse till either unsafe character or eos. */</comment>
      <while>while <condition>(<expr>(<name>q</name> &lt; <name>end</name>)
             &amp;&amp; ((! <call><name>svn_ctype_iscntrl</name><argument_list>(<argument><expr>*<name>q</name></expr></argument>)</argument_list></call>)
                 || (*<name>q</name> == '\n') || (*<name>q</name> == '\r') || (*<name>q</name> == '\t'))</expr>)</condition>
        <expr_stmt><expr><name>q</name>++</expr>;</expr_stmt></while>

      <comment type="block">/* copy chunk before marker */</comment>
      <expr_stmt><expr><call><name>svn_stringbuf_appendbytes</name><argument_list>(<argument><expr><name>outstr</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name>q</name> - <name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <if>if <condition>(<expr><name>q</name> == <name>end</name></expr>)</condition><then>
        <break>break;</break></then></if>

      <comment type="block">/* Append an escaped version of the unsafe character.

         ### This format was chosen for consistency with
         ### svn_utf__cstring_from_utf8_fuzzy().  The two functions
         ### should probably share code, even though they escape
         ### different characters.
      */</comment>
      <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>escaped_char</name></expr></argument>, <argument><expr>"?\\%03u"</expr></argument>, <argument><expr>(<name>unsigned</name> <name>char</name>) *<name>q</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>svn_stringbuf_appendcstr</name><argument_list>(<argument><expr><name>outstr</name></expr></argument>, <argument><expr><name>escaped_char</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><name>p</name> = <name>q</name> + 1</expr>;</expr_stmt>
    }</block></while>

  <return>return <expr><name><name>outstr</name>-&gt;<name>data</name></name></expr>;</return>
}</block></function>

<escape char="0xc"/>
<comment type="block">/*** Map from the Expat callback types to the SVN XML types. ***/</comment>

<function><type><specifier>static</specifier> <name>void</name></type> <name>expat_start_handler</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>userData</name></decl></param>,
                                <param><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>name</name></decl></param>,
                                <param><decl><type><specifier>const</specifier> <name>XML_Char</name> **</type><name>atts</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_xml_parser_t</name> *</type><name>svn_parser</name> <init>= <expr><name>userData</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call>(*<name><name>svn_parser</name>-&gt;<name>start_handler</name></name>)<argument_list>(<argument><expr><name><name>svn_parser</name>-&gt;<name>baton</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>atts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>expat_end_handler</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>userData</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>name</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_xml_parser_t</name> *</type><name>svn_parser</name> <init>= <expr><name>userData</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call>(*<name><name>svn_parser</name>-&gt;<name>end_handler</name></name>)<argument_list>(<argument><expr><name><name>svn_parser</name>-&gt;<name>baton</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>expat_data_handler</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>userData</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>XML_Char</name> *</type><name>s</name></decl></param>, <param><decl><type><name>int</name></type> <name>len</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_xml_parser_t</name> *</type><name>svn_parser</name> <init>= <expr><name>userData</name></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call>(*<name><name>svn_parser</name>-&gt;<name>data_handler</name></name>)<argument_list>(<argument><expr><name><name>svn_parser</name>-&gt;<name>baton</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr>(<name>apr_size_t</name>)<name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>

<escape char="0xc"/>
<comment type="block">/*** Making a parser. ***/</comment>

<function><type><name>svn_xml_parser_t</name> *</type>
<name>svn_xml_make_parser</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>,
                    <param><decl><type><name>svn_xml_start_elem</name></type> <name>start_handler</name></decl></param>,
                    <param><decl><type><name>svn_xml_end_elem</name></type> <name>end_handler</name></decl></param>,
                    <param><decl><type><name>svn_xml_char_data</name></type> <name>data_handler</name></decl></param>,
                    <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_xml_parser_t</name> *</type><name>svn_parser</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name></decl>;</decl_stmt>

  <decl_stmt><decl><type><name>XML_Parser</name></type> <name>parser</name> <init>= <expr><call><name>XML_ParserCreate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>XML_SetElementHandler</name><argument_list>(<argument><expr><name>parser</name></expr></argument>,
                        <argument><expr><name>start_handler</name> ? <name>expat_start_handler</name> : <name>NULL</name></expr></argument>,
                        <argument><expr><name>end_handler</name> ? <name>expat_end_handler</name> : <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>XML_SetCharacterDataHandler</name><argument_list>(<argument><expr><name>parser</name></expr></argument>,
                              <argument><expr><name>data_handler</name> ? <name>expat_data_handler</name> : <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* ### we probably don't want this pool; or at least we should pass it
     ### to the callbacks and clear it periodically.  */</comment>
  <expr_stmt><expr><name>subpool</name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name>svn_parser</name> = <call><name>apr_pcalloc</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>svn_parser</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <expr_stmt><expr><name><name>svn_parser</name>-&gt;<name>parser</name></name> = <name>parser</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>svn_parser</name>-&gt;<name>start_handler</name></name> = <name>start_handler</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>svn_parser</name>-&gt;<name>end_handler</name></name> = <name>end_handler</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>svn_parser</name>-&gt;<name>data_handler</name></name> = <name>data_handler</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>svn_parser</name>-&gt;<name>baton</name></name> = <name>baton</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>svn_parser</name>-&gt;<name>pool</name></name> = <name>subpool</name></expr>;</expr_stmt>

  <comment type="block">/* store our parser info as the UserData in the Expat parser */</comment>
  <expr_stmt><expr><call><name>XML_SetUserData</name><argument_list>(<argument><expr><name>parser</name></expr></argument>, <argument><expr><name>svn_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <return>return <expr><name>svn_parser</name></expr>;</return>
}</block></function>


<comment type="block">/* Free a parser */</comment>
<function><type><name>void</name></type>
<name>svn_xml_free_parser</name><parameter_list>(<param><decl><type><name>svn_xml_parser_t</name> *</type><name>svn_parser</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* Free the expat parser */</comment>
  <expr_stmt><expr><call><name>XML_ParserFree</name><argument_list>(<argument><expr><name><name>svn_parser</name>-&gt;<name>parser</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Free the subversion parser */</comment>
  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name><name>svn_parser</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>




<function><type><name>svn_error_t</name> *</type>
<name>svn_xml_parse</name><parameter_list>(<param><decl><type><name>svn_xml_parser_t</name> *</type><name>svn_parser</name></decl></param>,
              <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>buf</name></decl></param>,
              <param><decl><type><name>apr_size_t</name></type> <name>len</name></decl></param>,
              <param><decl><type><name>svn_boolean_t</name></type> <name>is_final</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>success</name></decl>;</decl_stmt>

  <comment type="block">/* Parse some xml data */</comment>
  <expr_stmt><expr><name>success</name> = <call><name>XML_Parse</name><argument_list>(<argument><expr><name><name>svn_parser</name>-&gt;<name>parser</name></name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>is_final</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* If expat choked internally, return its error. */</comment>
  <if>if <condition>(<expr>! <name>success</name></expr>)</condition><then>
    <block>{
      <comment type="block">/* Line num is "int" in Expat v1, "long" in v2; hide the difference. */</comment>
      <decl_stmt><decl><type><name>long</name></type> <name>line</name> <init>= <expr><call><name>XML_GetCurrentLineNumber</name><argument_list>(<argument><expr><name><name>svn_parser</name>-&gt;<name>parser</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

      <expr_stmt><expr><name>err</name> = <call><name>svn_error_createf</name>
        <argument_list>(<argument><expr><name>SVN_ERR_XML_MALFORMED</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
         <argument><expr><call><name>_</name><argument_list>(<argument><expr>"Malformed XML: %s at line %ld"</expr></argument>)</argument_list></call></expr></argument>,
         <argument><expr><call><name>XML_ErrorString</name><argument_list>(<argument><expr><call><name>XML_GetErrorCode</name><argument_list>(<argument><expr><name><name>svn_parser</name>-&gt;<name>parser</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <comment type="block">/* Kill all parsers and return the expat error */</comment>
      <expr_stmt><expr><call><name>svn_xml_free_parser</name><argument_list>(<argument><expr><name>svn_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>err</name></expr>;</return>
    }</block></then></if>

  <comment type="block">/* Did an error occur somewhere *inside* the expat callbacks? */</comment>
  <if>if <condition>(<expr><name><name>svn_parser</name>-&gt;<name>error</name></name></expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>err</name> = <name><name>svn_parser</name>-&gt;<name>error</name></name></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>svn_xml_free_parser</name><argument_list>(<argument><expr><name>svn_parser</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <return>return <expr><name>err</name></expr>;</return>
    }</block></then></if>

  <return>return <expr><name>SVN_NO_ERROR</name></expr>;</return>
}</block></function>



<function><type><name>void</name></type> <name>svn_xml_signal_bailout</name><parameter_list>(<param><decl><type><name>svn_error_t</name> *</type><name>error</name></decl></param>,
                            <param><decl><type><name>svn_xml_parser_t</name> *</type><name>svn_parser</name></decl></param>)</parameter_list>
<block>{
  <comment type="block">/* This will cause the current XML_Parse() call to finish quickly! */</comment>
  <expr_stmt><expr><call><name>XML_SetElementHandler</name><argument_list>(<argument><expr><name><name>svn_parser</name>-&gt;<name>parser</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>XML_SetCharacterDataHandler</name><argument_list>(<argument><expr><name><name>svn_parser</name>-&gt;<name>parser</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Once outside of XML_Parse(), the existence of this field will
     cause svn_delta_parse()'s main read-loop to return error. */</comment>
  <expr_stmt><expr><name><name>svn_parser</name>-&gt;<name>error</name></name> = <name>error</name></expr>;</expr_stmt>
}</block></function>







<escape char="0xc"/>
<comment type="block">/*** Attribute walking. ***/</comment>

<function><type><specifier>const</specifier> <name>char</name> *</type>
<name>svn_xml_get_attr_value</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>name</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>atts</name></decl></param>)</parameter_list>
<block>{
  <while>while <condition>(<expr><name>atts</name> &amp;&amp; (*<name>atts</name>)</expr>)</condition>
    <block>{
      <if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>atts</name><index>[<expr>0</expr>]</index></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> == 0</expr>)</condition><then>
        <return>return <expr><name><name>atts</name><index>[<expr>1</expr>]</index></name></expr>;</return></then>
      <else>else
        <expr_stmt><expr><name>atts</name> += 2</expr>;</expr_stmt></else></if> <comment type="block">/* continue looping */</comment>
    }</block></while>

  <comment type="block">/* Else no such attribute name seen. */</comment>
  <return>return <expr><name>NULL</name></expr>;</return>
}</block></function>


<escape char="0xc"/>
<comment type="block">/*** Printing XML ***/</comment>

<function><type><name>void</name></type>
<name>svn_xml_make_header</name><parameter_list>(<param><decl><type><name>svn_stringbuf_t</name> **</type><name>str</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>*<name>str</name> == <name>NULL</name></expr>)</condition><then>
    <expr_stmt><expr>*<name>str</name> = <call><name>svn_stringbuf_create</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <expr_stmt><expr><call><name>svn_stringbuf_appendcstr</name><argument_list>(<argument><expr>*<name>str</name></expr></argument>,
                           <argument><expr>"&lt;?xml version=\"1.0\"?&gt;\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<escape char="0xc"/>
<comment type="block">/*** Creating attribute hashes. ***/</comment>

<comment type="block">/* Combine an existing attribute list ATTS with a HASH that itself
   represents an attribute list.  Iff PRESERVE is true, then no value
   already in HASH will be changed, else values from ATTS will
   override previous values in HASH. */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>amalgamate</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>atts</name></decl></param>,
           <param><decl><type><name>apr_hash_t</name> *</type><name>ht</name></decl></param>,
           <param><decl><type><name>svn_boolean_t</name></type> <name>preserve</name></decl></param>,
           <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>key</name></decl>;</decl_stmt>

  <if>if <condition>(<expr><name>atts</name></expr>)</condition><then>
    <for>for (<init><expr><name>key</name> = *<name>atts</name></expr>;</init> <condition><expr><name>key</name></expr>;</condition> <incr><expr><name>key</name> = *(++<name>atts</name>)</expr></incr>)
      <block>{
        <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>val</name> <init>= <expr>*(++<name>atts</name>)</expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>size_t</name></type> <name>keylen</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>key</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* kff todo: should we also insist that val be non-null here?
           Probably. */</comment>

        <expr_stmt><expr><name>keylen</name> = <call><name>strlen</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <if>if <condition>(<expr><name>preserve</name> &amp;&amp; ((<call><name>apr_hash_get</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>keylen</name></expr></argument>)</argument_list></call>) != <name>NULL</name>)</expr>)</condition><then>
          <continue>continue;</continue></then>
        <else>else
          <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><call><name>apr_pstrndup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>keylen</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>keylen</name></expr></argument>,
                       <argument><expr><name>val</name> ? <call><name>apr_pstrdup</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call> : <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></else></if>
      }</block></for></then></if>
}</block></function>


<function><type><name>apr_hash_t</name> *</type>
<name>svn_xml_ap_to_hash</name><parameter_list>(<param><decl><type><name>va_list</name></type> <name>ap</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>ht</name> <init>= <expr><call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>key</name></decl>;</decl_stmt>

  <while>while <condition>(<expr>(<name>key</name> = <call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>char</name> *</expr></argument>)</argument_list></call>) != <name>NULL</name></expr>)</condition>
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>val</name> <init>= <expr><call><name>va_arg</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr>const <name>char</name> *</expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
      <expr_stmt><expr><call><name>apr_hash_set</name><argument_list>(<argument><expr><name>ht</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>APR_HASH_KEY_STRING</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></while>

  <return>return <expr><name>ht</name></expr>;</return>
}</block></function>


<function><type><name>apr_hash_t</name> *</type>
<name>svn_xml_make_att_hash</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>atts</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>ht</name> <init>= <expr><call><name>apr_hash_make</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <expr_stmt><expr><call><name>amalgamate</name><argument_list>(<argument><expr><name>atts</name></expr></argument>, <argument><expr><name>ht</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* third arg irrelevant in this case */</comment>
  <return>return <expr><name>ht</name></expr>;</return>
}</block></function>


<function><type><name>void</name></type>
<name>svn_xml_hash_atts_overlaying</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>atts</name></decl></param>,
                             <param><decl><type><name>apr_hash_t</name> *</type><name>ht</name></decl></param>,
                             <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>amalgamate</name><argument_list>(<argument><expr><name>atts</name></expr></argument>, <argument><expr><name>ht</name></expr></argument>, <argument><expr>0</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<function><type><name>void</name></type>
<name>svn_xml_hash_atts_preserving</name><parameter_list>(<param><decl><type><specifier>const</specifier> <name>char</name> **</type><name>atts</name></decl></param>,
                             <param><decl><type><name>apr_hash_t</name> *</type><name>ht</name></decl></param>,
                             <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <expr_stmt><expr><call><name>amalgamate</name><argument_list>(<argument><expr><name>atts</name></expr></argument>, <argument><expr><name>ht</name></expr></argument>, <argument><expr>1</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>


<escape char="0xc"/>
<comment type="block">/*** Making XML tags. ***/</comment>


<decl_stmt><decl><type><name>void</name></type>
<name>svn_xml_make_open_tag_hash</name><argument_list>(<argument><expr><name>svn_stringbuf_t</name> **<name>str</name></expr></argument>,
                           <argument><expr><name>apr_pool_t</name> *<name>pool</name></expr></argument>,
                           <argument>enum <expr><name>svn_xml_open_tag_style</name> <name>style</name></expr></argument>,
                           <argument><expr>const <name>char</name> *<name>tagname</name></expr></argument>,
                           <argument><expr><name>apr_hash_t</name> *<name>attributes</name></expr></argument>)</argument_list>
<block>{
  <decl_stmt><decl><type><name>apr_hash_index_t</name> *</type><name>hi</name></decl>;</decl_stmt>

  <if>if <condition>(<expr>*<name>str</name> == <name>NULL</name></expr>)</condition><then>
    <expr_stmt><expr>*<name>str</name> = <call><name>svn_stringbuf_create</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <expr_stmt><expr><call><name>svn_stringbuf_appendcstr</name><argument_list>(<argument><expr>*<name>str</name></expr></argument>, <argument><expr>"&lt;"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_stringbuf_appendcstr</name><argument_list>(<argument><expr>*<name>str</name></expr></argument>, <argument><expr><name>tagname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <for>for (<init><expr><name>hi</name> = <call><name>apr_hash_first</name><argument_list>(<argument><expr><name>pool</name></expr></argument>, <argument><expr><name>attributes</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>hi</name></expr>;</condition> <incr><expr><name>hi</name> = <call><name>apr_hash_next</name><argument_list>(<argument><expr><name>hi</name></expr></argument>)</argument_list></call></expr></incr>)
    <block>{
      <decl_stmt><decl><type><specifier>const</specifier> <name>void</name> *</type><name>key</name></decl>;</decl_stmt>
      <decl_stmt><decl><type><name>void</name> *</type><name>val</name></decl>;</decl_stmt>

      <expr_stmt><expr><call><name>apr_hash_this</name><argument_list>(<argument><expr><name>hi</name></expr></argument>, <argument><expr>&amp;<name>key</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr>&amp;<name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>val</name> != <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

      <expr_stmt><expr><call><name>svn_stringbuf_appendcstr</name><argument_list>(<argument><expr>*<name>str</name></expr></argument>, <argument><expr>"\n   "</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>svn_stringbuf_appendcstr</name><argument_list>(<argument><expr>*<name>str</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>svn_stringbuf_appendcstr</name><argument_list>(<argument><expr>*<name>str</name></expr></argument>, <argument><expr>"=\""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>svn_xml_escape_attr_cstring</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
      <expr_stmt><expr><call><name>svn_stringbuf_appendcstr</name><argument_list>(<argument><expr>*<name>str</name></expr></argument>, <argument><expr>"\""</expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></for>

  <if>if <condition>(<expr><name>style</name> == <name>svn_xml_self_closing</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>svn_stringbuf_appendcstr</name><argument_list>(<argument><expr>*<name>str</name></expr></argument>, <argument><expr>"/"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <expr_stmt><expr><call><name>svn_stringbuf_appendcstr</name><argument_list>(<argument><expr>*<name>str</name></expr></argument>, <argument><expr>"&gt;"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>style</name> != <name>svn_xml_protect_pcdata</name></expr>)</condition><then>
    <expr_stmt><expr><call><name>svn_stringbuf_appendcstr</name><argument_list>(<argument><expr>*<name>str</name></expr></argument>, <argument><expr>"\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
}</block></decl></decl_stmt>


<decl_stmt><decl><type><name>void</name></type>
<name>svn_xml_make_open_tag_v</name><argument_list>(<argument><expr><name>svn_stringbuf_t</name> **<name>str</name></expr></argument>,
                        <argument><expr><name>apr_pool_t</name> *<name>pool</name></expr></argument>,
                        <argument>enum <expr><name>svn_xml_open_tag_style</name> <name>style</name></expr></argument>,
                        <argument><expr>const <name>char</name> *<name>tagname</name></expr></argument>,
                        <argument><expr><name>va_list</name> <name>ap</name></expr></argument>)</argument_list>
<block>{
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_hash_t</name> *</type><name>ht</name> <init>= <expr><call><name>svn_xml_ap_to_hash</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>svn_xml_make_open_tag_hash</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>style</name></expr></argument>, <argument><expr><name>tagname</name></expr></argument>, <argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></decl></decl_stmt>



<decl_stmt><decl><type><name>void</name></type>
<name>svn_xml_make_open_tag</name><argument_list>(<argument><expr><name>svn_stringbuf_t</name> **<name>str</name></expr></argument>,
                      <argument><expr><name>apr_pool_t</name> *<name>pool</name></expr></argument>,
                      <argument>enum <expr><name>svn_xml_open_tag_style</name> <name>style</name></expr></argument>,
                      <argument><expr>const <name>char</name> *<name>tagname</name></expr></argument>,
                      <argument>...<expr/></argument>)</argument_list>
<block>{
  <decl_stmt><decl><type><name>va_list</name></type> <name>ap</name></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>tagname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_xml_make_open_tag_v</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>, <argument><expr><name>style</name></expr></argument>, <argument><expr><name>tagname</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></decl></decl_stmt>


<function><type><name>void</name></type> <name>svn_xml_make_close_tag</name><parameter_list>(<param><decl><type><name>svn_stringbuf_t</name> **</type><name>str</name></decl></param>,
                            <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>,
                            <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>tagname</name></decl></param>)</parameter_list>
<block>{
  <if>if <condition>(<expr>*<name>str</name> == <name>NULL</name></expr>)</condition><then>
    <expr_stmt><expr>*<name>str</name> = <call><name>svn_stringbuf_create</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>

  <expr_stmt><expr><call><name>svn_stringbuf_appendcstr</name><argument_list>(<argument><expr>*<name>str</name></expr></argument>, <argument><expr>"&lt;/"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_stringbuf_appendcstr</name><argument_list>(<argument><expr>*<name>str</name></expr></argument>, <argument><expr><name>tagname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_stringbuf_appendcstr</name><argument_list>(<argument><expr>*<name>str</name></expr></argument>, <argument><expr>"&gt;\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
}</block></function>
</unit>
