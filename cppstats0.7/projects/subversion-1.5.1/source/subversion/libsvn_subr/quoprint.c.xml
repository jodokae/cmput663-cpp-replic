<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.sdml.info/srcML/src" xmlns:cpp="http://www.sdml.info/srcML/cpp" language="C" filename="projects/subversion-1.5.1/source/subversion/libsvn_subr/quoprint.c"><comment type="block">/*
 * quoprint.c:  quoted-printable encoding and decoding functions
 *
 * ====================================================================
 * Copyright (c) 2000-2004 CollabNet.  All rights reserved.
 *
 * This software is licensed as described in the file COPYING, which
 * you should have received as part of this distribution.  The terms
 * are also available at http://subversion.tigris.org/license-1.html.
 * If newer versions of this license are posted there, you may use a
 * newer version instead, at your option.
 *
 * This software consists of voluntary contributions made by many
 * individuals.  For exact contribution history, see the revision
 * history and logs, available at http://subversion.tigris.org/.
 * ====================================================================
 */</comment>


<escape char="0xc"/>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_pools.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;apr_general.h&gt;</cpp:file></cpp:include>        <comment type="block">/* for APR_INLINE */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_pools.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_io.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_error.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"svn_quoprint.h"</cpp:file></cpp:include>


<comment type="block">/* Caveats:

	(1) This code is for the encoding and decoding of binary data
	    only.  Thus, CRLF sequences are encoded as =0D=0A, and we
	    don't have to worry about tabs and spaces coming before
	    hard newlines, since there aren't any.

	(2) The decoder does no error reporting, and instead throws
	    away invalid sequences.  It also discards CRLF sequences,
	    since those can only appear in the encoding of text data.

	(3) The decoder does not strip whitespace at the end of a
	    line, so it is not actually compliant with RFC 2045.
	    (Such whitespace should never occur, even in the encoding
	    of text data, but RFC 2045 requires a decoder to detect
	    that a transport agent has added trailing whitespace).

	(4) The encoder is tailored to make output embeddable in XML,
	    which means it quotes &lt;&gt;'"&amp; as well as the characters
	    required by RFC 2045.  */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>QUOPRINT_LINELEN</name></cpp:macro> <cpp:value>76</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>VALID_LITERAL</name><parameter_list>(<param><type><name>c</name></type></param>)</parameter_list></cpp:macro> <cpp:value>((c) == '\t' || ((c) &gt;= ' ' &amp;&amp; (c) &lt;= '~' \
                                          &amp;&amp; (c) != '='))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ENCODE_AS_LITERAL</name><parameter_list>(<param><type><name>c</name></type></param>)</parameter_list></cpp:macro> <cpp:value>(VALID_LITERAL(c) &amp;&amp; (c) != '\t' &amp;&amp; (c) != '&lt;' \
                              &amp;&amp; (c) != '&gt;' &amp;&amp; (c) != '\'' &amp;&amp; (c) != '"' \
                              &amp;&amp; (c) != '&amp;')</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name></type> <name><name>hextab</name><index>[]</index></name> <init>= <expr>"0123456789ABCDEF"</expr></init></decl>;</decl_stmt>


<escape char="0xc"/>
<comment type="block">/* Binary input --&gt; quoted-printable-encoded output */</comment>

<struct>struct <name>encode_baton</name> <block>{
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>output</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>linelen</name></decl>;</decl_stmt>                  <comment type="block">/* Bytes output so far on this line */</comment>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>
}</block>;</struct>


<comment type="block">/* Quoted-printable-encode a byte string which may or may not be the
   totality of the data being encoded.  *LINELEN carries the length of
   the current output line; initialize it to 0.  Output will be
   appended to STR.  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>encode_bytes</name><parameter_list>(<param><decl><type><name>svn_stringbuf_t</name> *</type><name>str</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name></decl></param>, <param><decl><type><name>apr_size_t</name></type> <name>len</name></decl></param>,
             <param><decl><type><name>int</name> *</type><name>linelen</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>3</expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name></decl>;</decl_stmt>

  <comment type="block">/* Keep encoding three-byte groups until we run out.  */</comment>
  <for>for (<init><expr><name>p</name> = <name>data</name></expr>;</init> <condition><expr><name>p</name> &lt; <name>data</name> + <name>len</name></expr>;</condition> <incr><expr><name>p</name>++</expr></incr>)
    <block>{
      <comment type="block">/* Encode this character.  */</comment>
      <if>if <condition>(<expr><call><name>ENCODE_AS_LITERAL</name><argument_list>(<argument><expr>*<name>p</name></expr></argument>)</argument_list></call></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>svn_stringbuf_appendbytes</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr>(*<name>linelen</name>)++</expr>;</expr_stmt>
        }</block></then>
      <else>else
        <block>{
          <expr_stmt><expr><name><name>buf</name><index>[<expr>0</expr>]</index></name> = '='</expr>;</expr_stmt>
          <expr_stmt><expr><name><name>buf</name><index>[<expr>1</expr>]</index></name> = <name><name>hextab</name><index>[<expr>(*<name>p</name> &gt;&gt; 4) &amp; 0xf</expr>]</index></name></expr>;</expr_stmt>
          <expr_stmt><expr><name><name>buf</name><index>[<expr>2</expr>]</index></name> = <name><name>hextab</name><index>[<expr>*<name>p</name> &amp; 0xf</expr>]</index></name></expr>;</expr_stmt>
          <expr_stmt><expr><call><name>svn_stringbuf_appendbytes</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr>3</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr>*<name>linelen</name> += 3</expr>;</expr_stmt>
        }</block></else></if>

      <comment type="block">/* Make sure our output lines don't exceed QUOPRINT_LINELEN.  */</comment>
      <if>if <condition>(<expr>*<name>linelen</name> + 3 &gt; <name>QUOPRINT_LINELEN</name></expr>)</condition><then>
        <block>{
          <expr_stmt><expr><call><name>svn_stringbuf_appendcstr</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr>"=\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr>*<name>linelen</name> = 0</expr>;</expr_stmt>
        }</block></then></if>
    }</block></for>
}</block></function>


<comment type="block">/* Write handler for svn_quoprint_encode.  */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>encode_data</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name></decl></param>, <param><decl><type><name>apr_size_t</name> *</type><name>len</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>encode_baton</name> *</type><name>eb</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name><name>eb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>encoded</name> <init>= <expr><call><name>svn_stringbuf_create</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>enclen</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name> <init>= <expr><name>SVN_NO_ERROR</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Encode this block of data and write it out.  */</comment>
  <expr_stmt><expr><call><name>encode_bytes</name><argument_list>(<argument><expr><name>encoded</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr>*<name>len</name></expr></argument>, <argument><expr>&amp;<name><name>eb</name>-&gt;<name>linelen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>enclen</name> = <name><name>encoded</name>-&gt;<name>len</name></name></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>enclen</name> != 0</expr>)</condition><then>
    <expr_stmt><expr><name>err</name> = <call><name>svn_stream_write</name><argument_list>(<argument><expr><name><name>eb</name>-&gt;<name>output</name></name></expr></argument>, <argument><expr><name><name>encoded</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr>&amp;<name>enclen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>err</name></expr>;</return>
}</block></function>


<comment type="block">/* Close handler for svn_quoprint_encode().  */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>finish_encoding_data</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>encode_baton</name> *</type><name>eb</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name> <init>= <expr><name>SVN_NO_ERROR</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>len</name></decl>;</decl_stmt>

  <comment type="block">/* Terminate the current output line if it's not empty.  */</comment>
  <if>if <condition>(<expr><name><name>eb</name>-&gt;<name>linelen</name></name> &gt; 0</expr>)</condition><then>
    <block>{
      <expr_stmt><expr><name>len</name> = 2</expr>;</expr_stmt>
      <expr_stmt><expr><name>err</name> = <call><name>svn_stream_write</name><argument_list>(<argument><expr><name><name>eb</name>-&gt;<name>output</name></name></expr></argument>, <argument><expr>"=\n"</expr></argument>, <argument><expr>&amp;<name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    }</block></then></if>

  <comment type="block">/* Pass on the close request and clean up the baton.  */</comment>
  <if>if <condition>(<expr><name>err</name> == <name>SVN_NO_ERROR</name></expr>)</condition><then>
    <expr_stmt><expr><name>err</name> = <call><name>svn_stream_close</name><argument_list>(<argument><expr><name><name>eb</name>-&gt;<name>output</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name><name>eb</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>err</name></expr>;</return>
}</block></function>


<function><type><name>svn_stream_t</name> *</type>
<name>svn_quoprint_encode</name><parameter_list>(<param><decl><type><name>svn_stream_t</name> *</type><name>output</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>encode_baton</name> *</type><name>eb</name> <init>= <expr><call><name>apr_palloc</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>eb</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>stream</name></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>eb</name>-&gt;<name>output</name></name> = <name>output</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>eb</name>-&gt;<name>linelen</name></name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>eb</name>-&gt;<name>pool</name></name> = <name>subpool</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>stream</name> = <call><name>svn_stream_create</name><argument_list>(<argument><expr><name>eb</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_stream_set_write</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><name>encode_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_stream_set_close</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><name>finish_encoding_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>stream</name></expr>;</return>
}</block></function>


<function><type><name>svn_stringbuf_t</name> *</type>
<name>svn_quoprint_encode_string</name><parameter_list>(<param><decl><type><name>svn_stringbuf_t</name> *</type><name>str</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>encoded</name> <init>= <expr><call><name>svn_stringbuf_create</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>linelen</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>encode_bytes</name><argument_list>(<argument><expr><name>encoded</name></expr></argument>, <argument><expr><name><name>str</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>str</name>-&gt;<name>len</name></name></expr></argument>, <argument><expr>&amp;<name>linelen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>linelen</name> &gt; 0</expr>)</condition><then>
    <expr_stmt><expr><call><name>svn_stringbuf_appendcstr</name><argument_list>(<argument><expr><name>encoded</name></expr></argument>, <argument><expr>"=\n"</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <return>return <expr><name>encoded</name></expr>;</return>
}</block></function>


<escape char="0xc"/>
<comment type="block">/* Quoted-printable-encoded input --&gt; binary output */</comment>

<struct>struct <name>decode_baton</name> <block>{
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>output</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr>3</expr>]</index></name></decl>;</decl_stmt>                  <comment type="block">/* Bytes waiting to be decoded */</comment>
  <decl_stmt><decl><type><name>int</name></type> <name>buflen</name></decl>;</decl_stmt>                   <comment type="block">/* Number of bytes waiting */</comment>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl>;</decl_stmt>
}</block>;</struct>


<comment type="block">/* Decode a byte string which may or may not be the total amount of
   data being decoded.  INBUF and *INBUFLEN carry the leftover bytes
   from call to call.  Have room for four bytes in INBUF and
   initialize *INBUFLEN to 0 and *DONE to FALSE.  Output will be
   appended to STR.  */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>decode_bytes</name><parameter_list>(<param><decl><type><name>svn_stringbuf_t</name> *</type><name>str</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name></decl></param>, <param><decl><type><name>apr_size_t</name></type> <name>len</name></decl></param>,
             <param><decl><type><name>char</name> *</type><name>inbuf</name></decl></param>, <param><decl><type><name>int</name> *</type><name>inbuflen</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><specifier>const</specifier> <name>char</name> *</type><name>p</name></decl>, *<decl><type ref="prev"/><name>find1</name></decl>, *<decl><type ref="prev"/><name>find2</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name>c</name></decl>;</decl_stmt>

  <for>for (<init><expr><name>p</name> = <name>data</name></expr>;</init> <condition><expr><name>p</name> &lt;= <name>data</name> + <name>len</name></expr>;</condition> <incr><expr><name>p</name>++</expr></incr>)
    <block>{
      <comment type="block">/* Append this byte to the buffer and see what we have.  */</comment>
      <expr_stmt><expr><name><name>inbuf</name><index>[<expr>(*<name>inbuflen</name>)++</expr>]</index></name> = *<name>p</name></expr>;</expr_stmt>
      <if>if <condition>(<expr>*<name>inbuf</name> != '='</expr>)</condition><then>
        <block>{
          <comment type="block">/* Literal character; append it if it's valid as such.  */</comment>
          <if>if <condition>(<expr><call><name>VALID_LITERAL</name><argument_list>(<argument><expr>*<name>inbuf</name></expr></argument>)</argument_list></call></expr>)</condition><then>
            <expr_stmt><expr><call><name>svn_stringbuf_appendbytes</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>inbuf</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
          <expr_stmt><expr>*<name>inbuflen</name> = 0</expr>;</expr_stmt>
        }</block></then>
      <else>else <if>if <condition>(<expr>*<name>inbuf</name> == '=' &amp;&amp; *<name>inbuflen</name> == 2 &amp;&amp; <name><name>inbuf</name><index>[<expr>1</expr>]</index></name> == '\n'</expr>)</condition><then>
        <block>{
          <comment type="block">/* Soft newline; ignore.  */</comment>
          <expr_stmt><expr>*<name>inbuflen</name> = 0</expr>;</expr_stmt>
        }</block></then>
      <else>else <if>if <condition>(<expr>*<name>inbuf</name> == '=' &amp;&amp; *<name>inbuflen</name> == 3</expr>)</condition><then>
        <block>{
          <comment type="block">/* Encoded character; decode it and append.  */</comment>
          <expr_stmt><expr><name>find1</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>hextab</name></expr></argument>, <argument><expr><name><name>inbuf</name><index>[<expr>1</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <expr_stmt><expr><name>find2</name> = <call><name>strchr</name><argument_list>(<argument><expr><name>hextab</name></expr></argument>, <argument><expr><name><name>inbuf</name><index>[<expr>2</expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
          <if>if <condition>(<expr><name>find1</name> != <name>NULL</name> &amp;&amp; <name>find2</name> != <name>NULL</name></expr>)</condition><then>
            <block>{
              <expr_stmt><expr><name>c</name> = ((<name>find1</name> - <name>hextab</name>) &lt;&lt; 4) | (<name>find2</name> - <name>hextab</name>)</expr>;</expr_stmt>
              <expr_stmt><expr><call><name>svn_stringbuf_appendbytes</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr>&amp;<name>c</name></expr></argument>, <argument><expr>1</expr></argument>)</argument_list></call></expr>;</expr_stmt>
            }</block></then></if>
          <expr_stmt><expr>*<name>inbuflen</name> = 0</expr>;</expr_stmt>
        }</block></then></if></else></if></else></if>
    }</block></for>
}</block></function>


<comment type="block">/* Write handler for svn_quoprint_decode.  */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>decode_data</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>, <param><decl><type><specifier>const</specifier> <name>char</name> *</type><name>data</name></decl></param>, <param><decl><type><name>apr_size_t</name> *</type><name>len</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>decode_baton</name> *</type><name>db</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>decoded</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>apr_size_t</name></type> <name>declen</name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name> <init>= <expr><name>SVN_NO_ERROR</name></expr></init></decl>;</decl_stmt>

  <comment type="block">/* Decode this block of data.  */</comment>
  <expr_stmt><expr><name>subpool</name> = <call><name>svn_pool_create</name><argument_list>(<argument><expr><name><name>db</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><name>decoded</name> = <call><name>svn_stringbuf_create</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>decode_bytes</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr>*<name>len</name></expr></argument>, <argument><expr><name><name>db</name>-&gt;<name>buf</name></name></expr></argument>, <argument><expr>&amp;<name><name>db</name>-&gt;<name>buflen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

  <comment type="block">/* Write the output, clean up, go home.  */</comment>
  <expr_stmt><expr><name>declen</name> = <name><name>decoded</name>-&gt;<name>len</name></name></expr>;</expr_stmt>
  <if>if <condition>(<expr><name>declen</name> != 0</expr>)</condition><then>
    <expr_stmt><expr><name>err</name> = <call><name>svn_stream_write</name><argument_list>(<argument><expr><name><name>db</name>-&gt;<name>output</name></name></expr></argument>, <argument><expr><name><name>decoded</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr>&amp;<name>declen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></then></if>
  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>err</name></expr>;</return>
}</block></function>


<comment type="block">/* Close handler for svn_quoprint_decode().  */</comment>
<function><type><specifier>static</specifier> <name>svn_error_t</name> *</type>
<name>finish_decoding_data</name><parameter_list>(<param><decl><type><name>void</name> *</type><name>baton</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type>struct <name>decode_baton</name> *</type><name>db</name> <init>= <expr><name>baton</name></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_error_t</name> *</type><name>err</name></decl>;</decl_stmt>

  <comment type="block">/* Pass on the close request and clean up the baton.  */</comment>
  <expr_stmt><expr><name>err</name> = <call><name>svn_stream_close</name><argument_list>(<argument><expr><name><name>db</name>-&gt;<name>output</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_pool_destroy</name><argument_list>(<argument><expr><name><name>db</name>-&gt;<name>pool</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>err</name></expr>;</return>
}</block></function>


<function><type><name>svn_stream_t</name> *</type>
<name>svn_quoprint_decode</name><parameter_list>(<param><decl><type><name>svn_stream_t</name> *</type><name>output</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>apr_pool_t</name> *</type><name>subpool</name> <init>= <expr><call><name>svn_pool_create</name><argument_list>(<argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type>struct <name>decode_baton</name> *</type><name>db</name> <init>= <expr><call><name>apr_palloc</name><argument_list>(<argument><expr><name>subpool</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>*<name>db</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>svn_stream_t</name> *</type><name>stream</name></decl>;</decl_stmt>

  <expr_stmt><expr><name><name>db</name>-&gt;<name>output</name></name> = <name>output</name></expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name>-&gt;<name>buflen</name></name> = 0</expr>;</expr_stmt>
  <expr_stmt><expr><name><name>db</name>-&gt;<name>pool</name></name> = <name>subpool</name></expr>;</expr_stmt>
  <expr_stmt><expr><name>stream</name> = <call><name>svn_stream_create</name><argument_list>(<argument><expr><name>db</name></expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_stream_set_write</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><name>decode_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <expr_stmt><expr><call><name>svn_stream_set_close</name><argument_list>(<argument><expr><name>stream</name></expr></argument>, <argument><expr><name>finish_decoding_data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>stream</name></expr>;</return>
}</block></function>


<function><type><name>svn_stringbuf_t</name> *</type>
<name>svn_quoprint_decode_string</name><parameter_list>(<param><decl><type><name>svn_stringbuf_t</name> *</type><name>str</name></decl></param>, <param><decl><type><name>apr_pool_t</name> *</type><name>pool</name></decl></param>)</parameter_list>
<block>{
  <decl_stmt><decl><type><name>svn_stringbuf_t</name> *</type><name>decoded</name> <init>= <expr><call><name>svn_stringbuf_create</name><argument_list>(<argument><expr>""</expr></argument>, <argument><expr><name>pool</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>char</name></type> <name><name>ingroup</name><index>[<expr>4</expr>]</index></name></decl>;</decl_stmt>
  <decl_stmt><decl><type><name>int</name></type> <name>ingrouplen</name> <init>= <expr>0</expr></init></decl>;</decl_stmt>

  <expr_stmt><expr><call><name>decode_bytes</name><argument_list>(<argument><expr><name>decoded</name></expr></argument>, <argument><expr><name><name>str</name>-&gt;<name>data</name></name></expr></argument>, <argument><expr><name><name>str</name>-&gt;<name>len</name></name></expr></argument>, <argument><expr><name>ingroup</name></expr></argument>, <argument><expr>&amp;<name>ingrouplen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
  <return>return <expr><name>decoded</name></expr>;</return>
}</block></function>
</unit>
